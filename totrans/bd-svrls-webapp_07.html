<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Managing a Serverless Database</h1>
                </header>
            
            <article>
                
<p>A serverless database is defined like any other serverless service: it needs to have <em>high availability</em>,Â <em>high scalability</em>, and the pricing model must consider its <em>real usage</em>. Satisfying those conditions is particularly hard for databases since <em>performance</em> is a key feature. For a predictable and high performance, databases are usually configured in their own dedicated servers, but serverless requires a shared model to avoid charging the customer for 100% of the time the database is available. In serverless, we want to pay only when a request is done and not when the database is in an idle state.</p>
<p>Currently, only a few services have managed to bring the serverless model to databases. AWS offers just one service: SimpleDB, but it lacks many important features and is extremely limited. For other and better options, you can try FaunaDB, Google Firebase, or Google Cloud Datastore. To continue to use AWS services in this book, we are going to cover DynamoDB, which is an almost serverless database.</p>
<p>Furthermore, we'll see how to use Amazon S3 to store media files since, in most cases, it's better to save files in a cheap storage system than a database server.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using and managing SimpleDB and DynamoDB databases</li>
<li>Using Amazon S3 to store media files</li>
</ul>
<p>When you finish this chapter, you'll have implemented the data access layer of the online store and acquired the necessary knowledge to use serverless databases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Amazon SimpleDB</h1>
                </header>
            
            <article>
                
<p>SimpleDB is an old service (late 2007), and it is the only one offered by AWS that can really be called a serverless database. AWS offers many other managed databases, such as DynamoDB or RDS, but all of them require that you set provisions and pay for 24 hours a day, even when no one is using your system. You <em>do</em> need to worry about the servers when you need to constantly check whether the capacity is well designed for your traffic.</p>
<p>SimpleDB is serverless for the following reasons:</p>
<ul>
<li><strong>Totally managed by AWS</strong>: You don't need to spin-up a machine and install/configure a DBMS.</li>
<li><strong>Highly available</strong>: AWS <span>manages multiple geographically distributed replicas of your database to enable</span> high availability and data durability.</li>
<li><strong>Scalable</strong>: You can grow in size very fast without worrying about provisioning.</li>
<li><strong>Cost-efficient</strong>: You pay for the amount of data stored, data transferred, and the CPU time used to run queries. If no one is using the database, you pay only for what is currently stored.</li>
</ul>
<p><span>SimpleDB is a NoSQL database, but unfortunately, it is very limited due to the absence of important functionalities. For example, the only data type that you can use is a string. This makes it harder for you to implement a lot of use cases, but we will cover some hacks here to make it feasible. If your application is somewhat complex, I would avoid using SimpleDB. Use it only for small applications.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the database</h1>
                </header>
            
            <article>
                
<p>First, a little bit of nomenclature: a <em>domain</em>, in SimpleDB, is the equivalent of a <em>table</em> in the relational world and an <em>item</em> is the equivalent of a <em>row</em>. They are pretty equivalent, but you need to know what they mean to understand SDK functions. Also, in SimpleDB, each <em>item</em> has a list of attribute-value pairs, where the <em>attribute</em> is like a <em>column</em> and the values are always of the string data type.</p>
<p>For a practical example, we will model the database for the serverless store. We are going to use just two domains such as <kbd>Products</kbd> and <kbd>ShoppingCart</kbd>. We will not create a domain to save user account data (e-mail, password, and others) because we are going to use Amazon Cognito in the next chapter and Cognito is responsible for saving and managing user data.</p>
<p>The following table lists the attributes for the <kbd>Products</kbd> domain. All of them will be created to hold strings due to a SimpleDB restriction, but I've added what would be the ideal data type. And, in the next sections, we will see how to handle this limitation:</p>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Desired data type</strong></td>
</tr>
<tr>
<td><kbd>ID</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Name</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Price</kbd></td>
<td>Decimal</td>
</tr>
<tr>
<td><kbd>Image</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Comments</kbd></td>
<td>Array of documents</td>
</tr>
</tbody>
</table>
<p>Some observations about this model are as follows:</p>
<ul>
<li class="mce-root"><kbd>ID</kbd>: The <kbd>ID</kbd> attribute could be defined as an integer, but I've defined it as a string since we are using the ID in the URL. Instead of showing the URL as <kbd>store.com/product/123</kbd>, we are using <kbd>store.com/product/lonely-bird</kbd>.</li>
<li class="mce-root"><kbd>Price</kbd>: The <kbd>Price</kbd> attribute will be saved as a string, although we wanted to save it as a number.</li>
<li><kbd>Image</kbd>: The <kbd>Image</kbd> attribute will be saved as a string because we will save the URL of a S3 object instead of saving the entire object in the database.</li>
<li><kbd>Comments</kbd>: The <kbd>Comments</kbd> attribute needs a relation of <strong>one-to-many</strong>, where <em>one</em> product has <em>many</em> comments. Some NoSQL databases, such as MongoDB, have an "array of documents" data type, which would be helpful here.</li>
</ul>
<p>The <kbd>Comments</kbd> field will be a list of:</p>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Desired data type</strong></td>
</tr>
<tr>
<td><kbd>ID</kbd></td>
<td>Integer</td>
</tr>
<tr>
<td><kbd>Username</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Date</kbd></td>
<td>DateTime</td>
</tr>
<tr>
<td><kbd>Text</kbd></td>
<td>String</td>
</tr>
</tbody>
</table>
<p>This model requires other observations:</p>
<ul>
<li>The <kbd>ID</kbd> attribute could be defined as an integer where the <kbd>ID</kbd> of every new comment would be the value of the last saved comment <kbd>ID</kbd> plus one unit. However, SimpleDB doesn't offer any feature for auto-incrementing a field. To avoid needing to query the last comment <kbd>ID</kbd> before saving a new comment, and the conflicts it would cause due to the lack of transactions, we can use this attribute to save an <strong>Universally Unique Identifier</strong> (<strong>UUID</strong>) as a string value.</li>
<li>The <kbd>Date</kbd> attribute will be discussed later.</li>
</ul>
<p>The following table lists the attributes for the <kbd>ShoppingCart</kbd> domain:</p>
<table class="CDPAlignCenter CDPAlign" style="width: 400px;height: 188px">
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Desired data type</strong></td>
</tr>
<tr>
<td><kbd>UserID</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>LastUpdate</kbd></td>
<td>DateTime</td>
</tr>
<tr>
<td><kbd>SelectedProducts</kbd></td>
<td>Array of documents</td>
</tr>
</tbody>
</table>
<p>As we are going to use Amazon Cognito, the <kbd>UserID</kbd> was defined as a string. The only problem with this model is that we want a field to store a datetime and another to store an array of data, where <kbd>SelectedProducts</kbd> are defined by a list of <kbd>ProductID</kbd> and <kbd>Quantity</kbd> pairs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling one-to-many relations</h1>
                </header>
            
            <article>
                
<p>In the previous models, we saw that <em>one</em> product has <em>many</em> comments and <em>one</em> cart has <em>many</em> selected products. In a relational database, we would model another table to list all comments or selected products and we would use the <kbd>join</kbd> operator to retrieve all related data when querying for a specific product or cart. However, in NoSQL, we usually don't have a <kbd>join</kbd> operator so we need to make two separated queries to retrieve what we need <em>or</em> we can save all related data in just one field as an array of documents.</p>
<p>In SimpleDB, we don't have an "array of documents" data type, but we have two other options:</p>
<ul>
<li><span>Save a stringified array of JSON objects</span></li>
<li>Multi-valued attributes</li>
</ul>
<p>The first option is a hacky solution where you can stringify an array of JavaScript objects and save it in a single attribute. The problem is that you won't be able to query attributes in this field, so forget queries such as "How many distinct users have ordered ProductID lonely-bird?".</p>
<p>The second option is the best solution since SimpleDB allows you to have multiple attributes with the same name. Take a look at the following dataset for the <kbd>ShoppingCart</kbd> that uses multi-valued attributes:</p>
<table class="CDPAlignCenter CDPAlign">
<tbody>
<tr>
<td><strong>UserID</strong></td>
<td><strong>LastUpdate</strong></td>
<td><strong>ProductID</strong></td>
<td><strong>QuantityX</strong></td>
<td><strong>ProductID</strong></td>
<td><strong>QuantityY</strong></td>
<td><strong>ProductID</strong></td>
<td><strong>QuantityZ</strong></td>
</tr>
<tr>
<td><kbd><span><span>A</span></span></kbd></td>
<td><kbd>&lt;Date&gt;</kbd></td>
<td><kbd>X</kbd></td>
<td><kbd>2</kbd></td>
<td><kbd>Y</kbd></td>
<td><kbd><span><span>2</span></span></kbd></td>
<td><kbd>Z</kbd></td>
<td><kbd>4</kbd></td>
</tr>
<tr>
<td><kbd>B</kbd></td>
<td><kbd><span>&lt;Date&gt;</span></kbd></td>
<td><kbd>X</kbd></td>
<td><kbd>3</kbd></td>
<td><span>​</span></td>
<td><span>​</span></td>
<td><span>​</span></td>
<td><span>​</span></td>
</tr>
<tr>
<td><kbd>C</kbd></td>
<td><kbd><span>&lt;Date&gt;</span></kbd></td>
<td><kbd>X</kbd></td>
<td><kbd>1</kbd></td>
<td><kbd>Y</kbd></td>
<td><kbd><span><span>5</span></span></kbd></td>
<td><span>​</span></td>
<td><span>​</span></td>
</tr>
</tbody>
</table>
<p>The <kbd>ProductID</kbd> attribute repeats with the same name multiple times and this is not an issue because SimpleDB allows two attributes with the same name. What SimpleDB does not allow is two attributes with the same name <em>and</em> value. In the first item (<kbd>UserID</kbd> with value <kbd>A</kbd>), we have a <kbd>ProductID</kbd> with value <kbd>X</kbd> and a <kbd>ProductID</kbd> with value <kbd>Y</kbd>, which is valid. The problem would be with the <kbd>Quantity</kbd> attributes, since two of them have value <kbd>2</kbd> in the same item. To fix this problem, the <kbd>ProductID</kbd> value was appended to the attribute name, creating the attributes <kbd>QuantityX</kbd> and <kbd>QuantityY</kbd>.</p>
<div class="packt_infobox">The SimpleDB domain is schemaless, which means that, when you insert a new item, you say what attributes it has and it won't return an error if you add an attribute name that doesn't exist yet.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling numbers</h1>
                </header>
            
            <article>
                
<p>The biggest issue with SimpleDB is not about how to store data as a string but how to retrieve it using queries. You can save the number <kbd>27</kbd> as <kbd>"27"</kbd>, but filtering a query with <kbd>Quantity &gt; "5"</kbd> would not return the desired value.</p>
<p>A solution to handle numerical data as a string is to modify it before saving. Instead of saving <kbd>"27"</kbd>, use a zero-padding function and store it as <kbd>"000027"</kbd>. Now query it with <kbd>Quantity &gt; "000005"</kbd> and you will get the value that you want.</p>
<p>How many zeros do you need to add? It depends. Think about the largest number that your dataset can reach and zero-pad all the other numbers to have the same number of characters.</p>
<p>This trick works for integers. If you have a decimal, as in the <kbd>Price</kbd> attribute, you need to multiply it by the number of decimal places. In this case, multiply it per 100 before saving the value and divide it by 100 when you retrieve it.</p>
<p>Another issue is handling negative numbers. In this case, you need to add an offset. This offset must be greater than the largest negative number of your entire dataset. For example, if your offset is <kbd>100,000</kbd>, the value <kbd>-27</kbd> must be added to <kbd>100,000</kbd> (resulting in <kbd>99973</kbd>) and zero-padded with six places, resulting in <kbd>"099973"</kbd>. If you need to compare whether the number is greater than <kbd>5</kbd>, you will need to add the offset and zero-pad the comparison value, resulting in <kbd>Quantity &gt; "100005"</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling Booleans</h1>
                </header>
            
            <article>
                
<p>You can store Boolean values as either <kbd>true</kbd>/<kbd>false</kbd> or <kbd>1</kbd>/<kbd>0</kbd>. You can select what you prefer, just define a convention and use the same strategy in all Boolean attributes.</p>
<p>Here's an example of this:</p>
<pre>
    const boolean = true; <br/><br/>    // save 'true' in the database<br/>    const booleanStr = boolean.toString(); <br/><br/>    // convert 'true' (string) to true (boolean)<br/>    const booleanAgain = Boolean(booleanStr); 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling dates</h1>
                </header>
            
            <article>
                
<p>When saving a datetime variable, you can use the ISO 8601 standard format, for example, <kbd>5:15:10 PM December 24th 2016 UTC</kbd> becomes <kbd>2016-12-24T17:15:10.000Z</kbd>. This format is queryable using strings. So <kbd>Date &gt; "2016-12-24T00:00:00.000Z"</kbd> will return the value of the previous example.</p>
<p>Now consider that you have a <kbd>LastAccess</kbd> attribute and you want to query all the users that accessed your system in the last 5 minutes. In this case, you just need to find the current time, subtract it by 5 minutes, and convert it into the ISO string before querying.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a domain</h1>
                </header>
            
            <article>
                
<p>Creating a domain is pretty straightforward. You just need to set the domain name as the parameter and it will be created with the <kbd>createDomain</kbd> function.</p>
<p>Here's an example of this:</p>
<pre>
    const AWS = require('aws-sdk');<br/>    const simpledb = new AWS.SimpleDB();<br/><span class="keyword"><br/>    const</span><span> params = { <br/></span><span>      DomainName: </span><span class="string">'Products'<br/></span><span>    }; <br/></span><span><br/>    simpledb.createDomain(params, </span><span>(err, data) =&gt; </span><span>{ <br/></span><span class="keyword">      if</span><span> (err) console.log(err, err.stack); <br/></span><span class="keyword">      else</span><span> console.log(data);<br/></span><span>    });</span>
</pre>
<p>Regarding the attributes, you don't need to specify them while creating the domain. There is no schema attached. Each item has its own list of attributes that are not necessarily the same as the other attributes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limits</h1>
                </header>
            
            <article>
                
<p>SimpleDB was designed for small workloads, so AWS has enforced some limits that may restrict your application. In the following table, I've listed the most important limits that you should be aware of before using SimpleDB in your system. You can find more about this in the official documentation at <a href="http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html">http://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/SDBLimits.html</a>:</p>
<table style="width: 615px;height: 307px">
<tbody>
<tr>
<td><strong>Parameter</strong></td>
<td><strong>Restriction</strong></td>
</tr>
<tr>
<td>Domain size</td>
<td>10 GB per domain</td>
</tr>
<tr>
<td>Domain size</td>
<td>1 billion attributes per domain</td>
</tr>
<tr>
<td>Attribute value length</td>
<td>1,024 bytes</td>
</tr>
<tr>
<td>Maximum items in the <kbd>Select</kbd> response</td>
<td>2,500</td>
</tr>
<tr>
<td>Maximum query execution time</td>
<td>5 seconds</td>
</tr>
<tr>
<td>Maximum response size of <kbd>Select</kbd></td>
<td>1 MB</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting and querying data</h1>
                </header>
            
            <article>
                
<p>The following example shows how to insert data into a SimpleDB domain. I'm using <kbd>batchPutAttributes</kbd> because it allows multiple inserts simultaneously, but you could call <kbd>putAttributes</kbd> to insert a single item:</p>
<pre>
    const AWS = require('aws-sdk'); <br/>    const simpledb = new AWS.SimpleDB();<br/><span class="keyword"><br/>    const</span><span> insertParams = { <br/></span><span>      DomainName: </span><span class="string">'Products',<br/>      Items: [<br/>        {<br/>          Attributes: [<br/>            {<br/>              Name: 'Name',<br/>              Value: 'Lonely Bird'<br/>            },<br/>            {<br/>              Name: 'Price',<br/>              Value: '2999'<br/>            },<br/>            // more attributes<br/>          ],<br/>          // needs to be unique<br/>          Name: 'lonely-bird'<br/>        },<br/>        // more items<br/>      ]<br/></span><span>    }; </span><span><br/><br/></span><span><strong>    simpledb.batchPutAttributes</strong>(insertParams, </span><span>(err, data) =&gt; </span><span>{ <br/></span><span class="keyword">      if</span><span> (err) console.log(err, err.stack); <br/></span><span class="keyword">      else</span><span> console.log(data);<br/></span><span>    });</span>
</pre>
<p>The following example shows how to query the data that was previously inserted. Despite being a NoSQL database, SimpleDB uses a SQL-like syntax for queries:</p>
<pre>
    const AWS = require('aws-sdk');<br/>    const simpledb = new AWS.SimpleDB(); <br/> <br/>    const selectParams = {<br/>      SelectExpression:<strong><br/>        'select * from Products where Name = "Lonely Bird"'</strong><br/>    };<br/><br/>    <strong>simpledb.select</strong>(selectParams, (err, data) =&gt; { <br/><span class="keyword">      if</span> (err) console.log(err, err.stack); <br/><span class="keyword">      else if (data.Items)</span> {<br/>        data.Items.map(item =&gt; {<br/>          item.Attributes.map(attr =&gt; {<br/>            console.log(attr);<br/>          });<br/>        });<br/>      }<br/>      else console.log('No results');<br/>    });
</pre>
<p>The preceding code will generate the following output:</p>
<pre>
    { Name: 'Name', Value: 'Lonely Bird' }<br/>    { Name: 'Price', Value: '2999' }
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance and concurrency</h1>
                </header>
            
            <article>
                
<p>AWS will automatically create an index for every attribute that you create, but querying data filtering by dates or integers converted into strings can easily lead to performance issues. You should always be careful of your performance requirements and the size of your domain.</p>
<p>Also, like most NoSQL databases, SimpleDB doesn't support transactions, so concurrency can be a real problem for data consistency. Instead of transactions, SimpleDB offers <em>conditional operations</em>. For example, if you need to insert some data, you can place a condition that will execute the operation only if the attribute does not exist yet. Another use case is to implement a counter. You will update the value of the counter to <kbd>X+1</kbd> only if the current value is <kbd>X</kbd>. If this condition is not met, it's because another user have already incremented the value and your update will be canceled.</p>
<p>Here's an example of a conditional operation:</p>
<pre>
    const AWS = require('aws-sdk');<br/>    const simpledb = new AWS.SimpleDB(); <br/><br/>    const params = {<br/>      Attributes: [<br/>        {<br/>          Name: 'Counter',<br/> <span>         </span>Value: '10', // new value<br/> <span>         </span>Replace: true<br/>        }<br/>      ],<br/>      DomainName: 'MyCounter',<br/>      ItemName: '123', // identifier<br/>      Expected: {<br/>        Exists: true,<br/><span>        </span>Name: 'Counter',<br/><span>        </span>Value: '9' // previous value<br/>      }<br/>    };<br/><br/>    <strong>simpledb.putAttributes</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err, err.stack);<br/>      else console.log(data);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the database</h1>
                </header>
            
            <article>
                
<p>You can manage your database using the AWS CLI or SDK, but many people prefer to use a tool that provides a user interface. Since AWS doesn't offer a console for SimpleDB, we need to rely on third-party tools. In this case, I can recommend the Chrome extension SdbNavigator. It's a very simple tool but offers a nice user interface with the essential features such as creating domains, inserting items, and making queries.</p>
<p>Take a look at the following steps for managing the database:</p>
<ol>
<li>Using Chrome, you can add the extension from <a href="https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg">https://chrome.google.com/webstore/detail/sdbnavigator/ddhigekdfabonefhiildaiccafacphgg.</a></li>
<li>After installing it, add your AWS keys and select a region to connect. You can add a new domain with the <span class="packt_screen">Add domain</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="320" src="assets/bda2ffed-14d2-403c-925c-94f68405f81f.png" width="671"/></div>
<ol start="3">
<li>This tool has a button to add properties. When you add a new item, these properties will become the items' attributes:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/c5896d86-4b53-405c-a5da-b876bd6d70f6.png"/></div>
<ol start="4">
<li>The <span class="packt_screen">Add record</span> button is used to add your domain items:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/48964ae1-80fc-4fd0-b062-58fdde867303.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backing up and restoring data</h1>
                </header>
            
            <article>
                
<p>Unfortunately, there is no native AWS feature to consistently back up and restore SimpleDB domains. The solution is to make queries that will read all of the data (backup) and scripts to insert (restore) this saved data when needed. However, the main issue is consistency. If your application is running while you are copying the data, there is no guarantee that your backup would be consistent. The application may have started a delete operation and your backup may still have some part of the items that should have been deleted.</p>
<p>Besides this consistency problem, you still have issues with copying/inserting data since AWS places many limits on this operation. For example, the maximum number of items in <kbd>select</kbd> is 2,500 items. To solve this second problem, you can try one of the many third-party tools available to mitigate this burden.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling user access</h1>
                </header>
            
            <article>
                
<p>SimpleDB relies on the AWS security model. So if you want to manage access, you will need to create IAM users and roles. The granularity of this control lies in the domains your users can access and the actions they can execute.</p>
<p>In our Lambda functions, we <em>must</em> give permissions <em>explicitly</em>. You can't execute a SimpleDB request without setting the restrictions. This configuration is done in the <kbd>serverless.yml</kbd> file under the <kbd>iamRoleStatements</kbd> function. In the following example, I'm giving read (<kbd>sdb:Select</kbd>) and write (<kbd>sdb:PutAttributes</kbd>) access to the <kbd>Products</kbd> and <kbd>ShoppingCart</kbd> domains. If you want to allow full access, use the <kbd>"sdb:*"</kbd> action and set the domain with <kbd>domain/*</kbd>:</p>
<pre>
    service: simpledb-example<br/><br/>    provider:<br/>      name: aws<br/>      runtime: nodejs6.10<br/><strong>      iamRoleStatements:</strong><br/><strong>        - Effect: "Allow"</strong><br/><strong>          Action:</strong><br/><strong>            - "sdb:BatchPutAttributes" </strong><br/><strong>            - "sdb:PutAttributes"</strong><br/><strong>            - "sdb:Select"</strong><br/><strong>          Resource: [</strong><br/><strong>            "arn:aws:sdb:us-east-1:*:domain/Products",</strong><br/><strong>            "arn:aws:sdb:us-east-1:*:domain/ShoppingCart"</strong><br/><strong>          ]</strong><br/><br/>    functions:<br/>      query:<br/>        handler: handler.query
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DynamoDB</h1>
                </header>
            
            <article>
                
<p>DynamoDB is a fully managed, NoSQL database with high availability and that can be configured to scale automatically. The only reason that it can't be considered as a serverless database is due to its pricing model. You must pay for provisioned resources even if no one is using your application.</p>
<p>However, DynamoDB is a great database, with many useful features, and AWS offers a generous permanent free tier. It is being extensively used in many serverless projects because it is cheap, easy to use and offers predictable performance. In this book, we are going to use DynamoDB as our main database. If you browse this chapters' code files, you will see the data layer of the serverless store implemented with SimpleDB and DynamoDB, but DynamoDB will be the default and the database where we will discuss here what features needs to be implemented for the serverless store.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the database</h1>
                </header>
            
            <article>
                
<p>In DynamoDB, a <em>table</em> is a collection of <em>items</em> and each item is a collection of key-value pairs called <em>attributes</em>. Like most NoSQL databases, DynamoDB is <em>schemaless</em>. You just need to define the primary key and you can add items with different attributes.</p>
<p>DynamoDB supports the following data types:</p>
<ul>
<li><strong>Scalar</strong>: Category of data types that store a single value:
<ul>
<li><kbd>String</kbd>: UTF-8 strings with a maximum size of 400 KB.</li>
<li><kbd>Number</kbd>: It stores a maximum of 38 digits and accepts negative numbers as well.</li>
<li><kbd>Boolean</kbd>: It stores true or false.</li>
<li><kbd>Binary</kbd>: It allows binary data to be saved. Due to maximum size of 400 KB, it may not be a good choice for many applications. We are going to use S3 to store product images and a <kbd>String</kbd> field in DynamoDB to save the S3 URL.</li>
<li><kbd>Null</kbd>: It represents an attribute with an unknown or undefined state.</li>
</ul>
</li>
<li><strong>Document</strong>: It is a category of data types that store multiple values:
<ul>
<li><kbd>List</kbd>: It stores an <em>ordered</em> collection of values. It's similar to an array where you can store elements of any type. Example: <kbd>[5, "foo", 2, -4, "bar"]</kbd>.</li>
<li><kbd>Map</kbd>: It stores an <em>unordered</em> collection of values. It's similar to JSON object. Example: <kbd>{ "Name": "foo", "Address": 123 }</kbd>.</li>
</ul>
</li>
<li><strong>Set</strong>: It's a data type where you store data as an array, but all elements must be unique and of the same data type. Also, the order is not preserved. Example: a set of numbers could be <kbd>[1, 7, 2, -4]</kbd>.</li>
</ul>
<p>For the serverless store, we need to create two tables such as <kbd>Products</kbd> and <kbd>ShoppingCart</kbd>. They will be defined as the following:</p>
<ul>
<li><kbd>Products</kbd>: Take a look at the following table depicting its attributes:</li>
</ul>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Data Type</strong></td>
</tr>
<tr>
<td><kbd>ID</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Name</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Price</kbd></td>
<td>Number</td>
</tr>
<tr>
<td><kbd>Image</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>Comments</kbd></td>
<td>List of Maps</td>
</tr>
</tbody>
</table>
<ul>
<li><kbd>Comments</kbd>: Take a look at the following table depicting its attributes:</li>
</ul>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Data Type</strong></td>
</tr>
<tr>
<td><kbd>ID</kbd></td>
<td><kbd>String</kbd></td>
</tr>
<tr>
<td><kbd>Username</kbd></td>
<td><kbd>String</kbd></td>
</tr>
<tr>
<td><kbd>Date</kbd></td>
<td><kbd>String</kbd></td>
</tr>
<tr>
<td><kbd>Text</kbd></td>
<td><kbd>String</kbd></td>
</tr>
</tbody>
</table>
<ul>
<li><kbd>ShoppingCart</kbd>: Take a look at the following table depicting its attributes:</li>
</ul>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Data Type</strong></td>
</tr>
<tr>
<td><kbd>UserID</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>LastUpdate</kbd></td>
<td>String</td>
</tr>
<tr>
<td><kbd>SelectedProducts</kbd></td>
<td>List of Maps</td>
</tr>
</tbody>
</table>
<ul>
<li><kbd>SelectedProducts</kbd>: Take a look at the following table depicting its attributes:</li>
</ul>
<table>
<tbody>
<tr>
<td><strong>Attribute</strong></td>
<td><strong>Data Type</strong></td>
</tr>
<tr>
<td><kbd>ProductID</kbd></td>
<td><kbd>String</kbd></td>
</tr>
<tr>
<td><kbd>Quantity</kbd></td>
<td><kbd>Number</kbd></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Some observations about this model are as follows:</p>
<ul>
<li>The <kbd>Comments</kbd> and <kbd>SelectedProducts</kbd> attributes were defined as a list of map objects, which means that we will save an ordered list of JSON objects</li>
<li>Just like SimpleDB, there is no auto-increment field for DynamoDB, so we will use UUIDs for the Comment IDs</li>
<li>DynamoDB doesn't support a datetime data type, so we will need to define the <kbd>Date</kbd> and <kbd>LastUpdate</kbd> attributes as a string that uses the ISO format</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a table</h1>
                </header>
            
            <article>
                
<p>We are going to create the tables for the serverless store using the AWS SDK. As DynamoDB is a schemaless database, we just need to set the primary key and the attributes will be defined when the items are inserted.</p>
<p>Use the following example to create them:</p>
<pre class="mce-root">
    const AWS = require('aws-sdk');<br/>    const dynamodb = new AWS.DynamoDB();<br/><br/>    let params = {<br/>      TableName: 'Products',<br/>      AttributeDefinitions: [<br/>        {<br/>          AttributeName: 'ID',<br/>          AttributeType: 'S' // string<br/>        }<br/>      ],<br/>      KeySchema: [<br/>        {<br/>          AttributeName: 'ID',<br/>          KeyType: 'HASH'<br/>        }   <br/>      ],<br/>      ProvisionedThroughput: {<br/>        ReadCapacityUnits: 5, // default value<br/>        WriteCapacityUnits: 5 // default value<br/>      } <br/>    };<br/><br/><strong>    dynamodb.createTable</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err, err.stack);<br/>      else console.log(data);<br/>    });
</pre>
<p>You can use the same code to create the <kbd>ShoppingCart</kbd> table. Just change the table name to <kbd>ShoppingCart</kbd> and the primary key name to <kbd>UserID</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limits</h1>
                </header>
            
            <article>
                
<p>DynamoDB imposes some limits that you need to consider before building your application. They are listed as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Parameter</strong></td>
<td><strong>Restriction</strong></td>
</tr>
<tr>
<td>Number of tables</td>
<td>256 per account</td>
</tr>
<tr>
<td>Table size</td>
<td>There is no limit in the number of items</td>
</tr>
<tr>
<td>Provisioned throughput</td>
<td>Up to 40,000 read and 40,000 write capacity units</td>
</tr>
<tr>
<td>Item size</td>
<td>The sum of the size of all attributes of one item must not exceed 400 KB</td>
</tr>
<tr>
<td>Secondary indexes</td>
<td>5 local and 5 global secondary indexes per table</td>
</tr>
<tr>
<td><kbd>API BatchGetItem()</kbd></td>
<td>Maximum of 100 items or 16 MB retrieved</td>
</tr>
<tr>
<td><kbd>API BatchWriteItem()</kbd></td>
<td>Maximum of 25 put or delete requests or 16 MB sent</td>
</tr>
<tr>
<td>API Query or Scan</td>
<td>The result set is limited to 1 MB</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting and querying data</h1>
                </header>
            
            <article>
                
<p>We are going to this discuss in this section how to insert and query data with DynamoDB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inserting data</h1>
                </header>
            
            <article>
                
<p>DynamoDB offers two ways to insert data such as <kbd>putItem()</kbd> and <kbd>batchWriteItem()</kbd>. The difference between them is that <kbd>putItem</kbd> allows you to create one new item or update an existing item, while <kbd>batchWriteItem</kbd> allows you to create or delete multiples items, but doesn't support the update operation.</p>
<p>The following is an example of the <kbd>putItem</kbd> method:</p>
<pre class="mce-root">
    const AWS = require('aws-sdk');<br/>    const dynamodb = new AWS.DynamoDB();    <br/><br/>    const params = {<br/>      TableName: "Products",<br/>      Item: {<br/>        ID: { S: "lonely-bird" },<br/>        Name: { S: "Lonely Bird" },<br/>        Price: { N: "29.99" },<br/>        Image: { S: "https://s3.amazonaws.com/..." },<br/>        Comments: { <br/>          L: [<br/>            { <br/>              M: { <br/>                ID: { S: "ABC"}, <br/>                Username: { S: "John Doe"},<br/>                Date: { S: "2016-12-24T17:15:10.000Z" },<br/>                Text: { S: "I liked it." }<br/>              }<br/>            },<br/>            {<br/>              M: { <br/>                ID: { S: "XYZ"}, <br/>                Username: { S: "Jane Smith"},<br/>                Date: { S: "2016-12-24T18:15:10.000Z" },<br/>                Text: { S: "I liked it too." }<br/>              }<br/>            } <br/>          ] <br/>        }<br/>      }<br/>    };<br/><br/><strong>    dynamodb.putItem</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err, err.stack);<br/>      else console.log(data);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Document Client API</h1>
                </header>
            
            <article>
                
<p>As you can see, the previous example shows how to insert a single item, but the syntax is very complicated. To define a string attribute, we need to create a JSON object where the key is <kbd>"S"</kbd> (string) and the value is the desired data.</p>
<p>To make this task easier, we can use the Dynamo's Document Client API to abstract the attribute values by using native JavaScript types for read and write operations.</p>
<p>The following example shows how to insert the same item using this API. Note that we need to retrieve the client using <kbd>new AWS.DynamoDB.DocumentClient()</kbd> and the command is <kbd>put</kbd> instead of <kbd>putItem</kbd>:</p>
<pre class="mce-root">
    const AWS = require('aws-sdk');<br/><strong>    const documentClient = new AWS.DynamoDB.DocumentClient();</strong><br/><br/>    const params = {<br/>      TableName: "Products",<br/>      Item: {<br/>        ID: "lonely-bird",<br/>        Name: "Lonely Bird",<br/>        Price: 29.99,<br/>        Image: "https://s3.amazonaws.com/...",<br/>        Comments: [<br/>          { <br/>            ID: "ABC", <br/>            Username: "John Doe",<br/>            Date: "2016-12-24T17:15:10.000Z",<br/>            Text: "I liked it."<br/>          },<br/>          {<br/>            ID: "XYZ", <br/>            Username: "Jane Smith",<br/>            Date: "2016-12-24T18:15:10.000Z",<br/>            Text: "I liked it too."<br/>          } <br/>        ] <br/>      }<br/>    };<br/><br/><strong>    documentClient.put</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err, err.stack);<br/>      else console.log(data);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Querying data</h1>
                </header>
            
            <article>
                
<p>To query the item that we have just inserted, DynamoDB offers two methods such as <kbd>scan()</kbd> and <kbd>query()</kbd>. We will see how they work in the next sections. For both of them, we are going to use the Document Client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scan method</h1>
                </header>
            
            <article>
                
<p>The <kbd>scan</kbd> method is used to retrieve all items of a table without needing to filter by a key. Filtering is possible, but is optional. The problem with this method is that, for a large table, you need to make multiple requests because it will interrupt the operation when it scans more than 1 MB of data. When the scan operation is interrupted, the result set will contain a <kbd>LastEvaluatedKey</kbd> parameter that can be used for further requests:</p>
<pre class="mce-root">
    const AWS = require('aws-sdk');<br/><strong>    const documentClient = new AWS.DynamoDB.DocumentClient();</strong><br/><br/>    const params = {<br/>      TableName: 'Products'<br/>    };<br/><br/><strong>    documentClient.scan</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err, err.stack);<br/>      else console.log(data);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The query method</h1>
                </header>
            
            <article>
                
<p>The <kbd>query</kbd> method finds items based on the hash key. It is similar to the <kbd>scan</kbd> method since a query will be interrupted if it reads more than 1 MB of data, returning a <kbd>LastEvaluatedKey</kbd> parameter, but the main difference between <kbd>query</kbd> and <kbd>scan</kbd> is that <kbd>query</kbd> will consider the filter conditions before reading the data and <kbd>scan</kbd> will apply the filters after the table is read.</p>
<p>The following is an example to query only the <kbd>Lonely Bird</kbd> product:</p>
<pre class="mce-root">
    const AWS = require('aws-sdk');<br/><strong>    const documentClient = new AWS.DynamoDB.DocumentClient();</strong><br/><br/>    const params = {<br/>      TableName: "Products",<br/>      KeyConditionExpression: "ID = :id",<br/>      ExpressionAttributeValues: { ":id": "lonely-bird" }<br/>    };<br/><br/><strong>    documentClient.query</strong>(params, (err, data) =&gt; {<br/>      if (err) console.log(err);<br/>      else console.log(data);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Performance and concurrency</h1>
                </header>
            
            <article>
                
<p>Like most NoSQL databases, there is no support for transactions in DynamoDB. Atomic operations can only be done on the item level, which means that you can atomically change two attributes of a single item, but you can't update two distinct items in a single operation. Like SimpleDB, DynamoDB supports conditional updates to implement counters.</p>
<p>Regarding performance, <span>DynamoDB creates indexes for the hash key and one optional range key, but if</span> <span>you need to query data filtering by other fields, you need to create additional indexes. For example, if you want to find all products that cost more than US$ 10, you need to create an index for the <kbd>Price</kbd> attribute.</span> <span>That's something that we don't need in our serverless store model, since we will query only by the hash keys for both tables, but we will describe here how to add extra indexes.</span></p>
<p>First, you need to understand that DynamoDB has the following two types of index:</p>
<ul>
<li><strong>Local secondary index</strong>: An index that has the same partition key as the base table</li>
<li><strong>Global secondary index</strong>: An index that is not restricted to the same partition of the base table</li>
</ul>
<p>One difference between them is that local indexes uses the same provisioned throughput of the hash key and global indexes requires that you pay for an extra provisioned throughput for them. The benefit of global indexes is that you don't need to include a filter by the hash key, and you can filter directly by the key that you have specified. In the previous example, if you want to query all products with a price above US$ 10, you need to create a global index for the <kbd>Price</kbd> attribute.</p>
<p>Now suppose that you have a table for <kbd>Orders</kbd> that saves the <kbd>OrderID</kbd>, <kbd>ProductID</kbd>, <kbd>Price</kbd>, and other information. The <kbd>OrderID</kbd> would be the hash key and, for a single order, we would have many items. For example, take a look at the following table:</p>
<table>
<tbody>
<tr>
<td><strong>OrderID</strong></td>
<td><strong>ProductID</strong></td>
<td><strong>Price</strong></td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td><kbd>77</kbd></td>
<td><kbd>15.99</kbd></td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td><kbd>88</kbd></td>
<td><kbd>18.99</kbd></td>
</tr>
<tr>
<td><kbd>1</kbd></td>
<td><kbd>23</kbd></td>
<td><kbd>12.99</kbd></td>
</tr>
<tr>
<td><kbd>2</kbd></td>
<td><kbd>18</kbd></td>
<td><kbd>15.00</kbd></td>
</tr>
</tbody>
</table>
<p>In this model, if you want to query by the <kbd>OrderID</kbd> with number <kbd>1</kbd> and filter by <kbd>Price</kbd> greater than 15, you would create a <em>local</em> secondary index for the <kbd>Price</kbd> attribute and not a <em>global</em> index.</p>
<p>The following example shows the syntax to create local and global indexes:</p>
<pre>
    const params = {<br/>      TableName: 'TableWithIndexes',<br/>      AttributeDefinitions: [<br/>        { AttributeName: 'ID', AttributeType: 'S' },<br/>        { AttributeName: 'MyOtherAttribute', AttributeType: 'S' },<br/>        { AttributeName: 'MyLocalAttribute', AttributeType: 'S' },<br/>        { AttributeName: 'MyGlobalAttribute', AttributeType: 'S' }<br/>      ],<br/>      KeySchema: [<br/>        { AttributeName: 'ID', KeyType: 'HASH' },<br/>        { AttributeName: 'MyOtherAttribute', KeyType: 'RANGE' }<br/>      ],<br/>      ProvisionedThroughput: <br/>        { ReadCapacityUnits: 5, WriteCapacityUnits: 5 },<br/>      LocalSecondaryIndexes: [<br/>        { <br/>          IndexName: 'MyLocalIndex',<br/>          KeySchema: [<br/>            { AttributeName: 'ID', KeyType: 'HASH' }, <br/>            { AttributeName: 'MyLocalAttribute', KeyType: 'RANGE' }<br/>          ],<br/>          Projection: { ProjectionType: 'ALL' }<br/>        }<br/>      ],<br/>      GlobalSecondaryIndexes: [<br/>        { <br/>          IndexName: 'MyGlobalIndex',<br/>          KeySchema: [<br/>            { AttributeName: 'MyGlobalAttribute', KeyType: 'HASH' }<br/>          ],<br/>          Projection: { ProjectionType: 'ALL' },<br/>          ProvisionedThroughput: <br/>            { ReadCapacityUnits: 5, WriteCapacityUnits: 5 }<br/>        }<br/>      ]<br/>    };
</pre>
<div class="packt_infobox">You can use <kbd>DynamoDB.updateTable()</kbd> to add <em>global secondary indexes</em> after a table is created, but you can only add <em>local secondary indexes</em> during the creation of a table. It is not possible to update a table to add local indexes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the database</h1>
                </header>
            
            <article>
                
<p>AWS has a management console for DynamoDB where you can configure the capacity of your tables, create indexes, and view CloudWatch metrics. In the following steps, I will show how you can see and manipulate your table's data:</p>
<ol>
<li>Browse the Management Console at this link <a href="https://console.aws.amazon.com/dynamodb">https://console.aws.amazon.com/dynamodb.</a></li>
<li>In the left menu, click on <span class="packt_screen">Tables</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="355" src="assets/30e54ee9-aef7-421c-a927-6b924c224750.png" width="493"/></div>
<ol start="3">
<li>Now click on your table <span class="packt_screen">Name</span> and in the <span class="packt_screen">Items</span> tab. In this tab, you can create, delete, or update items. A scan query will be executed automatically, but you can change the query parameters if you want to see other items. Click on the item <span class="packt_screen">ID</span> to open the edit modal:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="328" src="assets/428ee72d-dc8c-4168-a6a7-86d078aba4c6.png" width="826"/></div>
<ol start="4">
<li>The <span class="packt_screen">Edit item</span> modal allows you to see all properties of an item and update the attributes if required:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="298" src="assets/0efb45d7-7fc1-44e5-8a3d-4a2d4f78b6a4.png" width="511"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Provisioned throughput</h1>
                </header>
            
            <article>
                
<p>DynamoDB performance is based on provisioned throughput for read and write operations. One <em>read capacity unit</em> represents one strongly consistent read per second or two eventually consistent reads per second for objects with up to 4 KB in size, while one <em>write capacity unit</em> means that you can write one 1 KB object per second. You need to define those values when you create your table, but you can update them if you want later. In this chapter's example, the table was created with five read units and five write units for each key.</p>
<p>If your system requests more read/write operations than expected by your provisioned capacity, AWS will allow the operations to be executed without errors for a short period of time. If you continue to exceed the provisioned capacity, some requests will fail with the <kbd>ProvisionedThroughputExceededException</kbd> error. The good news is that the AWS SDK has built-in support for retrying throttled requests, so we don't need to write the logic for this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auto scaling</h1>
                </header>
            
            <article>
                
<p>You can configure CloudWatch to send e-mail alerts when your DynamoDB usage is higher than your provisioned throughput and manually update the capacity when necessary <em>or</em> you can configure auto scaling. As we want to avoid worrying about servers and scalability, we will configure auto scaling to handle this burden for us.</p>
<p>Auto scaling will actively manage the throughput capacity to scale up and down to match your application utilization when your workload increases or decreases. What we need to configure is a range (upper and lower limits) for read and write capacity units and a target utilization percentage within this range. You can access the auto scaling configuration through the Management Console. Click in the table where you want to enable this setting and select the <span class="packt_screen">Capacity</span> tab.</p>
<p>The following screenshot shows an example of auto scaling configuration:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="319" src="assets/7542bd2b-e390-47ba-9539-e96290b0a088.png" width="515"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backing up and restoring data</h1>
                </header>
            
            <article>
                
<p>Unfortunately, DynamoDB doesn't provide a simple feature for backup and restore. What AWS proposes is to use other two services for this task such as <strong>AWS Data Pipeline</strong> and <strong>Amazon Elastic MapReduce</strong> (<strong>EMR</strong>). Due to the complexity and length of this configuration, it won't be covered in this book. You can follow the AWS tutorial to implement a task for this:</p>
<p><a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb.html">http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb.html</a></p>
<p>In short, what you need is to use a AWS Data Pipeline template for DynamoDB and schedule a task that will start an EMR with Hive to save/restore a DynamoDB table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling user access</h1>
                </header>
            
            <article>
                
<p>Just like SimpleDB, we manage DynamoDB user access through IAM roles. We must give permissions <em>explicitly</em> to the Lambda functions to be able to execute the requests. This configuration is done in the <kbd>serverless.yml</kbd> file under the <kbd>iamRoleStatements</kbd> function:</p>
<pre>
    service: dynamodb-example<br/><br/>    provider:<br/>      name: aws<br/>      runtime: nodejs6.10<br/><strong>       iamRoleStatements:</strong><br/><strong>        - Effect: "Allow"</strong><br/><strong>          Action:</strong><br/><strong>            - "dynamodb:Scan" <br/>            - "dynamodb:Query"<br/>            - "dynamodb:PutItem"</strong><br/><strong>            - "dynamodb:DeleteItem"</strong><br/><strong>            - "dynamodb:BatchWriteItem"</strong><br/><strong>          Resource: [</strong><br/><strong>            "arn:aws:dynamodb:us-east-1:*:table/Products",</strong><br/><strong>            "arn:aws:dynamodb:us-east-1:*:table/ShoppingCart"</strong><br/><strong>          ]</strong><br/><br/>    functions:<br/>       query:<br/>         handler: handler.query
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the serverless store</h1>
                </header>
            
            <article>
                
<p>In this book's GitHub repository, you will find a <kbd>scripts</kbd> folder that you can use to create the tables for DynamoDB and SimpleDB, along with sample data to be used in our tests. Also, in the root directory, you will find a <kbd>backend</kbd> folder that contains a <kbd>repositories</kbd> folder with the <kbd>dynamodb.js</kbd>, <kbd>simpledb.js</kbd>, and <kbd>fakedb.js</kbd> files. The sample application uses <kbd>fakedb</kbd> as the default database, because it doesn't require any configuration since it provides only hardcoded data.</p>
<p>We are going to implement the DynamoDB code now. In the <kbd>lib</kbd> folder, we are going to change the dependencies from <kbd>const db = require('../repositories/fakedb')</kbd> to <kbd>const db = require('../repositories/dynamodb')</kbd> and in the <kbd>dynamodb.js</kbd> file, we need to develop four methods such as <kbd>retrieveAllProducts</kbd>, <kbd>retrieveCart</kbd>, <kbd>saveCart</kbd>, and <kbd>processCheckout</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving all products</h1>
                </header>
            
            <article>
                
<p>Retrieving all products is a simple function that will execute a <kbd>scan</kbd> operation. As we have just a few items, we don't need to worry about the 1 MB limit in this case:</p>
<pre class="mce-root">
    module.exports.<strong>retrieveAllProducts</strong> = (callback) =&gt; {<br/> <br/>      const params = {<br/>        TableName: 'Products'<br/>      };<br/><br/><strong>      documentClient.scan</strong>(params, callback);<br/>    };
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Retrieving the user's shopping cart</h1>
                </header>
            
            <article>
                
<p>Retrieving the user's cart uses a simple query where we will filter by <kbd>UserID</kbd>:</p>
<pre class="mce-root">
    module.exports.<strong>retrieveCart</strong> = (userId, callback) =&gt; {<br/><br/>      const params = {<br/>        TableName: "ShoppingCart",<br/>        KeyConditionExpression: "UserID = :userId",<br/>        ExpressionAttributeValues: { ":userId": userId }<br/>      };<br/><br/><strong>      documentClient.query</strong>(params, callback);<br/>    });
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving the user's shopping cart</h1>
                </header>
            
            <article>
                
<p>The <kbd>saveCart</kbd> function receives the <kbd>userId</kbd> and <kbd>selectedProducts</kbd> as arguments, where the <kbd>selectedProducts</kbd> is a pair of <kbd>ProductId-Quantity</kbd> elements:</p>
<pre class="mce-root">
    module.exports.<strong>saveCart</strong> = (userId, selectedProducts, callback) =&gt; {<br/><br/>      const params = {<br/>        TableName: "ShoppingCart",<br/>        Item: {<br/>          UserID: userId,<br/>          LastUpdate: new Date().toISOString(),<br/>          SelectedProducts: selectedProducts<br/>        }<br/>      };<br/><br/><strong>      documentClient.put</strong>(params, callback);<br/>    };
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing the checkout</h1>
                </header>
            
            <article>
                
<p>Handling payment data is a complex process and is out of scope for this book. In this case, we are going to implement a function that will just execute the callback passing <kbd>null</kbd> as the error parameter:</p>
<pre>
    module.exports.<strong>processCheckout</strong> = (callback) =&gt; {<br/>      // do nothing<br/>      callback(null);<br/>    };
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Amazon S3 (for media files)</h1>
                </header>
            
            <article>
                
<p>S3 is not a database, it is only a storage system. It lacks a database engine and many storage features, but it can be pretty useful for saving media files such as photos, videos, and music.</p>
<p>This approach is already very popular. For example, if you develop an application that uses a MongoDB database, you could use MongoDB GridFS to store large binary data. However, the most efficient solution is to offload this kind of data to cloud services because the machines responsible for your database are usually the most expensive ones. It means that the cost per gigabyte in a database is usually higher than a cloud storage service, such as S3.</p>
<p>In our serverless store, we are storing the product images in SimpleDB/DynamoDB as string fields. Instead of saving the full binary data, we save just the URL of the image file. Example:</p>
<p><a href="https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg">https://s3.amazonaws.com/serverless-store-media/product-images/lonely-bird.jpg</a></p>
<p>When we receive this information in the frontend, the <kbd>&lt;img&gt;</kbd> element has the <kbd>src</kbd> attribute referencing this S3 URL:</p>
<pre>
    &lt;img src={this.props.product.imageURL} alt="product" /&gt;
</pre>
<p>Instead of downloading the image from the database, the user will download the image from S3, thus relieving the database.</p>
<p>This is one use case for S3. There are two other common usages:</p>
<ul>
<li><strong>The user needs to upload his avatar image</strong>: Instead of saving in the database, we can generate a temporary permission for the user to upload the file directly to S3</li>
<li><strong>The user wants to see his private album</strong>: Instead of requesting a Lambda function to download the files from S3, we can generate private temporary links from where he will be able to download the files</li>
</ul>
<p>We will discuss in this section how to handle these examples and how to use S3 as a database for media files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading and downloading files</h1>
                </header>
            
            <article>
                
<p>If your bucket stores public files, you can configure it to allow anonymous requests to upload and download files. However, if the files are private, you need to give pre-signed URLs to the client to ensure privacy and security. Both the actions, namely upload and download, must be signed.</p>
<p>These keys are generated at the backend because you need to use the SDK with credential access to the bucket. Let's take a look at the following steps to upload and download files:</p>
<ol>
<li>Create a Lambda function and expose an endpoint to allow it to be called by the frontend code. Use the <kbd>getSignedUrl</kbd> function of the S3 object to obtain the signed URL:</li>
</ol>
<pre>
        const AWS = require('aws-sdk');<br/>        const s3 = new AWS.S3();<br/><br/>        const params = {<br/>          Bucket: 'bucket', <br/>          Key: 'key'<br/>        };<br/> <br/>        const operation = 'putObject'; // upload operation<br/>        // const operation = 'getObject'; // download operation<br/><br/>        s3.getSignedUrl(operation, params, (err, url) =&gt; {<br/>          // return the url<br/>        });
</pre>
<ol start="2">
<li>If the operation is to download a private file, render the HTML with an anchor tag that uses this pre-signed URL in the <kbd>href</kbd> attribute and set the attribute <kbd>target</kbd> to <kbd>_blank</kbd> in order to carry out the download:</li>
</ol>
<pre>
        &lt;a href="PRE-SIGNED-URL" target="_blank"&gt;Download&lt;/a&gt;
</pre>
<ol start="3">
<li>If the operation is to upload a file, add an <kbd>input</kbd> element to receive the file<span>:</span></li>
</ol>
<pre>
        &lt;input type="file" /&gt;
</pre>
<ol start="4">
<li>And upload the file with an Ajax request using the pre-signed URL:</li>
</ol>
<pre>
        $.ajax({<br/>          url: preSignedUrl, // use the signed URL in the request<br/>          type: 'POST',<br/>          data: file,<br/>          // ...<br/>          success: () =&gt; { console.log('Uploaded') },<br/>          error: err =&gt; { console.log(err) }<br/>        });
</pre>
<ol start="5">
<li>As you have generated the pre-signed URL using a Lambda function, you will know the filename and where the file will be stored, however, you won't know exactly when the file upload will finish if it is really started by the user. One option that you have is to add another Lambda function to receive the object created event, which will be triggered by the S3 bucket.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling CORS</h1>
                </header>
            
            <article>
                
<p>The previous code will only work if we enable CORS for the S3 bucket. CORS headers are necessary because we are going to make upload and download requests from a domain that is different from the S3 domain. This setting can be configured using <span>the S3 Console:</span> <a href="https://console.aws.amazon.com/s3">https://console.aws.amazon.com/s3</a><span>. Open your bucket properties and select <span class="packt_screen">Permissions</span>, followed by <span class="packt_screen">CORS Configuration,</span></span> as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f26675ef-04cd-40e2-a7ad-49c7c50e4e52.png"/></div>
<p>This command will add a CORS configuration for GET requests. Before saving, we need to add one line to include authorization for POST requests and change the Allowed Header to * (all):</p>
<pre>
    &lt;CORSConfiguration&gt;<br/>      &lt;CORSRule&gt;<br/>        &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;<br/>        &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;<br/><strong>        &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt;</strong><br/>        &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;<br/><strong>        &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt;</strong><br/>      &lt;/CORSRule&gt;<br/>    &lt;/CORSConfiguration&gt;
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Backing up and restoring data</h1>
                </header>
            
            <article>
                
<p>Amazon S3 was designed to provide up to 99.999999999% of durability, which means that AWS makes a huge effort to replicate your data and keep it safe from disk failures. Although you can rest assured that your data is safe on S3, you must consider that it is not so safe against your own mistakes. For example, if you have a feature that deletes specific files from S3, you can make a mistake and delete a wrong file or, even worse, delete all of them. So, making backups is important to ensure a safer operation for your business.</p>
<p>You can back up files locally (downloading) or make copies in other external services (such as Azure or Google Cloud), but it is usually not necessary. You can save all files of a bucket in another bucket using a command of the AWS CLI:</p>
<pre>
<strong>    aws s3 sync s3://original-bucket s3://backup-bucket</strong>
</pre>
<p>If you want to restore all files that were saved at specific time to the backup bucket, you would need to add a <kbd>--delete</kbd> option to remove files in the target bucket that do not exist in the backup bucket:</p>
<pre>
<strong>    aws s3 sync s3://backup-bucket s3://bucket-to-be-restored --delete</strong>
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using S3 versioning</h1>
                </header>
            
            <article>
                
<p>S3 versioning is another way to protect your data. Once enabled, every time you modify an object, a new one will be saved, and when you delete an object, S3 will just place a delete mark on it. Versioning allows you to recover files that were accidentally deleted, but you will pay more to keep those files available.</p>
<p>To configure S3 versioning, go to the Management Console and select the bucket <span class="packt_screen">Properties</span>. You will see an option to enable versioning:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="294" src="assets/8adc7511-86cd-4aaf-aaa2-670c32822493.png" width="384"/></div>
<p>You can reduce costs by configuring life cycle rules to delete old versioned files. This setting can be found under the <span class="packt_screen">Management</span> tab:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="156" src="assets/44059071-563b-4c41-8bc5-53c959992829.png" width="427"/></div>
<p>To finish this section, an observation about security: if your AWS access keys get compromised, a malicious user could delete the files in the S3 bucket and also remove versioned files. To prevent this, you can add an extra layer of protection by enabling <span class="packt_screen">MFA Delete</span>. With this setting, you can only permanently delete a file if you have access to the AWS account <em>and</em> if you are able to provide an access code from an authentication device.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to model, query, and insert data using serverless databases. We saw how SimpleDB works, but due to its lack of features, we also covered how to use DynamoDB. Plus, you learned more about Amazon S3 and how to use it to store media files.</p>
<p>In the next chapter, we are going to learn how to use authentication and authorization on AWS and also check out standard security practices to build a serverless project.</p>


            </article>

            
        </section>
    </body></html>