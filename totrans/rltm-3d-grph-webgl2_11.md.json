["```js\n// Create a VAO instance\nvar vertexArray = gl.createVertexArray();\n\n// Bind the VAO\ngl.bindVertexArray(vertexArray);\n\n// Set vertex array states\n\n// Set with GLSL layout qualifier\nconst vertexPositionLocation = 0;\n// Enable the attribute\ngl.enableVertexAttribArray(vertexPositionLocation);\n// Bind Buffer \ngl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);\n// ...\n// Configure instructions for VAO\ngl.vertexAttribPointer(vertexPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n// Clean\ngl.bindVertexArray(null);\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n// ...\n\n// Render\ngl.bindVertexArray(vertexArray);\ngl.drawArrays(gl.TRIANGLES, 0, 6);\n```", "```js\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 2);\n```", "```js\nvec2 size = textureSize(sampler, lod);\n```", "```js\nvec4 values = texelFetch(sampler, ivec2Position, lod);\n```", "```js\nconst samplerA = gl.createSampler();\ngl.samplerParameteri(samplerA, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);\ngl.samplerParameteri(samplerA, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.samplerParameteri(samplerA, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\ngl.samplerParameteri(samplerA, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\nconst samplerB = gl.createSampler();\ngl.samplerParameteri(samplerB, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\ngl.samplerParameteri(samplerB, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\ngl.samplerParameteri(samplerB, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\ngl.samplerParameteri(samplerB, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n\n// ...\n\ngl.activeTexture(gl.TEXTURE0);\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.bindSampler(0, samplerA);\n\ngl.activeTexture(gl.TEXTURE1);\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.bindSampler(1, samplerB);\n```", "```js\ngl.beginQuery(gl.ANY_SAMPLES_PASSED, query);\ngl.drawArraysInstanced(gl.TRIANGLES, 0, 3, 2);\ngl.endQuery(gl.ANY_SAMPLES_PASSED);\n\n//...\n\n(function tick() {\n  if (!gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {\n    // A query's result is never available in the same frame\n    // the query was issued.  Try in the next frame.\n    requestAnimationFrame(tick);\n    return;\n  }\n\n  var samplesPassed = gl.getQueryParameter(query, gl.QUERY_RESULT);\n  gl.deleteQuery(query);\n})();\n```", "```js\ngl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_LOD, 0.0);\ngl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAX_LOD, 10.0);\n```", "```js\nconst names = ['WebGL', 'experimental-WebGL', 'webkit-3d', 'moz-WebGL'];\n\nfor (let i = 0; i < names.length; ++i) {\n  try {\n    const context = canvas.getContext(names[i]);\n    // work with context\n  } catch (e) {\n    console.log('Error attaining WebGL context', e);\n  }\n}\n```", "```js\nconst context = canvas.getContext('WebGL 2');\n\n```", "```js\nattribute vec3 aVertexNormal;\nattribute vec4 aVertexPosition;\n```", "```js\nin vec3 aVertexNormal;\nin vec4 aVertexPosition;\n```", "```js\n// inside of the vertex shader\nvarying vec2 vTexcoord;\nvarying vec3 vNormal;\n\n// inside of the fragment shader\nvarying vec2 vTexcoord;\nvarying vec3 vNormal;\n```", "```js\n// inside of the vertex shader\nout vec2 vTexcoord;\nout vec3 vNormal;\n\n// inside of the fragment shader\nin vec2 vTexcoord;\nin vec3 vNormal;\n```", "```js\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.2, 0.3, 1.0);\n}\n```", "```js\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vec4(1.0, 0.2, 0.3, 1.0);\n}\n```", "```js\nuniform sampler2D uSome2DTexture;\nuniform samplerCube uSomeCubeTexture;\n\nvoid main(void) {\n  vec4 color1 = texture2D(uSome2DTexture, ...);\n  vec4 color2 = textureCube(uSomeCubeTexture, ...);\n}\n```", "```js\nuniform sampler2D uSome2DTexture;\nuniform samplerCube uSomeCubeTexture;\n\nvoid main(void) {\n  vec4 color1 = texture(uSome2DTexture, ...);\n  vec4 color2 = texture(uSomeCubeTexture, ...);\n}\n```"]