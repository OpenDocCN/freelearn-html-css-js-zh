- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Framework Organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The existing JavaScript frameworks have many technical and structural similarities
    that are useful to learn as part of becoming experts in framework development.
    In this chapter, framework organization refers to the way of composing a set of
    abstractions and building blocks, thus creating a collection of usable interfaces
    that can be utilized in application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to learn about the following organizational topics that enable
    framework development and use:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks of abstractions in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating modules, libraries, and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the core building blocks and aspects of framework development
    will help us craft our own framework and have the domain knowledge to use other
    frameworks to their maximum potential. The expectations from the users or stakeholders
    of a software framework are to have clear instructions with familiar application
    concepts, reduced complexity, and a well-defined code base. Let us explore how
    framework organization can help us satisfy those expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous chapter, we will be using the book’s repository as an
    extension to this chapter. You can find it at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    For the code from the repository, you can use any environment that supports a
    terminal and runs Node.js, such as Windows, macOS, and most varieties of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes examples from open source frameworks – to save space,
    the unimportant details are omitted with the `// ...` comment. You will need familiarity
    with reading JavaScript code, but don’t worry if you don’t understand the whole
    code block. As part of reading the code, be sure to follow the links next to those
    examples to see the full implementation with all the code details. The `chapter2/README.md`
    file lists the available code resources of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, it is suggested to try out debugging to further our expertise
    in framework structures. The easiest way to explore that on your computer would
    be by downloading the latest version of Visual Studio Code from [code.visualstudio.com](http://code.visualstudio.com).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive into the first aspect of framework organization – the fundamental
    concept of **abstractions**. One of the main conveniences of software development
    frameworks in web development or other fields is to provide developers with high-quality
    opinionated abstractions. This means taking a task that can span multiple lines
    of code, riddled with implementation gotchas, and creating a simple interface
    around it. It also means coming up with an intelligent way of structuring independent
    interfaces into a familiar, extensible pattern that is easily usable.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of abstracting away the complexity and generalization of objects
    helps us define the building blocks that could be used for multiple purposes in
    our frameworks. Each abstracted object can be initialized with a custom set of
    properties and be utilized in many shapes when needed. Having this benefit of
    simplification and generalization in frameworks is what allows developers to focus
    on the business logic of the programs. Precisely these abstraction concepts benefit
    developers by eliminating complexity, repetition, and the challenges of learning
    new systems. Through abstractions, developers do not have to use or even learn
    the low-level components of the systems they build for.
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions in computer science
  prefs: []
  type: TYPE_NORMAL
- en: In general, the concept of abstractions, a simplified representation of some
    complex mechanism, is essential in software development. This concept is taught
    early in programming courses and can be implemented in the high-level and low-level
    interfaces of large and small programs. Software abstractions structure many parts
    of these programs and dictate the program’s control flow. Data types and structures
    that define how the data is represented can be considered abstractions on top
    of lower-level object entities.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages offer direct syntax to write abstract classes and
    interfaces. TypeScript offers this feature as part of its extensions to JavaScript.
    This allows developers to declare *abstract* classes, methods, and fields. You
    can find some excellent examples at [www.typescriptlang.org/docs/handbook/2/classes.html](http://www.typescriptlang.org/docs/handbook/2/classes.html)
    for further reading and prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the process of developing websites with bare CSS, HTML, and JavaScript
    technologies, we can already spot many pre-defined abstractions to make that process
    more easily accessible and simplified. For instance, HTML, with its elements combined
    with attributes, can quickly define hyperlinks and embed media with just a few
    lines of marked-up tags. The styling of those elements with CSS is defined by
    a set of styling rules targeting particular element nodes. We can see examples
    of web API abstractions in the **Document Object Model API**, an abstraction on
    top of a complex tree of nested nodes defining a document structure. These frontend
    technologies provide a way for user interactions inside a web browser, which generalizes
    and removes the complexity of interacting with a web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see a simplified pyramid of abstractions here, starting from application
    code that developers write on top and rules of basic logic at the lowest level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Abstraction pyramid from higher- to lower-level structures](img/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Abstraction pyramid from higher- to lower-level structures'
  prefs: []
  type: TYPE_NORMAL
- en: This finally brings us to JavaScript, as a high-level programming language that
    already abstracts away complexity in many ways, such as memory management, interaction
    with the browser, and general object management. In fact, some abstractions that
    compile to JavaScript focus on abstracting away even the higher-level components.
    Toolkits such as GWT and programming languages such as Elm, C#, and Dart approach
    this higher-level abstraction process by compiling to CSS, HTML, and JavaScript.
    The language extensions for ECMAScript, such as TypeScript, hold closer to JavaScript
    in terms of syntax, abstract away the common pitfalls in how we write JavaScript
    programs, and improve the overall developer experience with the addition of a
    compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we looked at several frameworks
    that use TypeScript, rely on another framework, or both to create a framework
    of a higher abstraction level. For example, Nuxt.js is a Vue.js framework, and
    it relies on TypeScript. In such cases, frameworks require developers to use these
    language extensions and their own self-defined abstractions to build the applications.
    It is interesting to ponder how deep the levels of abstractions could be nested
    when we are developing for the web platform and within the JavaScript ecosystem.
    On the frontend, we have the web browser, which manages the network request/response
    networking, draws the layout, enables interactivity, and so much more. The backend
    application services are working on top of the process and operating system infrastructure
    within the cloud server instances. The levels of abstraction keep growing as we
    zoom out to electricity flowing through wires, which delivers the required bits
    for our application code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with abstractions and why they are used, we shall
    examine the downsides of this core pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Downsides of abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have examined the benefits of abstractions, but there are some downsides
    to consider when utilizing or implementing abstractions. These factors are also
    true for frameworks and heavily affect framework development. Let’s discuss some
    of the ways abstractions can lead you down the wrong path:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions may be incomplete – covering all the potential use cases of an
    underlying technology with an abstraction could be difficult. For instance, if
    you have a web application framework, this could usually be a case where a niche
    feature to output HTML in a certain way could not be supported. The niche requirements
    could include rendering different types of components, such as SVG animations
    or direct DOM manipulations. Frameworks offer escape hatches to avoid these issues,
    but there could be other cases where we have to rely on the knowledge of lower-level
    components, avoiding the defined abstractions. At the same time, an abstraction
    may falsely represent the low-level system, which could lead to confusion or false
    use of the underlying concepts. For instance, if a cryptographic library wrongly
    uses the primitives, even with the correct outcomes, it could potentially introduce
    bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions introduce an extra layer of code between you and the lower-level
    system, possibly affecting performance. In the case of frontend development, this
    means more code to transfer over the wire – additional function calls and layers
    of indirection. In the backend scenarios, server instances use more process memory.
    The performance may also be affected by the framework’s choice of algorithms.
    These days, performance is taken seriously by framework authors and users, and
    regular comparisons and benchmarks help deal with these drawbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the different framework abstractions may not provide the right interfaces
    or enough control for the users, which could limit the system’s potential. It
    could be as simple as not supporting all the underlying methods of the lower-level
    interface. This issue can also happen if a chosen abstraction is used for something
    other than what it was designed for. This can also be a problem if the framework
    was designed before a certain technology was introduced. For instance, with **WebAssembly**
    support in certain frameworks, loading the WASM modules is not possible in some
    cases due to loading limitations or has to be done with external components. Introducing
    and using WebAssembly in an already established project with a lacking framework
    would be an anti-pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, patterns and abstraction ideas change quickly in the JavaScript
    ecosystem. New tools and solutions come into existence that abstract how we manage
    frontend interactions and build backend services. This means, as project owners,
    we have to adjust either to the changing platform or our existing abstractions
    become outdated. This could lead to a lack of support for some functionalities
    or just general code breakage. In many circumstances, this happens when some web
    APIs change or evolve as the web platform introduces new features.
  prefs: []
  type: TYPE_NORMAL
- en: Another downside of abstractions is the scenario where a developer may know
    how to create applications with a certain framework but knows nothing about the
    internals of the underlying technology. The hidden-away complexity can lead to
    difficulty in troubleshooting problems and in tracking down errors in the core
    of the application. Not understanding the technology behind the scenes also limits
    the developer in their ability to optimize features and take advantage of advanced
    features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may also face so-called *leaky abstractions*. This is where the attempt to
    conceal some system complexity fully is not successful. This usually results in
    the details of the underlying system being revealed to the users of the abstraction.
    This phenomenon can lead to more complexity in the code with its own problems.
    The problem becomes evident when developers have to dig into the implementation
    details of the low-level system and try their best to figure out how the abstraction
    maps to the underlying system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly opinionated abstractions, in frameworks and in general, may cause issues
    when introducing additional layers of sophistication by imposing specific design
    choices that the developer may disagree with but is unable to change. These can
    limit the reusability and flexibility of the application code. If we look at Next.js,
    it provides highly opinionated solutions for several of its features. For example,
    if you are planning to add API routes to build an API in the Next.js project,
    these must be mapped to an `/api/` endpoint. To learn more about that, check out
    [nextjs.org/docs/api-routes/introduction](http://nextjs.org/docs/api-routes/introduction).
    This is a simple example, but hopefully it illustrates this drawback well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter where you introduce the use of an abstraction, it does add an extra
    layer of complexity and indirectness to what we are trying to interface with.
    When we add abstractions through various means, this makes our projects dependent
    on them. This dependency may create certain complications. With an external abstraction,
    we have to accept the risks and trade-offs that come with using it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look at the popular abstracted building
    blocks, which are often used in framework development and are exposed as public
    interfaces of frameworks. We will dive into the frontend browser APIs and the
    backend runtime modules to better understand what frameworks utilize to build
    their own abstractions. This is a useful exercise because it helps us figure out
    how these frameworks function and what techniques they use to combine different
    tools together. These exercises in tracing the framework organization are valuable
    to becoming a domain expert in frameworks and understanding the underlying technology
    behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of abstractions in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some detailed abstraction examples in JavaScript,
    as well as web APIs, and features that are used as the building blocks and foundational
    components of abstractions in frameworks. Framework and browser developers put
    a lot of thought and hard work into defining these abstractions, which allow developers
    to be really crafty, produce well-organized code, and build great products.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend framework abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With these three technologies – HTML, CSS, and JavaScript – that enable website
    development, we get plenty of building blocks that already abstract away the challenges
    of publishing something on the web. However, we do not get a particular, well-structured,
    opinionated way to build complex web application projects. This is where the frontend
    frameworks primarily fill the void that is lacking in the core technologies provided
    by the web. The frontend frameworks create abstractions in these two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: On top of existing web APIs, which are built into the web browser or a JavaScript
    runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When new abstractions are built from scratch based on the framework’s internals
    and opinionated definitions. The innovative and unique approach to these abstractions
    is what makes a particular framework desirable and liked among developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following web APIs provided by the browser engines are often abstracted
    by frontend frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document Object Model** (**DOM**) – This allows manipulation of the web page’s
    structure. The DOM represents a tree where the nodes constrain the objects. The
    DOM API provides access and the ability to modify this logical tree. The user
    interface frameworks primarily need this to display the rendered views and handle
    DOM interactions and events. Even the frameworks that use a virtual DOM need to
    attach their structures to the real document to make it visible on the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document` property. The browser also provides complex APIs, such as the WebAssembly
    API, which lets applications include binary-code modules. The frameworks usually
    have a loader for these low-level modules as part of their loader workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document.body.style.color = ''pink'';`. This object model also offers several
    method calls such as `getComputedStyle();` to fetch information about the object’s
    style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network APIs** – These APIs have the ability to make asynchronous network
    requests using the Fetch API or the XMLHttpRequest API. Frameworks utilize these
    for basic networking operations, including structuring complex requests using
    GraphQL. The networking APIs also offer **WebSocket** functionality. These APIs
    provide full-duplex (data can be transmitted and received simultaneously) communications
    with less overhead than usual networking calls, enabling applications with real-time
    updates and communication. The WebSocket API is simple enough that it can be used
    directly in the applications or with the inclusion of an extension package for
    a particular framework. **Socket.io** builds on top of WebSocket APIs and offers
    a complete low-latency solution that can coexist with the framework code. Finally,
    **WebRTC** also fits into the category of networking APIs, and it enables the
    capturing and streaming of audio and video content in the browser. Similar to
    WebSockets, the WebRTC framework integration is usually included with an external
    library because it is quite a subtle feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage APIs** – These APIs have the ability to store data for web application
    and caching purposes. These APIs are often utilized to store data in the local
    and session storages. They also write to browser cookies and databases, such as
    **IndexedDB**. For instance, Angular applications can include a dependency that
    provides a cookie service and makes it easier to read and write cookie information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background services** – These include a slew of services that enable background
    synchronization of data, notifications, push messaging, and more. Web workers
    generally provide a way to run background-independent scripts and make use of
    multiple CPU cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics APIs** – These APIs grant the ability to render high-performance
    3D and vector graphics. These include the **WebGL** APIs and **SVG** elements.
    The 3D graphics libraries utilize the *canvas* element for rendering and can utilize
    the graphics hardware. For applications built with Vue.js, there is an additional
    component library called VueGL that makes it easier to create WebGL-based components.
    In terms of SVG, JSX in React is able to directly parse SVG syntax, as long as
    the SVG properties are converted to the camel-case JavaScript syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful, in-depth list of web APIs that frameworks can potentially utilize
    can be found at [developer.mozilla.org/docs/Web/API](http://developer.mozilla.org/docs/Web/API).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at a real-world frontend example with Nuxt.js.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nuxt.js uses Vue as a backbone for its frontend components. As shown in *Figure
    2**.2*, the Nuxt.js framework has the `NuxtLink` built-in component for creating
    links, which can be used in application code, and utilizes several modules from
    Vue, such as the `vue-router` and component-building functions such as `defineComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Nuxt.js and Vue framework abstraction](img/Figure_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Nuxt.js and Vue framework abstraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can follow the usage of this abstraction (*Figure 2**.2*) in detail from
    an `example.vue` page in application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this particular code example on your computer, navigate to the `chapter2/nuxt-js-application`
    directory and run `npm install && npm run dev`. Refer to the included `chapter2/README.md`
    documentation for additional details. Once the application is ready to run locally,
    you should see the URL that you can open in your browser in the terminal. Here’s
    an example of the successful output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The auto-import feature of the framework allows the direct use of the component
    to create the two links in the template file. This built-in component is defined
    in the source of the Nuxt framework at [github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts](http://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a moment to understand the `nuxt-link` component code, following
    along with the source from the framework itself. The code behind this particular
    component extends the routing behavior from Vue.js. It defines the typed TypeScript
    interfaces, such as `NuxtLinkOptions` and `NuxtLinkProps`, to accept particular
    styling attributes and routing options. The `defineNuxtLink` function returns
    the component with the customized routing behavior. Helper functions, such as
    `checkPropConflicts` and `resolveTrailingSlashBehavior`, address specific routing
    use cases. The `setup()` function call uses the Vue 3 Composition API to enable
    reactive properties of the component and attach component lifecycle hooks to versions
    of `NuxtLink` in applications. More details on this API can be found in Vue.js’
    documentation – [vuejs.org/guide/extras/composition-api-faq.html](http://vuejs.org/guide/extras/composition-api-faq.html).
    The important parts are shown in a condensed form here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding component code, we see the final return statement of `defineComponent`.
    This generates the anchor `<a>` element that we ultimately see in the final source
    of the HTML structure in the web application. It is produced by the internal Vue.js
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the `defineNuxtLink` function, it is also evident that it is possible to
    modify some parts of the component. For example, we can define a component with
    a custom name using the `componentName` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we’ve seen that JavaScript
    has much to offer for full stack frameworks. In the next section, we are going
    to look at the APIs that we can utilize as part of the backend environment.
  prefs: []
  type: TYPE_NORMAL
- en: Backend runtime abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there are many frontend APIs to choose from, we are still bound by
    what the web browser supports. This is a lesser issue when we write backend services,
    as there are still many APIs that we can use, and we can even write our own extensions
    or integrate with external systems for custom use cases. Let’s take a look at
    important APIs that we can use as part of framework development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will look at both **Node.js** and **Deno**, as they are
    two runtimes that offer similar features. These runtimes need to handle server
    creation, file and process management, module packaging, and more. The following
    are some of the essential APIs that are used by the backend frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem APIs** – This has the ability to read and write files and other
    file system entities. Frameworks use this heavily while storing data, loading
    existing files, and serving static content. These APIs also include file streaming
    and asynchronous features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking** – These are the APIs to start new server processes and accept
    requests. Includes handling of HTTP requests and other request formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules and packaging** – These are the conventions of how modules and packages
    can be loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system APIs** – These are the APIs to fetch information from the
    operating system that is running the process. This includes useful data about
    memory consumption and useful operating system directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process handling** – These APIs allow for manipulating and gathering details
    of the currently running process. These also enable sub-process creation and handling
    of multi-process communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native modules** – The native module APIs allow users to call out to libraries
    written in other native languages, such as C/C++, Rust, and others. In some cases,
    they use the **Foreign Function Interface** (**FFI**). WebAssembly is also part
    of this native module support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worker APIs** – Allows the spawning of additional worker threads to schedule
    heavy server work to happen outside of the main process. For instance, the Deno
    runtime supports the **Web Worker API** to provide these features, while Node.js
    uses its **Worker** **Threads** module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Console and debugging** – This set of internal APIs allows for recording
    process logs. The debugging APIs make developing and finding issues in the running
    code easier. Paired with an editor that supports debugging operations, it can
    pause the debugger when the framework request handler is processing a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the APIs that backend frameworks can use as the foundation
    for their projects. For instance, the hapi.js framework is able to combine some
    of these APIs to create its `Server`, `Route`, `Request`, and `Plugin` modules.
    For example, its `Core` ([hapi/lib/core.js](http://hapi/lib/core.js)) module makes
    use of the operating system, networking, and module-handling APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can take a look at a detailed example of combinations of abstractions
    and runtime APIs in Nest.js, a framework that is familiar to us from [*Chapter
    1*](B19014_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: Backend framework abstractions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Nest.js framework supports the ability to provide any HTTP framework as
    long as there is an adapter defined to work with it. The existing adapters that
    are built right into Nest.js are `platform-express` and `platform-fastify`. The
    default behavior of the HTTP adapter abstraction is transparent to the developer
    as it uses the `express` module by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.3*, we can see the combination of all the components. The application
    code is powered by the framework that utilizes both the framework abstractions
    and the Node.js API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Nest.js framework abstractions](img/Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Nest.js framework abstractions'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 2**.3*, the `main.ts` entry point file in Nest.js starts
    the server and listens for incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`express-adapter`, which extends from `AbstractHttpAdapter`, defines the set
    of methods required for the HTTP server, including the `.``listen` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The adapter code above utilizes the `express` framework and the internal `http`
    APIs. Ultimately, this results in a class that exposes a method to set up an HTTP
    server. Even though `express` provides the routing and HTTP helpers, it does not
    start the server by itself. Inside `express-adapter`, there is a direct call to
    Node.js APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The direct call in the preceding code block figures out the type of server to
    start, *HTTP* or *HTTPS*. It also accepts a variety of `httpOptions` values. This
    pattern is similar in other frameworks. For instance, in AdonisJS, the framework
    authors define the `HttpServer` class ([github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts](http://github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts))
    that creates an HTTP server and utilizes the `createHttpServer` utility function
    to call out to the runtime APIs of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: As we dig in further to understand how existing frameworks are structured and
    how their abstractions work, it is important to have a way of traversing the code
    of these nested abstractions. In the next section, we will cover the technique
    of debugging, which can help us uncover the hidden interfaces within the frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: About debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging plays an important role in software development. It helps us identify
    and resolve issues quickly. As part of the framework learning process, it also
    helps us understand how these frameworks work internally. By stepping through
    the breakpoints of the program and digging deep into the call stack, we can understand
    the inner workings of the internal modules. It also helps us navigate through
    multiple levels of abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js’ debugger integration provides a way for us to debug our programs and
    frameworks. It is a good habit to try it out on your own to get a better understanding
    of how the framework functions. For example, to debug a Nest.js application, we
    can utilize the Visual Studio Code debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `nest-js-application` project in the `framework-organization` directory
    of the book’s GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `npm install` to get the project’s dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a code execution breakpoint in the `app.service.ts` file of the application;
    refer to the screenshot in *Figure* *2**.5*. To set the breakpoint, hit the empty
    space to the left of the line number until you see a red dot. Once this red dot
    appears, that will be your breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, browse to the `package.json` file, and press the `scripts`
    section. See an example of this in *Figure 2**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4: Debug button in package.json](img/Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Debug button in package.json'
  prefs: []
  type: TYPE_NORMAL
- en: After pressing the `start:dev` option, which should start the application, observable
    in the `nest` command is not found, that means you need to install the dependencies
    for this project using `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the application running in debug mode and using the `start:dev` script,
    open the address at `http://127.0.0.1:3000` in your browser. This should now pause
    on the extract line of your breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you hit a breakpoint properly in the editor, that means you successfully
    attached the debugger to the application. You can now use the call stack pane
    on the left (as shown in *Figure 2**.5*) to navigate around the running process
    and browse through the Nest.js modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Debugging a Nest.js application](img/Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Debugging a Nest.js application'
  prefs: []
  type: TYPE_NORMAL
- en: This technique is a quick way to get a view behind the scenes of a framework.
    It enables developers to quickly get a sense of how the framework functions and
    makes it easier to understand the nested abstractions. To get more from it, you
    can find an in-depth explanation of the Visual Studio Code debugger at [code.visualstudio.com/docs/editor/debugging](http://code.visualstudio.com/docs/editor/debugging).
  prefs: []
  type: TYPE_NORMAL
- en: Framework building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like most programming languages, JavaScript, and its extensions such as
    TypeScript, have the fundamental features of working with numbers, strings, Booleans,
    conditional logic statements, and much more. The more advanced features are built
    on top of those fundamentals. The frameworks utilize existing interfaces, such
    as events and modules. However, they also create their own build blocks, by defining
    interfaces to create components, routers, and others.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to examine both existing interfaces and custom
    ones. We are going to look at some of the common interfaces, which can be combined
    to make a framework. These are the abstracted entities that solve particular problems
    in application development and are beneficial to their users.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event binding and events are everywhere in JavaScript applications. They enable
    frontend user interfaces and interactivity through buttons, forms, pointer movement,
    keyboard keys, scrolling, and more. The concept of event binding is something
    that every framework handles with different syntax definitions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, the event handling is very similar to original DOM events,
    but with a modified syntax to fit the framework abstractions better. Frameworks
    further enable event handling by providing more complex event management components.
    For example, Angular has the concept of `HostListener` ([angular.io/api/core/HostListener](http://angular.io/api/core/HostListener))
    to register events within its components.
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, Node.js is heavily event-based because of its asynchronous,
    event-driven architecture and the frameworks take advantage of that. For example,
    hapi.js maintains its own event emitter package called `@hapi/podium`, which allows
    the developers to register custom application events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of the event handling pattern would be how the `change` and
    `navigation` events to report the latest values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The use of events is an important building block, which allows us to subscribe
    to user interaction and listen to the changes or progress of some operation. As
    we are set on developing our own framework, it needs to provide a way to interact
    with events and abstract certain complexities around them.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many frameworks provide an abstraction to create reusable components to organize
    the project. Depending on how the application is planned out, components can help
    split any type of application into reusable and independent pieces of code. These
    code parts can also be nested within each other. Depending on the required business
    logic, developers can define custom components, use the pre-built ones, or import
    a library of components that are designed for specific use. Once many components
    are nested and situated together, it is common to have some interaction between
    these objects. The components utilize data properties to render the information
    to the user from the current state, and in many cases, they need some properties
    from the parent components. For frameworks that use React or Vue, this means writing
    communication patterns that enable child-to-parent component communication and
    the other way around. This communication process can get complicated, which is
    why these frameworks use a unidirectional or a one-way data flow where the data
    updates flow from parent to child components. Instead of synchronizing the same
    state between nested components, it is advised to store the state in the most
    common ancestor component in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a complex application, this means that we will probably end up with
    a lot of components, nested multiple levels deep. This is where **component composition**
    can help. Component composition is a pattern that allows for minimal code duplication,
    and performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we have an illustrative example of how composition
    can affect and reorganize a set of nested components within an application. The
    component organization pattern is very familiar to developers, so it would be
    a good choice to use or create a framework utilizing this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF2.6: Nested versus composed components](img/Figure_2.6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Nested versus composed components'
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lifecycle methods or events are often managed by the framework, providing the
    ability to execute code at particular points. These methods can be used to execute
    custom logic at different stages of components and other parts of the system,
    which provides flexibility to the framework interfaces. These lifecycle methods
    can be used to attach or detach additional logging, utility functions, and more
    during the component execution. Lifecycle sequence, which means the order of how
    these events occur, must be well documented and described in the framework. This
    is done mostly due to the fact that the lifecycle methods can have a particular
    naming convention and have a complex runtime hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Nest.js, the server framework provides lifecycle hooks to its module system.
    Some examples of that are `onApplicationBootstrap()`, which is called when all
    modules in the application have been initialized, and `onModuleInit()`, which
    is called when the dependencies of a module have been resolved. Using the TypeScript
    interfaces in Nest.js, we can inject code into the `onApplicationShutdown` lifecycle
    event as all connections to the server close down, which can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Vue.js, given that the framework deals with rendering components, the events
    available cover the whole lifetime of the component. For instance, it has `beforeCreate`,
    `created` events as the component initializes its state, and `beforeMount`, `mounted`
    events as the component gets mounted to the DOM tree. You can find a great lifecycle
    diagram of Vue.js at [vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram](http://vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram).
  prefs: []
  type: TYPE_NORMAL
- en: Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both frontend and backend frameworks usually require some form of a router that
    navigates to different parts of the application. The router mechanism on the frontend
    follows the navigational pattern of web pages, following the browser’s URL patterns.
    On the frontend, the router is essential to transition between states or navigate
    to internal or external pages. Besides providing the routing *tree* structure,
    the router is also responsible for interfaces that allow components to invoke
    the routing behaviors – we saw an example of this via `NuxtLink` in the *Real-world
    Examples* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **react-router** ([reactrouter.com/main/start/overview](http://reactrouter.com/main/start/overview))
    project is a good example of everything you need from a router component. It makes
    it possible to simply define the routes within a component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The backend server frameworks use a server router to handle requests coming
    to API endpoints. Normally, the router interface takes different forms of endpoint
    URL structures and maps those into functions that process the route. Some good
    examples of an unopinionated router can be found in Express.js ([expressjs.com/guide/routing.html](http://expressjs.com/guide/routing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following code example, we see the relationship between the endpoint
    path and the function that is able to process the request and a text response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we have seen examples
    of file-based routing, which further simplifies the routing mechanisms by just
    looking at the files in the application, and dynamically creating routes based
    on those files.
  prefs: []
  type: TYPE_NORMAL
- en: Template engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another essential building block is the template engine. This engine combines
    the static parts of a marked-up document with the data from the application. Templating
    makes it possible to render views with various forms of data. With frontend frameworks,
    this usually means rendering the nested component hierarchy. The template engine’s
    job is to enable data binding and to bind any specified events for the interactive
    components, such as buttons or input fields.
  prefs: []
  type: TYPE_NORMAL
- en: With a backend framework, templating engines render the whole page or, in some
    cases, partials, sending them over the wire to the client for initial static rendering.
    From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we have seen frameworks,
    such as Next.js, that are able to render the frontend components on the server
    side and then attach any JavaScript behaviors to the readily rendered component.
    By default, in Next.js, the pages are pre-rendered to improve search engine optimization
    and performance in the browser client. Templating is a vital building block of
    a framework – this is how developers create the presentation layer and mark up
    the page structure.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web frameworks commonly provide several components as networking abstractions.
    The ability to use a good networking interface can vastly improve the readability,
    performance, and error handling of the application. Here are some features that
    usually come as part of a good networking abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session management** – This is the ability to manage sessions and provide
    easy access to session information. This is included as part of networking because
    frontend frameworks usually rely on the backend service to fetch and parse the
    session information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling** – This provides good interfaces to handle all types of possible
    errors that can happen during the process of making a request to an endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching** – This is the mechanism that provides a caching layer to improve
    performance and avoid redundant queries if the data is already fresh enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** – Often frameworks come with baked-in security features that follow
    the best practices. This includes examples such as XSS, CSRF protection, script
    injection prevention, and input validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request and response management** – This improves the ability to make requests
    with the required parameters and parse the responses from external systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these networking abstractions apply to both frontend and backend systems.
    In a full stack framework, a combination of these abstractions can vastly improve
    the workflow and the efficiency of the system that it is supporting.
  prefs: []
  type: TYPE_NORMAL
- en: All these abstractions are implemented in JavaScript, TypeScript, or enabled
    by the runtime. Their implementation can be provided from within three categories
    of code structures – as a module, library, or built into a framework. In the next
    section, we are going to explore these categories of code organization.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating modules, libraries, and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on JavaScript applications, we rely on modules, libraries, and,
    of course, the larger frameworks. These structures can originate from internal
    and external sources, meaning they are either written by you or your team or are
    a dependency that is written by someone else. JavaScript, specifically, is in
    a unique position where modules, libraries, and even frameworks can be used on
    browser and server environments. For framework developers, it is important to
    know how to work with these JavaScript structures, because frameworks heavily
    rely on defining and using modules and libraries. These abstractions and structures
    allow for better code organization, which we will be discussing in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers create their own modules to separate the code into multiple files
    or logical blocks. In a similar manner, modules can be imported from external
    sources. The module encapsulation wraps a block of code, providing a way for it
    to export various data types through strings, functions, and other data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The history of how modules are defined and used in JavaScript is complicated;
    it ventures out to different module patterns and implementations. Even in modern
    projects, you will find inconsistent approaches to module management. Initially,
    there was no way to organize modules, so frontend JavaScript modules were wrapped
    in immediately invoked function expressions or objects. Using functions allows
    the hosting of all the values inside of it within a lexical scope. Here is a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It was evident that the language needed some kind of a modular pattern, and
    this is where **CommonJS** and AMD types of modules were introduced. Defining
    a CommonJS module is straightforward and can be seen in use in a lot of the Node.js
    frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, hapi.js uses a similar CommonJS module pattern in most of its
    files, which can be found in the framework repository at [github.com/hapijs/hapi/tree/master/lib](http://github.com/hapijs/hapi/tree/master/lib)
    – a simple example from a list of its modules is `lib/compression.js` in the `lib`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This module provides compression functions for many hapi.js use cases. With
    some of the code omitted, we see the `exports` keyword, which is used to make
    methods from this module available in other files.
  prefs: []
  type: TYPE_NORMAL
- en: These days projects may have different types of JavaScript modules that are
    used as part of their workflow. The more standard ones you will see are CommonJS
    and `module.exports` keywords. The ESM system provides `import` and `export` keywords
    to manage the modules. To distinguish the module types, the `.cjs` and `.mjs`
    file extensions are used to be explicit about which module system is used. The
    normal `.js` extension can still be used, but then it is up to the module loading
    system to figure out how to load these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of module types that you may see in the ecosystem are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Module Definition** (**UMD**) – This is the module definition that
    tries to support all possible module declarations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require()` and `define()` functions to manage the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediately Invoked Function Expression** (**IIFE**) – These are simplistic
    modules encapsulated by a function scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module systems are slowly getting better in JavaScript, but it is something
    to watch out for when using various modules in frameworks and choosing the right
    module system to use. The varying usage of modules can lead to issues with loading
    in specific environments or can lead to some features not working as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Libraries are indispensable in software development nowadays; they play an important
    role in supporting web development projects of any size. The libraries consist
    of a collection of useful resources that implement certain specific functionality
    with a well-defined interface. The focus of libraries is to include the encapsulation
    of optimized features to solve certain problems. Most libraries try to focus on
    a specific set of problems that can help their stakeholders. JavaScript has an
    abundance of open source libraries that developers cannot live without in professional
    projects. They don’t dictate any specific opinionated control flow, but instead,
    let the developer make use of them when needed. In a similar fashion to frameworks,
    the technological availability of the JavaScript runtime allows some of the libraries
    to be used in both the browser and the backend environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries can serve as a core component used by a framework to solve certain
    technological challenges. There are many cases where we see frameworks building
    abstractions around the following libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lodash** ([lodash.com](http://lodash.com)) – This library provides a large
    set of utility functions for common tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React** ([reactjs.org](http://reactjs.org)) – This is an extremely popular
    user interface component rendering library with state management that many of
    the frontend frameworks mentioned so far are based on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Axios** ([axios-http.com](http://axios-http.com)) – This is a powerful HTTP
    client library for frontend and backend JavaScript projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Luxon** ([moment.github.io/luxon](http://moment.github.io/luxon)) – This
    is a library to manipulate date and time in JavaScript, the evolution of a popular
    library called moment.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery** ([jquery.com](http://jquery.com)) – This is more than a decade old
    – a popular library that simplified DOM traversal and abstracted away cross-browser
    quirks for CSS, AJAX, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three.js** ([threejs.org](http://threejs.org)) – This is a JavaScript 3D
    library that abstracts away the complexities of WebGL and 3D graphics on the web'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a common pattern to build out additional tooling on top of existing libraries
    to enable applications of various types. For example, in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    we saw examples of frameworks building tooling and abstractions around React.
    If the project allows you to, it is usually a good idea to utilize a library or
    learn from existing implementations for a solved problem rather than rebuilding
    or rewriting the same code. In the next section, we are going to compare choosing
    a development workflow with a set of libraries in contrast with framework-driven
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015), we already know what JavaScript
    frameworks do and the benefits they offer. It is also important to understand
    how much frameworks rely on libraries for their workflows and features, and the
    differences between them. Both libraries and frameworks manage control flow in
    the applications. This control flow is the order and structure of how the logic
    in the application flows. With a library workflow, the existing program will have
    its own control flow and as part of it the library functions are executed when
    required. This existing program precisely calls out to the reusable code in the
    library. This gives full control to the developer to structure the application
    as they see fit, allowing for more room to fine-tune the application behavior
    but missing the value and structures that could potentially be gained by using
    a framework.
  prefs: []
  type: TYPE_NORMAL
- en: With a framework workflow, the framework dictates how the control flow should
    be structured. In this case, the developer works within the constraints of the
    framework and follows the often strict guidelines defined by someone else.
  prefs: []
  type: TYPE_NORMAL
- en: A good comparison would be the React library versus a JavaScript framework such
    as Next.js that depends on the library. The library just consists of functions
    that execute certain tasks. React contains logic for rendering, creating components,
    and other methods. But it is Next.js – the framework – that defines the architecture
    for the application, using the library methods from within to enable its features.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the workflow of using the library within a framework makes it a powerful
    combination; this way, it is possible to gain the benefits of both of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Framework organization showcase
  prefs: []
  type: TYPE_NORMAL
- en: You can try out the framework organization examples from this chapter in the
    book repository. Access the examples by cloning the repository from [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    Then use your terminal to change directories into the `framework-organization`
    directory of the repository and run `npm install` followed by `npm start`. Follow
    the guidance in the terminal and keep an eye out for the `README.md` files in
    the directories for extra information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at abstractions combined with clever API design, which together
    form the key to building successful frameworks. We have also expanded our knowledge
    of common framework interfaces that provide value to developers and make the application
    development process much more efficient and approachable. Understanding how modules,
    libraries, and frameworks are used helps us be better system architects. In addition,
    the ability to use the debugger to quickly explore how all these pieces come together
    in existing frameworks empowers us to be much more efficient developers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with various organization patterns, we can dive
    deeper into the specific techniques that help us architect new systems. In the
    next chapter, we are going to look at the existing and common patterns that combine
    the building blocks that we have learned into a cohesive system.
  prefs: []
  type: TYPE_NORMAL
