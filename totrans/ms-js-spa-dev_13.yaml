- en: Chapter 13. Testing with Mocha, Karma, and More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章. 使用 Mocha、Karma 和更多进行测试
- en: Testing is an integral part of software development, especially when dealing
    with applications that interact with end-users and various clients, as is the
    case with JavaScript SPAs. The results of web application code can often be unpredictable
    due to the variety of clients potentially consuming the application, so all possible
    scenarios should be accounted for and tested appropriately.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个基本组成部分，尤其是在处理与最终用户和不同客户端交互的应用程序时，例如 JavaScript SPAs。由于可能消费应用程序的客户端种类繁多，因此网络应用程序代码的结果往往难以预测，因此应该考虑到所有可能的场景并进行适当的测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is unit testing, integration testing, and **end-to-end** (**E2E**) testing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试、集成测试和**端到端**（**E2E**）测试是什么？
- en: How to perform JavaScript unit testing with Mocha, Chai, and Sinon.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Mocha、Chai 和 Sinon.js 进行 JavaScript 单元测试
- en: How to configure Karma with Jasmine to test AngularJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置 Karma 使用 Jasmine 测试 AngularJS
- en: How to perform unit testing with AngularJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 AngularJS 进行单元测试
- en: How to perform end-to-end testing with AngularJS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 AngularJS 进行端到端测试
- en: Types of testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'There are various types of testing known throughout the software industry,
    but there are three main types that are consistently used, especially in web application
    development. They are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业中已知有许多种测试类型，但有三类测试被持续使用，尤其是在网络应用开发中。具体如下：
- en: Unit testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: End-to-end testing, also known as *functional* testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试，也称为*功能*测试
- en: 'These three types of testing comprise what is known as the *software testing
    pyramid*. The pyramid can be broken down into more granular forms of testing,
    but this is how it looks from a high vantage point:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种测试类型构成了所谓的*软件测试金字塔*。金字塔可以分解为更细粒度的测试形式，但从高视角来看，它看起来是这样的：
- en: '![Types of testing](img/B05228_13_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![测试类型](img/B05228_13_01.jpg)'
- en: Unit testing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: The bottom level of the software testing pyramid is *unit testing*. Unit testing
    targets the smallest pieces of an application, or units, in *isolation* from the
    remainder of the application. A unit is typically an individual method or object
    instance. When you test a unit in isolation, it means that the test should not
    interact with any application dependencies, such as network access, database access,
    user sessions, and any other dependencies that may be needed in the real-world
    application context. Instead, a unit test should only perform operations within
    local memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试金字塔的底层是*单元测试*。单元测试针对应用中最小的部分，即单元，在*隔离*于应用其余部分的情况下进行。一个单元通常是一个单独的方法或对象实例。当你对单元进行隔离测试时，这意味着测试不应该与任何应用依赖项交互，例如网络访问、数据库访问、用户会话以及在实际应用环境中可能需要的任何其他依赖项。相反，单元测试应该只执行本地内存中的操作。
- en: The goal of any unit test should be to test only a single feature of the application,
    and that feature should be encapsulated within the unit. If that unit does have
    any dependencies, they should be *mocked*, or simulated, instead of invoking the
    actual dependencies. We will discuss more about that later in the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何单元测试的目标应该是仅测试应用程序的一个功能，并且该功能应封装在单元中。如果该单元有任何依赖项，它们应该被*模拟*或模拟，而不是调用实际的依赖项。我们将在本章后面进一步讨论这一点。
- en: Knowing that you will perform unit testing will help you write smaller and more
    focused methods in your application because they are easier to test. Many will
    argue that you should always write your tests first before writing any application
    code. This is not always practical, however, because you may have been pushed
    into a speedy development cycle that didn't allow time for the tedious process
    of writing unit tests. Writing unit tests against existing code may prove tedious
    as well, but it is quite acceptable, and better than having no unit tests at all.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你将进行单元测试将帮助你编写更小、更专注的方法，因为它们更容易测试。许多人会争论说，你应该在编写任何应用程序代码之前先编写测试。然而，这并不总是实用的，因为你可能被推入一个快速的开发周期，没有时间进行编写单元测试的繁琐过程。对现有代码编写单元测试也可能很繁琐，但这是可以接受的，并且比完全没有单元测试要好。
- en: Let's look at some well-known JavaScript unit testing frameworks that can quickly
    and easily be integrated into a new or existing application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些知名的 JavaScript 单元测试框架，它们可以快速轻松地集成到新的或现有应用程序中。
- en: Mocha
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha
- en: '*Mocha* is a popular JavaScript unit testing framework that is commonly used
    throughout the Node.js community. Let''s revisit our Node.js sample project from
    the beginning of the book and install Mocha so we can try out a few unit testing
    examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mocha* 是一个流行的 JavaScript 单元测试框架，在 Node.js 社区中广泛使用。让我们回顾一下本书开头提到的 Node.js 示例项目，并安装
    Mocha，以便我们可以尝试一些单元测试示例：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Install `mocha` globally so that you can access it easily from any directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 全局安装 `mocha`，这样你就可以轻松地从任何目录访问它。
- en: 'Now, let''s create a `test` directory at the root of our project to store testing
    related files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在项目的根目录下创建一个 `test` 目录来存储测试相关文件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file in the `test` directory named `test.js` and open it for editing.
    Place the following code in the file and save it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test` 目录下创建一个名为 `test.js` 的文件，并打开它进行编辑。将以下代码放入文件并保存：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run the test, issue the following command from your console under the `test`
    directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请在 `test` 目录下的控制台输入以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should then see the following output in your console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中看到以下输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Mocha `describe` method, this unit test performs a simple **assertion**
    on the `search` method of the `String` constructor. An assertion in testing is
    simply an evaluation of whether something is `true` or not. In this example, we
    are testing the assertion that the `search` method returns `-1` when its argument
    is not found within the search context.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mocha 的 `describe` 方法，此单元测试对 `String` 构造函数的 `search` 方法执行简单的 **断言**。在测试中，断言简单地说就是评估某事是否为
    `true`。在此示例中，我们正在测试当 `search` 方法的参数在搜索上下文中未找到时，它返回 `-1` 的断言。
- en: Assertions with Chai
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Chai 进行断言
- en: 'The previous example uses the Node.js `assert` module, but with Mocha, you
    will want to use a full-fledged assertion library for a substantive testing environment.
    Mocha is compatible with multiple JavaScript assertion libraries, including the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了 Node.js 的 `assert` 模块，但使用 Mocha，你将希望使用一个完整的断言库来构建一个实质性的测试环境。Mocha 与多个
    JavaScript 断言库兼容，包括以下内容：
- en: Should.js
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Should.js
- en: Expect.js
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expect.js
- en: Chai
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chai
- en: Better-assert
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Better-assert
- en: Unexpected
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unexpected
- en: 'Chai is a popular and active open source assertion library, so we will use
    it for our Mocha assertion examples throughout this chapter. First, install `chai`
    in your local Node.js environment:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 是一个流行的活跃的开源断言库，因此我们将在此章的 Mocha 断言示例中使用它。首先，在你的本地 Node.js 环境中安装 `chai`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Chai includes three styles of assertions, `should`, `expect`, and `assert`,
    allowing you to choose the flavor you like best.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Chai 包含三种断言风格，`should`、`expect` 和 `assert`，允许你选择你最喜欢的风味。
- en: '**Should-style assertions**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**应该风格断言**'
- en: '*Should*-style assertions are accessible in Chai using `chai.should()`. This
    interface allows for a chainable method syntax that is familiar to many JavaScript
    developers, especially if you have worked with libraries such as jQuery. The chainable
    method names use natural language to make writing the tests more fluid. Additionally,
    Chai''s `should` method extends `Object.prototype` so that you can chain it directly
    to the variables you are testing, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*应该风格断言* 在 Chai 中通过 `chai.should()` 访问。此接口允许使用许多 JavaScript 开发者熟悉的链式方法语法，特别是如果你与
    jQuery 等库合作过。链式方法名称使用自然语言来使编写测试更加流畅。此外，Chai 的 `should` 方法扩展了 `Object.prototype`，这样你就可以直接将其链接到你要测试的变量，如下所示：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example will perform a simple assertion that the given variable is a string.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将执行一个简单的断言，检查给定的变量是否为字符串。
- en: '**Expect-style assertions**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**期望风格断言**'
- en: '*Expect*-style assertions are accessible in Chai using `chai.expect`. This
    interface is similar to `should`, in that, it uses method chaining, but it does
    not extend `Object.prototype`, so it is used in a more traditional fashion, as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*期望风格断言* 在 Chai 中通过 `chai.expect` 访问。此接口与 `should` 类似，因为它使用方法链，但它不扩展 `Object.prototype`，因此它以更传统的方式使用，如下所示：'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example performs the same assertion as the previous example, but with Chai's
    `expect` method instead of `should`. Notice that the `require` call to the `expect`
    method does not execute it, as is the case with `should`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例执行与上一个示例相同的断言，但使用 Chai 的 `expect` 方法而不是 `should`。请注意，对 `expect` 方法的 `require`
    调用不会执行它，就像 `should` 一样。
- en: '**Assert-style assertions**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言风格断言**'
- en: '*Assert*-style assertions are accessible in Chai using `chai.assert`. This
    interface uses the more traditional style of assertions, much like the Node.js
    native `assert` module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言风格断言* 在 Chai 中通过 `chai.assert` 访问。此接口使用更传统的断言风格，类似于 Node.js 原生的 `assert`
    模块：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example performs the same assertion as the two previous examples but with
    Chai's `assert` method. Notice that this example calls upon the `assert.typeOf`
    method, which is akin to the native JavaScript `typeof` operator, rather than
    using natural language method names as `should` and `expect` do.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例执行了与前面两个示例相同的断言，但使用的是 Chai 的 `assert` 方法。注意，这个示例调用了 `assert.typeOf` 方法，这与原生的
    JavaScript `typeof` 操作符类似，而不是像 `should` 和 `expect` 那样使用自然语言方法名称。
- en: Testing with Mocha and Chai does not favor any particular style of assertion
    available in Chai, but it is best to choose one and stick with it so that a testing
    pattern is established. We will use the `should` style of assertion for the remaining
    examples in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mocha 和 Chai 进行测试并不偏袒 Chai 中可用的任何特定断言风格，但最好选择一种并坚持下去，以便建立测试模式。我们将在这个章节的其余示例中使用
    `should` 断言风格。
- en: '**Using Mocha with Chai-and Should-style assertions**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Mocha 和 Chai 的 Should-style 断言**'
- en: 'Now, let''s go back to our original Mocha test example in `test.js` and add
    a similar test right under it, but use Chai''s `should` assertion method instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的原始 Mocha 测试示例 `test.js`，并在其下方添加一个类似的测试，但使用 Chai 的 `should` 断言方法：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This performs the same test as shown earlier using the native Node.js `assert`
    module, but with Chai's `should` method instead. The advantage of working with
    Chai in this scenario, however, is that it provides additional tests beyond what
    Node.js can provide out of the box, and the Chai tests are also browser compatible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行了前面展示的相同测试，但使用的是 Chai 的 `should` 方法。然而，在这个场景中使用 Chai 的优势在于，它提供了 Node.js 默认提供的额外测试，并且
    Chai 测试也兼容浏览器。
- en: 'Back in the console, run the Mochas tests:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台，运行 Mocha 测试：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should yield the following output from your two tests:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该从您的两个测试中产生以下输出：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s write a more interesting test that might be used in a real-world
    application context. A JavaScript SPA will often be dealing with the DOM, so we
    should test that interaction accordingly. Let''s consider the following method
    as an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个更有趣的测试，它可能在现实世界的应用场景中使用。一个 JavaScript 单页应用（SPA）通常会处理 DOM，因此我们应该相应地测试这种交互。以下方法可以作为示例：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `addClass` method simply adds a `className` to a DOM element if it does
    not already have that `className`. We are defining it with `module.exports` so
    that it is consumable as a Node.js module. To test this code, save it in a new
    file named `addClass.js` under your `test` directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`addClass` 方法简单地将 `className` 添加到 DOM 元素上，如果该元素尚未具有该 `className`。我们通过 `module.exports`
    定义它，以便它可以作为 Node.js 模块使用。为了测试这段代码，将其保存为名为 `addClass.js` 的新文件，位于您的 `test` 目录下。'
- en: 'Now, back in the `test.js` file, add the following unit test code under the
    other two tests that we have written so far:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `test.js` 文件，在其他两个测试代码下方添加以下单元测试代码：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Due to the no-dependencies constraint of unit testing, we are faking, or **mocking**,
    a DOM element here by defining a simple JavaScript object called `elem` and giving
    it a `className` property, just as a real DOM object would have. This test is
    written strictly to assert that calling `addClass` on an element with a new, non-existent
    `className` will, in fact, add that `className` to the element.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试的无依赖性约束，我们在这里通过定义一个简单的 JavaScript 对象 `elem` 并给它一个 `className` 属性来模拟或**模拟**一个
    DOM 元素，就像一个真实的 DOM 对象一样。这个测试严格编写来断言，在元素上调用 `addClass` 并传入一个新且不存在的 `className`
    时，实际上会向该元素添加该 `className`。
- en: 'Running the tests from the command line should now yield the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行测试现在应该产生以下输出：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running Mocha tests in the browser
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在浏览器中运行 Mocha 测试
- en: 'Mocha is easy enough to run from a CLI, but it also comes bundled with assets
    that allow you to easily run your tests in a browser. As we are currently working
    with frontend JavaScript code, it is best to test it in the environment it will
    actually be run. To do this, let''s first create a file named `test.html` at the
    root of the project and add the following markup to it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 从命令行运行起来足够简单，但它还附带了一些资产，允许您轻松地在浏览器中运行测试。由于我们目前正在处理前端 JavaScript 代码，最好在它实际运行的环境中进行测试。为此，让我们首先在项目根目录下创建一个名为
    `test.html` 的文件，并向其中添加以下标记：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mocha provides CSS and JavaScript assets to view tests in a browser. All that
    is required of the DOM structure is to have a `<div>` defined with an ID of `mocha`.
    The styles should be included in `<head>`, and the JavaScript should be included
    under `<div id="mocha">`. Additionally, the call to `mocha.setup('bdd')` tells
    the Mocha framework to use its **Behavior-Driven Development**(**BDD**) interface
    for testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 提供了 CSS 和 JavaScript 资产，以便在浏览器中查看测试。对于 DOM 结构的要求仅仅是定义一个带有 `mocha` ID 的
    `<div>`。样式应包含在 `<head>` 中，而 JavaScript 应包含在 `<div id="mocha">` 之下。此外，调用 `mocha.setup('bdd')`
    告诉 Mocha 框架使用其 **行为驱动开发**(**BDD**) 接口进行测试。
- en: 'Now, remember that our JavaScript files are written as Node.js modules, so
    we will have to modify their syntax to work properly in a browser context. For
    our `addClass.js` file, let''s modify the method to be defined in a global `window`
    object named `DOM`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，我们的 JavaScript 文件是以 Node.js 模块编写的，因此我们必须修改它们的语法才能在浏览器环境中正确运行。对于我们的 `addClass.js`
    文件，让我们将方法定义为全局 `window` 对象上的 `DOM`：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, modify `test.js` to load `chai.should` and `DOM.addClass` from the `window`
    context, instead of as Node.js modules, and let''s go ahead and remove the original
    Node.js `assert` module test that we created:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 `test.js` 以从 `window` 上下文加载 `chai.should` 和 `DOM.addClass`，而不是作为 Node.js
    模块，然后让我们继续删除我们创建的原始 Node.js `assert` 模块测试：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should now have two tests contained in `test.js`. Finally, run a local
    Node.js server from the root of the project so that you can view the `test.html`
    page in a browser:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在 `test.js` 中有两个测试。最后，从项目的根目录运行一个本地 Node.js 服务器，以便您可以在浏览器中查看 `test.html`
    页面：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the global `http-server` module, your local server will be accessible
    to your browser at `localhost:8080` and the test file at `localhost:8080/test.html`.
    Go to that page in a browser and you will see the tests run automatically. If
    everything is set up correctly, you should see the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局的 `http-server` 模块，您的本地服务器将在 `localhost:8080` 上对浏览器可用，测试文件在 `localhost:8080/test.html`。在浏览器中访问该页面，您将看到测试自动运行。如果一切设置正确，您应该看到以下输出：
- en: '![Running Mocha tests in the browser](img/image_13_002.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器中运行 Mocha 测试](img/image_13_002.jpg)'
- en: Sinon.js
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sinon.js
- en: Due to the requirement of isolation in unit testing, dependencies must often
    be simulated by providing `spies`, `stubs`, and `mocks` or objects that imitate
    the behavior of real objects. *Sinon.js* is a popular JavaScript library that
    provides these tools for testing and it is compatible with any unit testing framework,
    including Mocha.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试中隔离的要求，通常需要通过提供 `spies`、`stubs`、`mocks` 或模仿真实对象行为的对象来模拟依赖项。*Sinon.js*
    是一个流行的 JavaScript 库，它为测试提供了这些工具，并且与任何单元测试框架兼容，包括 Mocha。
- en: Spies
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 间谍
- en: 'Test spies are functions that can be used in place of callback dependencies
    and also are used to *spy* or record arguments, return values, and any other related
    data to other functions that is used throughout an application. Spies are available
    in Sinon.js through the `sinon.spy()` API. It can be used to create an anonymous
    function that records data on itself every time it is called throughout a test
    sequence:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试间谍是可以在回调依赖项的位置使用的函数，也用于 *监视* 或记录参数、返回值以及任何其他与应用程序中使用的相关数据。间谍在 Sinon.js 中通过
    `sinon.spy()` API 提供。它可以用来创建一个匿名函数，该函数在测试序列中的每次调用时都会记录数据：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An example use case of this is testing that a callback function is invoked
    properly from another function in a `publish` and `subscribe` design pattern,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的一个用例是测试在 `publish` 和 `subscribe` 设计模式中，从另一个函数正确调用回调函数，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, a spy is used to act as a callback for a `Payload.js` custom
    event. The callback is registered through the `Payload.subscribe` method and expected
    to be invoked upon publishing the custom event `test-event`. The `sinon.spy()`
    function will return an object with several properties available on it that give
    you information about the returned function. In this case, we are testing for
    the `spy.called` property, which will be `true` if the function was called at
    least once.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用 spy 来充当 `Payload.js` 自定义事件的回调。该回调通过 `Payload.subscribe` 方法注册，并预期在发布自定义事件
    `test-event` 时被调用。`sinon.spy()` 函数将返回一个对象，该对象具有几个属性，可以提供有关返回函数的信息。在这种情况下，我们正在测试
    `spy.called` 属性，如果函数至少被调用一次，则该属性将为 `true`。
- en: 'The `sinon.spy()` function can also be used to wrap another function and spy
    on it, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon.spy()` 函数还可以用来包装另一个函数并监视它，如下所示：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Additionally, `sinon.spy()` can be used to replace an existing method on an
    object and behave exactly like the original method, but with the added benefit
    of collecting data on that method through the API, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`sinon.spy()` 可以用来替换对象上的现有方法，并表现得与原始方法完全一样，但增加了通过 API 收集关于该方法数据的好处，如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Stubs
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存根
- en: Test `stubs` build on top of `spies`. They are functions that are spies themselves
    with access to the full test spy API, but with added methods to alter their behavior.
    Stubs are most often used when you want to force certain things to happen inside
    of functions when a test is being run on it, and also when you want to prevent
    certain things from happening.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `stubs` 是在 `spies` 的基础上构建的。它们是具有访问完整测试间谍 API 的间谍函数，但增加了改变其行为的方法。存根通常用于在测试运行时强制函数内部发生某些事情，以及当你想要防止某些事情发生时。
- en: 'For example, say that we have a `userRegister` function that registers a new
    user to a database. This function has a callback that is returned when a user
    is successfully registered, but if saving the user fails, it should return an
    error in that callback, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个 `userRegister` 函数，该函数将新用户注册到数据库中。该函数有一个回调，当用户成功注册时返回，但如果保存用户失败，则在该回调中返回错误，如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we will create an `Error` object to pass to our callback. Then, we will
    create a stub for our actual `save` method that replaces it and throws an error,
    passing the `Error` object to the callback. This replaces any actual database
    functionality as we cannot rely on real dependencies for unit testing. Finally,
    we will define the `callback` function as a spy. When we call the `registerUser`
    method for our test, we will pass the spy to it as its callback. In a scenario
    where we have a real `save` method, `save.restore()` will change it back to its
    original state and remove the stubbed behavior.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `Error` 对象并将其传递给我们的回调。然后，我们将为实际的 `save` 方法创建一个存根，用其替换并抛出错误，将 `Error`
    对象传递给回调。这取代了任何实际的数据库功能，因为我们不能依赖真实依赖项进行单元测试。最后，我们将 `callback` 函数定义为间谍。当我们为我们的测试调用
    `registerUser` 方法时，我们将间谍作为其回调传递给它。在一个有真实 `save` 方法的场景中，`save.restore()` 将将其恢复到原始状态并移除存根行为。
- en: Sinon.js also has its own assertion library built in for added functionality
    when working with spies and stubs. In this case, we will call `sinon.assert.calledWith()`
    to assert that the spy was called with the expected error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.js 还内置了自己的断言库，以便在处理间谍和存根时提供额外的功能。在这种情况下，我们将调用 `sinon.assert.calledWith()`
    来断言间谍被调用并传递了预期的错误。
- en: Mocks
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟
- en: Mocks in Sinon.js build upon both spies and stubs. They are fake methods, like
    `spies`, with the ability to add additional behaviors, like `stubs`, but also
    give you the ability to define *expectations* for the test before it is actually
    run.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.js 中的模拟建立在间谍和存根的基础上。它们是像 `spies` 一样的假方法，具有添加额外行为的能力，就像 `stubs` 一样，但还允许你在实际运行测试之前定义
    *期望*。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Mocks should only be used once per unit test. If you find yourself using more
    than one mock in a unit test, you are probably not using them as intended.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在每个单元测试中只应使用一次。如果你在一个单元测试中使用了多个模拟，那么你很可能没有按照预期使用它们。
- en: 'To demonstrate the use of a mock, let''s consider an example using the Payload.js
    `localStorage` API methods. We can define a method called `incrementDataByOne`
    that is used to increment a `localStorage` value from **`0`** to `1`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示模拟的使用，让我们考虑一个使用 Payload.js `localStorage` API 方法的例子。我们可以定义一个名为 `incrementDataByOne`
    的方法，用于将 `localStorage` 的值从 **`0`** 增加到 `1`：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that instead of defining a spy or a stub here, we will define a mock
    variable that takes the `Payload.storage` object API as its only argument. A mock
    is then created on the object to test its methods for expectations. In this case,
    we will set up our expectations that the initial value of data should return 0
    from the `Payload.storage.get` API method, and then after calling `Payload.storage.set`
    with 1, it should be incremented by 1 from its original value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们不会定义间谍或存根，而是定义一个模拟变量，它将 `Payload.storage` 对象 API 作为其唯一参数。然后，在对象上创建模拟以测试其方法是否符合期望。在这种情况下，我们将设置期望，即数据的初始值应该从
    `Payload.storage.get` API 方法返回 `0`，然后调用 `Payload.storage.set` 并传递 `1` 后，它应该从原始值增加
    `1`。
- en: Jasmine
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jasmine
- en: '*Jasmine* is another popular unit testing framework in the Node.js community,
    and it is also used for most AngularJS applications and referenced throughout
    the AngularJS core documentation. Jasmine is similar to Mocha in many ways, but
    it includes its own assertion library. Jasmine uses `expect` style assertions,
    much like the Chai `expect` style assertions, which were covered earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jasmine* 是 Node.js 社区中另一个流行的单元测试框架，它也被用于大多数 AngularJS 应用程序，并在 AngularJS 核心文档中有所引用。Jasmine
    在许多方面与 Mocha 相似，但它包含了自己的断言库。Jasmine 使用 `expect` 风格的断言，这与前面提到的 Chai `expect` 风格的断言类似：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see in this example, Jasmine uses `describe` and `it` method calls
    for its tests that are identical to those used in Mocha, so switching from one
    framework to the other is pretty straightforward. Having knowledge of both Mocha
    and Jasmine is quite useful as they are both used commonly throughout the JavaScript
    community.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本例中看到的，Jasmine 使用 `describe` 和 `it` 方法调用进行测试，这与 Mocha 中使用的相同，因此从一种框架切换到另一种框架非常直接。了解
    Mocha 和 Jasmine 都非常有用，因为它们在 JavaScript 社区中都被广泛使用。
- en: Karma test runner
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Karma 测试运行器
- en: '*Karma* is a JavaScript *test runner* that allows you to run your tests in
    browsers automatically. We have already demonstrated how to run Mocha unit tests
    in the browser manually, but when using a test runner such as `Karma`, this process
    is much easier to set up and work with.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*Karma* 是一个允许你在浏览器中自动运行测试的 JavaScript *测试运行器*。我们已经演示了如何在浏览器中手动运行 Mocha 单元测试，但当你使用像
    `Karma` 这样的测试运行器时，这个过程设置和操作起来要容易得多。'
- en: Testing with Karma, Mocha, and Chai
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Karma、Mocha 和 Chai 进行测试
- en: 'Karma can be used with multiple unit testing frameworks, including Mocha. First,
    let''s install the Node.js modules that we''ll need to work with Karma, Mocha,
    and Chai:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 可以与多个单元测试框架一起使用，包括 Mocha。首先，让我们安装我们需要与 Karma、Mocha 和 Chai 一起工作的 Node.js
    模块：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will install Karma and its Node.js plugins for Mocha and Chai to your
    local development environment and save them in your `package.json` file. Now,
    in order to have Karma launch tests in browsers on your system, we''ll need to
    install plugins for those as well, which are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的本地开发环境中安装 Karma 及其针对 Mocha 和 Chai 的 Node.js 插件，并将它们保存在你的 `package.json`
    文件中。现在，为了使 Karma 在你的系统浏览器中启动测试，我们还需要安装相应的插件，如下所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will install the `launcher` modules for the Chrome and Firefox browsers.
    If you do not have one or both of these browsers on your system, then install
    the launchers for one or two that you do have. There are Karma launcher plugins
    for all major browsers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Chrome 和 Firefox 浏览器的 `launcher` 模块。如果你系统上没有这些浏览器或其中之一，那么安装你有的一个或两个浏览器的启动器。Karma
    提供了所有主流浏览器的启动器插件。
- en: 'Next, we will need to create a config file for Karma to run our tests and launch
    the appropriate browsers. Create a file at the root of the project named `karma.conf.js`
    and add the following code to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 Karma 创建一个配置文件来运行我们的测试并启动适当的浏览器。在项目根目录创建一个名为 `karma.conf.js` 的文件，并将以下代码添加到其中：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This configuration simply tells Karma that we're using the Mocha and Chai testing
    frameworks, we want to load all JavaScript files under the test directory, and
    we want to launch the tests to run in the Chrome and Firefox browsers, or the
    browsers that you have chosen. The `singleRun` parameter tells Karma to run the
    tests and then exit, rather than continue to run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置只是告诉 Karma 我们正在使用 Mocha 和 Chai 测试框架，我们希望加载测试目录下的所有 JavaScript 文件，并且我们希望将测试启动到
    Chrome 和 Firefox 浏览器中，或者你选择的浏览器中。`singleRun` 参数告诉 Karma 运行测试然后退出，而不是继续运行。
- en: 'Now, all we have to do is run Karma from the CLI to run our tests in the defined
    browsers. As Karma is installed locally, you will have to add the relative path
    from your project root to the module in order to run it, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要从 CLI 运行 Karma 来在定义的浏览器中运行我们的测试。由于 Karma 是本地安装的，你必须添加从项目根目录到模块的相对路径才能运行它，如下所示：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice that this command also specifies the configuration file you
    want to use for your Karma instance, but it will default to the `karma.conf.js`
    file that you created at the root directory if you exclude it in the command.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个命令还指定了你想要为你的 Karma 实例使用的配置文件，但如果你在命令中省略了它，它将默认使用你在根目录中创建的 `karma.conf.js`
    文件。
- en: 'Alternatively, if you would like to run Karma from any directory globally,
    you can install the `karma-cli` module, just like you did with Grunt and `grunt-cli`
    in *[Chapter 1](ch01.html "Chapter 1. Getting Organized with NPM, Bower, and Grunt")*
    , *Getting Organized with NPM, Bower, and Grunt*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想从任何目录全局运行Karma，您可以安装`karma-cli`模块，就像您在*[第1章](ch01.html "第1章. 使用NPM、Bower和Grunt进行组织")*，*使用NPM、Bower和Grunt进行组织*中做的那样：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that you add the `-g` parameter so that `karma` is available as a
    global Node.js module.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保添加`-g`参数，以便`karma`作为一个全局Node.js模块可用。
- en: 'Now, you can simply run the following command from the CLI:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从CLI简单地运行以下命令：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running this command will open the specified browsers automatically while yielding
    an output similar to the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将自动打开指定的浏览器，并产生类似于以下命令的输出：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you follow along from the beginning of this output, you can see that Karma
    launches its own server on `port 9876` and then launches the specified browsers
    once it is running. Your two tests are run in each browser with success, thus
    a total of `4 SUCCESS` is noted in the final line of the output.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从输出的开头开始跟随，您可以看到Karma会在`端口9876`上启动自己的服务器，然后一旦启动，就会启动指定的浏览器。您的两个测试在每个浏览器中都会成功运行，因此输出最后的一行记录了总共`4
    SUCCESS`。
- en: The reason for doing this type of testing is so that your unit tests can run
    in multiple browsers and you can ensure that they pass in all of them. With frontend
    JavaScript, there is always the possibility that one browser will work differently
    than another, so as many scenarios as possible should be tested so you can be
    sure that your app won't have bugs in some browsers that may be experienced by
    any end users with those browsers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此类测试的原因是让您的单元测试可以在多个浏览器中运行，并确保它们在所有浏览器中都能通过。在前端JavaScript中，总有可能一个浏览器的工作方式与另一个不同，因此应该尽可能多地测试各种场景，以确保您的应用程序在可能使用这些浏览器的任何最终用户中都不会出现错误。
- en: This is also a great way to help you define the browsers you want to support
    for your application and which browsers you may want to detect and notify the
    user that it is not supported. This is a common practice when you want to use
    modern JavaScript techniques and methods that may not be supported by older, outdated
    browsers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种很好的方式来帮助您定义您想要支持的应用程序浏览器，以及您可能想要检测并通知用户不支持哪些浏览器。当您想要使用可能不被较老、过时的浏览器支持的现代JavaScript技术和方法时，这是一种常见的做法。
- en: Testing AngularJS with Karma and Jasmine
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Karma和Jasmine测试AngularJS
- en: 'The AngularJS community has embraced Jasmine as its unit testing framework
    of choice, and it can also be used with Karma. Let''s install our dependencies
    to work with Karma and Jasmine now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS社区已经接受Jasmine作为其首选的单元测试框架，并且它也可以与Karma一起使用。现在，让我们安装我们的依赖项以与Karma和Jasmine一起工作：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will install the Jasmine unit testing framework and its corresponding plugin
    for Karma, saving it to your `package.json` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装Jasmine单元测试框架及其对应的Karma插件，并将其保存到您的`package.json`文件中。
- en: Now, let's install AngularJS to our sample project, simply to test example code,
    so we can learn how to apply unit testing to our actual AngularJS app.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将AngularJS安装到我们的示例项目中，只是为了测试示例代码，这样我们可以学习如何将单元测试应用到我们的实际AngularJS应用中。
- en: 'AngularJS is available on both NPM and Bower. We will use Bower for the following
    example, as this is for frontend code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS可在NPM和Bower上使用。我们将使用Bower进行以下示例，因为这是针对前端代码的：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Save `angular` as a dependency. Next, install the `angular-mocks` library as
    a development dependency:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将`angular`保存为依赖项。接下来，将`angular-mocks`库安装为开发依赖项：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `angular-mocks` library gives you the `ngMock` module, which can be used
    in your AngularJS applications to mock services. Additionally, you can use it
    to extend other modules and make them behave synchronously, providing for more
    straightforward testing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`angular-mocks`库为您提供了`ngMock`模块，您可以在AngularJS应用程序中使用它来模拟服务。此外，您还可以使用它来扩展其他模块，使它们同步行为，从而为更直接的测试提供支持。'
- en: 'Now, let''s change the `karma.conf.js` file to reflect the use of Jasmine instead
    of Mocha, and the addition of `angular-mocks`. Your configuration should look
    like the following code block:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`karma.conf.js`文件更改为反映使用Jasmine而不是Mocha，并添加`angular-mocks`。您的配置应类似于以下代码块：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have changed the `frameworks` parameter of the Karma configuration
    to use only Jasmine. Jasmine can be dropped in as a replacement for both Mocha
    and Chai because Jasmine includes its own assertion methods. Additionally, we
    have added `angular.js` and `angular-mocks.js` from the `bower_components` directory
    to our `files` array to test AngularJS code with `ngMock`. Under the test directory,
    we will load a new file named `angular-test.js`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将Karma配置中的`frameworks`参数更改为仅使用Jasmine。Jasmine可以作为Mocha和Chai的替代品添加，因为Jasmine包含自己的断言方法。此外，我们已从`bower_components`目录将`angular.js`和`angular-mocks.js`添加到我们的`files`数组中，以便使用`ngMock`测试AngularJS代码。在测试目录下，我们将加载一个名为`angular-test.js`的新文件。
- en: 'Now, let''s use Jasmine and `ngMock` to write some tests for a simplified version
    of `DashMainController`, which we wrote for the gift app in *[Chapter 10](ch10.html
    "Chapter 10. Displaying Views")* , *Displaying Views*. Create a file under the
    test directory named `angular-test.js` and add the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Jasmine和`ngMock`为`DashMainController`的简化版本编写一些测试，这是我们为礼物应用在*[第10章](ch10.html
    "第10章。显示视图")*中编写的，*显示视图*。在测试目录下创建一个名为`angular-test.js`的文件，并添加以下代码：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will load the `giftappControllers` module into memory and subsequently
    register `DashMainController`. We are excluding any other services and factories
    here to ensure the isolated testing of the controller. Next, let''s write a simple
    Jasmine test to assert that the length of the `$scope.lists` array is `2`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载`giftappControllers`模块到内存中，并随后注册`DashMainController`。我们在这里排除了任何其他服务和工厂，以确保对控制器的隔离测试。接下来，让我们编写一个简单的Jasmine测试来断言`$scope.lists`数组的长度为`2`：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the initial `describe` call for `DashMainController`, we will initialize
    a `$controller` variable that will be used to represent the AngularJS `$controller`
    service. Additionally, we will make two calls to the Jasmine `beforeEach` method.
    This allows code to be run before each test is run and do any setup that is needed.
    In this case, we will need to initialize the `giftappControllers` module, done
    in the first call to `beforeEach`, and next we must assign the local `$controller`
    variable to the AngularJS `$controller` service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`DashMainController`的初始`describe`调用中，我们将初始化一个`$controller`变量，该变量将用于表示AngularJS的`$controller`服务。此外，我们还将调用两次Jasmine的`beforeEach`方法。这允许在每次测试运行之前执行代码，并进行任何必要的设置。在这种情况下，我们需要在第一次调用`beforeEach`时初始化`giftappControllers`模块，然后必须将本地的`$controller`变量分配给AngularJS的`$controller`服务。
- en: In order to access the AngularJS `$controller` service, we will use the angular-mock
    `inject` method, which wraps a function into an injectable function, making use
    of Angular's dependency injector. This method also includes a convention in which
    you can place an underscore on each side of an argument name and it will get injected
    properly without conflicting with your local variable names. Here, we will do
    this with the `_$controller_` argument, which is interpreted by the `inject` method
    as Angular's `$controller` service. This allows us to use the local `$controller`
    variable to take its place and keep the naming convention consistent.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问AngularJS的`$controller`服务，我们将使用angular-mock的`inject`方法，该方法将一个函数包装成一个可注入的函数，利用Angular的依赖注入器。此方法还包括一个约定，即在参数名两侧放置一个下划线，它将正确注入而不会与你的本地变量名冲突。在这里，我们将使用`_$controller_`参数，该参数被`inject`方法解释为Angular的`$controller`服务。这允许我们使用本地的`$controller`变量来替代它，并保持命名约定的一致性。
- en: 'With this code in place, you are ready to run the test, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码后，你就可以运行测试了，具体步骤如下：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will yield an output similar to the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下命令的输出：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You should see that the test passed in all browsers because the length of the
    `$scope.lists` array is `2`, as the Jasmine assertion tested for.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到测试在所有浏览器中都通过了，因为`$scope.lists`数组长度为`2`，正如Jasmine断言所测试的那样。
- en: Integration testing
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: The second level of the software testing pyramid is *integration testing*. Integration
    testing involves testing at least two units of code that interact with each other,
    so in its simplest form, an integration test will test the outcome of two unit
    tests, such that they *integrate* with your application as expected.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试金字塔的第二层是*集成测试*。集成测试涉及至少测试两个相互交互的代码单元，因此在其最简单形式中，集成测试将测试两个单元测试的结果，这样它们就能按照预期与你的应用程序*集成*。
- en: The idea behind integration testing is to build upon your unit tests by testing
    larger pieces, or *components*, of your application. It is possible that all of
    your unit tests may pass because they are tested in isolation, but when you start
    testing the interaction of those units with each other, the outcome may not be
    what you expect. This is why unit testing alone is not sufficient to adequately
    test a SPA. Integration testing allows you to test key functionality in various
    components of your application before you move on to end-to-end testing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试背后的想法是通过测试更大的部分，或称为 *组件*，来构建在您的单元测试之上。所有单元测试可能都通过了，因为它们是在隔离状态下进行测试的，但当您开始测试这些单元之间的交互时，结果可能并非如您所预期。这就是为什么仅仅单元测试不足以充分测试一个单页应用程序（SPA）。集成测试允许您在进入端到端测试之前，测试应用程序各个组件中的关键功能。
- en: End-to-end testing
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: The top level of the software testing pyramid is *end-to-end testing*, abbreviated
    as E2E, and also referred to as *functional testing*. The goal of end-to-end testing
    is to test the true functionality of your application's features in their entirety.
    For example, if you have a user registration feature in your app, an end-to-end
    test will ensure that the user is able to register properly through the UI, added
    to the database, a message to the user that they were successfully registered
    displayed, and, potentially, an e-mail sent to the user, or any other follow-up
    actions that may be required by your application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试金字塔的顶层是 *端到端测试*，缩写为 E2E，也称为 *功能测试*。端到端测试的目标是在整体上测试您应用程序功能的真实功能。例如，如果您在应用程序中有一个用户注册功能，端到端测试将确保用户能够通过用户界面正确注册，添加到数据库中，显示给用户一条成功注册的消息，以及可能发送给用户的电子邮件，或者应用程序可能需要的任何其他后续操作。
- en: The angular-seed project
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: angular-seed 项目
- en: In order to demonstrate a simple AngularJS application with examples of both
    unit and end-to-end testing, AngularJS created the `angular-seed` project. It
    is an open source project that is available on GitHub. Let's install it now so
    that we can run some simple unit and end-to-end testing with AngularJS.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个简单的 AngularJS 应用程序，其中包含单元测试和端到端测试的示例，AngularJS 创建了 `angular-seed` 项目。这是一个开源项目，可在
    GitHub 上找到。现在让我们安装它，以便我们可以使用 AngularJS 运行一些简单的单元测试和端到端测试。
- en: 'Let''s clone the angular-seed repository from GitHub into a new, clean project
    directory, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 angular-seed 仓库从 GitHub 克隆到一个新的、干净的工程目录中，如下所示：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The angular-seed project has both NPM dependencies and Bower dependencies,
    but you only need to run the NPM install that will install the Bower dependencies
    for you:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: angular-seed 项目既有 NPM 依赖项，也有 Bower 依赖项，但您只需要运行 NPM install 命令，它将为您安装 Bower 依赖项：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will install many tools and libraries, some of which you have seen already,
    including Jasmine, Karma, AngularJS, and angular-mocks. Next, all you have to
    do is start the NPM server using the following command line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装许多工具和库，其中一些您已经见过，包括 Jasmine、Karma、AngularJS 和 angular-mocks。接下来，您只需使用以下命令行启动
    NPM 服务器：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will run a few tasks and then start up a Node.js server for you. You should
    see the following output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行几个任务，然后为您启动一个 Node.js 服务器。您应该会看到以下输出：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, go to http://localhost:8000 in a web browser and you will see a simple
    layout displayed. It consists of two view labels, `view1` and `view2`, with `view1`
    being displayed by default after the page loads. Each view requests a partial
    template file to be loaded upon the first view, and then caches it for any subsequent
    view.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在网页浏览器中转到 http://localhost:8000，您将看到一个简单的布局显示。它由两个视图标签 `view1` 和 `view2`
    组成，`view1` 在页面加载后默认显示。每个视图在第一次查看时请求加载一个部分模板文件，然后将其缓存以供后续查看。
- en: Let's first run the angular-seed unit tests so we can see how they are set up.
    Karma is used to launch Jasmine unit tests, just as we did with our example controller
    test earlier; however, by default, they are set with the `singleRun` property
    in `karma.conf.js` set to false, which is intended for continuous integration.
    This allows Karma to watch for changes to your code as you make them so that the
    unit tests are run each time you save a file. In this way, you will get immediate
    feedback from the test runner and know if any tests are failing, which will prevent
    you from coding too far down a broken path.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行 angular-seed 单元测试，以便我们可以看到它们的设置。Karma 用于启动 Jasmine 单元测试，就像我们之前用示例控制器测试所做的那样；然而，默认情况下，它们在
    `karma.conf.js` 中将 `singleRun` 属性设置为 false，这是为了持续集成。这允许 Karma 在你进行更改时监视你的代码，以便每次你保存文件时都运行单元测试。这样，你将立即从测试运行器获得反馈，并知道是否有任何测试失败，这将防止你走上一条错误的道路。
- en: 'To run the `angular-seed` tests in continuous integration mode, simply run
    the following NPM `test` command from the CLI:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在持续集成模式下运行 `angular-seed` 测试，只需从 CLI 运行以下 NPM `test` 命令：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will yield an output similar to the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下输出的结果：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This output shows that `5 of 5` unit tests were executed successfully. Notice
    that the command continues to run as it is in continuous integration mode. You
    will also have a Chrome browser window open that is awaiting file changes so that
    it can rerun the tests, the results of which will be immediately printed back
    to the CLI.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，`5 of 5` 单元测试已成功执行。请注意，命令会继续运行，因为它处于持续集成模式。你还将打开一个等待文件更改以便重新运行测试的 Chrome
    浏览器窗口，测试结果将立即打印回 CLI。
- en: The project also includes a command to run Karma in `singleRun` mode, as we
    did with our previous Karma examples. To do this, hit **Ctrl** + **C** to close
    the currently running Karma instance. This will shut down the Chrome browser window
    as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 项目还包括一个命令，用于以 `singleRun` 模式运行 Karma，就像我们之前的 Karma 示例一样。为此，按 **Ctrl** + **C**
    关闭当前运行的 Karma 实例。这将关闭 Chrome 浏览器窗口。
- en: 'Next, you will use the following NPM run command to launch Karma just once
    and shut back down:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用以下 NPM 运行命令一次性启动 Karma 并关闭：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You will see the same output as you did earlier, but the browser window will
    open and close, the tests will run successfully, and the CLI will bring you back
    to the command prompt.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与之前相同的输出，但浏览器窗口将打开和关闭，测试将成功运行，CLI 将带你回到命令提示符。
- en: Now that we've done some simple unit testing with the angular-seed project,
    let's move on to end-to-end testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 angular-seed 项目进行了一些简单的单元测试，让我们继续进行端到端测试。
- en: End-to-end testing with AngularJS and angular-seed
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 AngularJS 和 angular-seed 进行端到端测试
- en: AngularJS emphasizes the importance of end-to-end testing and they have their
    own testing framework, **Protractor**,to do so. Protractor is an open source Node.js
    application that is built upon WebdriverJS, or just Webdriver, a component of
    the Selenium project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 强调端到端测试的重要性，并且他们有自己的测试框架 **Protractor** 来实现这一点。Protractor 是一个基于 WebdriverJS（或简称
    Webdriver，Selenium 项目的一个组件）的 Node.js 开源应用程序。
- en: Selenium has been around for a long time and is extremely well known throughout
    the web development community. It comprises multiple tools and libraries that
    allow for web browser automation. WebdriverJS is one of those libraries, and it
    is designed to test JavaScript applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 已经存在很长时间，在 Web 开发社区中极为知名。它包含多个工具和库，允许进行网页浏览器自动化。WebdriverJS 是这些库之一，它被设计来测试
    JavaScript 应用程序。
- en: Protractor is similar to Karma, in that, it is a test runner, but it designed
    to run end-to-end tests rather than unit tests. The end-to-end tests in the angular-seed
    project are written with Jasmine and Protractor is used to launch and run them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 与 Karma 类似，它也是一个测试运行器，但它被设计来运行端到端测试而不是单元测试。angular-seed 项目中的端到端测试是用
    Jasmine 编写的，Protractor 用于启动和运行它们。
- en: 'First, we will need to install Webdriver as Protractor is built on top of it.
    The project comes with the following script to do this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 Webdriver，因为 Protractor 是建立在它之上的。项目附带以下脚本来完成此操作：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will yield an output similar to the following, installing the latest version
    of Webdriver:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于以下输出的结果，安装最新的 Webdriver 版本：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once Webdriver is installed successfully, run the following NPM server again
    with Karma running so that Protractor can interact with the web application:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功安装了 Webdriver，再次运行以下 NPM 服务器命令，同时 Karma 正在运行，以便 Protractor 可以与 Web 应用程序交互：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, as Protractor is set up to test with Chrome by default, we will need
    to bypass the Selenium server as it uses a Java NPAPI plugin that the newer versions
    of Chrome do not support. Fortunately, Protractor can test directly against both
    Chrome and Firefox, which circumvents this problem. To use a direct server connection
    with Chrome or Firefox, open the `protractor.conf.js` file in the E2E-tests directory,
    add a new configuration property named `directConnect` at the bottom, and set
    it to `true`. The Protractor config file should now look like the following block
    of code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于Protractor默认设置为使用Chrome进行测试，我们需要绕过Selenium服务器，因为它使用的是Chrome的新版本不支持的一个Java
    NPAPI插件。幸运的是，Protractor可以直接针对Chrome和Firefox进行测试，从而绕过这个问题。要使用Chrome或Firefox的直接服务器连接，打开E2E-tests目录中的`protractor.conf.js`文件，在底部添加一个名为`directConnect`的新配置属性，并将其设置为`true`。Protractor配置文件现在应类似于以下代码块：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Keep in mind that the `directConnect` setting is only intended to be used with
    Chrome and Firefox only. If you decide to run your tests in another browser, you
    will want to set it to `false`, or remove the property from the config, otherwise
    an error will be thrown. Using Chrome and Firefox to run your tests with `directConnect`
    also gives you a boost in speed when running your tests as the Selenium server
    is bypassed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`directConnect`设置仅适用于Chrome和Firefox。如果您决定在另一个浏览器中运行测试，您希望将其设置为`false`，或者从配置中删除该属性，否则将抛出错误。使用Chrome和Firefox通过`directConnect`运行测试还可以在运行测试时提高速度，因为Selenium服务器被绕过。
- en: 'Now, with the server running, open another CLI session in the angular-seed
    root directory and run the following command for Protractor:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着服务器的运行，在angular-seed根目录中打开另一个CLI会话，并运行以下命令以使用Protractor：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The console output will indicate that ChromeDriver is being used directly and
    that one instance of WebDriver is running. You should see an output similar to
    the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将指示ChromeDriver正在直接使用，并且有一个WebDriver实例正在运行。您应该看到类似于以下命令的输出：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that `3 specs` is indicated in the output? This indicates that those
    three E2E tests were run. Let's take a closer look at these tests by opening the
    `e2e-tests/scenarios.js` file in an editor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中指示的`3 specs`吗？这表示运行了这三个端到端测试。让我们通过在编辑器中打开`e2e-tests/scenarios.js`文件来更仔细地查看这些测试。
- en: 'At the beginning of this file, you will see an opening `describe` method call
    used to describe the application you are testing:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件的开始部分，您将看到一个用于描述您正在测试的应用程序的`describe`方法调用：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This `describe` block is used to contain all E2E tests for the application.
    Now, let''s examine the first test:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`describe`块用于包含应用程序的所有端到端测试。现在，让我们检查第一个测试：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This test asserts that the application will redirect the URL in the browser
    to `/#!/view1` when the `#!` route is empty. This is because the application is
    configured to auto-load the `view111` partial when it loads, so the URL should
    reflect the route to that partial when it is loaded. You will notice that this
    does indeed occur when you load the application at `http://localhost:8000` in
    your browser and it redirects to `http://localhost:8000/#!/view1`. This uses WebDriver's
    direct connection to Chrome to run the application and test the functionality
    through the `browser` API method, combined with an `expect` assertion that the
    URL matches the test path.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试断言，当`#!`路由为空时，应用程序将重定向浏览器中的URL到`/#!/view1`。这是因为应用程序配置为在加载时自动加载`view111`部分，因此URL应该在加载时反映该部分的路径。您会注意到，当您在浏览器中加载应用程序到`http://localhost:8000`时，它确实会重定向到`http://localhost:8000/#!/view1`。这使用WebDriver直接连接到Chrome来运行应用程序并通过`browser`
    API方法测试功能，并结合一个`expect`断言，断言URL与测试路径匹配。
- en: 'The second test in `scenarios.js` is a bit more verbose, as shown in the following
    block of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`scenarios.js`中的第二个测试稍微详细一些，如下面的代码块所示：'
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This test asserts that the text shown in the view for the partial route `/#!/view1`
    is in fact what it is expected to be. If you watch your developer console when
    you load the app in a browser, you will notice that it automatically makes an
    AJAX request to retrieve the local file, `view1.html`, which contains the partial
    for this view. The subsequent text that is displayed from this view is what this
    end-to-end test is looking for. This test uses the `browser` API method again,
    and additionally it uses the `element` API method to access DOM selectors, combined
    with an `expect` assertion that the text in the view matches the test string.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试断言部分路由`/#!/view1`在视图中显示的文本确实是预期的。如果你在浏览器中加载应用程序时观察开发者控制台，你会注意到它自动发起一个AJAX请求以检索本地文件`view1.html`，该文件包含此视图的部分。从此视图中显示的后续文本正是端到端测试所寻找的内容。此测试再次使用`browser`
    API方法，并额外使用`element` API方法来访问DOM选择器，结合一个`expect`断言，以检查视图中的文本是否与测试字符串匹配。
- en: 'The third and final test in `scenarios.js` is much like the second test, but
    it is used to test the text shown in the view for the partial route rendered at
    `/#!/view2`. To view that text, first click on the **view2** link in the running
    angular-seed application in your browser. You will see the URL update to view2,
    the console will show that another AJAX request is made to retrieve the local
    file view2.html, and the rendered view is updated, displaying the text (**This
    is the partial for view 2**). Now, let''s take a look at the test, which is as
    follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`scenarios.js`中的第三个也是最后一个测试与第二个测试非常相似，但它用于测试在`/#!/view2`路径上渲染的部分路由显示的文本。要查看该文本，首先在浏览器中运行的angular-seed应用程序中点击**view2**链接。你会看到URL更新为view2，控制台将显示发起了一个新的AJAX请求以检索本地文件view2.html，并且渲染的视图已更新，显示了文本（**This
    is the partial for view 2**）。现在，让我们看一下测试，如下所示：'
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For this test to work, the browser must first be directed to go to the `/#!/view2`
    route so that the respective view will be displayed. This is accomplished by the
    `beforeEach` method that is run before the `it` method call. As discussed earlier,
    Jasmine provides the `beforeEach` method for any setup that needs to occur before
    each time a test is run. In this case, it runs code directing the `browser` API
    method to perform a `get` request to the `/#!/view2` URL, which will subsequently
    update the view for the application to display the `view2` partial. Only after
    this is complete will the test be run. This test also uses the `element` API method
    to access the DOM and find the text that it is looking to match against the `expect`
    assertion that the text (**This is the partial for view 2**) is found in the view.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此测试生效，浏览器必须首先被引导到`/#!/view2`路由，以便显示相应的视图。这是通过在`it`方法调用之前运行的`beforeEach`方法实现的。如前所述，Jasmine提供了`beforeEach`方法，用于在每次运行测试之前执行任何必要的设置。在这种情况下，它运行代码，指导`browser`
    API方法执行一个`get`请求到`/#!/view2` URL，这将随后更新应用程序的视图以显示`view2`部分。只有在此完成后，才会运行测试。此测试还使用`element`
    API方法访问DOM并找到它想要与`expect`断言匹配的文本（**This is the partial for view 2**）。
- en: End-to-end testing should certainly be more thorough for a real-world application,
    but the angular-seed project is a good place to start with experimenting on both
    unit testing and end-to-end testing for an AngularJS application. Once you have
    learned how it all works, gotten familiar with the Protractor and WebDriver APIs,
    and feel comfortable using Jasmine and Protractor together, you can begin writing
    custom tests for your own AngularJS applications with confidence.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际应用来说，端到端测试肯定应该更加彻底，但angular-seed项目是一个很好的起点，可以开始尝试对AngularJS应用程序进行单元测试和端到端测试。一旦你了解了所有的工作原理，熟悉了Protractor和WebDriver
    API，并且能够自信地使用Jasmine和Protractor，你就可以开始为你的AngularJS应用程序编写自定义测试了。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the differences between unit testing, integration
    testing, and end-to-end testing and how they can, and should, all be combined
    together to provide full-fledged testing for a JavaScript SPA. You have learned
    about the Mocha and Jasmine unit testing frameworks, and how to write unit test
    with both of them, including how to write unit tests for AngularJS with Jasmine.
    You have also learned how to launch multiple browsers to test cross-browser compatibility
    of your unit tests with Karma, and about various other tools that can be added
    to your testing stack, including Chai and Sinon.js.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了单元测试、集成测试和端到端测试之间的区别，以及它们如何以及应该结合起来为 JavaScript SPA 提供全面测试。你了解了 Mocha
    和 Jasmine 单元测试框架，以及如何使用它们编写单元测试，包括如何使用 Jasmine 编写 AngularJS 的单元测试。你还学习了如何使用 Karma
    启动多个浏览器来测试单元测试的跨浏览器兼容性，以及可以添加到你的测试堆栈中的各种其他工具，包括 Chai 和 Sinon.js。
- en: Now that you have all the tools you need to build and test a JavaScript SPA,
    we will bring you to the final chapter to learn about deployment and scaling.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了构建和测试 JavaScript SPA 所需的所有工具，我们将带你进入最后一章，学习部署和扩展。
