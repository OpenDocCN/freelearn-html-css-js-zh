- en: Chapter 6. Say Cheese!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time, not so long ago, when cameras on mobile phones didn't exist.
    And then there was a time when those cameras were so bad, they were really only
    useful for snapping *reminder shots*, for example, snapping a picture of a store
    item that you wanted to look up more information about later. But now so many
    mobile devices have excellent cameras that can take fantastic pictures. In this
    project, we'll look at how to use these cameras in our own app.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this Project, we're going to build an app called `Imgn`. It won't be a complete
    app; all it will do is take pictures and let you view them. But there are a lot
    of things you could add on to it, such as sharing functionality or creative filters
    that could change the image after it was taken.
  prefs: []
  type: TYPE_NORMAL
- en: What this app will do, however, is show the process for taking a picture via
    the device's camera and also show the process for accessing the user's photo album
    so that images can be imported to the app. Like with our previous apps, we'll
    have full file management, so images can be deleted, copied, and renamed at will.
    We'll accomplish this a little differently though; we'll be implementing something
    seen in a lot of photo apps – the image grid.
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultimately, the app will let you take a picture or import one from your photo
    library, and then view it. While it sounds simple enough, the app has full image
    management, which means we'll go over how to delete, copy, and rename images as
    well. In most photo apps, there is usually the option to delete images in batches
    (say you took several blurry photos and don't want them anymore), and deleting
    images in batches with the `File` API can be a bit tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Most photo apps also use what is called the image grid, which is a grid of small
    image thumbnails that let the user see several images at once on the screen and
    scroll through them all. This grid isn't terribly hard to implement; it's really
    just a series of thumbnails that wrap using good-old HTML. Where this idea falls
    apart is that there's no functionality in PhoneGap to create a thumbnail from
    an image; which means that the images displayed as a thumbnail are really the
    full-sized image, they're just scaled down to a small thumbnail. This scaling
    introduces a lot of performance problems, and as a workaround, we'll be using
    the HTML5 `Canvas` tag to actually get some of that performance back.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be covering a lot of technologies in this project, all of which are critical
    if you're going to make a performant photo app. We'll look at how to take a picture
    and how to import one from the user's photo library – both of which are critically
    important in a large number of apps. Social apps use this kind of functionality
    quite often, but there are other apps that do so as well.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we'll be covering file management, which is never that easy. In this
    project, we'll be introduced to the idea of a wrapper for the `File` API, which
    should make dealing with files just a little bit easier. Ultimately, though, we
    still have to get a bit tricky when dealing with files, so be prepared to twist
    your brain inside out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be working with something that''s gaining a lot of traction in the mobile
    web world: the **HTML5 Canvas**. It''s been used to great effect in desktop websites,
    but only now have our mobile devices started to become fast enough to use Canvas
    in interesting ways.'
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in all our previous tasks, we''re going to approach this using our tried-and-true
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the documents view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the image view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get started, you'll need to create the project as you've done in
    each project so far. You should also take a look at the resources directory in
    the project files for this project. We've got several icon files that you might
    find interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface and the look and feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conceptually, this is a pretty simple app from a user interface perspective.
    If you've seen a photo app on a phone, chances are you already know where we're
    headed. Even so, let's design a mockup, and then flesh that out a bit to come
    up with the assets we'll need for our look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine the mockups for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left-most screen is simply a grid (1) of all the images that the user has
    added to the app. These images might be taken with the camera, or they might have
    been imported in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the navigation bar, we'll have a fancy title – photo apps, for some reason,
    seem to call for something less utilitarian than some of our apps have been lately.
    We'll also be including an **Edit** button that can also change state to a **Done**
    button (2). This button indicates the current state; if a user taps **Edit**,
    the images will become selectable for batch operations such as a *delete* operation.
    In this mode, the button switches to **Done**. If the user taps the button again,
    they will exit selection mode, and the button will indicate **Edit** once again.
    Any selections the user made will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: It's been a little while since we had a toolbar (3), too. We'll show various
    icons here depending upon the current editing state. If we're not in selection
    mode (the navigation bar button shows **Edit**), we'll show a camera and a film
    roll. These two icons will allow interaction with the camera and photo album,
    respectively. If we are in the selection mode (the navigation bar button shows
    **Done**), and have at least one image selected, we'll show a trashcan icon and
    a person icon indicating *delete* and *share*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If we aren't in a selection mode, the user can tap an image to see it enlarged.
    At this point, we'll move to the right-most screen seen in the preceding screenshot.
    The navigation bar will have a **Back** button (4). The image will be displayed
    in the content area (5). If the image is larger than the screen, it will be able
    to scroll. In the toolbar (6), we'll provide a way to delete the image, or to
    share it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve gone over the mockups, let''s flesh things out a bit more.
    Here''s the final result after doing some work in our favorite graphics editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the basic elements of all our apps are present, it's clear that they've
    been spruced up quite a bit. The navigation bar has been given a fresh coat of
    paint and a playful font for the title of the app. The toolbar has also been given
    a nice upgrade to a darker color.
  prefs: []
  type: TYPE_NORMAL
- en: Each image will be given a simple white border and a drop shadow to help it
    stand out from the background. These effects are easily achieved using CSS, so
    we won't need images for this particular part.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the app though, it's a different story. We'll have four icons,
    namely, a camera, a film roll, a trashcan, and a person. These icons will always
    reside in the toolbar and can be tapped to perform an action. The navigation bar
    and toolbar itself will also need to be a graphical asset. These would be quite
    difficult to render using CSS alone (especially since there is some subtle *noise*
    in both to give them some texture). Finally, the title itself needs to be an image
    asset since the font we've used may not be available on the device. About the
    only thing other than the photos themselves on this workup that we can do without
    images is the **Edit** button on the navigation bar. We'll be using the same CSS
    we've been using to accomplish the display of the button.
  prefs: []
  type: TYPE_NORMAL
- en: The second screen of this app, the image view, isn't mocked up here – all it
    would be is a large image in the middle with the rest of the design unchanged.
    The two icons would be the trashcan and the person in the toolbar, but that's
    about all that's different.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've determined what needs to be a graphical asset, it's time to splice
    them out of our mockup. You can see the final result in the `www/images` directory
    of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We made the title its own image separate from the navigation bar. This is because
    the navigation bar is free to tile and we wouldn't want the title to tile along
    with it!
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we've mocked up the user interface and detailed how everything
    works together. We've also fleshed out the mockup so that we were able to generate
    the image assets we'll need for the implementation of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first time, our data model is going to be remarkably simple. There's
    really not a lot to keep track of here. In a way, our data model is exactly replicated
    by what is in persistent storage—the images themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in prior tasks, we do have a document collection model that reads
    all the images in persistent storage and lets our document view interact with
    them. There has been almost no change in this particular model (save for the name),
    so we won't cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: What we will cover is not quite a data model, but still important. When a user
    taps the **Edit** button, we want them to be able to select multiple pictures
    for a batch operation (such as delete). To do this, we need to keep track of which
    images are selected, and which ones aren't.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model itself is so simple that it doesn''t actually have its own code file.
    It''s just an array combined with a single property that indicates if we are in
    selection mode or not. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inSelectionMode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedItems[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it. Dreadfully simple, yes, but it is important to understand how this
    works to provide a selection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: When the app begins, we won't be in the selection mode, so `inSelectionMode`
    will be `false`. If the user taps **Edit**, we change this to `true`, and change
    the color of the borders around all the images to a light yellow color. The color
    itself really doesn't matter; it's done simply to show that the device responded
    to the tap and that all the images are currently not selected (we'll use red to
    indicate selected images). This also means the `selectedItems` array will also
    be blank.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways we could approach how to keep track of which images are selected.
    We could set up an array that had as many items as images on the screen. This
    would work, but chances are pretty good that most of these images would remain
    unselected throughout the selection operation. Unless the user is intending to
    delete all the images (which, while possible, is something that doesn't happen
    very often), there's really no need to waste all that space.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we'll keep a track of these selections using a `sparse` array; each
    item in the array will instead point to the image that is selected. That means,
    if we select three images, the array only needs to be three items long. Any image
    not contained within the array can be considered to be unselected, and those that
    are in the array are considered selected.
  prefs: []
  type: TYPE_NORMAL
- en: This does present a few difficulties in how to manage this array, though. Thankfully
    it's not too hard to get one's head around.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that the user taps on image 3 while in selection mode. First we'll
    change the border color to something striking (red, in our example) to indicate
    that we *heard* the user. Then we'll use the `push` method of the array to add
    the image to the selection. At this point our array contains exactly one item
    with the value of `3`. The user goes on to select a few more items, and say we
    finally end up with an array of `3`, `1`, `9`. This means images 1, 3, and 9 are
    selected. (Notice that the order simply doesn't matter.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's imagine that the user taps image 1 again. It's already selected,
    so we should unselect it. To do this, we need to remove the second item of the
    array so that we're left with an array of `3`, `9`. JavaScript makes it really
    easy to do this, though the names of the methods might not be immediately obvious.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll use `indexOf` to find where `1` is in the array. Once we've found
    the location, we'll use `splice()` to tell JavaScript to remove that particular
    item. The `splice()` method can be used for really cool array operations, but
    it also does item removal particularly well.
  prefs: []
  type: TYPE_NORMAL
- en: With these three methods on the array, we can track the selection state of any
    image. If we can't find the image in the array, we know it isn't selected. If
    we do find the image in the array, we know it is selected. And that's really all
    we need to know.
  prefs: []
  type: TYPE_NORMAL
- en: When the user is done with their selection, they have the option to do something
    with it. This is where things can get a little dicey. Let's say they want to delete
    several images at once. The `File` API is a bit painful, as we've seen from previous
    tasks, and now we have to figure out a way to call it several times in a row.
    In other programming languages with synchronous file operations, we'd use a simple
    `for` loop, but we don't have that luxury with the `File` API provided by PhoneGap,
    since it is an asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing the user can do is end their selection, which they can do by
    tapping on **Done**. When this occurs, we will change all the image borders back
    to white to indicate that we've heard the user, and to also indicate that any
    selected images are now unselected.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we've examined a simple data model that keeps track of selections
    in an array. We've discussed how we'll use `push()`, `indexOf()`, and `splice()`
    to maintain this array, and how all this will appear to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Since this model is so simple, we've not bothered to give it a separate file;
    we'll make it a part of the document view that we'll implement next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the document view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there are portions of our document view that are the same as or similar
    to the previous projects, there is also quite a bit that is different. The view
    has to handle taking pictures, importing them, and then dealing with the user
    selecting several pictures at once in advance of a batch operation. This means
    there is quite a bit going on, even if the underlying model is pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the view will look, first for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the document view](img/9403_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the document view](img/9403_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our view is located in `www/views/documentsView.html` in the files for this
    project if you want to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, let''s start with the HTML portion of our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is similar to the document views in previous projects. The
    `div` element `documentsView_title` has an in-line style to bring the title image
    down a bit; otherwise, it would align to the top of the navigation bar. The rest
    of the changes rest in the `div` classed `toolBar` where we have four icons defined,
    namely the photo (`photo_64.png`) icon, the film (`film_64.png`) icon, the trash
    (`trash_64.png`) icon, and the person (`man_64.png`) icon. As these icons aren't
    going to change based on localization, it is safe to put them here rather than
    define the content in `initializeView()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at our template that we will use for each image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the simplest template we've had in quite some time. All that
    is contained within is a `canvas` tag with a unique `id` value and a `click` handler.
    Don't let the simplicity fool you that we use a `canvas` tag rather than an `img`
    tag means that we have to have code that draws images to the `canvas` tag later
    on. The gains, however, that using `canvas` brings is worth this extra code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have given the `canvas` tag a specific `width` and `height`; this gives it
    a defined shape until we can later override it with the actual image width and
    height. This is simply to make a smoother transition from an unloaded image to
    a loaded image.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the HTML out of the way, let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of these properties just used are the ones we''re familiar with from previous
    projects. However, there are three that are important to this particular project,
    mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inSelectionMode`: This indicates if the user has placed us into the selection
    mode. In the selection mode, the user can select multiple images for a batch operation
    (such as a delete operation), whereas outside of the selection mode, tapping the
    image results in viewing it larger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectedItems`: This is an array, as discussed in the previous task, it contains
    the selected images. This is a *sparse* array, as it only contains those images
    actually selected and not those that are unselected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalAlert`: This is a placeholder for an alert. We''ll use this when doing
    a batch delete. If the user happens to delete several images at once, it might
    take a few seconds, and so we want to be able to display an alert over the action
    going on underneath.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this, we have the initialization code for the view given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So far, not much is different than in our previous projects. In the preceding
    code, we've added text and code to the **Edit** button – if tapped, we'll call
    `toggleSelection()`, which will switch the selection modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll define the handlers for each icon on the toolbar using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've not attached a touch listener to the **Share** button for now. Refer to
    [Project 2](ch02.html "Chapter 2. Let's Get Social!"), *Let's Get Social!* if
    you want to implement sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Something important to note is that the last two icons are set to a `display`
    of `none`, which means they won't show up on the screen. This is because they
    only apply to selected images and there's no need to display them if they can't
    do anything. When we change selection modes and at least one image is selected,
    we'll re-display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the view initialized, let''s look at `toggleSelection()`. This is the
    handler for when the user taps the **Edit** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do (given the name of the method) is to switch selection
    modes. We''ll take advantage of how Booleans work to simply switch the value:
    if it is `false` coming in, we''ll switch it to `true`, and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the preceding code, if we're now in the selection mode, we'll alter
    the **Edit** button to display **Done** so that the user knows how to end the
    selection mode. Next we empty the `selectedItems` array so that any previous selections
    are wiped out. Since we're using the image borders to indicate selection state,
    we need to iterate through each image and set its border to the unselected state
    (light yellow). Finally, we hide all the icons in the toolbar as none of them
    are immediately applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if we're ending a selection, we need to switch the **Done**
    button back to **Edit** and then turn all the image borders back to white. We
    also have to re-enable the first two icons (camera and import) since they now
    apply to our current state. The last two icons are hidden (since they may have
    been visible just prior to ending the selection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching the selection mode, of course, isn''t sufficient to actually implement
    selection, so let''s look at `documentContainerTapped()`, which is called every
    time an image is tapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Tapping on an image means different things based on whether or not we''re in
    the selection mode. If we are in the selection mode, tapping on it should either
    select the image (if not previously selected), unselect the image (if previously
    selected), and then update the toolbar; this is done using the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To determine if the image is selected, we use `indexOf()`. If the image is in
    the array, we know the image is currently selected; therefore, tapping on it should
    deselect it and we change the border color to light yellow and remove the image
    from the `selectedItems` array using the `splice()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the image isn't found in the `selectedItems` array, we know we need to select
    it, so we change the border color (red) and add it to the array via the `push()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether or not we selected or deselected the image, we need to
    handle the toolbar. If we've selected at least one image, we'll display the *delete*
    and *share* icons. If the selection ever becomes empty, we'll hide them again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we're not in the selection mode, tapping on the image should move to the
    image view so that we can see it at full size. We push the view first, then after
    `500` ms we actually tell the view what image to display. This may seem odd at
    first (normally we'd do this in the opposite order), but it is intended to smooth
    the transition to the new view. Images obtained from the camera can be quite large,
    and loading that image takes some time. If it is loading at the same time as the
    transition, the transition will stutter, making the app feel slower than it really
    is. So instead, we wait until the transition will be over, and then tell the view
    to load the image.
  prefs: []
  type: TYPE_NORMAL
- en: With selection out of the way, let's look at how we take and import pictures.
    Essentially these actions are the same thing, only the source of the image is
    different. Of course, to the user, they are very different. One involves taking
    a picture (framing the picture, waiting for the right moment, pressing the shutter
    release, and so on) while the other only involves the user searching for an image
    already on their camera. But to the app, they are technically the same thing with
    different image sources. Because of this, we'll have three methods, the first
    two to determine what the image source is, and the final one to do the actual
    work of taking or importing the image.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First up, taking a picture. We'll call `doPicture()` with the source of `CAMERA`,
    which indicates that the picture is to be obtained from the device camera. The
    user interface will vary based on the platform and device, but we don't need to
    worry about that as PhoneGap provides the interface for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To import a picture, we call `doPicture()` with the source of `PHOTOLIBRARY`.
    This indicates that the image should come from the user's own library of images.
    Again, the user interface will vary based on the platform and device, but our
    app doesn't have to worry about that as PhoneGap will handle all the details for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are several layers of callbacks going on in this function, each of which
    relies on the previous step being executed correctly. Let's look at the outer
    layer for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take an image, or import one, we call `navigator.camera.getPicture()` with
    three parameters: the `success` function, the `failure` function, and the options.
    The options in our function are at the very end of the method. Here''s what each
    one means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quality`: This is the compression used for the image. We use `50` because
    it is a good tradeoff between quality and file size. Furthermore, some devices
    have problems handling images from the camera with a quality higher than 50\.
    (Typically, on devices that exhibit problems with a quality larger than 50, the
    app would crash. Not a good end-user experience.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destinationType`: It determines the destination. There are two options here:
    we can either request a base64-encoded string which represents the image data,
    or we can request the file location where the image was saved. We''re requesting
    the file location instead of base64, simply due to ease of handling and memory
    concerns. (Base64 is at least double the file size of the image.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sourceType`: It determines where the image should come from. If set to `CAMERA`,
    it will get the image from the camera. If `PHOTOLIBRARY`, it will get it from
    the user''s library. Note that we take the incoming parameter here, which is what
    `takePicture()` and `importPicture()` send to us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encodingType`: This is the image format, generally either JPEG or PNG. PNGs
    are great for images with a lot of pixel repetition (such as diagrams), and are
    lossless. For photography, however, PNGs would be too large. Instead, we''ll use
    JPEGs. Though lossy, they won''t be so large as to be unwieldy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mediaType`: The camera can often be used to take video instead of a still
    image. In this case, all we want is a still image, so we send `PICTURE`. This
    also limits the available formats when importing an image. Without this, a user
    could import a video instead, which we can''t handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`correctOrientation`: This parameter can be used to correct the orientation
    used to take an image. For example, if the phone was rotated and we didn''t correct
    the orientation, the image might appear sideways or upside-down. With this enabled,
    we get the image right-side up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saveToPhotoAlbum`: This can be either `true` or `false`. If `true`, the image
    taken by the camera will be saved to the photo album and our app. If `false`,
    only our app receives the image. While we use `false` here, it is really a matter
    of choice. Does it make sense for the image to be saved to the album as well as
    your app? The answer to that question depends on your app and its target audience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we move into the `success` function for `navigator.camera.getPicture()`,
    we see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The file given to us by the camera may be in a temporary spot (especially on
    iOS), so we first move the file to a more permanent location. We're using the
    `PKFILE FILE` API wrapper to do this, which we'll discuss later on in this task.
    Using `doc://` here ensures that the file is written to persistent storage, and
    using the Unix Time (which is milliseconds since 1st January, 1970) ensures a
    nearly unique filename. (It's frankly impossible for the user to take two images
    in quick enough succession to end up on the same millisecond.)
  prefs: []
  type: TYPE_NORMAL
- en: When the move is complete, we call another `success` function, which simply
    reloads the available documents, which in our case redisplays the image grid with
    the new image in it.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way we also have `failure` functions where we have the `alerts`. These
    are important if, for some reason, the camera fails to take the picture, or an
    import goes badly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s handle deleting multiple pictures at once (deleting a single
    picture is done the same way we''ve deleted documents in past projects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First we ask the user if they really want to delete the selected images as the
    action is unrecoverable. If they do, we call `deleteSelectedPictures()` after
    a short delay. This delay is to give enough time for the first alert to go away
    before `deleteSelectedPictures()` puts up its own alert.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This method requires us to switch our brain inside-out a bit, since there's
    something missing we might normally expect—a `for` loop. Because the `FILE` APIs
    are all asynchronous, we can't loop around them, we need to be able to ensure
    all the API requests are finished before we tell the user we're done.
  prefs: []
  type: TYPE_NORMAL
- en: So instead, we use something akin to recursion. It's not true recursion, since
    the function calls aren't nested within each other, but it is close enough to
    be a bit painful on our neurons.
  prefs: []
  type: TYPE_NORMAL
- en: We start by checking the length of the `selectedItems` array. If it has any
    images in it, we know we need to delete one. If it has nothing in it, we know
    we've finished the job and can clean everything up.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to remove an image, we call `PKFILE.removeFile` with the full path
    to the image. We also pass along our current method to the `success` function.
    This means that once the image is successfully deleted, we'll be called again
    to repeat the process until we've deleted all images in the `selectedImages` array.
    The process will only stop when a failure occurs or when the `selectedImages`
    array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: When the `selectedImages` array is empty, we need to clean things up. We clear
    the alert we created when starting the deletion process, and we reload all our
    available documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this talk about reloading the document listing, perhaps we should
    go into that a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first portion of this function is identical to previous projects, so we''ll
    skip ahead to the interesting bits in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just like in our last project, we have a long press gesture attached to each
    image. When a long press is received, we'll display a menu allowing the user to
    delete, copy, or rename the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting bit is this next part, where we actually render the image''s
    thumbnail onto each `canvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, for each available document, we create a new `Image` object. We assign
    an `index` to a property of the object as well, because we'll need it later when
    the image is finished loading.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We then attach a method to the `onload` event of the image. This is where we'll
    render the image to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do after the image is loaded is to determine the size of
    the thumbnail. Since we want to maintain the aspect ratio, we have to know the
    image's width and height, something we can do by using `this.height` and `this.width`.
    First we assume the image will fit into a width of `84` pixels, and determine
    the height using the ratio of the height to the width. But on some images this
    might result in them being taller than `84` pixels, and so we redo the calculation
    for these images based on a height of `84` pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the thumbnail's width and height are determined, we can figure out the
    top and left so that the image is nicely centered within its 84 x 84 container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we obtain the canvas and set its width and height to the newly calculated
    values. Notice that we set both the CSS and the HTML width and height; this is
    important because the size of the canvas may actually be different on displays
    with different pixel ratios. (On a retina display the canvas is actually twice
    as large, but the CSS compresses it back to the original size visually.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we obtain a context from the canvas. We then scale the canvas to the
    pixel ratio so that we can continue to use point-based pixels on devices where
    each point is more than one pixel. Then we turn off image smoothing; this is to
    help speed up the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This line physically draws the image to the canvas at the size we calculated
    earlier. Once done, we will have a nice thumbnail instead of an empty canvas.
  prefs: []
  type: TYPE_NORMAL
- en: This operation isn't free, however; it takes time to draw the image to a smaller
    scale, but we only have to do this once (whenever we load the available documents).
    If we had used `IMG` tags for all our thumbnails, this would have had to be done
    every time something changed on the view, which would be so slow as to be unusable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we set the image's source. This triggers loading of the image, which
    will trigger the image's `onload()` method when finished. This operation isn't
    free either, but again, it only happens whenever we load the list of documents.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the view's code is very similar, if not identical, to prior projects,
    so we won't go over that code again.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've touched on quite a bit of stuff in this task. We created code that can
    take and import pictures, we worked with the HTML5 `canvas` tags, and we started
    working with a `FILE` API wrapper that makes working with files just a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned that we would discuss the `FILE` API wrapper a bit more, and here's
    as good a place as any.
  prefs: []
  type: TYPE_NORMAL
- en: Think of `PKFILE` as a convenience wrapper that makes working with files somewhat
    easier. It doesn't take away the asynchronous nature, but it does encapsulate
    some of the operations that a file operation typically has to do, getting the
    file system especially. It also gives us the ability to add in some shortcuts
    for referencing persistent and temporary storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover that last part first. Any filename that contains one of the following
    automatically gets translated to the system-specific value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doc://` is translated to `/path/to/app/persistent/storage/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp://` is translated to `/path/to/app/temporary/stora`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lhost` is replaced with `""`; the `FILE` APIs can''t handle a path starting
    with this.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `PKFILE` will translate these values in any path or filename for every
    method, we no longer have to worry about obtaining the file systems for ourselves.
    This cuts out at least one callback chain and simplifies how we refer to files
    within our own app's storage. For example, we can refer to `doc://photo.jpg` instead
    of something like `/var/something/somethingelse/app/Documents/photo.jpg`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each method in `PKFILE` takes some combination of filenames, and `success` and
    `failure` parameters. The `failure` functions are always passed an object that
    indicates the reason for failure. The `success` functions aren't passed any parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We won't go over the code for the wrapper, mainly because it isn't really anything
    you haven't seen before. If you want to take a look, it is located in `framework/fileutil.js`
    in the files available for this project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the image view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The image view itself is very simple: all it does is display a single image
    along with two icons in the toolbar (**Delete** and **Share**). Here''s how our
    view will look, first for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the image view](img/9403_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the image view](img/9403_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to follow along, the code is in `www/views/imageView.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically we''d start with the HTML for the view, but this is very similar
    to the previous project. Instead we''ll start with the template used to display
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the simplest template we've ever had. It is literally just
    an image with a specified width. The height will be inferred from the aspect ratio
    of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the template, the code is going to very simple as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We store two items: the path to the image and the index of the image. We also
    provide a method called `setImage` that others can use to tell us which image
    to load. Once called, we replace the content area with the image data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our view also supports deleting the picture being viewed. Here''s how that
    is handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We first ask the user if they are sure, and if so, we will remove the file via
    `PKFILE.removeFile()`. Once removed, we pop ourselves off the view stack because
    it doesn't make a lot of sense to be viewing an image that is now deleted. We
    also tell the `documentsView` to reload its documents, seeing as we've modified
    the file system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's one last method to cover, and that's the `viewDidHide()` method seen
    in the preceding code snippet. All we do here is clear out the content area so
    that when the image view is not being displayed, no image is sitting there hidden
    and taking up the memory. It also means the next time the view is displayed, there
    isn't an odd transition where the last loaded image is visible for a couple moments
    before the new one is loaded. (Remember, we wait a few milliseconds before loading
    in a new picture to ensure a smooth transition.)
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we implemented the image view, handled loading the image, and
    also handled deleting the image.
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, that wasn't terribly hard, was it? We have been able to take pictures
    using the in-built camera, and we've also been able to import images directly
    from the user's photo library. We've worked with displaying thumbnails via the
    HTML5 `canvas` tag to improve performance as well. Finally, we have worked a little
    with a `FILE` API wrapper to help make our code simpler to write.
  prefs: []
  type: TYPE_NORMAL
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a lot that could be done to improve the project as it stands now. Why
    don't you try a few?
  prefs: []
  type: TYPE_NORMAL
- en: Add sharing capabilities to the app. Be careful to deal with batch sharing multiple
    images, too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add filters to the images so that they can be converted to black and white,
    sepia, and more. If you want to save the files, you'll need to write a native
    plugin to save the data returned from the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed things up a bit by generating a thumbnail from each image if it doesn't
    already have one. You could store the thumbnail in local storage if you wanted,
    it wouldn't be very big, or use the `File` API to store it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
