- en: Chapter 9. Animations and Moving the Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we have seen some simple animations, but nothing
    too complex. In [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene
    with Three.js"), *Creating Your First 3D Scene with Three.js*, we introduced the
    basic rendering loop, and in the chapter following that, we used that to rotate
    some simple objects and show a couple of other basic animation concepts. In this
    chapter, we''re going to look in more detail at how animation is supported by
    Three.js. We will look in detail at the following four subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Morphing and skinning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading external animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start with the basic concepts behind animations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at the examples, let''s do a quick recap of what was shown in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Creating Your First 3D Scene with Three.js*, on the render loop. To support animations,
    we need to tell Three.js to render the scene every so often. For this, we use
    the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we only need to call the `render()` function once when were
    done initializing the scene. In the `render()` function itself, we use `requestAnimationFrame`
    to schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times a second).
    Before `requestAnimationFrame` was added to browsers, `setInterval(function, interval)`
    or `setTimeout(function, interval)` were used. These would call the specified
    function once every set interval. The problem with this approach is that it doesn't
    take into account what else is going on. Even if your animation isn't shown or
    is in a hidden tab, it is still called and is still using resources. Another issue
    is that these functions update the screen whenever they are called, not when it
    is the best time for the browser, which means higher CPU usage. With `requestAnimationFrame`,
    we don't tell the browser when it needs to update the screen; we ask the browser
    to run the supplied function when it's most opportune. Usually, this results in
    a frame rate of about 60 fps. With `requestAnimationFrame`, your animations will
    run more smoothly and will be more CPU- and GPU-friendly, and you don't have to
    worry about timing issues yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Simple animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this approach, we can very easily animate objects by changing their rotation,
    scale, position, material, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First 3D Scene with Three.js"), *Creating Your First 3D Scene with Three.js*,
    is available in `01-basic-animation.html`. The following screenshot shows this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple animations](img/2215OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The render loop for this is very simple. Just change the properties of the
    involved meshes, and Three.js handles the rest. Here''s how we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Nothing spectacular here, but it nicely shows the concept behind the basic animations
    we discuss in this book. In the next section, we'll take a quick sidestep. Besides
    animations, an important aspect, which you'll quickly run into when working with
    Three.js in more complex scenes, is the ability to select objects on screen using
    the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though not directly related to animations, since we''ll be looking into
    cameras and animations in this chapter, it is a nice addition to the subjects
    explained in this chapter. What we''ll show here is how you can select an object
    from the scene using the mouse. We''ll first look at the code required for this
    before we look at the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we use `THREE.Projector` together with `THREE.Raycaster` to determine
    whether we''ve clicked on a specific object. What happens when we click on the
    screen is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `THREE.Vector3` is created based on the position where we've clicked
    on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the `vector.unproject` function, we convert the clicked position
    on screen to coordinates in our Three.js scene. In other words, we unproject from
    screen coordinates to world coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create `THREE.Raycaster`. With `THREE.Raycaster`, we can cast rays
    into our scene. In this case, we emit a ray from the position of the camera (`camera.position`)
    to the position we clicked on in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the `raycaster.intersectObjects` function to determine whether
    any of the supplied objects are hit by this ray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result from this final step contains information on any object that is
    hit by this ray. The following information is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The mesh that was clicked on is the object, and `face` and `faceIndex` point
    to the face of the mesh that was selected. The `distance` value is measured from
    the camera to the clicked object, and `point` is the exact position on the mesh
    where it was clicked. You can test this out in the `02-selecting-objects.html`
    example. Any object you click on will become transparent and the details of the
    selection will be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the path of the ray that is cast, you can enable the `showRay`
    property from the menu. The following screenshot shows the ray that was used to
    select the blue sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting objects](img/2215OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've finished this small intermission, let's get back to our animations.
    Until now, we've changed the properties in our render loop to animate an object.
    In the next section, we'll look at a small library that makes defining animations
    a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with Tween.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called **tweening**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can use this library to change the *x* position of a mesh
    from 10 to 3 in 10 seconds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've created `TWEEN.Tween`. This tween will make sure that
    the *x* property is changed from 10 to 3 over a period of 10,000 milliseconds.
    Tween.js also allows you to define how this property is changed over time. This
    can be done using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The way the value is changed over time is called **easing**.
    With Tween.js, you configure this using the `easing()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this library from Three.js is very simple. If you open up the `03-animation-tween.html`
    example, you can see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating with Tween.js](img/2215OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we''ve taken a particle cloud from [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*, and
    animated all the particles down to the ground. The position of these particles
    is based on a tween created with the Tween.js library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this piece of code, we create two tweens: `tween` and `tweenBack`. The
    first one defines how the position property transitions from 1 to 0, and the second
    one does the opposite. With the `chain()` function, we chain these two tweens
    to each other, so these tweens will start looping when started. The final thing
    we define here is the `onUpdate` method. In this method, we walk through all the
    vertices of the particle system and change their position according to the position
    provided by the tween (`this.pos`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the tween when the model is loaded, so at the end of the following
    function, we call the `tween.start()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the tween is started, we need to tell the Tween.js library when we want
    it to update all the tweens it knows about. We do this by calling the `TWEEN.update()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With these steps in place, the tween library will take care of positioning the
    various points of the point cloud. As you can see, using this library is much
    easier than having to manage the transitions yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Besides animating and changing objects, we can also animate a scene by moving
    the camera around. In the previous chapters, we already did this a couple of times
    by manually updating the position of the camera. Three.js also provides a number
    of additional ways of updating the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three.js has a number of camera controls you can use to control the camera
    throughout a scene. These controls are located in the Three.js distribution and
    can be found in the `examples/js/controls` directory. In this section, we''ll
    look in more detail at the following controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FirstPersonControls` | These are controls that behave like those in first-person
    shooters. Move around with the keyboard and look around with the mouse. |'
  prefs: []
  type: TYPE_TB
- en: '| `FlyControls` | These are flight simulator-like controls. Move and steer
    with the keyboard and the mouse. |'
  prefs: []
  type: TYPE_TB
- en: '| `RollControls` | This is a simpler version of `FlyControls`. Allows you to
    move around and roll around the *z* axis. |'
  prefs: []
  type: TYPE_TB
- en: '| `TrackBallControls` | These are the most used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrbitControls` | This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard. |'
  prefs: []
  type: TYPE_TB
- en: 'These controls are the most useful controls available. Besides these, Three.js
    also provides a number of additional controls you can use (but which aren''t explained
    in this book). Using these controls, however, is done in the same manner as the
    ones explained in the previous table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DeviceOrientationControls` | This controls the movement of the camera based
    on the orientation of the device. It internally uses the HTML device orientation
    API ([http://www.w3.org/TR/orientation-event/](http://www.w3.org/TR/orientation-event/)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EditorControls` | These are controls that are specifically created for online
    3D editors. This is used by the Three.js online editor, which you can find at
    [http://threejs.org/editor/](http://threejs.org/editor/). |'
  prefs: []
  type: TYPE_TB
- en: '| `OculusControls` | These are controls that allow you to use an Oculus Rift
    device to look around in your scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrthographicTrackballControls` | This is the same control as `TrackBallControls`
    but specifically created to be used with `THREE.OrthographicCamera`. |'
  prefs: []
  type: TYPE_TB
- en: '| `PointerLockControls` | This is a simple control that locks the mouse using
    the DOM element on which the scene is rendered. This provides basic functionality
    for a simple 3D game. |'
  prefs: []
  type: TYPE_TB
- en: '| `TransformControls` | This is an internal control used by the Three.js editor.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `VRControls` | This is a control that uses the `PositionSensorVRDevice` API
    to control the scene. More information on this standard can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices).
    |'
  prefs: []
  type: TYPE_TB
- en: Besides using these camera controls, you can of course also move the camera
    yourself by setting `position` and change where it is pointed to using the `lookAt()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you've worked with an older version of Three.js, you might be missing a specific
    camera control named `THREE.PathControls`. With this control, it was possible
    to define a path (for example using `THREE.Spline`) and move the camera along
    that path. In the last version of Three.js, this control was removed because of
    code complexity. The people behind Three.js are currently working on a replacement,
    but one isn't available yet.
  prefs: []
  type: TYPE_NORMAL
- en: The first of the controls we'll look at is `TrackballControls`.
  prefs: []
  type: TYPE_NORMAL
- en: TrackballControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can use `TrackballControls`, you first need to include the correct
    JavaScript file into your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this included, we can create the controls and attach them to the camera,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Updating the position of the camera is something we do in the render loop,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to exactly calculate the elapsed time that
    a specific invocation or rendering loop takes to complete. You can do this by
    calling the `clock.getDelta()` function. This function will return the elapsed
    time between this call and the previous call to `getDelta()`. To update the position
    of the camera, we call the `trackballControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we use the `getDelta()` function from the `THREE.Clock`
    object. You might wonder why we don't just pass in the frame rate (1/60 seconds)
    to the `update` function. The reason is that with `requestAnimationFrame`, we
    can expect 60 fps, but this isn't guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A working example for this can be found in `04-trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TrackballControls](img/2215OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can control the camera in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Left mouse button and move | Rotate and roll the camera around the scene
    |'
  prefs: []
  type: TYPE_TB
- en: '| Scroll wheel | Zoom in and zoom out |'
  prefs: []
  type: TYPE_TB
- en: '| Middle mouse button and move | Zoom in and zoom out |'
  prefs: []
  type: TYPE_TB
- en: '| Right mouse button and move | Pan around the scene |'
  prefs: []
  type: TYPE_TB
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won't go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackballControls.js` file where these properties are listed.
  prefs: []
  type: TYPE_NORMAL
- en: FlyControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next control we''ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `05-fly-controls-camera.html`. The following screenshot shows
    a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FlyControls](img/2215OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enabling `FlyControls` works in the same manner as `TrackballControls.` First,
    load the correct JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we configure the controls and attach it to the camera, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we won''t look into all the specific properties. Look at the source
    of the `FlyControls.js` file for that. Let''s just pick out the properties you
    need to configure to get this control working. The property that needs to be set
    correctly is the `domElement` property. This property should point to the element
    in which we render the scene. For the examples in this book, we use the following
    element for our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we don't set this property correctly, moving the mouse around will result
    in strange behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the camera with `THREE.FlyControls` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Left and middle mouse button | Start moving forward |'
  prefs: []
  type: TYPE_TB
- en: '| Right mouse button | Move backwards |'
  prefs: []
  type: TYPE_TB
- en: '| Mouse movement | Look around |'
  prefs: []
  type: TYPE_TB
- en: '| W | Start moving forward |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move backwards |'
  prefs: []
  type: TYPE_TB
- en: '| A | Move left |'
  prefs: []
  type: TYPE_TB
- en: '| D | Move right |'
  prefs: []
  type: TYPE_TB
- en: '| R | Move up |'
  prefs: []
  type: TYPE_TB
- en: '| F | Move down |'
  prefs: []
  type: TYPE_TB
- en: '| Left, right, up, and down arrows | Look left, right, up, and down |'
  prefs: []
  type: TYPE_TB
- en: '| G | Roll left |'
  prefs: []
  type: TYPE_TB
- en: '| E | Roll right |'
  prefs: []
  type: TYPE_TB
- en: The next control we'll look at is `THREE.RollControls`.
  prefs: []
  type: TYPE_NORMAL
- en: RollControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RollControls` behaves much the same as `FlyControls`, so we won''t go into
    detail here. `RollControls` can be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to play around with this control, look at the `06-roll-controls-camera.html`
    example. Note that if you only see a black screen, move the mouse to the bottom
    of your browser, and the cityscape will pan into view. This camera can be moved
    around with the following controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Left mouse button | Move forward |'
  prefs: []
  type: TYPE_TB
- en: '| Right mouse button | Move backwards |'
  prefs: []
  type: TYPE_TB
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  prefs: []
  type: TYPE_TB
- en: '| W | Move forward |'
  prefs: []
  type: TYPE_TB
- en: '| A | Move left |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move backwards |'
  prefs: []
  type: TYPE_TB
- en: '| D | Move right |'
  prefs: []
  type: TYPE_TB
- en: '| Q | Roll left |'
  prefs: []
  type: TYPE_TB
- en: '| E | Roll right |'
  prefs: []
  type: TYPE_TB
- en: '| R | Move up |'
  prefs: []
  type: TYPE_TB
- en: '| F | Move down |'
  prefs: []
  type: TYPE_TB
- en: The last of the basic controls we'll look at is `FirstPersonControls`.
  prefs: []
  type: TYPE_NORMAL
- en: FirstPersonControls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![FirstPersonControls](img/2215OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Creating these controls follows the same principles as the ones followed for
    other controls we''ve seen until now. The example we''ve just shown uses the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The only properties that you should carefully look at when using this control
    for yourself are the last two: the `lon` and `lat` properties. These two properties
    define where the camera is pointed at when the scene is rendered for the first
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The controls for this control are pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mouse movement | Look around |'
  prefs: []
  type: TYPE_TB
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  prefs: []
  type: TYPE_TB
- en: '| W | Move forward |'
  prefs: []
  type: TYPE_TB
- en: '| A | Move left |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move backwards |'
  prefs: []
  type: TYPE_TB
- en: '| D | Move right |'
  prefs: []
  type: TYPE_TB
- en: '| R | Move up |'
  prefs: []
  type: TYPE_TB
- en: '| F | Move down |'
  prefs: []
  type: TYPE_TB
- en: '| Q | Stop all movement |'
  prefs: []
  type: TYPE_TB
- en: For the next control, we'll move on from this first-person perspective to the
    perspective from space.
  prefs: []
  type: TYPE_NORMAL
- en: OrbitControl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OrbitControl` control is a great way to rotate and pan around an object
    in the center of the scene. With `08-controls-orbit.html`, we''ve included an
    example that shows how this control works. The following screenshot shows a still
    image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OrbitControl](img/2215OS_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `OrbitControl` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The controls for `THREE.OrbitControls` are focused on using the mouse, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Left mouse click + move | Rotate the camera around the center of the scene
    |'
  prefs: []
  type: TYPE_TB
- en: '| Scroll wheel or middle mouse click + move | Zoom in and zoom out |'
  prefs: []
  type: TYPE_TB
- en: '| Right mouse click + move | Pan around the scene |'
  prefs: []
  type: TYPE_TB
- en: '| Left, right, up, and down arrows | Pan around the scene |'
  prefs: []
  type: TYPE_TB
- en: 'That''s it for the camera and moving it around. In this part, we''ve seen a
    lot of controls that allow you to create interesting camera actions. In the next
    section, we''ll look at a more advanced way of animation: morphing and skinning.'
  prefs: []
  type: TYPE_NORMAL
- en: Morphing and skeletal animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Morph targets**: With morph targets, you define a deformed version, that
    is, a key position, of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (the following image
    has been provided by the Blender foundation):![Morphing and skeletal animation](img/2215OS_09_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skeletal animation**: An alternative is using skeletal animation. With skeletal
    animation, you define the skeleton, that is, the bones, of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:![Morphing and skeletal animation](img/2215OS_09_10.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three.js supports both modes, but generally you'll probably get better results
    with morph targets. The main problem with skeletal animation is getting a good
    export from a 3D program like Blender that can be animated in Three.js. It's much
    easier to get a good working model with morph targets than it is with bones and
    skins.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at both options and additionally look at a couple
    of external formats supported by Three.js in which animations can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with morph targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called key frames) and
    tell Three.js to move the vertices from one position to the other. The disadvantage
    of this approach, though, is that for large meshes and large animations, the model
    files will become very large. The reason is that for each key position, all the
    vertex positions are repeated.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show you how to work with morph targets using two examples. In the first
    example, we'll let Three.js handle the transition between the various key frames
    (or morph targets as we'll call them from now on), and in the second one, we'll
    do this manually.
  prefs: []
  type: TYPE_NORMAL
- en: Animation with MorphAnimMesh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our first morphing example, we''ll use a model that is also available from
    the Three.js distribution—the horse. The easiest way to understand how a morph-targets-based
    animation works is by opening up the `10-morph-targets.html` example. The following
    screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation with MorphAnimMesh](img/2215OS_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the horse on the right-hand side is animated and running, and
    the horse on the left-hand side is standing still. This second horse (the left-hand
    side one) is rendered from the basic model, that is, the original set of vertices.
    With the menu in the top-right corner, you can browse through all the morph targets
    that are available and see the different positions the left-hand side horse can
    take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js provides a way to move from one position to the next, but this would
    mean we have to manually keep track of the current position we''re in and the
    target we want to morph into, and once we''ve reached the target position, repeat
    this for the other positions. Luckily, Three.js also provides a specific mesh,
    that is, `THREE.MorphAnimMesh`, that takes care of the details for us. Before
    we continue, here''s a quick note on another animation-related mesh provided by
    Three.js called `THREE.MorphBlendMesh`. If you look through the objects provided
    by Three.js, you might notice this object. With this specific mesh, you can do
    pretty much the same things you can do with `THREE.MorphAnimMesh`, and when you
    look at the source code, you can even see that much of it is duplicated between
    these two objects. `THREE.MorphBlendMesh`, however, seems to be deprecated and
    isn''t used in any of the official Three.js examples. Everything you could do
    with `THREE.MorhpBlendMesh` can be done with `THREE.MorphAnimMesh`, so use `THREE.MorphAnimMesh`
    for this kind of functionality. The following piece of code shows you how to load
    the model and create `THREE.MorphAnimMesh` from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same approach we saw when loading other models. This time, however,
    the external model also contains the morph targets. Instead of creating a normal
    `THREE.Mesh` object, we create `THREE.MorphAnimMesh`. There are a couple of things
    you need to take into account when loading animations:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the material you use has `THREE.morphTargets` set to `true`. If it's
    not set, your mesh won't animate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before creating `THREE.MorphAnimMesh`, make sure to call `computeMorphNormals`
    on the geometry so that all the normal vectors for the morph targets are calculated.
    This is required for correct lighting and shadow effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also possible to define colors for faces of a specific morph target. These
    are available from the `morphColors` property. You can use this to morph not just
    the shape of a geometry, but also the colors of the individual faces. With the
    `morphColorsToFaceColors` helper method, we just fix the colors of the faces to
    the first set of colors in the `morphColors` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default setting is to play the complete animation in one go. If there are
    multiple animations defined for the same geometry, you can use the `parseAnimations()`
    function together with `playAnimation(name,fps)` to play one of the defined animations.
    We'll use this approach in the last section of this chapter, where we load animations
    from an MD2 model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All that is left to do is update the animation in the render loop. For this,
    we once again use `THREE.Clock` to calculate the delta and use it to update the
    animation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This approach is the easiest and allows you to quickly set up an animation from
    a model that has morph targets defined. An alternative approach is to set up the
    animation manually as we show in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an animation by setting the morphTargetInfluence property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll create a very simple example where we morph a cube from one shape to
    another. This time, we''ll manually control which target we will morph to. You
    can find the example in `11-morph-targets-manually.html`. The following screenshot
    shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an animation by setting the morphTargetInfluence property](img/2215OS_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we''ve manually created two morph targets for a simple cube,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you open up this example, you''ll see a simple cube. With the sliders in
    the top-right corner, you can set `morphTargetInfluences`. In other words, you
    can determine how much the initial cube should morph into the cube specified as
    `mt1` and how much it should morph into `mt2`. When you create your morph targets
    by hand, you need to take into account the fact that the morph target has the
    same number of vertices as the source geometry. You can set the influence using
    the `morphTargetInfluences` property of the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the initial geometry can be influenced by multiple morph targets at
    the same time. These two examples show the most important concepts behind morph
    target animations. In the next section, we'll have a quick look at animation using
    bones and skinning.
  prefs: []
  type: TYPE_NORMAL
- en: Animation using bones and skinning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Morph animations are very straightforward. Three.js knows all the target vertex
    positions and only needs to transition each vertex from one position to the next.
    For bones and skinning, it becomes a bit more complex. When you use bones for
    animation, you move the bone, and Three.js has to determine how to translate the
    attached skin (a set of vertices) accordingly. For this example, we use a model
    that was exported from Blender to the Three.js format (`hand-1.js` in the `models`
    folder). This is a model of a hand, complete with a set of bones. By moving the
    bones around, we can animate the complete model. Let''s first look at how we loaded
    the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading a model for bone animation isn''t that different from any of the other
    models. We just specify the model file, which contains the definition of vertices,
    faces, and also bones, and based on that geometry, we create a mesh. Three.js
    also provides a specific mesh for skinned geometries like this called `THREE.SkinnedMesh`.
    The one thing you need to specify to make sure the model is updated is set the
    `skinning` property of the material you use to `true`. If you don''t set this
    to `true`, you won''t see any bone movement. The last thing we do here is that
    we set the `useQuaternion` property of all the bones to `false`. In this example,
    we''ll use a `tween` object to handle the animation. This `tween` instance is
    defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this tween, we transition the `pos` variable from `-1` to `0`. We've also
    set the `yoyo` property to `true`, which causes our animation to run in reverse
    the next time it is run. To make sure our animation keeps running, we set `repeat`
    to `Infinity`. You can also see that we specify an `onUpdate` method. This method
    is used to position the individual bones, and we'll look at this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move the bones, let''s look at the `12-bones-manually.html` example.
    The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation using bones and skinning](img/2215OS_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you open this example, you see the hand making a grab-like motion. We
    did this by setting the *z* rotation of the finger bones in the `onUpdate` method
    that is called from our tween animation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Whenever this update method is called, the relevant bones are set to the `pos`
    position. To determine which bone you need to move, it is a good idea to print
    out the `mesh.skeleton` property to the console. This will list all the bones
    and their names.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Three.js provides a simple helper you can use to show the bones of the models.
    Add the following to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The bones are highlighted. You can see an example of this by enabling the `showHelper`
    property shown in the `12-bones-manually.html` example.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, working with bones takes a bit more effort but is much more
    flexible than the fixed morph targets. In this example, we've only moved the rotation
    of the bones; you can also move the position or change the scale. In the next
    section, we look at loading animations from external models. In that section,
    we'll revisit this example, but now, we'll run a predefined animation from the
    model instead of manually moving the bones around.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations using external models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes and
    Geometries"), *Creating and Loading Advanced Meshes and Geometries*, we looked
    at a number of 3D formats that are supported by Three.js. A couple of those formats
    also support animations. In this chapter, we''ll look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blender with the JSON exporter**: We''ll start with an animation created
    in Blender and exported to the Three.js JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collada model**: The Collada format has support for animations. For this
    example, we''ll load an animation from a Collada file and render it with Three.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with the Blender model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bones animation using Blender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with animations from Blender, you can load the example we''ve
    included in the models folder. You can find the `hand.blend` file there, which
    you can load into Blender. The following screenshot shows a still image of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a bones animation using Blender](img/2215OS_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There isn''t room in this book to go into much detail on how to create animations
    in Blender, but there are a couple of things you need to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Every vertex from your model must at least be assigned to a vertex group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the vertex groups you use in Blender must correspond to the name
    of the bone that controls it. That way, Three.js can determine which vertices
    it needs to modify when moving the bones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the first "action" is exported. So make sure the animation you want to
    export is the first one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating key frames, it is a good idea to select all the bones even if
    they don't change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When exporting the model, make sure the model is in its rest pose. If this is
    not the case, you'll see a very deformed animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on creating and exporting animations from Blender and
    the reasons for the aforementioned pointers, you can look at the following great
    resource: [http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/](http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''ve created the animation in Blender, you can export the file using
    the Three.js exporter we used in the previous chapter. When exporting the file
    using the Three.js exporter, you have to make sure that the following properties
    are checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a bones animation using Blender](img/2215OS_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will export the animation you've specified in Blender as a skeletal animation
    instead of a morph animation. With a skeletal animation, the movements of the
    bones are exported, which we can replay in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the model in Three.js is the same as we did for our previous example;
    however, now that the model is loaded, we will also create an animation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To run this animation, all we have to do is create a `THREE.Animation` instance
    and call the `play` method on this animation. Before we see the animation, we
    still need to take one additional step. In our render loop, we call the `THREE.AnimationHandler.update(clock.getDelta())`
    function to update the animation, and Three.js will use the bones to set the model
    in the correct position. The result of this example (`13-animation-from-blender.html`)
    is a simple waving hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a bones animation using Blender](img/2215OS_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Besides Three.js' own format, we can use a couple of other formats to define
    animations. The first one we'll look at is loading a Collada model.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an animation from a Collada model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loading a model from a Collada file works in the same manner as for the other
    formats. First, you have to include the correct loader JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a loader and use it to load the model file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A Collada file can contain much more than just a single mode; it can store
    complete scenes, including cameras, lights, animations, and more. A good way to
    work with a Collada model is to print out the result from the `loader.load` function
    to the console and determine which components you want to use. In this case, there
    was a single `THREE.SkinnedMesh` in the scene (`child`). To render and animate
    this model, all we have to do is set up the animation just like we did for the
    Blender-based model; even the render loop stays the same. Here''s how we render
    and animate the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And the result for this specific Collada file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading an animation from a Collada model](img/2215OS_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another example of an external model, one that uses morph targets, is the MD2
    file format.
  prefs: []
  type: TYPE_NORMAL
- en: Animation loaded from a Quake model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. To use files in this format, we
    first have to convert them to the Three.js JavaScript format. You can do this
    online using the following site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://oos.moxiecode.com/js_webgl/md2_converter/](http://oos.moxiecode.com/js_webgl/md2_converter/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After conversion, you''ll get a JavaScript file in the Three.js format that
    you can load and render using `MorphAnimMesh`. Since we''ve already seen how to
    do this in the previous sections, we''ll skip the code where the model is loaded.
    One interesting thing though is happening in the code. Instead of playing the
    complete animation, we provide the name of the animation that needs to be played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that an MD2 file usually contains a number of different character
    animations. Luckily, though, Three.js provides functionality to determine the
    available animations and play them using the `playAnimation` function. The first
    thing we need to do is tell Three.js to parse the animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a list of names for the animations that can be played using
    the `playAnimation` function. In our example, you can select the name of the animation
    from the menu in the top-right corner. The available animations are determined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever an animation from the menu is selected, the `mesh.playAnimation` function
    is called with the specified animation name. The example that demonstrates this
    can be found in `15-animation-from-md2.html`. The following screenshot shows us
    a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation loaded from a Quake model](img/2215OS_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different ways that you can animate your scene.
    We started with some basic animation tricks, moved on to camera movement and control,
    and ended with animation models using morph targets and skeleton/bones animations.
    When you have the render loop in place, adding animations is very easy. Just change
    a property of the mesh, and in the next rendering step, Three.js will render the
    updated mesh.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we looked at the various materials you can use to skin
    your objects. For instance, we saw how you can change the color, shininess, and
    opacity of these materials. What we haven't discussed in detail yet, however,
    is how you can use external images (also called textures) together with these
    materials. With textures, you can easily create objects that look like they are
    made of wood, metal, stone, and much more. In the next chapter, we'll explore
    all the different aspects of textures and how they are used in Three.js.
  prefs: []
  type: TYPE_NORMAL
