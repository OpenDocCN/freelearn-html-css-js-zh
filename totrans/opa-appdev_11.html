<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Developing a Social Mobile Application &#x2013; LiveRoom"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Developing a Social Mobile Application – LiveRoom</h1></div></div></div><p>In this chapter, we will build a social mobile web application that we call LiveRoom. LiveRoom offers<a id="id358" class="indexterm"/> functionality similar to a forum. Users can login and post discussions and messages; they can also sign in with their Facebook account. The application will be able to<a id="id359" class="indexterm"/> support both mobile devices and desktop browsers. The following is a screenshot of LiveRoom and the source code is available at <a class="ulink" href="https://github.com/winbomb/opapackt/tree/master/liveroom">https://github.com/winbomb/opapackt/tree/master/liveroom</a>
</p><div class="mediaobject"><img src="graphics/3749OS_11_01.jpg" alt="Developing a Social Mobile Application – LiveRoom"/></div><div class="section" title="Project structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec55"/>Project structure</h1></div></div></div><p>First, let's <a id="id360" class="indexterm"/>have a look at the project structure. It's a<a id="id361" class="indexterm"/> classical Opa project structure; we can create a similar structure with the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>opa create liveroom</strong></span>
</pre></div><div class="mediaobject"><img src="graphics/3749OS_11_02.jpg" alt="Project structure"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">liveroom.opa</code>: The<a id="id362" class="indexterm"/> entry point of the application. It declares the database, dispatches the requests, and starts the web server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">login.opa</code>: The<a id="id363" class="indexterm"/> login module. It shows the login page, handles the <code class="literal">UserContext</code> when the user logs in and logs out, and connects to Facebook when the user tries to sign in with Facebook.</li><li class="listitem" style="list-style-type: disc"><code class="literal">model.opa</code>: The<a id="id364" class="indexterm"/> data model of the application. It defines data models and deals with database reading and writing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">view.opa</code>: The <a id="id365" class="indexterm"/>UI (user interface). It shows the pages, maps what we fetch from the database into XHTML, and then shows them on the page. And moreover, it gets the user's input and tries to insert data into the database through the <code class="literal">Model</code> module.</li><li class="listitem" style="list-style-type: disc"><code class="literal">style.css</code>: The <a id="id366" class="indexterm"/>external style sheet. It's registered when the web server starts, so we can use styles in this file application scope.</li></ul></div><p>To compile and run the application, type <code class="literal">make run</code>.</p></div></div>
<div class="section" title="Authorizing a user"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec56"/>Authorizing a user</h1></div></div></div><p>In this <a id="id367" class="indexterm"/>section, we will discuss how to make a simple <a id="id368" class="indexterm"/>sign in and sign out system that is an essential part of this forum and a subset of functionality that is frequently needed for other types of websites as well.</p><div class="section" title="Signing in and signing out"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec57"/>Signing in and signing out</h2></div></div></div><p>For simplicity, we do not provide a sign up process for the application. Users who input a <a id="id369" class="indexterm"/>non-blank username and password can log in to the system. <code class="literal">Model.auth</code> returns <code class="literal">{none}</code> if authorization fails, otherwise it returns <code class="literal">{user}</code>, where user is a value of type <code class="literal">User.t</code> containing information about the current user. Only signed in users will be able to create topics and post messages. This section will show you what you should do when users sign in. The following code fragment demonstrates the sign in, the code can be found in the <code class="literal">login.opa</code> file:</p><div class="informalexample"><pre class="programlisting">type Login.user = {unlogged} or {User.t user}
state = UserContext.make(Login.user {unlogged})
function login(_) {
username = Dom.get_value(#username)
  password = Dom.get_value(#password)
  match(Model.auth(username,password)){
  case {none}: Client.reload()
  case {some:user}: {
      UserContext.change(function(_){~{user}},state)
          Client.goto("/")
  }}
}</pre></div><p>The type <code class="literal">Login.user</code> is a sum type: <code class="literal">{unlogged}</code> means the current user has not signed in; <code class="literal">{Usert.t user}</code> means<a id="id370" class="indexterm"/> the current user has signed in and user information is stored in this record. As we can see from the second line, <code class="literal">UserContext</code> is used to manage the login state. <code class="literal">UserContext</code> is a high-level mechanism based on cookies. It is used to associate values with each client. The user's data stored in <code class="literal">UserContext</code> can only be accessed and modified by the user who owns this data. For most of our needs, we only need to use the following functions supplied by <code class="literal">UserContext</code>.</p><p>Use the <code class="literal">UserContext.make</code> function<a id="id371" class="indexterm"/> to create a <code class="literal">UserContext</code> with a default value; this is what we do in the second line.</p><p>Use the <code class="literal">UserContext.change</code> function<a id="id372" class="indexterm"/> to change the current state of the <code class="literal">UserContext</code> for this user. Note that in line nine of the previous code, we changed the state to <code class="literal">~{user}</code> after a successful authorization.</p><p>Use the<a id="id373" class="indexterm"/> <code class="literal">UserContext.remove</code> function<a id="id374" class="indexterm"/> to remove the current value. The following code removes the value when a user signs out:</p><div class="informalexample"><pre class="programlisting">function logout(_){
UserContext.remove(state)
  Client.reload()
}</pre></div><p>Use the <code class="literal">UserContext.get</code> function<a id="id375" class="indexterm"/> to get the current value of the <code class="literal">UserContext</code>. The following code uses this function to get the name of the current signed in user:</p><div class="informalexample"><pre class="programlisting">function get_user() {
  match(UserContext.get(state)){
    case {unlogged}: "anonymous"
    case ~{user}:    user.nickname
  }
}</pre></div><p>This is how we can implement a default user login. However, we can also allow the user to finish signing in with his or her Facebook or Twitter account.</p></div><div class="section" title="Signing in with Facebook"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec58"/>Signing in with Facebook</h2></div></div></div><p>Opa <a id="id376" class="indexterm"/>provides the modules FbAuth<a id="id377" class="indexterm"/> and Twitter<a id="id378" class="indexterm"/> to connect with Facebook and Twitter respectively. In the login page of LiveRoom, there is a link button that allows the user to sign in with Facebook. There are some additional steps required to authenticate with Facebook, and it is beyond the scope of this book to go into all the details of authenticating with Facebook, since we instead want to focus on the Opa language. Those who would like to know more about Facebook authentication should review the following excellent tutorial: <a class="ulink" href="https://github.com/akoprow/opa-devcamp-facebook">https://github.com/akoprow/opa-devcamp-facebook</a>.</p><p>Note that <a id="id379" class="indexterm"/>you should replace the x's in <code class="literal">login.opa</code> with your real data:</p><div class="informalexample"><pre class="programlisting">config = { 
app_id: "xxxxxxxxxxxxxxx",
api_key: "xxxxxxxxxxxxxxx",
app_secret: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
}</pre></div><p>
<code class="literal">App_id</code> and <code class="literal">app_key</code> are identical, and <code class="literal">app_secret</code> should not be shared with anyone.</p></div></div>
<div class="section" title="The application"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec57"/>The application</h1></div></div></div><p>LiveRoom<a id="id380" class="indexterm"/> is all about posting topics and messages. When users sign in, they can start discussions by creating new topics. The newly created topics will be shown in the<a id="id381" class="indexterm"/> list of most recent discussions, namely the latest discussions list. If a user clicks on a topic, he/she will enter the discussion and get a list of messages related to the topic. If he/she has signed in, he/she will be able to post a message related to the topic that he/she selected, or comment on an existing message. The following figure shows the data model of topic, message, and comment:</p><div class="mediaobject"><img src="graphics/3749OS_11_03.jpg" alt="The application"/></div><p>And here are the<a id="id382" class="indexterm"/> type definitions in Opa:</p><div class="informalexample"><pre class="programlisting">type Topic.t = {
  int   id,    //id, the primary key
  string title,    //title of the topic
  string author,  //the author
  int   posttime,  //post time
  int   lastupdate,  //last update time, 
  string lastposter,  //last poster
  int   reply,    //number of replies
  stringmap(Message.t) messages
}
type Message.t = { 
string author, string content, int posttime, 
  list(Comment.t) comments
}
type Comment.t = { string author, string content, int posttime }</pre></div><p>With these data<a id="id383" class="indexterm"/> model definitions in place, we can declare our database <code class="literal">liveroom</code>:</p><div class="informalexample"><pre class="programlisting">database liveroom {
  int     /next_id
  Topic.t /topics[{id}]
}</pre></div><p>The database path <code class="literal">next_id</code> is an integer holding the max topic id; this is a solution to simulate an auto-increment key that MongoDB does not natively support. The <code class="literal">topics</code> path stores the topics that the users users create. The primary key is the topic's id.</p><div class="section" title="Listing topics"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec59"/>Listing topics</h2></div></div></div><p>On the main <a id="id384" class="indexterm"/>page of LiveRoom, we will display recently discussed topics that were fetched from the database. In Opa this is an easy task. The following function query retrieves a specified page of topics:</p><div class="informalexample"><pre class="programlisting">function query(page){
  topics = /liveroom/topics[skip page*50;limit 50;order -lastupdate]
  DbSet.iterator(topics)
}</pre></div><p>Really simple, isn't it? As we have discussed in <a class="link" href="ch07.html" title="Chapter 7. Working with Databases">Chapter 7</a>, <span class="emphasis"><em>Working with Databases</em></span>, we can read data from the database by using a database path such as <code class="literal">/liveroom/topics</code>. The statements in square brackets are querying conditions. The query result <code class="literal">topics</code> is a dbset, we convert it into iteration in the next line, so we can loop the result in the following way:</p><div class="informalexample"><pre class="programlisting">Iter.map(function(t){
... //map a topic to an xhtml showing on the page
}, query(0))</pre></div><p>This is exactly <a id="id385" class="indexterm"/>what we do in the user interface code. Please refer to <code class="literal">list_topics</code> in the module View for details. To list messages and comments, you will also need to use similar code. First, we fetch a topic from the database for a given id:</p><div class="informalexample"><pre class="programlisting">function get(id) { 
/liveroom/topics[~{id}] 
}</pre></div><p>We then iterate on messages and comments in the module View to convert them into XHTML and display them on the page. The code is as follows:</p><div class="informalexample"><pre class="programlisting">topic = Model.get(id)
Map.iter(function(key, msg){
  ...
  List.map(function(comment){
      ...
  }, msg.comments)
}, topic.messages)</pre></div><p>Check the function <code class="literal">show_messages</code> in the module View for the complete code.</p></div><div class="section" title="Creating a topic"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec60"/>Creating a topic</h2></div></div></div><p>One of the<a id="id386" class="indexterm"/> most important use cases of LiveRoom is creating a topic. When users have signed in, they will be able to create a topic by clicking on <span class="strong"><strong>new topic</strong></span> on the main page. This will navigate users to a topic creating page where they can input the title and content. When users click on the <span class="strong"><strong>create</strong></span> button, the function <code class="literal">add_topic</code> will be invoked:</p><div class="informalexample"><pre class="programlisting">function add_topic(_){L
  topic = ...  //create a topic record from user's input
match(Model.insert(topic)){  //insert the record into database
    case {success: _}: Client.goto("/")  //go back to main page
    case {failure: f}: show_alert("{f}")  //show alert info
  }
}</pre></div><p>The<code class="literal"> add_topic</code> function<a id="id387" class="indexterm"/>
<a id="id388" class="indexterm"/> first creates a record of type <code class="literal">Topic.t</code> from the user's input. It then tries to insert the topic into the database by calling the <code class="literal">Model.insert</code> function defined as follows:</p><div class="informalexample"><pre class="programlisting">function insert(topic){
  match(next_id()){
  case {none}: {failure: "Failed to generate next id!"}
  case {some:id}:{
    /liveroom/topics[~{id}] &lt;- {topic with ~id}
    {success: id}  
  }}
}</pre></div><p>Because there is no auto-increment id in MongoDB, we use the <code class="literal">next_id</code> function to get a unique identifier. The function returns <code class="literal">{none}</code> if it fails, otherwise it returns <code class="literal">some(id)</code>, where <code class="literal">id</code> is the next identifier. In the <code class="literal">next_id</code> function<a id="id389" class="indexterm"/>, we use the Mongo API <code class="literal">MongoCommands.findAndUpdateOpa</code> to perform an atomic operation:</p><div class="informalexample"><pre class="programlisting">my_db = MongoConnection.openfatal("default")
function next_id(){
  if(?/liveroom/next_id == none) { /liveroom/next_id &lt;- 0 }
    r = MongoCommands.findAndUpdateOpa(
         my_db, "liveroom", "_default",
         Bson.opa2doc({_id : "/liveroom/next_id"}),
         Bson.opa2doc({`$inc` : { value : 1}}), 
{some : true}, {none}
  );
  match (r) {
    case { success : {string _id, int value} v }: some(v.value)
    case { failure : e }: {none}
}
}</pre></div></div><div class="section" title="Posting messages and comments"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec61"/>Posting messages and comments</h2></div></div></div><p>As we can tell from the data type <code class="literal">Topic.t</code> that we use to store messages in a string map inside a topic, we need a <a id="id390" class="indexterm"/>string key to access or update a message. In LiveRoom, we use <code class="literal">{topic id}_{system time}_{random string}</code> as a key. After inserting a message, some other fields, such as reply, need to be updated too.</p><div class="informalexample"><pre class="programlisting">function post_message(id, message){
  now = get_now()  //current time in milliseconds
  key = "{id}_{now}_{Random.string(5)}"
  /liveroom/topics[~{id}]/messages[key] &lt;- message
  /liveroom/topics[~{id}]/reply++
  /liveroom/topics[~{id}]/lastupdate = now
  /liveroom/topics[~{id}]/lastposter = message.author
}</pre></div><p>To post a comment, just <a id="id391" class="indexterm"/>append a new item to the list of comments for a given topic id and the message key:</p><div class="informalexample"><pre class="programlisting">function post_comment(id, key, comment){
  /liveroom/topics[~{id}]/messages[key]/comments &lt;+ comment
}</pre></div></div><div class="section" title="Designing for mobile devices"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec62"/>Designing for mobile devices</h2></div></div></div><p>To make sure whether <a id="id392" class="indexterm"/>our LiveRoom application is supported on mobile devices, we have to do a little more work. A viewport  metatag needs<a id="id393" class="indexterm"/> to be put into the <code class="literal">&lt;head&gt;</code> tag of the page:</p><div class="informalexample"><pre class="programlisting">header = &lt;&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt;&lt;/&gt;
xhtml = &lt;&gt;...&lt;/&gt; //the body of the page
Resource.full_page("Live Room", xhtml, header, {success}, [])</pre></div><p>Here we use <code class="literal">Resource.full_page</code> to embed the <code class="literal">viewport</code> meta tag into our page. A detailed description of this function can be found online (<a class="ulink" href="http://doc.opalang.org">http://doc.opalang.org</a>).</p><p>Next, we need to import <code class="literal">bootstrap.responsive</code> to help our application to be more responsive.</p><div class="informalexample"><pre class="programlisting">import stdlib.themes.{bootstrap, bootstrap.responsive}</pre></div><p>You can find more information about responsive Bootstrap classes on the Bootstrap home page: <a class="ulink" href="http://twitter.github.io/bootstrap/scaffolding.html#responsive">http://twitter.github.io/bootstrap/scaffolding.html#responsive</a>
</p><p>In our LiveRoom application, we use the responsive Bootstrap class <code class="literal">hide-phone</code> to hide the column <code class="literal">last poster</code> on mobile phones when listing the topics as there may not be enough width. The following code shows how we can do that:</p><div class="informalexample"><pre class="programlisting">  &lt;td align="center" class="hidden-phone"&gt;{t.lastposter}&lt;/td&gt;
  …
  &lt;th align="center" class="hidden-phone"&gt;Last Poster&lt;/th&gt;</pre></div><p>We can find the <a id="id394" class="indexterm"/>code in the function <code class="literal">main</code> of <code class="literal">view.opa</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we described how to write a social mobile web application in Opa. First, we talked about the user authorization procedure; we used <code class="literal">UserContext</code> to maintain the login state for a given client. We also mentioned how to connect with Facebook in Opa. In the next section, we discussed in detail how to implement LiveRoom, this included reading data from the database and displaying it in the webpage, and inserting user submitted topics, messages, and comments into the database. Please refer to the source code to review the complete code.</p></div></body></html>