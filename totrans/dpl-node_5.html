<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Monitoring Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Monitoring Applications</h1></div></div></div><p>Distributed systems fail often. Worse, they often fail partially. When failures occur during operations responsible for altering a system's state (for instance, a write or delete operation), how can the correct state be recovered, especially when these operations are concurrent? To make matters even worse, some operations fail silently. Partial failures, then, can put applications in an indeterminate state. It is difficult to predict how an opaque system will behave.</p><p>Consider this quote from <span class="emphasis"><em>The Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Suppose a cluster has ultra-reliable server nodes with a stellar mean time between failures (MTBF) of 30 years (10,000 days)—well beyond what is typically possible to achieve at a realistic cost. Even with these ideally reliable servers, a cluster of 10,000 servers will see an average of one server failure per day. Thus, any application that needs the entire cluster to be up to work will see an MTBF of no better than 1 day."</em></span></p></blockquote></div><p>Failure, especially on a large scale, is indifferent to the quality of your staff or your hardware. The point is that numerical ratios that seem large in common usage are less so in network environments where billions of transactions can happen in a matter of minutes or seconds and where hundreds or more separate systems are interacting. How failure evolves is often counterintuitive. It is a good idea, then, to prepare for failure, and, among other things, this means reducing the ability of any one failure to take down an entire system.</p><p>Typically, distributing the workload for a single user also requires distributing user data across many independent processes. Also, when a piece of the system fails, it must be restored in order to maintain two characteristics of the system—its capacity and any data or transactions that were in flight when the failure occurred.</p><p>In this chapter, I'll outline certain tools and tricks used to monitor what is going on across your application. We'll look at ways in which you can build your own monitoring and logging tools and discuss third-party tools. Along the way, you'll learn about the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Remotely controlling Node processes</li><li class="listitem" style="list-style-type: disc">Using New Relic to monitor servers</li><li class="listitem" style="list-style-type: disc">Catching errors</li><li class="listitem" style="list-style-type: disc">Other options for tracking and logging activity in your application</li></ul></div><div class="section" title="Dealing with failure"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Dealing with failure</h1></div></div></div><p>As we outlined in <a class="link" href="ch04.html" title="Chapter 4. Managing Memory and Space">Chapter 4</a>, <span class="emphasis"><em>Managing Memory and Space</em></span>, isolating operations and intelligently monitoring an applications help to minimize the chances of one failed subsystem taking<a id="id583" class="indexterm"/> down the larger system. In this section, we'll look at how to catch errors and exceptions within a Node program and how to gracefully shut down and/or restart a process that has become unstable individually and within clusters.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>The following <a id="id584" class="indexterm"/>comprehensive article on handling errors with Node.js is recommended:</p><p>
<a class="ulink" href="http://www.joyent.com/developers/node/design/errors">http://www.joyent.com/developers/node/design/errors</a>
</p></div></div><p>Peppering a codebase with try/catch blocks and trying to anticipate all errors can become unmanageable and unwieldy. Additionally, what if an exception you didn't anticipate occurs? How do you <span class="emphasis"><em>pick up where you left off</em></span>?</p><p>Node does not yet have a good built-in way to handle uncaught critical exceptions. This is a weakness of the platform. An exception that is uncaught will continue to bubble up through the execution stack until it hits the event loop where, like a wrench in the gears of a machine, it will take down the entire process.</p><p>One option is to attach an <code class="literal">uncaughtException</code> handler to the process itself, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">process.on('uncaughtException', function(err) {
  console.log('Caught exception: ' + err);
});
setTimeout(function() {
  console.log("The exception was caught and this can run.");
}, 1000);
throwAnUncaughtException();</pre></div><p>The output of the preceding code will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; Caught exception: ReferenceError: throwAnUncaughtException is not defined</strong></span>
<span class="strong"><strong>&gt; The exception was caught and this can run.</strong></span>
</pre></div><p>While nothing<a id="id585" class="indexterm"/> that follows our exception code will execute, the timeout will still fire as the process managed to catch the exception, thus saving itself. However, this is a very clumsy way of handling exceptions.</p><p>The <code class="literal">domain</code> module makes a good attempt at fixing this hole in Node's design. We will discuss the domain module next as a better tool to handle exceptions.</p><div class="section" title="The 'domain' module"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>The 'domain' module</h2></div></div></div><p>Error handling<a id="id586" class="indexterm"/> in asynchronous code is also difficult to<a id="id587" class="indexterm"/> trace:</p><div class="informalexample"><pre class="programlisting">function f() {
  throw new error("error somewhere!")
}
setTimeout(f, 1000*Math.random());
setTimeout(f, 1000*Math.random());</pre></div><p>Which function caused the error? It is difficult to say. It is also difficult to intelligently insert exception management tools. It is difficult to know what to do next. Node's <code class="literal">domain</code> module attempts to help with this and other exception localization issues. In this way, code can be tested and errors can be handled with more precision.</p><p>At its simplest, a <span class="strong"><strong>domain</strong></span> sets up a context within which a function or other "chunk" of code can be run such that any errors occurring within that implicit domain binding will be routed to a specific domain error handler. Take the following code as an example:</p><div class="informalexample"><pre class="programlisting">var domain = require('domain');
var dom = domain.create();
dom.on('error', function(err) {
  console.error('error', err.stack);
});

dom.run(function() {
  throw new Error("my domain error");
});
// error Error: my domain error
//  at /js/basicdomain.js:10:8
//  ...</pre></div><p>Here, we establish a domain and execute code within that domain via the <code class="literal">run</code> command within the context of that domain. This enables us to intelligently catch those exceptions, implicitly binding all event emitters, timers, and other requests created within that context.</p><p>Sometimes, a<a id="id588" class="indexterm"/> method might be created elsewhere (not within the implicit context of a given <code class="literal">domain.run</code> function call) but is nevertheless best associated <a id="id589" class="indexterm"/>with an external domain. The <code class="literal">add</code> method exists for just such explicit binding, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var dom = domain.create();
dom.on("error", function(err) {
  console.log(err);
});

var somefunc = function() {
  throw new Error('Explicit bind error');
};
dom.add(somefunc);
dom.run(function() {
  somefunc();
});
// [Error: Explicit bind error]</pre></div><p>Here, we see how a function that is not implicitly bound within the <code class="literal">run</code> context can still be added to that context explicitly. To remove an execution context from a domain, use <code class="literal">domain.remove</code>. An array of all timers, functions, and other emitters added explicitly or implicitly to a domain is accessible via <code class="literal">domain.members</code>.</p><p>In the same way that JavaScript's <code class="literal">bind</code> method binds a function to a context, the <code class="literal">domain.bind</code> method similarly allows an independent function to be bound to a domain. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var domain = require('domain');
var fs = require('fs');
var dom = domain.create();
dom.on("error", ...);
fs.readFile('somefile', dom.bind(function(err, data) {
  if(err) { throw new Error('bad file call'); }
}));
//  { [Error: bad call]
//  domain_thrown: true,
//  ...</pre></div><p>Here, we see how any function can be wrapped by a particular error domain <span class="emphasis"><em>inline</em></span>, a feature especially useful to manage exceptions in callbacks. Error objects <a id="id590" class="indexterm"/>emitted from a domain have the following <a id="id591" class="indexterm"/>special properties</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">error.domain</code>: This<a id="id592" class="indexterm"/> is the domain that handled the error.</li><li class="listitem" style="list-style-type: disc"><code class="literal">error.domainEmitter</code>: If <code class="literal">EventEmitter</code> fires an <code class="literal">error</code> event within a domain, this <a id="id593" class="indexterm"/>will be flagged.</li><li class="listitem" style="list-style-type: disc"><code class="literal">error.domainBound</code>: This<a id="id594" class="indexterm"/> is the callback that passed an error as its first argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">error.domainThrown</code>: This is a Boolean indicating whether the error was thrown or<a id="id595" class="indexterm"/> not. For example, the following callback will pass an ENOENT error as its first argument, so <code class="literal">domainThrown</code> would be false:<div class="informalexample"><pre class="programlisting">
<code class="literal">fs.createReadStream('nofile', callback)</code>
</pre></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Another method, <code class="literal">domain.intercept</code>, functions similarly to <code class="literal">domain.bind</code> but simplifies error handling in callbacks such that the developer will no longer need to repetitively check (or even set) the first argument of every callback, <code class="literal">cb(err, data)</code>, for errors. An example can be found in the <code class="literal">js/domainintercept.js</code> file in your code bundle.</p></div></div><p>You may also need to move between domains, entering and exiting them as needed. For this, we use the <code class="literal">domain.enter</code> and <code class="literal">domain.exit</code> methods. Assuming that we have set up two domains, <code class="literal">dom1</code> and <code class="literal">dom2</code>, the first emitting <code class="literal">domain 1 error</code> and the second <code class="literal">domain 2 error</code>, we can move between domain contexts, as shown here:</p><div class="informalexample"><pre class="programlisting">dom1.add(aFuncThatThrows);
dom1.run(function() {
  dom1.exit();
  dom2.enter();
  aFuncThatThrows();
});
// domain 2 error</pre></div><p>Any number of <code class="literal">enter</code> and <code class="literal">exit</code> events can be used. Note that no changes are made to the domain <a id="id596" class="indexterm"/>objects themselves—<code class="literal">exit</code> does not close the domain <a id="id597" class="indexterm"/>or do any such thing. If a domain needs to be destroyed, you should use the <code class="literal">domain.dispose</code> method, which will also try to clean up any inflight domain I/O—aborting streams, clearing timers, ignoring callbacks, and so on.</p></div><div class="section" title="Catching process errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Catching process errors</h2></div></div></div><p>Process-oriented <a id="id598" class="indexterm"/>designs are common in Node.js applications, where<a id="id599" class="indexterm"/> independent processes communicate with each other through evented streams. Errors in these channels, and in the processes themselves, must be tracked. In this section, we'll look at how to track and how to properly throw errors related to process events.</p><p>We covered the <code class="literal">child_process</code> module in <a class="link" href="ch03.html" title="Chapter 3. Scaling Node">Chapter 3</a>, <span class="emphasis"><em>Scaling Node</em></span>. Here, we will go into a little more detail about how to handle errors in child processes and their parents.</p><p>To spawn a Node program, use the <code class="literal">fork</code> method of the <code class="literal">child_process</code> module. This creates a new child process under the calling parent. Also, an IPC channel is automatically set up between the two processes, where the child calls <code class="literal">process.send</code> to send messages to its parent, and the parent can listen to <code class="literal">child.on('message')</code>. Create two files, the first named <code class="literal">parent.js</code> and the other named <code class="literal">child.js</code>:</p><div class="informalexample"><pre class="programlisting">// parent.js
var fork = require('child_process').fork;
var proc = fork('./child.js');

proc.on('message', function(msg) {
  console.log("Child sent: " + msg);
});
//  Keeps the parent running even if no children are alive.
process.stdin.resume();

// child.js
var cnt = 0;
setInterval(function() {
  process.send(++cnt);
}, 1000);</pre></div><p>The child process upon which fork has been used by the parent will increment and emit a value at a 1-second interval, which the parent will listen for and echo to your console. How do we catch an error in the child process from the parent process?</p><p>Let's cause an error in our child process by making it <code class="literal">throw</code>. Add the following line to <code class="literal">child.js</code>:</p><div class="informalexample"><pre class="programlisting">...
process.send(++cnt);
throw new Error('boom!');</pre></div><p>Running the <a id="id600" class="indexterm"/>parent process again will result in an error, and<a id="id601" class="indexterm"/> the message we set will be displayed. Typically, the parent will want to act when a child dies—such as using <code class="literal">fork</code> on a new child or logging the error, or both. To catch child errors in the parent, add the following line to <code class="literal">parent.js</code>:</p><div class="informalexample"><pre class="programlisting">proc.on('exit', function() {
  console.log("Child exited: ", arguments);
});</pre></div><p>Running the parent script again will result in the following being displayed in addition to the original error:</p><div class="informalexample"><pre class="programlisting">Child exited:  { '0': 1, '1': null }</pre></div><p>The first argument received is the exit code passed by the child process when it is terminated (if the parent had sent a kill signal, for example, <code class="literal">child.kill('SIGTERM')</code>, the second argument here would contain <code class="literal">'SIGTERM'</code>).</p><p>In addition to handling child errors from within a parent process, using the <code class="literal">Domain</code> module to catch and handle errors within the child process itself is recommended. In this way, you properly clean up after a child error and use <code class="literal">process.send()</code> to broadcast any additional error information to the parent.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>The exit codes<a id="id602" class="indexterm"/> that Node will return when a process exits abnormally can be found at <a class="ulink" href="https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes">https://github.com/joyent/node/blob/master/doc/api/process.markdown#exit-codes</a>. (Note that this is for Node 0.11.x—earlier versions always return exit code 8.)</p></div></div><p>A child process can also be created via <code class="literal">spawn</code>, which differs from <code class="literal">fork</code> in that it is not Node-specific; any OS process can be started by using <code class="literal">spawn</code>. For example, this is a roundabout way of executing the <code class="literal">ls</code> command; you should receive a directory listing when this runs:</p><div class="informalexample"><pre class="programlisting">var spawn = require('child_process').spawn;
var proc = spawn('ls',['-l']);
proc.stdout.setEncoding('utf8');
proc.stdout.on('data', function(data) {
  console.log(data)
});</pre></div><p>Note the differences from <code class="literal">fork</code>. The first argument is an OS command, and the second argument is an array of options passed to that command—the equivalent of <code class="literal">&gt; ls -l</code>. Secondly, we do not have access to a custom IPC (as with <code class="literal">fork</code>—no <code class="literal">send</code> or <code class="literal">on('message')</code>), but we do have access to the standard process pipes: <code class="literal">stdin</code>, <code class="literal">stdout</code>, and <code class="literal">stderr</code>. Because pipes will default to speaking in buffers, we have set the desired encoding and <a id="id603" class="indexterm"/>simply display any data that the spawned <a id="id604" class="indexterm"/>process writes to <code class="literal">stdout</code>.</p><p>Another way to catch subprocess errors should be clear to you. Modify the preceding code with the following:</p><div class="informalexample"><pre class="programlisting">var spawn = require('child_process').spawn;
var proc = spawn('ls',['-l', '/nonexistent/directory']);
proc.stderr.setEncoding('utf8');
proc.stderr.on('data', function(err) {
  console.log("Error", err)
});</pre></div><p>When this attempt to list the contents of a nonexistent directory is executed, you should see the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Error ls: /nonexistent/directory: No such file or directory</strong></span>
</pre></div><p>By listening on the <code class="literal">stderr</code> pipe, errors in child processes can be caught. We can also change the <code class="literal">stdio</code> settings such that errors are automatically logged to a file. Rather than catching the child output in the parent, we use <code class="literal">spawn</code> on the child using a customized <code class="literal">stdio</code> option, redirecting the child's <code class="literal">stdout</code> directly to a file:</p><div class="informalexample"><pre class="programlisting">var spawn = require('child_process').spawn;
// This will be the file we write to
var out = require('fs').openSync('./out.log', 'w+');
var proc = spawn('node', ['./spawn_child.js'], {
  // The options are: 0:stdin, 1:stdout, 2:stderr
  stdio : ['pipe', out, 'pipe']
});</pre></div><p>Next, we'll go a little deeper into logging strategies.</p></div><div class="section" title="Logging"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Logging</h2></div></div></div><p>Why log data? One<a id="id605" class="indexterm"/> answer might be that the amount of activity data a<a id="id606" class="indexterm"/> modern application produces exceeds the capacity of any one person's analytical abilities. We can't react to that much information usefully in real time. It is, therefore, necessary to store, or log, the mass of details and use smart tools to slice and sort that data into forms that we humans can comprehend. We can look for patterns in the logs and perhaps find bottlenecks or even bugs in our application, helping us improve the design of our system. We can garner business intelligence from logs, discovering usage patterns that help us understand customer preferences or ones that can help us design new features or enhance existing ones.</p><p>In what follows, I'll take you through some of the information available to all Node processes, how those might <a id="id607" class="indexterm"/>be logged using <span class="strong"><strong>UDP</strong></span>, and how to use Morgan for simple request logging.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>A popular open source project from the Etsy team for logging and statistical reporting <a id="id608" class="indexterm"/>is <span class="strong"><strong>StatsD</strong></span> (<a class="ulink" href="https://github.com/etsy/statsd">https://github.com/etsy/statsd</a>), for which there is a good Node client<a id="id609" class="indexterm"/> at <a class="ulink" href="https://github.com/sivy/node-statsd">https://github.com/sivy/node-statsd</a>.</p></div></div><p>Let's create a logging module that uses UDP. Detailed information on how UDP works was provided in <a class="link" href="ch03.html" title="Chapter 3. Scaling Node">Chapter 3</a>, <span class="emphasis"><em>Scaling Node</em></span>—go ahead and refresh your memory if necessary. The important concept to remember is that UDP achieves extremely high performance by making no guarantee that messages will arrive. Note that in 99 percent of cases, very few messages will drop, making UDP an excellent balance of speed and accuracy for applications that do not need perfect fidelity, such as logging applications.</p><div class="section" title="Logging with UDP"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec31"/>Logging with UDP</h3></div></div></div><p>The goal<a id="id610" class="indexterm"/> of our UDP logging module is to have a straightforward interface for any Node program to do logging. Also, we'll want to allow many<a id="id611" class="indexterm"/> independent processes to write to the same log file. The full code for this module can be found in the <code class="literal">udp/logger</code> folder of your code bundle.</p><p>Starting from the end, let's go over the client code first before diving into the logger itself. All clients will send (at least) a log file path, optional information about the port or host, a few handler functions if necessary, and the system will just work:</p><div class="informalexample"><pre class="programlisting">var dgram = require('dgram');
var Logger = require('./logger');

logger = new Logger({
  file : './out.log',
  port : 41234,
  host : 'localhost',
  encoding : 'utf8',
  onError : function(err) {
    console.log("ERROR: ", err);
  },
  onReady : function() {
...
  }
});</pre></div><p>We can see<a id="id612" class="indexterm"/> that our module starts a server on the port provided and is<a id="id613" class="indexterm"/> configured to notify the client of any errors as well as its ready state. By fleshing out the remaining code for <code class="literal">onReady</code>, we can also see the ways that we expect clients to hit the UDP logger:</p><div class="informalexample"><pre class="programlisting">console.log("READY");
var client = dgram.createSocket("udp4");
var udpm;
//  Flood it a bit.
for(var x=0; x &lt; 10000; x++) {
  udpm = new Buffer("UDP write #" + x);
  logger.log('Test write #' + x);
  client.send(udpm, 0, udpm.length, 41234, "localhost");
}</pre></div><p>The client will be able to either call the module's <code class="literal">log</code> function or send a UDP message directly. Also, we expect that it is possible to receive many messages. Besides, we expect that any number of processes could be logging to <span class="emphasis"><em>the same file</em></span>, so we must deal with managing a flood of messages.</p><p>The logging module is as follows:</p><div class="informalexample"><pre class="programlisting">var dgram = require('dgram');
var fs = require('fs');

module.exports = function(opts) {

  opts = opts || {};

  var file = opts.file;
  var host = opts.host || 'localhost';
  var port = opts.port || 41234;
  var encoding = opts.encoding || 'utf8';
  var onError = opts.onError || function() {};
  var onReady = opts.onReady || function() {};
  var socket = dgram.createSocket("udp4");
  var writeable = true;
  var _this = this;
  var stream;

  if(!file) {
    throw new Error("Must send a #file argument");
  }

  stream = fs.createWriteStream(file, {
    flags : 'a+'
  });
  stream.setMaxListeners(0);

  socket.bind(port, host);

  socket.on("listening", onReady);
  socket.on("error", onError);
  socket.on("message", function(msg) {
    this.log(msg.toString());
  });

  this.log = function(msg) {
    if(!stream) {
      throw new Error('No write stream available for logger.');
    }

    try {
      if(typeof msg !== 'string') {
        msg = JSON.stringify(msg);
      }
    } catch(e) {
      return onError("Illegal message type sent to #log. Must be a string, or JSON");
    };

    // You'll likely want to create retry limits here.
    //
    var writer = function() {
      if(!stream.write(msg + '\n', encoding)) {
        stream.once('drain', writer);
      }
    }
    writer();
  };
};</pre></div><p>This is <a id="id614" class="indexterm"/>all the code necessary to manage the setting up of a UDP server and <a id="id615" class="indexterm"/>our client interface. Note how the <code class="literal">log</code> function will either be called directly by a client or will be called via the <code class="literal">on('message')</code> handler of our UDP binding. This allows clients the flexibility of calling our logging server from any environment—using this module, using another language, using another server, without using this module, and so on.</p><p>The last important bit is the management of backpressure in <code class="literal">log</code>. Because many independent sources may be hitting our log file, the write stream managing that resource could be at its high watermark (<span class="emphasis"><em>full</em></span>) when we try to use <code class="literal">write</code>. When that happens, a call to <code class="literal">stream.write</code> will return <code class="literal">false</code>, which the caller should take as a signal to <span class="emphasis"><em>stop sending data</em></span>. When that happens, we bind to the <code class="literal">drain</code> event (only once—see <a class="ulink" href="http://nodejs.org/api/events.html#events_emitter_once_event_listener">http://nodejs.org/api/events.html#events_emitter_once_event_listener</a>), which is fired<a id="id616" class="indexterm"/> when the consumer (the write manager for our log file) is ready to accept more data.</p></div><div class="section" title="Logging with Morgan"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Logging with Morgan</h3></div></div></div><p>
<span class="strong"><strong>Morgan</strong></span> (<a class="ulink" href="https://github.com/expressjs/morgan">https://github.com/expressjs/morgan</a>) is <a id="id617" class="indexterm"/>an HTTP logger<a id="id618" class="indexterm"/> for the <span class="strong"><strong>Express</strong></span> framework. If logging HTTP connection data for a<a id="id619" class="indexterm"/> server is all you need, it serves very <a id="id620" class="indexterm"/>well and is easy to use. We'll close out this section with <a id="id621" class="indexterm"/>a few short examples using Express.</p><p>The following is the most basic usage of Morgan:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
var morgan = require('morgan')
var app = express()
app.use(morgan('combined'))
app.get('/', function (req, res) {
  res.send('hello, world!')
});
app.listen(8080);</pre></div><p>This code<a id="id622" class="indexterm"/> will create a server listening on port <code class="literal">8080</code> and will dump a log <a id="id623" class="indexterm"/>entry<a id="id624" class="indexterm"/> in Apache <span class="strong"><strong>Combined Log Format</strong></span> (<a class="ulink" href="http://httpd.apache.org/docs/1.3/logs.html#combined">httpd.apache.org/docs/1.3/logs.html#combined</a>) to <code class="literal">stdout</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>127.0.0.1 - - [20/Nov/2014:23:02:58 +0000] "GET / HTTP/1.1" 200 13 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.99 Safari/537.36"</strong></span>
</pre></div><p>In addition to the format parameter, Morgan also accepts various options. For example, to stream log data to a file, use the <code class="literal">stream</code> option. For this example, replace the <code class="literal">app.use</code> declaration with the following:</p><div class="informalexample"><pre class="programlisting">app.use(morgan('combined', {
  stream : require('fs').createWriteStream('./out.log')
}));</pre></div><p>Log entries will now be written to <code class="literal">out.log</code>.</p><p>The combined argument reflects one of the built-in Morgan log formatters. These formatters are composed of tokenized strings, with several tokens available by default. For example, the combined formatter interpolates the following string:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"</strong></span>
</pre></div><p>It should be clear how the preceding fully qualified output is generated via the given formatter with tokens mapping to the standard properties of the <code class="literal">ClientRequest</code> and <code class="literal">ClientResponse</code> objects managed by Node's <code class="literal">http</code> module.</p><p>Morgan logs data reflecting the states of the <code class="literal">ClientRequest</code> and <code class="literal">ClientResponse</code> objects. The <code class="literal">skip</code> option allows you to filter logging based on the state of these objects. By default, Morgan logs every request. To only log errors, you would add the following to your middleware definition:</p><div class="informalexample"><pre class="programlisting">skip: function(req, res) {
  return res.statusCode &lt; 400;
}</pre></div><p>You can also add new tokens. Here, we create one named <code class="literal">'cache'</code>:</p><div class="informalexample"><pre class="programlisting">morgan.token('cache', function(req, res) {
  return req.headers['cache-control'];
});</pre></div><p>This new token (and/or existing tokens) can be used in custom formatters:</p><div class="informalexample"><pre class="programlisting">app.use(morgan('cache-control is :cache'))</pre></div><p>Morgan is<a id="id625" class="indexterm"/> now initialized with a custom formatter that will write something <a id="id626" class="indexterm"/>like <code class="literal">cache-control is max-age=0</code> to your log.</p><p>For more information on additional built-in formatters and other advanced options, visit the project page. Given its flexibility, Morgan can be customized to satisfy many logging needs.</p><p>Other popular options are available for consideration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bunyan</strong></span> (<a class="ulink" href="https://github.com/trentm/node-bunyan">https://github.com/trentm/node-bunyan</a>): Bunyan is a simple <a id="id627" class="indexterm"/>but <a id="id628" class="indexterm"/>sufficiently powerful logging tool for most needs.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Winston</strong></span> (<a class="ulink" href="https://github.com/flatiron/winston">https://github.com/flatiron/winston</a>): The key selling point <a id="id629" class="indexterm"/>of Winston<a id="id630" class="indexterm"/> is the number of logging transport plugins it supports—you can configure it to log to Redis, a file, or a third-party service, such as <a class="ulink" href="http://loggly.com">loggly.com</a>.</li></ul></div></div></div></div></div>
<div class="section" title="Modifying behavior in changing environments"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Modifying behavior in changing environments</h1></div></div></div><p>Modifying <a id="id631" class="indexterm"/>application data in a running system has been compared to changing the engine of a jet while it is in flight. Luckily, we developers work in a virtual world where the <span class="emphasis"><em>laws of physics</em></span> are more forgiving. In this section, we will learn how to create a <span class="emphasis"><em>remote control</em></span> for your Node applications using examples demonstrating how to monitor processes remotely.</p><div class="section" title="Node REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Node REPL</h2></div></div></div><p>Node's <span class="strong"><strong>Read-Eval-Print-Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) represents the Node shell. To enter the shell prompt, enter <a id="id632" class="indexterm"/>Node via your terminal without <a id="id633" class="indexterm"/>passing<a id="id634" class="indexterm"/> a filename:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; node</strong></span>
</pre></div><p>You now have access to a running Node process and can pass JavaScript commands to this process. For example, after entering <code class="literal">2+2</code>, the shell would send <code class="literal">4</code> to <code class="literal">stdout</code>. Node's REPL is an excellent place to try out, debug, test, or otherwise play with JavaScript code.</p><p>Because REPL is <a id="id635" class="indexterm"/>a native object, programs can also <a id="id636" class="indexterm"/>use instances as a context in which to run JavaScript interactively. For example, here, we create our own custom function <code class="literal">sayHello</code>, add it to the context of an REPL instance, and start REPL, emulating a Node shell prompt:</p><div class="informalexample"><pre class="programlisting">require('repl').start("&gt; ").context.sayHello = function() {
  return "Hello"
};</pre></div><p>Entering <code class="literal">sayHello()</code> at the prompt will result in <code class="literal">Hello</code> being sent to <code class="literal">stdout</code>.</p><p>What this also means is that your Node process can expose an REPL instance to the outside world that can access that process in some way, providing a <span class="emphasis"><em>backdoor</em></span> through which you can connect to a process, modify its context, change its behavior, or even shut it down if it has gone bad in some way. Let's explore possible applications related to monitoring processes.</p><p>Create two files, <code class="literal">repl_client.js</code> and <code class="literal">repl_server.js</code>, using the following code, and run each in its own terminal window so that both terminal windows are visible to you:</p><div class="informalexample"><pre class="programlisting">/*  repl_client.js   */
var net = require('net');
var sock = net.connect(8080);
process.stdin.pipe(sock);
sock.pipe(process.stdout);</pre></div><p>The <code class="literal">repl_client</code> file simply creates a new socket connection to port <code class="literal">8080</code> through <code class="literal">net.connect</code> and pipes any data coming from <code class="literal">stdin</code> (your terminal) through that socket. Similarly, any data arriving from the socket is piped to <code class="literal">stdout</code> (your terminal). It should be clear that we have created a way to take input and send it via a socket to port <code class="literal">8080</code>, listening for any data that the socket may send back to us. The following code shows this:</p><div class="informalexample"><pre class="programlisting">/*  repl_server.js  */
var repl = require('repl')
var net = require('net')
net.createServer(function(socket) {
  var inst = repl.start({
    prompt : 'repl_server&gt; ',
    input    : socket,
    output  : socket,
    terminal  : true
  })

  inst.on('exit', function () {
    socket.end()
  })
}).listen(8080)</pre></div><p>The <code class="literal">repl_server</code> file closes the loop. We will first create a new <span class="strong"><strong>Transmission Control Protocol</strong></span> (<span class="strong"><strong>TCP</strong></span>) server with <code class="literal">net.createServer</code>, binding to port <code class="literal">8080</code> via <code class="literal">.listen</code>. The callback <a id="id637" class="indexterm"/>passed to <code class="literal">net.createServer</code> will receive a reference to the bound socket. Within the enclosure of that callback, we instantiate a new REPL instance, giving it a nice <code class="literal">prompt</code> (<code class="literal">'repl_server&gt;'</code> in this case, but it could be any string), indicating that it should both listen for <code class="literal">input</code> from, and broadcast <code class="literal">output</code> to, the passed socket reference, indicating that the socket data should be treated as <code class="literal">terminal</code> data (which has special encoding).</p><p>We can <a id="id638" class="indexterm"/>now type something, such as <code class="literal">console.log("hello")</code>, in<a id="id639" class="indexterm"/> the client terminal, and see <code class="literal">hello</code> displayed—the REPL server has executed the command we sent via our REPL client and sent back the evaluated response.</p><p>To confirm that the execution of our JavaScript commands is occurring in the <code class="literal">repl_server</code> process, type <code class="literal">process.argv</code> in the client terminal, and the server will display an object containing the current process path, which will be <code class="literal">/.../repl_server.js</code>.</p><p>Additionally, we can add custom methods to the REPL <code class="literal">context</code> that are then accessible through clients. For example, add the following line to <code class="literal">repl_server.js</code>:</p><div class="informalexample"><pre class="programlisting">  inst.context.sayHello = function() {
    return "Hello";
  }</pre></div><p>Restart the server and the client, and enter <code class="literal">sayHello()</code> in the client terminal. You will see <code class="literal">Hello</code> displayed. It should be clear from this demonstration that we have created a way to remotely monitor Node processes.</p><p>Finally, REPL provides custom commands, in particular <code class="literal">.save</code> and <code class="literal">.load</code> (the dot (<code class="literal">.</code>) prefix is intentional). The .<code class="literal">save</code> command will save the current REPL session to a file—all the commands you have sent to REPL will be written to a specified file, meaning that they can be replayed. To see this in action, open an REPL session and run some commands, building up a session history. Then, enter the following two commands:</p><div class="informalexample"><pre class="programlisting">.save test.js
.load test.js
// Session saved to:test.js
// ... the output of the session commands, replayed</pre></div><p>Now, let's <a id="id640" class="indexterm"/>create a demonstration module, which, when <a id="id641" class="indexterm"/>included in a process, opens it up to remote management via REPL.</p></div><div class="section" title="Remotely monitoring and managing Node processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Remotely monitoring and managing Node processes</h2></div></div></div><p>In your code <a id="id642" class="indexterm"/>bundle, you will find the <code class="literal">repl-monitor</code> package. This<a id="id643" class="indexterm"/> module will expose a server on a given port, which will provide the current process memory usage, allowing a remote process to read this information and send instructions to the monitored process. For this example, we'll be able to tell the process to stop storing things in memory when the process heap exceeds a limit and to start storing things again when it is back below the given threshold.</p><p>We'll also demonstrate the usefulness of <code class="literal">.load</code> to create highly dynamic monitoring solutions that can be adjusted without restarting targeted processes.</p><p>Note that creating this sort of access point in the internals of your application should be done with caution. While these techniques are very useful, you must take care to secure access to the various ports, and so on, primarily by limiting access to those within a properly secured private network.</p><p>The monitor code is as follows:</p><div class="informalexample"><pre class="programlisting">var repl = require('repl');
var net = require('net');
var events = require('events');
var Emitter = new events.EventEmitter();

module.exports = function(port) {
  net.createServer(function(socket) {
    var inst = repl.start({
      prompt : '',
      input    : socket,
      output  : socket,
      terminal  : false
    })

    inst.on('exit', function () {
      socket.end();
    })

    inst.context.heapUsed = function() {
      return process.memoryUsage().heapUsed;
    }

    inst.context.send = function(msgType, msg) {
      Emitter.emit(msgType, msg);
    }

  }).listen(port);

  return Emitter;
};</pre></div><p>This module <a id="id644" class="indexterm"/>creates REPL on a specified port and exposes two <a id="id645" class="indexterm"/>custom methods via the REPL context that clients can use. The <code class="literal">heapUsed</code> method returns a specific memory reading, and <code class="literal">send</code> is used by connecting clients to broadcast messages to monitored processes via the returned <code class="literal">EventEmitter</code> instance. It is important to note that the <code class="literal">output</code> pipe for this REPL is the connecting socket (identical to the <code class="literal">input</code> pipe). As we discussed earlier, this means that the calling process will receive the results of executing the JavaScript code it sends. We will provide more information on this later.</p><p>Next, we will create a process to be monitored, which will require the monitoring module:</p><div class="informalexample"><pre class="programlisting">var listener = require('./monitor')(8080);

store = true;
var arr = [];

listener.on('stop', function() {
  console.log('stopped');
  store = false;
})

listener.on('start', function() {
  store = true;
})

var runner = function() {
  if(store === true) {
    arr.push(Math.random()*1e6);
    process.stdout.write('.');
  }
  setTimeout(runner, 100);
};

runner();</pre></div><p>Here, we have a process that keeps adding to an array. Via the monitor module, a client can connect<a id="id646" class="indexterm"/> to this process, check memory usage, and broadcast <a id="id647" class="indexterm"/>either a start or a stop message, which this process will listen for and act upon.</p><p>The last step is to create a client that does remote process management. The control client is straightforward. We connect to REPL via a TCP (net) connection and periodically poll the memory state of the targeted process:</p><div class="informalexample"><pre class="programlisting">var net = require('net');
var sock = net.connect(8080);

var threshold = 0;
var stopped = false;
sock.on('end', function() {
  clearInterval(writer);
  console.log('**** Process ended ****');
});
//  Keep checking for memory usage, stringifying the returned object
var writer = setInterval(function() {
  sock.write('heapUsed()\n');
}, 1000);</pre></div><p>Recalling how we added the <code class="literal">heapUsed</code> method to the monitor's REPL context, we should expect some value back when we write to the REPL <code class="literal">input</code> socket. This means that we must add a data listener to <code class="literal">sock</code>:</p><div class="informalexample"><pre class="programlisting">sock.setEncoding('ascii');
sock.on('data', function(heapUsed) {

  //  Convert to number
  heapUsed = +heapUsed;

  //  Responses from commands will not be numbers
  if(isNaN(heapUsed)) {
    return;
  }

  if(!threshold) {
    threshold = heapUsed;
    console.log("New threshold: " + threshold)
  }

  console.log(heapUsed);

  //  If heap use grows past threshold, tell process to stop
  if((heapUsed - threshold) &gt; 1e6) {
    !stopped &amp;&amp; sock.write('.load stop_script.js\n');
    stopped = true;
  } else {
    stopped &amp;&amp; sock.write('.load start_script.js\n');
    stopped = false;
  }
});</pre></div><p>When we<a id="id648" class="indexterm"/> receive a memory probe reading, it is converted to <a id="id649" class="indexterm"/>an integer and checked against the threshold value (based on whatever the first reading was). If the reading exceeds a predetermined limit, we tell the process to stop allocating memory; when the memory frees up, the process is told to resume.</p><p>Importantly, the particular opportunity afforded by REPL is the ability to <span class="emphasis"><em>run a script</em></span> in the context of a remote process. Note the commands sent to <code class="literal">socket.write</code>, each of which loads an external file containing JavaScript:</p><div class="informalexample"><pre class="programlisting">// Stop script
send("stop")
// Start script
send("start")</pre></div><p>While these <span class="emphasis"><em>one-liners</em></span> simply exercise the messaging interface we discussed earlier, there is nothing that stops your implementation from using a much longer list of commands in the service of more realistic deployment needs. Crucially, this decoupling of process <a id="id650" class="indexterm"/>control facilitates dynamic process management as<a id="id651" class="indexterm"/> the script that you use <code class="literal">.load</code> on today can be changed in the future without requiring any alteration of the target process.</p><p>Now, let's take a look at more comprehensive techniques for deep analysis of application performance.</p></div></div>
<div class="section" title="Profiling processes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Profiling processes</h1></div></div></div><p>When tracing<a id="id652" class="indexterm"/> memory leaks and other hard-to-find bugs, it is useful to have profiling tools at the ready. What we will look at in this section is how to take snapshots of running processes and how to draw useful information out of them.</p><p>Node already provides some process information natively. Basic tracking of how much memory your Node process is using is easy to fetch with <code class="literal">process.memoryUsage()</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{ rss: 12361728, heapTotal: 7195904, heapUsed: 2801472 }</strong></span>
</pre></div><p>There are also modules available to track a little more information on processes. For example, the <a id="id653" class="indexterm"/>
<code class="literal">usage</code> module (<a class="ulink" href="http://github.com/arunoda/node-usage">github.com/arunoda/node-usage</a>) delivers<a id="id654" class="indexterm"/> straightforward memory and CPU usage information. To probe the current process, use the following code:</p><div class="informalexample"><pre class="programlisting">var usage = require('usage');
usage.lookup(process.pid, function(err, result) {
  console.log(result);
});</pre></div><p>This delivers the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{ memory: 15093760,</strong></span>
<span class="strong"><strong>  memoryInfo: { rss: 15093760, vsize: 3109531648 },</strong></span>
<span class="strong"><strong>  cpu: 3.8 }</strong></span>
</pre></div><p>Here, we see the<a id="id655" class="indexterm"/> total process memory usage in bytes and the CPU usage percentage.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>A good<a id="id656" class="indexterm"/> resource to learn about JavaScript memory profiling can be found at <a class="ulink" href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling">https://developer.chrome.com/devtools/docs/javascript-memory-profiling</a>.</p></div></div><p>It is more interesting to be able to get a look into what V8 sees when it is running your process. Any node process can have <code class="literal">v8.log</code> generated simply by passing the <code class="literal">--prof</code> (for profile) flag. Let's <a id="id657" class="indexterm"/>create a log reader and check its performance using the <code class="literal">tick</code> module (<a class="ulink" href="https://github.com/sidorares/node-tick">https://github.com/sidorares/node-tick</a>), which will read v8 logs and generate a <a id="id658" class="indexterm"/>breakdown of the execution profile.</p><p>To begin with, install the package globally:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g tick.</strong></span>
</pre></div><p>In your code bundle, under the <code class="literal">/profiling</code> directory for this chapter, there will be a file called <code class="literal">logreader.js</code>. This simply reads the <code class="literal">dummy.log</code> file (also in that folder) and dumps its contents to the console. It's a good example of how to use a <code class="literal">Transform</code> stream to process log files:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
var stream = require('stream');
var lineReader = new stream.Transform({
  objectMode: true
});
lineReader._transform = function $transform(chunk, encoding, done) {
  var data = chunk.toString()
  if(this._lastLine) {
    data = this._lastLine + data;
  }
  var lines = data.split('\n');
  this._lastLine = lines.pop();
  lines.forEach(this.push.bind(this));
  done();
}

lineReader._flush = function $flush(done) {
  if(this._lastLine) {
    this.push(this._lastLine);
  }
  this._lastLine = null;
  done();
}
lineReader.on('readable', function $reader() {
  var line;
  while(line = lineReader.read()) {
    console.log(line);
  }
});
fs.createReadStream('./dummy.log').pipe(lineReader);</pre></div><p>The important <a id="id659" class="indexterm"/>thing to note is that the main functions have been named and prefixed with <code class="literal">$</code>. This is good practice generally—you should always name your functions. The reason is specifically relevant to debugging. We want those names to show up in the reports we're about to generate.</p><p>To generate a v8 log, run this script using the <code class="literal">–-prof</code> (profile) argument and <code class="literal">–-nologfile-per-isolate</code> to suppress default log file generation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node --prof logreader --nologfile-per-isolate &gt; v8.log</strong></span>
</pre></div><p>You should now see a log file in the current working directory with the name <code class="literal">v8.log</code>. Go ahead and take a look at it—the log is somewhat intimidating. This is where the <code class="literal">tick</code> module comes into play:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node-tick-processor &gt; profile</strong></span>
</pre></div><p>This command will generate a more readable profile and dump that to the <code class="literal">profile</code> file. Open that file and take a look. There is a lot of information and doing a deep dive into what it all means is well beyond the scope of this chapter. However, it is very clear how many ticks are being consumed by various functions in our script, such as <code class="literal">$transform</code>, and we can also see whether or not the functions are optimized. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>16   21.6%      0    0.0%   LazyCompile: ~$transform /Users/sandro/profiling/logreader.js:8</strong></span>
</pre></div><p>Here, we see that <code class="literal">$transform</code> occupied 16 ticks and was lazily compiled, and the tilde (<code class="literal">~</code>) indicates that the function is not optimized—if it was optimized, you would see an asterisk (<code class="literal">*</code>) prefix.</p><p>As an experiment, create a script with the following code and run it with the <code class="literal">--prof</code> flag:</p><div class="informalexample"><pre class="programlisting">while((function $badidea() {
  return 1;
})());</pre></div><p>Let this endless loop run for a while and then terminate the process by using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>. Create a profile file, as we did previously, and view it. It should be clear how easy it would be to catch an expensive function using these profiling tools.</p><p>An extremely useful visualization tool available to those running the latest Node.js build (0.11.x or higher and io.js) is accessible simply by running the following in a version of the Chrome browser—<code class="literal">chrome://tracing/</code>:</p><div class="mediaobject"><img src="graphics/1403OS_05_05.jpg" alt="Profiling processes"/></div><p>Once you have this ready in your browser, click on the <span class="strong"><strong>Load</strong></span> button and upload your <code class="literal">v8.log</code> file. The execution timeline is laid out across the top, and, by clicking on the link (V8: V8 PC) on the left, you can access the starburst navigation tool. Starbursts radiate call stacks, nicely visualizing where the work in our application is being done. Note how our <code class="literal">$transform</code><a id="id660" class="indexterm"/> function is listed to the right—name your functions!</p><p>These are <a id="id661" class="indexterm"/>a few helpful links if you'd like to learn more about profiling v8:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developers.google.com/v8/profiler_example">https://developers.google.com/v8/profiler_example</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ">https://groups.google.com/forum/#!msg/nodejs/oRbX5eZvOPg/jM6TINytVhoJ</a></li></ul></div></div>
<div class="section" title="Using third-party monitoring tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Using third-party monitoring tools</h1></div></div></div><p>Node is a <a id="id662" class="indexterm"/>new technology for which there are few mature application monitoring tools. Some independent developers, along with established companies in the application monitoring space, have jumped in to fill this gap. In this section, we'll look at PM2 as a process manager and monitor and also have a look at Nodetime.</p><div class="section" title="PM2"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>PM2</h2></div></div></div><p>PM2 is <a id="id663" class="indexterm"/>designed to be an enterprise-level process <a id="id664" class="indexterm"/>manager. As discussed elsewhere, Node runs within a Unix process, and its <code class="literal">child_process</code> and <code class="literal">cluster</code> modules are used to spawn further processes, typically when scaling an application across multiple cores. PM2 can be used to implement the deployment and monitoring of your Node processes both via the command line and programmatically. Here, I will focus on programmatically using PM2 for process management and show you how to use it to monitor and display process activity.</p><p>Install PM2 globally:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install pm2 -g</strong></span>
</pre></div><p>The most straightforward way to use PM2 is as a simple process runner. The following program will increment and log a value every second:</p><div class="informalexample"><pre class="programlisting">// script.js
var count = 1;
function loop() {
  console.log(count++);
  setTimeout(loop, 1000);
};
loop();</pre></div><p>Here, we use <code class="literal">fork</code> on a new process from <code class="literal">script.js</code>, running it in the background <span class="emphasis"><em>forever</em></span>, until we stop it. This is a great way to run a daemonized process:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pm2 start script.js</strong></span>
<span class="strong"><strong>// [PM2] Process script.js launched</strong></span>
</pre></div><p>Once the script launches, you should see something like this in your terminal:</p><div class="mediaobject"><img src="graphics/1403OS_05_02.jpg" alt="PM2"/></div><p>The meaning<a id="id665" class="indexterm"/> of most of the values should be clear, such as the <a id="id666" class="indexterm"/>amount of memory your process is using, whether or not it is online, how long it has been up, and so on (the <code class="literal">mode</code> and <code class="literal">watching</code> fields will be explained shortly). The process will continue to run until it is stopped or deleted.</p><p>To set a custom name for your process when you start it, pass the <code class="literal">--name</code> argument to PM2 as follows: <code class="literal">pm2 start script.js --name 'myProcessName'</code>.</p><p>This overview of all running PM2 processes can be brought up at any time via the <code class="literal">pm2 list</code> command. PM2 offers <a id="id667" class="indexterm"/>other straightforward commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pm2 stop &lt;app_name | id | all&gt;</code>: This is used to stop a process by name or ID or stop all processes. A stopped process remains in the process list and can be restarted later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pm2 restart &lt;app_name | id | all&gt;</code>: This is used to restart a process. The number of process restarts is displayed under <code class="literal">restarted</code> in all process lists. To automatically restart a process when it reaches a maximum memory limit (say, 15 M), use the <code class="literal">pm2 start script.js --max-memory-restart 15M</code> command.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pm2 delete &lt;app_name | id | all&gt;</code>: This deletes a process. This process cannot be restarted.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pm2 info &lt;app_name | id &gt;</code>: This provides detailed information on a process, as shown here:<div class="mediaobject"><img src="graphics/1403OS_05_03.jpg" alt="PM2"/></div></li></ul></div><p>Note the paths<a id="id668" class="indexterm"/> given for error and other logs. Remember that our<a id="id669" class="indexterm"/> script increments an integer by one every second and logs that count. If you use <code class="literal">cat /path/to/script/ out/log</code>, your terminal will show what has been written to the <code class="literal">out</code> log, which should be a list of incrementing numbers. Errors are similarly written to a log. Furthermore, you can stream the output logs in real time with <code class="literal">pm2 logs</code>. For example, our <code class="literal">script.js</code> process is still pumping out incremented values:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PM2: 2014-07-19 23:20:51: Starting execution sequence in -fork mode- for app name:script id:1</strong></span>
<span class="strong"><strong>PM2: 2014-07-19 23:20:51: App name:script id:1 online</strong></span>
<span class="strong"><strong>script-1 (out): 2642</strong></span>
<span class="strong"><strong>script-1 (out): 2643</strong></span>
<span class="strong"><strong>script-1 (out): 2644</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>To clear all logs, use <code class="literal">pm2 flush</code>.</p><p>You can also use PM2 programmatically. First, you will need to install PM2 locally in your application's <code class="literal">package.json</code> file with the standard <code class="literal">npm install pm2</code> command. To replicate the steps we took to run <code class="literal">scripts.js</code> with PM2, first create the <code class="literal">programmatic.js</code> script as follows:</p><div class="informalexample"><pre class="programlisting">// programmatic.js
var pm2 = require('pm2');
pm2.connect(function(err) {
  pm2.start('script.js', {
    name: 'programmed script runner',
    scriptArgs: [
      'first',
      'second',
      'third'
    ],
    execMode : 'fork_mode'
  }, function(err, proc) {
    if(err) {
      throw new Error(err);
    }
  });
});</pre></div><p>This <a id="id670" class="indexterm"/>script will use the <code class="literal">pm2</code> module to run <code class="literal">script.js</code> as a <a id="id671" class="indexterm"/>process. Go ahead and run it with <code class="literal">node programmatic.js</code>. Executing a PM2 list should show that <code class="literal">programmed script runner</code> is alive. To make sure this is so, try <code class="literal">pm2 logs</code>—you should see numbers being incremented, just as before.</p><div class="section" title="Monitoring"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec33"/>Monitoring</h3></div></div></div><p>PM2 makes<a id="id672" class="indexterm"/> process monitoring easy. To view real-time statistics on the CPU and memory usage for your processes, simply enter the command <code class="literal">pm2 monit</code>:</p><div class="mediaobject"><img src="graphics/1403OS_05_04.jpg" alt="Monitoring"/></div><p>Here, we see a constantly updated graph of the CPU and memory usage for our process. What could be easier?</p><p>PM2 also makes it easy to create web-based monitoring interfaces—it's as simple as running <code class="literal">pm2 web</code>. This command will start a monitored process listening on port <code class="literal">9615</code>—running <code class="literal">pm2 list</code> will now list a process named <code class="literal">pm2-http-interface</code>. Run the web command and then navigate to <code class="literal">localhost:9615</code> in your browser. You will see a detailed snapshot of your processes, OS, and so on, as a JSON object:</p><div class="informalexample"><pre class="programlisting">...
  "monit": {
    "loadavg": [
      1.89892578125,
      1.91162109375,
      1.896484375
    ],
    "total_mem": 17179869184,
    "free_mem": 8377733120,
...
"pm_id": 1, // our script.js process
  "monit": {
    "memory": 19619840,
    "cpu": 0
  }
...</pre></div><p>Creating a <a id="id673" class="indexterm"/>web-based UI that polls your server every few seconds, fetches process information, and then graphs it is made much simpler due to this built-in feature of PM2.</p><p>PM2 also has an option to set a watcher on all managed scripts so that any changes to the watched script will cause an automatic process restart. This is very useful when developing. As a demonstration, let's create a simple HTTP server and run it through PM2:</p><div class="informalexample"><pre class="programlisting">// server.js
var http = require('http');
http.createServer(function(req, resp) {
  if(req.url === "/") {
    resp.writeHead(200, {
      'content-type' : 'text/plain'
    });
    return resp.end("Hello World");
  }
  resp.end();
}).listen(8080);</pre></div><p>This server will echo <span class="strong"><strong>"Hello World"</strong></span> whenever <code class="literal">localhost:8080</code> is hit. Start it using <code class="literal">pm2 start server.js --watch --name 'watchedHTTPServer'</code>. Note that if you now list the running processes, our named process will show <code class="literal">enabled</code> in the <code class="literal">watching</code> column. Bring up this server in your browser. You should see <span class="strong"><strong>"Hello World"</strong></span>. Now, navigate to the <code class="literal">server.js</code> script and change <code class="literal">"Hello World"</code> to <code class="literal">"Hello World, I've changed!"</code>. Reload your browser. Note the change. Run a process list, and you'll see that this server process indicates a restart. Do it a few more times. Live development of your server applications<a id="id674" class="indexterm"/> just got easier thanks to PM2.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>A process management tool with features similar to those of PM2 that is more focused on<a id="id675" class="indexterm"/> delivering a full-featured web UI out of the box<a id="id676" class="indexterm"/> is <span class="strong"><strong>Guvnor</strong></span>: <a class="ulink" href="https://github.com/tableflip/guvnor">https://github.com/tableflip/guvnor</a>. Other popular process monitors <a id="id677" class="indexterm"/>can be found<a id="id678" class="indexterm"/> at <a class="ulink" href="https://github.com/remy/nodemon">https://github.com/remy/nodemon</a> and <a class="ulink" href="https://github.com/foreverjs/forever">https://github.com/foreverjs/forever</a>.</p></div></div><p>We will talk about application deployment strategies using PM2 in <a class="link" href="ch07.html" title="Chapter 7. Deploying and Maintaining">Chapter 7</a>, <span class="emphasis"><em>Deploying and Maintaining</em></span>, including using PM2's <code class="literal">cluster</code> mode.</p></div></div><div class="section" title="Nodetime"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Nodetime</h2></div></div></div><p>Nodetime<a id="id679" class="indexterm"/> is an easy-to-use Node-monitoring<a id="id680" class="indexterm"/> tool. Visit <a class="ulink" href="http://www.nodetime.com">www.nodetime.com</a> and sign up. Once you do so, you <a id="id681" class="indexterm"/>will be presented with a page containing code to include in your application. Keep this page open as it will update when we start our application.</p><p>To begin with, we'll create a simple HTTP server application that returns <code class="literal">"Hello World"</code> for every request:</p><div class="informalexample"><pre class="programlisting">"use strict";
require('nodetime').profile({
  accountKey: 'your_account_key',
  appName: 'monitoring'
});

var http   = require('http');

http.createServer(function(request, response) {

  response.writeHead(200, {
    "content-type" : "text/html"
  });
  response.end('Hello World');

}).listen(8080)</pre></div><p>Save this as <code class="literal">server.js</code>. Execute it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node server.js</strong></span>
</pre></div><p>Note how, on the Nodetime page in your browser, you will see <span class="strong"><strong>monitoring</strong></span> show up under the <span class="strong"><strong>Applications</strong></span> section. Click on that link—you will now see Nodetime's monitoring<a id="id682" class="indexterm"/> interface:</p><div class="mediaobject"><img src="graphics/1403OS_05_01.jpg" alt="Nodetime"/></div><p>Go ahead and <a id="id683" class="indexterm"/>hit the server by visiting <code class="literal">localhost:8080</code> in your browser. After doing that a number of times, go back to your Nodetime interface and use the dropdown listing <span class="strong"><strong>OS / Load average</strong></span>, selecting other useful metrics. Try <code class="literal">Process/V8 heap total (MB)</code> to see how V8 is allocating memory. Other metrics allow you to check the profile of the machine executing this server process, and so on.</p></div></div>
<div class="section" title="Using New Relic for monitoring"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Using New Relic for monitoring</h1></div></div></div><p>New Relic is <a id="id684" class="indexterm"/>a well-known tool to monitor servers and applications<a id="id685" class="indexterm"/> that has been upgraded to support Node. It is intended to be used by those looking to monitor the memory and CPU usage as well as things such as network activity and the health of your Node processes. In this section, we'll look into how to install it on your server and provide examples of its use.</p><p>Installation involves applying for a license key from the <a id="id686" class="indexterm"/>New Relic website at <a class="ulink" href="http://newrelic.com">newrelic.com</a>. Setting up your account is straightforward. After signing up, you'll be presented with a list of monitoring tools that New Relic provides—you'll want to select New Relic Servers. In the next steps, you'll select Node.js as your development environment and the OS you'll be working within. I'll use CentOS. After selecting your OS, you should see the installation instructions generated for you, with your license key included—just cut and paste.</p><p>You are installing and starting a server that will probe system processes and report results to New Relic. This server must authenticate with New Relic by using your license key, and that means you must store that key in an accessible location. For this reason, a configuration file will be stored on your system. For most Unix installs, this file will be stored in <code class="literal">/etc/newrelic/nrsysmond.cfg</code>. Read through the configuration options described in that file, such as the location of log files.</p><p>Many third-party deployment environments/hosts often provide easy integration with New Relic, such as Heroku (<a class="ulink" href="https://devcenter.heroku.com/articles/newrelic">https://devcenter.heroku.com/articles/newrelic</a>).</p><p>Once New Relic is running, a log file will be created, and if all goes well, that file should contain a line similar to the following, indicating that New Relic is now tracking:</p><div class="informalexample"><pre class="programlisting">{
  "v": 0,
  "level": 30,
  "name": "newrelic",
  "hostname": "your.server.net",
  "pid": 32214,
  "time": "2015-02-16T19:52:20.295Z",
  "msg": "Connected to collector-114.newrelic.com:443 with agent run ID 39366519380378313.",
  "component": "collector_api"
}</pre></div><p>We'll connect to this server via the <code class="literal">newrelic</code> package. Once that package is installed into your application directory, you will need to configure it. Somewhat awkwardly, this means copying the <code class="literal">newrelic.js</code> file from <code class="literal">node_modules/newrelic</code> into your application's root folder, modifying its contents, and adding your license key and a name for your application. The log level field corresponds to the log levels used by Bunyan, so you may want to visit the<a id="id687" class="indexterm"/> project page for more information: <a class="ulink" href="https://github.com/trentm/node-bunyan">https://github.com/trentm/node-bunyan</a>.</p><p>You'll want to avoid storing your license key in the <code class="literal">newrelic.js</code> file when you go into production. You<a id="id688" class="indexterm"/> can pass configuration parameters to New Relic via environment variables rather than hardcoding them via environment variables. For example, you can pass your license key via the <code class="literal">NEW_RELIC_LICENSE_KEY</code> environment variable.</p><p>The <code class="literal">newrelic</code> package <a id="id689" class="indexterm"/>repository can be found at <a class="ulink" href="https://github.com/newrelic/node-newrelic">https://github.com/newrelic/node-newrelic</a>. This project page contains extensive information on New Relic's usage and configuration, environment variables, and so on. Also, there are examples for setting up client-side monitoring.</p><p>Let's add New Relic monitoring to an example application. Create the following Express server:</p><div class="informalexample"><pre class="programlisting">var newrelic = require('newrelic');
var express = require('express');

var app = express();

app.get('/', function(req, res) {
  res.send('Hello World');
});

app.get('/goodbye', function(req, res) {
  res.send('Goodbye World');
});
app.listen(3000);
console.log('Server started on port 3000');</pre></div><p>You can add additional routes or change the route names if you'd like. What we're going to do is run this server, hit it a few times, and then check with New Relic to see what it has picked up. Start the server and make some requests.</p><p>Once you've exercised the server a bit, head over to <code class="literal">newrelic.com</code> and log in. Across the top of the page, you will see a navigation menu, and you'll be in the <span class="strong"><strong>APM</strong></span> section. Here is where you can access various monitoring tools for you applications. You should see a list including the application name you set earlier. Click on that name, and you'll be brought to a dashboard overview (there won't be much information yet). You should, however, see some information about the server route activity:</p><div class="mediaobject"><img src="graphics/1403OS_05_06.jpg" alt="Using New Relic for monitoring"/></div><p>Along the<a id="id690" class="indexterm"/> left-hand side, there will be a more detailed navigation pane. Go to <span class="strong"><strong>Reports</strong></span> | <span class="strong"><strong>Web transactions</strong></span>, and you'll see more detailed information on the routes you've set up. If you navigate to the <span class="strong"><strong>SERVERS</strong></span> section, you'll see a dashboard for your host containing detailed system information.</p><p>Now, let's create server load and see how New Relic does with monitoring. If you have a favorite load stress tool, go ahead and send some traffic to your application. If you'd like to learn a simple<a id="id691" class="indexterm"/> and common stress-testing tool, learn and use the Apache Bench tool (<a class="ulink" href="http://httpd.apache.org/docs/2.2/programs/ab.html">http://httpd.apache.org/docs/2.2/programs/ab.html</a>). There are also free online stress-testing<a id="id692" class="indexterm"/> services, such<a id="id693" class="indexterm"/> as <a class="ulink" href="http://loader.io">http://loader.io</a> and <a class="ulink" href="https://loadimpact.com">https://loadimpact.com</a>.</p><p>Once you've started the stress test, return to the New Relic dashboard for your application and host server. You'll see regularly updated statistics as the New Relic monitor reports the effect of requests on the memory, CPU load, and other key metrics.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we engaged with one of the most important aspects of deployment—monitoring running processes. Starting at the most basic and necessary level—catching errors—you learned how to trap errors at the individual process level and across processes. After discussing techniques to log errors with both UDP and third-party tools, we looked at how to build remote process monitors using Node's REPL, leading to a deeper discussion on how to do extensive application profiling and memory analysis. Finally, we looked at how to deploy the PM2 process runner in an effort to manage processes and visualize their activity. We also looked at how to use the cloud-based Nodetime and New Relic services to monitor your applications.</p><p>Direct monitoring provides crucial real-time insights into any potential threats, but we must also try to limit the possibility of future errors by writing resilient code that we can be confident of. In the next chapter, we will look at how to build and test our applications such that they inspire confidence. Advice on how best to build and organize your applications so that their design is clear will be presented. This way, applying the remaining chapter content on testing strategies to your application can flow naturally with your ongoing development.</p></div></body></html>