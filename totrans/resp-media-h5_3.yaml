- en: Chapter 3. Mixing Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load Times For 69% Of Responsive Design Mobile Sites Deemed "Unacceptable"…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A staggering fact, but absolutely true: a survey carried out by the mobile
    developer company Tribilis in April 2014 found that for 155 sites surveyed, only
    21 percent loaded in four seconds or less on smartphones. Moreover, those that
    took longer had an average page weight of 1.7 MB.'
  prefs: []
  type: TYPE_NORMAL
- en: Sobering thoughts, but ones that perfectly illustrate the pitfalls of mixing
    videos and images on pages in responsive design! We need to strike a balance between
    displaying the right media content that is not too large or too small while keeping
    our page load times small. This chapter works through some examples and details
    some of the pitfalls associated with mixing content, which can lead to heavy pages
    and long download times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover a number of topics in this chapter, which will include:'
  prefs: []
  type: TYPE_NORMAL
- en: Mixing video and image content on the same page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering limitations of mixing content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using preloaders to reduce delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding lazy loading support to our pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making allowances for mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrigued? Let's make a start!
  prefs: []
  type: TYPE_NORMAL
- en: Mixing video and image content on the same page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we've seen some of the tips and tricks we need to use
    to make our media content responsive and worked through some examples of the styles
    we need to implement to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is unlikely that every responsive site will have either images or
    videos; it is more likely that there will be a mix of both on at least some sites!
    This can present its own issues, so to see what can happen, let's run through
    a simple demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the code download, extract the `code` folder for this chapter and save
    it to your project folder; this contains a simple demo that shows the issues we
    face with mixing videos and images together in a responsive design. If we run
    the `mix-responsive.html` demo as it stands, it would appear to look okay from
    the start until we scroll down and view the video. The layout is not ideal, but
    there are a few changes we can make:'
  prefs: []
  type: TYPE_NORMAL
- en: The banner image at the top of the browser window is too large. While this may
    be okay on a desktop, it will choke smartphones; it needs to be resized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The embedded video isn't respecting the boundaries of its container, with the
    result that it is spilling out over the whole page, making the text difficult
    to view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can improve on the use of the banner. Once we've changed it to a thinner
    design, we can then add a media query to switch in a smaller version of this thinner
    design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, these are easy fixes to make. Let''s see what is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a copy of `mix-responsive.html` and `mix-responsive.css` as `mix-responsiveV2.html`
    and `mix-responsiveV2.css` respectively (in the same folder). Don't forget to
    change the link to the CSS file from within our HTML markup to point to the new
    file!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for the `banner` div on or around line 28 and remove the `<img>` tags,
    so the HTML markup is as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further down, look for `<video controls>` on or around line 34; we need to
    encompass it within a wrapper `<div>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open up `mix-responsiveV2.css` and add the following styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the files. If we preview the results of our work in a browser, we can see
    a significant improvement in the appearance of our page.![Mixing video and image
    content on the same page](img/6968OT_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try resizing the page now; you should see that the video and image elements
    will resize perfectly, without any spillage. In a nutshell, our changes have been
    very simple. We've added a container to the video to which we've added the `max-width`
    style attribute and set this to `100%`. We then switched out the bulky banner
    to a thinner version, setting this to retain the full width of its container when
    resized. It is switched to a smaller version once we go below a screen width of
    `30rem`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a completed version of our demo with the fixes in place. In the code
    download, look for and extract `mix-responsiveV2-finished.html` and `mix-responsiveV2-finished.css`.
    Save both to the same places as the original files to view the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on and take a look at how we can make allowances for mobile
    devices when mixing content, I want to cover off a couple of tips that might help
    give you a little inspiration:'
  prefs: []
  type: TYPE_NORMAL
- en: We've embedded the video directly in the page. It works perfectly well, but
    if we wanted to give it a little extra sparkle, we could consider using an overlay.
    There are plenty available, but one good (responsive) example is FrescoJS, available
    at [http://www.frescojs.com/](http://www.frescojs.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be a need to resort to jQuery to provide the responsive functionality
    for an element if CSS3 is not supported. Older browsers such as IE8 or below might
    fall into this category. We can do this using something such as Embedly jQuery,
    available at [http://embedly.github.io/embedly-jquery/](http://embedly.github.io/embedly-jquery/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a tutorial available on how to configure Embedly jQuery at [http://embed.ly/docs/tutorials/responsive](http://embed.ly/docs/tutorials/responsive).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you need to add responsive code for third-party embedded videos (such as
    YouTube), you can use the service at [http://embedresponsively.com/](http://embedresponsively.com/);
    simply enter the URL of any video or image to embed and click on **Embed** to
    get the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay! On we go! We've talked a lot about mixing content, but as we've seen from
    the demo, there are some aspects where there is room for improvement. The alterations
    we've made in our demo are just some of the pointers we can use to remove some
    of the pitfalls of mixing content, so let's take a look at a few in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the pitfalls of mixing content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responsive design has become hugely popular over the last few years, with visitors
    browsing content on the Internet using a variety of devices. This increases the
    pressure on developers to ensure that their sites work well on a range of different
    devices and platforms. A recent study by eMarketeer illustrates that four out
    of every five people will access content via a mobile device and that this figure
    is projected to increase over the next three years.
  prefs: []
  type: TYPE_NORMAL
- en: '| Region | 2014 | 2015 | 2016 | 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Middle East and Africa | 94.0 | 94.0 | 95.0 | 96.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Asia Pacific | 87.4 | 90.0 | 92.6 | 93.9 |'
  prefs: []
  type: TYPE_TB
- en: '| Central and Eastern Europe | 72.4 | 80.6 | 86.6 | 91.7 |'
  prefs: []
  type: TYPE_TB
- en: '| North America | 64.3 | 69.8 | 74.4 | 79.2 |'
  prefs: []
  type: TYPE_TB
- en: '| Western Europe | 67.8 | 78.2 | 85.0 | 90.6 |'
  prefs: []
  type: TYPE_TB
- en: '| Latin America | 58.5 | 65.0 | 70.1 | 75.2 |'
  prefs: []
  type: TYPE_TB
- en: '| **Worldwide** | **79.1** | **83.6** | **87.3** | **90.1** |'
  prefs: []
  type: TYPE_TB
- en: The figures in the preceding table are percentage values taken from eMarketeer
    in December 2013.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that we don''t fall into the trap of producing a responsive site that offers
    a poor experience, let''s take a look at some of the pitfalls we need to consider
    when mixing media sources in responsive design:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The size and number of images on a page will directly affect how quickly your
    visitors can view the page. To reduce the impact, we can use several techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image compression is the first simple technique widely used. For a perfect example
    of the need to compress images, an article by Tribilis makes for interesting reading,
    available at [http://blog.trilibis.com/trilibis-web-performance-survey-finds-69-percent-of-responsive-design-websites-fail-to-deliver-acceptable-load-times-on-mobile-devices-02759](http://blog.trilibis.com/trilibis-web-performance-survey-finds-69-percent-of-responsive-design-websites-fail-to-deliver-acceptable-load-times-on-mobile-devices-02759).
    It shows some significant gains when images are compressed!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next important technique is the conversion of small images into data URIs
    or as part of an image sprite.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another technique is the use of lazy loading to only show those images that
    are visible within the viewport.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be aware of the breakpoints in our design and alter our media queries
    to suit. What may have worked well for images may not work equally as well for
    videos, particularly if they are of different sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling smaller images to a larger size will result in the loss of quality;
    it is recommended to start with large size images and dynamically resize them
    for smaller devices. Once we get to a particular breakpoint, then we can switch
    to using a smaller image by default to avoid images becoming illegible if they
    have not been sized for a particular breakpoint / viewport width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling images can cause issues when they are reduced to a very small size.
    The dimensions are likely to mean that we can't view the image properly, its meaning
    will be lost, the file size won't be any smaller, and it may be better to simply
    not display it instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider converting vector images to the SVG format. Conversion to standard
    image formats such as JPG, GIF, or PNG will likely lead to the same loss of quality
    as scaling small images to a larger size. SVG images scale well without any loss
    of quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your site uses video, then one pitfall that can trip you up is the format
    used. Although we only need to encode for MP4 or WebM support, not every device
    will use both. A careful analysis of web metrics should help us understand which
    operating systems are used to access the site and therefore help determine which
    format of video to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For an up-to-date check on format support, take a look at the articles available
    at [http://www.jwplayer.com/html5](http://www.jwplayer.com/html5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do you use images for small elements such as buttons? If so, consider converting
    them to CSS3 equivalents, at least for the browsers that can support them. It
    will mean a reduction in requests to the server (we're not calling the images)
    and the CSS style sheet would have been cached by the browser, so the response
    will be quicker. There are plenty of examples available online; you can try Chris
    Coyier's Button creator at [http://css-tricks.com/examples/ButtonMaker/](http://css-tricks.com/examples/ButtonMaker/)
    or CSS Shape Generator at [http://html-generator.weebly.com/css-shape-generator.html](http://html-generator.weebly.com/css-shape-generator.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifying only the width of images may cause a doubling or tripling of the
    cycles that many browsers must process to layout the new resized page. While each
    of these cycles typically take less than a millisecond, they stack up, especially
    if there are multiple scalable elements on the page. Addressing the height in
    the same declaration can reduce this issue:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your site needs to display videos in 4:3 or 16:9 ratio format, then these
    may not resize properly. We can get around this using a wrapper in HTML that is
    styled to the proper dimensions, then stretch the video to fit the following container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The CSS styling would look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Phew! There are certainly plenty of places where we can be tripped up if we're
    not careful! Let's move on and take a look at a couple of tricks we can use to
    help manage media content in our pages, beginning with a look at preloading images.
  prefs: []
  type: TYPE_NORMAL
- en: Using preloaders to reduce delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preloading content is not a new concept in the world of web design. The idea
    is to reduce the amount of time it takes to view the page in a browser, as some
    (or all) of the content has been fetched ahead of viewing the page and cached
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of examples available using JavaScript (such as PreloadJS at
    [http://www.createjs.com/#!/PreloadJS](http://www.createjs.com/#!/PreloadJS)).
    But this adds an extra overhead to our pages that we can avoid, particularly in
    a responsive design.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use CSS to achieve the same effect, provided the styles and
    images are called at the right time. This way, they will be ready for us when
    we render the images on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this demo, I've simplified the code to concentrate on the
    preloading process only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at preloading in action with a simple demo:'
  prefs: []
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, extract a copy of `preloading.html`
    and then save it in our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, extract `img01.png` to `img04.png` from the code download. The images
    should go into a subfolder marked `img` in our project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following styles to a new CSS style sheet. Save this
    as `preloading.css`, in a `css` subfolder within our project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we preview our work, it''s useful to take a quick look to see how this
    process works. The key to it is the class added to the body to retrieve the images
    before we use them later in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we preview the results of our work, we''ll see the following four images
    appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using preloaders to reduce delays](img/6968OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The beauty about using this method is that we've removed the need to have to
    use yet another library, such as PreloadJS. Instead, we can now choose to call
    it if we decide to provide support for older browsers that don't support the `body:before`
    trick we used in our demo.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change tack and look at the reverse side of this coin—lazy loading. No,
    this is not some form of getting up on a Sunday morning after a particularly good
    night out (terrible joke!), but a means to only load and display images at the
    point of viewing them. Intrigued? I will reveal all as part of our next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Adding lazy loading support to our pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary aims of responsive design should be the consideration of
    any tactic we can use to reduce the overall loading time of our pages; this is
    particularly true for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you''ve seen how we can preload content. In some instances, this may
    not be ideal; instead, we can do the opposite and not load content until we are
    about to view it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding lazy loading support to our pages](img/6968OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This process is known as lazy loading; it effectively removes the focus of loading
    the images from the front (that is, on loading of the page) to the point of when
    we need to see the images. To illustrate the process, we're going to use the bLazy
    plugin by Bjørn Klinggard, available at [http://dinbror.dk/blog/blazy/](http://dinbror.dk/blog/blazy/).
    The great thing about this library is that it is lightweight and written in pure
    JavaScript, so has a zero dependency count! Oh and did I forget— it's responsive
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at a demo (based on the original by the author), which
    we could easily use as a basis for something more involved within any responsive
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this demo, extract a copy of the `lazy loading` folder within
    the code download that accompanies this book. It contains the markup files, images,
    styling, and JavaScript needed for our demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `lazyloading.html` file. Notice how only the first few images show?
    If we scroll down, we can see the green loading image appear with the next image
    appearing after a short delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The magic in this demo centers on this code excerpt from the demo:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We kick off with a placeholder image. In this instance, we're using a 1 px square
    PNG file that could be easily converted to its data-URI equivalent with little
    overhead. We then use two `data-src` tags to flip between either the small or
    large versions of the image when the window is resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test to ensure that the pictures are indeed only being loaded when visible.
    In this instance, using Firefox''s **Developer** toolbar, we can see each URL
    loaded when viewed in the **Console** tab, as indicated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding lazy loading support to our pages](img/6968OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A small point to remember—in this instance, the preceding screenshot shows the
    use of a local webserver; the principle works the same whether the images are
    loaded from the filesystem or through a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This demo is perfect as a basis to display a gallery effect on a site, particularly
    when viewed on a mobile device. With a bit of reconfiguration, we could even set
    it to display retina-based images; although that is something I will leave for
    you as a challenge! Let''s move on and cover a key topic when designing responsively:
    the need to make allowances for mobile devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Making allowances for mobile devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding visual content to our pages will begin to bring the site alive, but we
    should bear in mind the increase in latency times. Latency is a major killer on
    mobile devices; if we take a 1 MB page with 80 plus requests, for example, loading
    the page can take over 4 seconds!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using JavaScript is expensive in terms of resources. It takes time and can
    block the rendering of pages. A much better alternative is to only load the resource
    when it is needed. On desktops, this is less of an issue, but becomes crucial
    for mobile devices. Take, for example, Google''s Gmail service—using this principle
    reduces the latency for loading JavaScript from 2600 ms to just 240 ms. With this
    in mind, let''s take a look at some useful tips we can consider to help reduce
    the impact of mixing responsive images and videos on a mobile device:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are designing for mobile devices, it is essential to work out which platform
    our users are using. This will dictate what content can be displayed. One way
    is that we can use lazy loading (in the form of media queries) to only show images
    when required:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another method encourages conditional loading to only load those elements and
    styling that are necessary:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: These methods do not require any additional libraries to be imported. This is
    ideal if our site is already code-heavy and we want to avoid adding more to our
    site. In reality though, we may look to use something like RequireJS to manage
    the importing of files when needed; this does come with the overhead of the RequireJS
    library though!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A good practice is to carefully consider whether all of the elements on the
    page are really needed for a useable mobile experience. Check those social media
    buttons. For example, some may be larger than you think and while they could be
    replaced with smaller/lighter versions, it may make better sense to not include
    them at all for mobile devices. Alternatively, consider loading the larger ones
    using conditional loading, while smaller ones can be loaded automatically. A great
    example of an easy replacement is to consider using the FontAwesome icons instead
    of images. This will help reduce the number of files that need to be loaded by
    the server (see the next point).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using data URIs (via a generator service, such as [http://datauri.net/](http://datauri.net/))
    or sprites / web fonts (such as Entype or FontAwesome) in place of images. Although
    data URIs or sprites may not make the code smaller, they will reduce the number
    of requests to the server. Using web fonts can have the same effect too; we can
    take it even further with building a custom font using the Fontello service at
    [http://www.fontello.com](http://www.fontello.com)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using videos on your site, consider hosting them on YouTube. This
    will save space and bandwidth costs to your site. In addition, there will be a
    consistent format, which reduces the risk of any issues where videos can't play
    on mobile devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful about where you use large, high quality images—on mobile devices,
    your visitors will not thank you when their data usage goes through the roof!
    There are plenty of options available to reduce the image size. We will look at
    two such examples later in this chapter that use Node JS to resize and compress
    images automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, if you need to display images on high pixel density displays,
    doubling the size but increasing the compression will help reduce the file size.
    To see the effect in action, take a look at the tutorial available at [http://greatfridays.com/blog/images-in-responsive-web-development/](http://greatfridays.com/blog/images-in-responsive-web-development/).
    Can you see any difference in quality between the two images used in the PayPal
    demo?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always set videos to show a poster image and not to automatically play for mobile
    devices. There are many options to produce images (including those that can be
    automated), so there is no excuse. We'll see one example later in this chapter,
    which can be easily adapted to produce an extra image to serve as the poster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful tool to get to grips with is the Page Visibility or Network APIs. This
    appears very simple to implement, but opens up a variety of possible uses. One
    such use is to shut off any videos that are playing temporarily if a browser window
    is not being displayed; this will help reduce bandwidth costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your site requires a lot of vector images, you will get better results using
    SVG-formatted files. These are effectively XML files that can resize with no loss
    of quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enough theory—let's actually try out two of these tips; we could complete them
    manually, but instead we can take advantage of a task runner to complete them
    automatically. Intrigued? I will explain all, beginning with a look at creating
    responsive versions of our chosen images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating responsive images automatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key part of providing content for any website is of course images. This becomes
    all the more important on responsive sites where we've seen that multiple versions
    of the same image are needed to provide a fluid solution to our responsive needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could of course create each version of the image manually, but this is the
    21st century: who wants (or even has the time) to create different sizes manually?
    Surely there has to be a better way. You''d be right: we can automate the whole
    process. Let''s take a look how using the Node JS task runner as the basis to
    automate the process.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise is designed to run as standalone; the principles can easily be
    applied to a larger, more complex grunt process as you get more accustomed to
    using Grunt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start by installing Node JS:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by browsing to [http://nodejs.org/download/](http://nodejs.org/download/)
    to download the latest version for your platform. It's available for Windows,
    Mac, and Linux platforms. Double-click on the **MSI installer** and run through
    the wizard, accepting all defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the code download, extract the `responseimg` folder and save it on your
    PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bring up a Node JS command prompt, then change to the `responseimg` folder
    and run this command to install `grunt-responsive-images`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install `grunt-responsive-images`, along with the dependencies and
    Grunt; in this instance, we're using the `grunt-simple-watch` applet to automatically
    monitor our folder for any changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt, change to the `src` folder and then run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This kicks off the `grunt-simple-watch` plugin to begin automatically monitoring
    for changes in the `src` folder. In this example, I've already dropped a single
    JPEG image into the `src` folder, which is also shown in the following screenshot:![Creating
    responsive images automatically](img/6968OT_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any image dropped into the `src` folder will be used to create three new images,
    such as the example shown in the following screenshot:![Creating responsive images
    automatically](img/6968OT_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The automated process is now ready for use. We can drop any number of JPEG images
    into the folder; three new images will be produced for each new image dropped
    into the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're using the default sizes for each image as specified in the plugin; these
    can be easily customized in the options for the plugin within our `gruntfile.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the shrinking process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can of course develop this automation further. It's definitely worth reading
    up on the capabilities of Node and checking out some of the wide range of plugins
    that have been created to help automate otherwise time-consuming processes that
    do not add any value when done manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at one way of extending our automated process. We''ve set
    up a process to create the images, but there is a likelihood that some of the
    images are not compressed as much as they could be. We can fix that by adding
    in support for compression, using the `grunt-contrib-imagemin` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a copy of the `gruntfile.js` file. We first need to add in support
    for the `grunt-contrib-imagemin` plugin, so go ahead and modify the line as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, alter the code to add in the block for `imagemin` task as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the task in Grunt, we need to tell it to load in the `grunt-contrib-imagemin`
    plugin, so go ahead and add this line into the `gruntfile.js` file as indicated
    in the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to make one final change, so go ahead and alter the following line
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bring up a NodeJS command prompt and run the following command to add the plugin
    and its dependencies to the `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''re now ready to test our Grunt package. In the command prompt, change the
    directory to the project folder, then run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, we'll see the Grunt task run and successfully produce three
    new images, which are then compressed.![Automating the shrinking process](img/6968OT_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The automation process is now ready for use. Although we've only put one image
    through the process, we could at this point put many images through. I would recommend
    running some tests to gauge how many you can safely process at the same time,
    as this will be dependent on resources in your PC or Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! We've certainly packed a lot into a small space! Let's recap on what you've
    learned throughout this chapter. We kicked off with a demo of mixing video and
    image content, initially to see firsthand some of the issues we face when mixing
    content, but then to use some of the tips and tricks you've learned to get the
    pages to behave responsively.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at a demo, we then moved onto considering some of the pitfalls
    of mixing content; we saw how the large increase in responsive use has increased
    over the last few years making it crucial that our designs work on a variety of
    platforms. We covered a number of tips we can use to make allowances for mobile
    platforms in our designs.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter looking at two demos using NodeJS to automate the creation
    of different versions of our images and automatically shrinking them; this illustrates
    how we can automate the process and save us a lot of manual effort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our content, we need to test it thoroughly to ensure it works
    across a wide range of devices. We'll take a look at the testing process in the
    next chapter, examining some of the considerations and pitfalls we need to be
    aware of when working with responsive media.
  prefs: []
  type: TYPE_NORMAL
