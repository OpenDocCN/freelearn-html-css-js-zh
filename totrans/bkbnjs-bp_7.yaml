- en: Chapter 7. Building a Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come to the final chapter of this book, and if I may speak in first-person
    for a moment, this was my favorite application to build. Everybody loves a game,
    and if word games are your thing, you'll have fun with this too. Most of the applications
    we've written so far have been single-view applications; the only screen the user
    sees is the view that performs the main action of the application. However, full
    web applications often have other views that aren't the main purpose of the application,
    but serve to fill it out. We have one or two such views in this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here are a few of the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Review all the primary uses of the Backbone components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add non-Backbone pages to fill out the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an app that uses data not provided by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write (simple) game logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are we building?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we'll start by describing what we're planning the build. It's going
    to be a word game, modeled after a very simple iPhone game I enjoy, called *7
    Little Words* ([http://www.7littlewords.com/](http://www.7littlewords.com/)).
    Each game (or round, if you will) has seven words that are broken into parts of
    two, three, or four letters. Your job is to reassemble the words based on the
    short definitions that you're given. To make it clear, I have no affiliation with
    this iPhone game, I just like playing it!
  prefs: []
  type: TYPE_NORMAL
- en: However, we're going to take it a little farther than that game does, by assigning
    different point values to words, and also timing our users. This way, players
    can compare scores and times to make things a little more competitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of what the game view of our application will look like
    when it is finished. At the bottom, you can see the tokens that the user will
    choose to combine into a word. There''s a textbox in the middle that shows the
    word the user has assembled. Then, they''ll click on the **Guess** button to see
    if the word matches one of the definitions above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What are we building?](img/6997OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start as we did in the last chapter; by adding user account to our basic
    application. We won''t go over the whole process again; you can copy it from the
    previous chapter''s application. There''s only one change we have to make. In
    the `app.post(''/create'')` route, we create a `userAttrs` object that we store
    in the database. Users of this application will have three application-specific
    values to store:'
  prefs: []
  type: TYPE_NORMAL
- en: '`score`: This is their highest score'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: This is their lowest time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`games`: This is an array of the games they have played'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code to create the `userAttrs` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, and all the other user account creation code we've previously
    created, we have the shell of an application, ready to customize.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our server-side templates have been pretty basic in previous applications.
    We''ve only ever had a single `index.ejs` file, and maybe a `login.ejs` file.
    However, in a big application, you''ll probably have several different server
    templates. When that''s the case, you want to remove code duplication as much
    as possible. How you go about this is dependent on which server-side template
    system you use. Since we''re using `ejs` ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs)),
    we''ll do this via **includes**. So, in our project''s `views` directory, make
    a file called `header.ejs`. Here''s what goes in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic and expected, right? Now, we''re also going to have a `footer.ejs` file
    in the `views` directory, which will close these tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could just remember to add these two lines to the bottom
    of every template you create that uses the `header.ejs` include (or, if you''re
    hip with the HTML5 lack-of-strictness, leave them out entirely), but I like the
    symmetry that comes from having both the `header.ejs` and `footer.ejs` files.
    For example, our `login.ejs` file in the `views` directory, which has both the
    login and signup forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'See what I mean about symmetry? We can use the same technique in the `index.ejs`
    file in the `views` directory, which will start out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ll be splitting models, views, and the router into separate
    files again. This will be especially important in this application because of
    some of the complex code the models will use. So now that we have a `index.ejs`
    file in the `views` directory, we can render the index route. In the `server.js`
    file, this code should be your final route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we're not passing any values into the index template; this application
    won't require anything like that. This might sound strange. Since it is supposed
    to be a more advanced application, wouldn't you expect it to need more data out
    of the gate? If your application needs to shuttle a lot of data from the server
    to the browser, it is sometimes a smarter move not to move the data all at once;
    it could seriously slow down your load time. A better technique is to load the
    data when it is needed, and that's what we'll do here. Also, it is possible that
    you might need the user to make a decision before you know exactly what data you
    need; this is another reason to delay loading data, and this is true in our case
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Speaking of loading data, the next step is to create the data for our game—the
    words the users will spell. This is actually the only application in this book
    that begins with data, instead of only working with the data that users give to
    the application. The actual raw data will be in the `words.json` file in the root
    of our project. One of the keys to this being a good game is to have plenty of
    words to choose from. Here''s how the file starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, every word has an ID. Then, the important properties are the words
    and definitions. The definition is what the user will see, and the word is what
    they'll have to piece together. The level is a number between 1 and 3, with level
    1 words being the easiest and level 3 words being the toughest. You can write
    your own list, or download this list from Github ([https://gist.github.com/andrew8088/9627996](https://gist.github.com/andrew8088/9627996)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the development of this application, one idea was to use a dictionary
    API (such as [dictionaryapi.com](http://dictionaryapi.com)) to randomly select
    words from a much larger database. However, this isn't really practical, because
    we need a short, crossword-puzzle-like definition, and standard dictionary definitions
    just don't cut it. Also, most APIs don't have a way of selecting a random word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our list of words, we''ll need to create the actual database.
    Add this to the top of the `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We also require the Underscore library here; you'll see what we need it for
    in a moment. We need the very same file that we use on the client side. This won't
    work for every file; it just happens that the latest version of Underscore (at
    the time of writing this book, 1.6.0) is written to work on both the client and
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each game played by a user will have eight words; this means that we need to
    pull eight words randomly, but all of the same difficulty level, from the database.
    To do this, we''ll add a `getWords` function to the server file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function will take a level number and a callback function. Then, we'll
    get all the words in the database for that level. We'll then shuffle the array
    of records, using Underscore's `shuffle` method. After we shuffle the array, we'll
    slice the first eight items off the array and pass them to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be said that this is probably not an optimal way to get eight random
    words from most databases. Since I wrote the Bourne database system for small
    datasets, and it keeps all records in memory, what we do here should be fast.
    However, there will probably be better ways, depending on the database system
    you're using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a way of getting the words, we need to create a route for
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The level for the game is part of the URL. We convert it to a number, and then
    call our `getWords` function. Once we have the words, we can send them back to
    the browser as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of the nature of this application, we will have more models than usual.
    The two obvious ones are the `Word` model and its collection, `Game`. These hardly
    require explanation. However, remember that we''ll split words into parts, which
    we''ll call tokens. For this, we''ll have a `Token` model and a `Tokens` collection.
    These are actually the simplest parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these are just shells for the chopped-up words, there doesn''t need to
    be much to them. All the primary logic will be in the `Word` and `Game` classes.
    Let''s start with the `Word` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Every `Word` instance will need to be assigned a point value. It's not that
    tricky; just add the length of the word and its difficulty level. Later, multiply
    this value with another that's based on time. The other method calls the `Word.split`
    function, passing it the word. This is where the code gets a little more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we get to splitting up words, notice that the `split` method
    is a static or class-level method. This isn''t something we''ve seen before in
    Backbone; but Backbone makes it very simple to add static methods. So far, we''ve
    only ever passed one parameter to the `Backbone.Model.extend` method; an object
    of instance-level properties and methods. However, the method can take a second
    object, with class properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This isn't just for models; it works with collections, views, and even routers.
    So, add a class properties object to the preceding `Word` model; we'll be using
    it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Randomly splitting the words into tokens is not as easy as you think. We want
    to do it randomly, so that each time a game is played, a word may be split up
    differently. We want to split every word into tokens of two, three, or four letters.
    You might think, then, that we could randomly select one of those numbers. However,
    we don''t really want equal amounts of all three sizes; we''d like fewer two-letter
    tokens. This requires a weighted random selection, so we first have to write a
    function for that. The way to represent our weighted options is through an array
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Each array within this array has two elements. The first is the value we want
    to use; this could be a string, an object, or anything. The second value is the
    chance that this will be the value chosen. As you can see from this array, the
    value 2 will be chosen 20 percent of the time, and values 3 and 4 will be chosen
    40 percent of the time, each. So, here''s the function that takes that array as
    a parameter. Remember to put this in the class properties object of the `Word`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to add up the percentage values in the arrays. In our case,
    these values add up to 1, but they don''t have to; if they add up to some other
    value, this will still work. We do this by calling the native reduce method on
    the array, summing up all seconds elements. The next step is to create a new array,
    which the weight values sum up as they go along. For example, our weight values
    are 0.2, 0.4, and 0.4\. For these values, we need to create an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we create a `sum` variable and an array called `list`. Then, we loop over
    the items, adding the value to the `sum` variable, and then pushing that `sum`
    variable into the `list` array. We now have the array we need. Finally, we''ll
    return a function. The function will start by getting a random number between
    0 and the total. Then, we''ll loop over the list, checking each item to see whether
    it is less than or equal to the random number. Once we get a match on that, we''ll
    return the value from the original items parameter, using the same index number.
    That''s all for our weighted random generator. Now, we''re ready to use this in
    the function that splits the word into tokens. This is the `split` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a word and splits it into tokens. First, we split the string
    into an array, and then create an array to hold the tokens. Next, we create three
    random generators, which we'll need at different points. Then, we have a `while`
    loop, for when the length of the word is greater than zero. If the length of the
    word is greater than five characters, we'll use the generator that will return
    a 2, 3, or 4\. If the word is five characters long, we'll use the generator that
    returns either 2 or 3\. If it's four characters long, we'll use the generator
    that will return either 2 or 4\. The final `else` statement will be used if the
    word is shorter than four characters; we'll use the length of the word.
  prefs: []
  type: TYPE_NORMAL
- en: All of this ensures that the word will be split up into tokens of two, three,
    or four characters; it also makes sure that we'll never get a one-letter token,
    by slicing off all but one of the letters. The last step in the `while` loop is
    to use the word array's `splice` method. This method will mutate the original
    array, taking those letters out of the array and returning them (this is how the
    word length changes in the `while` loop condition). Once we've split up the word
    into tokens, we return the array of tokens. This is the function used in the `Word`
    class's parts method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection class for this is `Game`. This will start out very simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This really is just the start. One of these collection instances will handle
    much more, but we'll get there. We start by setting the model class for this collection,
    and then we create the `initialize` method. A collection object will be responsible
    for tracking time and points, so we give it a `seconds` and `score` property.
    Since our game will have levels, we also have a `level` property. Then, we have
    the `getWords` method.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, we aren't sending a set of words with the initial page load, so
    this is the method that will do that. This makes an AJAX request to the route
    we created to send the words. The `Backbone.ajax` method actually wraps the `jQuery.ajax`
    method. It returns a promise, which we learned about in [Chapter 6](ch06.html
    "Chapter 6. Building a Podcast Application"), *Building a Podcast Application*,
    here. We call its `then` method, passing it the collection's `reset` method. This
    method will replace any models in the collection with the array of models passed
    as a parameter. The `then` method will return the promise object, so we return
    it. This way, we can perform an action after the words have been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice the `tokens` method; in here, we call the collection's `invoke`
    method. This method takes the name of another method and calls it on each model
    in the collection. This will return an array of values; in this case, the values
    will be an array of tokens, the split-up words. An array of arrays isn't useful,
    so we'll use Underscore's `flatten` method to flatten the nested arrays into a
    single array of tokens. Then, we return a `Tokens` collection instance, mapping
    the `tokens` array into an array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the tokens view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the models more or less in place, we''re ready to start writing
    the actual views. Let''s start with something simple: the tokens. We start with
    the `TokensView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing this class is very simple. We get the collection of tokens from the
    game, call the built-in `shuffle` method to shuffle the tokens, and then render
    them each with the `addToken` method. This method renders a `TokenView` instance
    and appends it to the element. So that''s the next stop—the `TokenView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `TokenView` instance will have a class: `token`. The `render` method is
    pretty basic—it just puts the text of the token in the element. However, notice
    the first line of the method; we''re giving the model a view property that points
    to this view. This is something we haven''t done before; we have never given a
    model a link to the view that renders it. This isn''t always considered a good
    thing; it''s often better to keep a clean separation between the model and the
    view. However, sometimes this can be a good thing, as we''ll see in this case.
    Either way, it''s very easy to do. When this element is clicked on, the `choose`
    method will be called. This method triggers the `token` event, using the model
    as a parameter. We''ve triggered events before, but this is the first time we''ve
    used the `Backbone.trigger` method. We can use this to trigger and listen for
    events globally across all our code. After we trigger the event, we''ll hide the
    view. We have `hide` and `show` views here as well. These add or remove a class
    on the element to hide or show the token respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, this would be the point where we start the router, so we can render
    our view and then style it. However, we''re going to go a different route this
    time. Often, when building a more complex application, you''re on a roll with
    whatever you''re working on—the views, in our case—and you don''t want to switch
    mindsets. What I''ll do in a case like this is put a `script` tag in the `index.ejs`
    file to test the view we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quick and dirty; we create a `Game` object, get a set of words, and then
    append a new `TokensView` instance to the page. You should see something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the tokens view](img/6997OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the individual tokens and open your developer tools, you''ll
    see that they get the `hidden` class, just like we coded. Of course, nothing else
    happens right now, but that''s because we don''t have anything listening for the
    `''token''` event. It''s a good start, and it''s enough to begin the styling.
    So, open the `style.css` file of the `public` directory. Let''s start with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re starting this by pulling in a Google font. There are several to choose
    from at [https://www.google.com/fonts](https://www.google.com/fonts); we''re going
    with Lato. On the `<body>` element, we''ll set the font, font color, and background.
    Then, we''ll set a width on the main `<div>` element, the one most of our application
    will be inside. Next, we''ll add some styling to our anchor elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All the links will get a bit of styling—no underline, some bolding, and a new
    color—but only anchors in the main element will get the hover styling. This is
    because we''re soon going to create a navigation bar (outside the main element),
    and we don''t want the links to be underlined when hovered over. Now, we''re ready
    to style the tokens, which we do with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We style the token as, basically, an orange block. We space them out evenly;
    we use the *n*th-child selectors to remove the margin from the outer edges of
    the other blocks. We add a hover effect to the blocks. Finally, we add the `hidden`
    class. Now, a refresh of the page should result in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the tokens view](img/6997OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looking pretty good, don't you think? Now, we're ready for the next view, the
    ones that display the clues, that is, the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Views of the clues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The clues for the words—the definitions—will need to appear above the tokens.
    The `CluesView` class is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The clues will be in a table. In the `render` method, we''ll loop over the
    collection, rendering a `ClueView` class for each `Word` model. The `ClueView`
    class is where all the action takes place. Here''s the `ClueView` class''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This view will use a table row element, and it's the first view we have that
    uses a template. To render the template, we'll just pass the JSON version of that
    model to the `template` function. In the `initialize` method, we listen for the
    `correct` event to occur. This is the event that will be triggered when the player
    has correctly guessed one of the words. This is another global event that we'll
    fire at another location. When it happens, we'll call the `correct` method. This
    method will receive as a parameter the `Word` model for the correct word. Even
    though only one word has been guessed, all the `ClueView` instances will be listening
    for the correct event. So, the first step will be to compare words and to find
    the right `ClueView` instance. If the model for this view matches, we'll add the
    `correct` class. Then, we'll remove the `clue` class from part of the template
    and add the word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the template, add this to the `index.ejs` file in the `views` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you know, this will go inside our table row element. The first `<td>` element
    will have the definition. The second will start by displaying the number of letters
    in the word, as another small clue. As we''ve seen, when they correctly guess
    the word, the clue will be replaced with the word itself. Before we check this
    out in the browser, let''s add some styling to the `style.css` file in the `public`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We'll straighten up the `table` element and the first `<td>` cell in each row.
    When the second `<td>` cell has the number of letters in it, the `clue` class
    will reduce the font size a little. Then, when the word is correctly guessed,
    we'll remove that class and add `correct` to the whole `<tr>` element, coloring
    it and making it bold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in the `index.ejs` file, you can render this view in that same quick
    and dirty way. Replace the content inside the `getWords` callback with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, refresh the page. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Views of the clues](img/6997OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can''t yet see the correct word styling, because we can''t yet guess words.
    That brings us to the next step: the guess view.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the guess view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be the longest view in our application, because it''s got the most
    to do. Let''s start this one with the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks simple. The first `<div>` element is where the token text will appear
    as the player clicks on tokens. The second `<div>` element will be a button; when
    they click on it, their guess will be "submitted". If the guess is one of the
    words, it will appear alongside the correct definition. Otherwise, the tokens
    will reappear with the other tokens. This is the code for the `GuessView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here's the start; we'll give this element a class called `guess`, and we'll
    get the preceding template that we just created. In the `initialize` method, we'll
    listen for the `token` event. Remember, when one of the tokens is clicked on,
    this event will trigger globally. Here, we catch that event and run our `add`
    method. The other thing going on in the `initialize` method is the creation of
    a `currentTokens` property. This will keep track of the tokens the user selects
    before they actually make a guess. In the `render` method, we'll get the template
    (which is just a string in this case, because there's no template data in this
    view), and then create a property that points to the `<div>` element we're using
    as a text field. This property is used in the `add` method; the method gets the
    `Token` model as a parameter. We'll cache the token in the `currentTokens` array,
    and append its text to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue with this, let''s style it. You know where to go—the `style.css`
    file in the `public` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Both the inside `<div>` elements have the class `btn`; we'll float them to the
    left and apply height, width, and coloring. Then, for the one with both the `btn`
    and `text` classes, we'll adjust the background color and width. When the actual
    button `<div>` is hovered over, we'll change the background color a bit, as buttons
    should do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s render this view. Back in the `index.ejs` file change the `getWords`
    callback one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this in the browser and click on a couple of tokens. You should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the guess view](img/6997OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After playing with this, you should see two changes we need to make to this
    view. The big obvious one is that our **Guess** button doesn''t do anything. The
    smaller, design-related problem is that the red border of our `GuessView` class''s
    `<div>` element doesn''t change color when the button is hovered over. Since they''re
    the same color, this would be a nice touch. However, we can''t use CSS to change
    an attribute on a parent element when a child element is hovered over. Don''t
    worry, JavaScript is here to rescue the situation. Add these two events to the
    `GuessView` class''s events property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When the button receives the `mouseover` or `mouseout` event, we''ll call the
    `color` method. This method is really simple; all it does is toggle the `border`
    class on that parent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this means that we''ll have to add a `border` class to our CSS file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on the more important problem; allowing the player to make
    an actual guess. We already have the `GuessView` class ready for the click on
    the **Guess** button. When this happens, we call the `guess` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to check this word against the collection. We do this by calling
    the collection's `guess` method. We haven't written this yet, but it will return
    an object with two properties. The first is the `word` property. If the guess
    is a word in the collection, this property will be the `Word` model itself; otherwise,
    it will be `undefined`. If there is a `Word` model, we'll trigger the `correct`
    event, passing along the `Word` model. Remember, the `ClueView` instances are
    listening for this event. If `results.word` is `undefined`, this means the tokens
    did not spell one of the words, and they need to be replaced. So, we'll loop over
    the tokens and call the `show` method on the `view` property that we gave them
    when rendering those views. In either case, we'll empty the `currentTokens` property
    and clear the text from the `guessText` property. The last step is to check for
    a `complete` property on the `results` object. If this is `true`, the player just
    completed the last word and finished the game. If the game is done, we'll trigger
    a `completed` event, passing the game object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to write the `Game` collection''s `guess` method. Back in
    the `models.js` file of the `public` directory, add this method to the `Game`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a `results` object with the `word` and `complete` properties.
    The `complete` property will be `false` by default; for the `word` property, we
    will search the collection to find a word model that matches the text we passed
    into this method. The `findWhere` method will return `undefined` if no word is
    found. However, if a `Word` model is found, we'll give that model a temporary
    property. We'll set `correct` to `true`. Since the player has just guessed a word
    correctly, the next step is to update the score. We create a `score` variable;
    it starts with the basic `points` property on the `Word` model. Then, we need
    to calculate the multiplier. As we saw earlier, a `Game` instance will have a
    `seconds` property; soon, we'll see how this will count up.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll divide the seconds count by 15, round it with `parseInt`, and
    subtract it from 10\. Then, if that results in a number less than or equal to
    `0`, we'll reset `mult` to `1`. This way, any correct guesses in the first 15
    seconds will get a 10x multiplier, anything in the second 15 seconds will get
    a 9x multipler, and so on. After 2 minutes and 30 seconds, the multiplier will
    be 1\. Then, we'll increment the `score` property by the word `score` times the
    multiplier. Finally, we'll compare the number of words with the `correct` property
    to the total number of words in the collection. If these are equal, `results.complete`
    will be `true`, because all the words have been guessed correctly. Finally, we'll
    return the `results` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with this in place, we can refresh the page and actually play our game.
    Go ahead, give it a whirl! Here''s what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the guess view](img/6997OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pretty impressive, don't you think? We can pretty much play our game. However,
    there are a lot of details to take care of. While we are playing the game here,
    we aren't actually keeping score yet. So that's the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Building the info view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next class is for what we''ll call the `InfoView` class. This will have
    both the time counter and the current score. We''ll start with the template. Add
    this to the `index.ejs` file in the `views` directory: we''re creating two `<span>`
    elements: one for the time and another for the points. Here''s the code of the
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we write the view class, we need to add a few more methods to our
    `Game` collection class. The `guess` method that we wrote earlier keeps track
    of the player''s score. We also want a `Game` instance to track the time. The
    counter will be inside the game instance, but the `InfoView` class will have to
    actually show the time. This is the `start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start` method is what the `InfoView` class will use. It takes a `callback`
    function as a parameter and assigns it as a property of the instance. Then, it
    calls the `loop` method. This method increments the `seconds` count, and then
    calls the `callback` function, passing it the result of the `time` method (that''s
    next). Then, we''ll set a timeout for this method to be called again in one second;
    we have to bind `loop` to `this`, so the value of `this` will remain the same
    each time we call it. The `time` method just returns the `seconds` count as a
    nice timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty basic math. We can use the division and modulus operators, and the
    `parseInt` function, to create a time string. So, when the `seconds` count is
    42, the string will be "00:42"; 73 will be "01:13". If the time is over an hour
    (which is unlikely, but possible), we'll add the hour count to the front. This
    time, string is the value that will be passed to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the actual class. We''ll give the element the class `info`,
    and we''ll fetch the template. This is the code of the `InfoView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `render` method begins by using the template string, and then creating two
    properties for the timer element and the score element. Then, we call the `collection.start`
    method that we have just written. Remember that this method takes a callback that
    will receive the time string, so, we can just pass it the jQuery `text` method
    bound to our `this.time` element. This will now count the time for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the `initialize` method, let''s add a little bit of styling
    to this. Add this to the `style.css` file in the `public` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s nothing big; we just up the font size and add some margin. Now, add an
    `InfoView` instance to the quick and dirty test we''ve been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Load this in the browser, and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the info view](img/6997OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `initialize` method, we listen for two application-wide events.
    When the player guesses a word correctly and the `correct` event is triggered,
    we''ll call the `updateScore` method. As you can see, this will set the text of
    the score element by using the `score` property that we''re updating on the collection
    object. The other event we''re listening for is the `completed` event, which will
    be triggered when the game is completed. When this happens, we call the `stop`
    method on the collection object. This method has two jobs to do. First, it must
    stop the timer, and secondly, it must log the game to the server. This is the
    last method to add to the `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create the timeout in the `loop` method, we assign it to the `this.timeout`
    property. In this `stop` method, we can clear the timeout to stop the timer. Then,
    we store the current game data to the server. Instead of doing this the Backbone
    way—by creating a model and using an instance of it to send the data to the server—we
    just use the `Backbone.ajax` method to POST this data to the server. If you''d
    rather use a model, it''s very simple. First, create the model class in your `models.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the `Backbone.ajax` call with a `GameInfo` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not actually going to do it this way, because we don''t use the `GameInfo`
    class anywhere else. However, the beauty of these methods is that the server-side
    code is identical in both cases. Open the `server.js` file again, and add this
    router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to see that the user is logged in; we do this because we need
    the `req.user` object in this method, and we don't want to get an error. If a
    user is logged in, we'll put together a game object, with the time, score, and
    date that we sent from the browser. Then, we'll push that game object into the
    user's game array. You might recall that the user object has score and time properties
    of its own; these are for their highest score and lowest time. If the score or
    time from this game is better than the user's best, we'll update their best results.
    Finally, we'll store the updated record in the database. Of course, the last step
    is to return the game as JSON, but we won't really use that on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping our views in a GameView class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, for the user to play the game, we are rendering four views.
    Let''s wrap these views up into a single view: the `GameView` class. It is a pretty
    short view, but it will clean up the code in our router, once we start the router.
    Here''s the code for the `GameView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, we''ll create the four views, and append them to the
    element. We can test this view very easily—just replace the `callback` function
    code that creates the four views with this single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Nothing will look any different in the browser, and that's exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re finally ready to begin building the router. As you might recall from
    the `index.ejs` file in the `views` directory, we pull in a `router.js` script,
    and so, create a `router.js` file in the `public` directory. Let''s start with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As in our previous applications, the `initialize` method will take an `options`
    object, which will set the main element for the application. In the `routes` object,
    you will see that we create two routes. To play the game, we can go to either
    `/play` or, say, `/play/2`: both routes call the `play` method. This method creates
    a `Game` collection object; if a level was selected via the route path, we''ll
    set it; otherwise, we''ll stick with the default level (level 1). Then, we can
    get the words and create the `GameView` instance once we have those words.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to get rid of our quick and dirty test and replace it with
    the use of our router. In the `index.ejs` file of the `views` directory, this
    is what the final script tag (the inline script) should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can go back to the browser and try the routes `/play` or `/play/3`.
    You should be able to play the game just as before.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the home view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user first comes to our website, we don''t want to display the game
    view right away. Most web applications will have some kind of home view, or welcoming
    view, explaining the purpose of the application. We could make that a server-side
    template, but we''re going to make it a Backbone view instead. Here''s the code
    of the `HomeView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the template with the `id` property of `home` from the `index.ejs` file.
    The `render` method is simple. The `events` object listens for clicks on anchor
    elements and calls the `chooseLevel` method. We''ve seen a method like this before;
    it just prevents the default action—the page refreshing—and uses `Backbone.history`
    to change the view instead. Finally, here''s the template for this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s style the `<h1>` elements a little bit. You know where this goes—in
    the `style.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to use this view in the router. Open the `router.js` file in the
    `public` directory and add the `index` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll add the `index` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should be able to go to the root route and see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the home view](img/6997OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building a scoreboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already built the primary view for this application. However, every
    complete web application will have several views that aren''t specific to the
    main purpose of the application, but help round out its usefulness. In our application,
    this will be a scoreboard view; a place where players can see each other''s best
    time and score. Let''s start on the server side this time, in the `server.js`
    file. Add this route before the catch-all route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We start by getting all the users in the database. Then, we loop over each user,
    adding a `totalScore` property to each one. We loop over the `games` array for
    each user and sum up the score for each game, creating the `totalScore` property.
    Note that we don't actually change anything in the database; we just create a
    temporary property here. Then, we sort the `userRecords` array; by default, the
    array's `sort` method will sort alphabetically, so we pass a function here that
    sorts the users from highest- to lowest-scoring. Then, we'll render the `scoreboard.ejs`
    template in the `views` directory, passing it the `userRecords` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code of the `scoreboard.ejs` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As with our other full-page templates, we''ll open and close with the header
    and footer includes. Then, we''ll create the main element. This element has a
    table element inside it. We start with a `<thead>` element, with four column headers:
    the player''s name, total score, best game score, and best time. Then, inside
    the `<tbody>` element, we loop over the `user` array and add a row for each user.
    We use one of the EJS''s features here: filters. For example, we print the `user.username`
    property, but we filter it through the `capitalize` filter so that the first letter
    will be, you guessed it, capitalized. Then, the `user.time` property is a seconds
    count, so we filter it through the `time` filter to display it as a human-friendly
    string. However, this isn''t a built-in filter, so we''ll have to write it ourselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `server.js` file, we first require the `ejs` library that Express
    uses behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to write the filter function. We can actually just copy and adjust
    the time method from the `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step for the scoreboard is to add some styling to the user''s table.
    Once again, turn to the `style.css` file in the `public` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s nothing too fancy, but it will do the job. We''ll add some padding and
    color the background, and we''re done! Here''s the final product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a scoreboard](img/6997OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing the navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next part of our application will pull things together; it is the navigation
    bar. In previous applications, the navigation has been its own Backbone view,
    but this is not the case this time. Instead, we''ll create a new server-side template
    just for navigation. We''ll be able to use this as an include, as we did with
    the header and footer templates. So, create the `nav.ejs` file in the `views`
    directory and put the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a basic list; there isn''t much navigating to do in our application.
    But of course, we''ll need to add some styling. Here''s the last addition to the
    `style.css` file in the `public` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This styling creates a nice navigation bar at the top of the page, with a nice
    hover effect on each link. The last part adds a color to the first item to make
    it appear like a logo. Now, add this as an include, under the header include of
    both the `index.ejs` and `scoreboard.ejs` files, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the navigation](img/6997OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding new words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add one more feature to our application; the ability to add new words
    to the word list. We won''t allow just any user to do this, only administrators.
    How exactly can we make a user an administrator? Well, we''ll cheat. Open the
    `users.json` file directly, and add an `"admin":true` property to the user object
    of our choice. Then, we''ll open the `server.js` file; first is the GET route
    for `/new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If there''s a user logged in, and that user is an administrator, then we''ll
    render the new word template. Otherwise, we''ll redirect to the root route. Create
    the `new.ejs` file in the `views` directory, and write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We will post to the `/new` route when the form is submitted. We have an input
    element for the word and its definition (we could use a text area here, but an
    input element will encourage a short definition). Then, we have a set of radio
    buttons for choosing the level. Since this will post to the same route, we need
    a POST route on the server side to catch the new word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If there's an admin user logged in, we'll create a word object, `w`. Then, we'll
    check the word's database to see if the word already exists; if it doesn't, we'll
    insert it. Finally, we'll return to the form so that the administrator can insert
    another word if they want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add this path to the navigation, but only when an administrator
    is logged in. In the `nav.ejs` file of the `views` directory, add this as the
    last list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, everywhere we call the `res.render` function on the templates that use
    `nav.ejs` (that''s `new.ejs`, `scoreboard.ejs`, and `index.ejs`), we add the `admin`
    value to the values passed to the template. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If a user is logged in and they are an administrator, admin will be `true`.
    Otherwise, it will be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of the last chapter. The first big idea we looked
    at in this chapter is not loading any application data with the initial page load.
    If your application uses a lot of data, this can often be a good idea. Not only
    does this shorten the initial page load, but it also prevents you from loading
    data that the user doesn't need (for example, if the user never uses a specific
    feature of the application, the data needed for that feature never loads).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing to remember from this chapter is that a Backbone application
    may not be just Backbone pages. Our scoreboard page is a good example of this.
    It wouldn''t have been difficult to create that page via Backbone—just create
    a `User` model and a `Users` collection and a couple of views—but since the user
    records don''t really have any client-side relevance, apart from being logged
    in, we took the simpler route of doing it from the server side. Your web app will
    likely have other pages too that don''t need data: a contact page, an FAQ page,
    that kind of thing. Don''t forget about these details!'
  prefs: []
  type: TYPE_NORMAL
- en: Most of what we've covered in this chapter is a review of the primary ways of
    using Backbone's main components, the model, the collection, the view, and the
    router. As with anything, the beauty of having a complete understanding of the
    way something works is that you are then free to bend it in whatever way you choose.
    Throughout this book, we look at several different ways of doing almost anything
    in Backbone. If you take only one thing away from it all, let it be this; it's
    just JavaScript, and there are countless other ways not mentioned here to create
    patterns of your own. It could be said that programming is just as much about
    self-expression as anything else, and a skilled programmer isn't afraid to experiment.
    Here's just one example for the road. What if the `initialize` method of a view
    class ended by calling the `render` method? Have fun with your Backbone applications!
  prefs: []
  type: TYPE_NORMAL
