<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Coffee with Strangers</h1></div></div></div><p>In this chapter, we will write an API that allows users to go for a coffee! This comprises of a simple yet extendable user matching system.</p><p>Initially, we'll just ask the user to enter their name and e-mail, which is stored on MongoDB. Whenever we can match these with the nearest other user, e-mails are sent to both sides and then it's coffee time. After we set up the base, it's time to make sure we keep a record of the matches and avoid duplicates from happening for a better user experience.</p><p>Soon after, let's make ourselves ready to go global and take into account their geo positioning.</p><p>Assuming everything goes well (which is a mistake), we are validated. So it's time to refactor to a more maintainable architecture, where the pairing becomes a service by itself.</p><p>Finally, let's allow our users to rate how their meeting was and tell us whether it was a successful meeting or not in real-world applications, the usage of user generated feedback is invaluable!</p><p>We expect that this sort of application structure will offer the reader inspiration to create real world matching applications.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Code structure</h1></div></div></div><p>Before getting<a id="id193" class="indexterm"/> into actual code, we want to provide a heads up on the structure for the code in this chapter, which is a bit different than before, and we hope it adds another view to structure code for Express and Node.js in general.</p><p>Some may call it a <strong>Factory pattern</strong>; it consists of wrapping each of the file's code with a function<a id="id194" class="indexterm"/> that can be used to configure or test it. While this requires a bit more of scaffolding, it frees our code from depending on a static state. It will often look as follows:</p><div><pre class="programlisting">'''javascript
module.exports = function (dependency1){
  // these will be public
  var methods = {}

  // individual for each instance
  var state = 0

  // some core functionality of this file
  methods.addToState = function(x) {
    state += x
  };

  methods.getResult = function() {
    return dependency1.getYforX(state)
  };

  return methods
}
'''</pre></div><p>A<a id="id195" class="indexterm"/> corollary of this structure is that each invocation of this file will have its own state, exactly like the instance of a class, except we don't depend on this, but the scope that never goes missing.</p><p>Going a bit further, we'll try centralizing the structure of the pieces per folder, each with a respective <code class="literal">index.js</code>, the main responsibilities of which are to initialize instances when needed, keep references to dependencies that will be passed down, and return only public methods.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Defining routes</h1></div></div></div><p>Let's<a id="id196" class="indexterm"/> start by defining the first routes we need and how we want them to behave and simple logical steps building what's strictly essential first, in a TDD style.</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing is that we need users to be able to register; the smallest test case to register our user is as follows:<div><pre class="programlisting">'''javascript
var dbCleanup = require('./utils/db')
var expect = require('chai').expect;
var request = require('supertest');
var app = require('../src/app');

describe('Registration', function() {
  it("shoots a valid request", function(done){
    var user = {
      'email': 'supertest'+Math.random()+'@example.com',
      'name': 'Super'+Math.random(),
    };

    request(app)
      .post('/register')
      .send(user)
      .expect(200, done);
  })
})</pre></div></li><li class="listitem">Assuming<a id="id197" class="indexterm"/> you have Mocha installed with <code class="literal">npm i -g mocha</code>, execute <code class="literal">mocha</code>.</li><li class="listitem">See 404? Good start! Now let's expand and create a file, <code class="literal">src/route/index.js</code>, which will declare all the routes known to the app. It uses controllers that handle each concern.</li><li class="listitem">Start with <code class="literal">user.js</code>, which implements a create action, as shown in the following code:<div><pre class="programlisting">'''javascript
// src/routes/index.js
module.exports = function() {
  var router = require('express').Router();
  var register = require('./user)();
  router.post("/user", user.create);
  return router;
};

// src/routes/user.js
module.exports = function() {
  var methods = {};

  methods.create = function(req,res,next) {
    res.send({});
  }

  return methods;
};</pre></div></li><li class="listitem">This amount of code should be enough to make the tests pass with Mocha.<div><img src="img/0818_05_01.jpg" alt="Defining routes"/></div></li><li class="listitem">For this<a id="id198" class="indexterm"/> app, we'll have all route definitions in one place, that is, <code class="literal">routes/index.js</code>.</li></ol></div><p>At this stage, we know that the testing setup works. Next, let's move onto persistence and some business logic!</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Persisting data</h1></div></div></div><p>Adding<a id="id199" class="indexterm"/> some diversity to the libraries, let's experiment with Mongojs (<a class="ulink" href="https://github.com/mafintosh/mongojs">https://github.com/mafintosh/mongojs</a>), a simple library for MongoDB that <a id="id200" class="indexterm"/>aims to be as close as possible to the native client.</p><div><ol class="orderedlist arabic"><li class="listitem">First things first, let's create a small config file, <code class="literal">./config.js</code>, to store all the common data and just return a simple object with relevant configurations for each environment. For now let's just make sure we have a URLin a format accepted by Mongojs.</li><li class="listitem">This file should be able to hold all global configs for the app. It ensures we also have different settings depending on the environment.<div><pre class="programlisting">module.exports = function(env) {
  var configs = {};
  configs.dbUrl = "localhost/coffee_"+env;
  return configs;
};</pre></div></li><li class="listitem">This file needs to be in <code class="literal">app.js</code>, a central place to initialize and gather dependencies, and it will be passed to our DB, which then returns public methods. Let's see that happening in the following code:<div><pre class="programlisting">'''javascript
//..
var config  = require('../config')(app.get('env'));
var models  = require('./models')(config.dbUrl);
app.set('models', models);
//..</pre></div></li><li class="listitem">For our<a id="id201" class="indexterm"/> models, let's define one file to rule them all s<code class="literal">rc/models/index.js</code> with its main responsibilities being to instantiate the db and expose public methods to other modules so that storage details stay encapsulated, keeping the code clean and decoupled.<div><pre class="programlisting">'''javascript
module.exports = function(dbUrl) {
  var mongojs = require('mongojs');
  var db = mongojs(dbUrl);
  var models = {
    User: require('./user')(db)
  };
  return models;
};</pre></div></li><li class="listitem">Our first model, <code class="literal">user</code>, has the ability to create one user. Notice that we are not making any validations in this model to keep things simple. Don't go to production without having the models double-checked.<div><pre class="programlisting">'''javascript
module.exports = function (db) {
  var methods = {};
  var User = db.collection('users');

  methods.create = function(name,email,cb) {
    User.insert({
      name: name,
      email: email
    }, cb)
  };

  return methods;
}</pre></div></li><li class="listitem">Let's update our <code class="literal">user.js</code> route to make use of our DB:<div><pre class="programlisting">'''javascript
module.exports = function(Model) {
  var methods = {};


  methods.create = function(req,res,next) {
    Model.User.create(req.param('name'), req.param('email'), function(err, user) {
      if(err) return next(err);
      res.send(user);
    });
  }</pre></div></li><li class="listitem">With<a id="id202" class="indexterm"/> this simple change, we should have a user created in our DB.</li></ol></div><p>Let's open<a id="id203" class="indexterm"/> Robomongo (<a class="ulink" href="http://robomongo.org/">http://robomongo.org/</a>) to see what user data was created; it's super handy to lookup what data we have in MongoDB no matter what library we use.</p><div><img src="img/0818_05_02.jpg" alt="Persisting data"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Exception handling</h2></div></div></div><p>Let's open<a id="id204" class="indexterm"/> a parenthesis here and talk about the <code class="literal">if(err) return next(err);</code>.command This is a pattern that is used to abstract error handling in a <a id="id205" class="indexterm"/>single action that is supposed to be treated in Express further down the stack, via <code class="literal">app.use</code>.</p><div><ol class="orderedlist arabic"><li class="listitem">To keep things neat, we can abstract error handling to a file of its own where we will define specific handlers for each type of error <code class="literal">src/routes/errorHandler.js</code>.</li><li class="listitem">Let's define a <code class="literal">catchAll()</code> method for now. Express will know the type of use for this function because its functionality is 4.<div><pre class="programlisting">'''
module.exports = function() {
  var methods = {};

  methods.catchAll = function(err, req, res, next) {
    console.warn("catchAll ERR:", err);
    res.status(500).send({
      error: err.toString ? err.toString() : err
    });
  }

  return methods;
};
'''</pre></div></li><li class="listitem">Lastly, it's activated in <code class="literal">routes/index.js</code>. error handling should be the very last middleware(s):<div><pre class="programlisting">//..
  router.use(errorHandler.catchAll);

  return router;
};</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Naive pairing</h1></div></div></div><p>The <a id="id206" class="indexterm"/>simplest pairing system we can implement is to simply lookup if there is another user available without a pair whenever someone signs up.</p><p>In order to do so, we'll start a new collection and model: Meeting, which will be the base matching structure we'll be expanding on. The fundamental idea here is that each document will represent a meeting; either it's in the request phase, already set or occurred, finally will also store the feedback.</p><p>We'll be elaborating and defining the structure for it as it goes. For an initial implementation, let's run the scheduling logic right when the user decides to be matched. The strategy will be to look for a meeting document, where only the first user is set, and update it. In <a id="id207" class="indexterm"/>case there is no document like that, let's create a new one.</p><p>There are a couple of race conditions that might kick in, which we certainly want to avoid. These are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user who's trying to find someone to schedule gets scheduled in the middle of the process.</li><li class="listitem" style="list-style-type: disc">The user who's available to be scheduled is selected but then reserved by someone else.</li></ul></div><p>Lucky MongoDB offers the <code class="literal">findAndModify()</code> method, which can find and update on a single document automatically, while also returning the updated document. Keep in mind that it also offers an <code class="literal">update()</code> method to update multiple methods.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Check out the docs from the following link: <a class="ulink" href="http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method">http://docs.mongodb.org/manual/reference/method/db.collection.findAndModify/#comparisons-with-the-update-method</a>
</p></div></div><p>Let's get started with a new collection, <code class="literal">Meeting</code>, where we will keep track of a user's interest in finding a pair as well as keeping track of meetings as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">This document will contain all of the user's info up to that point in time, so we can use it as a history, as well as use its contents to send e-mails and setup reviews.</li><li class="listitem">Let's see what the code looks like in <code class="literal">src/models/meeting.js</code>:<div><pre class="programlisting">'''javascript
  var arrangeTime = function() {
    var time = moment().add(1,'d');
    time.hour(12);
    time.minute(0);
    time.second(0);
    return time.toDate();
  };

  methods.pairNaive = function(user, done) {
    /**
     * Try to find an unpaired User in Meeting collection,
     * at the same time, update with an pair id, it either:
     * 1. Add the new created user to  Meeting collection, or
     * 2. The newly created user was added to a Meeting document
     */
    Meeting.findAndModify({
      new: true,
      query: {
        user2: { $exists: false },
      },
      update: {
        $set: {
          user2: user,
          at: arrangeTime()
        }
      }
    }, function(err, newPair) {
      if (err) { return done(err) }

      if (newPair){
        return done(null, newPair);
      }

      // no user currently waiting for a match
      Meeting.insert({user1: user}, function(err,meeting) {
        done();
      })
    });
  };
'''</pre></div></li><li class="listitem">In the<a id="id208" class="indexterm"/> case of a successful pairing, <code class="literal">user2</code> would be set in the <code class="literal">Meeting</code> object to meet the following day at noon, as you can see on the attribute <code class="literal">at</code>, which we set via the <code class="literal">aux</code> <code class="literal">arrangeTime()</code> function and the<a id="id209" class="indexterm"/> lightweight library moment.js (<a class="ulink" href="http://momentjs.com/">http://momentjs.com/</a>). It's amazing to deal with dates in a super readable way. It is recommended that you take a look and become more familiar with it.</li></ol></div><p>Also, notice <code class="literal">new: true</code> as a parameter. It ensures that MongoDB returns the updated version of the object, so we don't need to duplicate the logic in the app.</p><p>The new object <code class="literal">Meeting</code> needs to be created, as it carries the information of the users at that point in time and can be used to compose the emails/notification for both.</p><p>This is a good opportunity to define some basic structure for our tests that will follow a pattern of making several calls to the endpoints and asserting the response. There is a thorough explanation about the decisions to implement tests immediately, as shown in the following code:</p><div><pre class="programlisting">'''
describe('Naive Meeting Setup', function() {
  // will go over each collection and remove all documents
  before(dbCleanup);

  var userRes1, userRes2;

  it("register user 1", function(done){
    var seed = Math.random()
    var user = {
      'name': 'Super'+seed,
      'email': 'supertest'+seed+'@example.com',
    }

    request(app)
      .post('/register')
      .send(user)
      .expect(200, function(err,res){
        userRes1 = res.body
        done(err)
      })
  });

  it('should be no meeting for one user', function(done) {
    models.Meeting.all(function(err,meetings) {
      expect(meetings).to.have.length(1);
      var meeting = meetings[0];
      expect(meeting.user1).to.be.an("object");
      expect(meeting.user2).to.be.an("undefined");
      done(err);
    });
  });

  it("register user 2", function(done){
    var seed = Math.random();
    var user = {
      'name': 'Super'+seed,
      'email': 'supertest'+seed+'@example.com',
    };

    request(app)
      .post('/register')
      .send(user)
      .expect(200, function(err,res){
        userRes2 = res.body
        done(err)
      });
  });

  it('should be a meeting setup with the 2 users', function(done) {
    models.Meeting.all(function(err,meetings) {
      expect(meetings).to.have.length(1)
      var meeting = meetings[0]
      expect(meeting.user1.email).to.equal(userRes1.email)
      expect(meeting.user2.email).to.equal(userRes2.email)
      done(err)
    });
  });
});
'''</pre></div><p>(Source:git checkout e4fbf672d409482028de7c7427eab769ab0a20d2)</p><div><img src="img/0818_05_03.jpg" alt="Naive pairing"/></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Notes about tests</h2></div></div></div><p>When<a id="id210" class="indexterm"/> using Mocha, a test is much like any javascript file and is executed <a id="id211" class="indexterm"/>as expected, allowing for any sort of regular Node.js require as you would do usually.</p><p>The <code class="literal">describe()</code> method is the context on which our tests execute; in our case, it's a full run of a certain functionality. The <code class="literal">before()</code> method will run once; in this case, our logic is set to clean up all of our MongoDB collections.</p><p>It stands for a simple expectation to be fulfilled. It will run in the same order it's declared, and we will try to make the assertions small and predictable as far as possible. Each of these functions defines steps and in this case, because we are doing end-to-end tests, we make requests to the API and check the results, and sometimes save it to variables that are used later to assert.</p><p>There are <a id="id212" class="indexterm"/>advices that say that tests shouldn't be dependent on the previous <a id="id213" class="indexterm"/>state, but those don't usually test the application flow, rather, individual portions of logic. For this particular test scenario, in case of a failure, it's important to interpret the error from the first <code class="literal">it</code> that fails; fixing it will likely fix errors after it. You can configure Mocha to stop at the first error by using the <code class="literal">-b</code> flag.</p><p>While testing, the most important point to make sense is that our test cases should make sure all of the expected cases are checked, and bad behaviors don't happen. We can never expect to predict everything that may go wrong of course, but it's still our duty to test as many points as we are certain about common issues.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Considering user history</h1></div></div></div><p>Our users<a id="id214" class="indexterm"/> will probably want to always be paired to meet new people, so we have to avoid repetitive meetings. How should we handle this?</p><p>First, we need to allow for a method to set up new meetings. Think of it as a button in an app that would trigger a request to the route <code class="literal">POST/meeting/new</code>.</p><p>This endpoint will reply with the status <code class="literal">200</code> when the request is allowed and a pair is found, or if there is no pair but they are now attached to a <code class="literal">meeting</code> object and can now be matched with another user; <code class="literal">412</code> if the user is already scheduled in another meeting and <code class="literal">400</code> in case the expected e-mail of the user isn't sent; in this case, it can't be fulfilled because the user wasn't specified.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The usage of status codes is somewhat subjective, (see a more comprehensive list on Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">http://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>). However, having distinct responses is important so that the client can display meaningful messages to the user.</p></div></div><p>Let's implement an Express.js middleware, that requires an e-mail for all requests that are made on behalf of the user. It should also load their document and attach it to <code class="literal">res.locals</code>, which can be used in subsequent routes.</p><p>Our <code class="literal">src/routes/index.js</code> will look like this:</p><div><pre class="programlisting">'''javascript
//...
  app.post("/register", register.create);
  app.post("/meeting", [filter.requireUser], meeting.create);
//...
'''

The filter in 'src/routes/filter.js' is:

'''javascript
module.exports = function(Model) {
  var methods = {};

  methods.loadUser = function(req,res,next) {
    var email = req.query.email || req.body.email
    if(!email) return res.status(400).send({error: "email missing, it should be either in the body or querystring"});
    Model.User.loadByEmail(email, function(err,user) {
      if(err) return next(err);
      if(!user) return res.status(400).send({error: "email not associated with an user"});
      res.locals.user = user;
      next();
    })
  }

  return methods;
};</pre></div><p>The goal <a id="id215" class="indexterm"/>of this middleware is to stop and return an error message for every request that doesn't have a user email. It's a validation that would usually require a username and password or a secret token.</p><p>Let's set up a small but important test suite for this middleware:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clear DB</li><li class="listitem" style="list-style-type: disc">Try to get me without email and fail</li><li class="listitem" style="list-style-type: disc">Create a valid user; it succeeds</li><li class="listitem" style="list-style-type: disc">Try to get me with another email; it fails</li><li class="listitem" style="list-style-type: disc">Access me with the email we registered and it works!</li></ul></div><p>Now that we have a way to load the user who's making the request, let's go back to the goal of matching people without repetition. As a pre-condition, their past meeting time has to be in the past already, otherwise it returns a <code class="literal">412</code> code.</p><p>If we want to schedule a meeting for our users but any scheduled meeting will be set for tomorrow, how <a id="id216" class="indexterm"/>can we test it? Meet timekeeper (<a class="ulink" href="https://github.com/vesln/timekeeper">https://github.com/vesln/timekeeper</a>), library with a simple interface to alter the system dates<a id="id217" class="indexterm"/> in Node.js; this is especially useful for tests. Look closely for the snippet of this test:</p><div><pre class="programlisting">'''javascript
describe('Meeting Setup', function() {
  before(dbCleanup);

  after(function() {
    timekeeper.reset();
  });

  // ...

  it('should try matching an already matched user', function(done) {
    request(app)
      .post('/meeting')
      .send({email:userRes1.email})
      .expect(412, done);
  });

  it('should be able match the user again, 2 days later', function() {
    var nextNextDay = moment().add(2,'d');
    timekeeper.travel(nextNextDay.toDate());
    request(app)
      .post('/meeting')
      .send({email:userRes1.email})
      .expect(200, function(err,res){
        done(err);
      });
  });</pre></div><p>It's of vital importance to set an <code class="literal">after</code> hook to reset timekeeper so that the dates go back to normal after the scenario is finished in either success or failure; otherwise, there is a chance it will alter the results of other tests. It's also worth checking how date manipulation is made easy with <code class="literal">moment()</code> method and once you use <code class="literal">timekeeper.travel() function</code>, the time is warped to that date. For all Node.js knows, the new warped time is the actual time (although it does not affect any other applications). We can also switch it back and forth as required.</p><p>The <code class="literal">Meeting</code> method to perform this check on our user (defined at <code class="literal">models/meeting.js</code>) is as follows:</p><div><pre class="programlisting">  methods.isUserScheduled = function(user, cb) {
    Meeting.count({
      $or:[
        {'user1.email': user.email},
        {'user2.email': user.email}
      ],
      at: {$gt: new Date()}
    }, function(err,count) {
      cb(err, count &gt; 0);
    });
  };</pre></div><p>The <code class="literal">$or</code> operator is necessary because we don't know whether the user we are looking for is going to<a id="id218" class="indexterm"/> be <code class="literal">user1</code> or <code class="literal">user2</code>, so we take advantage of the query capabilities of MongoDB that can look inside objects in a document and match the <code class="literal">email</code> as a <code class="literal">String</code>, and the <code class="literal">at</code> field as mentioned earlier.</p><p>Our newly created <code class="literal">src/routes/meeting.js</code>, is given as follows:</p><div><pre class="programlisting">'''javascript
module.exports = function(Model) {
  var methods = {};

  methods.create = function(req,res,next) {
    var user = res.locals.user;
    Model.Meeting.isUserScheduled(user, function(err,isScheduled) {
      if(err) return next(err);
      if(isScheduled) return res.status(412).send({error: "user is already scheduled"});
      Model.Meeting.pair(user, function(err,result) {
        // we don't really expect this function to fail, if that's the case it should be an internal error
        if(err) return next(err);
        res.send({});
      })
    })
  }

  return methods;
};</pre></div><p>Moving on, we'll define a very important helper function that finds previous meetings involving the user who's making the request and returns the emails of everyone they have been matched with, so we can avoid matching those two users again.</p><p>Helper functions like this are super useful to keep the code understandable when dealing with complicated pieces of logic. As a rule of thumb, always separate into smaller functions <a id="id219" class="indexterm"/>when a chunk of code can be abstracted into a concept.</p><div><pre class="programlisting">  /**
   * the callback returns an array with emails that have previously been
   * matched with this user
   */
  methods.userMatchHistory = function(user,cb) {
    var email = user.email;
    Meeting.find({
      $or:[
        {'user1.email': email},
        {'user2.email': email}
      ],
      user1: {$exists: true},
      user2: {$exists: true}
    }, function(err, meetings) {
      if(err) return cb(err);
      var pastMatches = meetings.map(function(m) {
        if( m.user1.email != email) return m.user1.email;
        else return m.user2.email;
      });
      // avoid matching themselves!
      pastMatches.push(user.email);
      cb(null, pastMatches);
    })
  }</pre></div><p>The key to <code class="literal">userMatchHistory</code> object; is through the MongoDB <code class="literal">$nin</code> operator, which performs a match when the element doesn't match what's in the array. The matching logic follows the very same logic we had in naive pairing.</p><p>In our <code class="literal">Meeting</code> model, we removed our previous <code class="literal">pairNaive</code> method with the <code class="literal">pair </code>method, which does similar, but first build a list of the previous matches to ensure we don't match those again.</p><div><pre class="programlisting">  methods.pair = function(user,done) {
    // find the people we shouldn't be matched with again
    methods.userMatchHistory(user, function(err, emailList) {
      if(err) return done(err);

      Meeting.findAndModify({
        new: true,
        query: {
          user2: { $exists: false },
          'user1.email': {$nin: emailList}
        },
        update: {
          $set: {
            user2: user,
            at: arrangeTime()
          }
        }
      }, function(err, newPair) {
        if (err) { return done(err); }

        if (newPair){
          return done(null, newPair);
        }

        Meeting.insert({user1: user}, function(err,meeting) {
          done();
        })
        return;
      });
    })
  }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Optimizing for distance</h1></div></div></div><p>Let's<a id="id220" class="indexterm"/> use a down-to-earth geolocation approach (ah! I'm so funny) to the match. We have to be realistic. Our service was born in Smallville but it's going global and we can't match people who are too far apart.</p><p>Because our meetings are arranged free of racing conditions on the <code class="literal">Meeting</code> collection and we would like to keep it that way, let's adapt our existing <code class="literal">pair</code> method to incorporate the user's location. We can assume that at registration, they will supply their location (or we could also easily update the meeting document once they provide the location). In our existing strategy, we have one user who creates a meeting document; in this case, let's also set their location, so the next user looking for a match will have to be in a similar location as an additional constraint, as shown in the following code:</p><div><pre class="programlisting">'''javascript
  Meeting.ensureIndex({location1: "2dsphere"});

  //..

  methods.pair = function(user,done) {
    methods.userMatchHistory(user, function(err, emailList) {
      if(err) return done(err);

      Meeting.findAndModify({
        new: true,
        query: {
          user2: {$exists: false},
          'user1.email': {$nin: emailList},
          'location1': {$nearSphere:{
            $geometry :
              { type : 'Point',
              coordinates : user.location } ,
              $maxDistance : 7*1000
          }}
        },
        update: {
          $set: {
            user2: user,
            at: arrangeTime()
          }
        }
      }, function(err, newPair) {
        if (err) { return done(err); }

        if (newPair){
          return done(null, newPair);
        }

        Meeting.insert({
          user1: user,
          location1: user.location
        }, function(err,meeting) {
          done();
        })
        return;
      });

    });
  }
'''</pre></div><p>Our <code class="literal">Meeting</code> collection now has <code class="literal">location1</code> indexed as <code class="literal">2dsphere</code>. The geoquery for this field can<a id="id221" class="indexterm"/> easily be integrated with our previous query, using the operator <code class="literal">$nearSphere</code> to match geo positions in a sphere object. <code class="literal">$maxDistance</code> is the maximum radius for the match. It's expressed in meters and in this case, we intersect the coordinates with <code class="literal">Point</code>, which is a previously registered user. <code class="literal">7km</code> was chosen arbitrarily because it seems like a reasonable enough radius to meet someone.</p><p>If we changed <code class="literal">$maxDistance</code> to something considerably smaller, some of our tests would fail because matches wouldn't happen; see <code class="literal">test/meeting_near.js</code>.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clear DB</li><li class="listitem" style="list-style-type: disc">Create user 1 in Santiago</li><li class="listitem" style="list-style-type: disc">Create user 4 in Valparaiso</li><li class="listitem" style="list-style-type: disc">Check whether there is a match</li><li class="listitem" style="list-style-type: disc">Create <a id="id222" class="indexterm"/>user 2 in Santiago</li><li class="listitem" style="list-style-type: disc">Check whether there was a match between 1 and 2</li><li class="listitem" style="list-style-type: disc">Create user 3 in Vancouver</li><li class="listitem" style="list-style-type: disc">Check whether 3 has a match</li><li class="listitem" style="list-style-type: disc">Create user 5 in Valparaiso</li><li class="listitem" style="list-style-type: disc">Check whether there is a match between 4 &amp; 5</li></ul></div><p>(Source:git checkout 52e8f80b7fe3b9482ff27ea1bcc410270752a796)</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>E-mail follow up</h1></div></div></div><p>Users can now be matched. The meetings are unique and made between people that are nearby, which <a id="id223" class="indexterm"/>is awesome! There is no end to possible improvements on a matching system; so instead, lets now collect some data about how their meeting went!</p><p>To do so, we'll send an email to each of the attendees, which will consist of a few simple options to promote engagement. Some of them are listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It was awesome</li><li class="listitem" style="list-style-type: disc">It was awful</li><li class="listitem" style="list-style-type: disc">Meh…</li><li class="listitem" style="list-style-type: disc">My pair didn't show up!</li></ul></div><p>Those values are added to <code class="literal">src/models/meeting.js</code> as key-value pairs, which we can store for ratings and use them to communicate back to users.</p><div><pre class="programlisting">  methods.outcomes = function() {
    return {
      awesome : "It was awesome",
      awful   : "It was awful",
      meh     : "Meh",
      noshow  : "My pair didn't show up!"
    }
  }</pre></div><p>We could store these responses in the respective <code class="literal">meeting</code> object, associating it with the user who responded.</p><p>For this<a id="id224" class="indexterm"/> purpose, we'll rely primarily on the package <code class="literal">Nodemailer</code> (<a class="ulink" href="https://github.com/andris9/Nodemailer">https://github.com/andris9/Nodemailer</a>). It is broadly used and offers support for a number of integrations, including transport providers and templates so we can make our e-mails dynamic.</p><p>Coming to<a id="id225" class="indexterm"/> the setup decision, as you probably realized Node.js &amp; Express are free of conventions about how to set up your code because these apps may do very different things and there is no one-size-fits-all. Let's make mailing a concern of its own, as much as persistence and routes are separated concerns integrated into <code class="literal">src/app.js</code>.</p><p>The <code class="literal">src/mailer/index.js</code> will be our entry point and its main responsibility is to instantiate the <code class="literal">nodemailer</code> variable and provide public methods other files can refer to.</p><div><pre class="programlisting">'''
var nodemailer = require('nodemailer')

module.exports = function (mailConfig){
  var methods = {};
  var transporter;

  // Setup transport
  if(process.env.NODE_ENV == 'test'){
    var stubTransport = require('nodemailer-stub-transport');
    transporter = nodemailer.createTransport(stubTransport());
  } else if( mailConfig.service === 'Mailgun'){
    transporter = nodemailer.createTransport({
        service: 'Mailgun',
        auth: {
            user: mailConfig.user,
            pass: mailConfig.password
        }
    });
  } else {
    throw new Error("email service missing");
  }

  // define a simple function to deliver mails
  methods.send = function(recipients, subject, body, cb) {
    // small trick to ensure dev &amp; tests emails go to myself
    if(process.env.NODE_ENV !== 'production') {
      recipients = ["my.own.email@provider.com"];
    }
    transporter.sendMail({
      to: recipients,
      from: mailConfig.from,
      subject: subject,
      generateTextFromHTML: true,
      html: body
    }, function(err, info) {
      // console.info("nodemailer::send",err,info)
      if(typeof cb === 'function'){
        cb(err,info);
      }
    })
  }

  return methods;
}</pre></div><p>When it <a id="id226" class="indexterm"/>comes to the test environment, we definitely don't want to be sending real e-mails, that's why we register the stub transport. For other environments, we decided to go with <code class="literal">Mailgun</code> but we could also go with any service that integrates via SMTP (remember to use Gmail since there is a risk of failing to send e-mails, as they have a bunch of heuristics to prevent spam).</p><p>When it comes to testing, this section is one of the harder ones to test, we will implement something very basic in <code class="literal">test/send_mail.js</code>
</p><div><pre class="programlisting">var dbCleanup = require('./utils/db');
var app = require('../src/app');
var mailer = app.get('mailer');

describe('Meeting Setup', function() {

  it('just send one.', function(done) {
    this.timeout(10*1000);
    mailer.send(
      "my.own.email@provider.com",
      "Test "+(new Date()).toLocaleString(),
      "Body "+Math.random()+"&lt;br&gt;"+Math.random()
    , done);
  })
})</pre></div><p>Add to <code class="literal">config.js</code>, and have the correspondent environment variables defined because it's not a good idea to keep our secrets in the code.</p><div><pre class="programlisting">  var ENV = process.env;
  configs.email = {
    service: "Mailgun",
    from: ENV.MAIL_FROM,
    user: ENV.MAIL_USER,
    password: ENV.MAIL_PASSWORD
  };</pre></div><p>When I <a id="id227" class="indexterm"/>disable the <code class="literal">test</code> environment, I can actually see the email in my inbox. Win! To make the service look better, let's experiment with some templates, which is <a id="id228" class="indexterm"/>what email-templates (<a class="ulink" href="https://github.com/niftylettuce/node-email-templates">https://github.com/niftylettuce/node-email-templates</a>) is all about.</p><p>It makes it easy to implement dynamic e-mails including packing the CSS inline; these are required to be inline by many e-mail clients.</p><p>On <code class="literal">src/mailer/followUp.js</code>
</p><div><pre class="programlisting">'''javascript
module.exports = function(sendMail, models) {
  //..

  function sendForUser (user1, user2, id, date, cb) {
    emailTemplates(templatesDir, function(err,template) {
      if(err) return cb(err);

      template('followup', {
        meetingId: id.toString(),
        user1    : user1,
        user2    : user2,
        date     : date,
        outcomes : Meeting.outcomes()
      }, function(err,html) {
        if(err) return cb(err);
        sendMail(
          user1.email,
          "How was your meeting with "+user2.name+"?",
          html,
          cb
        )
      });
    });
  }

  // call done() when both emails are sent
  return function followUp(meeting, done) {
    async.parallel([
      function(cb) {
        sendForUser(meeting.user1, meeting.user2, meeting._id, meeting.at, cb);
      },
      function(cb) {
        sendForUser(meeting.user2, meeting.user1, meeting._id, meeting.at, cb);
      },
    ], done)
  }
}</pre></div><p>Essentially, we<a id="id229" class="indexterm"/> send two identical emails so we get feedback from both users. There is a bit of complexity there that we will manage by using <code class="literal">async.parallel()</code> method. It allows us to start two asynchronous operations and callbacks (done) when both are completed. See <a class="ulink" href="https://github.com/caolan/async#parallel">https://github.com/caolan/async#parallel</a>.</p><p>The actual print of the email is created by two files, <code class="literal">src/mailer/templates/followup/followUp.html.swig</code> and <code class="literal">style.css</code>, which are combined and set via our transport solution, respectively:</p><div><pre class="programlisting">'''html
&lt;h4 class="title"&gt;
  Hey {{user1.name}},
&lt;/h4&gt;
&lt;div class="text"&gt;
  We hope you just had an awesome meeting with {{user2.name}}!
  You guys were supposed to meetup at {{date|date('jS \o\f F H:i')}}, how did it go?
&lt;/div&gt;
&lt;ul&gt;
  {% for id, text in outcomes %}
  &lt;li&gt;&lt;a href="http://127.0.0.1:8000/followup/{{meetingId}}/{{user2._id.toString()}}/{{id}}"&gt;{{text}}&lt;/a&gt;&lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
&lt;div class="text"&gt;
  Hope to see you back soon!
&lt;/div&gt;
'''

'''css
body{
  background: #EEE;
  padding: 20px;
}
.text{
  margin-top: 30px;
}
ul{
  list-style-type: circle;
}
ul li{1
  line-height: 150%;
}
a{
  text-decoration: none;
}</pre></div><p>We can <a id="id230" class="indexterm"/>choose from many template solutions. swig (<a class="ulink" href="http://paularmstrong.github.io/swig/docs/">http://paularmstrong.github.io/swig/docs/</a>) comes with convenient helpers, makes it easy <a id="id231" class="indexterm"/>to work with lists, and has the familiar HTML visual. A bit of insight is given as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">{{string}}</code> is the general interpolating method</li><li class="listitem" style="list-style-type: disc"><code class="literal">|</code> is for helpers (aka filters); you can use built-ins or define your own</li><li class="listitem" style="list-style-type: disc"><code class="literal">for k,v in obj</code> is a tag and works looping over key-value pairs</li></ul></div><div><img src="img/0818_05_04.jpg" alt="E-mail follow up"/></div><p>When it came to the logic for the follow-up links, we made it really easy for the user to provide feedback; usually, the less friction, the better for outstanding UX. All they have to do is click on the link and their review is instantly recorded! In terms of Express.js, this means we<a id="id232" class="indexterm"/> have to set up a route that links all the piece of data together; in this case, in <code class="literal">src/routes/index.js</code>:</p><div><pre class="programlisting">  app.get("/followup/:meetingId/:reviewedUserId/:feedback", meeting.followUp);</pre></div><p>To have an endpoint that actually changes the data defined as a <code class="literal">GET</code> is an exception to HTTP &amp; REST conventions, but the reason is that email clients will send the request as a <code class="literal">GET</code>; not a lot we can do about it.</p><p>The method is defined at <code class="literal">src/routes/meeting.js</code> as follows:</p><div><pre class="programlisting">  methods.followUp = function(req,res,next) {
    var meetingId = req.param("meetingId");
    var reviewedUserId = req.param("reviewedUserId");
    var feedback = req.param("feedback");
    // validate feedback
    if(!(feedback in Model.Meeting.outcomes())) return res.status(400).send("Feedback not recognized");
    Model.Meeting.didMeetingHappened(meetingId, function(err, itDid) {
      if(err){
        if(err.message == "no meeting found by this id"){
          return res.status(404).send(err.message);
        } else {
          return next(err);
        }
      }
      if(!itDid){
        return res.status(412).send("The meeting didn't happen yet, come back later!");
      }
      Model.Meeting.rate(meetingId, reviewedUserId, feedback, function(err, userName, text) {
        if(err) return next(err);
        res.send("You just rated your meeting with "+userName+" as "+text+". Thanks!");
      });
    });

  }</pre></div><p>This method does quite a bit of checking and that's because there is a considerable amount of input that needs validation along with providing the appropriate response. First, we check whether the <code class="literal">feedback</code> provided is valid, since we are only taking quantitative data. <code class="literal">didMeetingHappened</code> returns <code class="literal">two</code> important pieces of info about the meeting; the ID may be completely wrong, or it might not have happened yet. Both scenarios should deliver different results. Finally, if everything looks good, we attempt to rate the<a id="id233" class="indexterm"/> meeting, which should work just fine and return some data to respond with and finish the request with an implied <code class="literal">200</code> status.</p><p>The implementation of the preceding methods are available at <code class="literal">src/models/meeting.js</code>
</p><div><pre class="programlisting">'''
  // cb(err, itDid)
  methods.didMeetingHappened = function(meetingId, cb) {
    if(!db.ObjectId.isValid(meetingId)) return cb(new Error("bad ObjectId"));
    Meeting.findOne({
      user1: {$exists: true},
      user2: {$exists: true},
      _id: new db.ObjectId(meetingId)
    }, function(err, meeting) {
      if(err) return cb(err);
      if(!meeting) return cb(new Error('no meeting found by this id'));
      if(meeting.at &gt; new Date()) return cb(null,false);
      cb(null,true);
    })
  }

  // cb(err, userName, text)
  methods.rate = function(meetingId, reviewedUserId, feedback, cb) {
    Meeting.findOne({
      _id: new db.ObjectId(meetingId),
    }, function(err,meeting) {
      if(err) return cb(err)
        var update = {};
        // check the ids present at the meeting object, if user 1 is being reviewed then the review belongs to user 2
        var targetUser = (meeting.user1._id.toString() == reviewedUserId) ? '1' : '2';
        update["user"+targetUser+"review"] = feedback;
        Meeting.findAndModify({
          new: true,
          query: {
            _id: new db.ObjectId(meetingId),
          },
          update: {
            $set: update
          }
        }, function(err, meeting) {
          if(err) return cb(err);
          var userName = (meeting["user"+targetUser].name);
          var text = methods.outcomes()[feedback];
          cb(null, userName, text);
        })
    })
  }
'''</pre></div><p>The<a id="id234" class="indexterm"/> implementation method should be pretty readable. The <code class="literal">didMeetingHappened()</code> method looks for a maximum of one document with <code class="literal">_id</code>, where <code class="literal">user1</code> and <code class="literal">user2</code> are filled. When this document is found, we look at the <code class="literal">at</code> field and compare with the current time to check whether it already happened.</p><p>The rate is a bit longer but just as simple. We find the <code class="literal">meeting</code> object and figure out which user is being rated. Such feedback belonging to the opposite user is stored in an atomic operation, setting either field <code class="literal">user1reviewed</code> or <code class="literal">user2reviewed</code> with the key for the feedback.</p><p>We have a thorough test suite implemented for this case, where we mind both success &amp; failure cases. It can be used to check the emails by simply calling the test with <code class="literal">NODE_ENV=development mocha test/meeting_followup.js</code>, which then overrides the test environment with development and delivers emails to our provider, so we can see how it looks and fine-tune it.</p><p>Our test for this whole scenario is a bit long but we need to test several things!</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clean up DB</li><li class="listitem" style="list-style-type: disc">Setting up the meeting</li><li class="listitem" style="list-style-type: disc">Register user 1</li><li class="listitem" style="list-style-type: disc">Register user 2 at the same position</li><li class="listitem" style="list-style-type: disc">STest that non-existent meetings can't be reviewed</li><li class="listitem" style="list-style-type: disc">Status 412 on meeting reviews that still didn't happen</li><li class="listitem" style="list-style-type: disc">Travel time two days ahead</li><li class="listitem" style="list-style-type: disc">Send an email</li><li class="listitem" style="list-style-type: disc">Taking up a review that makes sense</li><li class="listitem" style="list-style-type: disc">User 1 should be able to review the meeting</li><li class="listitem" style="list-style-type: disc">User 2 should be able to review the meeting as well</li></ul></div><p>Seems like we can now send emails and receive reviews, which is great, but how do we send the emails in a time-sensitive manner? A couple of minutes after the meeting has started, the <a id="id235" class="indexterm"/>emails should be sent to both parties.</p><p>(Source:git checkout 7f5303ef10bfa3d3bfb33469dea957f63e0ab1dc)</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Periodical tasks with node-cron</h1></div></div></div><p>Maybe <a id="id236" class="indexterm"/>you are familiar with cron (<a class="ulink" href="http://en.wikipedia.org/wiki/Cron">http://en.wikipedia.org/wiki/Cron</a>). It's a Unix-based task scheduling system that makes <a id="id237" class="indexterm"/>running tasks easy. One problem <a id="id238" class="indexterm"/>with it is that it's linked to your platform, and it's not trivial to turn it on and off from code.</p><p>Meet node-cron (<a class="ulink" href="https://github.com/ncb000gt/node-cron">https://github.com/ncb000gt/node-cron</a>). It's basically the same task <a id="id239" class="indexterm"/>scheduler but it runs directly from your Node application, so as long as it is up, your jobs should run.</p><p>Our strategy is simple: Periodically select all meetings that need mailing, call our mailer with each of these meetings, and then mark it as emailed.</p><p>Following this app's convention, let's separate concerns into their own folders, starting with <code class="literal">src/tasks/index.js</code>, as shown in the following code:</p><div><pre class="programlisting">var CronJob = require('cron').CronJob;

module.exports = function(models, mailer) {
  var tasks = {};

  tasks.followupMail = require('./followupMail')(models,mailer);

  tasks.init = function() {
    (new CronJob('00 */15 * * * *', tasks.followupMail)).start();
  };

  return tasks;
}</pre></div><p>It needs to take <code class="literal">models</code> and <code class="literal">mailer</code> as parameters, which can be used inside tasks. <code class="literal">followupMail</code> is the single user defined for now because it's all we need. The exported method <code class="literal">init</code> is what will kick start the cron job, the timer presenting respectively: <code class="literal">00</code> defined as the seconds, meaning it will run at second <code class="literal">00</code>, for every <code class="literal">*/15</code> minutes, any hour, any day of the month, any month, any day of the week. For the actual task, see <code class="literal">src/mailer/followUp.js</code>
</p><div><pre class="programlisting">'''
module.exports = function(Model, mailer) {
  return function() {
    Model.Meeting.needMailing(function(err,meetings) {
      if(err) return console.warn("needMailing", err);
      if(!meetings || meetings.length &lt; 1) return;
      meetings.forEach(function(meeting) {
        mailer.followUp(meeting, function(err) {
          if(err) return console.warn("needMailing followup failed "+meeting._id.toString(), err);
          Model.Meeting.markAsMailed(meeting._id);
        });
      });
      Model.Meeting.markAsMailed(meetings);
    });
  };
};
'''</pre></div><p>It returns<a id="id240" class="indexterm"/> a function, which when executed, looks up all<a id="id241" class="indexterm"/> meeting documents that still need to be mailed and for each one, use <code class="literal">mailer.followUp</code> as we defined before and upon completion, mark each email as sent. Notice that fails here have nowhere to communicate and that's because it's an automated task. It's important for web servers to have meaningful log reporting, so in this case, the warning messages should be reported.</p><p>Of course, this would require us to add two methods to <code class="literal">src/models/meeting.js</code>, which you should be able to easily make sense of by now:</p><div><pre class="programlisting">  // all meetings that are due and not mailed yet
  methods.needMailing = function(cb) {
    Meeting.find({
      at: {$lt: new Date},
      mailed: {$exists: false}
    },cb);
  };

  // mark a meeting as mailed
  methods.markAsMailed = function(id,cb) {
    Meeting.findAndModify({
      query: {
        _id: id
      },
      update:{
        $set: {mailed: new Date()}
      }
    },cb);
  };</pre></div><p>For our final test, we'll be creating four users implying 2 meetings, travel 2 days in the future and try sending the emails through the task, it should work and mark both emails as sent.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clear DB</li><li class="listitem" style="list-style-type: disc">Register<a id="id242" class="indexterm"/> users 1, 2, 3, and 4 at the same <a id="id243" class="indexterm"/>location</li><li class="listitem" style="list-style-type: disc">Travel time after the meeting is done</li><li class="listitem" style="list-style-type: disc">Task should send an email</li><li class="listitem" style="list-style-type: disc">Verify that the emails were sent</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we created an API that can set up meetings between users taking into account their matching history and the pair of longitude and latitude, while providing them the chance to give feedback on how it went-essential information which can be used in many ways to further improve the algorithm!</p><p>We hope you learned about many interesting and practical concepts, such as making geo queries, testing time-sensitive code, sending e-mails with style, and tasks that run periodically.</p><p>Besides the technical bits, hope you had fun and perhaps were able to spark some insight on the framework behind match-making apps!</p><p>Next on, we'll see how <code class="literal">Koa.js</code> works by leveraging the power of generators, bringing the readability of synchronous code on top of the async features of Node.js.</p></div></body></html>