- en: Getting Started with ECMAScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ECMAScript 2017** (**ES8**) was released at the end of June 2017 by **Technical
    Committee number 39** (**TC39**). It''s part of ECMA, the institution that standardizes
    the JavaScript language under the ECMAScript specification. Currently, the standard
    aims to publish a new ES specification version once a year. ES6 was published
    in 2015 and ES7 was published in 2016\. A lot changed when ES6 was released (arrow
    functions, classes, generators, module loaders, async programming, and so on) and
    even more interesting stuff keeps happening, as time goes by.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be starting off with the fundamentals of JavaScript,
    starting off with ES6 basics and heading towards ES8 stuff. Furthermore, we'll
    be taking a look at some interesting aspects of traditional JS such as closures,
    and some new ones such as arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: As an autodidact, I highly recommend not only reading this book, but also trying
    to apply whatever you're learning here in some small but interesting projects.
    This will help you to retain a lot of stuff effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating block-scoped variables using the `let` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating constant variables using the `const` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spread operator and the rest parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hoisting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from iterables and objects using a destructuring assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures and how to deal with them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of semicolons in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking `let` versus `var` versus `const`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new syntaxes for creating object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The let keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `let` keyword is used to declare a block-scoped variable (more on this later),
    optionally initializing it to a value. Programmers who come from a different programming
    language background, but are new to JavaScript, often end up writing error-prone
    JavaScript programs, believing that the JavaScript variables created using the
    traditional `var` keyword are block-scoped. Almost every popular programming language
    has the same set of rules when it comes to the variable scopes, but JavaScript
    acts a bit differently due to a lack of block-scoped variables. Due to the fact
    that JavaScript variables are not block-scoped, there are chances of memory leaks
    and JavaScript programs are harder to read and debug.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function-scoped variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript variables that are declared using the `var` keyword are called **function-scoped variables**.
    Function-scoped variables are accessible globally to the script, that is, throughout
    the script, if declared outside a function. Similarly, if the function scoped
    variables are declared inside a function, then they become accessible throughout
    the function, but not outside the function. Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, variables initialized inside a function are restricted inside that
    function only. However, variables declared in a block scope (that is, inside curly
    braces `{ }` that is not a function (that is, `if` statements)) can be used outside
    those blocks as well.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring block-scoped variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables that are declared using the `let` keyword are called **block-scoped
    variables**. Block-scoped variables behave the same way as function-scoped variables
    when declared outside a function, that is, they are accessible globally. But when
    block-scoped variables are declared inside a block, they are accessible inside
    the block that they are defined in (and also any sub-blocks) but not outside the
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Study the code carefully. This is the same as the preceding example, but with  `var` replaced
    by `let` everywhere. Observe how C alerts `undefined` now (`let` makes it inaccessible
    outside `if {}`).
  prefs: []
  type: TYPE_NORMAL
- en: Re-declaring variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `var` keyword that is already declared
    using  the `var` keyword (in the same scope) then it''s **overwritten**. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result is as expected. But the variables created using the `let` keyword
    don't behave in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare a variable using the `let` keyword that is already declared
    using the `let` keyword in the same scope, then it throws a **SyntaxError exception**.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you declare a variable with a name that''s already accessible in a function
    (or inner function), or is a sub-block using `var` or the `let` keyword respectively,
    then it''s a different variable. Here, is an example this shows the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Closures and let keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on making it to here! Let's face it, JavaScript has got some
    weird (and some bad) sides. **Closures** are on the weird side of JavaScript.
    Let's see what the term closure actually means.
  prefs: []
  type: TYPE_NORMAL
- en: When you declare a local variable, that variable has a restricted scope, that
    is, it cannot be used outside that particular scope within which it is declared
    (depends on `var` and `let`). As discussed earlier, local variables are not available
    outside the block (as in the case of `let`) or function scope (as in the case
    of `var` or `let`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example to understand what the preceding
    paragraph states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When a function is fully executed, that is, has returned its value, its local
    variables are no longer required and cleaned from memory. However, a closure is
    a *persistent local variable scope*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the returned function makes use of the local variable to the `counter()`
    function. What happens when you call counter?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Look carefully, we are not executing `counter()` again and again. We stored
    the returned value of the `counter` in the `myCounter` variable and then kept
    calling the returned function.
  prefs: []
  type: TYPE_NORMAL
- en: The returned `myCounter` function will count up by one each time it's called.
    When you call `myCounter()`, you are executing a function that contains a reference
    to a variable (`count`), which exists in a parent function and technically should've
    been destroyed after its complete execution. However, JavaScript preserves used
    variables inside a returned function in a kind of different stack. This property
    is called a closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures have been around for a long time, so what''s different? Using it with
    the `let` keyword.Have a look at this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? Because till the time `setTimeout` fires, the loop has already ended and
    the `i` variable was already `5`. But this does not happen with `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The fact that `let` binds variables to the block (thus, in this case, the `for`
    loop) means that it binds the variable to every iteration. So, when the loop is
    finished, you have five `setTimeout` functions (with `i` = `0`, `1`, `2`, `3`,
    `4`) waiting to fire one after another.
  prefs: []
  type: TYPE_NORMAL
- en: '`let` achieves this by creating a closure of its own in every iteration. This
    happens behind the scenes with `let`, so you do not need to code that aspect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this code without `let`, we''ll need to create an **Immediately Invoked
    Function Expression** (**IIFE**), which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is more or less what `let` does behind the scenes. So what happened here?
  prefs: []
  type: TYPE_NORMAL
- en: We created an anonymous function that is immediately invoked at every loop cycle
    with the correct `i` value associated with it. Now, this function has the correct
    `i` value passed as `arg` in the function argument. Finally, we use `console.log` after
    a second to get the correct output as `0 1 2 3 4`.
  prefs: []
  type: TYPE_NORMAL
- en: So you can observe, a simple `let` statement can simplify the code a lot in
    such cases.
  prefs: []
  type: TYPE_NORMAL
- en: The const keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `const` keyword, you can create variables that cannot change their
    values (hence they're  called **constants**) once they're initialized, that is,
    you cannot reinitialize them with another value later in your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to reinitialize a `const` variable, a read-only exception is thrown.
    Furthermore, you cannot just declare and not initialize a `const` variable. It'll
    also throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you might want your JavaScript to crash if someone tries to change
    a particular constant, say `pi`, in your calculator. Here''s how to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The scope of const variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `const` variables are block-scoped variables, that is, they follow the
    same scoping rules as the variables that are declared using the `let` keyword.
    The following example demonstrates the scope of the constant variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that constant variables behave in the same way as block-scoped
    variables when it comes to scoping rules.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing objects using constant variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we assign an object to a variable, the reference of the object is what
    the variable holds and not the object itself. So, when assigning an object to
    a constant variable, the reference of the object becomes constant to that variable
    and not to the object itself. Therefore, the object is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `a` variable stores the address (that is, reference) of
    the object. So the address of the object is the value of the `a` variable, and
    it cannot be changed. But the object is mutable. So when we tried to assign another
    object to the `a` variable, we got an exception as we were trying to change the
    value of the `a` variable.
  prefs: []
  type: TYPE_NORMAL
- en: When to use var/let/const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between `const` and `let` is that `const` makes sure that rebinding
    will not happen. That means you cannot reinitialize a `const` variable, but a
    `let` variable can be reinitialized (but not redeclared).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a particular scope, a `const` variable always refers to the same object.
    Because `let` can change its value at runtime, there is no guarantee that a `let`
    variable always refers to the same value. Therefore, as a rule of thumb, you can
    (not strictly) follow these:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `const` by default if you know that you'll not change the value (max performance
    boost)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only use `let` if you think reassignment is required/can happen somewhere in
    your code (modern syntax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using `var` (`let` does not create global variables when defined in a
    block scope; this makes it less confusing for you if you come from a C, C++, Java,
    or any similar background)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let versus var versus const performance benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, running a benchmark test on my own laptop (MacBook Air, Google Chrome Version
    61.0.3163.100 (official build) (64-bit)) produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad02c03-9357-48ec-b5fd-86ad946f0e58.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, performance-wise on Chrome, let on the global scope is slowest, while
    `let` inside a block is fastest, and so is const.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the aforementioned benchmark tests are performed by running a
    loop 1000 x 30 times and the operation performed in the loop was appending a value
    to an array. That is, the array starts from [1], then becomes [1,2] in the next
    iteration, then [1,2,3], and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do the results mean? One inference we can draw from these results is that
    `let` is slower in a `for` loop when used inside the declaration: `for(let i=0;i<1000;i++)`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is because `let` is redeclared every time for each iteration (relate this
    to the closure section you read earlier), whereas `for(var i=0;i<1000;i++)` declares
    the `i` variable for the whole block of code. This makes `let` a bit slower when
    used in a loop definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when `let` is not used inside the loop body but declared outside the
    loop, it performs quite well. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will give you the best results. However, if you're not performing tens
    of hundreds of iterations, it should not matter.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Immutability, defined in a single line, means that once that value is assigned,
    then it can never be *changed*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`string1.slice` does not change the value of `string1`. In fact, no string
    methods change the string they operate on, they all return new strings. The reason
    is that strings are immutable—they cannot change.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are not the only immutable entity in JavaScript. Numbers, too, are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Object.freeze versus const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that even if you create objects with `const` in front of them,
    a programmer is still able to modify its properties. This is because `const` creates
    an immutable binding, that is, you cannot assign a new value to the binding.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in order to truly make objects constants (that is, unmodifiable properties),
    we have to use something called `Object.freeze`. However, `Object.freeze` is,
    again, a shallow method, that is, you need to recursively apply it on nested objects
    to protect them. Let's clear this up with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We froze `ob1` so all of its first-level hierarchical properties got frozen
    (that is, cannot be modified). A frozen object will not throw an error when attempted
    to be modified, but rather it'll simply ignore the modification done.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we go deeper, you'll observe that `ob1.bar.value` got modified because
    it's 2 levels down and is not frozen. So, you'll need to recursively freeze nested
    objects in order to make them *constant*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we look at the last two lines, you'll realize when to use `Object.freeze`
    and when to use `const`. The `const` declaration is not declared again, whereas `ob1`
    is redeclared because it's not constant (it's `var`). `Object.freeze` does not
    freeze the original variable binding and hence is not a replacement for `const`.
    Similarly, `const` does not freeze properties and is not a replacement for `Object.freeze`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, once an object is frozen, you can no longer add properties to it. However,
    you can add properties to nested objects (if present).
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, there is no defined way to assign default values to function
    parameters that are not passed. So programmers usually check for parameters with
    the `undefined` value (as it is the default value for missing parameters) and
    assign the default values to them. The following example demonstrates how to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done in an easier way by providing a default value to function
    arguments. Here is the code that demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, since we've passed first two arguments in the function
    calling statement, the default values (that is `x = 1` and `y = 2`) will be overwritten
    with our passed values (that is `x = 6` and `y = 7`). The third argument is not
    passed, hence its default value (that is `z =3`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, passing `undefined` is considered as missing an argument. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A similar thing happens here. If you want to omit the first argument, just pass
    `undefined` in that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defaults can also be expressions. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're making use of the argument variables themselves inside a default
    argument value! That is, whatever you pass as the first two arguments, if the
    third argument is not passed it'll take the value of the sum of the first two
    arguments. Since we passed `6` and `7` to the first and second argument, `z` becomes
    *6 + 7 = 13*.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **spread operator** is represented by the `...` token. A spread operator splits
    an iterable object into its individual values.
  prefs: []
  type: TYPE_NORMAL
- en: An **iterable** is an object that contains a group of values and implements
    the ES6 iterable protocol to let us iterate through its values. An **array** is
    an example of a built-in iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: A spread operator can be placed wherever multiple function arguments or multiple
    elements (for array literals) are expected in code.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator is commonly used to spread the values of an iterable object
    into the arguments of a function. Let's take the example of an array and see how
    to split it into the arguments of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide the values of an array as a function argument, you can use the `apply()`
    method of `Function`. This method is available to every function. The following
    example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `apply` method takes an array, extracts the values, passes them as
    individual arguments to the function, and then calls it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using the modern way, that is, with the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'During runtime, before the JavaScript interpreter calls the `myFunction` function,
    it replaces `...data` with the `1,4` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is replaced with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After this, the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses of the spread operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The spread operator is not just limited to spreading an iterable object into
    function arguments, but it can be used wherever multiple elements (for example,
    array literals) are expected in code. So it has many uses. Let's see some other
    use cases of the spread operator for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Making array values a part of another array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The spread operator can also be used to make array values a part of another
    array. The following example code that demonstrates how to make the values of
    an existing array a part of another array while creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This previous code is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Pushing the values of an array into another array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we may need to push the values of an existing array into the end
    of another existing array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how programmers used to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'But from ES6 onward we have a much cleaner way to do it, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here the `push` method takes a series of variables and adds them to the end
    of the array on which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be replaced with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Spreading multiple arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple arrays can be spread on a single-line expression. For example, take
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The rest parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **rest parameter** is also represented by the `...` token. The last parameter
    of a function with `...` is called a rest parameter. The rest parameter is an
    array type and contains the rest of the parameters of a function when the number
    of arguments exceeds the number of named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The rest parameter is used to capture a variable number of function arguments
    from within a function.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` object can also be used to access all arguments passed. The
    `argument` object is not strictly an array, but it provides some interfaces that
    are similar to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code shows how to use the `arguments` object to retrieve
    the extra arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done in a much easier and cleaner way, by using the rest parameter.
    The following example demonstrates to use the rest parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `arguments` object is not an array object. Therefore, to do array operations
    on the `arguments` object, you need to convert it to an array. The rest parameter
    is easy to work with.
  prefs: []
  type: TYPE_NORMAL
- en: What is the `...` token called?
  prefs: []
  type: TYPE_NORMAL
- en: The `...` token is called the spread operator or rest parameter, depending on
    where and how it's used.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hoisting** is JavaScript''s default behavior: moving declarations to the
    top. That means the following code will work in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re coming from a C/C++ background, this might seem a little weird at
    first because those languages do not allow you to call a function before at least
    declaring its prototype. But JavaScript, behind the scenes, hoists the function,
    that is, all function declarations are moved to the top of the context. So, essentially,
    the preceding code is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Hoisting only moves the declarations to the top, not the initializations. Therefore,
    although the preceding code works, the following code won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because, as we said earlier, only declarations are hoisted. Therefore,
    what a browser sees is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Guess the output of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Ready to find out? Your possible answers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: 'The output will be :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? Because this is how your browser see this code (after applying the hoisting
    thing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once the function is hoisted, it doesn't matter what you pass in that function.
    It is always overwritten with the function defined inside the `foo` function.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the output is just `Mehul` written three times.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring assignments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **destructuring assignment** is an expression that allows you to assign the
    values or properties of an iterable or object to variables, using a syntax that
    looks similar to the array or object construction literals respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A destructuring assignment makes it easy to extract data from iterables or objects
    by providing a shorter syntax. A destructuring assignment is already present in
    programming languages such as Perl and Python, and works the same way everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of destructuring assignment expressions: **array** and **object**.
    Let's see each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The array destructuring assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **array destructuring assignment** is used to extract the values of an iterable
    object and assign them to the variables. It's called an array destructuring assignment
    because the expression is similar to an array construction literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmers used to do it this way to assign the values of an array to the
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are extracting the values of an array and assigning them to the `a`,
    `b`, `c` variables respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an array destructuring assignment we can do this in a one-line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `[a, b, c]` is an array destructuring expression.
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side of the array destructuring statement, we need to place
    the variables to which we want to assign the array values, using a syntax similar
    to an array literal. On the right-hand side, we need to place an array (actually
    any iterable object) whose values we want to extract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example code can be made even shorter in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create the variables on the same statement, and instead of providing
    the array variable, we provide the array with a construction literal.
  prefs: []
  type: TYPE_NORMAL
- en: If there are fewer variables than items in the array, then only the first items
    are considered.
  prefs: []
  type: TYPE_NORMAL
- en: If you place a non-iterable object on the right-hand side of the array destructuring
    assignment syntax, then a TypeError exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also ignore some of the values of the iterable. Here is example code
    that shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using the rest operator in an array destructuring assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can prefix the last variable of an array destructuring expression using the
    `...` token. In this case, the variable is always converted into an array object
    that holds the rest of the values of the iterable object, if the number of other
    variables is less than the values in the iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example code, you can see that the `b` variable is converted
    into an array, and it holds all the other values of the right-hand side array.
  prefs: []
  type: TYPE_NORMAL
- en: Here the `...` token is called the rest operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ignore the values while using the rest operator. The following
    example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we ignored the `2`, `3` values.
  prefs: []
  type: TYPE_NORMAL
- en: Default values for variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While destructuring, you can also provide default values for the variables
    if an array index is `undefined`. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Nested array destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also extract the values from a multidimensional array and assign them
    to variables. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using a destructuring assignment as a parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also use an array destructuring expression as the function parameter
    for extracting the values of an iterable object, passed as an argument into the
    function parameters. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier in this chapter, we saw that if we pass `undefined` as an argument
    to a function call, then JavaScript checks for the default parameter value. So,
    we can provide a default array here too, which will be used if the argument is
    `undefined`. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed `undefined` as an argument and therefore the default array,
    which is `[1, 2, 3]`, was used to extract the values.
  prefs: []
  type: TYPE_NORMAL
- en: Object destructuring assignments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **object destructuring assignment** is used to the extract property values
    of an object and assign them to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a traditional (and still useful) way of assigning property values to
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do this in a one-line statement, using the object destructuring assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: On the left-hand side of the object destructuring statement, we need to place
    the variables to which we want to assign the object property values using a syntax
    similar to that of an object literal. On the right-hand side, we need to place
    an object whose property values we want to extract. The statement is finally closed
    using the `( )` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the variable names must be the same as the object property names. If you
    want to assign different variable names, then you can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code can be made even shorter this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here we are creating the variables and object on the same line. We don't need
    to close the statement using the `( )` token, as we are creating the variables
    on the same statement.
  prefs: []
  type: TYPE_NORMAL
- en: Default values for variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also provide default values for the variables if the object property
    is `undefined` while destructuring. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Some property names are constructed dynamically using expressions. In this
    case, to extract the property values, we can use the `[ ]` token to provide the
    property name with an expression. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring nested objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also extract property values from nested objects, that is, objects within
    objects. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Using the object destructuring assignment as a parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the array destructuring assignment, we can also use the object destructuring
    assignment as a function parameter. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed an empty object as a default parameter value, which will be
    used as a default object if `undefined` is passed as a function argument.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **arrow function** is, at first glance, just a fancy way to create regular
    JavaScript functions (however, there are some surprises). Using arrow functions,
    you can create concise one-liner functions that actually work!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, circumference is a variable, referencing to the anonymous arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is similar to the following code in ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If your function contains just a single statement (and you want to return the
    result of that statement), then you don''t have to use the `{}` brackets to wrap
    the code. This makes it a one-liner. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'When `{}` brackets are not used then the value of the statement in the body
    is automatically returned. The preceding code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if there''s only a single argument, you can omit the brackets to make
    the code even shorter. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Since there is only one argument, `side`, we can omit the circular brackets
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: The value of "this" in an arrow function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In arrow functions, the value of the `this` keyword is the same as the value
    of the `this` keyword of the enclosing scope (the global or function scope, whichever
    the arrow function is defined inside). That means, instead of referring to the
    context object (that is, the object inside which the function is a property),
    which is the value of `this` in traditional functions, `this` instead refers to
    global or function scope, in which the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example to understand the difference between the traditional
    functions and the arrow functions, this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: What do you think will happen when you call the `car.addFuel()` method? If you
    guessed `The fuel is now undefined` will appear forever, then you are right! But
    why?!
  prefs: []
  type: TYPE_NORMAL
- en: When you define the `addFuel` method inside the **`function() {}` **(above site
    B), your `this` keyword refers to the current object. However, once you go another
    level deeper into functions (site C), your `this` now points to that particular
    function and its prototypes. Hence, you cannot access the parent object's property
    with the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: How do we fix this? Take a look at these arrow functions!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, inside site C, the `this` keyword refers to the parent object. Hence, we're
    able to access the `fuel` property using the `this` keyword only.
  prefs: []
  type: TYPE_NORMAL
- en: Other differences between arrow and traditional functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrow functions cannot be used as **object constructors**, that is, the `new`
    operator cannot be applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from **syntax**, the **value**, and the `new` operator, everything else
    is the same between arrow and traditional functions, that is, they are both instances
    of the `Function` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once, JavaScript required developers to write complete function names, property
    names, even when the function name / property name values matched each other (example:
    `var a = { obj: obj }`). However, ES6/ES7/ES8 and beyond relaxes this and allows
    the minification and readability of code in a number of ways. Let us see how.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 brought in a shorter syntax for assigning object properties to the values
    of variables that have the same name as the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, you would''ve done this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, you can do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Defining methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 onwards provides a new syntax for defining the methods on an object. The
    following example demonstrates the new syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This concise function allows the use of `super` in them, whereas traditional
    object methods don't allow the use of `super`. We will learn more about this later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Computed property names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property names that are evaluated during runtime are called computed property
    names. An expression is usually resolved to find the property name dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computed properties were once defined in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after creating the object, we attach the properties to the object. But
    in ES6, we can add the properties with the computed name while creating the object.
    The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Trailing commas and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Trailing commas** are those commas found at the end of an array list, object,
    or function arguments. They can be useful when adding new elements, parameters,
    or properties to JavaScript code. It just makes it a little more convenient for
    developers that they can choose to write an array as `[1,2,3]` or `[1,2,3,]` (notice
    the comma in the second example)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has allowed trailing commas in arrays and objects for a long time.
    Finally, in ECMAScript 2017 (ES8), the standard now allows you to add trailing
    commas to function parameters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means all the following examples are valid JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is clearly valid JavaScript code and `arr` is created
    as `[1, 2, 3, undefined, undefined]`
  prefs: []
  type: TYPE_NORMAL
- en: Let us now explore how objects behave with trailing commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: It can be seen that the code does not throw any error even after putting a comma
    after the last property name. Let's move on to functions now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: All the aforementioned function definitions are valid from the ES2017 (ES8)
    spec.
  prefs: []
  type: TYPE_NORMAL
- en: The semicolon dilemma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must've seen a lot of JavaScript code with semicolons, and a lot without
    semicolons as well. And surprisingly, both work fine! While languages such as
    C, C++, Java, and so on are strict about the use of semicolons, and on the other
    hand languages such as Python are strict about not using semicolons (only indentations),
    there is no such fixed rule for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: So let's see when is semicolon required in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic semicolon insertion in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ECMAScript Language specification ([http://www.ecma-international.org/ecma-262/5.1/#sec-7.9](http://www.ecma-international.org/ecma-262/5.1/#sec-7.9))
    states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Certain ECMAScript statements must be terminated with semicolons. Such semicolons
    may always appear explicitly in the source text"'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the spec also says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"For convenience, however, such semicolons may be omitted from the source text
    in certain situations."'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the specification states that JavaScript is able to handle automatic
    semicolon insertion by its own judgment. However, it is extremely error-prone
    in some cases and not intuitive at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript automatically inserts semicolon to make code look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: So far so good.
  prefs: []
  type: TYPE_NORMAL
- en: Where to insert semicolons in JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, you will find yourself skipping semicolons somewhere and you'll see
    that your code still works! This is strictly opposite to what you find in languages
    such as C or C++. Let us take a look at a scenario where you can get trapped by
    not using semicolons properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a good look and guess what possible alerts might be, with their orders
    as well. When you''re ready with your answer, look at the following, the code
    to which JavaScript compiles (not really, just the code after inserting automatic
    semicolons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: So instead of invoking that self-invoking function, what you do apparently is,
    pass that whole function as an argument to the first one. Therefore, try to use
    semicolons to avoid ambiguity in your code. You can always use JavaScript compressors
    later on, which will take care of necessary places to leave semicolons intact.
    The takeaway from here is **use semicolons.**
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about variable scopes, read-only variables, splitting
    arrays into individual values, passing indefinite parameters to a function, extracting
    data from objects and arrays, arrow functions, and new syntaxes for creating object
    properties, hoisting, IIFE, semicolon usage, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about built-in objects and symbols, and we
    will discover tons of fundamental tools JavaScript natively provides us with out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
