- en: Getting Started with ECMAScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript入门
- en: '**ECMAScript 2017** (**ES8**) was released at the end of June 2017 by **Technical
    Committee number 39** (**TC39**). It''s part of ECMA, the institution that standardizes
    the JavaScript language under the ECMAScript specification. Currently, the standard
    aims to publish a new ES specification version once a year. ES6 was published
    in 2015 and ES7 was published in 2016\. A lot changed when ES6 was released (arrow
    functions, classes, generators, module loaders, async programming, and so on) and
    even more interesting stuff keeps happening, as time goes by.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**ECMAScript 2017**（**ES8**）于2017年6月底由**技术委员会第39号**（**TC39**）发布。它是ECMA的一部分，该机构根据ECMAScript规范标准化JavaScript语言。目前，该标准旨在每年发布一个新的ES规范版本。ES6于2015年发布，ES7于2016年发布。ES6发布时发生了许多变化（箭头函数、类、生成器、模块加载器、异步编程等），随着时间的推移，还有更多有趣的事情发生。'
- en: In this chapter, we'll be starting off with the fundamentals of JavaScript,
    starting off with ES6 basics and heading towards ES8 stuff. Furthermore, we'll
    be taking a look at some interesting aspects of traditional JS such as closures,
    and some new ones such as arrow functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从JavaScript的基础知识开始，从ES6基础知识开始，逐步过渡到ES8的内容。此外，我们还将探讨传统JS的一些有趣方面，如闭包，以及一些新特性，如箭头函数。
- en: As an autodidact, I highly recommend not only reading this book, but also trying
    to apply whatever you're learning here in some small but interesting projects.
    This will help you to retain a lot of stuff effortlessly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名自学者，我强烈推荐不仅阅读这本书，还尝试将在这里学到的知识应用到一些小而有趣的项目中。这将帮助你轻松地保留大量知识。
- en: 'In this chapter, we''ll be covering:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating block-scoped variables using the `let` keyword
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`let`关键字创建块作用域变量
- en: Creating constant variables using the `const` keyword
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`const`关键字创建常量变量
- en: The spread operator and the rest parameter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展运算符和剩余参数
- en: Hoisting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量提升
- en: Extracting data from iterables and objects using a destructuring assignment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解构赋值从可迭代对象和对象中提取数据
- en: Arrow functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Closures and how to deal with them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包及其处理方法
- en: Use of semicolons in JavaScript
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中使用分号
- en: Benchmarking `let` versus `var` versus `const`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较`let`、`var`和`const`的性能基准
- en: The new syntaxes for creating object properties
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象属性的新的语法
- en: The let keyword
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`let`关键字'
- en: The `let` keyword is used to declare a block-scoped variable (more on this later),
    optionally initializing it to a value. Programmers who come from a different programming
    language background, but are new to JavaScript, often end up writing error-prone
    JavaScript programs, believing that the JavaScript variables created using the
    traditional `var` keyword are block-scoped. Almost every popular programming language
    has the same set of rules when it comes to the variable scopes, but JavaScript
    acts a bit differently due to a lack of block-scoped variables. Due to the fact
    that JavaScript variables are not block-scoped, there are chances of memory leaks
    and JavaScript programs are harder to read and debug.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`关键字可以声明一个块作用域变量（关于这一点稍后会有更多介绍），并可选择性地将其初始化为某个值。来自不同编程语言背景但新接触JavaScript的程序员，常常会编写出容易出错的JavaScript程序，认为使用传统`var`关键字创建的JavaScript变量是块作用域的。几乎每种流行的编程语言在变量作用域方面都有相同的规则，但JavaScript由于缺乏块作用域变量而表现得略有不同。由于JavaScript变量不是块作用域的，存在内存泄漏的风险，并且JavaScript程序更难以阅读和调试。
- en: Declaring function-scoped variables
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数作用域变量
- en: 'The JavaScript variables that are declared using the `var` keyword are called **function-scoped variables**.
    Function-scoped variables are accessible globally to the script, that is, throughout
    the script, if declared outside a function. Similarly, if the function scoped
    variables are declared inside a function, then they become accessible throughout
    the function, but not outside the function. Let''s take a look at an example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`关键字声明的JavaScript变量被称为**函数作用域变量**。函数作用域变量对整个脚本全局可用，即如果在外部函数中声明，则在整个脚本中可用。同样，如果函数作用域变量在函数内部声明，则它们在整个函数中可用，但不在函数外部。让我们看一个例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Clearly, variables initialized inside a function are restricted inside that
    function only. However, variables declared in a block scope (that is, inside curly
    braces `{ }` that is not a function (that is, `if` statements)) can be used outside
    those blocks as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在函数内部初始化的变量仅限于该函数内部。然而，在块作用域（即不在函数内的花括号`{}`，例如`if`语句）中声明的变量也可以在那些块外部使用。
- en: Declaring block-scoped variables
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明块级作用域变量
- en: 'Variables that are declared using the `let` keyword are called **block-scoped
    variables**. Block-scoped variables behave the same way as function-scoped variables
    when declared outside a function, that is, they are accessible globally. But when
    block-scoped variables are declared inside a block, they are accessible inside
    the block that they are defined in (and also any sub-blocks) but not outside the
    block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`关键字声明的变量被称为**块级作用域变量**。当在函数外部声明时，块级作用域变量的行为与函数级作用域变量相同，即它们是全局可访问的。但是，当块级作用域变量在块内部声明时，它们只在其定义的块内部（以及任何子块）可访问，而块外部则不可访问：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Study the code carefully. This is the same as the preceding example, but with  `var` replaced
    by `let` everywhere. Observe how C alerts `undefined` now (`let` makes it inaccessible
    outside `if {}`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究代码。这与前面的示例相同，但是将`var`替换为`let`。观察现在C如何提示`undefined`（`let`使其在`if {}`之外不可访问）。
- en: Re-declaring variables
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新声明变量
- en: 'When you declare a variable using the `var` keyword that is already declared
    using  the `var` keyword (in the same scope) then it''s **overwritten**. Consider
    this example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`var`关键字声明一个变量，而这个变量已经在同一作用域内使用`var`关键字声明过时，那么它会被**覆盖**。考虑以下示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result is as expected. But the variables created using the `let` keyword
    don't behave in the same way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如预期。但是，使用`let`关键字创建的变量并不以相同的方式表现。
- en: 'When you declare a variable using the `let` keyword that is already declared
    using the `let` keyword in the same scope, then it throws a **SyntaxError exception**.
    Consider this example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`let`关键字声明一个变量，而这个变量已经在同一作用域内使用`let`关键字声明过时，那么它会抛出一个**SyntaxError异常**。考虑以下示例：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you declare a variable with a name that''s already accessible in a function
    (or inner function), or is a sub-block using `var` or the `let` keyword respectively,
    then it''s a different variable. Here, is an example this shows the behavior:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一个在函数（或内部函数）中已经可访问的名称声明一个变量，或者是一个使用`var`或`let`关键字分别创建的子块时，那么它就是一个不同的变量。这里有一个示例，展示了这种行为：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Closures and let keyword
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包和`let`关键字
- en: Congratulations on making it to here! Let's face it, JavaScript has got some
    weird (and some bad) sides. **Closures** are on the weird side of JavaScript.
    Let's see what the term closure actually means.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你到达这里！让我们面对现实，JavaScript有一些奇怪（以及一些不好）的一面。**闭包**是JavaScript奇怪的一面之一。让我们看看“闭包”这个术语实际上是什么意思。
- en: When you declare a local variable, that variable has a restricted scope, that
    is, it cannot be used outside that particular scope within which it is declared
    (depends on `var` and `let`). As discussed earlier, local variables are not available
    outside the block (as in the case of `let`) or function scope (as in the case
    of `var` or `let`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个局部变量时，该变量有一个受限的作用域，也就是说，它不能在声明它的特定作用域之外使用（这取决于`var`和`let`）。如前所述，局部变量在块（如`let`的情况）或函数作用域（如`var`或`let`的情况）之外是不可用的。
- en: 'Let''s take a look at the following example to understand what the preceding
    paragraph states:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解前一段落所阐述的内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When a function is fully executed, that is, has returned its value, its local
    variables are no longer required and cleaned from memory. However, a closure is
    a *persistent local variable scope*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数完全执行完毕，即返回了它的值，它的局部变量就不再需要，并且从内存中清理掉。然而，闭包是一个**持久的局部变量作用域**。
- en: 'Consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Clearly, the returned function makes use of the local variable to the `counter()`
    function. What happens when you call counter?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，返回的函数使用了`counter()`函数的局部变量。当你调用`counter()`时会发生什么？
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Look carefully, we are not executing `counter()` again and again. We stored
    the returned value of the `counter` in the `myCounter` variable and then kept
    calling the returned function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们并没有反复执行`counter()`。我们将`counter`返回的值存储在`myCounter`变量中，然后不断调用返回的函数。
- en: The returned `myCounter` function will count up by one each time it's called.
    When you call `myCounter()`, you are executing a function that contains a reference
    to a variable (`count`), which exists in a parent function and technically should've
    been destroyed after its complete execution. However, JavaScript preserves used
    variables inside a returned function in a kind of different stack. This property
    is called a closure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`myCounter`函数每次被调用时都会增加一。当你调用`myCounter()`时，你正在执行一个包含对变量（`count`）的引用的函数，该变量存在于父函数中，并且在技术上应该在完全执行后销毁。然而，JavaScript以一种不同的堆保留了返回函数中的使用过的变量。这种属性被称为闭包。
- en: 'Closures have been around for a long time, so what''s different? Using it with
    the `let` keyword.Have a look at this one:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包已经存在很长时间了，那么有什么不同？使用`let`关键字。看看这个例子：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output will be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Why? Because till the time `setTimeout` fires, the loop has already ended and
    the `i` variable was already `5`. But this does not happen with `let`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？因为在`setTimeout`触发之前，循环已经结束，`i`变量已经是`5`了。但这种情况不会发生在`let`上：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fact that `let` binds variables to the block (thus, in this case, the `for`
    loop) means that it binds the variable to every iteration. So, when the loop is
    finished, you have five `setTimeout` functions (with `i` = `0`, `1`, `2`, `3`,
    `4`) waiting to fire one after another.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`将变量绑定到块（因此，在这种情况下，是`for`循环）的事实意味着它将变量绑定到每个迭代。所以，当循环结束时，你将拥有五个`setTimeout`函数（`i`分别为`0`、`1`、`2`、`3`、`4`），它们将依次触发。'
- en: '`let` achieves this by creating a closure of its own in every iteration. This
    happens behind the scenes with `let`, so you do not need to code that aspect.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`通过在每次迭代中创建自己的闭包来实现这一点。在`let`中，这发生在幕后，所以你不需要编写这方面的代码。'
- en: 'To fix this code without `let`, we''ll need to create an **Immediately Invoked
    Function Expression** (**IIFE**), which looks something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不使用`let`的情况下修复此代码，我们需要创建一个立即执行的函数表达式（**IIFE**），其外观如下：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is more or less what `let` does behind the scenes. So what happened here?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`let`在幕后所做的大致事情。那么这里发生了什么？
- en: We created an anonymous function that is immediately invoked at every loop cycle
    with the correct `i` value associated with it. Now, this function has the correct
    `i` value passed as `arg` in the function argument. Finally, we use `console.log` after
    a second to get the correct output as `0 1 2 3 4`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个匿名函数，它在每个循环周期立即执行，并带有与其关联的正确`i`值。现在，这个函数将正确的`i`值作为`arg`传递给函数参数。最后，我们使用`console.log`在两秒后得到正确的输出`0
    1 2 3 4`。
- en: So you can observe, a simple `let` statement can simplify the code a lot in
    such cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以观察到，一个简单的`let`语句可以在这种情况下大大简化代码。
- en: The const keyword
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`const`关键字'
- en: Using the `const` keyword, you can create variables that cannot change their
    values (hence they're  called **constants**) once they're initialized, that is,
    you cannot reinitialize them with another value later in your code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`const`关键字，你可以创建一旦初始化后就不能改变其值的变量（因此它们被称为**常量**），即你无法在代码的后续部分用另一个值重新初始化它们。
- en: If you try to reinitialize a `const` variable, a read-only exception is thrown.
    Furthermore, you cannot just declare and not initialize a `const` variable. It'll
    also throw an exception.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试重新初始化一个`const`变量，将抛出一个只读异常。此外，你不能只声明而不初始化一个`const`变量。它也会抛出异常。
- en: 'For instance, you might want your JavaScript to crash if someone tries to change
    a particular constant, say `pi`, in your calculator. Here''s how to achieve that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能希望当有人试图更改计算器中的特定常数，比如`pi`时，你的JavaScript崩溃。下面是如何实现这一点：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The scope of const variables
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量变量的作用域
- en: 'The `const` variables are block-scoped variables, that is, they follow the
    same scoping rules as the variables that are declared using the `let` keyword.
    The following example demonstrates the scope of the constant variables:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量是块级作用域变量，即它们遵循与使用`let`关键字声明的变量相同的范围规则。以下示例演示了常量变量的作用域：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see that constant variables behave in the same way as block-scoped
    variables when it comes to scoping rules.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到，常量变量在作用域规则方面与块级作用域变量表现相同。
- en: Referencing objects using constant variables
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量变量引用对象
- en: When we assign an object to a variable, the reference of the object is what
    the variable holds and not the object itself. So, when assigning an object to
    a constant variable, the reference of the object becomes constant to that variable
    and not to the object itself. Therefore, the object is mutable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个对象赋值给变量时，变量持有的是对象的引用，而不是对象本身。因此，当将对象赋值给常量变量时，对象的引用变为对该变量的常量引用，而不是对对象的引用。因此，对象是可变的。
- en: 'Consider this example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the `a` variable stores the address (that is, reference) of
    the object. So the address of the object is the value of the `a` variable, and
    it cannot be changed. But the object is mutable. So when we tried to assign another
    object to the `a` variable, we got an exception as we were trying to change the
    value of the `a` variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a` 变量存储的是对象的地址（即引用）。因此，对象的地址是 `a` 变量的值，并且不能被更改。但是对象是可变的。因此，当我们尝试将另一个对象赋值给
    `a` 变量时，我们得到了异常，因为我们试图更改 `a` 变量的值。
- en: When to use var/let/const
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 var/let/const
- en: The difference between `const` and `let` is that `const` makes sure that rebinding
    will not happen. That means you cannot reinitialize a `const` variable, but a
    `let` variable can be reinitialized (but not redeclared).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 和 `let` 之间的区别在于 `const` 确保不会发生重新绑定。这意味着您不能重新初始化一个 `const` 变量，但 `let`
    变量可以被重新初始化（但不能重新声明）。'
- en: 'Within a particular scope, a `const` variable always refers to the same object.
    Because `let` can change its value at runtime, there is no guarantee that a `let`
    variable always refers to the same value. Therefore, as a rule of thumb, you can
    (not strictly) follow these:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定的作用域内，`const` 变量始终引用同一个对象。因为 `let` 可以在运行时更改其值，所以不能保证 `let` 变量始终引用同一个值。因此，作为一般规则，您可以（不是严格地）遵循以下规则：
- en: Use `const` by default if you know that you'll not change the value (max performance
    boost)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您知道您不会更改值（最大性能提升），请默认使用 `const`。
- en: Only use `let` if you think reassignment is required/can happen somewhere in
    your code (modern syntax)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当您认为在您的代码中需要/可能发生重新赋值时才使用 `let`（现代语法）
- en: Avoid using `var` (`let` does not create global variables when defined in a
    block scope; this makes it less confusing for you if you come from a C, C++, Java,
    or any similar background)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用 `var`（`let` 在块作用域中定义时不会创建全局变量；如果您来自 C、C++、Java 或任何类似背景，这会使您更不容易混淆）
- en: Let versus var versus const performance benchmarks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let 与 var 与 const 的性能基准
- en: 'Currently, running a benchmark test on my own laptop (MacBook Air, Google Chrome Version
    61.0.3163.100 (official build) (64-bit)) produces the following result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我的笔记本电脑上（MacBook Air，Google Chrome 版本 61.0.3163.100（官方构建）（64位））运行基准测试产生以下结果：
- en: '![](img/fad02c03-9357-48ec-b5fd-86ad946f0e58.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fad02c03-9357-48ec-b5fd-86ad946f0e58.png)'
- en: Clearly, performance-wise on Chrome, let on the global scope is slowest, while
    `let` inside a block is fastest, and so is const.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，在 Chrome 上，全局作用域中的 `let` 性能最慢，而块内的 `let` 和 `const` 性能最快。
- en: First of all, the aforementioned benchmark tests are performed by running a
    loop 1000 x 30 times and the operation performed in the loop was appending a value
    to an array. That is, the array starts from [1], then becomes [1,2] in the next
    iteration, then [1,2,3], and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，上述基准测试是通过运行循环 1000 x 30 次来执行的，循环中执行的操作是将一个值追加到数组中。也就是说，数组从 [1] 开始，然后在下一次迭代中变为
    [1,2]，然后是 [1,2,3]，依此类推。
- en: 'What do the results mean? One inference we can draw from these results is that
    `let` is slower in a `for` loop when used inside the declaration: `for(let i=0;i<1000;i++)`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果意味着什么？我们可以从这些结果中得出的一个推论是，当在声明中使用 `let` 时，`let` 在 `for` 循环中较慢：`for(let i=0;i<1000;i++)`。
- en: This is because `let` is redeclared every time for each iteration (relate this
    to the closure section you read earlier), whereas `for(var i=0;i<1000;i++)` declares
    the `i` variable for the whole block of code. This makes `let` a bit slower when
    used in a loop definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `let` 在每次迭代时都会重新声明（将此与您之前阅读的闭包部分联系起来），而 `for(var i=0;i<1000;i++)` 则为整个代码块声明了
    `i` 变量。这使得 `let` 在循环定义中使用时稍微慢一些。
- en: 'However, when `let` is not used inside the loop body but declared outside the
    loop, it performs quite well. For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当 `let` 不在循环体内部使用而是在循环外部声明时，它的性能相当不错。例如：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will give you the best results. However, if you're not performing tens
    of hundreds of iterations, it should not matter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您带来最佳结果。然而，如果您不是进行成百上千次的迭代，这应该不会有什么影响。
- en: Immutability in JavaScript
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 中的不可变性
- en: 'Immutability, defined in a single line, means that once that value is assigned,
    then it can never be *changed*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性，用一行定义，意味着一旦该值被赋值，那么它就永远不能*改变*：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`string1.slice` does not change the value of `string1`. In fact, no string
    methods change the string they operate on, they all return new strings. The reason
    is that strings are immutable—they cannot change.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`string1.slice` 不会改变 `string1` 的值。事实上，没有字符串方法会改变它们操作的字符串，它们都返回新的字符串。原因是字符串是不可变的——它们不能改变。'
- en: Strings are not the only immutable entity in JavaScript. Numbers, too, are immutable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不是 JavaScript 中唯一的不可变实体。数字也是不可变的。
- en: Object.freeze versus const
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object.freeze 与 const 的比较
- en: Earlier, we saw that even if you create objects with `const` in front of them,
    a programmer is still able to modify its properties. This is because `const` creates
    an immutable binding, that is, you cannot assign a new value to the binding.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到即使你在对象前使用 `const`，程序员仍然能够修改其属性。这是因为 `const` 创建了一个不可变的绑定，也就是说，你不能将新值赋给这个绑定。
- en: Therefore, in order to truly make objects constants (that is, unmodifiable properties),
    we have to use something called `Object.freeze`. However, `Object.freeze` is,
    again, a shallow method, that is, you need to recursively apply it on nested objects
    to protect them. Let's clear this up with a simple example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了真正使对象成为常量（即，不可修改的属性），我们必须使用一个叫做 `Object.freeze` 的东西。然而，`Object.freeze`
    又是一个浅层方法，也就是说，你需要递归地应用于嵌套对象以保护它们。让我们用一个简单的例子来澄清这一点。
- en: 'Consider this example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We froze `ob1` so all of its first-level hierarchical properties got frozen
    (that is, cannot be modified). A frozen object will not throw an error when attempted
    to be modified, but rather it'll simply ignore the modification done.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们冻结了 `ob1`，因此它的所有第一级层次属性都被冻结了（即，不能被修改）。一个冻结的对象在尝试修改时不会抛出错误，而是简单地忽略所做的修改。
- en: However, as we go deeper, you'll observe that `ob1.bar.value` got modified because
    it's 2 levels down and is not frozen. So, you'll need to recursively freeze nested
    objects in order to make them *constant*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们深入研究时，你会注意到 `ob1.bar.value` 被修改了，因为它有 2 个层级并且没有被冻结。所以，你需要递归地冻结嵌套对象以使它们*常量*。
- en: Finally, if we look at the last two lines, you'll realize when to use `Object.freeze`
    and when to use `const`. The `const` declaration is not declared again, whereas `ob1`
    is redeclared because it's not constant (it's `var`). `Object.freeze` does not
    freeze the original variable binding and hence is not a replacement for `const`.
    Similarly, `const` does not freeze properties and is not a replacement for `Object.freeze`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们看看最后两行，你会意识到何时使用 `Object.freeze` 和何时使用 `const`。`const` 声明不再声明，而 `ob1`
    被重新声明，因为它不是常量（它是 `var`）。`Object.freeze` 不会冻结原始变量绑定，因此不是 `const` 的替代品。同样，`const`
    不会冻结属性，也不是 `Object.freeze` 的替代品。
- en: Also, once an object is frozen, you can no longer add properties to it. However,
    you can add properties to nested objects (if present).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦一个对象被冻结，你不能再向它添加属性。然而，你可以向嵌套对象添加属性（如果存在）。
- en: Default parameter values
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'In JavaScript, there is no defined way to assign default values to function
    parameters that are not passed. So programmers usually check for parameters with
    the `undefined` value (as it is the default value for missing parameters) and
    assign the default values to them. The following example demonstrates how to do
    this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，没有定义的方法可以为未传递的函数参数分配默认值。因此，程序员通常会检查具有 `undefined` 值的参数（因为它是不传递参数的默认值）并将默认值分配给它们。以下示例演示了如何做到这一点：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This can be done in an easier way by providing a default value to function
    arguments. Here is the code that demonstrates how to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过为函数参数提供默认值来更容易地完成。以下代码演示了如何做到这一点：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code block, since we've passed first two arguments in the function
    calling statement, the default values (that is `x = 1` and `y = 2`) will be overwritten
    with our passed values (that is `x = 6` and `y = 7`). The third argument is not
    passed, hence its default value (that is `z =3`) is used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，由于我们在函数调用语句中传递了前两个参数，默认值（即 `x = 1` 和 `y = 2`）将被我们传递的值（即 `x = 6` 和 `y
    = 7`）覆盖。第三个参数没有传递，因此使用其默认值（即 `z = 3`）。
- en: 'Also, passing `undefined` is considered as missing an argument. The following
    example demonstrates this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，传递 `undefined` 被认为是缺少一个参数。以下示例演示了这一点：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A similar thing happens here. If you want to omit the first argument, just pass
    `undefined` in that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生类似的事情。如果你想省略第一个参数，只需在那个位置传递`undefined`即可。
- en: 'Defaults can also be expressions. The following example demonstrates this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值也可以是表达式。以下示例演示了这一点：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we're making use of the argument variables themselves inside a default
    argument value! That is, whatever you pass as the first two arguments, if the
    third argument is not passed it'll take the value of the sum of the first two
    arguments. Since we passed `6` and `7` to the first and second argument, `z` becomes
    *6 + 7 = 13*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在使用默认参数值内部的参数变量！也就是说，无论你传递什么作为前两个参数，如果第三个参数没有传递，它将取前两个参数之和的值。由于我们向第一个和第二个参数传递了`6`和`7`，所以`z`变为*6
    + 7 = 13*。
- en: The spread operator
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: A **spread operator** is represented by the `...` token. A spread operator splits
    an iterable object into its individual values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展运算符**由`...`标记表示。扩展运算符将可迭代对象拆分为其单个值。'
- en: An **iterable** is an object that contains a group of values and implements
    the ES6 iterable protocol to let us iterate through its values. An **array** is
    an example of a built-in iterable object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代**是一个包含一组值并实现了ES6可迭代协议的对象，使我们能够遍历其值。**数组**是内置可迭代对象的一个例子。'
- en: A spread operator can be placed wherever multiple function arguments or multiple
    elements (for array literals) are expected in code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符可以放置在代码中需要多个函数参数或多个元素（对于数组字面量）的任何地方。
- en: The spread operator is commonly used to spread the values of an iterable object
    into the arguments of a function. Let's take the example of an array and see how
    to split it into the arguments of a function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符通常用于将可迭代对象的值扩展到函数的参数中。让我们以数组为例，看看如何将其拆分为函数的参数。
- en: 'To provide the values of an array as a function argument, you can use the `apply()`
    method of `Function`. This method is available to every function. The following
    example demonstrates:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数组的值作为函数参数提供，你可以使用`Function`的`apply()`方法。此方法对每个函数都可用。以下示例演示了：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the `apply` method takes an array, extracts the values, passes them as
    individual arguments to the function, and then calls it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`apply`方法接受一个数组，提取其值，将它们作为单独的参数传递给函数，然后调用它。
- en: 'Here''s an example using the modern way, that is, with the spread operator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用现代方法（即使用扩展运算符）的示例：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'During runtime, before the JavaScript interpreter calls the `myFunction` function,
    it replaces `...data` with the `1,4` expression:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，在JavaScript解释器调用`myFunction`函数之前，它将`...data`替换为`1,4`表达式：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The previous code is replaced with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码被替换为：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After this, the function is called.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，函数被调用。
- en: Other uses of the spread operator
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展运算符的其他用法
- en: The spread operator is not just limited to spreading an iterable object into
    function arguments, but it can be used wherever multiple elements (for example,
    array literals) are expected in code. So it has many uses. Let's see some other
    use cases of the spread operator for arrays.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符不仅限于将可迭代对象扩展到函数参数，它还可以用于代码中需要多个元素（例如，数组字面量）的任何地方。因此，它有很多用途。让我们看看扩展运算符在数组中的其他一些用例。
- en: Making array values a part of another array
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组值作为另一个数组的一部分
- en: 'The spread operator can also be used to make array values a part of another
    array. The following example code that demonstrates how to make the values of
    an existing array a part of another array while creating it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展运算符也可以用来将数组值作为另一个数组的一部分。以下示例代码演示了如何在创建数组的同时将现有数组的值作为另一个数组的一部分：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Consider the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This previous code is equivalent to:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Pushing the values of an array into another array
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组值推送到另一个数组
- en: Sometimes, we may need to push the values of an existing array into the end
    of another existing array.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要将现有数组的值推送到另一个现有数组的末尾。
- en: 'This is how programmers used to do it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序员过去通常的做法：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But from ES6 onward we have a much cleaner way to do it, which is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但从ES6开始，我们有一个更简洁的方式来完成它，如下所示：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here the `push` method takes a series of variables and adds them to the end
    of the array on which it is called.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`push`方法接受一系列变量，并将它们添加到调用它的数组的末尾。
- en: 'See the following line:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下行：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will be replaced with the following line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被替换为以下行：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Spreading multiple arrays
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展多个数组
- en: 'Multiple arrays can be spread on a single-line expression. For example, take
    the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单行表达式中展开多个数组。例如，以下代码：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The rest parameter
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: The **rest parameter** is also represented by the `...` token. The last parameter
    of a function with `...` is called a rest parameter. The rest parameter is an
    array type and contains the rest of the parameters of a function when the number
    of arguments exceeds the number of named parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**剩余参数**也用`...`标记表示。带有`...`的函数的最后一个参数被称为剩余参数。剩余参数是一个数组类型，当参数的数量超过命名参数的数量时，它包含函数的其余参数。'
- en: The rest parameter is used to capture a variable number of function arguments
    from within a function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余参数用于从函数内部捕获一个可变数量的函数参数。
- en: The `arguments` object can also be used to access all arguments passed. The
    `argument` object is not strictly an array, but it provides some interfaces that
    are similar to an array.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`对象也可以用来访问所有传递的参数。`arguments`对象不是严格意义上的数组，但它提供了一些类似于数组的接口。'
- en: 'The following example code shows how to use the `arguments` object to retrieve
    the extra arguments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码展示了如何使用`arguments`对象来检索额外的参数：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This can be done in a much easier and cleaner way, by using the rest parameter.
    The following example demonstrates to use the rest parameter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用剩余参数以更简单、更干净的方式完成。以下示例演示了如何使用剩余参数：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `arguments` object is not an array object. Therefore, to do array operations
    on the `arguments` object, you need to convert it to an array. The rest parameter
    is easy to work with.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`对象不是一个数组对象。因此，要对`arguments`对象执行数组操作，你需要将其转换为数组。剩余参数易于处理。'
- en: What is the `...` token called?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`...`标记叫什么？
- en: The `...` token is called the spread operator or rest parameter, depending on
    where and how it's used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`标记被称为扩展操作符或剩余参数，具体取决于其使用方式和位置。'
- en: Hoisting
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升机制
- en: '**Hoisting** is JavaScript''s default behavior: moving declarations to the
    top. That means the following code will work in JavaScript:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升机制**是JavaScript的默认行为：将声明移动到顶部。这意味着以下代码在JavaScript中将会工作：'
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you''re coming from a C/C++ background, this might seem a little weird at
    first because those languages do not allow you to call a function before at least
    declaring its prototype. But JavaScript, behind the scenes, hoists the function,
    that is, all function declarations are moved to the top of the context. So, essentially,
    the preceding code is the same as the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自C/C++的背景，一开始这可能会觉得有点奇怪，因为那些语言不允许你在至少声明其原型之前调用函数。但JavaScript在幕后会提升函数，也就是说，所有的函数声明都会移动到上下文的顶部。所以，本质上，前面的代码等同于以下代码：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Hoisting only moves the declarations to the top, not the initializations. Therefore,
    although the preceding code works, the following code won''t work:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 提升机制只移动声明，而不是初始化。因此，尽管前面的代码可以工作，但以下代码将不会工作：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is because, as we said earlier, only declarations are hoisted. Therefore,
    what a browser sees is something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，正如我们之前所说的，只有声明会被提升。因此，浏览器看到的是类似以下的内容：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Guess the output of the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜以下代码的输出：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Ready to find out? Your possible answers are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好揭晓答案了吗？你的可能答案是：
- en: '[PRE44]'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be :'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会是：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Why? Because this is how your browser see this code (after applying the hoisting
    thing):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为这就是浏览器看到这段代码的方式（在应用提升机制之后）：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once the function is hoisted, it doesn't matter what you pass in that function.
    It is always overwritten with the function defined inside the `foo` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数被提升，你传递给该函数的内容就不再重要。它总是会被`foo`函数内部定义的函数覆盖。
- en: Therefore, the output is just `Mehul` written three times.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出结果仅仅是`Mehul`这个词重复三次。
- en: Destructuring assignments
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构赋值
- en: A **destructuring assignment** is an expression that allows you to assign the
    values or properties of an iterable or object to variables, using a syntax that
    looks similar to the array or object construction literals respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构赋值**是一种表达式，它允许你使用类似于数组或对象构造字面量的语法，将可迭代或对象中的值或属性赋给变量。'
- en: A destructuring assignment makes it easy to extract data from iterables or objects
    by providing a shorter syntax. A destructuring assignment is already present in
    programming languages such as Perl and Python, and works the same way everywhere.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值使得从可迭代或对象中提取数据变得简单，因为它提供了一个更短的语法。解构赋值已经存在于像Perl和Python这样的编程语言中，并且它们的工作方式是一样的。
- en: There are two kinds of destructuring assignment expressions: **array** and **object**.
    Let's see each of them in detail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种解构赋值表达式：**数组**和**对象**。让我们详细看看每一种。
- en: The array destructuring assignment
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组解构赋值
- en: An **array destructuring assignment** is used to extract the values of an iterable
    object and assign them to the variables. It's called an array destructuring assignment
    because the expression is similar to an array construction literal.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组解构赋值**用于从可迭代对象中提取值并将它们赋给变量。它被称为数组解构赋值，因为表达式类似于数组构造字面量。'
- en: 'Programmers used to do it this way to assign the values of an array to the
    variables:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员过去是这样做的，将数组的值赋给变量：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we are extracting the values of an array and assigning them to the `a`,
    `b`, `c` variables respectively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在提取数组的值并将它们分别赋值给`a`、`b`、`c`变量。
- en: 'With an array destructuring assignment we can do this in a one-line statement:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组解构赋值，我们可以用一行语句完成：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, `[a, b, c]` is an array destructuring expression.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`[a, b, c]`是一个数组解构表达式。
- en: On the left-hand side of the array destructuring statement, we need to place
    the variables to which we want to assign the array values, using a syntax similar
    to an array literal. On the right-hand side, we need to place an array (actually
    any iterable object) whose values we want to extract.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组解构语句的左侧，我们需要放置我们想要将数组值赋给变量的变量，使用与数组字面量类似的语法。在右侧，我们需要放置一个数组（实际上可以是任何可迭代对象），我们想要从中提取值。
- en: 'The previous example code can be made even shorter in this way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，前面的示例代码可以变得更短：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we create the variables on the same statement, and instead of providing
    the array variable, we provide the array with a construction literal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在同一语句中创建变量，而不是提供数组变量，我们提供带有构造字面量的数组。
- en: If there are fewer variables than items in the array, then only the first items
    are considered.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量比数组中的项目少，则只考虑前几个项目。
- en: If you place a non-iterable object on the right-hand side of the array destructuring
    assignment syntax, then a TypeError exception is thrown.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将非可迭代对象放在数组解构赋值语法的右侧，则会抛出TypeError异常。
- en: Ignoring values
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略值
- en: 'We can also ignore some of the values of the iterable. Here is example code
    that shows how to do this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以忽略可迭代对象的一些值。以下示例代码展示了如何做到这一点：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the rest operator in an array destructuring assignment
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组解构赋值中使用剩余操作符
- en: We can prefix the last variable of an array destructuring expression using the
    `...` token. In this case, the variable is always converted into an array object
    that holds the rest of the values of the iterable object, if the number of other
    variables is less than the values in the iterable object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`...`符号来给数组解构表达式的最后一个变量加前缀。在这种情况下，如果其他变量的数量少于可迭代对象的值，该变量总是被转换为一个数组对象，该对象包含可迭代对象的所有剩余值。
- en: 'Consider this example to understand it:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子来理解它：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the previous example code, you can see that the `b` variable is converted
    into an array, and it holds all the other values of the right-hand side array.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，你可以看到`b`变量被转换为一个数组，并且它包含了右侧数组中的所有其他值。
- en: Here the `...` token is called the rest operator.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`...`符号被称为剩余操作符。
- en: 'We can also ignore the values while using the rest operator. The following
    example demonstrates this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在使用剩余操作符时忽略值。以下示例演示了这一点：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we ignored the `2`, `3` values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们忽略了`2`、`3`值。
- en: Default values for variables
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的默认值
- en: 'While destructuring, you can also provide default values for the variables
    if an array index is `undefined`. The following example demonstrates this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构时，如果数组索引是`undefined`，你也可以为变量提供默认值。以下示例演示了这一点：
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Nested array destructuring
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套数组解构
- en: 'We can also extract the values from a multidimensional array and assign them
    to variables. The following example demonstrates this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从多维数组中提取值并将它们赋给变量。以下示例演示了这一点：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using a destructuring assignment as a parameter
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用解构赋值作为参数
- en: 'We can also use an array destructuring expression as the function parameter
    for extracting the values of an iterable object, passed as an argument into the
    function parameters. The following example demonstrates this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用数组解构表达式作为函数参数，以提取作为函数参数传递的可迭代对象的值。以下示例演示了这一点：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Earlier in this chapter, we saw that if we pass `undefined` as an argument
    to a function call, then JavaScript checks for the default parameter value. So,
    we can provide a default array here too, which will be used if the argument is
    `undefined`. The following example demonstrates this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们了解到如果我们将 `undefined` 作为参数传递给函数调用，那么JavaScript会检查默认参数值。因此，我们也可以在这里提供一个默认数组，如果参数是
    `undefined`，它将被使用。以下示例演示了这一点：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we passed `undefined` as an argument and therefore the default array,
    which is `[1, 2, 3]`, was used to extract the values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了 `undefined` 作为参数，因此使用了默认数组 `[1, 2, 3]` 来提取值。
- en: Object destructuring assignments
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象解构赋值
- en: An **object destructuring assignment** is used to the extract property values
    of an object and assign them to the variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构赋值用于提取对象的属性值并将它们分配给变量。
- en: 'This is a traditional (and still useful) way of assigning property values to
    an object:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统（并且仍然有用）的方法，用于将属性值赋给对象：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can do this in a one-line statement, using the object destructuring assignment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一行语句完成这个操作，使用对象解构赋值：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: On the left-hand side of the object destructuring statement, we need to place
    the variables to which we want to assign the object property values using a syntax
    similar to that of an object literal. On the right-hand side, we need to place
    an object whose property values we want to extract. The statement is finally closed
    using the `( )` token.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象解构语句的左侧，我们需要放置我们想要将对象属性值分配到的变量，使用类似于对象字面量的语法。在右侧，我们需要放置我们想要提取属性值的对象。最后，使用
    `( )` 符号关闭语句。
- en: 'Here the variable names must be the same as the object property names. If you
    want to assign different variable names, then you can do it this way:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量名必须与对象属性名相同。如果你想使用不同的变量名，可以这样操作：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The previous code can be made even shorter this way:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以这样进一步缩短：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here we are creating the variables and object on the same line. We don't need
    to close the statement using the `( )` token, as we are creating the variables
    on the same statement.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们在同一行创建了变量和对象。我们不需要使用 `( )` 符号关闭语句，因为我们是在同一语句中创建变量的。
- en: Default values for variables
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的默认值
- en: 'You can also provide default values for the variables if the object property
    is `undefined` while destructuring. The following example demonstrates this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在解构时对象属性是 `undefined`，你也可以为变量提供默认值。以下示例演示了这一点：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Some property names are constructed dynamically using expressions. In this
    case, to extract the property values, we can use the `[ ]` token to provide the
    property name with an expression. The following example demonstrates this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性名是使用表达式动态构建的。在这种情况下，为了提取属性值，我们可以使用 `[ ]` 符号提供一个带有表达式的属性名。以下示例演示了这一点：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Destructuring nested objects
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构嵌套对象
- en: 'We can also extract property values from nested objects, that is, objects within
    objects. The following example demonstrates this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从嵌套对象中提取属性值，即对象中的对象。以下示例演示了这一点：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Using the object destructuring assignment as a parameter
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象解构赋值作为参数
- en: 'Just like the array destructuring assignment, we can also use the object destructuring
    assignment as a function parameter. The following example demonstrates this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组解构赋值一样，我们也可以将对象解构赋值用作函数参数。以下示例演示了这一点：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we passed an empty object as a default parameter value, which will be
    used as a default object if `undefined` is passed as a function argument.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们传递了一个空对象作为默认参数值，如果将 `undefined` 作为函数参数传递，它将用作默认对象。
- en: Arrow functions
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: An **arrow function** is, at first glance, just a fancy way to create regular
    JavaScript functions (however, there are some surprises). Using arrow functions,
    you can create concise one-liner functions that actually work!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看上去，箭头函数只是创建常规JavaScript函数的一种花哨方式（然而，也有一些惊喜）。使用箭头函数，你可以创建简洁的一行代码函数，而且它们确实可以工作！
- en: 'The following example demonstrates how to create an arrow function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何创建一个箭头函数：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, circumference is a variable, referencing to the anonymous arrow function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，周长是一个变量，引用了匿名箭头函数。
- en: 'The previous code is similar to the following code in ES5:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与以下ES5代码类似：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If your function contains just a single statement (and you want to return the
    result of that statement), then you don''t have to use the `{}` brackets to wrap
    the code. This makes it a one-liner. The following example demonstrates this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数只包含一个语句（并且你想返回该语句的结果），那么你不需要使用`{}`括号来包裹代码。这使得它成为一行代码。以下示例演示了这一点：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'When `{}` brackets are not used then the value of the statement in the body
    is automatically returned. The preceding code is equivalent to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用`{}`括号时，则语句体的值将自动返回。前面的代码等同于以下代码：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Also, if there''s only a single argument, you can omit the brackets to make
    the code even shorter. Consider the following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果只有一个参数，你可以省略括号以使代码更短。考虑以下示例：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Since there is only one argument, `side`, we can omit the circular brackets
    for this.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个参数，`side`，因此我们可以省略圆括号。
- en: The value of "this" in an arrow function
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数中的"this"值
- en: In arrow functions, the value of the `this` keyword is the same as the value
    of the `this` keyword of the enclosing scope (the global or function scope, whichever
    the arrow function is defined inside). That means, instead of referring to the
    context object (that is, the object inside which the function is a property),
    which is the value of `this` in traditional functions, `this` instead refers to
    global or function scope, in which the function is called.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中，`this`关键字的值与封闭作用域（全局或函数作用域，无论箭头函数定义在何处）的`this`关键字的值相同。这意味着，与传统的函数中`this`的值（即函数作为属性所在的对象的上下文）不同，`this`实际上指的是全局或函数作用域，其中函数被调用。
- en: 'Consider this example to understand the difference between the traditional
    functions and the arrow functions, this value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例以了解传统函数和箭头函数之间的区别，这个值：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: What do you think will happen when you call the `car.addFuel()` method? If you
    guessed `The fuel is now undefined` will appear forever, then you are right! But
    why?!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为当你调用`car.addFuel()`方法时会发生什么？如果你猜到`燃料现在未定义`将永远出现，那么你是正确的！但为什么呢？！
- en: When you define the `addFuel` method inside the **`function() {}` **(above site
    B), your `this` keyword refers to the current object. However, once you go another
    level deeper into functions (site C), your `this` now points to that particular
    function and its prototypes. Hence, you cannot access the parent object's property
    with the `this` keyword.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在**`function() {}`**（上述网站B）内部定义`addFuel`方法时，你的`this`关键字指向当前对象。然而，一旦你进入函数的更深层次（网站C），你的`this`现在指向那个特定的函数及其原型。因此，你不能使用`this`关键字访问父对象的属性。
- en: How do we fix this? Take a look at these arrow functions!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？看看这些箭头函数！
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, inside site C, the `this` keyword refers to the parent object. Hence, we're
    able to access the `fuel` property using the `this` keyword only.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在网站C内部，`this`关键字指向父对象。因此，我们只能使用`this`关键字来访问`fuel`属性。
- en: Other differences between arrow and traditional functions
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数与传统函数之间的其他区别
- en: Arrow functions cannot be used as **object constructors**, that is, the `new`
    operator cannot be applied to them.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数不能用作**对象构造函数**，也就是说，不能将`new`运算符应用于它们。
- en: Apart from **syntax**, the **value**, and the `new` operator, everything else
    is the same between arrow and traditional functions, that is, they are both instances
    of the `Function` constructor.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**语法**、**值**和`new`运算符之外，箭头函数和传统函数之间没有其他区别，即它们都是`Function`构造函数的实例。
- en: Enhanced object literals
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强的对象字面量
- en: 'Once, JavaScript required developers to write complete function names, property
    names, even when the function name / property name values matched each other (example:
    `var a = { obj: obj }`). However, ES6/ES7/ES8 and beyond relaxes this and allows
    the minification and readability of code in a number of ways. Let us see how.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '曾经，JavaScript要求开发者写出完整的函数名、属性名，即使函数名/属性名值相同（例如：`var a = { obj: obj }`）。然而，ES6/ES7/ES8以及之后的版本放宽了这一限制，并以多种方式允许代码的压缩和可读性。让我们看看如何。'
- en: Defining properties
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性
- en: ES6 brought in a shorter syntax for assigning object properties to the values
    of variables that have the same name as the properties.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了为具有与属性同名的变量赋值对象属性的更短语法。
- en: 'Traditionally, you would''ve done this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，你会这样做：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'But now, you can do it this way:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，你可以这样做：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Defining methods
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义方法
- en: 'ES6 onwards provides a new syntax for defining the methods on an object. The
    following example demonstrates the new syntax:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始，提供了定义对象上方法的新语法。以下示例演示了新语法：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This concise function allows the use of `super` in them, whereas traditional
    object methods don't allow the use of `super`. We will learn more about this later
    in the book.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的函数允许在其中使用`super`，而传统的对象方法不允许使用`super`。我们将在本书的后面了解更多关于这个内容。
- en: Computed property names
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性名
- en: Property names that are evaluated during runtime are called computed property
    names. An expression is usually resolved to find the property name dynamically.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时评估的属性名称为计算属性名。表达式通常被解析以动态找到属性名。
- en: 'Computed properties were once defined in this way:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性曾经是这样定义的：
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, after creating the object, we attach the properties to the object. But
    in ES6, we can add the properties with the computed name while creating the object.
    The following example demonstrates this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建对象之后，我们将属性附加到对象上。但在ES6中，我们可以在创建对象时添加具有计算名称的属性。以下示例演示了这一点：
- en: '[PRE81]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Trailing commas and JavaScript
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾随逗号和JavaScript
- en: '**Trailing commas** are those commas found at the end of an array list, object,
    or function arguments. They can be useful when adding new elements, parameters,
    or properties to JavaScript code. It just makes it a little more convenient for
    developers that they can choose to write an array as `[1,2,3]` or `[1,2,3,]` (notice
    the comma in the second example)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**尾随逗号**是指在数组列表、对象或函数参数末尾找到的逗号。当向JavaScript代码添加新元素、参数或属性时，它们可能很有用。它只是让开发者可以选择将数组写成`[1,2,3]`或`[1,2,3,]`（注意第二个示例中的逗号）'
- en: JavaScript has allowed trailing commas in arrays and objects for a long time.
    Finally, in ECMAScript 2017 (ES8), the standard now allows you to add trailing
    commas to function parameters as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript长期以来允许在数组和对象中使用尾随逗号。最终，在ECMAScript 2017（ES8）中，标准现在允许你将尾随逗号添加到函数参数中。
- en: 'That means all the following examples are valid JavaScript code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下所有示例都是有效的JavaScript代码：
- en: 'Arrays:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding example is clearly valid JavaScript code and `arr` is created
    as `[1, 2, 3, undefined, undefined]`
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例显然是有效的JavaScript代码，`arr`被创建为`[1, 2, 3, undefined, undefined]`
- en: Let us now explore how objects behave with trailing commas.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来探索带有尾随逗号的物体行为。
- en: 'Objects:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对象：
- en: '[PRE83]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It can be seen that the code does not throw any error even after putting a comma
    after the last property name. Let's move on to functions now.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，即使在最后一个属性名后放置逗号，代码也不会抛出任何错误。现在让我们转向函数。
- en: 'Functions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 函数：
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: All the aforementioned function definitions are valid from the ES2017 (ES8)
    spec.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述函数定义从ES2017（ES8）规范起都是有效的。
- en: The semicolon dilemma
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分号困境
- en: You must've seen a lot of JavaScript code with semicolons, and a lot without
    semicolons as well. And surprisingly, both work fine! While languages such as
    C, C++, Java, and so on are strict about the use of semicolons, and on the other
    hand languages such as Python are strict about not using semicolons (only indentations),
    there is no such fixed rule for JavaScript.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定见过很多带有分号的JavaScript代码，也见过很多不带分号的代码。而且令人惊讶的是，两者都工作得很好！虽然像C、C++、Java等语言对分号的使用非常严格，而另一方面像Python这样的语言对不使用分号（只有缩进）非常严格，但JavaScript没有这样的固定规则。
- en: So let's see when is semicolon required in JavaScript.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们看看在JavaScript中何时需要分号。
- en: Automatic semicolon insertion in JavaScript
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的自动分号插入
- en: 'The ECMAScript Language specification ([http://www.ecma-international.org/ecma-262/5.1/#sec-7.9](http://www.ecma-international.org/ecma-262/5.1/#sec-7.9))
    states that:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript语言规范（[http://www.ecma-international.org/ecma-262/5.1/#sec-7.9](http://www.ecma-international.org/ecma-262/5.1/#sec-7.9)）指出：
- en: '"Certain ECMAScript statements must be terminated with semicolons. Such semicolons
    may always appear explicitly in the source text"'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '"某些ECMAScript语句必须以分号结束。这样的分号可以始终显式出现在源文本中"'
- en: 'But the spec also says:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 但规范还说：
- en: '"For convenience, however, such semicolons may be omitted from the source text
    in certain situations."'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '"为了方便起见，然而，在某些情况下，可以从源文本中省略这些分号。"'
- en: Therefore, the specification states that JavaScript is able to handle automatic
    semicolon insertion by its own judgment. However, it is extremely error-prone
    in some cases and not intuitive at all.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，规范指出JavaScript能够根据其自身判断处理自动分号插入。然而，在某些情况下，它极其容易出错，而且一点也不直观。
- en: 'Consider this example:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE85]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'JavaScript automatically inserts semicolon to make code look like:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript会自动插入分号，使代码看起来像：
- en: '[PRE86]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: So far so good.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。
- en: Where to insert semicolons in JavaScript?
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JavaScript中在哪里插入分号？
- en: At times, you will find yourself skipping semicolons somewhere and you'll see
    that your code still works! This is strictly opposite to what you find in languages
    such as C or C++. Let us take a look at a scenario where you can get trapped by
    not using semicolons properly.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会发现自己跳过了某些分号，但你发现代码仍然可以正常工作！这与你在C或C++等语言中遇到的情况正好相反。让我们看看一个可能会因为不正确使用分号而陷入困境的场景。
- en: 'Consider this code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE87]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Take a good look and guess what possible alerts might be, with their orders
    as well. When you''re ready with your answer, look at the following, the code
    to which JavaScript compiles (not really, just the code after inserting automatic
    semicolons):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察并猜测可能出现的警告及其顺序。当你准备好答案后，看看以下内容，这是JavaScript编译后的代码（实际上并不是，只是插入自动分号后的代码）：
- en: '[PRE88]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: So instead of invoking that self-invoking function, what you do apparently is,
    pass that whole function as an argument to the first one. Therefore, try to use
    semicolons to avoid ambiguity in your code. You can always use JavaScript compressors
    later on, which will take care of necessary places to leave semicolons intact.
    The takeaway from here is **use semicolons.**
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其调用那个自调用的函数，你显然是，将整个函数作为参数传递给第一个函数。因此，尽量使用分号来避免代码中的歧义。你总是可以在之后使用JavaScript压缩器，它会处理保留分号必要的地方。从这个例子中我们可以得到的启示是**使用分号**。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about variable scopes, read-only variables, splitting
    arrays into individual values, passing indefinite parameters to a function, extracting
    data from objects and arrays, arrow functions, and new syntaxes for creating object
    properties, hoisting, IIFE, semicolon usage, and more.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了变量作用域、只读变量、将数组拆分为单个值、向函数传递不定参数、从对象和数组中提取数据、箭头函数以及创建对象属性的新语法、提升、IIFE、分号的使用以及更多。
- en: In the next chapter, we will learn about built-in objects and symbols, and we
    will discover tons of fundamental tools JavaScript natively provides us with out-of-the-box.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习内置对象和符号，并会发现JavaScript为我们提供的许多基本工具，这些工具是开箱即用的。
