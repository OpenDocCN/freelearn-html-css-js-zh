- en: Chapter 3. Adding Vector Layers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。添加矢量图层
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Adding markers to maps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加标记
- en: Adding popups to markers or maps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向标记或地图添加弹出窗口
- en: Adding lines to maps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加线条
- en: Adding polygons to maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加多边形
- en: Adding circles/rectangles to maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加圆形/矩形
- en: Adding animated lines to maps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加动画线条
- en: Adding the KML/GeoRSS layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 KML/GeoRSS 图层
- en: Adding GeoJSON to the Google Maps JavaScript API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GeoJSON 添加到 Google Maps JavaScript API
- en: Adding WKT to the Google Maps JavaScript API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 WKT 添加到 Google Maps JavaScript API
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is about vector layers, which are completely different from raster
    layers. This chapter gives you the most common and important recipes that you
    may need while working with the Google Maps JavaScript API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于矢量图层，它与栅格图层完全不同。本章为你提供了在使用 Google Maps JavaScript API 时可能需要的最常见和最重要的食谱。
- en: 'In the GIS world, both the vector and raster layers are used in different cases.
    Vectors are used for representing the Earth''s features in most cases. For example,
    **Points of Interest** (**POI**), such as coffee shops or restaurants, are shown
    with points; rivers or roads are shown with polylines; and parks or buildings
    are shown with polygons. As it is seen here, there are three different vector
    types: point, polyline, and polygon. Remember that all vectors consist of points,
    which are the building blocks of vectors.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GIS 世界中，矢量和栅格图层在不同情况下都会被使用。矢量通常用于表示地球的特征。例如，**兴趣点**（**POI**），如咖啡店或餐厅，以点表示；河流或道路以折线表示；公园或建筑物以多边形表示。正如你所看到的，这里有三种不同的矢量类型：点、折线和多边形。请记住，所有矢量都由点组成，点是矢量的基本构建块。
- en: In the Google Maps JavaScript API, all types of vectors are called **overlays**.
    In addition to vectors, popups and symbols are also included in overlays. All
    the recipes related to them are included in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Maps JavaScript API 中，所有类型的矢量都称为 **覆盖层**。除了矢量之外，弹出窗口和符号也包含在覆盖层中。所有与它们相关的食谱都包含在本章中。
- en: Maps are mostly used for visualization, so static maps are not enough in some
    cases. Some animations added to polylines make a difference. For example, showing
    the flow direction with rivers is remarkable for scientists. The Google Maps JavaScript
    API also supports animated polylines, which is one of the recipes in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 地图主要用于可视化，因此在某些情况下静态地图是不够的。一些添加到折线上的动画可以产生差异。例如，用河流显示流向对科学家来说是非常显著的。Google Maps
    JavaScript API 也支持动画折线，这是本章中的一个食谱。
- en: The Google Maps JavaScript API is a great API with support for KML and GeoRSS,
    but some of the industry de facto standards are not supported out of the box,
    such as GeoJSON and WKT. GeoJSON and WKT are the most used vector publishing formats
    in the industry, especially in open source libraries. These formats will be supported
    by additional libraries, which are also included in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API 是一个功能强大的 API，支持 KML 和 GeoRSS，但一些行业事实标准不支持默认设置，例如
    GeoJSON 和 WKT。GeoJSON 和 WKT 是行业中最常用的矢量发布格式，尤其是在开源库中。这些格式将由额外的库支持，这些库也包含在本章中。
- en: Let's start to explore the recipes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索这些食谱。
- en: Adding markers to maps
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向地图添加标记
- en: Maps are used for many cases in websites, but the most used one shows the location
    of a company or business. The location of a company or business can be called
    a POI in the LBS or GIS sector and this is a point type of the vector layer. In
    the Google Maps JavaScript API, POIs or points are shown as **markers**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 地图在网站中有许多用途，但最常用的用途是显示公司或企业的位置。在 LBS 或 GIS 领域，公司或企业的位置可以称为 POI，这是矢量图层的一种点类型。在
    Google Maps JavaScript API 中，POI 或点以 **标记** 的形式显示。
- en: This recipe shows how to add markers to maps using the `google.maps.LatLng`
    and `google.maps.Marker` classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何使用 `google.maps.LatLng` 和 `google.maps.Marker` 类将标记添加到地图中。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In Chapter 1, Google Maps JavaScript API Basics, you learned how to create a
    map. So, only the additional code lines that will add markers are covered in this
    recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章《Google Maps JavaScript API 基础》中，你学习了如何创建地图。因此，本食谱只涵盖将标记添加到地图所需的附加代码行。
- en: You can find the source code at `Chapter 3/ch03_adding_markers.html.`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Chapter 3/ch03_adding_markers.html` 找到源代码。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following are the steps we need to add both standard and icon markers to
    maps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们需要添加标准和图标标记到地图的步骤：
- en: 'Let''s add the minimum and maximum values of latitudes and longitudes of **bounding
    box** (**BBOX**) to limit our random markers'' area. This bounding box almost
    defines the area that **Turkey** covers. Also `markerId` is defined to name the
    random markers. All variables must be defined outside the function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加**边界框**（**BBOX**）的纬度和经度的最小和最大值，以限制随机标记的区域。这个边界框几乎定义了**土耳其**覆盖的区域。同时定义了`markerId`来命名随机标记。所有变量都必须在函数外部定义：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following function after the `initMap()` function. This function starts
    listening to the click events of the buttons:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initMap()`函数之后添加以下函数。这个函数开始监听按钮的点击事件：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add the following function after the `startButtonEvents()` function. This function
    creates a random latitude and longitude according to the values given at the beginning
    of this section and returns the `google.maps.LatLng` object.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`startButtonEvents()`函数之后添加以下函数。这个函数根据本节开头给出的值创建一个随机纬度和经度，并返回`google.maps.LatLng`对象。
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, the `addStandardMarker()` function is added. This function creates the
    standard Google Maps red marker. It gets the random `LatLng` object value from
    the function created in the preceding step. There is a commented line in the code
    block that will be explained later:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加了`addStandardMarker()`函数。这个函数创建了一个标准的谷歌地图红色标记。它从前面步骤中创建的函数中获取随机的`LatLng`对象值。代码块中有一行注释，稍后会进行解释：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is also another function named `addIconMarker()` described in this step.
    This is used for adding random markers with random images:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个步骤中，还有一个名为`addIconMarker()`的另一个函数进行了描述。这个函数用于添加带有随机图像的随机标记：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we will add HTML tags to finish the code. These links will help to
    trigger the functions defined in event listeners:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加HTML标签来完成代码。这些链接将帮助触发事件监听器中定义的函数：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. Initially, you will see an empty map. Then click on the links
    on the map to add random markers. The final map can be seen as shown in the following
    screenshot:![How to do it…](img/8825OT_03_01.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的浏览器中转到您本地存储HTML文件的URL，查看结果。最初，您将看到一个空地图。然后点击地图上的链接以添加随机标记。最终地图可以参考以下截图：![如何操作…](img/8825OT_03_01.jpg)
- en: As seen in the preceding screenshot, we created a map with both the standard
    and icon markers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们创建了一个包含标准和图标标记的地图。
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Google Maps uses the Web Mercator projection system for its tile system, but
    the coordinates are still in GPS coordinates based on WGS 84 Datum. Coordinates
    are based on latitudes and longitudes that are between -90 to 90 and -180 to 180
    degrees respectively. The combination of a latitude and longitude defines a point
    on Earth. The Google Maps JavaScript API uses the `google.maps.LatLng` class to
    create a point. This class is also used in [Chapter 1](ch01.html "Chapter 1. Google
    Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*, to set the
    center of a map. The following line defines the coordinates of **Istanbul**, **Turkey**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌地图使用Web Mercator投影系统为其瓦片系统，但坐标仍然是基于WGS 84基准的GPS坐标。坐标基于介于-90到90和-180到180度之间的纬度和经度。纬度和经度的组合定义了地球上的一个点。谷歌地图JavaScript
    API使用`google.maps.LatLng`类来创建一个点。这个类也在[第1章](ch01.html "第1章。谷歌地图JavaScript API基础")，*谷歌地图JavaScript
    API基础*中用于设置地图的中心。以下行定义了**伊斯坦布尔**，**土耳其**的坐标：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `google.maps.Marker` class creates the marker with one required parameter,
    `google.maps.MarkerOptions`. The `MarkerOptions` class also has one required parameter
    that is named as `position`. This parameter gets the `google.maps.LatLng` object
    to define the coordinates of the marker. In the code, there are also the `map`
    and `title` parameters that are not required, but they are needed to show the
    marker on the map and set the title of the marker respectively. If you want to
    show the marker immediately after the creation of the marker, you should use the
    `map` parameter. But in some cases, you want to create markers and show them on
    the map later. In such a case, you should use the `setMap` method of `marker`
    with your map reference.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`google.maps.Marker` 类使用一个必需的参数 `google.maps.MarkerOptions` 创建标记。`MarkerOptions`
    类还有一个名为 `position` 的必需参数。此参数获取 `google.maps.LatLng` 对象以定义标记的坐标。在代码中，还有 `map` 和
    `title` 参数，它们不是必需的，但它们是显示标记在地图上和设置标记标题所必需的。如果你想立即在创建标记后显示标记，你应该使用 `map` 参数。但在某些情况下，你可能想创建标记并在稍后将其显示在地图上。在这种情况下，你应该使用
    `marker` 的 `setMap` 方法与你的地图引用。'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to remove the marker from the map, you must set the map value to
    null. Do not forget to keep a reference of your markers in order to remove them
    from the map:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从地图中删除标记，你必须将地图值设置为 null。不要忘记保留你的标记引用，以便从地图中删除它们：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Default markers with red icons are not suitable for all cases. The Google Maps
    JavaScript API lets you customize the icon of a marker. Basically, you should
    add the `icon` parameter to `google.maps.MarkerOptions` to customize the marker
    icon. This parameter accepts three different types: `String`, the `google.maps.Icon`
    object, or the `google.maps.Symbol` object. If you have a simple icon image, you
    will use the string type with a path to the image. Otherwise, you will create
    the icon or symbol objects to set a complex visualization for the marker. Showing
    an icon via a `String` parameter can be done as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的带有红色图标的标记并不适用于所有情况。Google Maps JavaScript API 允许你自定义标记的图标。基本上，你应该将 `icon`
    参数添加到 `google.maps.MarkerOptions` 中来自定义标记图标。此参数接受三种不同类型：`String`、`google.maps.Icon`
    对象或 `google.maps.Symbol` 对象。如果你有一个简单的图标图像，你将使用字符串类型并指定图像的路径。否则，你需要创建图标或符号对象来为标记设置复杂的可视化效果。通过
    `String` 参数显示图标可以按照以下方式完成：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, random coordinates are used to show markers. If you have a data
    source that includes coordinates, you could easily add them to the map with JavaScript
    techniques without changing anything while creating the marker. Please be sure
    about the JavaScript asynchronous behavior while adding markers to the map from
    external sources because your data will not be available when you need it due
    to asynchronous behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，使用随机坐标来显示标记。如果你有一个包含坐标的数据源，你可以很容易地使用 JavaScript 技术将其添加到地图上，而无需在创建标记时进行任何更改。请确保在从外部源添加标记到地图时了解
    JavaScript 的异步行为，因为由于异步行为，你的数据在你需要时可能不可用。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html "第1章。Google Maps JavaScript API 基础") 的 *在自定义 DIV 元素中创建简单地图*
    菜谱中，*Google Maps JavaScript API 基础*
- en: Adding popups to markers or maps
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向标记或地图添加弹出窗口
- en: Almost every mapping application has an ability to display information related
    to the features shown on it. Showing all the related information on the map at
    the same time is an impossible mission for a developer and it is also useless
    for users. Instead of showing all the information on the map, developers add interaction
    to points, polylines, or polygons that show the related information with different
    techniques such as popups or info windows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个地图应用都有显示与显示在地图上的功能相关的信息的能力。同时显示所有相关信息对于开发者来说是一项不可能完成的任务，对于用户来说也是无用的。因此，开发者不是在地图上显示所有信息，而是通过弹出窗口或信息窗口等技术，将相关信息的显示添加到点、折线或多边形上。
- en: Popups or info windows can hold anything that can be written in HTML tags, such
    as pictures, videos, or standard text.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口或信息窗口可以包含任何可以用 HTML 标签编写的元素，例如图片、视频或标准文本。
- en: 'You will see something like the following screenshot, if you get through to
    the end of the recipe:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功完成菜谱的整个过程，你会看到以下类似的截图：
- en: '![Adding popups to markers or maps](img/8825OT_03_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![向标记或地图添加弹出窗口](img/8825OT_03_02.jpg)'
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is the modified version of the previous recipe named *Adding markers
    to maps*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是之前名为 *添加标记到地图* 的食谱的修改版本。
- en: You can find the source code at `Chapter 3/ch03_adding_popups.html`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `Chapter 3/ch03_adding_popups.html` 找到源代码。
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can easily add popups to markers or maps by performing the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤轻松地将弹出窗口添加到标记或地图上：
- en: 'First, the `initMap()` function is modified by adding the following code lines
    after creating the `map` object. This will open an info window or popup at the
    center of the map when the map first initializes:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在创建 `map` 对象后添加以下代码行修改 `initMap()` 函数。这将使地图在首次初始化时在地图中心打开一个信息窗口或弹出窗口：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the following function to listen to the click events of the button
    defined in the HTML:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下函数添加到监听HTML中定义的按钮的点击事件：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `startButtonEvents()` function must be called on initializing the map,
    so the following line is added to the `initMap()` function after `map` is initialized:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化地图时必须调用 `startButtonEvents()` 函数，因此，在 `map` 初始化后，向 `initMap()` 函数中添加以下行：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, the `addStandardMarker()` function is modified by adding the following
    code lines after the creation of the marker:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在标记创建后添加以下代码行修改 `addStandardMarker()` 函数：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and take a look at the result. You will see an info window at the beginning of
    the map. You will also click on the link on the map to add random markers, but
    these markers are different from the ones before because they will open a popup
    when the user clicks on them.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你喜欢的浏览器中存储HTML文件的本地URL，查看结果。你将看到地图开始处有一个信息窗口。你还可以点击地图上的链接来添加随机标记，但与之前的标记不同，因为当用户点击它们时，它们将打开一个弹出窗口。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Google Maps JavaScript API has a default `InfoWindow` class to create info
    windows or popups. This class can be initialized in two ways. One way is to give
    a location at info windows options with the `LatLng` object. By using this, you
    can open a popup on the map wherever you want. This can be attached to a function
    or an event. For example, you can attach the `click` event to the map to query
    something from the server and show the result in the popup. This is common for
    the Google Maps JavaScript API. The following code creates an info window at the
    location of 39.9078 (latitude) and 32.8252 (longitude) with the HTML content.
    Its `open` method with the `map` input shows the info window attached to the given
    map reference:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API有一个默认的 `InfoWindow` 类来创建信息窗口或弹出窗口。这个类可以通过两种方式初始化。一种方式是在信息窗口选项中提供一个位置，使用
    `LatLng` 对象。通过这种方式，你可以在地图上的任何位置打开一个弹出窗口。这可以附加到一个函数或事件。例如，你可以将 `click` 事件附加到地图上，从服务器查询某些内容，并在弹出窗口中显示结果。这在Google
    Maps JavaScript API中很常见。以下代码在39.9078（纬度）和32.8252（经度）的位置创建了一个信息窗口，并带有HTML内容。它的
    `open` 方法使用 `map` 输入显示了附加到给定地图引用的信息窗口：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another way to use popups is by binding them to markers. Instead of giving
    a location, info windows will be anchored to a `marker` object. The `infoWindow`
    object given in the following code does not have a `position` property, which
    means it will be anchored to a `marker` object. Remember that `marker` objects
    are subclasses of the `MVCObject` class in Google Maps JavaScript API. They are
    a type of anchor parameter of the `open` method of the `InfoWindow` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用弹出窗口的另一种方法是将其绑定到标记上。而不是给出一个位置，信息窗口将锚定到一个 `marker` 对象。以下代码中给出的 `infoWindow`
    对象没有 `position` 属性，这意味着它将锚定到一个 `marker` 对象。记住，`marker` 对象是Google Maps JavaScript
    API中 `MVCObject` 类的子类。它们是 `InfoWindow` 类 `open` 方法的一种锚定参数：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is an event attached to `marker` in the preceding code, which is the subject
    of [Chapter 5](ch05.html "Chapter 5. Understanding Google Maps JavaScript API
    Events"), *Understanding Google Maps JavaScript API Events*. So use the code as
    it is written; this will be explained in detail later, but basically this code
    snippet listens to the `marker` object and opens the created `infowindow` object
    on the `click` event.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`marker` 对象关联了一个事件，这是 [第5章](ch05.html "第5章。理解Google Maps JavaScript
    API事件")，*理解Google Maps JavaScript API事件* 的主题。因此，按照代码原样使用；这将在稍后详细解释，但基本上这个代码片段监听
    `marker` 对象，并在 `click` 事件上打开创建的 `infowindow` 对象。
- en: As it is seen in this recipe, you can use both simple strings and complex HTML
    content within the info windows. This means you can even add YouTube videos or
    Flash content inside info windows.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如本菜谱所示，您可以在信息窗口中使用简单的字符串和复杂的 HTML 内容。这意味着您甚至可以在信息窗口中添加 YouTube 视频或 Flash 内容。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html "第1章. Google Maps JavaScript API 基础") 的 *在自定义 DIV 元素中创建简单地图*
    菜谱中，*Google Maps JavaScript API 基础*，
- en: The *Adding markers to maps* recipe
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向地图添加标记* 菜谱'
- en: Adding lines to maps
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向地图添加线条
- en: Lines or polylines in GIS are an array of points connected to each other to
    show features on Earth such as roads, paths, or rivers. The properties of polylines
    on maps are similar to the properties of features represented on Earth. For example,
    a road is differentiated on Earth by its color and width. The same properties
    are also defined in the Google Maps JavaScript API to exactly represent the road
    on the map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GIS 中，线条或多边形是一系列相互连接的点，用于在地球上显示诸如道路、路径或河流等特征。地图上多边形的属性与地球上表示的特征的属性相似。例如，地球上的道路通过其颜色和宽度来区分。相同的属性也在
    Google Maps JavaScript API 中定义，以精确地表示地图上的道路。
- en: This recipe is focused on showing lines/polylines on a map to show a route from
    **Istanbul** to **Ankara**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的重点是展示地图上的线条/多边形，以显示从 **伊斯坦布尔** 到 **安卡拉** 的路线。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the same map creation process defined in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    but there are some minor changes in the `zoom` level and center coordinates to
    show the route in detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用与 [第1章](ch01.html "第1章. Google Maps JavaScript API 基础") 中定义的相同地图创建过程，*Google
    Maps JavaScript API 基础*，但在 `zoom` 级别和中心坐标上有些细微的变化，以详细显示路线。
- en: You can find the source code at `Chapter 3/ch03_adding_lines.html`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter 3/ch03_adding_lines.html` 找到源代码。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you want to add line-type geometries to your map, you should perform the
    following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想向地图添加线型几何形状，您应执行以下步骤：
- en: Let's open our first recipe's source code mentioned in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    and save it as `adding_lines.html`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开 [第1章](ch01.html "第1章. Google Maps JavaScript API 基础") 中提到的第一个菜谱的源代码，并将其保存为
    `adding_lines.html`。
- en: 'Then, add the following lines of code after defining the `map` object at the
    beginning of the JavaScript part of the code. The array defined in this step is
    the route coordinates in latitudes and longitudes from **Istanbul** to **Ankara**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在代码的 JavaScript 部分定义 `map` 对象之后添加以下代码行。本步骤中定义的数组是从 **伊斯坦布尔** 到 **安卡拉** 的经纬度路线坐标：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, create the `addPolyline` function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 `addPolyline` 函数：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need to create a new array composed of `LatLng` objects from the array defined
    at the beginning in the function:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的数组，由函数开头定义的 `LatLng` 对象组成：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we need to create the `polyline` object as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要创建 `polyline` 对象，如下所示：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add the `polyline` object to `map`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `polyline` 对象添加到 `map` 中：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, call the `addPolyline()` function at the end of the `initMap()` function
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `initMap()` 函数的末尾调用 `addPolyline()` 函数，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. You will see a red route from **Istanbul** to **Ankara** on
    the map, as shown in the following screenshot:![How to do it…](img/8825OT_03_03.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储 HTML 文件的本地 URL，查看结果。您将在地图上看到从 **伊斯坦布尔** 到 **安卡拉** 的红色路线，如下面的截图所示：![如何操作…](img/8825OT_03_03.jpg)
- en: Thus, we have successfully created a map with a line-type geometry on it, which
    is the route from one place to another in this case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们成功创建了一个带有线型几何形状的地图，在这个例子中，它表示从一个地方到另一个地方的路线。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As stated before, polylines consist of points. Points are defined by the `LatLng`
    class in the Google Maps JavaScript API, so an array of latitudes and longitudes
    should be converted to the `LatLng` array. The following code block creates a
    new array composed of `LatLng` objects. To do this, a classic approach of iterating
    an array via a loop is used as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，多边形由点组成。点由 Google Maps JavaScript API 中的 `LatLng` 类定义，因此应将经纬度数组转换为 `LatLng`
    数组。以下代码块创建了一个由 `LatLng` 对象组成的新数组。为此，使用以下循环遍历数组的经典方法：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A route will be created by the `Polyline` class that takes the instance of the
    `PolylineOptions` class as a parameter. There are many properties of the `PolylineOptions`
    class, but we only added the most used ones.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`PolylineOptions`类的实例作为参数的`Polyline`类将创建一个路线。`PolylineOptions`类有许多属性，但我们只添加了最常用的。
- en: The `path` property that defines the route feature contains an array of `LatLng`
    objects. The `strokeWeight` property is used in order to define the width of the
    line in pixels. The `strokeColor` property defines the color of the line in the
    `String` type as a `HEX` format with a leading `#` symbol.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路线特征的`path`属性包含一个`LatLng`对象的数组。`strokeWeight`属性用于定义线的宽度（以像素为单位）。`strokeColor`属性定义线的颜色，以`String`类型表示，采用带前导`#`符号的`HEX`格式。
- en: The `strokeOpacity` property usage can be optional, but it can be useful while
    showing multiple layers. This parameter gets a value from 0.0 to 1.0\. 0.0 means
    your line is invisible and 1.0 means your line is not transparent. If you have
    multiple layers, you should define the opacity of your lines to show other features
    or layers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`strokeOpacity`属性的用法是可选的，但在显示多个图层时可能很有用。此参数的值从0.0到1.0。0.0表示你的线是不可见的，1.0表示你的线不是透明的。如果你有多个图层，你应该定义你线条的不透明度以显示其他特征或图层。'
- en: 'This recipe shows the static route defined in the HTML; but in some cases,
    you can load data from a remote source. In this case, you should change the path
    array via the method of the `Polyline` class `setPath()`. This method gets the
    same array defined in the `PolylineOptions` class. For example, you create a new
    path array named `newRoute`. To change the coordinates to the new route, you should
    call the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方显示了在HTML中定义的静态路线；但在某些情况下，你可以从远程源加载数据。在这种情况下，你应该通过`Polyline`类的`setPath()`方法更改路径数组。此方法获取与`PolylineOptions`类中定义的相同的数组。例如，你创建一个名为`newRoute`的新路径数组。要将坐标更改为新路线，你应该调用以下代码：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you want to remove `polyline` completely from the map, then you should set
    the `map` property to null or call the `setMap(null)` method of the `Polyline`
    class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要完全从地图中移除`polyline`，那么你应该将`map`属性设置为null或调用`Polyline`类的`setMap(null)`方法。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. Google Maps JavaScript API基础知识")中的*在自定义DIV元素中创建简单地图*配方'
- en: The *Adding polygons to maps* recipe
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加多边形到地图*配方'
- en: Adding polygons to maps
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多边形添加到地图中
- en: Polygons are similar to polylines that are an array of points connected to each
    other. However, polygons are closed loops to show Earth features such as parks,
    parcels, or regions. In addition to the properties of polylines, polygons have
    a fill region inside.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形类似于多段线，多段线是一系列相互连接的点。然而，多边形是封闭的环路，用于显示地球上的特征，如公园、地块或区域。除了多段线的属性外，多边形内部还有一个填充区域。
- en: This recipe is focused on showing polygons on a map to show a region around
    **Ankara**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方专注于在地图上显示多边形以显示**安卡拉**周围的区域。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the same map-creation process defined in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    but there are some minor changes in the `zoom` level and center coordinates to
    show the region in detail.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用在[第1章](ch01.html "第1章. Google Maps JavaScript API基础知识")中定义的相同的地图创建过程，*Google
    Maps JavaScript API基础知识*，但在`zoom`级别和中心坐标上有些小的变化，以详细显示区域。
- en: You can find the source code at `Chapter 3/ch03_adding_polygons.html`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter 3/ch03_adding_polygons.html`找到源代码。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you perform the following steps, you can add polygon-type geometries to
    your map:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行以下步骤，你可以将多边形类型的几何形状添加到你的地图中：
- en: Let's open our first recipe's source code mentioned in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    and save it as `adding_polygons.html`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开在[第1章](ch01.html "第1章. Google Maps JavaScript API基础知识")中提到的第一个配方的源代码，*Google
    Maps JavaScript API基础知识*，并将其保存为`adding_polygons.html`。
- en: 'Then, add the following lines of code after defining the map object at the
    beginning of the JavaScript part. The array defined in this step is the area coordinates
    of a random region in latitudes and longitudes around **Ankara**:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在JavaScript部分的开始处定义地图对象后，添加以下代码行。在此步骤中定义的数组是围绕**安卡拉**的经纬度随机区域的区域坐标：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then create the `addPolygon` function:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建`addPolygon`函数：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to create a new array composed of `LatLng` objects from the array defined
    at the beginning in the function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的数组，该数组由函数开头定义的数组中的 `LatLng` 对象组成：
- en: '[PRE26]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we need to create the `polygon` object as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要按照以下方式创建 `polygon` 对象：
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s add the `polygon` object to `map`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `polygon` 对象添加到 `map` 中：
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, call the `addPolygon()` function at end of the `initMap()` function as
    follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `initMap()` 函数的末尾调用 `addPolygon()` 函数，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. You will see a yellow region surrounded by a red boundary
    around **Ankara**, as shown in the following screenshot:![How to do it…](img/8825OT_03_04.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您最喜欢的浏览器中转到存储 HTML 文件的本地 URL，并查看结果。您将看到一个由红色边界围绕的黄色区域，该区域位于 **安卡拉** 附近，如下面的截图所示：![如何操作…](img/8825OT_03_04.jpg)
- en: This is how we add polygon-type geometry to our map.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们在地图上添加多边形类型几何形状的方法。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Polygon` class is much like the `Polyline` class in the Google Maps JavaScript
    API. There are minor differences between the `Polyline` and `Polygon` classes,
    so we will get into the details of these differences only in this recipe. Please
    refer to the previous recipe for more details.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon` 类在 Google Maps JavaScript API 中与 `Polyline` 类非常相似。`Polyline` 和 `Polygon`
    类之间有一些细微的差异，所以我们只在这个菜谱中详细介绍这些差异。请参考之前的菜谱以获取更多详细信息。'
- en: As stated in the previous recipe, the `Polygon` class creates objects with the
    help of the `PolygonOptions` class that includes many parameters for polygons.
    There are `path`, `strokeWeight`, `strokeColor`, and `strokeOpacity` parameters
    shared with the `PolylineOptions` class. The usage and purpose of these parameters
    are the same for both polygons and polylines. The main difference is that polygons
    fill an area. There must be some new parameters to define the polygon fill.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个菜谱所述，`Polygon` 类通过包含许多多边形参数的 `PolygonOptions` 类来创建对象。`path`、`strokeWeight`、`strokeColor`
    和 `strokeOpacity` 参数与 `PolylineOptions` 类共享。这些参数的用法和目的对多边形和折线都是相同的。主要区别在于多边形填充一个区域。必须有一些新参数来定义多边形的填充。
- en: The `fillColor` property defines the color of the fill area in the `String`
    type as a `HEX` format with a leading `#` symbol. The `fillOpacity` property usage
    can be optional, but it can also be useful while showing multiple layers at the
    same time. This parameter gets a value from 0.0 to 1.0\. 0.0 means your polygon
    is invisible and 1.0 means your polygon is not transparent. This parameter is
    more important in polygons than in polylines because polygons fill areas, which
    can be an obstacle for some markers or polylines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillColor` 属性以 `String` 类型定义填充区域的颜色，格式为带前缀 `#` 的 `HEX` 格式。`fillOpacity` 属性的使用可以是可选的，但在同时显示多个图层时也可能很有用。此参数的值从
    0.0 到 1.0。0.0 表示您的多边形不可见，1.0 表示您的多边形不透明。此参数在多边形中比在折线中更重要，因为多边形填充区域，这可能会成为某些标记或折线的障碍。'
- en: Adding or removing the polygons has the same API usage as polylines, so there
    is no need to talk about it here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或删除多边形与折线的 API 使用方式相同，因此在这里无需讨论。
- en: One last thing to mention is that polygons are a closed version of polylines,
    so we add the same coordinates both at the start and end. This is a good usage
    but not necessary. Even if you do not add the end coordinates, which are the same
    as the start coordinates, the Google Maps JavaScript API will close the polygon
    without any errors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的一点是，多边形是折线的封闭版本，因此我们在开始和结束处添加相同的坐标。这是一个好的用法，但不是必需的。即使您没有添加与起始坐标相同的结束坐标，Google
    Maps JavaScript API 也会无错误地关闭多边形。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。Google Maps JavaScript API 基础") 的 *在自定义 DIV 元素中创建简单地图*
    菜谱中，*Google Maps JavaScript API 基础*
- en: The *Adding lines to maps* recipe
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在地图上添加线条* 菜谱'
- en: Adding circles/rectangles to maps
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在地图上添加圆形/矩形
- en: Circles and rectangles are similar to polygons in that they have stroke and
    fill colors, weights, and opacities. The main difference between them and polygons
    is in defining the geometry. As seen in the previous recipes, the `PolygonOptions`
    class has a `path` parameter that consists of an array of `LatLng` objects. On
    the other side, the `CircleOptions` class has the `center` and `radius` parameters,
    and the `RectangleOptions` class has bounds parameters for defining the geometry
    of the `Circle` and `Rectangle` classes respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形和矩形在具有描边和填充颜色、权重和透明度方面与多边形相似。它们与多边形的主要区别在于定义几何形状。如前几个菜谱所示，`PolygonOptions`
    类有一个 `path` 参数，该参数由 `LatLng` 对象数组组成。另一方面，`CircleOptions` 类有 `center` 和 `radius`
    参数，而 `RectangleOptions` 类有用于定义 `Circle` 和 `Rectangle` 类几何形状的边界参数。
- en: In this recipe, we will go through adding circles according to the population
    of cities and a rectangle to map bounding to **Turkey**. The result map will show
    the bounding box of **Turkey** and major cities' population in a graph.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将根据城市的人口添加圆形，并添加一个矩形以将地图边界映射到**土耳其**。结果地图将显示**土耳其**的边界框和主要城市的人口图。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the first recipe defined in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template in order to skip map creation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 [第1章](ch01.html "第1章。Google Maps JavaScript API 基础") 中定义的第一个菜谱作为模板，以跳过地图创建。
- en: You can find the source code at `Chapter 3/ch03_circle_rectangle.html`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter 3/ch03_circle_rectangle.html` 找到源代码。
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Adding circles or rectangles to your map is quite easy if you perform the following
    steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行以下步骤，将圆形或矩形添加到地图上相当简单：
- en: Let's start by creating a new empty file named `circles_rectangles.html`. Then,
    copy all the code in the HTML file that was introduced in the *Creating a simple
    map in a custom DIV element* recipe of [Chapter 1](ch01.html "Chapter 1. Google
    Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*, and paste it
    into a new file.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `circles_rectangles.html` 的新空文件开始。然后，复制在 [第1章](ch01.html "第1章。Google
    Maps JavaScript API 基础") 中介绍的 HTML 文件中的所有代码，该代码位于 *在自定义 DIV 元素中创建简单地图* 菜谱中，*Google
    Maps JavaScript API 基础*，并将其粘贴到新文件中。
- en: 'Add the following lines for defining the global variables used in the functions:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下行以定义函数中使用的全局变量：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add the `addCircle()` and `addRectangle()` functions before the `initMap()`
    function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `initMap()` 函数之前添加 `addCircle()` 和 `addRectangle()` 函数：
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, add the following code block into the `addCircle()` function to initialize
    the circles:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码块添加到 `addCircle()` 函数中以初始化圆形：
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, add the following lines to the `addRectangle()` function to initialize
    the rectangle:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `addRectangle()` 函数添加以下行以初始化矩形：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, change the `zoom` level and `center` of the map according to your needs
    in the `initMap()` function. This example uses the following parameters:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `initMap()` 函数中根据您的需求更改地图的 `zoom` 级别和 `center`。本例使用以下参数：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, add the `addRectangle()` and `addCircle()` functions at the end of
    the `initMap()` function as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `initMap()` 函数的末尾添加 `addRectangle()` 和 `addCircle()` 函数，如下所示：
- en: '[PRE35]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Go to your local URL where your `circles_rectangles.html` file is stored in
    your favorite browser and take a look at the result. You will see the map with
    three circles and a grey rectangle behind them, as shown in the following screenshot:![How
    to do it…](img/8825OT_03_05.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您最喜欢的浏览器中存储 `circles_rectangles.html` 文件的本地 URL，并查看结果。您将看到地图上有三个圆形和一个灰色的矩形，如下面的截图所示：![如何做到这一点…](img/8825OT_03_05.jpg)
- en: This is the result of the recipe that shows both the circles and rectangles
    at the same time on the map. This can be a good example to visualize your tabular
    data on maps.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该菜谱的结果，它同时在地图上显示了圆形和矩形。这可以是一个很好的例子，用于可视化你在地图上的表格数据。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, let's talk about the circles. Circles are types of polygons, except they
    are defined by a center in the `LatLng` object with a radius in meters instead
    of paths. Other parameters are the same as the `PolygonOptions` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈圆形。圆形是多边形的一种类型，但它们由 `LatLng` 对象中的中心和一个以米为单位的半径定义，而不是路径。其他参数与 `PolygonOptions`
    类相同。
- en: 'In this recipe, first three cities of **Ankara**, **Istanbul**, and **Izmir**,
    are selected. The center and the population of these cities are defined using
    JSON objects in the array. The centers of cities are defined in `LatLng` objects,
    so there is no need for extra conversion. The following code block iterates over
    the cities'' array and creates a circle with a `center` parameter defined in the
    JSON object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，首先选择了**安卡拉**、**伊斯坦布尔**和**伊兹密尔**这三个城市。这些城市的中心和人口使用数组中的JSON对象定义。城市的中心使用`LatLng`对象定义，因此不需要额外的转换。下面的代码块遍历城市数组，并使用在JSON对象中定义的`center`参数创建一个圆：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `radius` parameter is defined as a parameter of population, that is, population
    divided by `100`; it shows the magnitude of a population. As seen on the map,
    the higher the population, the larger the circle. This can be used as a visualization
    of the population distribution without knowing the exact numbers. As seen, the
    other parameters, such as `fillColor`, `fillOpacity`, `strokeColor`, `strokeOpacity`,
    and `strokeWeight`, are used in the same way as in the `PolygonOptions` class.
    The `setMap()` function is also used as it is used in the polygon or polyline
    recipes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`radius`参数被定义为人口的一个参数，即人口除以`100`；它显示了人口的规模。如图所示，人口越高，圆就越大。这可以用来表示人口分布，而无需知道确切的数字。如图所示，其他参数，如`fillColor`、`fillOpacity`、`strokeColor`、`strokeOpacity`和`strokeWeight`，与`PolygonOptions`类的使用方式相同。`setMap()`函数也像在多边形或折线菜谱中使用的那样使用。'
- en: 'The other element, the rectangle, is also a type of polygon, except that its
    geometry is defined by the `LatLngBounds` object. In theory, the `LatLngBounds`
    object is composed of two `LatLng` objects that are defined as the southwest and
    northeast coordinates of a rectangle. These coordinates can also be defined as
    the minimum and maximum points of latitudes and longitudes. In this recipe, the
    rectangle defined shows the bounding box of **Turkey**. BBOX can be used for simple
    geometric calculations such as "point in polygon" or "intersection". Using BBOX
    in calculations gives fast results because of the simple geometry, but there is
    always an error in this calculation. As seen in the preceding screenshot, some
    areas are not on the border of **Turkey**, but they are in the bounding box. If
    you want to get the geometries to intersect with **Turkey** using the BBOX method,
    you can easily get other geometries that are outside the real geometry object
    of **Turkey**. As you can see, using the BBOX approach gets some geometries at
    the intersection of BBOX that can be outside the real area. The usage of the `Rectangle`
    class is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个元素，矩形，也是一种多边形，只不过其几何形状是由`LatLngBounds`对象定义的。在理论上，`LatLngBounds`对象由两个`LatLng`对象组成，分别定义为矩形的西南和东北坐标。这些坐标也可以定义为纬度和经度的最小和最大点。在这个菜谱中，定义的矩形显示了**土耳其**的边界框。BBOX可用于简单的几何计算，如“点在多边形内”或“交集”。由于几何形状简单，使用BBOX进行计算可以给出快速的结果，但这个计算总是存在误差。如图所示，一些区域不在**土耳其**的边界上，但它们在边界框内。如果您想使用BBOX方法获取与**土耳其**相交的几何形状，可以轻松地获取其他位于**土耳其**真实几何对象之外的几何形状。如图所示，使用BBOX方法得到的某些几何形状在BBOX的交点处可能位于真实区域的之外。`Rectangle`类的使用方法如下：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Google Maps JavaScript API gives many opportunities to developers that can
    make their life easier. Circles and rectangles can both be used for geometries
    or other visualization techniques in your applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API为开发者提供了许多机会，可以使他们的生活更加轻松。圆和矩形都可以用于应用程序中的几何形状或其他可视化技术。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In this recipe, we add circles and rectangles without any order. The most recently
    added one is shown in the preceding map. In this example, a rectangle is added
    first in order to show the circles better. If you want to change the display order
    of markers, info windows, polylines, polygons, circles, or rectangles, you should
    change the `zIndex` parameter of the option classes or change them via the `setZIndex(3)`
    or `setOptions({ zIndex: 3 })` methods.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个菜谱中，我们无序地添加圆和矩形。在先前的地图中显示的是最近添加的一个。在这个例子中，首先添加矩形是为了更好地显示圆。如果您想改变标记、信息窗口、折线、多边形、圆或矩形的显示顺序，应该更改选项类的`zIndex`参数，或者通过`setZIndex(3)`或`setOptions({
    zIndex: 3 })`方法进行更改。'
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。Google Maps JavaScript API 基础")中的*在自定义 DIV 元素中创建简单地图的配方*，*Google
    Maps JavaScript API 基础*'
- en: The *Adding lines to maps* recipe
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将线条添加到地图中的配方*'
- en: The *Adding polygons to maps* recipe
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将多边形添加到地图中的配方*'
- en: Adding animated lines to maps
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将动画线条添加到地图中
- en: Polylines are the representations of Earth's features on the Earth, but sometimes,
    they are not enough to show the mobility of Earth features. For example, a river
    can be shown with the help of polylines, but the flow direction of the river can't
    be demonstrated by the polylines alone. Animating polylines can be a solution
    to show the mobility of Earth features. The flow direction of a river can be shown
    with the help of animated polylines.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 折线是地球特征在地球上的表示，但有时它们不足以展示地球特征的移动性。例如，河流可以通过折线来显示，但河流的流向不能仅通过折线来展示。动画折线可以作为一个展示地球特征移动性的解决方案。河流的流向可以通过动画折线来展示。
- en: The Google Maps JavaScript API has a symbol feature that can add vector-based
    images to a polyline in the form of a symbol. You can create your own symbol with
    the help of the `Symbol` class, or you can also use the predefined symbols that
    are accessed from the `SymbolPath` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API 具有符号功能，可以将基于矢量的图像以符号的形式添加到折线中。您可以使用 `Symbol` 类创建自己的符号，或者您也可以使用从
    `SymbolPath` 类访问的预定义符号。
- en: In this recipe, we will create an animated polyline from the previous recipe.
    This animation shows that a car is moving from **Istanbul** to **Ankara**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将从上一个配方创建一个动画折线。这个动画显示一辆车从 **伊斯坦布尔** 移动到 **安卡拉**。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the fourth recipe of this chapter as a template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用本章的第四个配方作为模板。
- en: You can find the source code at `Chapter 3/ch03_animating_line.html`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `第3章/ch03_animating_line.html` 找到源代码。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps that are needed to add animated line-type geometries
    to your map:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将动画线条型几何图形添加到您的地图中所需的步骤：
- en: First, start by copying the contents of `ch03_adding_lines.html` to your new
    HTML file.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 `ch03_adding_lines.html` 的内容复制到您的新 HTML 文件中。
- en: 'Then, add the following line after the `map` object to make it global. This
    is used while animating the line:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `map` 对象之后添加以下行以使其全局。这在动画线条时使用：
- en: '[PRE38]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Change the function name from `addPolyline()` to `addAnimatedPolyline()` and
    add the following code block to define your symbol:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数名称从 `addPolyline()` 更改为 `addAnimatedPolyline()` 并添加以下代码块来定义您的符号：
- en: '[PRE39]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, change the polyline options as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式更改折线选项：
- en: '[PRE40]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, add the following function call to start the animation that will be defined
    right after the following step:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在以下步骤之后添加以下函数调用以启动动画，该动画将在以下步骤之后定义：
- en: '[PRE41]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following function block before the `initMap()` function:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initMap()` 函数之前添加以下函数块：
- en: '[PRE42]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, change the function call from `addPolyline()` to `addAnimatedPolyline()`
    in the `initMap()` function to add the new animated polyline:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `initMap()` 函数中将函数调用从 `addPolyline()` 更改为 `addAnimatedPolyline()` 以添加新的动画折线：
- en: '[PRE43]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and take a look at the result. You will see an arrow animating animating the route
    from **Istanbul** to **Ankara** on the map, as shown in the following screenshot:![How
    to do it…](img/8825OT_03_06.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储 HTML 文件的本地 URL，并查看结果。您将看到箭头在地图上从 **伊斯坦布尔** 到 **安卡拉** 的路线上进行动画，如下面的截图所示：![如何操作…](img/8825OT_03_06.jpg)
- en: As a result of this recipe, we can add the animated line-type geometry to our
    map, which shows the movement of a vehicle on a route.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个配方，我们可以将动画线条型几何图形添加到我们的地图中，显示车辆在路线上的移动。
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Animating polylines includes a trick with the JavaScript `setInterval` method
    and the Google Maps JavaScript API's icons property of the `PolylineOptions` class.
    As stated, you can create your own symbol or use the predefined ones.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 动画折线包括使用 JavaScript `setInterval` 方法和 Google Maps JavaScript API 的 `PolylineOptions`
    类的图标属性的一个技巧。正如所述，您可以创建自己的符号或使用预定义的符号。
- en: 'Predefined symbols can be accessible via the `SymbolPath` class, which is shown
    in the following screenshot, as it is in the Google Maps JavaScript API document:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义的符号可以通过 `SymbolPath` 类访问，如下面的截图所示，就像在 Google Maps JavaScript API 文档中一样：
- en: '![How it works...](img/8825OT_03_07.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8825OT_03_07.jpg)'
- en: 'In this recipe, we will use the `FORWARD_CLOSED_ARROW` type. This symbol is
    defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 `FORWARD_CLOSED_ARROW` 类型。这个符号定义如下：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `strokeColor` property is used to define the color of the symbol. The `path`
    property is used for defining the symbol type and the `scale` property is used
    for the size of the symbol. You can also change the `fillColor` and `fillOpacity`
    properties of predefined symbols like in polygons.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`strokeColor` 属性用于定义符号的颜色。`path` 属性用于定义符号类型，而 `scale` 属性用于定义符号的大小。你还可以更改预定义符号（如多边形）的
    `fillColor` 和 `fillOpacity` 属性。'
- en: As seen in the preceding screenshot, the predefined symbols are limited. If
    you need more types of symbols, you should define them yourself in the `Symbol`
    class. You need to define custom symbols via the `path` property of the `Symbol`
    class with the **SVG path notation**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，预定义的符号是有限的。如果你需要更多类型的符号，你应该在 `Symbol` 类中自己定义它们。你需要通过 `Symbol` 类的 `path`
    属性使用 **SVG 路径符号**来定义自定义符号。
- en: 'The SVG path notation is the definition of the shape in SVG commands such as
    `moveto` (`M`), `lineto` (`L`), or `closepath` (`Z`). For example, the following
    path notation defines a triangle:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 路径符号是 SVG 命令（如 `moveto` (`M`)、`lineto` (`L`) 或 `closepath` (`Z`)）中形状的定义。例如，以下路径符号定义了一个三角形：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The explanation of the path notation is as follows: move to point (`100`,`100`),
    draw a horizontal line from `100`,`100` to `300`, `100`, and draw a second line
    from (`300`,`100`) to (`200`, `300`). This shape appears as a triangle. Finally,
    the `Z` command is used to close the path. You can draw any shape with this notation,
    but you should be aware of the area that will be available for the map use. The
    Google Maps JavaScript API allows a 22 x 22 px square area to show a defined shape.
    If the shape is larger than this area, you should use the `scale` parameter to
    fit the shape into the area. The following code block will change the predefined
    arrow shape to a yellow triangle moving on the same route:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 路径符号的解释如下：移动到点 (`100`,`100`)，从 `100`,`100` 到 `300`,`100` 绘制一条水平线，然后从 (`300`,`100`)
    到 (`200`, `300`) 绘制第二条线。这个形状看起来像一个三角形。最后，使用 `Z` 命令关闭路径。你可以使用这种符号绘制任何形状，但你应该注意可用于地图的区域。Google
    Maps JavaScript API 允许一个 22 x 22 px 的正方形区域显示定义的形状。如果形状大于这个区域，你应该使用 `scale` 参数将形状调整到该区域。以下代码块将预定义的箭头形状更改为在同一路线上移动的黄色三角形：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![How it works...](img/8825OT_03_08.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8825OT_03_08.jpg)'
- en: If you noticed, there is an additional parameter named `anchor`. This parameter
    is used to define the position of the symbol relative to the polyline. If you
    do not add this parameter, your symbol will be pinned to the polyline from the
    (0,0) point as a default. In general, using the center of the symbol as an `anchor`
    point gives the best result. The `anchor` parameter accepts the `Point` class.
    It also gets its x and y parameters in pixels.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，这里有一个额外的参数名为 `anchor`。这个参数用于定义符号相对于折线的位置。如果你不添加这个参数，你的符号将默认从 (0,0) 点固定到折线上。一般来说，使用符号的中心作为
    `anchor` 点可以得到最佳结果。`anchor` 参数接受 `Point` 类。它也以像素为单位获取其 x 和 y 参数。
- en: 'The trickiest part of this recipe is the animation. In the `animateArrow()`
    function, we define a trigger that animates the symbol defined before via the
    `window.setInterval` method at every 50 milliseconds. An anonymous function is
    defined in this trigger as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱中最棘手的部分是动画。在 `animateArrow()` 函数中，我们定义了一个触发器，通过 `window.setInterval` 方法每
    50 毫秒动画化之前定义的符号。在这个触发器中定义了一个匿名函数如下：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function gets the first object of the icons array and changes the `offset`
    parameter of the defined icon with the changing parameter according to the `counter`
    variable. Running this function every 50 milliseconds moves the symbol over the
    polyline.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取图标数组中的第一个对象，并根据 `counter` 变量更改定义的图标中 `offset` 参数的动态参数。每 50 毫秒运行此函数将符号移动到折线上。
- en: In the anonymous function, you may have noticed that the polyline object has
    the `get()` and `set()` methods, which are not defined in the documentation. Since
    the `Polyline` class extends the `MVCObject` class, we can also use the methods
    of the `MVCObject` class. So, we can use the `get()` and `set()` methods of the
    parent class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名函数中，你可能已经注意到折线对象有 `get()` 和 `set()` 方法，这些方法在文档中并未定义。由于 `Polyline` 类扩展了 `MVCObject`
    类，我们也可以使用 `MVCObject` 类的方法。因此，我们可以使用父类的 `get()` 和 `set()` 方法。
- en: Using symbols and timers can make different visualizations on the map without
    the need of an extra library in addition to the Google Maps JavaScript API.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号和计时器可以在不添加额外库的情况下，通过Google Maps JavaScript API实现不同的可视化。
- en: There's more...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: '**SVG** is the abbreviation of **Scalable Vector Graphics**. It is an XML-based
    vector image format for two-dimensional graphics that support interactivity and
    animation. SVG is supported by all modern browsers. It can be a good solution
    for mapping platforms in some cases, like this one. SVG is a completely different
    subject, which is out of the scope of this book.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**SVG**是**可缩放矢量图形**的缩写。它是一种基于XML的二维矢量图像格式，支持交互性和动画。SVG被所有现代浏览器支持。在某些情况下，如本例，它可以是地图平台的良好解决方案。SVG是一个完全不同的主题，超出了本书的范围。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about SVG path notation**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于SVG路径表示法的更多信息**'
- en: 'More details can be found on the W3C site ([http://www.w3.org/TR/SVG/paths.html#PathData](http://www.w3.org/TR/SVG/paths.html#PathData)).
    There is also some editing software to get path notations without learning the
    language. The following address can be used for creating SVG and getting the path
    notation: [http://svg-edit.googlecode.com/svn/branches/2.6/editor/svg-editor.html](http://svg-edit.googlecode.com/svn/branches/2.6/editor/svg-editor.html).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息可以在W3C网站上找到([http://www.w3.org/TR/SVG/paths.html#PathData](http://www.w3.org/TR/SVG/paths.html#PathData))。还有一些编辑软件可以在不学习语言的情况下获取路径表示法。以下地址可用于创建SVG和获取路径表示法：[http://svg-edit.googlecode.com/svn/branches/2.6/editor/svg-editor.html](http://svg-edit.googlecode.com/svn/branches/2.6/editor/svg-editor.html)。
- en: See also
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. Google Maps JavaScript API基础知识")的“在自定义DIV元素中创建简单地图”菜谱中，*Google
    Maps JavaScript API基础知识*
- en: The *Adding lines to maps* recipe
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*向地图添加线条*菜谱'
- en: Adding KML/GeoRSS layers
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加KML/GeoRSS图层
- en: '**Keyhole Markup Language** (**KML**) has been introduced in Google Earth,
    which was originally named Keyhole Earth Viewer before Google bought it. KML became
    an OGC standard in 2008\. It is an XML notation for showing features in geo-enabled
    viewers. **GeoRSS** is also an emerging standard for sharing Earth features to
    show in geo-enabled viewers mostly used by web feeds or services. Both these standards
    can be consumable with the Google Maps JavaScript API.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键孔标记语言** (**KML**) 已在Google Earth中引入，在Google收购之前原名为Keyhole Earth Viewer。KML于2008年成为OGC标准。它是一种XML表示法，用于在地理启用查看器中显示特征。**GeoRSS**也是一种用于在地理启用查看器中共享地球特征的新兴标准，主要用于Web订阅或服务。这两个标准都可以通过Google
    Maps JavaScript API进行消费。'
- en: In this recipe, dynamic services will be consumed via the Google Maps JavaScript
    API. We will use the **U.S. Geological Survey** (**USGS**) web services to show
    recent earthquakes on maps. These services are updated regularly to reflect recent
    events.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，将通过Google Maps JavaScript API消耗动态服务。我们将使用**美国地质调查局**(**USGS**)的Web服务在地图上显示最近的地震。这些服务定期更新以反映最近的事件。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the simple map recipe introduced in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用在[第1章](ch01.html "第1章. Google Maps JavaScript API基础知识")中介绍的简单地图菜谱，*Google
    Maps JavaScript API基础知识*，作为模板。
- en: The source code of this recipe is at `Chapter 3/ch03_kml_georss.html`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该菜谱的源代码位于`第3章/ch03_kml_georss.html`。
- en: How to do it…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can add your KML/GeoRSS files to your map if you perform the following
    steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行以下步骤，可以将您的KML/GeoRSS文件添加到地图中：
- en: First, start by copying the contents of `ch01_simple_map.html` to our new HTML
    file.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`ch01_simple_map.html`的内容复制到我们的新HTML文件中。
- en: 'Next, define the following variables as global variables:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下变量定义为全局变量：
- en: '[PRE48]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following function after defining the global variables. This function
    triggers the adding of the GeoRSS feed to the map:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义全局变量后，添加以下函数。此函数触发将GeoRSS数据添加到地图中：
- en: '[PRE49]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, add the other function after the previous one. This function also triggers
    adding the KML feed to the map:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在之前的函数之后添加其他函数。此函数也会触发将KML数据添加到地图中：
- en: '[PRE50]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, add the following function, `clearMap(),` before the `initMap()` function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`initMap()`函数之前添加以下函数，`clearMap()`：
- en: '[PRE51]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, add the following function to listen to the click events of the buttons
    defined in the HTML in step 8:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下函数以监听第8步中定义的HTML按钮的点击事件：
- en: '[PRE52]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `startButtonEvents` function must be called on initializing the map, so
    the following line is added to the HTML file after the map gets initialized:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`startButtonEvents`函数必须在初始化地图时调用，因此以下行在地图初始化后添加到HTML文件中：'
- en: '[PRE53]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, add the following lines to the HTML body tag to trigger functions
    on clicking the links:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下行添加到HTML body标签中，以便在点击链接时触发函数：
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and take a look at the result. You will see an empty map at the beginning. When
    you click on the links on the map, you will see two different layers on the map
    as follows:![How to do it…](img/8825OT_03_09.jpg)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储HTML文件的本地URL，查看结果。您将看到开始时是一个空地图。当您点击地图上的链接时，您将看到地图上有两个不同的图层，如下所示：![如何操作…](img/8825OT_03_09.jpg)
- en: As seen in the preceding screenshot, you can easily add your GeoRSS files or
    services to the map with the Google Maps JavaScript API.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，您可以使用Google Maps JavaScript API轻松地将您的GeoRSS文件或服务添加到地图中。
- en: '![How to do it…](img/8825OT_03_10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/8825OT_03_10.jpg)'
- en: This is the result of adding the KML layer to your map. With Google Maps JavaScript
    API, you can easily add your KML files or services to the map.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将KML图层添加到您的地图中的结果。使用Google Maps JavaScript API，您可以轻松地将您的KML文件或服务添加到地图中。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Adding the KML/GeoRSS layer is the simplest one. There is only one class for
    adding both the layers, named `KmlLayer`. This class reads the KML or GeoRSS feed
    from local or remote locations and decides what to render. The usage of the class
    is very simple:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 添加KML/GeoRSS图层是最简单的一种。添加这两个图层只有一个类，名为`KmlLayer`。这个类从本地或远程位置读取KML或GeoRSS源，并决定要渲染的内容。类的使用非常简单：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After creating the layer, you must set the map with the `setMap(map)` method
    to show the layer on the map. If you want to remove the layer from the map, you
    must use the `setMap(null)` method as described earlier in the chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图层后，您必须使用`setMap(map)`方法设置地图，以便在地图上显示图层。如果您想从地图中移除图层，必须使用前面章节中描述的`setMap(null)`方法。
- en: Remember that Google Maps JavaScript API v3 does not have any function to clear
    all layers or overlays like in v2\. All the responsibility to handle the layer
    states is on your shoulders. In practice, the Google Maps JavaScript API documentation
    suggests you hold all layers in an array and manage your own add/remove functions
    via the `setMap()` method. As we did in the `clearMap()` function, we check if
    a layer is defined. If it is, we remove it; otherwise we do nothing, so that we
    do not get an error.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Google Maps JavaScript API v3没有像v2那样的清除所有图层或覆盖物的功能。处理图层状态的所有责任都在您的肩上。在实际应用中，Google
    Maps JavaScript API文档建议您将所有图层保存在一个数组中，并通过`setMap()`方法自行管理添加/移除函数。正如我们在`clearMap()`函数中所做的那样，我们检查图层是否已定义。如果是，我们将其移除；如果不是，我们不做任何事情，这样我们就不会得到错误。
- en: See also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。Google Maps JavaScript API基础知识")的*在自定义DIV元素中创建简单地图*配方中，*Google
    Maps JavaScript API基础知识*
- en: Adding GeoJSON to the Google Maps JavaScript API
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GeoJSON添加到Google Maps JavaScript API
- en: XML is the first hero of services in the Web 2.0 zone. With the help of XML,
    services or machines can easily communicate between them. XML can also be readable
    by humans. But after browser evolution, JSON has become much more popular due
    to its native readability for JavaScript and its lightweight compared to XML.
    GeoJSON is a form of JSON that includes collections of simple features such as
    points, polylines, or polygons. GeoJSON is not a standard of OGC, but it is a
    new de facto standard used by most GIS software or services.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: XML是Web 2.0区域中服务的第一个英雄。借助XML的帮助，服务或机器可以轻松地相互通信。XML也可以被人类阅读。但是，随着浏览器的演变，JSON由于其JavaScript的原生可读性和与XML相比的轻量级，变得更加流行。GeoJSON是一种包含简单特征集合的JSON形式，如点、折线或多边形。GeoJSON不是OGC的标准，但它是一种被大多数GIS软件或服务使用的新事实标准。
- en: The Google Maps JavaScript API does not support GeoJSON natively, but GeoJSON
    support will be added with a few lines of coding or with some additional libraries.
    With coding, we will go through the JSON format and read the coordinates one by
    one. Then, we will show the feature on the map according to its type, which can
    be point, polyline, or polygon.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API本身不支持GeoJSON，但可以通过几行代码或使用一些额外的库来添加GeoJSON支持。通过编码，我们将遍历JSON格式并逐个读取坐标。然后，我们将根据其类型（可以是点、折线或多边形）在地图上显示特征。
- en: In this recipe, we will read GeoJSON from a local file via the jQuery functions
    and show them on the map. This GeoJSON file is composed of a simplified version
    of the **Ankara** province border, a sample river, and some POIs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过jQuery函数从本地文件读取GeoJSON，并在地图上显示它们。这个GeoJSON文件由安卡拉省边界的简化版本、一条示例河流和一些POI组成。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the simple map recipe introduced in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在[第1章](ch01.html "第1章。Google Maps JavaScript API基础")中介绍的简单地图菜谱作为模板。
- en: You can find the source code at `Chapter 3/ch03_adding_geojson.html`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Chapter 3/ch03_adding_geojson.html`找到源代码。
- en: How to do it…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'If you perform the following steps, you can add your GeoJSON files to your
    map:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行以下步骤，你可以将你的GeoJSON文件添加到你的地图中：
- en: First, start by copying the contents of `ch01_simple_map.html` to our new HTML
    file.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`ch01_simple_map.html`的内容复制到我们新的HTML文件中。
- en: Next, we will add a jQuery JavaScript library to make it easy to access local
    or remote GeoJSON files. In this recipe, we will add the library from Google CDN.
    This block will be added in the `<head>` section before the Google Maps JavaScript
    API.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个jQuery JavaScript库，以便轻松访问本地或远程的GeoJSON文件。在这个菜谱中，我们将从Google CDN添加库。这个代码块将添加在`<head>`部分，在Google
    Maps JavaScript API之前。
- en: '[PRE56]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, add the following `drawGeometry()` function after defining the global
    `map` variable. This function draws each geometry read from the GeoJSON file.
    We have three types of geometries, so we will switch blocks for each type:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在定义全局`map`变量后添加以下`drawGeometry()`函数。这个函数绘制从GeoJSON文件中读取的每个几何形状。我们有三种类型的几何形状，所以我们将为每种类型添加代码块：
- en: '[PRE57]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, add the following `if` block in the new function. This block will add
    geometry if its type is `Point`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新的函数中添加以下`if`块。这个块将在几何形状的类型为`Point`时添加几何形状：
- en: '[PRE58]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, the `if` block is for `LineString` that shows polylines on the map:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`if`块用于显示地图上的`LineString`折线：
- en: '[PRE59]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, the `if` block is used for showing the polygons as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`if`块显示多边形如下：
- en: '[PRE60]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, add the following function to read the GeoJSON file and iterate over
    the geometries:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下函数来读取GeoJSON文件并遍历几何形状：
- en: '[PRE61]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, call the `parseGeoJSON()` function at the end of the `initMap()` function:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`initMap()`函数的末尾调用`parseGeoJSON()`函数：
- en: '[PRE62]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. You will see three different types of geometries on the map
    with their styles as follows:![How to do it…](img/8825OT_03_11.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储HTML文件的本地URL，查看结果。您将在地图上看到三种不同类型的几何形状及其样式如下：![如何操作…](img/8825OT_03_11.jpg)
- en: Thus, we have successfully added our GeoJSON files to the map with multiple
    types of geometries.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功地将包含多种几何形状的GeoJSON文件添加到地图中。
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'GeoJSON is a vector format that we described earlier. It is a form of JSON.
    The GeoJSON format can consist of different types of the same file as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON是我们之前描述的矢量格式。它是一种JSON形式。GeoJSON格式可以由同一文件中的不同类型组成，如下所示：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The sample GeoJSON is taken from the [www.geojson.org](http://www.geojson.org)
    site. As seen from the code, it is composed of point, polyline, and polygons in
    the same file separated by the `feature` keywords. Each `feature` has JavaScript
    objects named `geometry` and `properties`. The `geometry` part stores the geometry
    of the object and the `properties` part stores the related information. The `geometry`
    part is based on the geographic coordinate reference system using WGS84 Datum
    as default, and the coordinates are in longitudes and latitudes of decimal degrees
    until it is defined in the `crs` object. The `type` object stores the type of
    geometry such as `Point`, `Polyline`, or `Polygon`. The `coordinates` array is
    the actual part that stores the array of point coordinates. The order of coordinates
    in GeoJSON is different from the Google Maps JavaScript API in terms of its longitudes
    and latitudes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从[www.geojson.org](http://www.geojson.org)网站获取的示例GeoJSON。从代码中可以看出，它由同一文件中的点、折线和多边形组成，这些元素通过`feature`关键字分隔。每个`feature`都有一个名为`geometry`和`properties`的JavaScript对象。`geometry`部分存储对象的几何形状，而`properties`部分存储相关联的信息。`geometry`部分基于使用WGS84基准的地理坐标参考系统，默认情况下坐标以十进制度数表示，直到在`crs`对象中定义。`type`对象存储几何形状的类型，如`Point`、`Polyline`或`Polygon`。`coordinates`数组是实际存储点坐标数组的部分。GeoJSON中坐标的顺序与Google
    Maps JavaScript API在经纬度方面不同。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More about GeoJSON**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多关于 GeoJSON**'
- en: More details can be obtained from GeoJSON's unofficial site ([http://www.geojson.org](http://www.geojson.org)).
    There are also some tools to view or edit the GeoJSON without any coding. GitHub
    ([http://www.github.com](http://www.github.com)) can easily display your GeoJSON
    files on the map. The [http://www.geojson.io](http://www.geojson.io) site is also
    a tool from MapBox that displays and edits your GeoJSON files on browsers without
    the need for any software or coding. Please check these sites to understand GeoJSON
    in detail.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息可以从 GeoJSON 的非官方网站 ([http://www.geojson.org](http://www.geojson.org))
    获取。还有一些工具可以查看或编辑 GeoJSON 而无需任何编码。GitHub ([http://www.github.com](http://www.github.com))
    可以轻松地在地图上显示您的 GeoJSON 文件。[http://www.geojson.io](http://www.geojson.io) 网站也是 MapBox
    的一个工具，可以在浏览器上显示和编辑您的 GeoJSON 文件，无需任何软件或编码。请检查这些网站以详细了解 GeoJSON。
- en: In this recipe, we will read the local GeoJSON file with the help of the jQuery
    method, `getJSON()`. jQuery is used in order to focus on coding for the Google
    Maps JavaScript API. Otherwise, we will have to deal with remote file reading
    on multiple browser platforms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将借助 jQuery 的 `getJSON()` 方法读取本地 GeoJSON 文件。使用 jQuery 是为了专注于 Google
    Maps JavaScript API 的编码。否则，我们将在多个浏览器平台上处理远程文件读取。
- en: 'This method gets the contents of the `geojson.js` local file and puts them
    in the `data` variable. Then, we will iterate over the GeoJSON features with the
    jQuery method, `each()`. Finally, we get each feature''s `geometry` part and send
    it to the `drawGeometry()` function, which will be examined later:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取 `geojson.js` 本地文件的内容，并将它们放入 `data` 变量中。然后，我们将使用 jQuery 的 `each()` 方法遍历
    GeoJSON 特征。最后，我们获取每个特征的 `geometry` 部分，并将其发送到稍后将要检查的 `drawGeometry()` 函数：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The code written in the `drawGeometry()` function may seem complex, but it is
    not because we will use all the code written for adding markers, lines, and polygons
    in this chapter. This function first checks for the type of geometry, then prepares
    the appropriate options and coordinate(s) for the point, polyline, or polygon.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawGeometry()` 函数中编写的代码可能看起来很复杂，但这并不是因为我们将使用本章中为添加标记、线条和多边形编写的所有代码。此函数首先检查几何类型，然后为点、折线或多边形准备适当的选项和坐标。
- en: In polylines or polygons, there is a need to iterate over the `coordinates`
    array of the `geometry` field to create a path or paths for the `PolylineOptions`
    or `PolygonOptions` classes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在折线或多边形中，需要遍历 `geometry` 字段的 `coordinates` 数组，以创建 `PolylineOptions` 或 `PolygonOptions`
    类的路径或路径。
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this recipe, we will process GeoJSON with our functions and these functions
    can't draw all kinds of GeoJSON geometries. We are only dealing with the simple
    ones to show you how to deal with GeoJSON on your own. If you need to do a more
    complex GeoJSON process, there are two ways. One way is to read the full specification
    of GeoJSON and add it to your functions. The other way, which is also easy, is
    to use a library that is dedicated to this job. There is a library named **GeoJSON
    to Google Maps** written by *Jason Sanford* on GitHub ([https://github.com/JasonSanford/geojson-google-maps](https://github.com/JasonSanford/geojson-google-maps)).
    With the help of this library, you do not need to deal with GeoJSON specs. You
    can just add geometries with your own styles.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用我们的函数处理 GeoJSON，这些函数不能绘制所有类型的 GeoJSON 几何形状。我们只处理简单的形状，以向您展示如何自己处理
    GeoJSON。如果您需要进行更复杂的 GeoJSON 处理，有两种方法。一种方法是通过阅读 GeoJSON 的完整规范并将其添加到您的函数中。另一种方法，也很简单，是使用一个专门为此目的编写的库。有一个名为
    **GeoJSON to Google Maps** 的库，由 *Jason Sanford* 在 GitHub ([https://github.com/JasonSanford/geojson-google-maps](https://github.com/JasonSanford/geojson-google-maps))
    上编写。借助这个库，您无需处理 GeoJSON 规范。您只需使用自己的样式添加几何形状即可。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。Google Maps JavaScript API 基础") *Google Maps JavaScript
    API 基础* 中，*在自定义 DIV 元素中创建简单地图* 的配方
- en: The *Adding markers to maps* recipe
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加标记到地图* 的配方'
- en: The *Adding lines to maps* recipe
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加线条到地图* 的配方'
- en: The *Adding polygons to maps* recipe
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将多边形添加到地图* 的配方'
- en: The *Adding WKT to the Google Maps JavaScript API* recipe
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 WKT 添加到 Google Maps JavaScript API* 的配方'
- en: Adding WKT to the Google Maps JavaScript API
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 WKT 添加到 Google Maps JavaScript API
- en: '**Well-known Text** (**WKT**) is a text markup language for representing vector
    geometry objects on the map according to Wikipedia. This format was originally
    defined by the **Open Geospatial Consortium** (**OGC**), which is also a standard.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**已知文本**（**WKT**）是根据维基百科，在地图上表示矢量几何对象的一种文本标记语言。此格式最初由**开放地理空间联盟**（**OGC**）定义，它也是一个标准。'
- en: Apart from XML or JSON, WKT is a defined text format that only defines geometries
    without properties compared to GeoJSON. It was an old and outdated format, but
    there are still software or services supporting this format. There are 18 distinct
    geometric objects that represent Earth features, but simple ones are observed
    in this recipe.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 除了XML或JSON之外，WKT是一种定义的文本格式，它只定义几何形状而不定义属性，与GeoJSON相比。这是一个过时且陈旧的格式，但仍有软件或服务支持此格式。有18种不同的几何对象代表地球特征，但在这个菜谱中只观察到简单的几何形状。
- en: The Google Maps JavaScript API does not support WKT natively, but WKT support
    will be added with a few lines of coding or with some additional libraries. With
    coding, we will go through the WKT format, split them into arrays, and read the
    coordinates one by one. Then, we will show the feature on the map according to
    its type, which can be point, polyline, or polygon.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps JavaScript API本身不支持WKT，但可以通过几行代码或使用一些额外的库来添加WKT支持。通过编码，我们将遍历WKT格式，将它们拆分为数组，并逐个读取坐标。然后，我们将根据其类型（可以是点、多段线或多边形）在地图上显示特征。
- en: In this recipe, we will read a WKT from a local file via jQuery functions and
    show them on the map. The WKT geometries are within JSON attributes to make iteration
    easy. This WKT file is composed of a simplified version of the **Ankara** province
    border, a sample river, and some POIs.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过jQuery函数从本地文件中读取WKT，并在地图上显示它们。WKT几何形状位于JSON属性中，以便于迭代。此WKT文件由**安卡拉**省边界的一个简化版本、一条示例河流和一些POI组成。
- en: Getting ready
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the simple map recipe introduced in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*,
    as a template.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用在[第1章](ch01.html "第1章。Google Maps JavaScript API基础")中介绍的简单地图菜谱作为模板。
- en: You can find the source code at `Chapter 3/ch03_adding_wkt.html`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Chapter 3/ch03_adding_wkt.html`中找到源代码。
- en: How to do it…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You can easily add your WKT geometries to the map after performing the following
    steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下步骤后，您可以轻松地将WKT几何形状添加到地图中：
- en: First, start by copying the contents of `ch01_simple_map.html` to our new HTML
    file.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`ch01_simple_map.html`的内容复制到我们的新HTML文件中。
- en: 'Next, we will add a jQuery JavaScript library to make it easy to access local
    or remote JSON files with WKT geometries. In this recipe, we will add the library
    from Google CDN. This block will be added in the `<head>` section before the Google
    Maps JavaScript API:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个jQuery JavaScript库，以便轻松访问带有WKT几何形状的本地或远程JSON文件。在这个菜谱中，我们将从Google
    CDN添加库。此代码块将在Google Maps JavaScript API之前的`<head>`部分添加：
- en: '[PRE66]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, add the following `drawGeometry()` function after defining the global
    `map` variable. This function draws each WKT geometry read from the JSON file.
    We have three types of geometries, so we will switch blocks for each type:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在定义全局`map`变量之后添加以下`drawGeometry()`函数。此函数绘制从JSON文件中读取的每个WKT几何形状。我们有三种类型的几何形状，因此我们将为每种类型切换代码块：
- en: '[PRE67]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, add the following `if` block in the new function. This block will add
    the geometry if its type is `POINT`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在新的函数中添加以下`if`代码块。此代码块将在几何形状的类型为`POINT`时添加几何形状：
- en: '[PRE68]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, add the `if` block for `LINESTRING` that shows polylines on the map:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加用于在地图上显示多段线的`if`代码块`LINESTRING`：
- en: '[PRE69]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, the `if` block is used for showing the polygons as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下方式使用`if`代码块显示多边形：
- en: '[PRE70]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, add the following function to read the JSON file and iterate over the
    WKT geometries:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下函数以读取JSON文件并遍历WKT几何形状：
- en: '[PRE71]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, call the `parseWKT()` function at the end of the `initMap()` function:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`initMap()`函数的末尾调用`parseWKT()`函数：
- en: '[PRE72]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Go to your local URL where your HTML file is stored in your favorite browser
    and see the result. You will see three different types of geometries on the map
    with their styles, as shown in the following screenshot:![How to do it…](img/8825OT_03_12.jpg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您在最喜欢的浏览器中存储HTML文件的本地URL，查看结果。您将在地图上看到三种不同类型的几何形状及其样式，如下面的截图所示：![如何操作…](img/8825OT_03_12.jpg)
- en: This is how we add WKT geometries to the map with multiple types of geometries.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将多种类型的几何形状添加到地图中的方法。
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'WKT is a vector format that we defined earlier, which is different from GeoJSON.
    GeoJSON defines both the geometry and properties of Earth features, but WKT is
    only used for defining the geometry. Simple types of WKT examples are shown in
    the following table:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: WKT是我们之前定义的矢量格式，与GeoJSON不同。GeoJSON定义了地球特征的几何和属性，但WKT仅用于定义几何。以下表格展示了WKT的简单类型示例：
- en: '| Geometry type | WKT example |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 几何类型 | WKT示例 |'
- en: '| --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| POINT | POINT(31.541742 40.730608) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| POINT | POINT(31.541742 40.730608) |'
- en: '| POLYLINE | LINESTRING(35.24414 41.742627, 34.859619 41.586688, 34.7717285
    41.508577, 34.832153 41.364441) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| POLYLINE | LINESTRING(35.24414 41.742627, 34.859619 41.586688, 34.7717285
    41.508577, 34.832153 41.364441) |'
- en: '| POLYGON | POLYGON((33.759299 38.779907, 33.73552 38.758208, 33.73187 38.748987,
    33.703537 38.723535, 33.677514 33.800384 38.876017, 33.783532 38.842548, 33.759299
    38.779907)) |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| POLYGON | POLYGON((33.759299 38.779907, 33.73552 38.758208, 33.73187 38.748987,
    33.703537 38.723535, 33.677514 33.800384 38.876017, 33.783532 38.842548, 33.759299
    38.779907)) |'
- en: WKT geometries are exactly the same as used in the *Adding GeoJSON to Google
    Maps JavaScript API* recipe, but they are formatted in WKT geometries. WKT geometries
    are not alone due to their text format. So we put them in a JSON file with the
    `geom` attribute. This is used for easy parsing. If you have different types of
    formats that include WKT geometries, you should parse them with JavaScript.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: WKT几何与在*将GeoJSON添加到Google Maps JavaScript API*配方中使用的几何完全相同，但它们是以WKT几何格式进行格式化的。由于它们的文本格式，WKT几何并不是孤立的。因此，我们将它们放入一个带有`geom`属性的JSON文件中。这样做是为了便于解析。如果你有包含WKT几何的不同类型的格式，你应该用JavaScript解析它们。
- en: 'First, we will read the JSON file to get the WKT geometries. We will read the
    local JSON file with the help of the jQuery method, `getJSON()`. jQuery is used
    for focusing on the Google Maps JavaScript API instead of writing and fixing JavaScript
    code for each browser. Otherwise, we will have to deal with a remote file reading
    on multiple browser platforms. This method gets the contents of the `wkt.js` local
    file and puts them in the `data` variable. Then, we will iterate over the JSON
    objects with a jQuery method, `each()`. Finally, we get each object''s `geom`
    part and send it to the `drawGeometry()` function, which will be examined later:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将读取JSON文件以获取WKT几何。我们将使用jQuery方法`getJSON()`读取本地JSON文件。jQuery用于专注于Google
    Maps JavaScript API，而不是为每个浏览器编写和修复JavaScript代码。否则，我们将在多个浏览器平台上处理远程文件读取。此方法获取`wkt.js`本地文件的内容，并将它们放入`data`变量中。然后，我们将使用jQuery方法`each()`遍历JSON对象。最后，我们获取每个对象的`geom`部分，并将其发送到稍后将要讨论的`drawGeometry()`函数：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Parsing of WKT is much harder than GeoJSON because we need to deal with text
    parsing. With the `drawGeometry()` function, we will split the WKT text into smaller
    arrays and make them significant. Before parsing each type, we need to get the
    type of their geometry. Since they have no separate attribute for defining the
    type, we need to extract the type from the WKT text. As seen from the examples,
    the type is separated with the `(` character from the coordinates. If we slice
    string from the `(` character, the first array element is the type of geometry.
    This is done as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: WKT的解析比GeoJSON要困难得多，因为我们需要处理文本解析。使用`drawGeometry()`函数，我们将WKT文本分割成更小的数组并使它们变得有意义。在解析每种类型之前，我们需要获取它们的几何类型。由于它们没有单独的属性来定义类型，我们需要从WKT文本中提取类型。从示例中可以看出，类型是用`(`字符与坐标分开的。如果我们从`(`字符开始切片字符串，第一个数组元素就是几何类型的类型。这是按照以下方式完成的：
- en: '[PRE74]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The contents of `geomType` can be `POINT`, `LINESTRING`, or `POLYGON`. Then,
    we will check each type of geometry in different blocks. Let's go through each
    geometry type starting with point.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`geomType`的内容可以是`POINT`、`LINESTRING`或`POLYGON`。然后，我们将检查不同块中的每种几何类型。让我们从点类型开始逐一介绍每种几何类型。'
- en: 'Point is the simplest WKT geometry to parse with JavaScript. First, we get
    the second element of the `slice` array and slice it from the `)` character to
    only get the coordinates separated by a comma. Then, we will split the result
    text by a comma into an array. This array has only one element, so we will easily
    access the coordinates. To access the coordinates, we must slice the final text
    with the space character. This final array contains the latitude and longitude.
    The Google Maps JavaScript API uses latitude and longitude in order to define
    a point, but WKT uses longitude and latitude order to define a point. As described
    in the *Adding GeoJSON to Google Maps JavaScript API* recipe, the order of coordinates
    is also the same for WKT, which is in the reverse order of the Google Maps JavaScript
    API as longitudes and latitudes:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 点是使用JavaScript解析的最简单的WKT几何形状。首先，我们获取`slice`数组的第二个元素，并从`)`字符开始切片，只获取由逗号分隔的坐标。然后，我们将结果文本按逗号分割成一个数组。这个数组只有一个元素，因此我们可以轻松访问坐标。要访问坐标，我们必须使用空格字符切片最终文本。这个最终数组包含纬度和经度。Google
    Maps JavaScript API使用纬度和经度来定义一个点，但WKT使用经度和纬度的顺序来定义一个点。如*将GeoJSON添加到Google Maps
    JavaScript API*菜谱中所述，坐标的顺序对于WKT也是相同的，它是与Google Maps JavaScript API相反的顺序，即经度和纬度：
- en: '[PRE75]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The second type is the polyline that is defined as `LINESTRING` in WKT. Parsing
    polylines is much more complex than points. First, we get the arrays of coordinates
    by splitting `)` and comma as described earlier. Then, we will iterate in this
    array to get each coordinate. Before splitting the text with a space, we must
    check if there is a space at the beginning of the text. If there is a space, we
    will get the rest of the text to get only numbers for valid latitudes and longitudes.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型是WKT中定义为`LINESTRING`的折线。解析折线比解析点要复杂得多。首先，我们通过分割`)`和逗号来获取坐标数组，如前所述。然后，我们将在这个数组中迭代以获取每个坐标。在用空格分割文本之前，我们必须检查文本开头是否有空格。如果有空格，我们将获取文本的其余部分以获取有效的纬度和经度的数字。
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The last, simple type is polygon that is also defined as `POLYGON` in WKT.
    Parsing polygon is very similar to parsing polylines, except that the polygon
    definition has two parentheses, which is one more than polylines. We will get
    the third element of the array instead of the second, because WKT can contain
    multiple polygon geometries so in this case we have only one. If you have multiple
    geometries then you should iterate over the geometries. The only difference is
    written as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，简单类型是多边形，在WKT中也定义为`POLYGON`。解析多边形与解析折线非常相似，除了多边形定义有两个括号，比折线多一个。我们将获取数组的第三个元素而不是第二个，因为WKT可以包含多个多边形几何形状，所以在这种情况下我们只有一个。如果您有多个几何形状，那么您应该遍历这些几何形状。唯一的区别如下：
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The code blocks written in the `drawGeometry()` function may seem complex, but
    they are not because we will use all the codes written for adding markers, lines,
    and polygons in this chapter. The result of this recipe is exactly the same as
    the *Adding GeoJSON to* the *Google Maps JavaScript API* recipe, which is the
    expected result. We do not imagine we will get different outputs on changing the
    vector formats.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawGeometry()`函数中编写的代码块可能看起来很复杂，但它们并不复杂，因为我们将在本章中使用为添加标记、线和多边形编写的所有代码。这个菜谱的结果与*将GeoJSON添加到*Google
    Maps JavaScript API的菜谱完全相同，这是预期的结果。我们并不想象在改变矢量格式时我们会得到不同的输出。
- en: In this recipe, we will process WKT with our own functions, and these functions
    can't draw all kinds of WKT geometries defined in its standard. We are only dealing
    with the simple ones to show you how to deal with WKT on your own. If you need
    to do more complex WKT geometries, then there are two ways. One way is to read
    the full specification of WKT and add them to your functions. The other, easier
    way is to use a library that is dedicated for this job. There is a library named
    **Wicket** written by *K. Arthur Endsley* on GitHub ([https://github.com/arthur-e/Wicket](https://github.com/arthur-e/Wicket)).
    With the help of this library, you do not need to deal with WKT specs. You can
    just add geometries with your own styles.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用我们自己的函数处理WKT，而这些函数无法绘制其标准中定义的所有WKT几何形状。我们只处理简单的几何形状，以向您展示如何自行处理WKT。如果您需要处理更复杂的WKT几何形状，那么有两种方法。一种方法是通过阅读WKT的完整规范并将其添加到您的函数中。另一种，更简单的方法是使用为此工作而专门编写的库。有一个名为**Wicket**的库，由*K.
    Arthur Endsley*在GitHub上编写([https://github.com/arthur-e/Wicket](https://github.com/arthur-e/Wicket))。借助这个库，您无需处理WKT规范。您只需添加具有您自己风格的几何形状即可。
- en: See also
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a simple map in a custom DIV element* recipe in [Chapter 1](ch01.html
    "Chapter 1. Google Maps JavaScript API Basics"), *Google Maps JavaScript API Basics*
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。Google Maps JavaScript API 基础") 的 *在自定义 DIV 元素中创建简单地图*
    配方，*Google Maps JavaScript API 基础*
- en: The *Adding markers to maps* recipe
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加 *标记* 的配方
- en: The *Adding lines to maps* recipe
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加 *线条* 的配方
- en: The *Adding polygons to maps* recipe
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向地图添加 *多边形* 的配方
- en: The *Adding GeoJSON to* the *Google Maps JavaScript API* recipe
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *GeoJSON 添加到* *Google Maps JavaScript API* 的配方
