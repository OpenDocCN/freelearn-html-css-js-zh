- en: Chapter 11. Alternative View Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 替代视图组件
- en: The Flux documentation doesn't have a whole lot to say about view components.
    And yet, views are an essential part of any Flux architecture. Perhaps what the
    Flux authors really mean is that Flux doesn't really care about the mechanisms
    used to render our views—just as long as they're rendered somehow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Flux文档并没有太多关于视图组件的说明。然而，视图是任何Flux架构中不可或缺的一部分。也许Flux的作者真正想要表达的是，Flux并不真正关心我们渲染视图所使用的机制——只要它们以某种方式被渲染即可。
- en: It's no secret that Flux was designed with React in mind. Facebook had already
    built React for their view components—Flux was the missing piece that allows them
    to formulate a full-fledged, frontend architecture. We'll start this chapter off
    with a discussion on what makes React such a good fit for Flux architectures.
    Then we'll weigh these benefits against the downsides of React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人会不知道Flux是为了与React配合而设计的。Facebook已经为他们的视图组件构建了React——Flux是缺失的那一块，使得他们能够构建一个完整的、前端架构。我们将从讨论是什么让React如此适合Flux架构开始这一章。然后，我们将权衡这些好处与React的缺点。
- en: Next, we'll spend some time building views using jQuery and the Handlebars template
    engine. These are two popular technologies that have likely crossed the path of
    any given developer at some point. We'll then close the chapter by thinking about
    views that don't require specific rendering technology, allowing us to be nimble
    about our views and adopt the new hotness when it arrives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将花一些时间使用jQuery和Handlebars模板引擎构建视图。这些是两个可能在任何开发者的职业生涯中某个时刻都曾接触过的流行技术。然后，我们将通过思考那些不需要特定渲染技术的视图来结束这一章，这样我们就可以灵活地处理视图，并在新热点到来时采用它。
- en: ReactJS is a good fit for Flux
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS非常适合Flux
- en: It's no surprise that React is a good fit for Flux architectures. Both technologies
    were created by the same company, and they both solve complimentary problems.
    In this section, we'll dive into some of the details of what it is about React
    that makes it work so well with Flux. We'll start by looking at the unidirectional
    flows found in both Flux and React. Next, we'll discuss the idea that re-rendering
    DOM structures is easier than manipulating specific DOM nodes, and why this is
    a good fit for store change event handlers. Finally, we'll talk about the relatively
    small code footprint of React components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React适合Flux架构并不令人惊讶。这两种技术都是由同一家公司创造的，并且它们都解决了互补的问题。在本节中，我们将深入了解React与Flux配合得如此之好的原因。我们将从查看Flux和React中都存在的单向流开始。接下来，我们将讨论重新渲染DOM结构比操作特定的DOM节点更容易，以及为什么这对存储更改事件处理器来说是一个很好的选择。最后，我们将讨论React组件相对较小的代码占用。
- en: ReactJS is unidirectional
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReactJS是单向的
- en: The data-flow in a Flux architecture is unidirectional. It starts with an action
    and ends with view updates—there's no other way for data to get into a view component.
    React itself shares this same unidirectional philosophy with Flux. Data flows
    into a root React component and trickles down into any components used to compose
    the root. This process is recursive down the component hierarchy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux架构中，数据流是单向的。它从动作开始，以视图更新结束——数据进入视图组件没有其他方式。React本身也与Flux共享相同的单向哲学。数据流入根React组件，并逐渐流入用于组成根组件的任何组件。这个过程在组件层次结构中是递归的。
- en: 'Data flows into Flux stores through actions, and flows out as change events.
    React components keep this unidirectional flow going. Once the React component
    has re-rendered itself based on the store state, the flow is done. The only option
    is to start all over again by dispatching a new action. The flow between Flux
    and React components is illustrated here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过动作流入Flux存储，并以更改事件的形式流出。React组件保持这种单向流。一旦React组件根据存储状态重新渲染自己，流程就结束了。唯一的选择是重新开始，通过派发一个新的动作。Flux和React组件之间的流程在此处展示：
- en: '![ReactJS is unidirectional](img/B05419_11_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![ReactJS是单向的](img/B05419_11_01.jpg)'
- en: The first three items in our data flow are Flux entities. Any given data flow
    is kicked off when an action is dispatched. The action itself then enters the
    dispatcher and is sent to every store. Then the store makes any state changes
    as appropriate. From here, the data-flow is handed off to the React component.
    This is where we've specified the structure of the markup we want to render, using
    JSX. The component then consults with the virtual DOM to figure out what changes,
    if any, should be made in the actual DOM. Once these changes are made, the end
    of the data-flow has been reached.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据流的前三项是Flux实体。每当一个动作被分发时，就会启动一个给定的数据流。然后，该动作本身进入分发器，并发送到每个存储。然后存储根据需要做出任何状态更改。从这里，数据流被传递给React组件。这是我们指定要渲染的标记结构的结构，使用JSX。组件随后与虚拟DOM协商，以确定是否需要在实际DOM中进行任何更改。一旦这些更改完成，数据流就达到了终点。
- en: The flow that we've outlined here for React components wouldn't look any different
    even if they weren't part of a Flux architecture. The Flux components just add
    predictable state changes in a synchronous way, before handing the data off to
    components for rendering. Without Flux, React would still need to start from the
    top and pass data down so that the re-rendering process can start. This fits nicely
    with the change events that are emitted by the Flux stores.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为React组件概述的流程，即使它们不是Flux架构的一部分，看起来也不会有任何不同。Flux组件只是以同步方式添加可预测的状态更改，然后在将数据传递给组件进行渲染之前。没有Flux，React仍然需要从顶部开始传递数据，以便重新渲染过程可以开始。这与Flux存储发出的更改事件非常契合。
- en: What doesn't fit so well with React is the idea of two-way data binding. Some
    people love the idea and have found ways to make it work with React, but I digress.
    For two-way binding to be effective, our view components need to be in close proximity
    to mutable data. Then, the view can listen directly to this data in order to re-render
    itself. We're not setup to handle this with Flux architectures, let alone React.
    The idea that we can directly mutate the state of something without first entering
    a work-flow that manages the synchronous update of application-wide state, goes
    against every idea of Flux. Put simply, Flux architectures favor unidirectional
    data-flows with predictable outcomes and React helps with this mission.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与React不太匹配的是双向数据绑定的概念。有些人喜欢这个想法，并找到了使其与React一起工作的方法，但我在这里跑题了。为了使双向绑定有效，我们的视图组件需要与可变数据紧密相邻。然后，视图可以直接监听这些数据以重新渲染自身。我们并没有设置好使用Flux架构来处理这种情况，更不用说React了。我们可以直接修改某个状态，而不必首先进入一个管理应用程序全局状态同步更新的工作流程，这与Flux的每个想法都相悖。简单来说，Flux架构倾向于具有可预测结果的单向数据流，而React有助于完成这一使命。
- en: Re-rendering new data is easy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新渲染新数据很容易
- en: One thing about ReactJS that really stands out is it's ability to re-render
    entire DOM trees. Well, any JavaScript code can replace an existing DOM tree by
    building it again. React uses what's called a virtual DOM to compare the existing
    elements that the user is currently looking at, against the new elements that
    we've just rendered. Instead of replacing the entire tree, React will only touch
    the DOM in places where the two trees differ. Aside from the heuristics React
    has built into it, the fundamental performance edge comes from the fact that the
    virtual DOM is in JavaScript memory—we don't have to query the real DOM for elements.
    It's querying the DOM that can have negative performance implications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ReactJS的一个真正突出之处在于它重新渲染整个DOM树的能力。嗯，任何JavaScript代码都可以通过重新构建来替换现有的DOM树。React使用所谓的虚拟DOM来比较用户当前正在查看的现有元素，以及我们刚刚渲染的新元素。React不会替换整个树，而只会触及两个树不同的DOM位置。除了React内置的启发式方法外，基本性能优势来自于虚拟DOM位于JavaScript内存中——我们不需要查询真实DOM中的元素。查询DOM可能会产生负面的性能影响。
- en: To get around these performance issues, our view code can issue specific queries
    that are efficient to run, and only fetch the exact elements we need. Our view
    code can also cache the specific elements that it needs. The problem with this
    approach is that it feels fragmented once we have more than a few view components.
    It's difficult for components to share code when they're all tailored for their
    own specific performance requirements, and this is highly dependent on the DOM
    structure of the component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些性能问题，我们的视图代码可以发出特定的查询，这些查询运行效率高，并且只获取我们需要的精确元素。我们的视图代码还可以缓存它需要的特定元素。这种方法的缺点是，一旦我们有了超过几个视图组件，就会感觉零散。当组件都针对它们自己的特定性能要求定制时，它们很难共享代码，而且这高度依赖于组件的DOM结构。
- en: It's more natural for programmers to be able to say *here's a snapshot of what
    these view elements should look like at this point in time*. We shouldn't have
    to pick apart the DOM structure and say that this `div` should look like this
    while this `span` should be hidden and so on. This is why JSX works; we can more
    easily visualize what the output of our component is going to look like, because
    it's structured like the elements are structured.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，能够说出“这里是一个快照，展示了这些视图元素在这个时间点应该看起来是什么样子”更为自然。我们不应该需要拆解DOM结构，并说这个`div`应该看起来像这样，而那个`span`应该隐藏，等等。这就是为什么JSX起作用的原因；我们可以更容易地可视化我们组件的输出将是什么样子，因为它结构化得就像元素的结构一样。
- en: Small code footprint
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型代码占用
- en: React components generally have less code than view components that have lots
    of imperative DOM manipulation code. React doesn't have this type of code because
    it just needs to express the structure of the DOM through JSX. However, without
    Flux as the architecture, an application that uses React will probably find that
    the React components contain much more data transformation code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有大量命令式DOM操作代码的视图组件相比，React组件通常包含更少的代码。React没有这种类型的代码，因为它只需要通过JSX表达DOM的结构。然而，如果没有Flux作为架构，使用React的应用程序可能会发现React组件包含更多的数据转换代码。
- en: For example, when React components are mounted into the DOM, we might need to
    perform some kind of transformation on data that comes from some source, perhaps
    an AJAX response. With Flux, the source is always the state of the store, so we
    know that the data transforms have already happened by the time they're handed
    off to the React views. Remember, it's the views that drive the structure of our
    store state, not the stores that drive how our views must be structured.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当React组件挂载到DOM中时，我们可能需要对来自某些来源的数据进行某种转换，可能是AJAX响应。有了Flux，来源始终是存储的状态，因此我们知道数据转换已经在它们传递给React视图之前发生了。记住，是视图驱动我们的存储状态的结构，而不是存储驱动视图的结构。
- en: Event-handling code is another area where React components can have a small
    code footprint. Well, there's really two dimensions to this. First, event handlers
    in React are declared right in the JSX, so they're as much a part of the DOM tree
    structure as any other element properties—there's no need to insert the elements
    into the DOM and then look them up again later so we can attach an event handler
    function to them. The second dimension isn't actually specific to React, but more
    of a Flux phenomenon. The event handlers themselves are usually just action creator
    functions. All the logic that would have been in our views is now part of our
    stores.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理代码是另一个React组件可以具有小型代码占用的领域。好吧，这里实际上有两个维度。首先，React中的事件处理程序直接在JSX中声明，因此它们就像DOM树结构中的任何其他元素属性一样——不需要将元素插入DOM，然后在稍后查找它们，以便我们可以将事件处理函数附加到它们上。第二个维度实际上并不特定于React，而更多的是Flux现象。事件处理程序本身通常是动作创建函数。我们视图中的所有逻辑现在都是我们存储的一部分。
- en: The downsides of ReactJS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS的缺点
- en: Now that you have a good handle on the benefits of using ReactJS as the view
    layer in a Flux architecture, it's time to look at some of the downsides. Everything
    has negative tradeoffs—there's no such thing as a perfect technology. So these
    things are worth considering in the context of a Flux architecture for your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地掌握了在Flux架构中使用ReactJS作为视图层的优点，是时候看看一些缺点了。任何事物都有其负面权衡——没有完美技术的存在。因此，在应用Flux架构的背景下，这些因素是值得考虑的。
- en: First, we'll consider memory consumption. React is a fairly big library and
    has a noticeable impact on application load time. However, this is of minor concern
    compared to the amount of memory consumed by the virtual DOM. Next, we'll look
    at introducing JSX syntax into our JavaScript modules and the problems that might
    introduce for those not accustomed to blending other languages into their JavaScript
    modules.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑内存消耗。React是一个相当大的库，对应用程序加载时间有明显的影響。然而，与虚拟DOM消耗的内存量相比，这只是一个次要问题。接下来，我们将探讨将JSX语法引入我们的JavaScript模块，以及这可能会给那些不习惯将其他语言混合到他们的JavaScript模块中的人带来的问题。
- en: Virtual DOM and memory
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟DOM和内存
- en: JavaScript applications should strive to be as memory-efficient as possible.
    Those that don't feel bloated and unresponsive to the user. Applications that
    use a lot of memory are inherently slower than those that use less memory because
    they need to perform more work. For example, if we need to look something up in
    a collection, it's obviously going to take more compute resources if the collection
    has a ton of objects in it, as opposed to a collection that's much smaller. Another
    place this can hurt application performance is during garbage collection. This
    is less of an issue if we have huge collections that are allocated and never freed
    (possibly due to other problems like leaks). But the more common behavior is to
    allocate large amounts of memory in response to a user action, then to deallocate
    that memory when the user moves on. This behavior will trigger frequent garbage
    collection runs, which translates to pauses in responsiveness.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序应尽可能追求内存效率。那些感觉臃肿且对用户不响应的应用程序。使用大量内存的应用程序本质上比使用较少内存的应用程序慢，因为它们需要执行更多的工作。例如，如果我们需要在集合中查找某个东西，如果集合中有大量对象，那么显然需要更多的计算资源，而不是一个对象数量小得多的集合。这种做法还会在垃圾回收期间损害应用程序性能。如果我们有大量分配后从未释放（可能由于其他问题如泄漏）的集合，那么这就不成问题了。但更常见的行为是，在用户操作时分配大量内存，然后在用户继续操作时释放该内存。这种行为将触发频繁的垃圾回收运行，这会导致响应性暂停。
- en: 'The architecture of React requires more memory than alternative approaches
    to memory. This is due to the virtual DOM that React maintains. This in-memory
    structure is meant to reflect the structure of the real DOM. It doesn''t track
    every single piece of data about every element that the real DOM has. It only
    tracks the data that''s necessary to compute diffs. Here''s an illustration of
    the mapping between our component, the virtual DOM, and the real DOM:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React的架构比其他内存处理方法需要更多的内存。这是由于React维护的虚拟DOM。这个内存结构旨在反映真实DOM的结构。它不跟踪真实DOM中每个元素的每一份数据。它只跟踪计算diff所必需的数据。以下是我们组件、虚拟DOM和真实DOM之间映射的示意图：
- en: '![Virtual DOM and memory](img/B05419_11_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟DOM和内存](img/B05419_11_02.jpg)'
- en: The elements in our React component aren't necessarily occupying much memory,
    because they're just the declarative part of the component that specify which
    elements to use and which property values they should have. The virtual DOM reflects
    the structure and properties as specified in our JSX; these elements actually
    do occupy memory. Finally, we have the real DOM elements that the user sees and
    interacts with. These occupy a significant amount of memory too.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们React组件中的元素不一定占用很多内存，因为它们只是组件的声明部分，指定了要使用哪些元素以及它们应该具有哪些属性值。虚拟DOM反映了我们在JSX中指定的结构和属性；这些元素实际上确实占用了内存。最后，我们有用户看到并与之交互的真实DOM元素。这些也占用了相当大的内存。
- en: The main challenge with this approach is that we're doubling-up on anything
    that's rendered in the DOM. Put another way, the virtual DOM adds to the total
    memory consumed by our DOM elements out of necessity. Without the virtual DOM,
    React and JSX is just another template engine. The virtual DOM solves performance
    issues in other places. The main area where React excels performance-wise is efficient
    DOM API interactions, because the virtual DOM eliminates the need for many of
    these calls.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要挑战是我们对DOM中渲染的任何内容都进行了重复。换句话说，虚拟DOM出于必要增加了我们的DOM元素消耗的总内存。没有虚拟DOM，React和JSX只是另一个模板引擎。虚拟DOM解决了其他地方的性能问题。React在性能方面表现优异的主要领域是高效的DOM
    API交互，因为虚拟DOM消除了许多这些调用的需要。
- en: Is the memory consumed by your typical React application a showstopper? Absolutely
    not. Memory is quickly becoming a commodity, even in the mobile space. So if we
    can allocate more memory to solve real performance issues, we should by all means
    do so. However, there are cases where excessive memory allocation can become a
    problem with React applications. For instance, what if we simply need to render
    lots of elements? When and if this becomes a performance issue, your best bet
    is to probably design for fewer elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: JSX and markup
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX is essentially HTML (well, XML technically) mixed in with JavaScript code.
    If your initial response to this approach wasn't favorable, you're not alone.
    Over a long period of time, decades actually, we've been conditioned to separate
    our concerns. Something like HTML should never be in the same module as the JavaScript
    logic that controls when and how that markup is displayed. If we've been living
    through the separation-of-concerns principle for so many years, it's only natural
    to balk at the notion of combining to concerns into a single module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: It's quite possible that the last project you worked on involved specifying
    markup in template files. These templates are then fed into the view layer for
    rendering. Coming to Flux from this setting might be a little too much to take
    in all at once. On one hand, we have a whole new unidirectional data-flow to think
    about. On the other hand, we're talking about throwing out everything we've worked
    so hard to build into separate layers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Let's not forget the fact that the separation of concerns principle does serve
    a purpose. If two concerns are implemented in two different places, there's less
    chance that a change in one concern will impact the other. Think of having templates
    as a way to compartmentalize the visual aspect of any given component. We can,
    in theory at least, give the design team free reign over the templates and not
    have to worry about them breaking the JavaScript implementation of the component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve learned anything so far in this book, it''s probably that there''s
    a lot more to the complexities of UI components than the sum of their parts. Flux
    tries to acknowledge these complexities by explicitly modeling them in stores.
    There''s a strict ordering and synchronicity to updating the UI in Flux for a
    reason: predictability despite all the complexity involved. What does this have
    to do with JSX, you might ask? Well, before discounting it as something that violates
    the separation of concerns principle, think about how well it fits with Flux stores.
    Also consider the idea that markup and the logic that renders it might be the
    same concern after all.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Vendor lock-in
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever heard someone say something along the lines of *I'm using library
    x because I don't want to be locked into library y?* Vendor lock-in is a tricky
    area to navigate. Although these days, where most projects rely on open source
    projects, it's more like *technology approach lock-in*. I would be remiss if I
    didn't at least mention the subject here with regard to Flux and React.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾听到有人这么说：“我正在使用库x，因为我不想被锁定在库y中？”供应商锁定是一个棘手的问题领域。尽管如今，大多数项目都依赖于开源项目，这更像是一种*技术方法锁定*。如果我不在这里至少提及与Flux和React相关的话题，那将是一个疏忽。
- en: Once we start using React and JSX, we've pretty much rolled the dice. It's a
    safe bet for more reasons than it's an unsafe one. Nonetheless, we've started
    down a path that's very difficult to get off, which is essentially the point of
    these past three sections. Even if your mind is 95% made up on choosing React,
    you'll sleep better at night knowing that you've weighed the tradeoffs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始使用React和JSX，我们基本上就下了赌注。这不仅仅是因为它是一个安全的赌注。尽管如此，我们已经走上了一条非常难以摆脱的道路，这正是过去三个部分的核心观点。即使你的心中95%已经决定选择React，知道你已经权衡了利弊，你也会睡得更香。
- en: Using jQuery and Handlebars
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery和Handlebars
- en: Both jQuery and Handlebars are pervasive technologies in modern web applications.
    There's a high probability that someone new to Flux has used one or both of these
    technologies, so we'll spend this section implementing some views that use both
    jQuery and Handlebars.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery和Handlebars是现代Web应用中普遍使用的两种技术。对于新接触Flux的人来说，有很大概率他们已经使用过其中一种或两种技术，因此我们将在这个部分实现一些使用jQuery和Handlebars的视图。
- en: We'll start with a discussion on what makes jQuery and Handlebars a good fit
    for implementing view components. Then, we'll implement a basic view that uses
    these technologies to render the state of Flux stores. After this, we'll think
    about the various ways that we can compose larger views out of smaller parts and
    how to best handle user events.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论jQuery和Handlebars为何适合实现视图组件开始。然后，我们将实现一个使用这些技术来渲染Flux存储状态的视图。之后，我们将思考如何从更小的部分组合更大的视图，以及如何最好地处理用户事件。
- en: Why jQuery and Handlebars?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么是jQuery和Handlebars？
- en: Before there were JavaScript frameworks, there was jQuery. This small library
    set out to solve cross-browser issues prevalent in frontend development, and in
    general to make development more pleasant. Today, jQuery is still a dominant player
    in the JavaScript library game. Many larger frameworks depend on jQuery, because
    it's so effective and the barrier to learn how it works is so low.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript框架出现之前，jQuery就已经存在。这个小库旨在解决前端开发中普遍存在的跨浏览器问题，总的来说是为了让开发更加愉快。如今，jQuery在JavaScript库领域仍然是一个主导者。许多大型框架都依赖于jQuery，因为它非常有效，而且学习它的工作原理的门槛很低。
- en: One thing that jQuery isn't so great at is specifying the layout of UI components
    using HTML. For example, we can use jQuery to construct new elements and insert
    them into the DOM on the fly. However, something about this approach feels cumbersome
    and unnatural. It's often clearer to be able to write the HTML using the same
    structure as it would appear on the page. This removes a layer of indirection
    and makes it easier for us to map the markup to the rendered output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery不太擅长的一件事是使用HTML指定UI组件的布局。例如，我们可以使用jQuery动态构建新元素并将它们插入DOM。然而，这种方法的某些方面感觉笨拙且不自然。通常，能够使用与页面显示相同的结构来编写HTML会更清晰。这消除了间接层，使我们更容易将标记映射到渲染输出。
- en: Enter Handlebars. This library adds a sophisticated template engine to our frontend.
    Writing Handlebars templates means that we can write HTML, along with some specific
    Handlebars syntax for the dynamic bits, and avoid the mess of trying to assemble
    elements using jQuery. Both libraries are complimentary to one another. We have
    Handlebars templates that declare the structure of our application, and we use
    the Handlebars rendering engine to render this structure. Then, jQuery can handle
    every other aspect of the view components, such as selecting DOM elements and
    handling events. Let's see how this looks in the context of a Flux architecture
    by implementing a view that renders a Handlebars template.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 Handlebars。这个库为我们前端添加了一个复杂的模板引擎。编写 Handlebars 模板意味着我们可以编写 HTML，以及一些特定的 Handlebars
    语法用于动态部分，并避免使用 jQuery 尝试组装元素的混乱。这两个库是互补的。我们有 Handlebars 模板来声明我们应用程序的结构，我们使用 Handlebars
    渲染引擎来渲染这个结构。然后，jQuery 可以处理视图组件的各个方面，例如选择 DOM 元素和处理事件。让我们看看在 Flux 架构的上下文中这看起来是什么样子，通过实现一个渲染
    Handlebars 模板的视图：
- en: Rendering templates
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染模板
- en: 'Let''s start by covering the most basic usage scenario—rendering a Handlebars
    template into a DOM element using jQuery. Let''s first start by looking at the
    Handlebars template file itself:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的使用场景开始——使用 jQuery 将 Handlebars 模板渲染到 DOM 元素中。首先，让我们看看 Handlebars 模板文件本身：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, this is essentially basic HTML with a bit of specialized Handlebars
    syntax mixed in for the dynamic parts. This template is stored inside of a `.hbs`
    file (short for *handlebars*—some people use the full `.handlebars` extension).
    We can update our Webpack configuration to add the Handlebars loader. This parses
    and compiles the `.hbs` templates for us, meaning that our code that uses these
    templates can import them just like regular JavaScript modules. Let''s take a
    look at what this looks like in our view component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这基本上是基本的 HTML，其中混合了一些用于动态部分的特定 Handlebars 语法。这个模板存储在一个 `.hbs` 文件中（代表 *handlebars*——有些人使用完整的
    `.handlebars` 扩展名）。我们可以更新我们的 Webpack 配置以添加 Handlebars 加载器。这个加载器会解析和编译 `.hbs` 模板，这意味着使用这些模板的代码可以像导入常规
    JavaScript 模块一样导入它们。让我们看看在我们的视图组件中这看起来是什么样子：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `template()` function that this view module imports is created as the result
    of the Webpack plugin compiling the template into a function for us. The runtime
    for Handlebars is included as part of the bundle that Webpack creates. The `render()`
    method of our view component calls the `template()` function, passing it a context
    and using the return value as the new content for the view's element. The context
    is just the state of the store, and each time the store state changes, the `html()`
    jQuery function is used to replace the existing element content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图模块导入的 `template()` 函数是作为 Webpack 插件编译模板为我们创建的函数的结果。Handlebars 的运行时作为 Webpack
    创建的包的一部分包含在内。我们的视图组件的 `render()` 方法调用 `template()` 函数，传递一个上下文，并使用返回值作为视图元素的新的内容。上下文只是存储的状态，每次存储状态改变时，`html()`
    jQuery 函数都会用来替换现有的元素内容。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fundamental difference between ReactJS and an approach such as this one
    that uses the Handlebars templating engine, is that React attempts to make small
    updates. With Handlebars, we could end up replacing a lot of DOM content, and
    the performance issues could become noticeable by users. To combat these sorts
    of problems, we have to change the way our application is composed. This in and
    of itself could put us at a disadvantage compared to using something like React
    where we can re-render large DOM structures and still be efficient.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS 与像 Handlebars 模板引擎这样的方法之间的基本区别在于，React 尝试进行小范围的更新。使用 Handlebars，我们可能会替换大量的
    DOM 内容，性能问题可能会对用户变得明显。为了解决这类问题，我们必须改变我们应用程序的构建方式。这本身可能会让我们在使用像 React 这样的工具时处于不利地位，因为我们可以重新渲染大量的
    DOM 结构，同时仍然保持效率。
- en: 'Now, let''s take a look at the store that drives the content of this view:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看驱动这个视图内容的存储：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a fairly typical store—not unlike most stores that we''ve seen so far
    in this book. The payload that''s dispatched as part of the `MY_ACTION` action
    is used to extend the state of the store and will override existing property names,
    if any. Let''s take a look at the main program now:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当典型的存储——与我们在本书中看到的大多数存储没有太大区别。作为 `MY_ACTION` 动作一部分发送的有效负载用于扩展存储的状态，如果有的话，将覆盖现有的属性名称。现在让我们看看主程序：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is where we initialize the instance of our view component, passing it a
    jQuery instance. This jQuery object represents the `#app` element, and is used
    by the view to hold the rendered Handlebars template content. After a one second
    delay, we call `myAction()`, which causes the `myStore` state to change and the
    handlebars template to re-render.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们初始化视图组件实例的地方，传递给它一个 jQuery 实例。这个 jQuery 对象代表 `#app` 元素，并由视图用来持有渲染的 Handlebars
    模板内容。在一秒延迟后，我们调用 `myAction()`，这会导致 `myStore` 状态改变，并且 Handlebars 模板重新渲染。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generally, what happens when our Handlebars templates start getting bigger,
    we'll start adding specialized handlers that only respond to specific store properties.
    The reason is that the properties change too frequently and they only impact a
    tiny section of the visible UI. These micro-handlers then proliferate, and we
    start to lose predictability because we're introducing more paths into the rendering
    code. With ReactJS, this is less likely to happen, because we seldom have to decompose
    our view updates like this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们的 Handlebars 模板开始变大时，我们会开始添加专门的处理程序，它们只对特定的存储属性做出响应。原因是属性变化得太频繁，它们只影响可见
    UI 的一小部分。然后这些微处理程序就会扩散，我们开始失去可预测性，因为我们正在向渲染代码中引入更多的路径。在 ReactJS 中，这种情况不太可能发生，因为我们很少需要像这样分解视图更新。
- en: Composing views
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组成视图
- en: If we're using Handlebars templates as the main ingredient of our view components,
    we probably need the ability to decompose our templates into smaller chunks. Think
    about the way we decompose our React components—we end up with smaller components
    that can usually be shared across features. Using Handlebars templates, we can
    achieve something similar using partial templates. The partial is a smaller part
    that fits into a larger whole to form the template that gets rendered by the view
    component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 Handlebars 模板作为视图组件的主要成分，我们可能需要能够将我们的模板分解成更小的块。想想我们分解 React 组件的方式——我们最终得到更小的组件，这些组件通常可以在功能之间共享。使用
    Handlebars 模板，我们可以通过使用部分模板实现类似的效果。部分是一个较小的部分，它适合于更大的整体，以形成由视图组件渲染的模板。
- en: 'Let''s start by looking at a Handlebars template that serves as the list view
    for a store that has an array of user data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个作为具有用户数据数组的存储库的列表视图的 Handlebars 模板开始。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This template is iterating over the `users` property of our store, which is
    an array. However, instead of directly rendering each item, it''s simply referring
    to a partial template using special syntax. Let''s look at this partial template
    now, so we can get a sense of what''s being passed to it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板正在遍历我们的存储库的 `users` 属性，它是一个数组。然而，它并没有直接渲染每个项目，而是简单地使用特殊语法引用一个部分模板。现在让我们看看这个部分模板，这样我们就可以了解传递给它的是什么：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this template, we don''t have to qualify the properties that are used in
    this case: `first` and `last`. The context in the parent template is passed to
    the partial template, in this case the user object. So it''s kind of like passing
    in props to a child React component from a parent component. Once again, however,
    the difference is that every Handlebars component we use to compose the structure
    of the DOM elements is re-rendered as there''s no virtual DOM to speak of. Let''s
    look at the store that was used to populate this view with data:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们不需要对在这种情况下使用的属性进行限定：`first` 和 `last`。父模板中的上下文传递给部分模板，在这个例子中是用户对象。所以这有点像从父组件向子
    React 组件传递 props。然而，再次强调，区别在于我们使用的每个 Handlebars 组件来组合 DOM 元素的结构的组件都会重新渲染，因为没有虚拟
    DOM。让我们看看用来填充这个视图数据的存储库：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And finally, the main program. Here, we''ll setup an interval timer that keeps
    dispatching the `REVERSE` action. This causes the whole UI to re-render with every
    dispatch:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主程序。在这里，我们将设置一个间隔计时器，不断分发 `REVERSE` 动作。这会导致整个 UI 在每次分发时重新渲染：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Generally speaking, Flux architectures should have as few stores as possible.
    However, if we're using Handlebars in the view layer, we might be influenced to
    design our stores differently. For example, we might want to split the collective
    application state in such a way that results in less DOM structure being re-inserted
    into the document.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，Flux 架构应该尽可能少地使用存储库。然而，如果我们使用 Handlebars 在视图层，我们可能会受到影响而以不同的方式设计我们的存储库。例如，我们可能想要以这种方式分割整个应用程序状态，从而减少需要重新插入文档的
    DOM 结构。
- en: Handling events
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: Long before any modern web frameworks came into existence, jQuery was addressing
    cross-browser event-handling issues. Though the API has changed over the years,
    the powerful capabilities of jQuery's event handling remain intact. This is something
    that's obviously relevant if we're building views that are powered by jQuery and
    Handlebars.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何现代Web框架出现之前，jQuery就已经解决了跨浏览器事件处理问题。尽管API在多年中有所变化，但jQuery事件处理功能仍然强大。如果我们正在构建由jQuery和Handlebars驱动的视图，这显然是相关的。
- en: 'The most pressing challenge with event handling in this context is the fact
    that we''re re-rendering elements every time a Handlebars template needs updating.
    What we don''t want is to have to re-attach event handlers to DOM elements every
    time they''re inserted into the DOM. ReactJS utilizes a strategy that doesn''t
    actually bind event handlers directly to the element we want to listen to. Instead,
    the handler is bound to the `body` element and as events bubble up, the appropriate
    handler is invoked. It turns out that this approach has a performance advantage,
    because it avoids having to bind the same handler function to the same element,
    over and over. Here''s an illustration of the idea:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中处理事件的最紧迫的挑战是我们每次Handlebars模板需要更新时都会重新渲染元素。我们不希望每次将元素插入DOM时都要重新附加事件处理程序。ReactJS利用了一种策略，实际上并没有直接将事件处理程序绑定到我们想要监听的元素上。相反，处理程序绑定到`body`元素上，当事件冒泡时，调用适当的处理程序。事实证明，这种方法具有性能优势，因为它避免了需要反复将同一个处理程序函数绑定到同一个元素上。以下是这个想法的说明：
- en: '![Handling events](img/B05419_11_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![处理事件](img/B05419_11_03.jpg)'
- en: 'We can achieve something similar to this using jQuery. Let''s first look at
    the Handlebars template files so that we can get a feel for the type of UI we''re
    dealing with here. We''ll extend the preceding example by adding a reverse button
    and selection capabilities. Here''s the new item view template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用jQuery实现类似的效果。首先让我们看看Handlebars模板文件，这样我们就可以了解我们正在处理的UI类型。我们将通过添加反向按钮和选择功能来扩展前面的示例。以下是新的项目视图模板：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The item is now a link. Note that we''re able to use the `@index` Handlebars
    syntax, which allows access to the index of the current item in the collection
    we''re iterating over. Even though the iteration happens in another template,
    this special value is still accessible. Now let''s see what we have in the main
    list view Handlebars template:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目现在是一个链接。请注意，我们能够使用`@index` Handlebars语法，它允许访问我们正在迭代的集合中当前项的索引。即使迭代发生在另一个模板中，这个特殊值仍然可以访问。现在让我们看看主列表视图Handlebars模板中有什么：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ul` that builds the list is the same as it was previously. Now we have
    a new button to reverse the sort order of the list, instead of an interval timer.
    Let''s now take a look at the event handling capabilities of the view component:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构建列表的`ul`与之前相同。现在我们有一个新的按钮来反转列表的排序顺序，而不是一个间隔计时器。现在让我们看看视图组件的事件处理能力：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're following the pattern of React where the handler is never directly attached
    to something that's going to be re-rendered frequently. In fact, you can see that
    the event handlers are setup in the constructor of the view component, long before
    anything has ever been rendered by this view. This works because the `#app` element
    is already in place, and this is the element we're interested in.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循React的模式，其中处理程序永远不会直接绑定到经常需要重新渲染的东西上。实际上，你可以看到事件处理程序是在视图组件的构造函数中设置的，在视图渲染任何内容之前。这是因为`#app`元素已经就位，这是我们感兴趣的元素。
- en: 'The first handler is for the reverse button, and it uses the `reverse()` action
    creator function. It''s the second parameter to `on()` that provides the element
    context, so that we know this handler is for `button` elements. The same principle
    is applied with our second handler, which is called when the user clicks a link.
    Here, we''re simply preventing the default browser behavior and dispatching the
    `select` event. Now, let''s take a look at some of the changes we had to make
    to our store to support this new event behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个处理程序是为反向按钮，它使用`reverse()`动作创建函数。这是`on()`的第二个参数，它提供了元素上下文，因此我们知道这个处理程序是为`button`元素。同样的原则也应用于我们的第二个处理程序，当用户点击链接时被调用。在这里，我们只是阻止默认的浏览器行为并派发`select`事件。现在，让我们看看我们为了支持这种新的事件行为对存储所做的某些更改：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are two important changes here that are worth pointing out. The first
    change is that our `users` array now has a new `fontWeight` property for each
    item within it. This is necessary because it controls the display of our links
    to indicate that something has been selected. Everything defaults to `normal`
    since nothing has been selected yet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的更改值得指出。第一个更改是我们现在的`users`数组中的每个项目都有一个新的`fontWeight`属性。这是必要的，因为它控制着我们的链接的显示，以表明某些内容已被选中。由于尚未选择任何内容，所以一切默认为`normal`。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could put some code in our view component that looks for a `fontWeight` property,
    and when it can't find one, it defaults to normal. The problem with this tactic
    is that it introduces unnecessary logic into the view component. We're trying
    to keep everything in the store, even seemingly trivial things like this. Even
    if that means adding default values in a store that are also default in the browser.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在视图组件中放入一些代码，用于查找`fontWeight`属性，如果找不到，则默认为正常。这种策略的问题在于它向视图组件中引入了不必要的逻辑。我们试图将所有东西都保留在存储中，即使是看似微不足道的事情，比如这个。即使这意味着在存储中添加默认值，这些默认值在浏览器中也是默认的。
- en: The second change to the store is the addition of the `SELECT` handling logic.
    When this action is dispatched, we match up the item index with the payload index
    and change the font weight. Everything else that doesn't match gets reverted back
    to a normal `font-weight`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对存储的第二次更改是添加了`SELECT`处理逻辑。当这个动作被分发时，我们将项目索引与有效负载索引匹配，并更改字体粗细。所有不匹配的其他内容都会被重置为正常的`font-weight`。
- en: Using VanillaJS
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯JavaScript
- en: Not having enough diversity in the ecosystem of frontend JavaScript rendering
    libraries isn't a problem. In fact, the problem for us is the exact opposite—there's
    too many libraries and frameworks to choose from. While some people in the JavaScript
    community view this disjointed plethora of choice as a problem, it doesn't have
    to be. It's better to have too many technologies to choose from than not enough.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端JavaScript渲染库的生态系统中的多样性不足不是一个问题。事实上，对我们来说，问题正好相反——可供选择的库和框架太多了。虽然JavaScript社区中的一些人认为这种多样化的选择是一个问题，但这并不一定如此。有太多的技术可供选择，总比选择不足要好。
- en: In this section, we'll discuss using VanillaJS as our view technology—no libraries
    or frameworks. The idea isn't to completely avoid using frameworks, it's to keep
    our options open as the architecture of our application unfolds. Eventually, we
    might move our view components to use React, or perhaps there's some other new
    hotness we've been keeping our eye on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用纯JavaScript作为我们的视图技术——不使用任何库或框架。这个想法并不是要完全避免使用框架，而是要保持我们的选择多样化，随着我们应用程序架构的展开。最终，我们可能会将视图组件移动到使用React，或者也许有一些其他新潮的技术我们一直在关注。
- en: Keeping my options open
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持选择多样化
- en: At some point, we have to choose a technology to use with our view components.
    That depends on which stage of the project we're on. If it's early in the game
    and we've already decided on a view library, we could end up limiting ourselves
    to this technology for a long time. Given how fast JavaScript and it's surrounding
    ecosystem is moving, being stuck with any technology for a length of time usually
    isn't a good thing. We have to embrace the fact that change is constantly deprecating
    the thing that was once new hotness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，我们必须选择一种与我们的视图组件一起使用的技术。这取决于我们目前的项目处于哪个阶段。如果游戏还处于早期，并且我们已经决定使用一个视图库，我们可能会长时间限制自己使用这项技术。鉴于JavaScript及其周围生态系统的发展速度如此之快，长时间停留在任何技术上通常并不是一件好事。我们必须接受这样一个事实：变化不断使曾经的新潮事物变得过时。
- en: On the other hand, we don't want to wait too long to make a technology decision
    for our views, because the more things we build using plain JS, the more difficult
    it's going to be to migrate these views to a more opinionated approach. Where's
    the sweet-spot?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们不想等待太久才为我们的视图做出技术决策，因为使用纯JavaScript构建的东西越多，将这些视图迁移到更具意见导向的方法就越困难。那么，最佳平衡点在哪里呢？
- en: The best strategy is to avoid lock-in where possible. This involves keeping
    things loosely-coupled so that they're substitutable. Thankfully, Flux architectures
    make this easy because the responsibilities of the view layer are fairly limited.
    They need to listen to store change events and render the store state. Maybe we
    should try building two sets of view components. The first set uses a technology
    such as React, and the other uses something else, such as jQuery and Handlebars.
    This not only allows us to pick the view technology that works best for our product,
    but also lets us test our readiness to adopt new technologies, which we'll inevitably
    want to do.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的策略是在可能的情况下避免锁定。这涉及到保持事物松散耦合，以便它们可以互换。幸运的是，Flux架构使这变得容易，因为视图层的责任相当有限。它们需要监听存储更改事件并渲染存储状态。也许我们应该尝试构建两套视图组件。第一套使用像React这样的技术，另一套使用像jQuery和Handlebars这样的其他技术。这不仅允许我们选择最适合我们产品的视图技术，还让我们测试我们采用新技术的准备情况，这是我们不可避免地想要做的。
- en: Moving to React
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转向React
- en: As you saw in this chapter, we can use technologies like jQuery and Handlebars
    in the view components of our Flux architecture. What's more, they don't interfere
    with the unidirectional data-flow found in Flux architectures. That being said,
    React is probably the best suited view technology to use as part of a Flux architecture.
    From the perspective of unidirectional data-flow, React picks this up naturally.
    Even without Flux in place, stateless functional React components behave exactly
    how we would expect a view to behave in a Flux architecture. When new properties
    come in, new HTML is rendered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，我们可以在Flux架构的视图组件中使用像jQuery和Handlebars这样的技术。更重要的是，它们不会干扰Flux架构中发现的单向数据流。话虽如此，React可能是作为Flux架构一部分使用的最佳视图技术。从单向数据流的角度来看，React自然地吸收了这一点。即使没有Flux，无状态的函数式React组件也会表现得像我们在Flux架构中期望视图那样。当新的属性到来时，新的HTML就会被渲染。
- en: In addition to React's natural tendency toward unidirectional data-flow, the
    idea of re-rendering large DOM structures feels less daunting. Thanks to the virtual
    DOM that React uses to patch the rendered output—instead of replacing the entire
    thing—we can efficiently pass store state to top-level views for re-rendering.
    React also handles other edge cases for us too, such as maintaining the focus
    of a form control during a re-render.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React对单向数据流的自然倾向之外，重新渲染大型DOM结构的感觉也不那么令人畏惧。多亏了React用来修补渲染输出的虚拟DOM——而不是替换整个内容——我们可以高效地将存储状态传递给顶层视图以进行重新渲染。React还为我们处理其他边缘情况，例如在重新渲染期间保持表单控件的关注点。
- en: 'The real question is twofold: how inevitable is a move to React, and how salvageable
    is our existing code? Well, the first question is generally pretty easy to answer—there''s
    a high probability that you''re going to use React in your Flux architecture.
    It''s simply a good fit for a Flux architecture. However, it''s naive to assume
    that there are no negative tradeoffs, like higher memory consumption for example.
    So if we do decide to move to React after already having developed some view components,
    do we need to throw everything out? Unlikely. Views play a relatively small role
    in Flux architectures, as I''ve stressed throughout the book. So, if moving to
    React solves problems in your Flux view components, by all means do so—it''s a
    good direction to move in. For now.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是双重的：转向React的必然性有多强，以及我们现有的代码有多容易挽救？好吧，第一个问题通常很容易回答——你很可能会在你的Flux架构中使用React。它只是Flux架构的一个很好的匹配。然而，认为没有负面权衡是天真了，比如更高的内存消耗。所以，如果我们决定在已经开发了一些视图组件之后转向React，我们需要把所有东西都扔掉吗？不太可能。视图在Flux架构中扮演着相对较小的角色，正如我在整本书中强调的那样。所以，如果转向React解决了你的Flux视图组件中的问题，那就这么做吧——这是一个好的发展方向。目前是这样的。
- en: New hotness
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的热门技术
- en: A couple of years ago, React was brand new hotness. As with any new hotness,
    developers can and should approach the technology with some degree of skepticism.
    As it turned out, React was a good bet for many of it's early adopters. On the
    other hand, not all new and shiny technologies work out. This is how progress
    is made, and is why so much progress has been made in the JavaScript ecosystem.
    What's the point of this anecdote? There's always going to be new hotness that's
    superior to what you've already bet on. Be ready to adopt and re-adopt again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，React 还是一种全新的热门技术。就像任何新热门技术一样，开发者应该以一定程度的怀疑态度来接近这项技术。结果证明，React 对许多早期采用者来说是一个不错的选择。另一方面，并非所有新潮的技术都能成功。这就是进步的途径，也是为什么
    JavaScript 生态系统取得了如此多的进步。这个故事的要点是什么？总会出现一些比你已经下注的更好的新热门技术。准备好去采纳和再次采纳。
- en: For example, Google is currently implementing view technology called Incremental
    DOM ([http://google.github.io/incremental-dom/](http://google.github.io/incremental-dom/)),
    which takes a different approach to rendering that uses a lot less memory. There's
    `Veu.js` ([http://vuejs.org/](http://vuejs.org/)). There are endless other possibilities
    for the future. Just make sure that you are views can pivot and embrace the latest
    and greatest view technology—it'll be here soon.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，谷歌目前正在实施一种名为 Incremental DOM 的视图技术（[http://google.github.io/incremental-dom/](http://google.github.io/incremental-dom/)），它采用了一种不同的渲染方法，使用更少的内存。还有
    `Veu.js`（[http://vuejs.org/](http://vuejs.org/)）。未来还有无数其他可能性。只需确保你的视图可以转向并拥抱最新的最佳视图技术——它很快就会到来。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The focus of this chapter was on the view components of our Flux architecture
    and how they're loosely-coupled to the point that we can substitute rendering
    technologies. We started with a discussion on React itself and what makes it a
    good fit for Flux architectures. Then, we switched gears and covered the potential
    downsides of using ReactJS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是 Flux 架构中的视图组件以及它们如何松散耦合到可以替换渲染技术的程度。我们从一个关于 React 本身的讨论开始，讨论了它为什么适合 Flux
    架构。然后，我们转换了话题，讨论了使用 ReactJS 的潜在缺点。
- en: We spent some time implementing views that leveraged both jQuery and Handlebars.
    These are two mature technologies that many developers are familiar with and serve
    as a good jumping off point for implementing a Flux architecture. However, there
    are strong motivations for anyone implementing Flux to look at React as the view
    technology of choice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间实现了一些利用 jQuery 和 Handlebars 的视图。这些是许多开发者熟悉的成熟技术，可以作为实现 Flux 架构的良好起点。然而，对于任何实现
    Flux 的人来说，将 React 视为首选的视图技术有着强烈的动机。
- en: We wrapped the chapter up with a discussion on using VanillaJS to render our
    view components. There's no sense in rushing into using a particular technology
    until we understand the ramifications of that choice. There's always going to
    be newer and better view libraries, and Flux architectures make it easy to pivot
    and embrace new hotness.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以讨论使用 VanillaJS 渲染视图组件结束本章。在我们理解了选择该技术的后果之前，没有必要急于采用特定的技术。总会出现更新、更好的视图库，而
    Flux 架构使得转向和拥抱新热门技术变得容易。
