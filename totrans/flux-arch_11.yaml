- en: Chapter 11. Alternative View Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flux documentation doesn't have a whole lot to say about view components.
    And yet, views are an essential part of any Flux architecture. Perhaps what the
    Flux authors really mean is that Flux doesn't really care about the mechanisms
    used to render our views—just as long as they're rendered somehow.
  prefs: []
  type: TYPE_NORMAL
- en: It's no secret that Flux was designed with React in mind. Facebook had already
    built React for their view components—Flux was the missing piece that allows them
    to formulate a full-fledged, frontend architecture. We'll start this chapter off
    with a discussion on what makes React such a good fit for Flux architectures.
    Then we'll weigh these benefits against the downsides of React.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll spend some time building views using jQuery and the Handlebars template
    engine. These are two popular technologies that have likely crossed the path of
    any given developer at some point. We'll then close the chapter by thinking about
    views that don't require specific rendering technology, allowing us to be nimble
    about our views and adopt the new hotness when it arrives.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS is a good fit for Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's no surprise that React is a good fit for Flux architectures. Both technologies
    were created by the same company, and they both solve complimentary problems.
    In this section, we'll dive into some of the details of what it is about React
    that makes it work so well with Flux. We'll start by looking at the unidirectional
    flows found in both Flux and React. Next, we'll discuss the idea that re-rendering
    DOM structures is easier than manipulating specific DOM nodes, and why this is
    a good fit for store change event handlers. Finally, we'll talk about the relatively
    small code footprint of React components.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS is unidirectional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data-flow in a Flux architecture is unidirectional. It starts with an action
    and ends with view updates—there's no other way for data to get into a view component.
    React itself shares this same unidirectional philosophy with Flux. Data flows
    into a root React component and trickles down into any components used to compose
    the root. This process is recursive down the component hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data flows into Flux stores through actions, and flows out as change events.
    React components keep this unidirectional flow going. Once the React component
    has re-rendered itself based on the store state, the flow is done. The only option
    is to start all over again by dispatching a new action. The flow between Flux
    and React components is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ReactJS is unidirectional](img/B05419_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first three items in our data flow are Flux entities. Any given data flow
    is kicked off when an action is dispatched. The action itself then enters the
    dispatcher and is sent to every store. Then the store makes any state changes
    as appropriate. From here, the data-flow is handed off to the React component.
    This is where we've specified the structure of the markup we want to render, using
    JSX. The component then consults with the virtual DOM to figure out what changes,
    if any, should be made in the actual DOM. Once these changes are made, the end
    of the data-flow has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: The flow that we've outlined here for React components wouldn't look any different
    even if they weren't part of a Flux architecture. The Flux components just add
    predictable state changes in a synchronous way, before handing the data off to
    components for rendering. Without Flux, React would still need to start from the
    top and pass data down so that the re-rendering process can start. This fits nicely
    with the change events that are emitted by the Flux stores.
  prefs: []
  type: TYPE_NORMAL
- en: What doesn't fit so well with React is the idea of two-way data binding. Some
    people love the idea and have found ways to make it work with React, but I digress.
    For two-way binding to be effective, our view components need to be in close proximity
    to mutable data. Then, the view can listen directly to this data in order to re-render
    itself. We're not setup to handle this with Flux architectures, let alone React.
    The idea that we can directly mutate the state of something without first entering
    a work-flow that manages the synchronous update of application-wide state, goes
    against every idea of Flux. Put simply, Flux architectures favor unidirectional
    data-flows with predictable outcomes and React helps with this mission.
  prefs: []
  type: TYPE_NORMAL
- en: Re-rendering new data is easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing about ReactJS that really stands out is it's ability to re-render
    entire DOM trees. Well, any JavaScript code can replace an existing DOM tree by
    building it again. React uses what's called a virtual DOM to compare the existing
    elements that the user is currently looking at, against the new elements that
    we've just rendered. Instead of replacing the entire tree, React will only touch
    the DOM in places where the two trees differ. Aside from the heuristics React
    has built into it, the fundamental performance edge comes from the fact that the
    virtual DOM is in JavaScript memory—we don't have to query the real DOM for elements.
    It's querying the DOM that can have negative performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: To get around these performance issues, our view code can issue specific queries
    that are efficient to run, and only fetch the exact elements we need. Our view
    code can also cache the specific elements that it needs. The problem with this
    approach is that it feels fragmented once we have more than a few view components.
    It's difficult for components to share code when they're all tailored for their
    own specific performance requirements, and this is highly dependent on the DOM
    structure of the component.
  prefs: []
  type: TYPE_NORMAL
- en: It's more natural for programmers to be able to say *here's a snapshot of what
    these view elements should look like at this point in time*. We shouldn't have
    to pick apart the DOM structure and say that this `div` should look like this
    while this `span` should be hidden and so on. This is why JSX works; we can more
    easily visualize what the output of our component is going to look like, because
    it's structured like the elements are structured.
  prefs: []
  type: TYPE_NORMAL
- en: Small code footprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React components generally have less code than view components that have lots
    of imperative DOM manipulation code. React doesn't have this type of code because
    it just needs to express the structure of the DOM through JSX. However, without
    Flux as the architecture, an application that uses React will probably find that
    the React components contain much more data transformation code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when React components are mounted into the DOM, we might need to
    perform some kind of transformation on data that comes from some source, perhaps
    an AJAX response. With Flux, the source is always the state of the store, so we
    know that the data transforms have already happened by the time they're handed
    off to the React views. Remember, it's the views that drive the structure of our
    store state, not the stores that drive how our views must be structured.
  prefs: []
  type: TYPE_NORMAL
- en: Event-handling code is another area where React components can have a small
    code footprint. Well, there's really two dimensions to this. First, event handlers
    in React are declared right in the JSX, so they're as much a part of the DOM tree
    structure as any other element properties—there's no need to insert the elements
    into the DOM and then look them up again later so we can attach an event handler
    function to them. The second dimension isn't actually specific to React, but more
    of a Flux phenomenon. The event handlers themselves are usually just action creator
    functions. All the logic that would have been in our views is now part of our
    stores.
  prefs: []
  type: TYPE_NORMAL
- en: The downsides of ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a good handle on the benefits of using ReactJS as the view
    layer in a Flux architecture, it's time to look at some of the downsides. Everything
    has negative tradeoffs—there's no such thing as a perfect technology. So these
    things are worth considering in the context of a Flux architecture for your application.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll consider memory consumption. React is a fairly big library and
    has a noticeable impact on application load time. However, this is of minor concern
    compared to the amount of memory consumed by the virtual DOM. Next, we'll look
    at introducing JSX syntax into our JavaScript modules and the problems that might
    introduce for those not accustomed to blending other languages into their JavaScript
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM and memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript applications should strive to be as memory-efficient as possible.
    Those that don't feel bloated and unresponsive to the user. Applications that
    use a lot of memory are inherently slower than those that use less memory because
    they need to perform more work. For example, if we need to look something up in
    a collection, it's obviously going to take more compute resources if the collection
    has a ton of objects in it, as opposed to a collection that's much smaller. Another
    place this can hurt application performance is during garbage collection. This
    is less of an issue if we have huge collections that are allocated and never freed
    (possibly due to other problems like leaks). But the more common behavior is to
    allocate large amounts of memory in response to a user action, then to deallocate
    that memory when the user moves on. This behavior will trigger frequent garbage
    collection runs, which translates to pauses in responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of React requires more memory than alternative approaches
    to memory. This is due to the virtual DOM that React maintains. This in-memory
    structure is meant to reflect the structure of the real DOM. It doesn''t track
    every single piece of data about every element that the real DOM has. It only
    tracks the data that''s necessary to compute diffs. Here''s an illustration of
    the mapping between our component, the virtual DOM, and the real DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtual DOM and memory](img/B05419_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The elements in our React component aren't necessarily occupying much memory,
    because they're just the declarative part of the component that specify which
    elements to use and which property values they should have. The virtual DOM reflects
    the structure and properties as specified in our JSX; these elements actually
    do occupy memory. Finally, we have the real DOM elements that the user sees and
    interacts with. These occupy a significant amount of memory too.
  prefs: []
  type: TYPE_NORMAL
- en: The main challenge with this approach is that we're doubling-up on anything
    that's rendered in the DOM. Put another way, the virtual DOM adds to the total
    memory consumed by our DOM elements out of necessity. Without the virtual DOM,
    React and JSX is just another template engine. The virtual DOM solves performance
    issues in other places. The main area where React excels performance-wise is efficient
    DOM API interactions, because the virtual DOM eliminates the need for many of
    these calls.
  prefs: []
  type: TYPE_NORMAL
- en: Is the memory consumed by your typical React application a showstopper? Absolutely
    not. Memory is quickly becoming a commodity, even in the mobile space. So if we
    can allocate more memory to solve real performance issues, we should by all means
    do so. However, there are cases where excessive memory allocation can become a
    problem with React applications. For instance, what if we simply need to render
    lots of elements? When and if this becomes a performance issue, your best bet
    is to probably design for fewer elements.
  prefs: []
  type: TYPE_NORMAL
- en: JSX and markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX is essentially HTML (well, XML technically) mixed in with JavaScript code.
    If your initial response to this approach wasn't favorable, you're not alone.
    Over a long period of time, decades actually, we've been conditioned to separate
    our concerns. Something like HTML should never be in the same module as the JavaScript
    logic that controls when and how that markup is displayed. If we've been living
    through the separation-of-concerns principle for so many years, it's only natural
    to balk at the notion of combining to concerns into a single module.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite possible that the last project you worked on involved specifying
    markup in template files. These templates are then fed into the view layer for
    rendering. Coming to Flux from this setting might be a little too much to take
    in all at once. On one hand, we have a whole new unidirectional data-flow to think
    about. On the other hand, we're talking about throwing out everything we've worked
    so hard to build into separate layers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's not forget the fact that the separation of concerns principle does serve
    a purpose. If two concerns are implemented in two different places, there's less
    chance that a change in one concern will impact the other. Think of having templates
    as a way to compartmentalize the visual aspect of any given component. We can,
    in theory at least, give the design team free reign over the templates and not
    have to worry about them breaking the JavaScript implementation of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve learned anything so far in this book, it''s probably that there''s
    a lot more to the complexities of UI components than the sum of their parts. Flux
    tries to acknowledge these complexities by explicitly modeling them in stores.
    There''s a strict ordering and synchronicity to updating the UI in Flux for a
    reason: predictability despite all the complexity involved. What does this have
    to do with JSX, you might ask? Well, before discounting it as something that violates
    the separation of concerns principle, think about how well it fits with Flux stores.
    Also consider the idea that markup and the logic that renders it might be the
    same concern after all.'
  prefs: []
  type: TYPE_NORMAL
- en: Vendor lock-in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever heard someone say something along the lines of *I'm using library
    x because I don't want to be locked into library y?* Vendor lock-in is a tricky
    area to navigate. Although these days, where most projects rely on open source
    projects, it's more like *technology approach lock-in*. I would be remiss if I
    didn't at least mention the subject here with regard to Flux and React.
  prefs: []
  type: TYPE_NORMAL
- en: Once we start using React and JSX, we've pretty much rolled the dice. It's a
    safe bet for more reasons than it's an unsafe one. Nonetheless, we've started
    down a path that's very difficult to get off, which is essentially the point of
    these past three sections. Even if your mind is 95% made up on choosing React,
    you'll sleep better at night knowing that you've weighed the tradeoffs.
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery and Handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both jQuery and Handlebars are pervasive technologies in modern web applications.
    There's a high probability that someone new to Flux has used one or both of these
    technologies, so we'll spend this section implementing some views that use both
    jQuery and Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a discussion on what makes jQuery and Handlebars a good fit
    for implementing view components. Then, we'll implement a basic view that uses
    these technologies to render the state of Flux stores. After this, we'll think
    about the various ways that we can compose larger views out of smaller parts and
    how to best handle user events.
  prefs: []
  type: TYPE_NORMAL
- en: Why jQuery and Handlebars?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before there were JavaScript frameworks, there was jQuery. This small library
    set out to solve cross-browser issues prevalent in frontend development, and in
    general to make development more pleasant. Today, jQuery is still a dominant player
    in the JavaScript library game. Many larger frameworks depend on jQuery, because
    it's so effective and the barrier to learn how it works is so low.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that jQuery isn't so great at is specifying the layout of UI components
    using HTML. For example, we can use jQuery to construct new elements and insert
    them into the DOM on the fly. However, something about this approach feels cumbersome
    and unnatural. It's often clearer to be able to write the HTML using the same
    structure as it would appear on the page. This removes a layer of indirection
    and makes it easier for us to map the markup to the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Handlebars. This library adds a sophisticated template engine to our frontend.
    Writing Handlebars templates means that we can write HTML, along with some specific
    Handlebars syntax for the dynamic bits, and avoid the mess of trying to assemble
    elements using jQuery. Both libraries are complimentary to one another. We have
    Handlebars templates that declare the structure of our application, and we use
    the Handlebars rendering engine to render this structure. Then, jQuery can handle
    every other aspect of the view components, such as selecting DOM elements and
    handling events. Let's see how this looks in the context of a Flux architecture
    by implementing a view that renders a Handlebars template.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by covering the most basic usage scenario—rendering a Handlebars
    template into a DOM element using jQuery. Let''s first start by looking at the
    Handlebars template file itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is essentially basic HTML with a bit of specialized Handlebars
    syntax mixed in for the dynamic parts. This template is stored inside of a `.hbs`
    file (short for *handlebars*—some people use the full `.handlebars` extension).
    We can update our Webpack configuration to add the Handlebars loader. This parses
    and compiles the `.hbs` templates for us, meaning that our code that uses these
    templates can import them just like regular JavaScript modules. Let''s take a
    look at what this looks like in our view component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `template()` function that this view module imports is created as the result
    of the Webpack plugin compiling the template into a function for us. The runtime
    for Handlebars is included as part of the bundle that Webpack creates. The `render()`
    method of our view component calls the `template()` function, passing it a context
    and using the return value as the new content for the view's element. The context
    is just the state of the store, and each time the store state changes, the `html()`
    jQuery function is used to replace the existing element content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fundamental difference between ReactJS and an approach such as this one
    that uses the Handlebars templating engine, is that React attempts to make small
    updates. With Handlebars, we could end up replacing a lot of DOM content, and
    the performance issues could become noticeable by users. To combat these sorts
    of problems, we have to change the way our application is composed. This in and
    of itself could put us at a disadvantage compared to using something like React
    where we can re-render large DOM structures and still be efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the store that drives the content of this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fairly typical store—not unlike most stores that we''ve seen so far
    in this book. The payload that''s dispatched as part of the `MY_ACTION` action
    is used to extend the state of the store and will override existing property names,
    if any. Let''s take a look at the main program now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is where we initialize the instance of our view component, passing it a
    jQuery instance. This jQuery object represents the `#app` element, and is used
    by the view to hold the rendered Handlebars template content. After a one second
    delay, we call `myAction()`, which causes the `myStore` state to change and the
    handlebars template to re-render.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally, what happens when our Handlebars templates start getting bigger,
    we'll start adding specialized handlers that only respond to specific store properties.
    The reason is that the properties change too frequently and they only impact a
    tiny section of the visible UI. These micro-handlers then proliferate, and we
    start to lose predictability because we're introducing more paths into the rendering
    code. With ReactJS, this is less likely to happen, because we seldom have to decompose
    our view updates like this.
  prefs: []
  type: TYPE_NORMAL
- en: Composing views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we're using Handlebars templates as the main ingredient of our view components,
    we probably need the ability to decompose our templates into smaller chunks. Think
    about the way we decompose our React components—we end up with smaller components
    that can usually be shared across features. Using Handlebars templates, we can
    achieve something similar using partial templates. The partial is a smaller part
    that fits into a larger whole to form the template that gets rendered by the view
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at a Handlebars template that serves as the list view
    for a store that has an array of user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This template is iterating over the `users` property of our store, which is
    an array. However, instead of directly rendering each item, it''s simply referring
    to a partial template using special syntax. Let''s look at this partial template
    now, so we can get a sense of what''s being passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template, we don''t have to qualify the properties that are used in
    this case: `first` and `last`. The context in the parent template is passed to
    the partial template, in this case the user object. So it''s kind of like passing
    in props to a child React component from a parent component. Once again, however,
    the difference is that every Handlebars component we use to compose the structure
    of the DOM elements is re-rendered as there''s no virtual DOM to speak of. Let''s
    look at the store that was used to populate this view with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the main program. Here, we''ll setup an interval timer that keeps
    dispatching the `REVERSE` action. This causes the whole UI to re-render with every
    dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, Flux architectures should have as few stores as possible.
    However, if we're using Handlebars in the view layer, we might be influenced to
    design our stores differently. For example, we might want to split the collective
    application state in such a way that results in less DOM structure being re-inserted
    into the document.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Long before any modern web frameworks came into existence, jQuery was addressing
    cross-browser event-handling issues. Though the API has changed over the years,
    the powerful capabilities of jQuery's event handling remain intact. This is something
    that's obviously relevant if we're building views that are powered by jQuery and
    Handlebars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most pressing challenge with event handling in this context is the fact
    that we''re re-rendering elements every time a Handlebars template needs updating.
    What we don''t want is to have to re-attach event handlers to DOM elements every
    time they''re inserted into the DOM. ReactJS utilizes a strategy that doesn''t
    actually bind event handlers directly to the element we want to listen to. Instead,
    the handler is bound to the `body` element and as events bubble up, the appropriate
    handler is invoked. It turns out that this approach has a performance advantage,
    because it avoids having to bind the same handler function to the same element,
    over and over. Here''s an illustration of the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling events](img/B05419_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can achieve something similar to this using jQuery. Let''s first look at
    the Handlebars template files so that we can get a feel for the type of UI we''re
    dealing with here. We''ll extend the preceding example by adding a reverse button
    and selection capabilities. Here''s the new item view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The item is now a link. Note that we''re able to use the `@index` Handlebars
    syntax, which allows access to the index of the current item in the collection
    we''re iterating over. Even though the iteration happens in another template,
    this special value is still accessible. Now let''s see what we have in the main
    list view Handlebars template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ul` that builds the list is the same as it was previously. Now we have
    a new button to reverse the sort order of the list, instead of an interval timer.
    Let''s now take a look at the event handling capabilities of the view component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We're following the pattern of React where the handler is never directly attached
    to something that's going to be re-rendered frequently. In fact, you can see that
    the event handlers are setup in the constructor of the view component, long before
    anything has ever been rendered by this view. This works because the `#app` element
    is already in place, and this is the element we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first handler is for the reverse button, and it uses the `reverse()` action
    creator function. It''s the second parameter to `on()` that provides the element
    context, so that we know this handler is for `button` elements. The same principle
    is applied with our second handler, which is called when the user clicks a link.
    Here, we''re simply preventing the default browser behavior and dispatching the
    `select` event. Now, let''s take a look at some of the changes we had to make
    to our store to support this new event behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are two important changes here that are worth pointing out. The first
    change is that our `users` array now has a new `fontWeight` property for each
    item within it. This is necessary because it controls the display of our links
    to indicate that something has been selected. Everything defaults to `normal`
    since nothing has been selected yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could put some code in our view component that looks for a `fontWeight` property,
    and when it can't find one, it defaults to normal. The problem with this tactic
    is that it introduces unnecessary logic into the view component. We're trying
    to keep everything in the store, even seemingly trivial things like this. Even
    if that means adding default values in a store that are also default in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The second change to the store is the addition of the `SELECT` handling logic.
    When this action is dispatched, we match up the item index with the payload index
    and change the font weight. Everything else that doesn't match gets reverted back
    to a normal `font-weight`.
  prefs: []
  type: TYPE_NORMAL
- en: Using VanillaJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not having enough diversity in the ecosystem of frontend JavaScript rendering
    libraries isn't a problem. In fact, the problem for us is the exact opposite—there's
    too many libraries and frameworks to choose from. While some people in the JavaScript
    community view this disjointed plethora of choice as a problem, it doesn't have
    to be. It's better to have too many technologies to choose from than not enough.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll discuss using VanillaJS as our view technology—no libraries
    or frameworks. The idea isn't to completely avoid using frameworks, it's to keep
    our options open as the architecture of our application unfolds. Eventually, we
    might move our view components to use React, or perhaps there's some other new
    hotness we've been keeping our eye on.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping my options open
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At some point, we have to choose a technology to use with our view components.
    That depends on which stage of the project we're on. If it's early in the game
    and we've already decided on a view library, we could end up limiting ourselves
    to this technology for a long time. Given how fast JavaScript and it's surrounding
    ecosystem is moving, being stuck with any technology for a length of time usually
    isn't a good thing. We have to embrace the fact that change is constantly deprecating
    the thing that was once new hotness.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we don't want to wait too long to make a technology decision
    for our views, because the more things we build using plain JS, the more difficult
    it's going to be to migrate these views to a more opinionated approach. Where's
    the sweet-spot?
  prefs: []
  type: TYPE_NORMAL
- en: The best strategy is to avoid lock-in where possible. This involves keeping
    things loosely-coupled so that they're substitutable. Thankfully, Flux architectures
    make this easy because the responsibilities of the view layer are fairly limited.
    They need to listen to store change events and render the store state. Maybe we
    should try building two sets of view components. The first set uses a technology
    such as React, and the other uses something else, such as jQuery and Handlebars.
    This not only allows us to pick the view technology that works best for our product,
    but also lets us test our readiness to adopt new technologies, which we'll inevitably
    want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in this chapter, we can use technologies like jQuery and Handlebars
    in the view components of our Flux architecture. What's more, they don't interfere
    with the unidirectional data-flow found in Flux architectures. That being said,
    React is probably the best suited view technology to use as part of a Flux architecture.
    From the perspective of unidirectional data-flow, React picks this up naturally.
    Even without Flux in place, stateless functional React components behave exactly
    how we would expect a view to behave in a Flux architecture. When new properties
    come in, new HTML is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to React's natural tendency toward unidirectional data-flow, the
    idea of re-rendering large DOM structures feels less daunting. Thanks to the virtual
    DOM that React uses to patch the rendered output—instead of replacing the entire
    thing—we can efficiently pass store state to top-level views for re-rendering.
    React also handles other edge cases for us too, such as maintaining the focus
    of a form control during a re-render.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real question is twofold: how inevitable is a move to React, and how salvageable
    is our existing code? Well, the first question is generally pretty easy to answer—there''s
    a high probability that you''re going to use React in your Flux architecture.
    It''s simply a good fit for a Flux architecture. However, it''s naive to assume
    that there are no negative tradeoffs, like higher memory consumption for example.
    So if we do decide to move to React after already having developed some view components,
    do we need to throw everything out? Unlikely. Views play a relatively small role
    in Flux architectures, as I''ve stressed throughout the book. So, if moving to
    React solves problems in your Flux view components, by all means do so—it''s a
    good direction to move in. For now.'
  prefs: []
  type: TYPE_NORMAL
- en: New hotness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A couple of years ago, React was brand new hotness. As with any new hotness,
    developers can and should approach the technology with some degree of skepticism.
    As it turned out, React was a good bet for many of it's early adopters. On the
    other hand, not all new and shiny technologies work out. This is how progress
    is made, and is why so much progress has been made in the JavaScript ecosystem.
    What's the point of this anecdote? There's always going to be new hotness that's
    superior to what you've already bet on. Be ready to adopt and re-adopt again.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Google is currently implementing view technology called Incremental
    DOM ([http://google.github.io/incremental-dom/](http://google.github.io/incremental-dom/)),
    which takes a different approach to rendering that uses a lot less memory. There's
    `Veu.js` ([http://vuejs.org/](http://vuejs.org/)). There are endless other possibilities
    for the future. Just make sure that you are views can pivot and embrace the latest
    and greatest view technology—it'll be here soon.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter was on the view components of our Flux architecture
    and how they're loosely-coupled to the point that we can substitute rendering
    technologies. We started with a discussion on React itself and what makes it a
    good fit for Flux architectures. Then, we switched gears and covered the potential
    downsides of using ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: We spent some time implementing views that leveraged both jQuery and Handlebars.
    These are two mature technologies that many developers are familiar with and serve
    as a good jumping off point for implementing a Flux architecture. However, there
    are strong motivations for anyone implementing Flux to look at React as the view
    technology of choice.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped the chapter up with a discussion on using VanillaJS to render our
    view components. There's no sense in rushing into using a particular technology
    until we understand the ramifications of that choice. There's always going to
    be newer and better view libraries, and Flux architectures make it easy to pivot
    and embrace new hotness.
  prefs: []
  type: TYPE_NORMAL
