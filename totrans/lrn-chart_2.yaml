- en: Technology Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes that you have a working knowledge of HTML, CSS, and JavaScript,
    which are essential tools for creating visualizations with Chart.js. All examples
    in the book are written with JavaScript ES2015 or ES6\. One of the goals of this
    chapter is to review the fundamental topics of these technologies. This includes
    JavaScript topics related to string, object, and array manipulation, the HTML
    document object model (DOM), basic JQuery, CSS selectors, and HTML canvas. You
    can, of course, skip these sections if you already feel comfortable with these
    technologies.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also describes popular data formats used in visualizations, such
    as CSV, XML, and JSON, and how to load, parse, and use external data files in
    these formats in your Web pages. You will also learn how to set up a small testing
    Web server to run files that load external resources.
  prefs: []
  type: TYPE_NORMAL
- en: The final section contains some tips on how to obtain and prepare data for your
    visualizations, how to convert HTML data into standard formats, and how to extract
    selected information from HTML pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Essential JavaScript for Chart.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other technologies: DOM, CSS, JQuery, and Canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load and parse external data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract and transform data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential JavaScript for Chart.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side applications, such as interactive Web graphics, depend on browser
    support. This book assumes that your audience uses browsers that support HTML5
    Canvas and ES2015 (which include all modern browsers). All examples use ES2015
    syntax, including *const* and *let* instead of *var*, arrow functions where appropriate,
    spread operators, maps, sets, and promises. External files are loaded using the
    Fetch API, which has only been supported more recently, but you can easily switch
    to JQuery if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Although the creation of visualizations with Chart.js is mostly a declarative
    process, it is still a JavaScript library and requires basic knowledge of JavaScript.
    To create a simple chart, you need to know how to declare constants and variables,
    perform basic mathematical Boolean string and attribution operations, call and
    create functions, manipulate objects and arrays, and instantiate the Chart.js
    object. A typical chart also requires enough knowledge to program control structures,
    write callbacks, sort and filter datasets, generate random numbers, and load external
    files. This section is a quick refresher on the main ES2015 topics you will need
    to use Chart.js.
  prefs: []
  type: TYPE_NORMAL
- en: Browser tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't need a full frontend modular Node development environment to create
    visualizations with Chart.js, but you still need a good debugger. Every browser
    comes with development tools that allow you to navigate a static page structure
    and generated DOM elements, and a console where you can interact in real time
    with the data used by the JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important tool is the **JavaScript console**, where you will see any
    error messages. It''s very common to get a blank page when you expected something
    else and not have a clue as to why your code doesn''t work as expected. Sometimes,
    it''s just a comma you forgot, or the internet is down and some file was not loaded.
    If you have the JavaScript console open while you run your page, it will instantly
    tell you what''s going on. It''s also a good idea to use an editor with line numbering,
    since most error messages inform us of the lines where the problem occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0d0a36f-9ca6-4578-bf2e-86e8895b12c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging JavaScript with the JavaScript console
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the developer tools as a frame in your browser or as a separate
    window. The following are the menu paths for the JavaScript console in latest
    versions of the three most popular browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome: View | Developer | JavaScript Console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firefox: Tools | Web Developer | Web Console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safari: Develop | Show Error Console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the code fragments and examples in this section can be tested by typing
    them in the JavaScript console. It's a great way to learn JavaScript. It will
    also access the functions of any JavaScript library file that was loaded with
    the `<script>` tag, and any global variables declared in the `<script></script>`
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript types and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is not a typed language, since types are not declared and variables
    can receive different types, but data values do have types. The main types are *Number*,
    *String*, *Boolean*, *Array*, *Object*, and *Function*. The first three are scalar
    types, and the last three are also objects. A value is treated differently in
    the same expression if it has one type or another. For example, in an expression
    such as *a = b* + *c*, the value of *a* will be different if *b* and *c* are numbers
    (they will be added) or if one of them is a string (they will be concatenated).
  prefs: []
  type: TYPE_NORMAL
- en: Values can be compared, and their types are important if the comparison is *strict*
    (for example, using `===` instead of `==`). But it can be confusing to rely on
    such conversions (`0`, `""`, `null`, `NaN` , and `undefined` are all considered
    `false`, but the  `false` string converts to `true`, since its not an empty string).
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5 JavaScript, `var` was the only keyword for declaring a variable. It
    ignores block scope and is hoisted to the top of the functions. Since ES6 (ES2015),
    two new keywords have been introduced: `const` and `let`. They both are block-scoped
    and need to be assigned a value before they are used (`var` defaults to `undefined`).
    Declarations with `const` are constants and can''t be reassigned. It''s usually
    considered good practice to use `const` whenever possible, and only use `let`
    if you actually need to redefine a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Data structures used in charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data used as sources for visualizations is usually organized in some kind of
    structure. The most common structures are probably *lists* (arrays) and *tables*
    (maps), stored in some standard data format. When using data from external sources,
    you usually need to clean it up, removing unnecessary values, simplifying its
    structure, applying bounds, and so on. After that, you can parse it and finally
    store it locally in a JavaScript array or JavaScript object that can be used by
    the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Once your data is stored in a JavaScript data structure, you can transform it
    further by applying mathematical operations on the stored values. You can change
    the structure, create new fields, merge, and delete data. Typical operations include
    pushing new values into the dataset, splicing or splitting the array, creating
    a subset, transforming data, and so on. JavaScript provides many native operations
    that make it easier to modify arrays and objects. You can also use libraries such
    as JQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main data structure you will use to store one-dimensional data is the JavaScript
    array. It''s used as the main dataset format in most chart types in Chart.js.
    An array of values is all you need to make a simple bar chart. You can create
    an array by declaring a list of items within brackets, or simply a pair of opening-closing
    brackets if you want to start with an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then access the items of an array using an array index, which starts
    counting from zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each array has a length property that returns the number of elements. It''s
    very useful to iterate using the array index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also loop over the elements of an array using the *of* operator (introduced
    in ES2015) when you don''t need the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can use the `forEach()` method, which runs a function for each element
    and also allows access to the index, item, and array inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays are created in JavaScript as arrays of arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve individual items like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript provides many ways to extract and insert data into an array. It''s
    usually recommended to use these methods whenever possible. The following table
    lists useful methods you can use on arrays. Some modify the array; others return
    new arrays and other types. The examples provided use the `colors` and `numbers`
    arrays as declared previously. Try them out using your browser''s JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `push(item)` | Modifies the array, adding an item to the end. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `pop()` | Modifies the array, removing and returning the last item. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `unshift(item)` | Modifies the array, inserting an item at the beginning.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `shift()` | Modifies the array, removing and returning the first item. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `splice(p,n,i)` | Modifies the array, starting at position `p`. Can be used
    to delete, insert, or replace items. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `reverse()` | Modifies the array, reversing its order. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `sort()` | Modifies the array, sorting by string order (if no args) or by
    a comparator function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `slice(b,e)` | Returns a shallow copy of the array between `b` and `e`. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `filter(callback)` | Returns new array where the elements pass the test implemented
    by the function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `find(function)` | Returns the first element that satisfies the test function.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `indexOf(item)` | Returns the index of the first occurrence of the item in
    the array. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `includes(item)` | Returns `true` if an array contains the item among its
    entries. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `lastIndexOf(item)` | Returns the index of the last occurrence of the item
    in the array. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `concat(other)` | Returns a new array that merges the current array with
    another. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `join()``join(delim)` | Returns a comma-separated string of the elements
    in the array (an optional delimiter may be used). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `map(function)` | Returns a new array with each element modified by the function.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `reduce(function)` | Returns the result of an accumulation operation using
    the values in the array. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `forEach(function)` | Executes the provided function once for each element
    in the array. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions for array manipulation
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides arrays, ES2015 also introduced two new data structures: Map, an associative
    array with key-value pairs, easier to use than simple objects, and Set, which
    doesn''t allow repeated values. Both can be transformed to and from arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strings are primitive types in JavaScript that can be created with single quotes
    or double quotes. There is no difference. It''s only a matter of style. ES2015
    introduced two new string features: *template literals* and *multiline strings*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline strings can be created by adding a backslash at the end of each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Template literals are strings created with backticks. They allow the inclusion
    of JavaScript expressions inside the `${}` placeholders. The result is concatenated
    as a single string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to use a special character in a string, such as a double quote
    in a double-quoted string or a backslash, you need to precede it with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several methods for string manipulation. They all return new strings
    or other types. No methods modify the original strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `startsWith(s)` | Returns `true` if the string starts with the string passed
    as a parameter. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `endsWith(s)` | Returns `true` if string ends with the string passed as a
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `substring(s,e)` | Returns a substring between `start` (incl.) and *end*
    indexes (not incl.). |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `split(regx)``split(delim)` | Splits a string by a delimiter character or 
    a regular expression and returns an array. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `indexOf()` | Returns the index of the first occurrence of a substring. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `lastIndexOf()` | Returns the index of the last occurrence of a substring.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `charAt(i)` | Returns `char` at index `*i*`. Also supported as `‘string''[i]`.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `trim()` | Removes whitespace from both ends of a string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `match(regx)` | Returns an array as the result of matching a regular expression
    against the string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `replace(regx,r)``replace(s,t)` | Returns a new string replacing the matching
    of regexp applied to the string with a replacement or all occurrences of the source
    string with a target string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions for string manipulation
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are typically created in JavaScript using the `function` keyword,
    using one of the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword refers to the object that owns the function. If this code
    runs in a browser, and this is a top-level function created in the `<script>`
    block, the owner is the global `window` object. Any properties accessed via this
    refer to that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can be placed in the scope of an object, behaving as a method. The
    `this` reference in the following code refers to the `obj` object and can access
    `this.a` and `this.b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions were introduced in ES2015\. They are much more compact and
    can lead to cleaner code, but the scope of `this` is no longer retained by the
    object. In the following code, it refers to the global window object. Code that
    uses `this.a` and `this.b` will not find any data in the object and will return
    undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can use arrow functions in Chart.js callbacks, but you should use regular
    functions instead of arrow functions if you need to access the instance of the
    chart, usually available using `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object is an unordered collection of data. Values in an object are stored
    as key-value pairs. You can create an object by declaring a comma-separated list
    of *key:value* pairs within curly braces, or simply a pair of opening-closing
    curly braces if you want to start with an empty object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects can contain other objects and arrays, which can also contain objects.
    They can also contain functions, which have access to local properties and behave
    as methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical dataset used by a simple chart usually consists of an array of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the properties of an object using the dot operator or brackets
    containing the key as a string. You can run its methods using the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also loop over the properties of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties and functions can be added to objects. It''s common to write code
    that declares an empty object in a global context so that operations in other
    contexts add data to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Objects can also be created with a constructor. You can create an object that
    contains the current date/time using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A Chart.js instance is created using a constructor that receives at least two
    parameters. The second parameter is an object with two properties, a string and
    another object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON is a data format based on JavaScript objects. It has the same structure
    as a JavaScript object, but the property keys have to be placed within double
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To use a JSON string in JavaScript you have to parse it.
  prefs: []
  type: TYPE_NORMAL
- en: Other technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section presents a brief summary of other technologies you should know
    about, covering their fundamental concepts. They include HTML DOM, JQuery, CSS,
    and HTML Canvas. You can skim or skip this section if you already know about and
    use these technologies. The next sections also provide code examples that can
    be downloaded from the GitHub repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Document Object Model(DOM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of an HTML document is normally described with tags, but it can
    also be specified using JavaScript commands with a **Document Object Model (DOM)**:
    a language-neutral API that represents an HTML or XML document as a *tree*. Consider
    the following HTML document (`Examples/example-1.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This page builds a tree of interconnected *nodes* containing HTML elements
    and text. The exact same result can be obtained with the following JavaScript
    commands (`Examples/example-2.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it's much simpler to write tags, but JavaScript gives you the power
    to make the structure and content *dynamic*. Using DOM commands, you can add new
    elements, move them around, remove them, and change their attributes and text
    contents. You can also navigate the DOM tree, select or search for specific elements
    or data, and bind styles and event handlers to elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you add the following code, a new `<p>` containing the `“New
    line”` text will be created every time you click on the image (`Examples/example-3.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, you wouldn''t write your entire document using DOM, but only the
    parts you wish to control dynamically. Normally, you write the static parts as
    HTML and use scripting only when necessary (`Examples/example-4.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For data-driven documents, you can use DOM scripting to bind data stored in
    arrays and objects to attributes of the elements, changing the dimensions, colors,
    text contents, and position. Most data visualization libraries do exactly that
    by providing functions that are built over the DOM, and make this task much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the most important DOM commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method or property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `createElement(tag)` | Creates an element (not connected to the node tree)
    and returns its reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `createTextNode(text)` | Creates a text node (not connected to the node tree)
    and returns its reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `appendChild(element)` | Connects the element passed as a parameter as the
    child of the current element. |'
  prefs: []
  type: TYPE_TB
- en: '| `removeChild(element)` | Disconnects the child element from the current element.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `setAttribute(name, value)` | Sets an attribute for this element with the
    name and value passed as parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `getElementById(id)` | Returns an element identified by the `id` passed as
    a parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `getElementsByTagName(tag)` | Returns a `nodelist` (array) containing all
    the elements that match the tag name passed as a parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `addEventListener(e, func)` | Attaches an event handler to this element.
    The first parameter is the event type (for example, `‘click''`, `‘key''`, and
    so on) and the second parameter is a handler function. |'
  prefs: []
  type: TYPE_TB
- en: '| `documentElement` | This property references the element at the root of the
    document. For HTML and XHTML, it is the `<html>` element. |'
  prefs: []
  type: TYPE_TB
- en: '| `children` | This property returns a node list containing the child elements
    of this element. |'
  prefs: []
  type: TYPE_TB
- en: '| `innerText` | In SVG or HTML documents, this read/write property is a shortcut
    for creating a text node and appending it to the element. |'
  prefs: []
  type: TYPE_TB
- en: '| `innerHTML` | In HTML documents, this read/write property is a shortcut for
    appending an entire HTML fragment as a child element. |'
  prefs: []
  type: TYPE_TB
- en: '| `style` | In SVG or HTML documents, this property allows access to the element''s
    CSS styles. You can use it to read and modify styles dynamically. |'
  prefs: []
  type: TYPE_TB
- en: A selection of properties and methods supported by HTML DOM
  prefs: []
  type: TYPE_NORMAL
- en: Cascading Style Sheets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cascading Style Sheets** (**CSS**) is a W3C standard that specifies how HTML
    and XML elements are displayed on the screen. It''s a declarative language where
    visual properties are applied to tag selectors. You can use CSS to apply properties
    such as colors, fonts, margins, shadows, and gradients to one or more tags, perform
    coordinate transformations in two and three dimensions, and set rules for transitions
    and animations. CSS properties and selectors are also used in JavaScript libraries,
    such as JQuery and D3.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS selectors are expressions used to select elements by type, class, ID, wildcards,
    attributes, context, state, and position. The result of a selection expression
    may consist of none, one, or more elements. JavaScript libraries use selectors
    to obtain objects that can be manipulated programmatically via DOM. A result set
    can be formed from a list of comma-separated selection expressions. Elements may
    also be selected from context with combinator selectors. The following table lists
    some of the main selectors and some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Selector** | **Syntax** | **Description Example (in CSS)** |'
  prefs: []
  type: TYPE_TB
- en: '| Type selector | `tagname` | Selects a set of elements of the specified type
    (tag name), for example `td, h1, prect { … } /* all <rect> tags */`. |'
  prefs: []
  type: TYPE_TB
- en: '| Class selector | `.classname` | Selects a set of elements that belongs to
    a specified class, for example `.selected` and `p.copy`. |'
  prefs: []
  type: TYPE_TB
- en: '| ID selector | `#idname` | Selects one element with the specified `id` attribute,
    for example `#main` and `#chart`. |'
  prefs: []
  type: TYPE_TB
- en: '| Universal selector | `*` | Selects all elements. |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute selector | `[attr]` `[attr=value]`(several other combinations)
    | Selects elements that contain an attribute.Selects elements that contain an
    attribute with a specified value.Other combinations match a string in the attribute
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| Descendant combinator | `ancestor selectedtag` | Selects elements nested
    within a specified ancestor element (may have other elements in between), for
    example table `td`. |'
  prefs: []
  type: TYPE_TB
- en: '| Child combinator | `parent > selectedtag` | Selects elements nested *directly*
    below a specified parent element (`selectedTag` is a child of a parent), for example `table
    >tbody >tr >td`. |'
  prefs: []
  type: TYPE_TB
- en: '| General sibling combinator | `preceding ~ selectedtag` | Selects elements
    that appear after a specified predecessor (both have the same parent), for example `h1
    ~p.last`. |'
  prefs: []
  type: TYPE_TB
- en: '| Adjacent sibling combinator | `previous + selectedtag` | Selects elements
    that appear *directly* after a specified sibling (both have the same parent),
    for example `h1 +p.first`. |'
  prefs: []
  type: TYPE_TB
- en: '| Pseudo-classes | `tag:state` | Selects elements that are in a specified *state,*
    for example `a:hover, p:last-child, td:nth-of-type(2), :not(x)`. |'
  prefs: []
  type: TYPE_TB
- en: '| Pseudo-elements | `tag::property` | Selects elements with a specified `property`,
    and is rarely used. |'
  prefs: []
  type: TYPE_TB
- en: CSS selectors
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will use the simplest selectors. The ID, class, and type
    selectors are the most common. Eventually, you might use descendant combinators
    or attribute selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses simple selectors to change the visual appearance of
    an unformatted page containing three sections. The sections are stacked one on
    top of the other. The CSS properties and other parts were omitted, but you can
    see them in the full code listing (`Examples/example-5-selectors.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd5c5108-f516-4aca-b70f-c6563c648daf.png)'
  prefs: []
  type: TYPE_IMG
- en: An HTML page with stacked information styled using only CSS
  prefs: []
  type: TYPE_NORMAL
- en: JQuery fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JQuery is not a standard technology, but it''s a de facto Web standard. It
    uses CSS selectors to locate elements in any HTML file, and provides the same
    power as the DOM but with a much cleaner syntax. To use *JQuery,* you first need
    to include its library in your HTML page using the `<script>` tag. This is easily
    done with a CDN URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The code fragment here is a page that uses *JQuery* to perform the exact same
    operations shown in the last DOM example. The result is much easier to understand
    (`Examples/example-6.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'CSS selectors are used in JavaScript libraries such as *JQuery* to apply dynamic
    styles and manipulate a document''s structure and contents. The main JQuery(selector)
    function, normally used via its alias, the `$(selector)`function, is an element
    selector that receives a CSS selector expression as its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A selection can return zero, one, or a list of elements. You can test the length
    of a selection using the `length` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Using *JQuery* and the code shown in the CSS example, we can make the tabs
    fade in and fade out as they are clicked using selectors and *JQuery* functions
    (`Examples/example-7-selectors.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: HTML5 Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no way to draw circles or gradients using HTML tags, but you can use
    HTML Canvas: a full-featured JavaScript graphics API for 2D vector graphics. You
    can draw anything you wish with Canvas, and since it''s JavaScript, you can make
    it animate and respond to events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw using Canvas, you need to create a `<canvas>` element in your page.
    You can do that using plain HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create it dynamically, using HTML DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create it using *JQuery* too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can reference using the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can reference using JQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a canvas object, you obtain a 2D graphics context and can start
    drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Practically, all the Canvas API consists of is methods and properties called
    from the graphics context. Before drawing, you set properties such as font, fill
    color, and stroke color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And then *fill* or *stroke* rectangles and arbitrary paths containing lines
    and curves. These commands will draw a red 50 x 50 pixel square with a 10 pixel
    wide yellow semi-transparent border at position 50,50:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You can draw other shapes, texts, and images on the same canvas. The context
    properties will not change unless they are redefined.
  prefs: []
  type: TYPE_NORMAL
- en: You can also draw using path commands. You need to start the path with `ctx.beginPath()`,
    and call a sequence of commands that moves to points and draws lines and curves,
    and when you are done you can close the path (if it's a closed path) and call
    `fill()` and/or `stroke()` to draw it using the current styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code draws some shapes, paths, shadows, gradients, and text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the result. You can try and run the full code,
    which is available in `Examples/example-8-canvas.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36859749-cdcb-4ec3-a68b-764d6d911393.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some shapes drawn in an HTML Canvas context. Code: *Examples/example-8-canvas.html*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some essential Canvas commands are listed in the following table. All commands
    are methods of the current Canvas context:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method or property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `fillStyle` | Sets the color to be used in the `fill()` commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `strokeStyle` | Sets the color to be used in the `stroke()` commands. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineWidth` | Sets the line width to be used in the `stroke()` commands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lineCap` | Sets the style of the line caps, for example `butt` (default),
    `round`, or `square`. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineJoin` | Sets the style of the line joins, for example `‘round''`, `‘bevel''`,
    or `‘miter''` (default). |'
  prefs: []
  type: TYPE_TB
- en: '| `font` | Sets the font to be used in the `strokeText()` or `fillText()` commands.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `globalAlpha` | Sets the global opacity (`0` = transparent, `1` = opaque)
    for the context. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowBlur, shadowColor,` `shadowOffsetX, shadowOffsetY` | Sets shadow properties.
    The default color is transparent black. The default numeric values are zero. |'
  prefs: []
  type: TYPE_TB
- en: '| `fillRect(x,y,w,h)` | Fills a rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `strokeRect(x,y,w,h)` | Draws a border around a rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| `setLineDash(dasharray)` | Receives an array for the dash, alternating lines
    and spaces. |'
  prefs: []
  type: TYPE_TB
- en: '| `fillText(text,x,y);` | Fills text at the x and y positions (y is the baseline).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `strokeText(text,` x, y); | Draws a border around text at the x and y positions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `createLinearGradient(x0, y0, x1, y1)` | Creates a linear gradient perpendicular
    to the line. Radial gradients and patterns are also supported. |'
  prefs: []
  type: TYPE_TB
- en: '| `drawImage(image, x, y, w, h)` | Draws an image. |'
  prefs: []
  type: TYPE_TB
- en: '| `beginPath()` | Starts a path. |'
  prefs: []
  type: TYPE_TB
- en: '| `moveTo(x, y)` | Moves the cursor to a position in the path. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineTo(x, y)` | Moves the cursor to a position in the path, drawing a line
    along the way. |'
  prefs: []
  type: TYPE_TB
- en: '| `bezierCurveTo(c1x, c1y, c2x, c2y, x, y), quadraticCurveTo(cx, cy, x, y)`
    | Draws curves with one (*quadratic*) or two (*Bezier*) control points in a path.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `arc(x, y, r, sa, ea)` | Draws an arc by specifying the center, radius, start,
    and end angles in a path. |'
  prefs: []
  type: TYPE_TB
- en: '| `arcTo(sx, sy, r, ex, ey)` | Draws an arc by specifying the coordinates of
    the starting point, the radius, and the coordinates of the end point. |'
  prefs: []
  type: TYPE_TB
- en: '| `rect(x, y, w, h)` | Draws a rectangle in a path with the coordinates of
    the top-left corner, width, and height. |'
  prefs: []
  type: TYPE_TB
- en: '| `clip()` | Creates a clipping region with the shapes drawn by the path that
    will affect objects that are drawn afterwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `fill()` | Fills a path with the current color. |'
  prefs: []
  type: TYPE_TB
- en: '| `stroke()` | Strokes the path with the current color. |'
  prefs: []
  type: TYPE_TB
- en: Selected HTML Canvas commands
  prefs: []
  type: TYPE_NORMAL
- en: Data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data used in visualizations is usually distributed in a standard format that
    can be shared. Even when the data is served from a database, the data is usually
    delivered in some standard format. Popular proprietary formats, such as Excel
    spreadsheets, are common, but most statistical data is stored or delivered in
    CSV, XML, or JSON formats.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSV stands for comma-separated values. It''s a very popular data format for
    public data. A CSV file is a text file that emulates a table. It usually contains
    one header row with the names of the columns, and one or more data rows containing
    value fields. Rows are separated by line breaks, and the comma-separated fields
    in each row form columns. It maps perfectly to an HTML table. This is a simple
    CSV file containing the population and land area of seven continents (`Data/sample.csv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There are no types in CVS. Quotes are used to contain text that might contain
    the delimiter. They are not necessary if the fields don't contain a comma.
  prefs: []
  type: TYPE_NORMAL
- en: CSV is also used to refer to similar files that don't use a comma as a delimiter.
    These files are more accurately called **delimiter-separated value **(**DSV**)
    files. The most common delimiters are tabs (TSV), vertical bars (|), and semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: CSVs may become corrupt and unreadable, but it's text and you can fix it. Missing
    or unescaped commas are the most common problems.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**eXtensible Markup Language** (**XML**) is a very popular data format. Ajax
    responses from Web services are usually returned as text or XML. It has standard
    native support in JavaScript via the DOM APIs and doesn''t require additional
    parsing. Although it is still common to find data in XML format, CSV and JSON
    alternatives, if available, are usually smaller and easier to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of an XML file with the same data as the CSV file shown
    earlier (`Data/sample.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: XML files can be validated if an XML Schema is available. You can extract data
    from a well-formed XML file with DOM or with XPath (which is easier). There are
    many tools in all languages to manipulate XML. XML is also very easy to generate.
    Its main disadvantage is verbosity and size.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON stands for JavaScript Object Notation. It looks a lot like a JavaScript
    object, but it has stricter formation rules. It's probably the easiest format
    to work with. It's compact and easy to parse, and it's gradually replacing XML
    as a preferred data format in Web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following data file containing continent data is shown in JSON format (`Data/sample.json`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: JSON is the preferred format for data manipulation in JavaScript. There are
    many online tools you can use to transform CSV and XML files into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and parsing external data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you have a very small or static dataset, it will usually not be embedded
    in your web page. You will probably use an asynchronous request to load it from
    a separate file after your HTML page is already loaded and then parse it. This
    section covers topics related to loading and parsing external files.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the examples in this book consist of a single file (not considering
    the external libraries loaded using the `<script>` tags), and you can run them
    by simply opening them in a browser. You don't even need a Web server. Just click
    on the file and view it in your browser. But this won't work in examples that
    load external files via Ajax. For those files, you do need a Web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an HTML editor, such as PHPStorm or Brackets, it automatically
    starts a Web server for you and serves the page to your default browser. If you
    have Python installed in your system (it is native in macOS and Linux, and you
    can install it in Windows), you can run a simple server from the directory where
    your files are installed. The syntax depends on which Python version you have
    installed. You can check by opening a console and typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now move to the directory where your HTML files are stored and run one of the
    following commands. If you have Python 3.x , run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If your version is 2.x, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Now you can open your files using `http://localhost:8080/your-file-name.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading files using standard JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard way to load data into a Web page is using asynchronous JavaScript
    and XML, or Ajax. It uses the standard built-in `XMLHttpRequest` object, supported
    by all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: To load a file using `XMLHttpRequest`, you need to create the `XMLHttpRequest`
    object, choose an HTTP method, use the object to open an HTTP connection to the
    file's URL, and send the request. You must also create a callback function that
    listens to the object's `'readystatechange'` event and test the object's `readystate`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this property contains `XMLHttpRequest.DONE`, the request is done and
    you can extract the data. But it''s not finished yet! If the request finished
    successfully (the object *status* property equals 200), you need to extract the
    data from the object. In a CSV file, the data will be in the `responseText` property
    (it''s in a different place if it''s XML). Only then can you finally parse its
    contents and create your data array. This is shown in the following code (`Examples/example-9-ajax.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Loading files using JQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You never have to use standard JavaScript to load files, but it''s good to
    know how it works. It''s much, much simpler to load files using the *JQuery* library
    (`Examples/example-10-ajax-jquery.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also load and parse JSON files in a single step using *JQuery*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Loading files using the standard Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all modern browsers, you can also load external files using the Fetch API.
    It's the new JavaScript standard for loading files asynchronously, and we will
    be using it in all examples that load external files in this book, but it may
    not work in some older browsers. In that case, you should revert to standard JavaScript
    or JQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fetch()` command is a reactive method based on JavaScript promises. A
    basic fetch request is shown as follows (`Examples/example-12-fetch.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also parse JSON files using `fetch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Parsing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although JSON is based on JavaScript, a JSON file is not a JavaScript object.
    It''s a string. To convert it into an object and access its properties with the
    dot operator, you can use `JSON.parse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you need to convert a JavaScript object back into JSON format. You
    might also do this for debugging. You can do this with `JSON.stringify()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If you parsed the example JSON file at the beginning of this section, the JavaScript
    object will actually be an array of objects, and you can list its contents (in
    the JavaScript console) using the following code (`Examples/example-14.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Parsing CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no native CSV parser in JavaScript, but if you have a very small and
    simple CSV file, you can parse it using JavaScript string manipulation tools or
    regular expressions, splitting by newlines (`\n`) to select each row, and then
    splitting by the delimiter to select each data cell within each row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Larger data files are more complex, since the preceding code depends on a specific
    format and does not deal with commas inside quoted strings, missing data, and
    so on. In this case, you should use a CSV parser. Most examples in this book use
    the PapaParse CSV parser ([papaparse.com](http://papaparse.com)) by Matt Holt,
    which is open source and free. The following code shows how to convert CSV into
    a JavaScript object using PapaParse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If you parsed the example CSV file at the beginning of this section, you will
    receive an array of objects, and you can list the contents (in the JavaScript
    console) using the following code (`Examples/example-15.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The + before the last two properties converts them into numbers. If you don't
    do that they will be loaded as strings, even though they are numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Loading multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you need files from different sources that need to be loaded and
    then manipulated within a page. You load these using `Promise.all()`, as shown
    next. The code in the promise will only be executed when all the files are loaded
    (`Examples/example-16.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without any charting library, using just standard JavaScript, you can load
    a JSON file and draw a world map using Canvas. The data is a special JSON format
    that stores geographical shapes: GeoJSON. Its general structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Using JavaScript, you can load this file, parse it, and access each longitude
    and latitude pair. Then you can scale the values so that they fit into the coordinate
    system of your Canvas, and draw each shape using Canvas path commands. This is
    done in the following code (`Examples/example-17.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a15b5ae7-16a4-44ac-a0bb-31508fd50cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: A world map created using GeoJSON, JavaScript, and Canvas code
  prefs: []
  type: TYPE_NORMAL
- en: Extracting and transforming data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are lucky enough to find your data in CSV, XML, or JSON, you can load
    it and start using it right away. But what if your data is only available as HTML
    tables, or worse, as a PDF file? In these cases, you need to extract your data
    and transform it into a usable format.
  prefs: []
  type: TYPE_NORMAL
- en: If it's a very simple HTML table, sometimes you can select it and copy and paste
    it into a spreadsheet and preserve the rows and columns. Then you can export it
    as a CSV. Sometimes you will need to do extra work, perhaps removing garbage characters,
    styles, and unnecessary columns. This is risky, since you may also lose data or
    introduce errors during the process.
  prefs: []
  type: TYPE_NORMAL
- en: Online tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use online tools that try to convert HTML tables into XML, CSV,
    and JSON. Let''s try an example. The NASA JPL site has a Web page containing data
    about the moon and the planets in our solar system ([nssdc.gsfc.nasa.gov/planetary/factsheet](http://nssdc.gsfc.nasa.gov/planetary/factsheet)).
    To use that data, you will need to have it in a standard format such as JSON,
    CSV, or XML, but it''s only available as an HTML table, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/117a42aa-2a25-49c4-a2e5-adf0c11e2f03.png)'
  prefs: []
  type: TYPE_IMG
- en: An HTML table containing data that can be used in a chart
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first try an online conversion service. Searching for HTML-to-CSV conversion,
    I found an online conversion service at at `www.convertcsv.com` with several CSV
    conversion tools. Open the HTML Table to CSV link and either paste the source
    code in the input box, or provide its URL. There are some options you can configure,
    such as choosing the delimiter. Click on the Convert HTML to CSV button, and the
    following text will appear in the output box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is valid CSV, but some fields were interpreted as strings, not numbers
    (some diameters, for example). You might also wish to remove some unnecessary
    rows, such as the last one, or data you don't need. You can edit the file later
    and write a script to fix the numbers using regular expressions. Download the
    result and save it in a file, and then try loading the file using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a third-party online service, I can't guarantee it will still
    exist when you read this book, but you should find similar services that perform
    the same conversion. If not, you can always write an extraction script yourself.
    A good tool for that is *XPath*, supported by many extraction libraries and browsers,
    described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data with XPath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since HTML is a structure document, you can use a computer program to navigate
    that structure and extract selected text nodes, attributes, and elements. Most
    Web extraction tools are based on XPath: an XML standard that can be used to navigate
    in a XML structure and select elements, attributes, and text nodes using path
    notation. Although HTML is not as strict as XML, it has similar structures that
    can be represented as XPath paths and is supported by many Web scraping tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the first lines of the previous web page have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not XML or XHTML, since attributes are not within quotes and tags don''t
    close, but you can still use XPath to extract data from it. This path will give
    you the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Any one of these one will return the `bgcolor` attribute (its name and value)
    from the body tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This one will return the contents of the `<H1>` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is tricky. If this was XML, it would be `/html/head/p/hr/H1`, because
    all XML tags must close, but HTML parsers automatically close the `<p>` and `<hr>`
    tags because there can''t be an `<h1>` header inside them. HTML is also case insensitive,
    so using `H1` or `h1` doesn''t make any difference with these parsers. Still,
    this may still confuse some parsers. You can play it safe by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `//` or double slash means that between `<head>` and `<H1>` there can be
    any number of levels. This is compatible with the XML or HTML absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can experiment with XPath using your browser''s JavaScript console, writing
    XPath expressions inside `$x(expression)`. Let''s try it out using the *Planetary
    Fact Sheet* page. Open the page in your browser and then open a console window,
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This will select all the tables in the document. In this case, there is only
    one. You can also view the source code or inspect the page to discover the absolute
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter this command and the console will reveal the HTML fragment corresponding
    to your selection. Now let''s select the row that contains diameters. It''s the
    third row in the table. You can ignore the existing `<thead>` or `<tbody>` tags
    using the `//`. XPath counts child nodes starting with 1, not 0 as in JavaScript.
    The command returns a single `<tr>` element in an array. We can extract it using
    `[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This will select the following fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the diameter of the earth, you need to add one more path step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the text, you need to include the `text()` function at the end of
    the XPath expression. You also need to extract the data from the `$x()` function
    result, using the `data` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the result as a string. You can then use regular expressions
    to remove the comma and then convert the result to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You might want to automate that with a programming library if you need to extract
    lots of data, such as all the planetary diameters. The `$x()` command only works
    in the browser console, but many programming languages support XPath libraries
    and APIs. You can also use tools such as Scrapy (in Python) or testing tools such
    as Selenium (in several languages) that support XPath selectors for extracting
    data from HTML.
  prefs: []
  type: TYPE_NORMAL
- en: XPath is a very powerful data extraction language, and this was only a very
    brief introduction. But there are also alternatives, such as XQuery (another XML
    standard with a query syntax) and CSS selectors (used by *JQuery* and also supported
    by Scrapy and Selenium).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a refresher on several fundamental technology concepts
    that will help you create visualizations with Chart.js. Even though Chart.js tries
    to hide all the underlying complexity from you, it is still a JavaScript library
    and basic knowledge of JavaScript, DOM, and CSS are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter also described the main data formats used for statistical data:
    CSV, XML, and JSON. It also described how to load external files in these formats
    and how to parse them. Additionally, you learned some ways to obtain data not
    in these formats by extracting it from HTML pages.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin using Chart.js to create data visualizations.
  prefs: []
  type: TYPE_NORMAL
