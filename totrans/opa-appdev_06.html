<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Binding with Other Languages</h1></div></div></div><p>As mentioned in the <em>Register handler</em> section of <a class="link" href="ch03.html" title="Chapter 3. Developing Web Applications">Chapter 3</a>, <em>Developing Web Applications</em>, we can register external JavaScript code by utilizing the <code class="literal">Resource.register_external_js</code> function. But, this is not how we call external JavaScript functions from Opa. This is only true when we wish to invoke Node.js functions. In such cases, we instead bind external functions with Opa's binding ability. In this chapter, we will explain how to bind external JavaScript or Node.js functions.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Binding JavaScript</h1></div></div></div><p>Opa allows <a id="id236" class="indexterm"/>binding of the external functions through its <strong>Binding System Library</strong> (<strong>BSL</strong>).<a id="id237" class="indexterm"/> If we surf the source code of Opa, <a id="id238" class="indexterm"/>we will find in many places that Opa binds JavaScript in its source code. Actually, Opa provides three forms of binding syntax: <code class="literal">classic</code> , <code class="literal">jsdoc</code>, and <code class="literal">new</code>. The jsdoc syntax is now (Opa 1.1.0) the default.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec48"/>The first example</h2></div></div></div><p>Let's get started<a id="id239" class="indexterm"/> with a binding example of JavaScript. Suppose we have finished a <code class="literal">test</code> function in the <code class="literal">test.js</code> JavaScript file, and then we want to use it in the <code class="literal">601.opa</code> Opa file.</p><div><img src="img/3749OS_06_01.png.jpg" alt="The first example"/></div><p>The content of the <code class="literal">test.js</code> file is as follows:</p><div><pre class="programlisting">/**
* A test function of Opa binding
* @register {string -&gt; void}
*/
function test(str){
         alert(str);
}</pre></div><p>We registered<a id="id240" class="indexterm"/> the <code class="literal">test</code> function using the annotation <code class="literal">@register {string -&gt; void}</code>. This indicates that the function being registered has the <code class="literal">string -&gt; void</code> type. To invoke the <code class="literal">test</code> function in Opa code, we designate the function as an external JavaScript function by surrounding the name of the function with the special designator <code class="literal">%%</code>. In the following example, we call the JavaScript <code class="literal">test</code> function located in <code class="literal">test.js</code> from within the <code class="literal">601.opa</code> file:</p><div><pre class="programlisting">function page(){
    &lt;input type="button" value="click" onclick={function(_){
         %%test.test%%("Hello Opa!")
    }}/&gt;
}
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div><p>We call the function using <code class="literal">%%test.test%%("Hello Opa!")</code>. The word "test" appears in this example twice, <a id="id241" class="indexterm"/>once preceding the dot and once after the dot. The first "test" is the name of the plugin module; in this case it is the filename of <code class="literal">test.js</code>. The second "test" is the name of the function that we define in this file. We can compile the JavaScript code and Opa code together by using the following command line:</p><div><pre class="programlisting">
<strong>opa test.js 601.opa  --</strong>
</pre></div><p>By default, the registered function name is identical to the original function name that we defined in the JavaScript file. However, we can modify the name as follows:</p><div><pre class="programlisting">/** 
* @register {string -&gt; void} test2
*/
function test(str){ 
         alert(str);
}</pre></div><p>Note that we added <code class="literal">test2</code> to the end of the line that we used to register the function. Now, we can invoke it using <code class="literal">%%test.test2%%("Hello Opa!")</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec49"/>Using external types</h2></div></div></div><a id="id242" class="indexterm"/><p>Sometimes, we may want to handle the Opa types such as list (`a), option ('a), or Opa external types that we defined in Opa in JavaScript. In the following example, we define a type <code class="literal">Student</code> and its variable <code class="literal">stu</code>; variable <code class="literal">lst</code> is the Opa type <code class="literal">list(string)</code>, which we may not use in JavaScript directly; and the variable <code class="literal">arr</code> is an external type.</p><div><pre class="programlisting">/** 602.opa */
type Student = {string name, bool sex, int age} //Type we defined
<strong>Student      stu</strong> = {name:"Li", sex: {true}, age: 28}
<strong>list(string) lst</strong> = ["I ","Like ","Opa ","!"];   //Opa's types
<strong>llarray(int) arr</strong> = @llarray(1,2,3,4);           //Extern types
function page(){
    &lt;input type="button" value="func1()" onclick={function(_){
         %%test2.func1%%(stu)
    }}/&gt;
    &lt;input type="button" value="func2()" onclick={function(_){
         %%test2.func2%%(lst)
    }}/&gt;
    &lt;input type="button" value="func3()" onclick={function(_){
         %%test2.func3%%(arr)
    }}/&gt;
}
Server.start(Server.http, {title:"Opa Packt", ~page});</pre></div><p>In our<a id="id243" class="indexterm"/> JavaScript file, we define three functions: <code class="literal">func1</code>, <code class="literal">func2</code>, and <code class="literal">func3</code>. <code class="literal">func1</code> accepts type <code class="literal">Student</code>, <code class="literal">func2</code> accepts type <code class="literal">list(string)</code>, and <code class="literal">func3</code> accepts type <code class="literal">llarray(int)</code>. All these three functions do nothing but print the content of their respective arguments to the console. The first thing we should do is declare Opa types and external types with the directives <code class="literal">@opaType</code> and <code class="literal">@externType</code> respectively.</p><p>The content of the file <code class="literal">test2.js</code> is as follows:</p><div><pre class="programlisting">/** test2.js */
/** <strong>@opaType list('a)</strong> */
/** <strong>@opaType Student</strong> */
/** <strong>@externType llarray('a)</strong> */
/** @register {<strong>opa[Student]</strong> -&gt; void} */
function func1(stu){ 
    console.log("func1: "+ stu.name +" , "+stu.sex+", "+stu.age);
}
/** @register {<strong>opa[list(string)]</strong> -&gt; void} */
function func2(lst){
    //use list2js to convert Opa list to js list.
    var lst2 = list2js(lst); 
    for(var i=0; i&lt;lst2.length; i++) 
        console.log("func2: " + lst2[i]);
}
/** @register {<strong>llarray(int)</strong> -&gt; void} */
function func3(arr){
    for(var i=0; i&lt;arr.length; i++) 
        console.log("func3: " + arr[i]);
}</pre></div><p>Compile and run <code class="literal">opa test2.js 602.opa --</code>
</p><p>Press <em>F12</em> in<a id="id244" class="indexterm"/> your Chrome browser to open the developer tool and you will see the output we printed in the console.</p><div><img src="img/3749OS_06_02.png.jpg" alt="Using external types"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Binding Node.js</h1></div></div></div><p>Binding <a id="id245" class="indexterm"/>Node.js code is just as easy as binding JavaScript. Let's see an<a id="id246" class="indexterm"/> example: suppose we have written a function called <code class="literal">calcMD5</code> in a Node.js file called <code class="literal">test.nodejs</code>. The function accepts a string and returns its MD5 hash value. The <code class="literal">test.nodejs</code> file contains the following code:</p><div><pre class="programlisting">/** test.nodejs */
var crypto = require('crypto');
/**
 * Calculates the MD5 hash value of a string.
 * @register {string -&gt; string}
 */
var calcMD5 = function(str){
    return crypto.createHash('md5').update(str).digest('hex');
}</pre></div><p>As we can see from the preceding code, we bind Node.js in the same manner that we previously used to<a id="id247" class="indexterm"/> bind the client-side JavaScript code. We also invoke it in the same way:</p><div><pre class="programlisting">/** 603.opa */
md5 = %%test.calcMD5%%("Hello Opa!");
println("MD5 value: {md5}");</pre></div><p>And finally, we compile and run the application:</p><div><pre class="programlisting">opa test.nodejs 603.opa --</pre></div><p>The result is as shown in the following screenshot:</p><div><img src="img/3749OS_06_03.png.jpg" alt="Binding Node.js"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Binding external functions using the classic syntax</h1></div></div></div><p>We can<a id="id248" class="indexterm"/> also <a id="id249" class="indexterm"/>bind external functions with<a id="id250" class="indexterm"/> the <code class="literal">classic</code> syntax. The <code class="literal">classic</code> syntax is a little different from the <code class="literal">jsdoc</code> syntax. It uses <code class="literal">##</code> to register functions. A typical registration body is as follows:</p><div><pre class="programlisting">##register function_name: function_type
##args(argment_list)
{
    //function body
}</pre></div><p>In <code class="literal">classic</code> syntax, <code class="literal">test2.js</code> will contain the following code:</p><div><pre class="programlisting">##opa-type Student
##opa-type list('a)
##extern-type llarray('a)
##register func1: opa[Student] -&gt; void
##args(stu)
{ 
  console.log("func1: "+ stu.name +" , "+stu.sex+", "+stu.age);
}

##register func2: opa[list(string)] -&gt; void
##args(lst)
{ 
    var lst2 = list2js(lst); 
    for(var i=0; i&lt;lst2.length; i++) 
          console.log("func2: " + lst2[i]);
}

##register func3: llarray(int) -&gt; void
##args(arr)
{ 
  for(var i=0; i&lt;arr.length; i++) 
        console.log("func3: " + arr[i]);
}</pre></div><p>We can <a id="id251" class="indexterm"/>now<a id="id252" class="indexterm"/> compile the rewritten<a id="id253" class="indexterm"/> file using the following command:</p><div><pre class="programlisting">
<strong>opa test2.js 601.opa --js-bypass-syntax classic</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we talked about how to bind client-side JavaScript and server-side Node.js into our Opa code. We described two syntax variations: <code class="literal">classic</code> syntax and <code class="literal">jsdoc</code> syntax. The examples used in this chapter demonstrated that binding JavaScript and Node.js is quite trivial in Opa.</p></div></body></html>