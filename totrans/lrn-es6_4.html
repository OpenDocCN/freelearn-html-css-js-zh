<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Asynchronous Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Asynchronous Programming</h1></div></div></div><p>ES6 introduced a native support for the well-known programming patterns. One such pattern is the Promise pattern, which makes it easier to read and write the asynchronous code. In this chapter, we will learn to write asynchronous code using the ES6 Promise API. The new JavaScript and <span class="strong"><strong>HTML5</strong></span><a id="id244" class="indexterm"/> asynchronous APIs are now being implemented with Promises to facilitate writing less and cleaner code. Therefore, it's important to learn Promises in-depth. We will also see some example APIs that are exposed using Promises such as the<a id="id245" class="indexterm"/> <span class="strong"><strong>Web Cryptography API</strong></span>, and the <a id="id246" class="indexterm"/>
<span class="strong"><strong>Battery Status API</strong></span>.</p><p>In this chapter, we'll cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The JavaScript execution model</li><li class="listitem" style="list-style-type: disc">The difficulties faced while writing the asynchronous code</li><li class="listitem" style="list-style-type: disc">Creating Promises and how Promises work</li><li class="listitem" style="list-style-type: disc">How Promises make it easier to write the asynchronous code</li><li class="listitem" style="list-style-type: disc">The different states of a Promise</li><li class="listitem" style="list-style-type: disc">Various methods of the Promise object.</li><li class="listitem" style="list-style-type: disc">Various JavaScript and HTML5 APIs, which use Promises</li></ul></div><div class="section" title="The JavaScript execution model"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>The JavaScript execution model</h1></div></div></div><p>The JavaScript code is <a id="id247" class="indexterm"/>executed in a single thread, that is, two pieces of script cannot run at same time. Each website opened in browser gets a single thread for downloading, parsing, and executing the website called as the main thread.</p><p>The main thread also maintains a queue, which has asynchronous tasks queued to be executed one by one. These queued tasks can be event handlers, callbacks, or any other kind of task. The new tasks are added to the queue as<a id="id248" class="indexterm"/> <span class="strong"><strong>AJAX</strong></span> requests/response happen, events occur, timers registered, and more. One long running queue task can stop the execution of all other queue tasks and the main script. The main thread executes the tasks of this queue whenever possible.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>HTML5 introduced <a id="id249" class="indexterm"/>
<span class="strong"><strong>web workers</strong></span>, which are the actual threads running parallel to the main thread. When a web worker finishes executing or needs to notify the main thread, it simply adds a new event item to the queue.</p></div></div><p>This queue is <a id="id250" class="indexterm"/>what makes it possible for executing the code asynchronously.</p></div></div>
<div class="section" title="Writing asynchronous code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Writing asynchronous code</h1></div></div></div><p>ES5 natively <a id="id251" class="indexterm"/>supports two patterns for writing the asynchronous code, that is, the event pattern and the callback pattern. While writing the asynchronous code, we usually start an asynchronous operation and register the event handlers or pass the callbacks, which will be executed once the operation is finished.</p><p>The event handlers or the callbacks are used, depending on how the specific asynchronous API is designed. An API that is designed for an event pattern can be wrapped with some custom code to create the callback pattern for the API, and vice-versa. For example, AJAX is designed for the event pattern, but <span class="strong"><strong>jQuery</strong></span><a id="id252" class="indexterm"/> AJAX exposes it as a callback pattern.</p><p>Let's consider some examples of writing asynchronous code involving events and callbacks and their difficulties.</p><div class="section" title="The asynchronous code involving events"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>The asynchronous code involving events</h2></div></div></div><p>For asynchronous JavaScript <a id="id253" class="indexterm"/>APIs involving events, you need to register the success and error event handlers which will be executed depending on whether the operation was a success or failure respectively.</p><p>For example, while making an AJAX request, we register the event handlers which will be executed depending on whether the AJAX request was made successfully or not. Consider this code snippet which makes and AJAX request and logs the retrieved information:</p><div class="informalexample"><pre class="programlisting">function displayName(json)
{
  try
  {
    //we usally display it using DOM
    console.log(json.Name);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}
function displayProfession(json)
{
  try
  {
    console.log(json.Profession);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayAge(json)
{
  try
  {
    console.log(json.Age);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayData(data)
{
  try
  {
    var json = JSON.parse(data);

    displayName(json);
    displayProfession(json);
    displayAge(json);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

var request = new XMLHttpRequest();
var url = "data.json";

request.open("GET", url);
request.addEventListener("load", function(){
  if(request.status === 200)
  {
    displayData(request.responseText);
  }
  else
  {
    console.log("Server Error: " + request.status);
  }
}, false);

request.addEventListener("error", function(){
  console.log("Cannot Make AJAX Request");
}, false);

request.send();</pre></div><p>Here, we assume the <code class="literal">data.json</code> file to have this content:</p><div class="informalexample"><pre class="programlisting">{
  "Name": "Eden",
  "Profession": "Developer",
  "Age": "25"
}</pre></div><p>The <code class="literal">send()</code> method <a id="id254" class="indexterm"/>of the <code class="literal">XMLHttpRequest</code> object is executed asynchronously, which retrieves the <code class="literal">data.json</code> file and calls the <code class="literal">load</code> or <code class="literal">error</code> event handler, depending on whether the request was made successfully or not.</p><p>There is absolutely no issue with how this AJAX works, but the issue is with how we write the code involving events. Here are the issues that we faced while writing the previous code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We had to add an exception handler for every block of code that will be executed asynchronously. We can't just wrap the whole code using a single <code class="literal">try…catch</code> statement. This makes it difficult to catch the exceptions.</li><li class="listitem" style="list-style-type: disc">The code is harder to read, as it's difficult to follow the code flow due to the nested function calls.</li><li class="listitem" style="list-style-type: disc">If another part of the program wants to know if the asynchronous operation is finished, pending, or being executed then we have to maintain the custom variables for that purpose. So we can say it is difficult to find the state of the asynchronous operation.</li></ul></div><p>This code can get <a id="id255" class="indexterm"/>even more complicated and harder to read if you are nesting multiple AJAX or any other asynchronous operations. For example, after displaying the data, you may want to ask the user to verify if the data is correct or not and then send the Boolean value back to the server. Here is the code example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">function verify()
{
  try
  {
    var result = confirm("Is the data correct?");
    if (result == true)
    {
      //make AJAX request to send data to server
    }
    else
    {
      //make AJAX request to send data to server
    }
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayData(data)
{
  try
  {
    var json = JSON.parse(data);

    displayName(json);
    displayProfession(json);
    displayAge(json);

    verify();
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}</pre></div></div><div class="section" title="The asynchronous code involving callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec69"/>The asynchronous code involving callbacks</h2></div></div></div><p>For asynchronous JavaScript <a id="id256" class="indexterm"/>APIs involving callbacks, you need to pass the success and error callbacks, which will be called depending on whether the operation was a success or failure respectively.</p><p>For example, while making an AJAX request using jQuery, we need to pass the callbacks, which will be executed depending on whether the AJAX request was made successfully or not. Consider this code snippet that makes an AJAX request using jQuery and logs the retrieved information:</p><div class="informalexample"><pre class="programlisting">function displayName(json)
{
  try
  {
    console.log(json.Name);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayProfession(json)
{
  try
  {
    console.log(json.Profession);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayAge(json)
{
  try
  {
    console.log(json.Age);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

function displayData(data)
{
  try
  {
    var json = JSON.parse(data);

    displayName(json);
    displayProfession(json);
    displayAge(json);
  }
  catch(e)
  {
    console.log("Exception: " + e.message);
  }
}

$.ajax({url: "data.json", success: function(result, status, responseObject){
    displayData(responseObject.responseText);
}, error: function(xhr,status,error){
    console.log("Cannot Make AJAX Request. Error is: " + error);
}});</pre></div><p>Even here, there is <a id="id257" class="indexterm"/>absolutely no issue with how this jQuery AJAX works, but the issue is with how we write the code involving callbacks. Here are the issues that we faced while writing the preceding code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is difficult to catch the exceptions, as we have to use multiple <code class="literal">try</code> and <code class="literal">catch</code> statements.</li><li class="listitem" style="list-style-type: disc">The code is harder to read, as it's difficult to follow the code flow due to the nested function calls.</li><li class="listitem" style="list-style-type: disc">It's difficult to maintain the state of the asynchronous operation.</li></ul></div><p>Even this code will get more complicated if we nest the multiple jQuery AJAX or any other asynchronous operations.</p></div></div>
<div class="section" title="Promises to the rescue"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Promises to the rescue</h1></div></div></div><p>ES6 introduces a new native pattern for writing<a id="id258" class="indexterm"/> the asynchronous code called as Promise pattern.</p><p>This new pattern removes the common code issues that the event and callback pattern had. It also makes the code look more like a synchronous code.</p><p>A Promise (or a Promise object) represents an asynchronous operation. The existing asynchronous JavaScript APIs are usually wrapped with Promises, and the new JavaScript APIs are being purely implemented using the Promises.</p><p>Promises are new<a id="id259" class="indexterm"/> in JavaScript but are already present in many other programming languages. Programming Languages such as C# 5, C++ 11, Swift, Scala, and more are some examples that support Promises.</p><p>ES6 provides the Promise API using which we can create Promises and use them. Let's explore the ES6 Promise API.</p><div class="section" title="The Promise constructor"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec70"/>The Promise constructor</h2></div></div></div><p>The <code class="literal">Promise</code> constructor<a id="id260" class="indexterm"/> is used to create new Promise instances. A Promise object represents an asynchronous operation.</p><p>We need to pass a callback to the <code class="literal">Promise</code> constructor, which executes the asynchronous operation. This callback is called as the <a id="id261" class="indexterm"/>
<span class="strong"><strong>executor</strong></span>. The executor should take two parameters, that is, the <code class="literal">resolve</code> and <code class="literal">reject</code> callbacks. The <code class="literal">resolve</code> callback should be executed if the asynchronous operation was successful, and the <code class="literal">reject</code> callback should be executed if the operation was unsuccessful. If the asynchronous operation was successful and has a result, then we can pass the result of the asynchronous operation to the <code class="literal">resolve</code> callback. If the asynchronous operation was unsuccessful, then we can pass the reason of failure to the <code class="literal">reject</code> callback.</p><p>Here is a code example, which demonstrates how to create a Promise and wrap an AJAX request using it:</p><div class="informalexample"><pre class="programlisting">var promise = new Promise(function(resolve, reject){

  var request = new XMLHttpRequest();
  var url = "data.json";

  request.open("GET", url);

  request.addEventListener("load", function(){
    if(request.status === 200)
    {
      resolve(request.responseText);
    }
    else
    {
      reject("Server Error: " + request.status);
    }
  }, false);

  request.addEventListener("error", function(){
    reject("Cannot Make AJAX Request");
  }, false);

  request.send();

});</pre></div><p>The executor is executed synchronously. But the executor is executing an asynchronous operation and therefore, the executor can return before the asynchronous operation is finished.</p><p>A Promise is always<a id="id262" class="indexterm"/> in one of these states:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fulfilled</strong></span>: If the <code class="literal">resolve</code> callback<a id="id263" class="indexterm"/> is invoked with a non-Promise<a id="id264" class="indexterm"/> object as argument or no argument, then we say that the Promise is fulfilled</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rejected</strong></span>: If the <code class="literal">reject</code> callback is<a id="id265" class="indexterm"/> invoked or an exception occurs in the executor scope, then we say that the Promise is rejected</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pending</strong></span>: If the <code class="literal">resolve</code> or <code class="literal">reject</code> callback <a id="id266" class="indexterm"/>is yet to be invoked, then we say that the Promise is pending</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Settled</strong></span>: A Promise is <a id="id267" class="indexterm"/>said to be settled if it's either fulfilled or rejected, but not pending</li></ul></div><p>Once a Promise is fulfilled or rejected, it cannot be transitioned back. An attempt to transition it will have no effect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>If the <code class="literal">resolve</code> callback is invoked with a Promise object as an argument, then the Promise object is either fulfilled or rejected, depending on whether the passed Promise object is fulfilled or rejected.</p></div></div></div><div class="section" title="The fulfillment value"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec71"/>The fulfillment value</h2></div></div></div><p>The fulfillment value of a<a id="id268" class="indexterm"/> fulfilled Promise represents the result of a successful asynchronous operation.</p><p>If the argument that we passed to the <code class="literal">resolve</code> callback is anything other than another Promise object, then the argument itself is considered as a fulfillment value of the Promise object.</p><p>If we pass nothing to the <code class="literal">resolve</code> callback, then the fulfillment value is considered as <code class="literal">undefined,</code> and the Promise is considered to be fulfilled.</p><p>To see what happens when we pass a Promise object as an argument to the <code class="literal">resolve</code> callback, consider this example—suppose we have a Promise named A. Promise A's <code class="literal">resolve</code> callback was called by passing Promise B as argument then Promise A is said to be fulfilled if Promise B is fulfilled and the fulfillment value of Promise A now is same as the fulfillment value of Promise B.</p><p>Consider this code example:</p><div class="informalexample"><pre class="programlisting">var a = new Promise(function(resolve, reject){
  var b = new Promise(function(res, rej){
    rej("Reason");
  });

  resolve(b);
});

var c = new Promise(function(resolve, reject){
  var d = new Promise(function(res, rej){
    res("Result");
  });

  resolve(d);
});</pre></div><p>In the previous example, as<a id="id269" class="indexterm"/> Promise B gets rejected, therefore Promise A also gets rejected. The reason for the rejection of both the Promises is the string called <code class="literal">"Reason"</code>. Similarly, C gets fulfilled if D gets fulfilled. The fulfillment value of C and D is the string called <code class="literal">"Result"</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>When we say that "a Promise resolves with a value, or is resolved with a value," it means that the executor of the Promise invokes or has invoked the <code class="literal">resolve</code> callback with the value.</p></div></div></div><div class="section" title="The then(onFulfilled, onRejected) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec72"/>The then(onFulfilled, onRejected) method</h2></div></div></div><p>The <code class="literal">then()</code> method of a <a id="id270" class="indexterm"/>Promise object lets us do some task after a Promise has been fulfilled or rejected. The task can also be another event-driven or callback-based asynchronous operation.</p><p>The <code class="literal">then()</code> method of a Promise object takes two arguments, that is, the <code class="literal">onFulfilled</code> and <code class="literal">onRejected</code> callbacks. The <code class="literal">onFulfilled</code> callback is executed if the Promise object was fulfilled, and the <code class="literal">onRejected</code> callback is executed if the Promise was rejected.</p><p>The <code class="literal">onRejected</code> callback is also executed if an exception is thrown in the scope of the executor. Therefore, it behaves like an exception handler, that is, it catches the exceptions.</p><p>The <code class="literal">onFulfilled</code> callback takes a parameter, that is, the fulfillment value of the Promise. Similarly, the <code class="literal">onRejected</code> callback takes a parameter, that is, the reason of rejection.</p><p>The callbacks passed <a id="id271" class="indexterm"/>to the <code class="literal">then()</code> method are executed asynchronously.</p><p>Here is the code example to demonstrate the <code class="literal">then()</code> method:</p><div class="informalexample"><pre class="programlisting">var promise = new Promise(function(resolve, reject){
  var request = new XMLHttpRequest();
  var url = "data.json";
  request.open("GET", url);
  request.addEventListener("load", function(){
    if(request.status === 200)
    {
      resolve(request.responseText);
    }
    else
    {
      reject("Server Error: " + request.status);
    }
  }, false);
  request.addEventListener("error", function(){
    reject("Cannot Make AJAX Request");
  }, false);

  request.send();
});

promise.then(function(value){
  value = JSON.parse(value);
  return value;
}, function(reason){
  console.log(reason);
});</pre></div><p>Here, if the AJAX request was successful (that is, the Promise was fulfilled), then the <code class="literal">onFulfilled</code> callback is executed by passing the response text as the argument. The <code class="literal">onFulfilled</code> callback converts the JSON string into the JavaScript object. The <code class="literal">onFulfilled</code> callback returns the JavaScript object.</p><p>Many programmers remove the Promise object variable, and write the preceding code in this way:</p><div class="informalexample"><pre class="programlisting">function ajax()
{
  return new Promise(function(resolve, reject){
    var request = new XMLHttpRequest();
    var url = "data.json";
    request.open("GET", url);
    request.addEventListener("load", function(){
      if(request.status === 200)
      {
        resolve(request.responseText);
      }
      else
      {
        reject("Server Error: " + request.status);
      }
    }, false);
    request.addEventListener("error", function(){
      reject("Cannot Make AJAX Request");
    }, false);

    request.send();
  });
}

ajax().then(function(value){
  value = JSON.parse(value);
  return value;
}, function(reason){
  console.log(reason);
});</pre></div><p>This style makes<a id="id272" class="indexterm"/> the code even easier to read. All the new JavaScript APIs that are implemented using Promises come in this pattern.</p><p>The <code class="literal">then()</code> method always returns a new <code class="literal">promise</code> object, which resolves the return value of the calling callback. Here is how a new <code class="literal">promise</code> object is returned by the <code class="literal">then()</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the <code class="literal">onFulfilled</code> callback is called and there is no return statement in it, then a new fulfilled Promise is created internally and returned.</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">onFulfilled</code> callback is called and we return a custom Promise, then it internally creates and returns a new <code class="literal">promise</code> object. The new Promise object resolves the custom Promise object.</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">onFulfilled</code> callback is called and we return something else other than a custom Promise, then also a new Promise object is created internally and returned. The new Promise object resolves the return value.</li><li class="listitem" style="list-style-type: disc">If we pass <code class="literal">null</code> instead of the <code class="literal">onFulfilled</code> callback, then a callback is created internally and replaced with the <code class="literal">null</code>. The internally created <code class="literal">onFulfilled</code> returns a new fulfilled <code class="literal">promise</code> object. The fulfillment value of the new <code class="literal">promise</code> object is same as the fulfillment value of the parent Promise.</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">onRejected</code> callback is called and there is no return statement in it, then a new rejected Promise is created internally and returned.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">onRejected</code> callback is called and we return a custom Promise, then it internally creates and returns a new <code class="literal">promise</code> object. The new <code class="literal">promise</code> object resolves the custom <code class="literal">promise</code> object.</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">onRejected</code> callback is called and we return something else other than a custom Promise, then also a new <code class="literal">promise</code> object is created internally and returned. The new <code class="literal">promise</code> object resolves the returned value.</li><li class="listitem" style="list-style-type: disc">If we pass <code class="literal">null</code> instead of the <code class="literal">onRejected</code> callback, or omit it, then a callback is created internally and is used instead. The internally created <code class="literal">onRejected</code> callback returns a new rejected <code class="literal">promise</code> object. The reason of rejection of the new <code class="literal">promise</code> object is same as the reason of rejection of the parent Promise.</li></ul></div><p>In the previous <a id="id273" class="indexterm"/>code example, we haven't yet logged the retrieved data to console. We can chain Promises to do this. And also in the previous code, we do not handle the exceptions that might occur in the <code class="literal">onFulfilled</code> callback. Here is how we can expand the code to log data and also handle exceptions of all the <code class="literal">onFulfilled</code> callbacks chained:</p><div class="informalexample"><pre class="programlisting">function ajax()
{
  return new Promise(function(resolve, reject){
    var request = new XMLHttpRequest();
    var url = "data.json";
    request.open("GET", url);
    request.addEventListener("load", function(){
      if(request.status === 200)
      {
        resolve(request.responseText);
      }
      else
      {
        reject("Server Error: " + request.status);
      }
    }, false);
    request.addEventListener("error", function(){
      reject("Cannot Make AJAX Request");
    }, false);

    request.send();
  });
}

ajax().then(function(value){
  value = JSON.parse(value);
  return value;
}).then(function(value){
  console.log(value.Name);
  return value;
}).then(function(value){
  console.log(value.Profession);
  return value;
}).then(function(value){
  console.log(value.Age);
  return value;
}).then(null, function(reason){
  console.log(reason);
});</pre></div><p>In this code example, we <a id="id274" class="indexterm"/>chained multiple Promises using the <code class="literal">then()</code> method to parse and log the response received by the executor of the first Promise of the chain. Here, the last <code class="literal">then()</code> method is used as an exception or error handler for all the <code class="literal">onFulfilled</code> methods and executors.</p><p>Here is an image that shows how the execution of multiple chained Promises work:</p><div class="mediaobject"><img src="graphics/4197_04_01.jpg" alt="The then(onFulfilled, onRejected) method"/><div class="caption"><p>Image courtesy of MDN</p></div></div><p>Let's go ahead and add an <a id="id275" class="indexterm"/>event driven asynchronous operation to the chain, that is, to verify if the data displayed is correct or not. Here is how we can expand the code to do this:</p><div class="informalexample"><pre class="programlisting">function ajax()
{
  return new Promise(function(resolve, reject){
    var request = new XMLHttpRequest();
    var url = "http://localhost:8888/data.json";
    request.open("GET", url);
    request.addEventListener("load", function(){
      if(request.status === 200)
      {
        resolve(request.responseText);
      }
      else
      {
        reject("Server Error: " + request.status);
      }
    }, false);
    request.addEventListener("error", function(){
      reject("Cannot Make AJAX Request");
    }, false);

    request.send();
  });
}

function verify(value)
{
  return new Promise(function(resolve, reject){
    if(value == true)
    {
      //make AJAX request to send data to server
    }
    else
    {
      //make AJAX request to send data to server
    }
  });
}

ajax().then(function(value){
  value = JSON.parse(value);
  return value;
}).then(function(value){
  console.log(value.Name);
  return value;
}).then(function(value){
  console.log(value.Profession);
  return value;
}).then(function(value){
  console.log(value.Age);
  return value;
}).then(function(value){
  var result = confirm("Is the data correct?");
  return result;
}).then(verify).then(null, function(reason){
  console.log(reason);
});</pre></div><p>Now we can see how<a id="id276" class="indexterm"/> wrapping the AJAX operation with Promises made the code easier to read and write. Now the code is more understandable at first glance.</p></div><div class="section" title="The catch(onRejected) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec73"/>The catch(onRejected) method</h2></div></div></div><p>The <code class="literal">catch()</code> method of a <code class="literal">promise</code> object is<a id="id277" class="indexterm"/> used instead of the <code class="literal">then()</code> method, when we use the <code class="literal">then()</code> method only to handle errors and exceptions. There is nothing special about how the <code class="literal">catch()</code> method works. It's just that it makes the code much easier to read, as the word "catch" makes it more meaningful.</p><p>The <code class="literal">catch()</code> method just takes one argument, that is, the <code class="literal">onRejected</code> callback. The <code class="literal">onRejected</code> callback of the <code class="literal">catch()</code> method is invoked in the same way as the <code class="literal">onRejected</code> callback of the <code class="literal">then()</code> method.</p><p>The <code class="literal">catch()</code> method always returns a Promise. Here is how a new <code class="literal">promise</code> object is returned by the <code class="literal">catch()</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If there is no return statement in the <code class="literal">onRejected</code> callback, then a new fulfilled Promise is created internally and returned.</li><li class="listitem" style="list-style-type: disc">If we return a custom Promise, then it internally creates and returns a new <code class="literal">promise</code> object. The new <code class="literal">promise</code> object resolves the custom <code class="literal">promise</code> object.</li><li class="listitem" style="list-style-type: disc">If we return something else other than a custom Promise in the <code class="literal">onRejected</code> callback, then also a new <code class="literal">promise</code> object is created internally and returned. The new <code class="literal">promise</code> object resolves the returned value.</li><li class="listitem" style="list-style-type: disc">If we pass <code class="literal">null</code> instead of the <code class="literal">onRejected</code> callback, or omit it, then a callback is created internally and used instead. The internally created <code class="literal">onRejected</code> callback returns a rejected <code class="literal">promise</code> object. The reason for the rejection of the new <code class="literal">promise</code> object is same as the reason for the rejection of a parent <code class="literal">promise</code> object.</li><li class="listitem" style="list-style-type: disc">If the <code class="literal">promise</code> object to which <code class="literal">catch()</code> is called gets fulfilled, then the <code class="literal">catch()</code> method simply returns a new fulfilled <code class="literal">promise</code> object and ignores the <code class="literal">onRejected</code> callback. The fulfillment value of the new <code class="literal">promise</code> object is same as the fulfillment value of the parent Promise.</li></ul></div><p>To understand <a id="id278" class="indexterm"/>the <code class="literal">catch()</code> method, consider this code:</p><div class="informalexample"><pre class="programlisting">promise.then(null, function(reason){
});</pre></div><p>This code can be rewritten in this way using the <code class="literal">catch()</code> method:</p><div class="informalexample"><pre class="programlisting">promise.catch(function(reason){
});</pre></div><p>These two code snippets work exactly in the same way.</p><p>Let's rewrite the AJAX code example by replacing the last chained <code class="literal">then()</code> method with the <code class="literal">catch()</code> method:</p><div class="informalexample"><pre class="programlisting">function ajax()
{
  return new Promise(function(resolve, reject){
    var request = new XMLHttpRequest();
    var url = "data.json";
    request.open("GET", url);
    request.addEventListener("load", function(){
      if(request.status === 200)
      {
        resolve(request.responseText);
      }
      else
      {
        reject("Server Error: " + request.status);
      }
    }, false);
    request.addEventListener("error", function(){
      reject("Cannot Make AJAX Request");
    }, false);

    request.send();
  });
}

function verify(value)
{
  return new Promise(function(resolve, reject){
    if(value == true)
    {
      //make AJAX request to send data to server
    }
    else
    {
      //make AJAX request to send data to server
    }
  });
}

ajax().then(function(value){
  value = JSON.parse(value);
  return value;
}).then(function(value){
  console.log(value.Name);
  return value;
}).then(function(value){
  console.log(value.Profession);
  return value;
}).then(function(value){
  console.log(value.Age);
  return value;
}).then(function(value){
  var result = confirm("Is the data correct?");
  return result;
}).then(verify)
.catch(function(reason){
  console.log(reason);
});</pre></div><p>Now the code <a id="id279" class="indexterm"/>is even easier to read at first glance.</p></div><div class="section" title="The Promise.resolve(value) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec74"/>The Promise.resolve(value) method</h2></div></div></div><p>The <code class="literal">resolve()</code> method of<a id="id280" class="indexterm"/> the <code class="literal">Promise</code> object takes a value and returns a <code class="literal">promise</code> object that resolves the passed value.</p><p>The <code class="literal">resolve()</code> method is basically used to convert a value to an <code class="literal">promise</code> object. It is useful when you find yourself with a value that may or may not be a Promise, but you want to use it as a Promise. For example, the jQuery Promises have different interfaces than the ES6 Promises. Therefore, you can use the <code class="literal">resolve()</code> method to convert the jQuery Promises into the ES6 Promises.</p><p>Here is code example that demonstrates how to use the <code class="literal">resolve()</code> method:</p><div class="informalexample"><pre class="programlisting">var p1 = Promise.resolve(4);
p1.then(function(value){
  console.log(value);
});

//passed a promise object
Promise.resolve(p1).then(function(value){
  console.log(value);
});

Promise.resolve({name: "Eden"}).then(function(value){
  console.log(value.name);
});</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">4
4
Eden</pre></div></div><div class="section" title="The Promise.reject(value) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec75"/>The Promise.reject(value) method</h2></div></div></div><p>The <code class="literal">reject()</code> method <a id="id281" class="indexterm"/>of the <code class="literal">Promise</code> object takes a value and returns a rejected <code class="literal">promise</code> object with the passed value as the reason.</p><p>Unlike <code class="literal">Promise.resolve()</code> method, the <code class="literal">reject()</code> method is used for debugging purposes and not for converting values into Promises.</p><p>Here is code example that demonstrates how to use the <code class="literal">reject()</code> method:</p><div class="informalexample"><pre class="programlisting">var p1 = Promise.reject(4);
p1.then(null, function(value){
  console.log(value);
});

Promise.reject({name: "Eden"}).then(null, function(value){
  console.log(value.name);
});</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">4
Eden</pre></div></div><div class="section" title="The Promise.all(iterable) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec76"/>The Promise.all(iterable) method</h2></div></div></div><p>The <code class="literal">all()</code> method of the <code class="literal">Promise</code> object <a id="id282" class="indexterm"/>takes an iterable object as an argument and returns a Promise that fulfills when all of the Promises in the iterable object have been fulfilled.</p><p>This can be useful when we want to execute some task after some asynchronous operations have finished.</p><p>Here is code example which demonstrates how to use the <code class="literal">Promise.all()</code> method:</p><div class="informalexample"><pre class="programlisting">var p1 = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve();
  }, 1000);
});

var p2 = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve();
  }, 2000);
});

var arr = [p1, p2];

Promise.all(arr).then(function(){
  console.log("Done"); //"Done" is logged after 2 seconds
});</pre></div><p>If the iterable object contains a value that is not a <code class="literal">promise</code> object, then it's converted to the Promise object using the <code class="literal">Promise.resolve()</code> method.</p><p>In case any of the passed Promises get rejected, then the <code class="literal">Promise.all()</code> method immediately returns a new rejected Promise for the same reason as the rejected passed Promise. Here is an example to demonstrate this:</p><div class="informalexample"><pre class="programlisting">var p1 = new Promise(function(resolve, reject){
  setTimeout(function(){
    reject("Error");
  }, 1000);
});

var p2 = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve();
  }, 2000);
});

var arr = [p1, p2];

Promise.all(arr).then(null, function(reason){
  console.log(reason); //"Error" is logged after 1 second
});</pre></div></div><div class="section" title="The Promise.race(iterable) method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec77"/>The Promise.race(iterable) method</h2></div></div></div><p>The the <code class="literal">race()</code> method of the <code class="literal">Promise</code> object takes<a id="id283" class="indexterm"/> an iterable object as the argument and returns a Promise that fulfills or rejects as soon as one of the Promises in the iterable object is fulfilled or rejected, with the fulfillment value or reason from that Promise.</p><p>As the name suggests, the <code class="literal">race()</code> method is used to race between Promises and see which one finishes first.</p><p>Here is code example that shows how to use the <code class="literal">race()</code> method:</p><div class="informalexample"><pre class="programlisting">var p1 = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve("Fulfillment Value 1");
  }, 1000);
});

var p2 = new Promise(function(resolve, reject){
  setTimeout(function(){
    resolve("fulfillment Value 2");
  }, 2000);
});

var arr = [p1, p2];

Promise.race(arr).then(function(value){
  console.log(value); //Output "Fulfillment value 1"
}, function(reason){
  console.log(reason);
});</pre></div></div></div>
<div class="section" title="The JavaScript APIs based on Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>The JavaScript APIs based on Promises</h1></div></div></div><p>The new asynchronous<a id="id284" class="indexterm"/> JavaScript APIs are now based on the Promise pattern instead of events and callbacks. And the new versions of the old JavaScript APIs are now based on Promises.</p><p>For example, the old version of the Battery status API and the Web Cryptography API were based on event, but the new versions of these APIs are purely implemented using Promises. Let's see an overview of these APIs.</p><div class="section" title="The Battery Status API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec78"/>The Battery Status API</h2></div></div></div><p>The Battery Status API <a id="id285" class="indexterm"/>provides us the battery's current charge level and charging status. Here is<a id="id286" class="indexterm"/> a code example of the new Battery Status API:</p><div class="informalexample"><pre class="programlisting">navigator.getBattery().then(function(value){
  console.log("Batter Level: " + (value.level * 100));
}, function(reason){
  console.log("Error: " + reason);
});</pre></div><p>The <code class="literal">getBattery()</code> method of the <code class="literal">navigator</code> object returns a fulfilled Promise if it has successfully retrieved the battery information. Otherwise, it returns a rejected Promise.</p><p>If the Promise is fulfilled, then the fulfillment value is an object holding the battery information. The <code class="literal">level</code> property of the fulfillment value represents the level of charge remaining.</p></div><div class="section" title="The Web Cryptography API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec79"/>The Web Cryptography API</h2></div></div></div><p>The <a id="id287" class="indexterm"/>Web Cryptography API<a id="id288" class="indexterm"/> lets us do hashing, signature generation and verification, encryption and decryption.</p><p>Here is a code example of the new Web Cryptography API:</p><div class="informalexample"><pre class="programlisting">function convertStringToArrayBufferView(str)
{
    var bytes = new Uint8Array(str.length);
    for (var iii = 0; iii &lt; str.length; iii++)
    {
        bytes[iii] = str.charCodeAt(iii);
    }

    return bytes;
}

function convertArrayBufferToHexaDecimal(buffer)
{
    var data_view = new DataView(buffer)
    var iii, len, hex = '', c;

    for(iii = 0, len = data_view.byteLength; iii &lt; len; iii++)
    {
        c = data_view.getUint8(iii).toString(16);
        if(c.length &lt; 2)
        {
            c = '0' + c;
        }

        hex += c;
    }

    return hex;
}


window.crypto.subtle.digest({name: "SHA-256"}, convertStringToArrayBufferView("ECMAScript 6")).then(function(result){
  var hash_value = convertArrayBufferToHexaDecimal(result);
  console.log(hash_value);
});</pre></div><p>In this code example, we will find the SHA-256 hash value of a string.</p><p>The <code class="literal">window.crypto.subtle.digest</code> method takes an array buffer of a string and hash the algorithm name, and<a id="id289" class="indexterm"/> returns a Promise <a id="id290" class="indexterm"/>object. If it has successfully produced the hashes value, then it returns a fulfilled Promise and the fulfillment value is an array buffer representing the hash value.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we learned how JavaScript executes the asynchronous code. We learned about the different patterns of writing asynchronous code. We saw how Promises make it easier to read and write the asynchronous code, and how to use the ES6 Promise API. We also saw some JavaScript APIs that are based on Promises. Overall, the chapter aimed at explaining Promises, their benefits, and how to use APIs that are based on them.</p><p>In the next chapter, we will learn about ES6 Reflect API and its uses.</p></div></body></html>