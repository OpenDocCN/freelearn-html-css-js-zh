<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor018" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor019" class="pcalibre1 calibre6 pcalibre"/>1</h1>
<h1 id="_idParaDest-16" class="calibre5"><a id="_idTextAnchor020" class="pcalibre1 calibre6 pcalibre"/>Working with Creational Design Patterns</h1>
<p class="calibre3">JavaScript design patterns are techniques that allow us to write more robust, scalable, and extensible applications in JavaScript. JavaScript is a very popular programming language, in part due to its place as a way to deliver interactive functionality on web pages. The other reason for its popularity is JavaScript’s lightweight, dynamic, multi-paradigm nature, which means that design patterns from other ecosystems can be adapted to take advantage of JavaScript’s strengths. JavaScript’s specific strengths and weaknesses can also inform new patterns specific to the language and the contexts in which it’s used.</p>
<p class="calibre3">Creational design patterns<a id="_idIndexMarker000" class="pcalibre1 calibre6 pcalibre"/> give structure to object creation, which enables the development of systems and applications where different modules, classes, and objects don’t need to know how to create instances of each other. The design patterns most relevant to JavaScript – the prototype, singleton, and factory patterns – will be explored, as well as situations where they’re helpful and how to implement them in an idiomatic fashion.</p>
<p class="calibre3">We’ll cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">A comprehensive definition of creational design patterns and definitions for the prototype, singleton, and factory patterns</li>
<li class="calibre11">Multiple implementations of the prototype pattern and its use cases</li>
<li class="calibre11">An implementation of the singleton design pattern, eager and lazy initialization, use cases for singleton, and what a singleton pattern in modern JavaScript looks like</li>
<li class="calibre11">How to implement the factory pattern using classes, a modern JavaScript alternative, and use cases</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to identify when a creational design pattern is useful and make an informed decision on which of its multiple implementations to use, ranging from a more idiomatic JavaScript form to a classical form.<a id="_idTextAnchor021" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-17" class="calibre5"><a id="_idTextAnchor022" class="pcalibre1 calibre6 pcalibre"/>What are creational design patterns?</h1>
<p class="calibre3">Creational design patterns<a id="_idIndexMarker001" class="pcalibre1 calibre6 pcalibre"/> handle object creation. They allow a consumer to create object instances without knowing the details of how to instantiate the object. Since, in object-oriented languages, instantiation of objects is limited to a class’s constructor, allowing object instances to be created without calling the constructor is useful to reduce noise and tight coupling between the consumer and the class being instantiated.</p>
<p class="calibre3">In JavaScript, there’s ambiguity when we discuss “object creation,” since JavaScript’s multi-paradigm nature means we can create objects without a class or a constructor. For example, in JavaScript this is an object creation using an object literal – <code>const config = { forceUpdate: true</code> <code>}</code>. In fact, modern idiomatic JavaScript tends to lean more toward procedural and function paradigms than object orientation. This means that creational design patterns may have to be adapted to be fully useful in JavaScript.</p>
<p class="calibre3">In summary, creational design patterns are useful in object-oriented JavaScript, since they hide instantiation details from consumers, which keeps coupling low, thereby allowing better module separation.</p>
<p class="calibre3">In the next section, we’ll encounter our first creational design pattern – the prototype design pattern<a id="_idTextAnchor023" class="pcalibre1 calibre6 pcalibre"/>.</p>
<h1 id="_idParaDest-18" class="calibre5"><a id="_idTextAnchor024" class="pcalibre1 calibre6 pcalibre"/>Implementing the prototype pattern in JavaScript</h1>
<p class="calibre3">Let’s start with a definition<a id="_idIndexMarker002" class="pcalibre1 calibre6 pcalibre"/> of the prototype pattern<a id="_idIndexMarker003" class="pcalibre1 calibre6 pcalibre"/> fir<a id="_idTextAnchor025" class="pcalibre1 calibre6 pcalibre"/>st.</p>
<p class="calibre3">The prototype design pattern allows us to create an instance based on another existing instance (our prototype).</p>
<p class="calibre3">In more formal terms, a <code>prototype</code> class exposes a <code>clone()</code> method. Consuming code, instead of calling <code>new SomeClass</code>, will call <code>new</code> <code>SomeClassPrototype(someClassInstance).clone()</code>. This method call will return a <code>new SomeClass</code> instance with all the values copied from <code>someClassInstan<a id="_idTextAnchor026" class="pcalibre1 calibre6 pcalibre"/>ce</code>.</p>
<h2 id="_idParaDest-19" class="calibre7"><a id="_idTextAnchor027" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">Let’s imagine a scenario<a id="_idIndexMarker004" class="pcalibre1 calibre6 pcalibre"/> where we’re building a chessboard. There are two key types of squares – white and black. In addition to this information, each square contains information such as its row, file, and which piece sits atop it.</p>
<p class="calibre3">A <code>BoardSquare</code> class constructor might look like the following:</p>
<pre class="source-code">
class BoardSquare {
  constructor(color, row, file, startingPiece) {
    this.color = color;
    this.row = row;
    this.file = file;
  }
}</pre> <p class="calibre3">A set of useful methods on <code>BoardSquare</code> might be <code>occupySquare</code> and <code>clearSquare</code>, as follows:</p>
<pre class="source-code">
class BoardSquare {
  // no change to the rest of the class
  occupySquare(piece) {
    this.piece = piece;
  }
  clearSquare() {
    this.piece = null;
  }
}</pre> <p class="calibre3">Instantiating <code>BoardSquare</code> is quite cumbersome, due to all its properties:</p>
<pre class="source-code">
const whiteSquare = new BoardSquare('white');
const whiteSquareTwo = new BoardSquare('white');
// ...
const whiteSquareLast = new BoardSquare('white');</pre> <p class="calibre3">Note the repetition of arguments<a id="_idIndexMarker005" class="pcalibre1 calibre6 pcalibre"/> being passed to <code>new BoardSquare</code>, which will cause issues if we want to change all board squares to black. We would need to change the parameter passed to each call of <code>BoardSquare</code> is one by one for each <code>new BoardSquare</code> call. This can be quite error-prone; all it takes is one hard-to-find mistake in the <code>color</code> value to cause a bug:</p>
<pre class="source-code">
const blackSquare = new BoardSquare('black');
const blackSquareTwo = new BoardSquare('black');
// ...
const blackSquareLast = new BoardSquare('black');</pre> <p class="calibre3">Implementing our instantiation logic using a classical prototype looks as follows. We need a <code>BoardSquarePrototype</code> class; its constructor takes a <code>prototype</code> property, which it stores on the instance. <code>BoardSquarePrototype</code> exposes a <code>clone()</code> method that takes no arguments and returns a <code>BoardSquare</code> instance, with all the properties of <code>prototype</code> copied onto it:</p>
<pre class="source-code">
class BoardSquarePrototype {
  constructor(prototype) {
    this.prototype = prototype;
  }
  clone() {
    const boardSquare = new BoardSquare();
    boardSquare.color = this.prototype.color;
    boardSquare.row = this.prototype.row;
    boardSquare.file = this.prototype.file;
    return boardSquare;
  }
}</pre> <p class="calibre3">Using <code>BoardSquarePrototype</code> requires<a id="_idIndexMarker006" class="pcalibre1 calibre6 pcalibre"/> the following steps:</p>
<ol class="calibre15">
<li class="calibre11">First, we want an instance of <strong class="source-inline1">BoardSquare</strong> to initialize – in this case, with <strong class="source-inline1">'white'</strong>. It will then be passed as the <strong class="source-inline1">prototype</strong> property during the <strong class="source-inline1">BoardSquarePrototype</strong> constructor call:<pre class="source-code">
const whiteSquare = new BoardSquare('white');
const whiteSquarePrototype = new BoardSquarePrototype
  (whiteSquare);</pre></li> <li class="calibre11">We can then use <strong class="source-inline1">whiteSquarePrototype</strong> with <strong class="source-inline1">.clone()</strong> to create our copies of <strong class="source-inline1">whiteSquare</strong>. Note that <strong class="source-inline1">color</strong> is copied over but each call to <strong class="source-inline1">clone()</strong> returns a new instance.<pre class="source-code">
const whiteSquareTwo = whiteSquarePrototype.clone();
// ...
const whiteSquareLast = whiteSquarePrototype.clone();
console.assert(
  whiteSquare.color === whiteSquareTwo.color &amp;&amp;
    whiteSquareTwo.color === whiteSquareLast.color,
  'Prototype.clone()-ed instances have the same color
     as the prototype'
);
console.assert(
  whiteSquare !== whiteSquareTwo &amp;&amp;
    whiteSquare !== whiteSquareLast &amp;&amp;
    whiteSquareTwo !== whiteSqua<a id="_idTextAnchor028" class="pcalibre1 calibre16 pcalibre"/>reLast,
  'each Prototype.clone() call outputs a different
     instanc<a id="_idTextAnchor029" class="pcalibre1 calibre16 pcalibre"/>es'
);</pre></li> </ol>
<p class="calibre3">Per the assertions in the<a id="_idIndexMarker007" class="pcalibre1 calibre6 pcalibre"/> code, the cloned instances contain the same value for <code>color</code> but are different instances of the <code>Square</code> object.</p>
<h2 id="_idParaDest-20" class="calibre7"><a id="_idTextAnchor030" class="pcalibre1 calibre6 pcalibre"/>A use case</h2>
<p class="calibre3">To illustrate what it would<a id="_idIndexMarker008" class="pcalibre1 calibre6 pcalibre"/> take to change from a white square to a black square, let’s look at some sample code where <code>'white'</code> is not referenced in the variable names:</p>
<pre class="source-code">
const boardSquare = new BoardSquare('white');
const boardSquarePrototype = new BoardSquarePrototype(boardSquare);
const boardSquareTwo = boardSquarePrototype.clone();
// ...
const boardSquareLast = boardSquarePrototype.clone();
console.assert(
  boardSquareTwo.color === 'white' &amp;&amp;
    boardSquare.color === boardSquareTwo.color &amp;&amp;
    boardSquareTwo.color === boardSquareLast.color,
  'Prototype.clone()-ed instances have the same color as
     the prototype'
);
console.assert(
  boardSquare !== boardSquareTwo &amp;&amp;
    boardSquare !== boardSquareLast &amp;&amp;
    boardSquareTwo !== boardSquareLast,
  'each Prototype.clone() call outputs a different
    instances'
);</pre> <p class="calibre3">In this scenario, we would <a id="_idIndexMarker009" class="pcalibre1 calibre6 pcalibre"/>only have to change the <code>color</code> value passed to <code>BoardSquare</code> to change the color of all the instances cloned from the prototype:</p>
<pre class="source-code">
const boardSquare = new BoardSquare('black');
// rest of the code stays the same
console.assert(
  boardSquareTwo.color === 'black' &amp;&amp;
    boardSquare.color === boardSquareTwo.color &amp;&amp;
    boardSquareTwo.color === boardSquareLast.color,
  'Prototype.clone()-ed instances have the same color as
     the prototype'
);
console.assert(
  boardSquare !== boardSquareTwo &amp;&amp;
    boardSquare !== boardSquareLast &amp;&amp;
    boardSquareTwo !== boardSquareLast,
  'each Prototype.clone() call outputs a different
     instances'
);</pre> <p class="calibre3">The prototype pattern is useful in situations where a “template” for the object instances is useful. It’s a good pattern to create a “default object” but with custom values. It allows faster and easier changes, since they are implemented<a id="_idIndexMarker010" class="pcalibre1 calibre6 pcalibre"/> once on the template object but are applied to all <code>clone()</code>-ed <a id="_idTextAnchor031" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor032" class="pcalibre1 calibre6 pcalibre"/>instances.</p>
<h3 class="calibre9">Increasing robustness to change in the prototype’s instance variables with modern JavaScript</h3>
<p class="calibre3">There are improvements<a id="_idIndexMarker011" class="pcalibre1 calibre6 pcalibre"/> we can make to our prototype implementation in JavaScript.</p>
<p class="calibre3">The first is in the <code>clone()</code> method. To make our prototype class robust to changes in the prototype’s constructor/instance variables, we should avoid copying the properties one by one.</p>
<p class="calibre3">For example, if we add a new <code>startingPiece</code> parameter that the <code>BoardSquare</code> constructor takes and sets the <code>piece</code> instance variable to, our current implementation of <code>BoardSquarePrototype</code> will fail to copy it, since it only copies <code>color</code>, <code>row</code>, and <code>file</code>:</p>
<pre class="source-code">
class BoardSquare {
  constructor(color, row, file, startingPiece) {
    this.color = color;
    this.row = row;
    this.file = file;
    this.piece = startingPiece;
  }
  // same rest of the class
}
const boardSquare = new BoardSquare('white', 1, 'A',
  'king');
const boardSquarePrototype = new BoardSquarePrototype
  (boardSquare);
const otherBoardSquare = boardSquarePrototype.clone();
console.assert(
  otherBoardSquare.piece === undefined,
  'prototype.piece was not copied over'
);</pre> <p class="callout-heading">Note</p>
<p class="callout">Reference<a id="_idIndexMarker012" class="pcalibre1 calibre6 pcalibre"/> for <strong class="source-inline1">Object.assign</strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" class="pcalibre1 calibre6 pcalibre">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a>.</p>
<p class="calibre3">If we amend our <code>BoardSquarePrototype</code> class to use <code>Object.assign(new BoardSquare(), this.prototype)</code>, it will copy <a id="_idIndexMarker013" class="pcalibre1 calibre6 pcalibre"/>all the enumerable properties of <code>prototype</code>:</p>
<pre class="source-code">
class BoardSquarePrototype {
  constructor(prototype) {
    this.prototype = prototype;
  }
  clone() {
    return Object.assign(new BoardSquare(), this.prototype);
  }
}
const boardSquare = new BoardSquare('white', 1, 'A',
  'king');
const boardSquarePrototype = new BoardSquarePrototype
  (boardSquare);
const otherBoardSquare = boardSquarePrototype.clone();
console.assert(
  otherBoardSquare.piece === 'king' &amp;&amp;
    otherBoardSquare.piece === boardSquare.piece,
  'prototype.piece was co<a id="_idTextAnchor033" class="pcalibre1 calibre16 pcalibre"/>pied over'
);</pre> <h3 class="calibre9">The prototype pattern without classes in JavaScript</h3>
<p class="calibre3">For historical reasons, JavaScript<a id="_idIndexMarker014" class="pcalibre1 calibre6 pcalibre"/> has a prototype concept deeply embedded into the language. In fact, classes were introduced much later into the ECMAScript standard, with ECMAScript 6, which was released in 2015 (for reference, ECMAScript 1 was published in 1997).</p>
<p class="calibre3">This is why a lot of JavaScript completely forgoes the use of classes. The JavaScript “object prototype” can be used to make objects inherit methods and variables from each other.</p>
<p class="calibre3">One way to clone objects is by using the <code>Object.create</code> to clone objects with their methods. This relies on the JavaScript prototype system:</p>
<pre class="source-code">
const square = {
  color: 'white',
  occupySquare(piece) {
    this.piece = piece;
  },
  clearSquare() {
    this.piece = null;
  },
};
const otherSquare = Object.create(square);</pre> <p class="calibre3">One subtlety here is that <code>Object.create</code> does not actually copy<a id="_idIndexMarker015" class="pcalibre1 calibre6 pcalibre"/> anything; it simply creates a new object and sets its prototype to <code>square</code>. This means that if properties are not found on <code>otherSquare</code>, they’re accessed on <code>square</code>:</p>
<pre class="source-code">
console.assert(otherSquare.__proto__ === square, 'uses JS
  prototype');
console.assert(
  otherSquare.occupySquare === square.occupySquare &amp;&amp;
    otherSquare.clearSquare === square.clearSquare,
  "methods are not copied, they're 'inherited' using the
     prototype"
);
delete otherSquare.color;
console.assert(
  otherSquare.color === 'white' &amp;&amp; otherSquare.color ===
    square.color,
  'data fields are also inherited'
);</pre> <p class="calibre3">A further note on the JavaScript prototype, and its existence before classes were part of JavaScript, is that subclassing<a id="_idIndexMarker016" class="pcalibre1 calibre6 pcalibre"/> in JavaScript is another syntax for setting an object’s prototype. Have a look at the following <code>extends</code> example. <code>BlackSquare extends Square</code> sets the <code>prototype.__proto__</code> property of <code>BlackSquare</code> to <code>Square.prototype</code>:</p>
<pre class="source-code">
class Square {
  constructor() {}
  occupySquare(piece) {
    this.piece = piece;
  }
  clearSquare() {
    this.piece = null;
  }
}
class BlackSquare extends Square {
  constructor() {
    super();
    this.color = 'black';
  }
}
console.assert(
  BlackSquare.prototype.__proto__ === Square.prototype,
  'subclass prototype has prototype of superclass'
);</pre> <p class="calibre3">In this section, we learned how to implement the prototype pattern with a prototype class that exposes a <code>clone()</code> method, which code situations the prototype patterns can help with, and how to further improve our prototype implementation with modern JavaScript features. We also covered the JavaScript “prototype,” why it exists, and its relationship<a id="_idIndexMarker017" class="pcalibre1 calibre6 pcalibre"/> with the prototype design pattern.</p>
<p class="calibre3">In the next part of the chapter, we’ll look at another creational design pattern, the singleton design pattern, with some implementation approaches in JavaScript a<a id="_idTextAnchor034" class="pcalibre1 calibre6 pcalibre"/>nd its use cases.</p>
<h1 id="_idParaDest-21" class="calibre5">The singleton pattern with eager and lazy initializat<a id="_idTextAnchor035" class="pcalibre1 calibre6 pcalibre"/>ion in JavaScript</h1>
<p class="calibre3">To begin, let’s define the singleton design pattern.</p>
<p class="calibre3">The singleton pattern<a id="_idIndexMarker018" class="pcalibre1 calibre6 pcalibre"/> allows an object<a id="_idIndexMarker019" class="pcalibre1 calibre6 pcalibre"/> to be instantiated <a id="_idIndexMarker020" class="pcalibre1 calibre6 pcalibre"/>only once, exposes<a id="_idIndexMarker021" class="pcalibre1 calibre6 pcalibre"/> this single instance to consumers, and controls the instantiation of the single instance.</p>
<p class="calibre3">The singleton is another way of getting access to an object instance without using a constructor, although it’s necessary for the object to be des<a id="_idTextAnchor036" class="pcalibre1 calibre6 pcalibre"/>igned as a singleton.</p>
<h2 id="_idParaDest-22" class="calibre7"><a id="_idTextAnchor037" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">A classic example of a singleton<a id="_idIndexMarker022" class="pcalibre1 calibre6 pcalibre"/> is a logger. It’s rarely necessary (and often, it’s a problem) to instantiate multiple loggers in an application. Having a singleton means the initialization site is controlled, and the logger configuration will be consistent across the application – for example, the log level won’t change depending on where in the application we call the logger from.</p>
<p class="calibre3">A simple logger looks something as follows, with a constructor taking <code>logLevel</code> and <code>transport</code>, and an <code>isLevelEnabled</code> private method, which allows us to drop logs that the logger is not configured to keep (for example, when the level is <code>warn</code> we drop <code>info</code> messages). The logger finally implements the <code>info</code>, <code>warn</code>, and <code>error</code> methods, which behave as previously described; they only call the relevant <code>transport</code> method if the level is “enabled” (i.e., “above” what the configured log level is).</p>
<p class="calibre3">The possible <code>logLevel</code> values<a id="_idIndexMarker023" class="pcalibre1 calibre6 pcalibre"/> that power <code>isLevelEnabled</code> are stored as a static field on <code>Logger</code>:</p>
<pre class="source-code">
class Logger {
  static logLevels = ['info', 'warn', 'error'];
  constructor(logLevel = 'info', transport = console) {
    if (Logger.#loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
           instead'
      );
    }
    this.logLevel = logLevel;
    this.transport = transport;
  }
  isLevelEnabled(targetLevel) {
    return (
      Logger.logLevels.indexOf(targetLevel) &gt;=
      Logger.logLevels.indexOf(this.logLevel)
    );
  }
  info(message) {
    if (this.isLevelEnabled('info')) {
      return this.transport.info(message);
    }
  }
  warn(message) {
    if (this.isLevelEnabled('warn')) {
      this.transport.warn(message);
    }
  }
  error(message) {
    if (this.isLevelEnabled('error')) {
      this.transport.error(message);
    }
  }
}</pre> <p class="calibre3">In order to make <code>Logger</code> a singleton, we need<a id="_idIndexMarker024" class="pcalibre1 calibre6 pcalibre"/> to implement a <code>getInstance</code> static method that returns a cached instance. In order to do, this we’ll use a static <code>loggerInstance</code> on <code>Logger</code>. <code>getInstance</code> will check whether <code>Logger.loggerInstance</code> exists and return it if it does; otherwise, it will create a new <code>Logger</code> instance, set that as <code>loggerInstance</code>, and return it:</p>
<pre class="source-code">
class Logger {
  static loggerInstance = null;
  // rest of the class
  static getInstance() {
    if (!Logger.loggerInstance) {
      Logger.loggerInstance = new Logger('warn', console);
    }
    return Logger.loggerInstance;
  }
}</pre> <p class="calibre3">Using this in another module is as simple as calling <code>Logger.getInstance()</code>. All <code>getInstance</code> calls will return the same instance of <code>Logger</code>:</p>
<pre class="source-code">
const a = Logger.getInstance();
const b = Logger.getInstance();
console.assert(a === b, 'Logger.getInstance() returns the
  same reference');</pre> <p class="calibre3">We’ve implemented a singleton with “lazy” initialization. The initialization occurs when the first <code>getInstance</code> call is made. In the next section, we’ll see how we might extend our code to have an “eager” initialization of <code>loggerInstance</code>, where <code>loggerInstance</code> will be initialized <a id="_idIndexMarker025" class="pcalibre1 calibre6 pcalibre"/>when the <a id="_idTextAnchor038" class="pcalibre1 calibre6 pcalibre"/><code>Logger</code> code is evaluated.</p>
<h3 class="calibre9"> Ensuring only one singleton instance is constructed</h3>
<p class="calibre3">A characteristic of a singleton<a id="_idIndexMarker026" class="pcalibre1 calibre6 pcalibre"/> is the “single instance” concept. We want to “force” consumers to use the <code>getInstance</code> method.</p>
<p class="calibre3">In order to do this, we can check for the existence of <code>loggerInstance</code> when the contructor is called:</p>
<pre class="source-code">
class Logger {
  // rest of the class
  constructor(logLevel = 'info', transport = console) {
    if (Logger.loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
          instead'
      );
    }
    this.logLevel = logLevel;
    this.transport = transport;
  }
  // rest of the class
}</pre> <p class="calibre3">In the case where we call <code>getInstance</code> (and, therefore, <code>Logger.loggerInstance</code> is populated), the constructor<a id="_idIndexMarker027" class="pcalibre1 calibre6 pcalibre"/> will now throw an error:</p>
<pre class="source-code">
Logger.getInstance();
new Logger('info', console); // new TypeError('Logger is
  not constructable, use getInstance() instead');</pre> <p class="calibre3">This behavior is useful to ensure that consumers don’t instantiate their own Logger and they use <code>getInstance</code> instead. All consumers using <code>getInstance</code> means the configuration to set up the logger is encapsulated by the <code>Logger</code> class.</p>
<p class="calibre3">There’s still a gap in the implementation, as constructing <code>new Logger()</code> before any <code>getInstance()</code> calls will succeed, as shown in the following example:</p>
<pre class="source-code">
new Logger('info', console); // Logger { logLevel: 'info',
  transport: ... }
new Logger('info', console); // Logger { logLevel: 'info',
  transport: ... }
Logger.getInstance();
new Logger('info', console); // new TypeError('Logger is
  not constructable, use getInstance() instead');</pre> <p class="calibre3">In multithreaded languages, our implementation would also have a potential race condition – multiple consumers calling <code>Logger.getInstance()</code> concurrently could cause multiple instances to exist. However, since popular JavaScript runtimes are single-threaded, we won’t have to worry about such a race condition – <code>getInstance</code> is a “synchronous” method, so multiple calls to it would be interpreted one after the other. For reference, Node.js, Deno, and the mainstream browsers Chrome, Safari, Edge, and Firefox<a id="_idIndexMarker028" class="pcalibre1 calibre6 pcalibre"/> provide a single-<a id="_idTextAnchor039" class="pcalibre1 calibre6 pcalibre"/>threaded JavaScript runtime.</p>
<h3 class="calibre9">Singleton with eager initialization</h3>
<p class="calibre3">Eager initialization<a id="_idIndexMarker029" class="pcalibre1 calibre6 pcalibre"/> can be useful to ensure that the singleton<a id="_idIndexMarker030" class="pcalibre1 calibre6 pcalibre"/> is ready for use and features, such as disabling the constructor when an instance exists, work for all cases.</p>
<p class="calibre3">We can eager-initialize by setting <code>Logger.loggerInstance</code> in the <code>Logger</code> constructor:</p>
<pre class="source-code">
class Logger {
  // rest of the class unchanged
  constructor(logLevel = 'info', transport = console) {
    // rest of the constructor unchanged
    Logger.loggerInstance = this;
  }
}</pre> <p class="calibre3">This approach has the downside of the constructor performing a global state mutation, which isn’t ideal from a “single responsibility principle” standpoint; the constructor now has a side-effect of sorts (mutating global state) beyond its responsibility to set up an object instance.</p>
<p class="calibre3">An alternative way to eager-initialize is by running <code>Logger.getInstance()</code> in the logger’s module; it’s useful to pair it with an <code>export </code><code>default</code> statement:</p>
<pre class="source-code">
export class Logger {
  // no changes to the Logger class
}
export default Logger.getInstance();</pre> <p class="calibre3">With the preceding exports added, there are now two ways to access a logger instance. The first is to import <code>Logger</code> by name and call <code>Logger.getInstance()</code>:</p>
<pre class="source-code">
import { Logger } from './logger.js';
const logger = Logger.getInstance();
logger.warn('testing testing 12'); // testing testing 12</pre> <p class="calibre3">The second way to use the logger is by importing the default export:</p>
<pre class="source-code">
import logger from './logger.js';
logger.warn('testing testing 12'); // testing testing 12</pre> <p class="calibre3">Any code now importing <code>Logger</code> will get a pre-determined <a id="_idIndexMarker031" class="pcalibre1 calibre6 pcalibre"/>si<a id="_idTextAnchor040" class="pcalibre1 calibre6 pcalibre"/>ngleton instance <a id="_idIndexMarker032" class="pcalibre1 calibre6 pcalibre"/>of the logger.</p>
<h2 id="_idParaDest-23" class="calibre7"><a id="_idTextAnchor041" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">A singleton shines when<a id="_idIndexMarker033" class="pcalibre1 calibre6 pcalibre"/> there should only be one instance of an object in an application – for example, a logger that shouldn’t be set up/torn down on every request.</p>
<p class="calibre3">Since the singleton class controls how it gets instantiated, it’s also a good fit for objects that are tricky to configure (again, a logger, a metrics exporter, and an API client are good examples). The instantiation is completely encapsulated if, like in our example, we “disable” the constructor.</p>
<p class="calibre3">There’s a performance benefit to constraining the application to a single instance of an object in terms of memory footprint.</p>
<p class="calibre3">The major drawbacks of singletons are an effect of their reliance on global state (in our example, the static <code>loggerInstance</code>). It’s hard to test a singleton, especially in a case where the constructor is “disabled” (like in our example), since our tests will want to always have a single instance of the singleton.</p>
<p class="calibre3">Singletons can also be considered “global state” to some extent, which comes with all its drawbacks. Global state can sometimes be a sign of poor design, and updating/consuming global state is error-prone (e.g., if a consumer is reading state but it is <a id="_idTextAnchor042" class="pcalibre1 calibre6 pcalibre"/>then updated and not read again).</p>
<h2 id="_idParaDest-24" class="calibre7"><a id="_idTextAnchor043" class="pcalibre1 calibre6 pcalibre"/>Improvements with the “class singleton” pattern</h2>
<p class="calibre3">With our singleton logger<a id="_idIndexMarker034" class="pcalibre1 calibre6 pcalibre"/> implementation, it’s possible<a id="_idIndexMarker035" class="pcalibre1 calibre6 pcalibre"/> to modify the internal state of the singleton from outside of it. This is nothing specific to our singleton; it’s the nature of JavaScript. By default, its fields and methods are public.</p>
<p class="calibre3">However, this is a bigger issue in our singleton scenario, since a consumer could reset <code>loggerInstance</code> using a statement such as <code>Logger.loggerInstance = null</code> or <code>delete</code> <code>Logger.loggerInstance</code>. See the following example:</p>
<pre class="source-code">
const logger = Logger.getInstance();
Logger.loggerInstance = null;
const logger = new Logger('info', console); // should throw but creates a new instance</pre> <p class="calibre3">In order to stop consumers<a id="_idIndexMarker036" class="pcalibre1 calibre6 pcalibre"/> from modifying<a id="_idIndexMarker037" class="pcalibre1 calibre6 pcalibre"/> the <code>loggerInstance</code> static field, we can make it a private field. Private fields in JavaScript are part of the ECMAScript 2023 specification (the 13th ECMAScript edition).</p>
<p class="calibre3">To define a private field, we use the <code>#</code> prefix for the field name – in this case, <code>loggerInstance</code> becomes <code>#loggerInstance</code>. The <code>isLevelEnabled</code> method becomes <code>#isLevelEnabled</code>, and we also declare <code>logLevel</code> and <code>transport</code> as <code>#logLevel</code> and <code>#</code><code>transport</code>, respectively:</p>
<pre class="source-code">
export class Logger {
  // other static fields are unchanged
  static #loggerInstance = null;
  #logLevel;
  #transport;
  constructor(logLevel = 'info', transport = console) {
    if (Logger.#loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
          instead'
      );
    }
    this.#logLevel = logLevel;
    this.#transport = transport;
  }
  #isLevelEnabled(targetLevel) {
    // implementation unchanged
  }
  info(message) {
    if (this.#isLevelEnabled('info')) {
      return this.#transport.info(message);
    }
  }
  warn(message) {
    if (this.#isLevelEnabled('warn')) {
      this.#transport.warn(message);
    }
  }
  error(message) {
    if (this.#isLevelEnabled('error')) {
      this.#transport.error(message);
    }
  }
  getInstance() {
    if (!Logger.#loggerInstance) {
      Logger.#loggerInstance = new Logger('warn', console);
    }
    return Logger.#loggerInstance;
  }
}</pre> <p class="calibre3">It’s not possible<a id="_idIndexMarker038" class="pcalibre1 calibre6 pcalibre"/> to delete <code>loggerInstace</code> or set it to <code>null</code>, since attempting<a id="_idIndexMarker039" class="pcalibre1 calibre6 pcalibre"/> to access <code>Logger.#loggerInstance</code> is a syntax error:</p>
<pre class="source-code">
  Logger.#loggerInstance = null;
        ^
SyntaxError: Private field '#loggerInstance' must be
  declared in an enclosing class</pre> <p class="calibre3">Another useful technique is to disallow modification of fields on an object. In order to disallow modification, we can use <code>Object.freeze</code> to freeze the instance once it’s created.</p>
<pre class="source-code">
class Logger {
  // no changes to the logger class
}
export default Object.freeze(new Logger('warn', console));</pre> <p class="calibre3">Now, when someone attempts to change a field on the <code>Logger</code> instance, they’ll get <code>TypeError</code>:</p>
<pre class="source-code">
import logger from './logger.js';
logger.transport = {}; // new TypeError('Cannot add
  propert<a id="_idTextAnchor044" class="pcalibre1 calibre16 pcalibre"/>y transport, object is not extensible')</pre> <p class="calibre3">We’ve now refactored our singleton implementation to disallow external modifications<a id="_idIndexMarker040" class="pcalibre1 calibre6 pcalibre"/> to it by using private<a id="_idIndexMarker041" class="pcalibre1 calibre6 pcalibre"/> fields and <code>Object.freeze</code>. Next, we’ll see how to use <strong class="bold">EcmaScript</strong> (<strong class="bold">ES</strong>) modules to deliver singleton functionality.</p>
<h2 id="_idParaDest-25" class="calibre7"><a id="_idTextAnchor045" class="pcalibre1 calibre6 pcalibre"/>A singleton without class fields using ES module behavior</h2>
<p class="calibre3">The JavaScript module system<a id="_idIndexMarker042" class="pcalibre1 calibre6 pcalibre"/> has the following caching <a id="_idIndexMarker043" class="pcalibre1 calibre6 pcalibre"/>behavior – if a module is loaded, any further imports of the module’s exports will be cached instances of exports.</p>
<p class="calibre3">Therefore, it’s possible to create a singleton as follows in JavaScript.</p>
<pre class="source-code">
class MySingleton {
  constructor(value) {
    this.value = value;
  }
}
export default new MySingleton('my-value');</pre> <p class="calibre3">Multiple imports of the default export will result in only one existing instance of the <code>MySingleton</code> object. Furthermore, if we don’t export the class, then the constructor doesn’t need to be “protected.”</p>
<pre>import('./my-singleton.js')</strong> result in the same object. They both return the same object because the output of the <code>import</code> for a given module is a singleton:</pre>
<pre class="source-code">
await Promise.all([
  import('./my-singleton.js'),
  import('./my-singleton.js'),
]).then(([import1, import2]) =&gt; {
  console.assert(
    import1.default.value === 'my-value' &amp;&amp;
      import2.default.value === 'my-value',
    'instance variable is equal'
  );
  console.assert(
    import1.default === import2.default,
    'multiple imports of a module yield the same default
      object value, a single MySingleton instance'
  );
  console.assert(import1 === import2, 'import objects are a
    single reference');
});</pre> <p class="calibre3">For our logger, this means we could<a id="_idIndexMarker044" class="pcalibre1 calibre6 pcalibre"/> implement an eager-initialized<a id="_idIndexMarker045" class="pcalibre1 calibre6 pcalibre"/> singleton in JavaScript without any of the heavy-handed guarding of the constructor or even a <code>getInstance</code> method. Note the use of <code>logLevel</code> and <code>isLevelEnabled</code> as a public instance property and a public method, respectively (since it might be useful to have access to them from a consumer). In the meantime, <code>#transport</code> remains private, and we’ve dropped <code>loggerInstance</code> and <code>getInstance</code>. We’ve kept <code>Object.freeze()</code>, which means that even though <code>logLevel</code> is readable from a consumer, it’s not available to modify:</p>
<pre class="source-code">
class Logger {
  static logLevels = ['info', 'warn', 'error'];
  #transport;
  constructor(logLevel = 'info', transport = console) {
    this.logLevel = logLevel;
    this.#transport = transport;
  }
  isLevelEnabled(targetLevel) {
    return (
      Logger.logLevels.indexOf(targetLevel) &gt;=
      Logger.logLevels.indexOf(this.logLevel)
    );
  }
  info(message) {
    if (this.isLevelEnabled('info')) {
      return this.#transport.info(message);
    }
  }
  warn(message) {
    if (this.isLevelEnabled('warn')) {
      this.#transport.warn(message);
    }
  }
  error(message) {
    if (this.isLevelEnabled('error')) {
      this.#transport.error(message);
    }
  }
}
export default Object.freeze(new Logger('warn', console));</pre> <p class="calibre3">In this part of the chapter, we learned how to implement the singleton pattern with a class that exposes a <code>getInstance()</code> method, as well as the difference between the eager and lazy initialization of a singleton. We’ve covered some JavaScript features, such as private class fields and <code>Object.freeze</code>, which can be useful when implementing the singleton pattern. Finally, we explored how JavaScript/ECMAScript modules have singleton-like behavior and can be relied <a id="_idIndexMarker046" class="pcalibre1 calibre6 pcalibre"/>upon to provide this behavior<a id="_idIndexMarker047" class="pcalibre1 calibre6 pcalibre"/> for a class instance.</p>
<p class="calibre3">In the next section, we’ll explore the final creational design pattern covere<a id="_idTextAnchor046" class="pcalibre1 calibre6 pcalibre"/>d in this chapter – the factory de<a id="_idTextAnchor047" class="pcalibre1 calibre6 pcalibre"/>sign pattern.</p>
<h1 id="_idParaDest-26" class="calibre5"><a id="_idTextAnchor048" class="pcalibre1 calibre6 pcalibre"/>The factory pattern in JavaScript</h1>
<p class="calibre3">In a similar fashion to the discussion<a id="_idIndexMarker048" class="pcalibre1 calibre6 pcalibre"/> about the JavaScript “prototype” versus the prototype creational design pattern, “factory” refers to related but different concepts when it comes to general program design discussions and design patterns.</p>
<p class="calibre3">A “factory,” in the general programming sense, is an object that’s built with the goal of creating other objects. This is hinted at by the name that refers to a facility that processes items from one shape into another (or from one type of item to another). This factory denomination means that the output of a function or method is a new object. In JavaScript, this means that something as simple as a function that returns an object literal is a factory function:</p>
<pre class="source-code">
const simpleFactoryFunction = () =&gt; ({}); // returns an object, therefore it's a factory.</pre> <p class="calibre3">This definition of a factory is useful, but this section of the chapter is about the factory design pattern, which does fit into this overall “factory” definition.</p>
<p class="calibre3">The factory or factory method design pattern solves a class inheritance problem. A base or superclass is extended (the extended class is a subclass). The base class’s role is to provide orchestration for the methods implemented in the subclasses, as we want the subclasses to control w<a id="_idTextAnchor049" class="pcalibre1 calibre6 pcalibre"/>hich other objects to populate an instance with.</p>
<h2 id="_idParaDest-27" class="calibre7"><a id="_idTextAnchor050" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">A factory example<a id="_idIndexMarker049" class="pcalibre1 calibre6 pcalibre"/> is as follows. We have a <code>Building</code> base class that implements a <code>generateBuilding()</code> method. For now, it’s going to create a top floor using the <code>makeTopFloor</code> instance method. In the base class (<code>Building</code>), <code>makeTopFloor</code> is implemented, mainly because JavaScript doesn’t provide a way to define abstract methods. The <code>makeTopFloor</code> implementation throws an error because subclasses should override it; <code>makeTopFloor</code> is the “factory method” in this case. It’s how the base class defers the instantiation of objects to the subclasses:</p>
<pre class="source-code">
class Building {
  generateBuilding() {
    this.topFloor = this.makeTopFloor();
  }
  makeTopFloor() {
    throw new Error('not implemented, left for subclasses
      to implement');
  }
}</pre> <p class="calibre3">If we wanted to implement a single-story house, we would extend <code>Building</code> and override <code>makeTopFloor</code>; in this instance, <code>topFloor</code> will have <code>level: 1</code>.</p>
<pre class="source-code">
class House extends Building {
  makeTopFloor() {
    return {
      level: 1,
    };
  }
}</pre> <p class="calibre3">When we instantiate <code>House</code>, which is a subclass of <code>Building</code>, we have access to the <code>generateBuilding</code> method; when called, it sets <code>topFloor</code> correctly (to <code>{ level: </code><code>1 }</code>).</p>
<pre class="source-code">
const house = new House();
house.generateBuilding();
console.assert(house.topFloor.level === 1, 'topFloor works
  in House');</pre> <p class="calibre3">Now, if we want to create a different<a id="_idIndexMarker050" class="pcalibre1 calibre6 pcalibre"/> type of building that has a very different top floor, we can still extend <code>Building</code>; we simply override <code>makeTopFloor</code> to return a different floor. In the case of a skyscraper, we want the top floor to be very high, so we’ll do the following:</p>
<pre class="source-code">
class SkyScraper extends Building {
  makeTopFloor() {
    return {
      level: 125,
    };
  }
}</pre> <p class="calibre3">Having defined our <code>SkyScraper</code>, which is a subclass of <code>Building</code>, we can instantiate it and call <code>generateBuilding</code>. As in the preceding <code>House</code> case, the <code>generateBuilding</code> method will use <code>SkyScraper</code>’s <code>makeTopFloor</code> method to populate the <code>topFloor</code> instance property:</p>
<pre class="source-code">
const skyScraper = new SkyScraper();
skyScraper.generateBuilding();
console.assert(skyScraper.topFloor.level &gt; 100, 'topFloor
  works in SkyScraper');</pre> <p class="calibre3">The “factory method” in this case is <code>makeTopFloor</code>. The <code>makeTopFloor</code> method is “not implemented” in the base class, in the sense that it’s implemented in a manner that forces subclasses that wish to use <code>generateBuilding</code> to define a <code>makeTopFloor</code> override.</p>
<p class="calibre3">Note that <code>makeTopFloor</code> in our examples returned object literals, as mentioned earlier in the chapter; this is a feature of JavaScript not available in all object-oriented languages (JavaScript is multi-paradigm). We’ll see different ways to im<a id="_idTextAnchor051" class="pcalibre1 calibre6 pcalibre"/>plement the factory pattern<a id="_idIndexMarker051" class="pcalibre1 calibre6 pcalibre"/> later in this section.</p>
<h2 id="_idParaDest-28" class="calibre7"><a id="_idTextAnchor052" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The benefit of using a factory<a id="_idIndexMarker052" class="pcalibre1 calibre6 pcalibre"/> method is that we can create a wide variety of subclasses without modifying the base class. This is the “open/closed principle” at play – the <code>Building</code> class in our example is “open” to extension (i.e., can be subclassed to infinity for different types of buildings) but “closed” to modification (i.e., we don’t need to make changes in <code>Building</code> for ever<a id="_idTextAnchor053" class="pcalibre1 calibre6 pcalibre"/>y subclass, only when we want to add new behaviors).</p>
<h2 id="_idParaDest-29" class="calibre7"><a id="_idTextAnchor054" class="pcalibre1 calibre6 pcalibre"/>Improvements with modern JavaScript</h2>
<p class="calibre3">The key improvement we can make <a id="_idIndexMarker053" class="pcalibre1 calibre6 pcalibre"/>with JavaScript is enabled by its first-class support for functions and the ability to define objects using literals (instead of classes being instantiated).</p>
<p class="calibre3">JavaScript having “first-class functions” means functions are like any other type – they can be passed as parameters, set as variable values, and returned from other functions.</p>
<p class="calibre3">A more idiomatic implementation of this pattern would probably involve a <code>generateBuilding</code> standalone function instead of a <code>Building</code> class. <code>generateBuilding</code> would take <code>makeTopFloor</code> either as a parameter or take an object parameter with a <code>makeTopFloor</code> key. The output of <code>generateBuilding</code> would be an object created using an object literal, which takes the output of <code>makeTopFloor()</code> and sets it as the value to a <code>topFloor</code> key:</p>
<pre class="source-code">
function generateBuilding({ makeTopFloor }) {
  return {
    topFloor: makeTopFloor(),
  };
}</pre> <p class="calibre3">In order to create our house and skyscraper, we would call <code>generateBuilding</code> with the relevant <code>makeTopFloor</code> functions. In the case of the house, we want a top floor that is on level 1; in the case of the skyscraper, we want a top floor on level 125.</p>
<pre class="source-code">
const house = generateBuilding({
  makeTopFloor() {
    return {
      level: 1,
    };
  },
});
console.assert(house.topFloor.level === 1, 'topFloor works
  in house');
const skyScraper = generateBuilding({
  makeTopFloor() {
    return {
      level: 125,
    };
  },
});
console.assert(skyScraper.topFloor.level &gt; 100, 'topFloor works in skyScraper');</pre> <p class="calibre3">One reason why using functions<a id="_idIndexMarker054" class="pcalibre1 calibre6 pcalibre"/> directly works better in JavaScript is that we didn’t have to implement a “throw an error to remind consumers to override me” <code>makeFloor</code> method that we had with the <code>Building</code> class.</p>
<p class="calibre3">In languages other than JavaScript that have support for abstract methods, this pattern is more useful and natural to implement than in JavaScript, where we have first-class functions.</p>
<p class="calibre3">You also have to bear in mind that the original versions of JavaScript/ECMAScript didn’t include a <code>class</code> construct.</p>
<p class="calibre3">In the final section of the<a id="_idIndexMarker055" class="pcalibre1 calibre6 pcalibre"/> chapter, we learned what the factory method pattern is and how it contrasts with the factory programming concept. We then implemented a class-based factory pattern scenario as well as a more idiomatic JavaScript version. Interspersed through this section, we covered the use cases, benefits, and<a id="_idTextAnchor055" class="pcalibre1 calibre6 pcalibre"/> drawbacks of the factory method pattern in JavaScript.</p>
<h1 id="_idParaDest-30" class="calibre5"><a id="_idTextAnchor056" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">Throughout this chapter, we discussed how creational design patterns allow us to build more extensible and maintainable systems in JavaScript.</p>
<p class="calibre3">The prototype design pattern shines when creating many instances of objects that contain the same values. This design pattern allows us to change the initial values of the prototype and affect all the cloned instances.</p>
<p class="calibre3">The singleton design pattern is useful to completely hide initialization details of a class that should really only be instantiated once. We saw how JavaScript’s module system generates singletons and how that can be leveraged to simplify a singleton implementation.</p>
<p class="calibre3">The factory method design pattern allows a base class to defer the implementation of some object creations to subclasses. We saw which features would make this pattern more useful in JavaScript, as well as an alternative idiomatic JavaScript approach with factory functions.</p>
<p class="calibre3">We can now leverage creational design patterns to build classes that are composable and can be evolved as necessary to cover different use cases.</p>
<p class="calibre3">Now that we know how to create objects efficiently with creational design patterns, in the next chapter, we’ll cover how to use structural design patterns to organize relationships between different objects and classes.</p>
</div>
</body></html>