<html><head></head><body>
<div id="_idContainer008" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor018" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor019" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16" class="calibre5"><a id="_idTextAnchor020" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Working with Creational Design Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">JavaScript design patterns are techniques that allow us to write more robust, scalable, and extensible applications in JavaScript. </span><span class="kobospan" id="kobo.3.2">JavaScript is a very popular programming language, in part due to its place as a way to deliver interactive functionality on web pages. </span><span class="kobospan" id="kobo.3.3">The other reason for its popularity is JavaScript’s lightweight, dynamic, multi-paradigm nature, which means that design patterns from other ecosystems can be adapted to take advantage of JavaScript’s strengths. </span><span class="kobospan" id="kobo.3.4">JavaScript’s specific strengths and weaknesses can also inform new patterns specific to the language and the contexts in which </span><span><span class="kobospan" id="kobo.4.1">it’s used.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">Creational design patterns</span><a id="_idIndexMarker000" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.6.1"> give structure to object creation, which enables the development of systems and applications where different modules, classes, and objects don’t need to know how to create instances of each other. </span><span class="kobospan" id="kobo.6.2">The design patterns most relevant to JavaScript – the prototype, singleton, and factory patterns – will be explored, as well as situations where they’re helpful and how to implement them in an </span><span><span class="kobospan" id="kobo.7.1">idiomatic fashion.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.8.1">We’ll cover the following topics in </span><span><span class="kobospan" id="kobo.9.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.10.1">A comprehensive definition of creational design patterns and definitions for the prototype, singleton, and </span><span><span class="kobospan" id="kobo.11.1">factory patterns</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Multiple implementations of the prototype pattern and its </span><span><span class="kobospan" id="kobo.13.1">use cases</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">An implementation of the singleton design pattern, eager and lazy initialization, use cases for singleton, and what a singleton pattern in modern JavaScript </span><span><span class="kobospan" id="kobo.15.1">looks like</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">How to implement the factory pattern using classes, a modern JavaScript alternative, and </span><span><span class="kobospan" id="kobo.17.1">use cases</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.18.1">By the end of this chapter, you’ll be able to identify when a creational design pattern is useful and make an informed decision on which of its multiple implementations to use, ranging from a more idiomatic JavaScript form to a </span><span><span class="kobospan" id="kobo.19.1">classical form.</span></span><a id="_idTextAnchor021" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-17" class="calibre5"><a id="_idTextAnchor022" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.20.1">What are creational design patterns?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">Creational design patterns</span><a id="_idIndexMarker001" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.22.1"> handle object creation. </span><span class="kobospan" id="kobo.22.2">They allow a consumer to create object instances without knowing the details of how to instantiate the object. </span><span class="kobospan" id="kobo.22.3">Since, in object-oriented languages, instantiation of objects is limited to a class’s constructor, allowing object instances to be created without calling the constructor is useful to reduce noise and tight coupling between the consumer and the class </span><span><span class="kobospan" id="kobo.23.1">being instantiated.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">In JavaScript, there’s ambiguity when we discuss “object creation,” since JavaScript’s multi-paradigm nature means we can create objects without a class or a constructor. </span><span class="kobospan" id="kobo.24.2">For example, in JavaScript this is an object creation using an object literal – </span><strong class="source-inline"><span class="kobospan" id="kobo.25.1">const config = { forceUpdate: true</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.26.1">}</span></strong><span class="kobospan" id="kobo.27.1">. </span><span class="kobospan" id="kobo.27.2">In fact, modern idiomatic JavaScript tends to lean more toward procedural and function paradigms than object orientation. </span><span class="kobospan" id="kobo.27.3">This means that creational design patterns may have to be adapted to be fully useful </span><span><span class="kobospan" id="kobo.28.1">in JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">In summary, creational design patterns are useful in object-oriented JavaScript, since they hide instantiation details from consumers, which keeps coupling low, thereby allowing better </span><span><span class="kobospan" id="kobo.30.1">module separation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">In the next section, we’ll encounter our first creational design pattern – the prototype </span><span><span class="kobospan" id="kobo.32.1">design pattern</span><a id="_idTextAnchor023" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.33.1">.</span></span></p>
<h1 id="_idParaDest-18" class="calibre5"><a id="_idTextAnchor024" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.34.1">Implementing the prototype pattern in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">Let’s start with a definition</span><a id="_idIndexMarker002" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.36.1"> of the prototype </span><span><span class="kobospan" id="kobo.37.1">pattern</span></span><span><a id="_idIndexMarker003" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.38.1"> fir</span><a id="_idTextAnchor025" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.39.1">st.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">The prototype design pattern allows us to create an instance based on another existing instance (</span><span><span class="kobospan" id="kobo.41.1">our prototype).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">In more formal terms, a </span><strong class="source-inline"><span class="kobospan" id="kobo.43.1">prototype</span></strong><span class="kobospan" id="kobo.44.1"> class exposes a </span><strong class="source-inline"><span class="kobospan" id="kobo.45.1">clone()</span></strong><span class="kobospan" id="kobo.46.1"> method. </span><span class="kobospan" id="kobo.46.2">Consuming code, instead of calling </span><strong class="source-inline"><span class="kobospan" id="kobo.47.1">new SomeClass</span></strong><span class="kobospan" id="kobo.48.1">, will call </span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">new</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.50.1">SomeClassPrototype(someClassInstance).clone()</span></strong><span class="kobospan" id="kobo.51.1">. </span><span class="kobospan" id="kobo.51.2">This method call will return a </span><strong class="source-inline"><span class="kobospan" id="kobo.52.1">new SomeClass</span></strong><span class="kobospan" id="kobo.53.1"> instance with all the values copied </span><span><span class="kobospan" id="kobo.54.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.55.1">someClassInstan</span><a id="_idTextAnchor026" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.56.1">ce</span></strong></span><span><span class="kobospan" id="kobo.57.1">.</span></span></p>
<h2 id="_idParaDest-19" class="calibre7"><a id="_idTextAnchor027" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.58.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">Let’s imagine a scenario</span><a id="_idIndexMarker004" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.60.1"> where we’re building a chessboard. </span><span class="kobospan" id="kobo.60.2">There are two key types of squares – white and black. </span><span class="kobospan" id="kobo.60.3">In addition to this information, each square contains information such as its row, file, and which piece sits </span><span><span class="kobospan" id="kobo.61.1">atop it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.62.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.63.1">BoardSquare</span></strong><span class="kobospan" id="kobo.64.1"> class constructor might look like </span><span><span class="kobospan" id="kobo.65.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.66.1">
class BoardSquare {
  constructor(color, row, file, startingPiece) {
    this.color = color;
    this.row = row;
    this.file = file;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.67.1">A set of useful methods on </span><strong class="source-inline"><span class="kobospan" id="kobo.68.1">BoardSquare</span></strong><span class="kobospan" id="kobo.69.1"> might be </span><strong class="source-inline"><span class="kobospan" id="kobo.70.1">occupySquare</span></strong><span class="kobospan" id="kobo.71.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.72.1">clearSquare</span></strong><span class="kobospan" id="kobo.73.1">, </span><span><span class="kobospan" id="kobo.74.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.75.1">
class BoardSquare {
  // no change to the rest of the class
  occupySquare(piece) {
    this.piece = piece;
  }
  clearSquare() {
    this.piece = null;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.76.1">Instantiating </span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">BoardSquare</span></strong><span class="kobospan" id="kobo.78.1"> is quite cumbersome, due to all </span><span><span class="kobospan" id="kobo.79.1">its properties:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.80.1">
const whiteSquare = new BoardSquare('white');
const whiteSquareTwo = new BoardSquare('white');
// ...
</span><span class="kobospan1" id="kobo.80.2">const whiteSquareLast = new BoardSquare('white');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.81.1">Note the repetition of arguments</span><a id="_idIndexMarker005" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.82.1"> being passed to </span><strong class="source-inline"><span class="kobospan" id="kobo.83.1">new BoardSquare</span></strong><span class="kobospan" id="kobo.84.1">, which will cause issues if we want to change all board squares to black. </span><span class="kobospan" id="kobo.84.2">We would need to change the parameter passed to each call of </span><strong class="source-inline"><span class="kobospan" id="kobo.85.1">BoardSquare</span></strong><span class="kobospan" id="kobo.86.1"> is one by one for each </span><strong class="source-inline"><span class="kobospan" id="kobo.87.1">new BoardSquare</span></strong><span class="kobospan" id="kobo.88.1"> call. </span><span class="kobospan" id="kobo.88.2">This can be quite error-prone; all it takes is one hard-to-find mistake in the </span><strong class="source-inline"><span class="kobospan" id="kobo.89.1">color</span></strong><span class="kobospan" id="kobo.90.1"> value to cause </span><span><span class="kobospan" id="kobo.91.1">a bug:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.92.1">
const blackSquare = new BoardSquare('black');
const blackSquareTwo = new BoardSquare('black');
// ...
</span><span class="kobospan1" id="kobo.92.2">const blackSquareLast = new BoardSquare('black');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.93.1">Implementing our instantiation logic using a classical prototype looks as follows. </span><span class="kobospan" id="kobo.93.2">We need a </span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">BoardSquarePrototype</span></strong><span class="kobospan" id="kobo.95.1"> class; its constructor takes a </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">prototype</span></strong><span class="kobospan" id="kobo.97.1"> property, which it stores on the instance. </span><strong class="source-inline"><span class="kobospan" id="kobo.98.1">BoardSquarePrototype</span></strong><span class="kobospan" id="kobo.99.1"> exposes a </span><strong class="source-inline"><span class="kobospan" id="kobo.100.1">clone()</span></strong><span class="kobospan" id="kobo.101.1"> method that takes no arguments and returns a </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">BoardSquare</span></strong><span class="kobospan" id="kobo.103.1"> instance, with all the properties of </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">prototype</span></strong><span class="kobospan" id="kobo.105.1"> copied </span><span><span class="kobospan" id="kobo.106.1">onto it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.107.1">
class BoardSquarePrototype {
  constructor(prototype) {
    this.prototype = prototype;
  }
  clone() {
    const boardSquare = new BoardSquare();
    boardSquare.color = this.prototype.color;
    boardSquare.row = this.prototype.row;
    boardSquare.file = this.prototype.file;
    return boardSquare;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.108.1">Using </span><strong class="source-inline"><span class="kobospan" id="kobo.109.1">BoardSquarePrototype</span></strong><span class="kobospan" id="kobo.110.1"> requires</span><a id="_idIndexMarker006" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.111.1"> the </span><span><span class="kobospan" id="kobo.112.1">following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.113.1">First, we want an instance of </span><strong class="source-inline1"><span class="kobospan" id="kobo.114.1">BoardSquare</span></strong><span class="kobospan" id="kobo.115.1"> to initialize – in this case, with </span><strong class="source-inline1"><span class="kobospan" id="kobo.116.1">'white'</span></strong><span class="kobospan" id="kobo.117.1">. </span><span class="kobospan" id="kobo.117.2">It will then be passed as the </span><strong class="source-inline1"><span class="kobospan" id="kobo.118.1">prototype</span></strong><span class="kobospan" id="kobo.119.1"> property during the </span><strong class="source-inline1"><span class="kobospan" id="kobo.120.1">BoardSquarePrototype</span></strong> <span><span class="kobospan" id="kobo.121.1">constructor call:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.122.1">
const whiteSquare = new BoardSquare('white');
const whiteSquarePrototype = new BoardSquarePrototype
  (whiteSquare);</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.123.1">We can then use </span><strong class="source-inline1"><span class="kobospan" id="kobo.124.1">whiteSquarePrototype</span></strong><span class="kobospan" id="kobo.125.1"> with </span><strong class="source-inline1"><span class="kobospan" id="kobo.126.1">.clone()</span></strong><span class="kobospan" id="kobo.127.1"> to create our copies of </span><strong class="source-inline1"><span class="kobospan" id="kobo.128.1">whiteSquare</span></strong><span class="kobospan" id="kobo.129.1">. </span><span class="kobospan" id="kobo.129.2">Note that </span><strong class="source-inline1"><span class="kobospan" id="kobo.130.1">color</span></strong><span class="kobospan" id="kobo.131.1"> is copied over but each call to </span><strong class="source-inline1"><span class="kobospan" id="kobo.132.1">clone()</span></strong><span class="kobospan" id="kobo.133.1"> returns a </span><span><span class="kobospan" id="kobo.134.1">new instance.</span></span><pre class="source-code"><span class="kobospan1" id="kobo.135.1">
const whiteSquareTwo = whiteSquarePrototype.clone();
// ...
</span><span class="kobospan1" id="kobo.135.2">const whiteSquareLast = whiteSquarePrototype.clone();
console.assert(
  whiteSquare.color === whiteSquareTwo.color &amp;&amp;
    whiteSquareTwo.color === whiteSquareLast.color,
  'Prototype.clone()-ed instances have the same color
     as the prototype'
);
console.assert(
  whiteSquare !== whiteSquareTwo &amp;&amp;
    whiteSquare !== whiteSquareLast &amp;&amp;
    whiteSquareTwo !== whiteSqua</span><a id="_idTextAnchor028" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.136.1">reLast,
  'each Prototype.clone() call outputs a different
     instanc</span><a id="_idTextAnchor029" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.137.1">es'
);</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.138.1">Per the assertions in the</span><a id="_idIndexMarker007" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.139.1"> code, the cloned instances contain the same value for </span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">color</span></strong><span class="kobospan" id="kobo.141.1"> but are different instances of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.142.1">Square</span></strong></span><span><span class="kobospan" id="kobo.143.1"> object.</span></span></p>
<h2 id="_idParaDest-20" class="calibre7"><a id="_idTextAnchor030" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.144.1">A use case</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.145.1">To illustrate what it would</span><a id="_idIndexMarker008" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.146.1"> take to change from a white square to a black square, let’s look at some sample code where </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">'white'</span></strong><span class="kobospan" id="kobo.148.1"> is not referenced in the </span><span><span class="kobospan" id="kobo.149.1">variable names:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.150.1">
const boardSquare = new BoardSquare('white');
const boardSquarePrototype = new BoardSquarePrototype(boardSquare);
const boardSquareTwo = boardSquarePrototype.clone();
// ...
</span><span class="kobospan1" id="kobo.150.2">const boardSquareLast = boardSquarePrototype.clone();
console.assert(
  boardSquareTwo.color === 'white' &amp;&amp;
    boardSquare.color === boardSquareTwo.color &amp;&amp;
    boardSquareTwo.color === boardSquareLast.color,
  'Prototype.clone()-ed instances have the same color as
     the prototype'
);
console.assert(
  boardSquare !== boardSquareTwo &amp;&amp;
    boardSquare !== boardSquareLast &amp;&amp;
    boardSquareTwo !== boardSquareLast,
  'each Prototype.clone() call outputs a different
    instances'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.151.1">In this scenario, we would </span><a id="_idIndexMarker009" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.152.1">only have to change the </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">color</span></strong><span class="kobospan" id="kobo.154.1"> value passed to </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">BoardSquare</span></strong><span class="kobospan" id="kobo.156.1"> to change the color of all the instances cloned from </span><span><span class="kobospan" id="kobo.157.1">the prototype:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.158.1">
const boardSquare = new BoardSquare('black');
// rest of the code stays the same
console.assert(
  boardSquareTwo.color === 'black' &amp;&amp;
    boardSquare.color === boardSquareTwo.color &amp;&amp;
    boardSquareTwo.color === boardSquareLast.color,
  'Prototype.clone()-ed instances have the same color as
     the prototype'
);
console.assert(
  boardSquare !== boardSquareTwo &amp;&amp;
    boardSquare !== boardSquareLast &amp;&amp;
    boardSquareTwo !== boardSquareLast,
  'each Prototype.clone() call outputs a different
     instances'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.159.1">The prototype pattern is useful in situations where a “template” for the object instances is useful. </span><span class="kobospan" id="kobo.159.2">It’s a good pattern to create a “default object” but with custom values. </span><span class="kobospan" id="kobo.159.3">It allows faster and easier changes, since they are implemented</span><a id="_idIndexMarker010" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.160.1"> once on the template object but are applied to all </span><span><strong class="source-inline"><span class="kobospan" id="kobo.161.1">clone()</span></strong></span><span><span class="kobospan" id="kobo.162.1">-ed </span><a id="_idTextAnchor031" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor032" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.163.1">instances.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.164.1">Increasing robustness to change in the prototype’s instance variables with modern JavaScript</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.165.1">There are improvements</span><a id="_idIndexMarker011" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.166.1"> we can make to our prototype implementation </span><span><span class="kobospan" id="kobo.167.1">in JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.168.1">The first is in the </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">clone()</span></strong><span class="kobospan" id="kobo.170.1"> method. </span><span class="kobospan" id="kobo.170.2">To make our prototype class robust to changes in the prototype’s constructor/instance variables, we should avoid copying the properties one </span><span><span class="kobospan" id="kobo.171.1">by one.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.172.1">For example, if we add a new </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">startingPiece</span></strong><span class="kobospan" id="kobo.174.1"> parameter that the </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">BoardSquare</span></strong><span class="kobospan" id="kobo.176.1"> constructor takes and sets the </span><strong class="source-inline"><span class="kobospan" id="kobo.177.1">piece</span></strong><span class="kobospan" id="kobo.178.1"> instance variable to, our current implementation of </span><strong class="source-inline"><span class="kobospan" id="kobo.179.1">BoardSquarePrototype</span></strong><span class="kobospan" id="kobo.180.1"> will fail to copy it, since it only copies </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">color</span></strong><span class="kobospan" id="kobo.182.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">row</span></strong><span class="kobospan" id="kobo.184.1">, </span><span><span class="kobospan" id="kobo.185.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">file</span></strong></span><span><span class="kobospan" id="kobo.187.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.188.1">
class BoardSquare {
  constructor(color, row, file, startingPiece) {
    this.color = color;
    this.row = row;
    this.file = file;
    this.piece = startingPiece;
  }
  // same rest of the class
}
const boardSquare = new BoardSquare('white', 1, 'A',
  'king');
const boardSquarePrototype = new BoardSquarePrototype
  (boardSquare);
const otherBoardSquare = boardSquarePrototype.clone();
console.assert(
  otherBoardSquare.piece === undefined,
  'prototype.piece was not copied over'
);</span></pre> <p class="callout-heading"><span class="kobospan" id="kobo.189.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.190.1">Reference</span><a id="_idIndexMarker012" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.191.1"> for </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">Object.assign</span></strong></span><span><span class="kobospan" id="kobo.193.1">: </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.194.1">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</span></span></a><span><span class="kobospan" id="kobo.195.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.196.1">If we amend our </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">BoardSquarePrototype</span></strong><span class="kobospan" id="kobo.198.1"> class to use </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">Object.assign(new BoardSquare(), this.prototype)</span></strong><span class="kobospan" id="kobo.200.1">, it will copy </span><a id="_idIndexMarker013" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.201.1">all the enumerable properties </span><span><span class="kobospan" id="kobo.202.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.203.1">prototype</span></strong></span><span><span class="kobospan" id="kobo.204.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.205.1">
class BoardSquarePrototype {
  constructor(prototype) {
    this.prototype = prototype;
  }
  clone() {
    return Object.assign(new BoardSquare(), this.prototype);
  }
}
const boardSquare = new BoardSquare('white', 1, 'A',
  'king');
const boardSquarePrototype = new BoardSquarePrototype
  (boardSquare);
const otherBoardSquare = boardSquarePrototype.clone();
console.assert(
  otherBoardSquare.piece === 'king' &amp;&amp;
    otherBoardSquare.piece === boardSquare.piece,
  'prototype.piece was co</span><a id="_idTextAnchor033" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.206.1">pied over'
);</span></pre> <h3 class="calibre9"><span class="kobospan" id="kobo.207.1">The prototype pattern without classes in JavaScript</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">For historical reasons, JavaScript</span><a id="_idIndexMarker014" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.209.1"> has a prototype concept deeply embedded into the language. </span><span class="kobospan" id="kobo.209.2">In fact, classes were introduced much later into the ECMAScript standard, with ECMAScript 6, which was released in 2015 (for reference, ECMAScript 1 was published </span><span><span class="kobospan" id="kobo.210.1">in 1997).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">This is why a lot of JavaScript completely forgoes the use of classes. </span><span class="kobospan" id="kobo.211.2">The JavaScript “object prototype” can be used to make objects inherit methods and variables from </span><span><span class="kobospan" id="kobo.212.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.213.1">One way to clone objects is by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.214.1">Object.create</span></strong><span class="kobospan" id="kobo.215.1"> to clone objects with their methods. </span><span class="kobospan" id="kobo.215.2">This relies on the JavaScript </span><span><span class="kobospan" id="kobo.216.1">prototype system:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.217.1">
const square = {
  color: 'white',
  occupySquare(piece) {
    this.piece = piece;
  },
  clearSquare() {
    this.piece = null;
  },
};
const otherSquare = Object.create(square);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.218.1">One subtlety here is that </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">Object.create</span></strong><span class="kobospan" id="kobo.220.1"> does not actually copy</span><a id="_idIndexMarker015" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.221.1"> anything; it simply creates a new object and sets its prototype to </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">square</span></strong><span class="kobospan" id="kobo.223.1">. </span><span class="kobospan" id="kobo.223.2">This means that if properties are not found on </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">otherSquare</span></strong><span class="kobospan" id="kobo.225.1">, they’re accessed </span><span><span class="kobospan" id="kobo.226.1">on </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">square</span></strong></span><span><span class="kobospan" id="kobo.228.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.229.1">
console.assert(otherSquare.__proto__ === square, 'uses JS
  prototype');
console.assert(
  otherSquare.occupySquare === square.occupySquare &amp;&amp;
    otherSquare.clearSquare === square.clearSquare,
  "methods are not copied, they're 'inherited' using the
     prototype"
);
delete otherSquare.color;
console.assert(
  otherSquare.color === 'white' &amp;&amp; otherSquare.color ===
    square.color,
  'data fields are also inherited'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.230.1">A further note on the JavaScript prototype, and its existence before classes were part of JavaScript, is that subclassing</span><a id="_idIndexMarker016" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.231.1"> in JavaScript is another syntax for setting an object’s prototype. </span><span class="kobospan" id="kobo.231.2">Have a look at the following </span><strong class="source-inline"><span class="kobospan" id="kobo.232.1">extends</span></strong><span class="kobospan" id="kobo.233.1"> example. </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">BlackSquare extends Square</span></strong><span class="kobospan" id="kobo.235.1"> sets the </span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">prototype.__proto__</span></strong><span class="kobospan" id="kobo.237.1"> property of </span><strong class="source-inline"><span class="kobospan" id="kobo.238.1">BlackSquare</span></strong> <span><span class="kobospan" id="kobo.239.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.240.1">Square.prototype</span></strong></span><span><span class="kobospan" id="kobo.241.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.242.1">
class Square {
  constructor() {}
  occupySquare(piece) {
    this.piece = piece;
  }
  clearSquare() {
    this.piece = null;
  }
}
class BlackSquare extends Square {
  constructor() {
    super();
    this.color = 'black';
  }
}
console.assert(
  BlackSquare.prototype.__proto__ === Square.prototype,
  'subclass prototype has prototype of superclass'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.243.1">In this section, we learned how to implement the prototype pattern with a prototype class that exposes a </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">clone()</span></strong><span class="kobospan" id="kobo.245.1"> method, which code situations the prototype patterns can help with, and how to further improve our prototype implementation with modern JavaScript features. </span><span class="kobospan" id="kobo.245.2">We also covered the JavaScript “prototype,” why it exists, and its relationship</span><a id="_idIndexMarker017" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.246.1"> with the prototype </span><span><span class="kobospan" id="kobo.247.1">design pattern.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.248.1">In the next part of the chapter, we’ll look at another creational design pattern, the singleton design pattern, with some implementation approaches in JavaScript a</span><a id="_idTextAnchor034" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.249.1">nd its </span><span><span class="kobospan" id="kobo.250.1">use cases.</span></span></p>
<h1 id="_idParaDest-21" class="calibre5"><span class="kobospan" id="kobo.251.1">The singleton pattern with eager and lazy initializat</span><a id="_idTextAnchor035" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.252.1">ion in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.253.1">To begin, let’s define the singleton </span><span><span class="kobospan" id="kobo.254.1">design pattern.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">The singleton pattern</span><a id="_idIndexMarker018" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.256.1"> allows an object</span><a id="_idIndexMarker019" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.257.1"> to be instantiated </span><a id="_idIndexMarker020" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.258.1">only once, exposes</span><a id="_idIndexMarker021" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.259.1"> this single instance to consumers, and controls the instantiation of the </span><span><span class="kobospan" id="kobo.260.1">single instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.261.1">The singleton is another way of getting access to an object instance without using a constructor, although it’s necessary for the object to be des</span><a id="_idTextAnchor036" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.262.1">igned as </span><span><span class="kobospan" id="kobo.263.1">a singleton.</span></span></p>
<h2 id="_idParaDest-22" class="calibre7"><a id="_idTextAnchor037" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.264.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.265.1">A classic example of a singleton</span><a id="_idIndexMarker022" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.266.1"> is a logger. </span><span class="kobospan" id="kobo.266.2">It’s rarely necessary (and often, it’s a problem) to instantiate multiple loggers in an application. </span><span class="kobospan" id="kobo.266.3">Having a singleton means the initialization site is controlled, and the logger configuration will be consistent across the application – for example, the log level won’t change depending on where in the application we call the </span><span><span class="kobospan" id="kobo.267.1">logger from.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.268.1">A simple logger looks something as follows, with a constructor taking </span><strong class="source-inline"><span class="kobospan" id="kobo.269.1">logLevel</span></strong><span class="kobospan" id="kobo.270.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">transport</span></strong><span class="kobospan" id="kobo.272.1">, and an </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">isLevelEnabled</span></strong><span class="kobospan" id="kobo.274.1"> private method, which allows us to drop logs that the logger is not configured to keep (for example, when the level is </span><strong class="source-inline"><span class="kobospan" id="kobo.275.1">warn</span></strong><span class="kobospan" id="kobo.276.1"> we drop </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">info</span></strong><span class="kobospan" id="kobo.278.1"> messages). </span><span class="kobospan" id="kobo.278.2">The logger finally implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">info</span></strong><span class="kobospan" id="kobo.280.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.281.1">warn</span></strong><span class="kobospan" id="kobo.282.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">error</span></strong><span class="kobospan" id="kobo.284.1"> methods, which behave as previously described; they only call the relevant </span><strong class="source-inline"><span class="kobospan" id="kobo.285.1">transport</span></strong><span class="kobospan" id="kobo.286.1"> method if the level is “enabled” (i.e., “above” what the configured log </span><span><span class="kobospan" id="kobo.287.1">level is).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.288.1">The possible </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">logLevel</span></strong><span class="kobospan" id="kobo.290.1"> values</span><a id="_idIndexMarker023" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.291.1"> that power </span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">isLevelEnabled</span></strong><span class="kobospan" id="kobo.293.1"> are stored as a static field </span><span><span class="kobospan" id="kobo.294.1">on </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">Logger</span></strong></span><span><span class="kobospan" id="kobo.296.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.297.1">
class Logger {
  static logLevels = ['info', 'warn', 'error'];
  constructor(logLevel = 'info', transport = console) {
    if (Logger.#loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
           instead'
      );
    }
    this.logLevel = logLevel;
    this.transport = transport;
  }
  isLevelEnabled(targetLevel) {
    return (
      Logger.logLevels.indexOf(targetLevel) &gt;=
      Logger.logLevels.indexOf(this.logLevel)
    );
  }
  info(message) {
    if (this.isLevelEnabled('info')) {
      return this.transport.info(message);
    }
  }
  warn(message) {
    if (this.isLevelEnabled('warn')) {
      this.transport.warn(message);
    }
  }
  error(message) {
    if (this.isLevelEnabled('error')) {
      this.transport.error(message);
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.298.1">In order to make </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">Logger</span></strong><span class="kobospan" id="kobo.300.1"> a singleton, we need</span><a id="_idIndexMarker024" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.301.1"> to implement a </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">getInstance</span></strong><span class="kobospan" id="kobo.303.1"> static method that returns a cached instance. </span><span class="kobospan" id="kobo.303.2">In order to do, this we’ll use a static </span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">loggerInstance</span></strong><span class="kobospan" id="kobo.305.1"> on </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">Logger</span></strong><span class="kobospan" id="kobo.307.1">. </span><strong class="source-inline"><span class="kobospan" id="kobo.308.1">getInstance</span></strong><span class="kobospan" id="kobo.309.1"> will check whether </span><strong class="source-inline"><span class="kobospan" id="kobo.310.1">Logger.loggerInstance</span></strong><span class="kobospan" id="kobo.311.1"> exists and return it if it does; otherwise, it will create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.312.1">Logger</span></strong><span class="kobospan" id="kobo.313.1"> instance, set that as </span><strong class="source-inline"><span class="kobospan" id="kobo.314.1">loggerInstance</span></strong><span class="kobospan" id="kobo.315.1">, and </span><span><span class="kobospan" id="kobo.316.1">return it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.317.1">
class Logger {
  static loggerInstance = null;
  // rest of the class
  static getInstance() {
    if (!Logger.loggerInstance) {
      Logger.loggerInstance = new Logger('warn', console);
    }
    return Logger.loggerInstance;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.318.1">Using this in another module is as simple as calling </span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">Logger.getInstance()</span></strong><span class="kobospan" id="kobo.320.1">. </span><span class="kobospan" id="kobo.320.2">All </span><strong class="source-inline"><span class="kobospan" id="kobo.321.1">getInstance</span></strong><span class="kobospan" id="kobo.322.1"> calls will return the same instance </span><span><span class="kobospan" id="kobo.323.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">Logger</span></strong></span><span><span class="kobospan" id="kobo.325.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.326.1">
const a = Logger.getInstance();
const b = Logger.getInstance();
console.assert(a === b, 'Logger.getInstance() returns the
  same reference');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.327.1">We’ve implemented a singleton with “lazy” initialization. </span><span class="kobospan" id="kobo.327.2">The initialization occurs when the first </span><strong class="source-inline"><span class="kobospan" id="kobo.328.1">getInstance</span></strong><span class="kobospan" id="kobo.329.1"> call is made. </span><span class="kobospan" id="kobo.329.2">In the next section, we’ll see how we might extend our code to have an “eager” initialization of </span><strong class="source-inline"><span class="kobospan" id="kobo.330.1">loggerInstance</span></strong><span class="kobospan" id="kobo.331.1">, where </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">loggerInstance</span></strong><span class="kobospan" id="kobo.333.1"> will be initialized </span><a id="_idIndexMarker025" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.334.1">when the </span><a id="_idTextAnchor038" class="pcalibre1 calibre6 pcalibre"/><strong class="source-inline"><span class="kobospan" id="kobo.335.1">Logger</span></strong><span class="kobospan" id="kobo.336.1"> code </span><span><span class="kobospan" id="kobo.337.1">is evaluated.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.338.1"> Ensuring only one singleton instance is constructed</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.339.1">A characteristic of a singleton</span><a id="_idIndexMarker026" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.340.1"> is the “single instance” concept. </span><span class="kobospan" id="kobo.340.2">We want to “force” consumers to use the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">getInstance</span></strong></span><span><span class="kobospan" id="kobo.342.1"> method.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.343.1">In order to do this, we can check for the existence of </span><strong class="source-inline"><span class="kobospan" id="kobo.344.1">loggerInstance</span></strong><span class="kobospan" id="kobo.345.1"> when the contructor </span><span><span class="kobospan" id="kobo.346.1">is called:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.347.1">
class Logger {
  // rest of the class
  constructor(logLevel = 'info', transport = console) {
    if (Logger.loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
          instead'
      );
    }
    this.logLevel = logLevel;
    this.transport = transport;
  }
  // rest of the class
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.348.1">In the case where we call </span><strong class="source-inline"><span class="kobospan" id="kobo.349.1">getInstance</span></strong><span class="kobospan" id="kobo.350.1"> (and, therefore, </span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">Logger.loggerInstance</span></strong><span class="kobospan" id="kobo.352.1"> is populated), the constructor</span><a id="_idIndexMarker027" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.353.1"> will now throw </span><span><span class="kobospan" id="kobo.354.1">an error:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.355.1">
Logger.getInstance();
new Logger('info', console); // new TypeError('Logger is
  not constructable, use getInstance() instead');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.356.1">This behavior is useful to ensure that consumers don’t instantiate their own Logger and they use </span><strong class="source-inline"><span class="kobospan" id="kobo.357.1">getInstance</span></strong><span class="kobospan" id="kobo.358.1"> instead. </span><span class="kobospan" id="kobo.358.2">All consumers using </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">getInstance</span></strong><span class="kobospan" id="kobo.360.1"> means the configuration to set up the logger is encapsulated by the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.361.1">Logger</span></strong></span><span><span class="kobospan" id="kobo.362.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">There’s still a gap in the implementation, as constructing </span><strong class="source-inline"><span class="kobospan" id="kobo.364.1">new Logger()</span></strong><span class="kobospan" id="kobo.365.1"> before any </span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">getInstance()</span></strong><span class="kobospan" id="kobo.367.1"> calls will succeed, as shown in the </span><span><span class="kobospan" id="kobo.368.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.369.1">
new Logger('info', console); // Logger { logLevel: 'info',
  transport: ... </span><span class="kobospan1" id="kobo.369.2">}
new Logger('info', console); // Logger { logLevel: 'info',
  transport: ... </span><span class="kobospan1" id="kobo.369.3">}
Logger.getInstance();
new Logger('info', console); // new TypeError('Logger is
  not constructable, use getInstance() instead');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.370.1">In multithreaded languages, our implementation would also have a potential race condition – multiple consumers calling </span><strong class="source-inline"><span class="kobospan" id="kobo.371.1">Logger.getInstance()</span></strong><span class="kobospan" id="kobo.372.1"> concurrently could cause multiple instances to exist. </span><span class="kobospan" id="kobo.372.2">However, since popular JavaScript runtimes are single-threaded, we won’t have to worry about such a race condition – </span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">getInstance</span></strong><span class="kobospan" id="kobo.374.1"> is a “synchronous” method, so multiple calls to it would be interpreted one after the other. </span><span class="kobospan" id="kobo.374.2">For reference, Node.js, Deno, and the mainstream browsers Chrome, Safari, Edge, and Firefox</span><a id="_idIndexMarker028" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.375.1"> provide a single-</span><a id="_idTextAnchor039" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.376.1">threaded </span><span><span class="kobospan" id="kobo.377.1">JavaScript runtime.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.378.1">Singleton with eager initialization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.379.1">Eager initialization</span><a id="_idIndexMarker029" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.380.1"> can be useful to ensure that the singleton</span><a id="_idIndexMarker030" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.381.1"> is ready for use and features, such as disabling the constructor when an instance exists, work for </span><span><span class="kobospan" id="kobo.382.1">all cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.383.1">We can eager-initialize by setting </span><strong class="source-inline"><span class="kobospan" id="kobo.384.1">Logger.loggerInstance</span></strong><span class="kobospan" id="kobo.385.1"> in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">Logger</span></strong></span><span><span class="kobospan" id="kobo.387.1"> constructor:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.388.1">
class Logger {
  // rest of the class unchanged
  constructor(logLevel = 'info', transport = console) {
    // rest of the constructor unchanged
    Logger.loggerInstance = this;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.389.1">This approach has the downside of the constructor performing a global state mutation, which isn’t ideal from a “single responsibility principle” standpoint; the constructor now has a side-effect of sorts (mutating global state) beyond its responsibility to set up an </span><span><span class="kobospan" id="kobo.390.1">object instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.391.1">An alternative way to eager-initialize is by running </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">Logger.getInstance()</span></strong><span class="kobospan" id="kobo.393.1"> in the logger’s module; it’s useful to pair it with an </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">export </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.395.1">default</span></strong></span><span><span class="kobospan" id="kobo.396.1"> statement:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.397.1">
export class Logger {
  // no changes to the Logger class
}
export default Logger.getInstance();</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.398.1">With the preceding exports added, there are now two ways to access a logger instance. </span><span class="kobospan" id="kobo.398.2">The first is to import </span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">Logger</span></strong><span class="kobospan" id="kobo.400.1"> by name and </span><span><span class="kobospan" id="kobo.401.1">call </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.402.1">Logger.getInstance()</span></strong></span><span><span class="kobospan" id="kobo.403.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.404.1">
import { Logger } from './logger.js';
const logger = Logger.getInstance();
logger.warn('testing testing 12'); // testing testing 12</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.405.1">The second way to use the logger is by importing the </span><span><span class="kobospan" id="kobo.406.1">default export:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.407.1">
import logger from './logger.js';
logger.warn('testing testing 12'); // testing testing 12</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.408.1">Any code now importing </span><strong class="source-inline"><span class="kobospan" id="kobo.409.1">Logger</span></strong><span class="kobospan" id="kobo.410.1"> will get a pre-determined </span><a id="_idIndexMarker031" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.411.1">si</span><a id="_idTextAnchor040" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.412.1">ngleton instance </span><a id="_idIndexMarker032" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.413.1">of </span><span><span class="kobospan" id="kobo.414.1">the logger.</span></span></p>
<h2 id="_idParaDest-23" class="calibre7"><a id="_idTextAnchor041" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.415.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.416.1">A singleton shines when</span><a id="_idIndexMarker033" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.417.1"> there should only be one instance of an object in an application – for example, a logger that shouldn’t be set up/torn down on </span><span><span class="kobospan" id="kobo.418.1">every request.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.419.1">Since the singleton class controls how it gets instantiated, it’s also a good fit for objects that are tricky to configure (again, a logger, a metrics exporter, and an API client are good examples). </span><span class="kobospan" id="kobo.419.2">The instantiation is completely encapsulated if, like in our example, we “disable” </span><span><span class="kobospan" id="kobo.420.1">the constructor.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.421.1">There’s a performance benefit to constraining the application to a single instance of an object in terms of </span><span><span class="kobospan" id="kobo.422.1">memory footprint.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.423.1">The major drawbacks of singletons are an effect of their reliance on global state (in our example, the static </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">loggerInstance</span></strong><span class="kobospan" id="kobo.425.1">). </span><span class="kobospan" id="kobo.425.2">It’s hard to test a singleton, especially in a case where the constructor is “disabled” (like in our example), since our tests will want to always have a single instance of </span><span><span class="kobospan" id="kobo.426.1">the singleton.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.427.1">Singletons can also be considered “global state” to some extent, which comes with all its drawbacks. </span><span class="kobospan" id="kobo.427.2">Global state can sometimes be a sign of poor design, and updating/consuming global state is error-prone (e.g., if a consumer is reading state but it is </span><a id="_idTextAnchor042" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.428.1">then updated and not </span><span><span class="kobospan" id="kobo.429.1">read again).</span></span></p>
<h2 id="_idParaDest-24" class="calibre7"><a id="_idTextAnchor043" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.430.1">Improvements with the “class singleton” pattern</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">With our singleton logger</span><a id="_idIndexMarker034" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.432.1"> implementation, it’s possible</span><a id="_idIndexMarker035" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.433.1"> to modify the internal state of the singleton from outside of it. </span><span class="kobospan" id="kobo.433.2">This is nothing specific to our singleton; it’s the nature of JavaScript. </span><span class="kobospan" id="kobo.433.3">By default, its fields and methods </span><span><span class="kobospan" id="kobo.434.1">are public.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.435.1">However, this is a bigger issue in our singleton scenario, since a consumer could reset </span><strong class="source-inline"><span class="kobospan" id="kobo.436.1">loggerInstance</span></strong><span class="kobospan" id="kobo.437.1"> using a statement such as </span><strong class="source-inline"><span class="kobospan" id="kobo.438.1">Logger.loggerInstance = null</span></strong><span class="kobospan" id="kobo.439.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">delete</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.441.1">Logger.loggerInstance</span></strong><span class="kobospan" id="kobo.442.1">. </span><span class="kobospan" id="kobo.442.2">See the </span><span><span class="kobospan" id="kobo.443.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.444.1">
const logger = Logger.getInstance();
Logger.loggerInstance = null;
const logger = new Logger('info', console); // should throw but creates a new instance</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.445.1">In order to stop consumers</span><a id="_idIndexMarker036" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.446.1"> from modifying</span><a id="_idIndexMarker037" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.447.1"> the </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">loggerInstance</span></strong><span class="kobospan" id="kobo.449.1"> static field, we can make it a private field. </span><span class="kobospan" id="kobo.449.2">Private fields in JavaScript are part of the ECMAScript 2023 specification (the 13th </span><span><span class="kobospan" id="kobo.450.1">ECMAScript edition).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.451.1">To define a private field, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">#</span></strong><span class="kobospan" id="kobo.453.1"> prefix for the field name – in this case, </span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">loggerInstance</span></strong><span class="kobospan" id="kobo.455.1"> becomes </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">#loggerInstance</span></strong><span class="kobospan" id="kobo.457.1">. </span><span class="kobospan" id="kobo.457.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">isLevelEnabled</span></strong><span class="kobospan" id="kobo.459.1"> method becomes </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">#isLevelEnabled</span></strong><span class="kobospan" id="kobo.461.1">, and we also declare </span><strong class="source-inline"><span class="kobospan" id="kobo.462.1">logLevel</span></strong><span class="kobospan" id="kobo.463.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.464.1">transport</span></strong><span class="kobospan" id="kobo.465.1"> as </span><strong class="source-inline"><span class="kobospan" id="kobo.466.1">#logLevel</span></strong><span class="kobospan" id="kobo.467.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">#</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.469.1">transport</span></strong></span><span><span class="kobospan" id="kobo.470.1">, respectively:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.471.1">
export class Logger {
  // other static fields are unchanged
  static #loggerInstance = null;
  #logLevel;
  #transport;
  constructor(logLevel = 'info', transport = console) {
    if (Logger.#loggerInstance) {
      throw new TypeError(
        'Logger is not constructable, use getInstance()
          instead'
      );
    }
    this.#logLevel = logLevel;
    this.#transport = transport;
  }
  #isLevelEnabled(targetLevel) {
    // implementation unchanged
  }
  info(message) {
    if (this.#isLevelEnabled('info')) {
      return this.#transport.info(message);
    }
  }
  warn(message) {
    if (this.#isLevelEnabled('warn')) {
      this.#transport.warn(message);
    }
  }
  error(message) {
    if (this.#isLevelEnabled('error')) {
      this.#transport.error(message);
    }
  }
  getInstance() {
    if (!Logger.#loggerInstance) {
      Logger.#loggerInstance = new Logger('warn', console);
    }
    return Logger.#loggerInstance;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.472.1">It’s not possible</span><a id="_idIndexMarker038" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.473.1"> to delete </span><strong class="source-inline"><span class="kobospan" id="kobo.474.1">loggerInstace</span></strong><span class="kobospan" id="kobo.475.1"> or set it to </span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">null</span></strong><span class="kobospan" id="kobo.477.1">, since attempting</span><a id="_idIndexMarker039" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.478.1"> to access </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">Logger.#loggerInstance</span></strong><span class="kobospan" id="kobo.480.1"> is a </span><span><span class="kobospan" id="kobo.481.1">syntax error:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.482.1">
  Logger.#loggerInstance = null;
        ^
SyntaxError: Private field '#loggerInstance' must be
  declared in an enclosing class</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.483.1">Another useful technique is to disallow modification of fields on an object. </span><span class="kobospan" id="kobo.483.2">In order to disallow modification, we can use </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">Object.freeze</span></strong><span class="kobospan" id="kobo.485.1"> to freeze the instance once </span><span><span class="kobospan" id="kobo.486.1">it’s created.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.487.1">
class Logger {
  // no changes to the logger class
}
export default Object.freeze(new Logger('warn', console));</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.488.1">Now, when someone attempts to change a field on the </span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">Logger</span></strong><span class="kobospan" id="kobo.490.1"> instance, they’ll </span><span><span class="kobospan" id="kobo.491.1">get </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.492.1">TypeError</span></strong></span><span><span class="kobospan" id="kobo.493.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.494.1">
import logger from './logger.js';
logger.transport = {}; // new TypeError('Cannot add
  propert</span><a id="_idTextAnchor044" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.495.1">y transport, object is not extensible')</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.496.1">We’ve now refactored our singleton implementation to disallow external modifications</span><a id="_idIndexMarker040" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.497.1"> to it by using private</span><a id="_idIndexMarker041" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.498.1"> fields and </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">Object.freeze</span></strong><span class="kobospan" id="kobo.500.1">. </span><span class="kobospan" id="kobo.500.2">Next, we’ll see how to use </span><strong class="bold"><span class="kobospan" id="kobo.501.1">EcmaScript</span></strong><span class="kobospan" id="kobo.502.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.503.1">ES</span></strong><span class="kobospan" id="kobo.504.1">) modules to deliver </span><span><span class="kobospan" id="kobo.505.1">singleton functionality.</span></span></p>
<h2 id="_idParaDest-25" class="calibre7"><a id="_idTextAnchor045" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.506.1">A singleton without class fields using ES module behavior</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.507.1">The JavaScript module system</span><a id="_idIndexMarker042" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.508.1"> has the following caching </span><a id="_idIndexMarker043" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.509.1">behavior – if a module is loaded, any further imports of the module’s exports will be cached instances </span><span><span class="kobospan" id="kobo.510.1">of exports.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.511.1">Therefore, it’s possible to create a singleton as follows </span><span><span class="kobospan" id="kobo.512.1">in JavaScript.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.513.1">
class MySingleton {
  constructor(value) {
    this.value = value;
  }
}
export default new MySingleton('my-value');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.514.1">Multiple imports of the default export will result in only one existing instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">MySingleton</span></strong><span class="kobospan" id="kobo.516.1"> object. </span><span class="kobospan" id="kobo.516.2">Furthermore, if we don’t export the class, then the constructor doesn’t need to </span><span><span class="kobospan" id="kobo.517.1">be “protected.”</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.518.1">As the following snippet with dynamic imports shows, both </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">import('./my-singleton.js')</span></strong><span class="kobospan" id="kobo.520.1"> result in the same object. </span><span class="kobospan" id="kobo.520.2">They both return the same object because the output of the </span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">import</span></strong><span class="kobospan" id="kobo.522.1"> for a given module is </span><span><span class="kobospan" id="kobo.523.1">a singleton:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.524.1">
await Promise.all([
  import('./my-singleton.js'),
  import('./my-singleton.js'),
]).then(([import1, import2]) =&gt; {
  console.assert(
    import1.default.value === 'my-value' &amp;&amp;
      import2.default.value === 'my-value',
    'instance variable is equal'
  );
  console.assert(
    import1.default === import2.default,
    'multiple imports of a module yield the same default
      object value, a single MySingleton instance'
  );
  console.assert(import1 === import2, 'import objects are a
    single reference');
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.525.1">For our logger, this means we could</span><a id="_idIndexMarker044" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.526.1"> implement an eager-initialized</span><a id="_idIndexMarker045" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.527.1"> singleton in JavaScript without any of the heavy-handed guarding of the constructor or even a </span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">getInstance</span></strong><span class="kobospan" id="kobo.529.1"> method. </span><span class="kobospan" id="kobo.529.2">Note the use of </span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">logLevel</span></strong><span class="kobospan" id="kobo.531.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.532.1">isLevelEnabled</span></strong><span class="kobospan" id="kobo.533.1"> as a public instance property and a public method, respectively (since it might be useful to have access to them from a consumer). </span><span class="kobospan" id="kobo.533.2">In the meantime, </span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">#transport</span></strong><span class="kobospan" id="kobo.535.1"> remains private, and we’ve dropped </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">loggerInstance</span></strong><span class="kobospan" id="kobo.537.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">getInstance</span></strong><span class="kobospan" id="kobo.539.1">. </span><span class="kobospan" id="kobo.539.2">We’ve kept </span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">Object.freeze()</span></strong><span class="kobospan" id="kobo.541.1">, which means that even though </span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">logLevel</span></strong><span class="kobospan" id="kobo.543.1"> is readable from a consumer, it’s not available </span><span><span class="kobospan" id="kobo.544.1">to modify:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.545.1">
class Logger {
  static logLevels = ['info', 'warn', 'error'];
  #transport;
  constructor(logLevel = 'info', transport = console) {
    this.logLevel = logLevel;
    this.#transport = transport;
  }
  isLevelEnabled(targetLevel) {
    return (
      Logger.logLevels.indexOf(targetLevel) &gt;=
      Logger.logLevels.indexOf(this.logLevel)
    );
  }
  info(message) {
    if (this.isLevelEnabled('info')) {
      return this.#transport.info(message);
    }
  }
  warn(message) {
    if (this.isLevelEnabled('warn')) {
      this.#transport.warn(message);
    }
  }
  error(message) {
    if (this.isLevelEnabled('error')) {
      this.#transport.error(message);
    }
  }
}
export default Object.freeze(new Logger('warn', console));</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.546.1">In this part of the chapter, we learned how to implement the singleton pattern with a class that exposes a </span><strong class="source-inline"><span class="kobospan" id="kobo.547.1">getInstance()</span></strong><span class="kobospan" id="kobo.548.1"> method, as well as the difference between the eager and lazy initialization of a singleton. </span><span class="kobospan" id="kobo.548.2">We’ve covered some JavaScript features, such as private class fields and </span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">Object.freeze</span></strong><span class="kobospan" id="kobo.550.1">, which can be useful when implementing the singleton pattern. </span><span class="kobospan" id="kobo.550.2">Finally, we explored how JavaScript/ECMAScript modules have singleton-like behavior and can be relied </span><a id="_idIndexMarker046" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.551.1">upon to provide this behavior</span><a id="_idIndexMarker047" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.552.1"> for a </span><span><span class="kobospan" id="kobo.553.1">class instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.554.1">In the next section, we’ll explore the final creational design pattern covere</span><a id="_idTextAnchor046" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.555.1">d in this chapter – the factory </span><span><span class="kobospan" id="kobo.556.1">de</span><a id="_idTextAnchor047" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.557.1">sign pattern.</span></span></p>
<h1 id="_idParaDest-26" class="calibre5"><a id="_idTextAnchor048" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.558.1">The factory pattern in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.559.1">In a similar fashion to the discussion</span><a id="_idIndexMarker048" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.560.1"> about the JavaScript “prototype” versus the prototype creational design pattern, “factory” refers to related but different concepts when it comes to general program design discussions and </span><span><span class="kobospan" id="kobo.561.1">design patterns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.562.1">A “factory,” in the general programming sense, is an object that’s built with the goal of creating other objects. </span><span class="kobospan" id="kobo.562.2">This is hinted at by the name that refers to a facility that processes items from one shape into another (or from one type of item to another). </span><span class="kobospan" id="kobo.562.3">This factory denomination means that the output of a function or method is a new object. </span><span class="kobospan" id="kobo.562.4">In JavaScript, this means that something as simple as a function that returns an object literal is a </span><span><span class="kobospan" id="kobo.563.1">factory function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.564.1">
const simpleFactoryFunction = () =&gt; ({}); // returns an object, therefore it's a factory.</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.565.1">This definition of a factory is useful, but this section of the chapter is about the factory design pattern, which does fit into this overall “</span><span><span class="kobospan" id="kobo.566.1">factory” definition.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.567.1">The factory or factory method design pattern solves a class inheritance problem. </span><span class="kobospan" id="kobo.567.2">A base or superclass is extended (the extended class is a subclass). </span><span class="kobospan" id="kobo.567.3">The base class’s role is to provide orchestration for the methods implemented in the subclasses, as we want the subclasses to control w</span><a id="_idTextAnchor049" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.568.1">hich other objects to populate an </span><span><span class="kobospan" id="kobo.569.1">instance with.</span></span></p>
<h2 id="_idParaDest-27" class="calibre7"><a id="_idTextAnchor050" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.570.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.571.1">A factory example</span><a id="_idIndexMarker049" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.572.1"> is as follows. </span><span class="kobospan" id="kobo.572.2">We have a </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">Building</span></strong><span class="kobospan" id="kobo.574.1"> base class that implements a </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">generateBuilding()</span></strong><span class="kobospan" id="kobo.576.1"> method. </span><span class="kobospan" id="kobo.576.2">For now, it’s going to create a top floor using the </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.578.1"> instance method. </span><span class="kobospan" id="kobo.578.2">In the base class (</span><strong class="source-inline"><span class="kobospan" id="kobo.579.1">Building</span></strong><span class="kobospan" id="kobo.580.1">), </span><strong class="source-inline"><span class="kobospan" id="kobo.581.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.582.1"> is implemented, mainly because JavaScript doesn’t provide a way to define abstract methods. </span><span class="kobospan" id="kobo.582.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.583.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.584.1"> implementation throws an error because subclasses should override it; </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.586.1"> is the “factory method” in this case. </span><span class="kobospan" id="kobo.586.2">It’s how the base class defers the instantiation of objects to </span><span><span class="kobospan" id="kobo.587.1">the subclasses:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.588.1">
class Building {
  generateBuilding() {
    this.topFloor = this.makeTopFloor();
  }
  makeTopFloor() {
    throw new Error('not implemented, left for subclasses
      to implement');
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.589.1">If we wanted to implement a single-story house, we would extend </span><strong class="source-inline"><span class="kobospan" id="kobo.590.1">Building</span></strong><span class="kobospan" id="kobo.591.1"> and override </span><strong class="source-inline"><span class="kobospan" id="kobo.592.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.593.1">; in this instance, </span><strong class="source-inline"><span class="kobospan" id="kobo.594.1">topFloor</span></strong><span class="kobospan" id="kobo.595.1"> will have </span><span><strong class="source-inline"><span class="kobospan" id="kobo.596.1">level: 1</span></strong></span><span><span class="kobospan" id="kobo.597.1">.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.598.1">
class House extends Building {
  makeTopFloor() {
    return {
      level: 1,
    };
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.599.1">When we instantiate </span><strong class="source-inline"><span class="kobospan" id="kobo.600.1">House</span></strong><span class="kobospan" id="kobo.601.1">, which is a subclass of </span><strong class="source-inline"><span class="kobospan" id="kobo.602.1">Building</span></strong><span class="kobospan" id="kobo.603.1">, we have access to the </span><strong class="source-inline"><span class="kobospan" id="kobo.604.1">generateBuilding</span></strong><span class="kobospan" id="kobo.605.1"> method; when called, it sets </span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">topFloor</span></strong><span class="kobospan" id="kobo.607.1"> correctly (to </span><strong class="source-inline"><span class="kobospan" id="kobo.608.1">{ level: </span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.609.1">1 }</span></strong></span><span><span class="kobospan" id="kobo.610.1">).</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.611.1">
const house = new House();
house.generateBuilding();
console.assert(house.topFloor.level === 1, 'topFloor works
  in House');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.612.1">Now, if we want to create a different</span><a id="_idIndexMarker050" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.613.1"> type of building that has a very different top floor, we can still extend </span><strong class="source-inline"><span class="kobospan" id="kobo.614.1">Building</span></strong><span class="kobospan" id="kobo.615.1">; we simply override </span><strong class="source-inline"><span class="kobospan" id="kobo.616.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.617.1"> to return a different floor. </span><span class="kobospan" id="kobo.617.2">In the case of a skyscraper, we want the top floor to be very high, so we’ll do </span><span><span class="kobospan" id="kobo.618.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.619.1">
class SkyScraper extends Building {
  makeTopFloor() {
    return {
      level: 125,
    };
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.620.1">Having defined our </span><strong class="source-inline"><span class="kobospan" id="kobo.621.1">SkyScraper</span></strong><span class="kobospan" id="kobo.622.1">, which is a subclass of </span><strong class="source-inline"><span class="kobospan" id="kobo.623.1">Building</span></strong><span class="kobospan" id="kobo.624.1">, we can instantiate it and call </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">generateBuilding</span></strong><span class="kobospan" id="kobo.626.1">. </span><span class="kobospan" id="kobo.626.2">As in the preceding </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">House</span></strong><span class="kobospan" id="kobo.628.1"> case, the </span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">generateBuilding</span></strong><span class="kobospan" id="kobo.630.1"> method will use </span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">SkyScraper</span></strong><span class="kobospan" id="kobo.632.1">’s </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.634.1"> method to populate the </span><strong class="source-inline"><span class="kobospan" id="kobo.635.1">topFloor</span></strong> <span><span class="kobospan" id="kobo.636.1">instance property:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.637.1">
const skyScraper = new SkyScraper();
skyScraper.generateBuilding();
console.assert(skyScraper.topFloor.level &gt; 100, 'topFloor
  works in SkyScraper');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.638.1">The “factory method” in this case is </span><strong class="source-inline"><span class="kobospan" id="kobo.639.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.640.1">. </span><span class="kobospan" id="kobo.640.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.641.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.642.1"> method is “not implemented” in the base class, in the sense that it’s implemented in a manner that forces subclasses that wish to use </span><strong class="source-inline"><span class="kobospan" id="kobo.643.1">generateBuilding</span></strong><span class="kobospan" id="kobo.644.1"> to define a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.645.1">makeTopFloor</span></strong></span><span><span class="kobospan" id="kobo.646.1"> override.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.647.1">Note that </span><strong class="source-inline"><span class="kobospan" id="kobo.648.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.649.1"> in our examples returned object literals, as mentioned earlier in the chapter; this is a feature of JavaScript not available in all object-oriented languages (JavaScript is multi-paradigm). </span><span class="kobospan" id="kobo.649.2">We’ll see different ways to im</span><a id="_idTextAnchor051" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.650.1">plement the factory pattern</span><a id="_idIndexMarker051" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.651.1"> later in </span><span><span class="kobospan" id="kobo.652.1">this section.</span></span></p>
<h2 id="_idParaDest-28" class="calibre7"><a id="_idTextAnchor052" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.653.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.654.1">The benefit of using a factory</span><a id="_idIndexMarker052" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.655.1"> method is that we can create a wide variety of subclasses without modifying the base class. </span><span class="kobospan" id="kobo.655.2">This is the “open/closed principle” at play – the </span><strong class="source-inline"><span class="kobospan" id="kobo.656.1">Building</span></strong><span class="kobospan" id="kobo.657.1"> class in our example is “open” to extension (i.e., can be subclassed to infinity for different types of buildings) but “closed” to modification (i.e., we don’t need to make changes in </span><strong class="source-inline"><span class="kobospan" id="kobo.658.1">Building</span></strong><span class="kobospan" id="kobo.659.1"> for ever</span><a id="_idTextAnchor053" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.660.1">y subclass, only when we want to add </span><span><span class="kobospan" id="kobo.661.1">new behaviors).</span></span></p>
<h2 id="_idParaDest-29" class="calibre7"><a id="_idTextAnchor054" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.662.1">Improvements with modern JavaScript</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.663.1">The key improvement we can make </span><a id="_idIndexMarker053" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.664.1">with JavaScript is enabled by its first-class support for functions and the ability to define objects using literals (instead of classes </span><span><span class="kobospan" id="kobo.665.1">being instantiated).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.666.1">JavaScript having “first-class functions” means functions are like any other type – they can be passed as parameters, set as variable values, and returned from </span><span><span class="kobospan" id="kobo.667.1">other functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.668.1">A more idiomatic implementation of this pattern would probably involve a </span><strong class="source-inline"><span class="kobospan" id="kobo.669.1">generateBuilding</span></strong><span class="kobospan" id="kobo.670.1"> standalone function instead of a </span><strong class="source-inline"><span class="kobospan" id="kobo.671.1">Building</span></strong><span class="kobospan" id="kobo.672.1"> class. </span><strong class="source-inline"><span class="kobospan" id="kobo.673.1">generateBuilding</span></strong><span class="kobospan" id="kobo.674.1"> would take </span><strong class="source-inline"><span class="kobospan" id="kobo.675.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.676.1"> either as a parameter or take an object parameter with a </span><strong class="source-inline"><span class="kobospan" id="kobo.677.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.678.1"> key. </span><span class="kobospan" id="kobo.678.2">The output of </span><strong class="source-inline"><span class="kobospan" id="kobo.679.1">generateBuilding</span></strong><span class="kobospan" id="kobo.680.1"> would be an object created using an object literal, which takes the output of </span><strong class="source-inline"><span class="kobospan" id="kobo.681.1">makeTopFloor()</span></strong><span class="kobospan" id="kobo.682.1"> and sets it as the value to a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.683.1">topFloor</span></strong></span><span><span class="kobospan" id="kobo.684.1"> key:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.685.1">
function generateBuilding({ makeTopFloor }) {
  return {
    topFloor: makeTopFloor(),
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.686.1">In order to create our house and skyscraper, we would call </span><strong class="source-inline"><span class="kobospan" id="kobo.687.1">generateBuilding</span></strong><span class="kobospan" id="kobo.688.1"> with the relevant </span><strong class="source-inline"><span class="kobospan" id="kobo.689.1">makeTopFloor</span></strong><span class="kobospan" id="kobo.690.1"> functions. </span><span class="kobospan" id="kobo.690.2">In the case of the house, we want a top floor that is on level 1; in the case of the skyscraper, we want a top floor on </span><span><span class="kobospan" id="kobo.691.1">level 125.</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.692.1">
const house = generateBuilding({
  makeTopFloor() {
    return {
      level: 1,
    };
  },
});
console.assert(house.topFloor.level === 1, 'topFloor works
  in house');
const skyScraper = generateBuilding({
  makeTopFloor() {
    return {
      level: 125,
    };
  },
});
console.assert(skyScraper.topFloor.level &gt; 100, 'topFloor works in skyScraper');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.693.1">One reason why using functions</span><a id="_idIndexMarker054" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.694.1"> directly works better in JavaScript is that we didn’t have to implement a “throw an error to remind consumers to override me” </span><strong class="source-inline"><span class="kobospan" id="kobo.695.1">makeFloor</span></strong><span class="kobospan" id="kobo.696.1"> method that we had with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.697.1">Building</span></strong></span><span><span class="kobospan" id="kobo.698.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.699.1">In languages other than JavaScript that have support for abstract methods, this pattern is more useful and natural to implement than in JavaScript, where we have </span><span><span class="kobospan" id="kobo.700.1">first-class functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.701.1">You also have to bear in mind that the original versions of JavaScript/ECMAScript didn’t include a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.702.1">class</span></strong></span><span><span class="kobospan" id="kobo.703.1"> construct.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.704.1">In the final section of the</span><a id="_idIndexMarker055" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.705.1"> chapter, we learned what the factory method pattern is and how it contrasts with the factory programming concept. </span><span class="kobospan" id="kobo.705.2">We then implemented a class-based factory pattern scenario as well as a more idiomatic JavaScript version. </span><span class="kobospan" id="kobo.705.3">Interspersed through this section, we covered the use cases, benefits, and</span><a id="_idTextAnchor055" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.706.1"> drawbacks of the factory method pattern </span><span><span class="kobospan" id="kobo.707.1">in JavaScript.</span></span></p>
<h1 id="_idParaDest-30" class="calibre5"><a id="_idTextAnchor056" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.708.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.709.1">Throughout this chapter, we discussed how creational design patterns allow us to build more extensible and maintainable systems </span><span><span class="kobospan" id="kobo.710.1">in JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.711.1">The prototype design pattern shines when creating many instances of objects that contain the same values. </span><span class="kobospan" id="kobo.711.2">This design pattern allows us to change the initial values of the prototype and affect all the </span><span><span class="kobospan" id="kobo.712.1">cloned instances.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.713.1">The singleton design pattern is useful to completely hide initialization details of a class that should really only be instantiated once. </span><span class="kobospan" id="kobo.713.2">We saw how JavaScript’s module system generates singletons and how that can be leveraged to simplify a </span><span><span class="kobospan" id="kobo.714.1">singleton implementation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.715.1">The factory method design pattern allows a base class to defer the implementation of some object creations to subclasses. </span><span class="kobospan" id="kobo.715.2">We saw which features would make this pattern more useful in JavaScript, as well as an alternative idiomatic JavaScript approach with </span><span><span class="kobospan" id="kobo.716.1">factory functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.717.1">We can now leverage creational design patterns to build classes that are composable and can be evolved as necessary to cover different </span><span><span class="kobospan" id="kobo.718.1">use cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.719.1">Now that we know how to create objects efficiently with creational design patterns, in the next chapter, we’ll cover how to use structural design patterns to organize relationships between different objects </span><span><span class="kobospan" id="kobo.720.1">and classes.</span></span></p>
</div>
</body></html>