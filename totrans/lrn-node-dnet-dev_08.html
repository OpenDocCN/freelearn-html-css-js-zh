<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Mastering Asynchronicity</h1></div></div></div><p>Our JavaScript primer (<a class="link" title="Chapter 3. A JavaScript Primer" href="part0022.xhtml#aid-KVCC1">Chapter 3</a>, <em>A JavaScript Primer</em>) covered all the important concepts to let us start building our application. But there is one fundamental aspect of JavaScript programming worth exploring in more detail: asynchronicity.</p><p>
<a class="link" title="Chapter 1. Why Node.js?" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <em>Why Node.js?</em>, discussed the asynchronous programming model of Node.js. It described the consistent approach used throughout Node.js APIs and third-party libraries. Recall that each asynchronous method takes a callback function that gets passed error and result arguments, for example, the <code class="literal">fs.stat</code> function we saw in <a class="link" title="Chapter 1. Why Node.js?" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <em>Why Node.js?</em>:</p><div><pre class="programlisting">fs.stat('/hello/world', function (error, stats) {
  console.log('File last updated at: ' + stats.mtime);
});</pre></div><p>However, the callback pattern has some weaknesses. Performing error handling and combining results from multiple asynchronous operations can become quite clumsy. There are alternative asynchronous patterns available in JavaScript that address these issues. The idea of multiple competing patterns might seem worrying in itself, though. Having a single consistent approach was one of the benefits of Node.js discussed in <a class="link" title="Chapter 1. Why Node.js?" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <em>Why Node.js?</em>.</p><p>We should also revisit the idea of Node.js APIs and libraries being asynchronous throughout. We need to consider how this applies to our own code. This is not just something we need to worry about if writing a module for use by a third-party. Even within our own applications, most modules will need to expose their functionality through an asynchronous interface. If not, we severely limit the freedom of how we implement these modules.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Introducing asynchronous interfaces to our own modules</li><li class="listitem">Observing some of the weaknesses of the callback pattern</li><li class="listitem">Refactoring away from callbacks to make our asynchronous code more readable</li><li class="listitem">Seeing how we can still benefit from the consistency of Node.js's asynchronous programming model</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Using the callback pattern for asynchronous code</h1></div></div></div><p>Let's look at one of the methods from our games service:</p><div><pre class="programlisting">module.exports.get = (id) =&gt; games.find(game =&gt; game.id === id);</pre></div><p>The interface <a id="id288" class="indexterm"/>of this function is synchronous: you<a id="id289" class="indexterm"/> call it and get a value back. <a class="link" title="Chapter 4. Introducing Node.js Modules" href="part0025.xhtml#aid-NQU21">Chapter 4</a>, <em>Introducing Node.js Modules</em>, introduced the games service as the module responsible for how we store our games. The interface shouldn't need to change if we change the storage implementation. This isn't quite the case at the moment, though.</p><p>As discussed before, most Node.js libraries are asynchronous. Synchronous interfaces can't make use of asynchronous implementations. Let's say the <code class="literal">get</code> function wants to make use of an asynchronous method in a third-party <code class="literal">datastore</code> library. What would that look like? The comments in the following (non-working) code describe the problem:</p><div><pre class="programlisting">module.exports.get = (id) =&gt; {
    datastore.getById(id, (err, result) =&gt; {
        // Result available, but outer method has already returned
    });
    return ???; // Need to return here, but have no result yet
};</pre></div><p>This is a problem in general, not just in JavaScript. In other platforms, you could delay returning until the asynchronous operation has completed. This turns an asynchronous operation into a blocking operation. In Node.js (and other JavaScript environments), blocking in this way is not an option. It would be incompatible with the single-threaded, non-blocking, event-driven execution model.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec42"/>Exposing the callback pattern</h2></div></div></div><p>To allow our <a id="id290" class="indexterm"/>games service to be able to make use of asynchronous libraries, we need to give it an asynchronous interface. Note that almost all libraries in the Node.js ecosystem are asynchronous. If they weren't, they would be limited in the same way as our games service currently is.</p><p>We can rewrite the interface of our <code class="literal">get</code> function to follow the standard asynchronous callback pattern. Let's see what effect this has on using an asynchronous third-party <code class="literal">datastore</code> library (again, this is non-working code, with a fictional <code class="literal">datastore</code> object):</p><div><pre class="programlisting">module.exports.get = (id, callback) =&gt; {
  datastore.getById(id, (err, result) =&gt; {
    // Can now make use of the result by passing to the callback
    callback(err, result);
  }
  // No longer need to return here
}</pre></div><p>Of course, in<a id="id291" class="indexterm"/> this case we could simplify the preceding code as follows:</p><div><pre class="programlisting">module.exports.get = (id, callback) =&gt; {
    datastore.getById(id, callback);
}</pre></div><p>In general, though, we might want to do some more processing of the result from a third-party library. So our function might look more like this:</p><div><pre class="programlisting">module.exports.get = (id, callback) =&gt; {
    datastore.getById(id, (err, result) =&gt; {
        if (err) {
            callback(err);
        } else {
            callback(null, processResult(result));
        }
    }
}</pre></div><p>Assuming <code class="literal">processResult</code> is internal to our module, it's fine for it to have a synchronous interface for now. If it needs to do asynchronous work later, we can change its interface without affecting the consumers of our module.</p><p>Our games service module's <em>public</em> interface does need to be entirely asynchronous, though. We're not actually changing the implementation of the module yet. This makes updating the interface quite straightforward. We can make the following changes in <code class="literal">src/services/games.js</code>:</p><div><pre class="programlisting">'use strict';

const games = [];
let nextId = 1;

class Game {
    ...
    
<strong>    remove(callback) {</strong>
        games.splice(games.indexOf(this), 1);
<strong>        callback();</strong>
    }
}

<strong>module.exports.create = (userId, word, callback) =&gt; {</strong>
    const newGame = new Game(nextId++, userId, word); 
    games.push(newGame);
<strong>    callback(newGame);</strong>
};
<strong>module.exports.get = (id, callback) =&gt;</strong>
<strong>    callback(null,</strong>
<strong>        games.find(game =&gt; game.id === parseInt(id, 10)));</strong>
<strong>module.exports.createdBy = (userId, callback) =&gt;</strong>
<strong>    callback(null, games.filter(game =&gt; game.setBy === userId));</strong>
<strong>module.exports.availableTo = (userId, callback) =&gt;</strong>
<strong>    callback(null, games.filter(game =&gt; game.setBy !== userId));</strong>
</pre></div><p>Note that this is <a id="id292" class="indexterm"/>slightly unrealistic, though. Control would normally return to the caller before an asynchronous method completes. We can achieve this by using <code class="literal">process.nextTick</code> to schedule the execution of the callback on the next tick of the event loop (refer to <a class="link" title="Chapter 1. Why Node.js?" href="part0014.xhtml#aid-DB7S2">Chapter 1</a>, <em>Why Node.js?</em>, if you want a refresher on the event loop):</p><div><pre class="programlisting">'use strict';

const games = [];
let nextId = 1;

<strong>const asAsync = (callback, result) =&gt;</strong>
<strong>                process.nextTick(() =&gt; callback(null, result));</strong>

class Game {
    ...
    
    remove(callback) {
        games.splice(games.indexOf(this), 1);
<strong>        asAsync(callback);</strong>
    }
}

module.exports.create = (userId, word, callback) =&gt; {
    let game = new Game(nextId++, userId, word);
    games.push(game);
<strong>    asAsync(callback);</strong>
};
module.exports.get = (id, callback) =&gt;
<strong>    asAsync(callback,</strong>
<strong>        games.find(game =&gt; game.id === parseInt(id, 10)));</strong>
module.exports.createdBy = (userId, callback) =&gt;
<strong>    asAsync(callback, games.filter(game =&gt; game.setBy === userId));</strong>
module.exports.availableTo = (userId, callback) =&gt;
<strong>    asAsync(callback, games.filter(game =&gt; game.setBy !== userId));</strong>
</pre></div><p>Updating the <a id="id293" class="indexterm"/>rest of our application to consume this asynchronous interface is a trickier task. This is why it is worth always writing module interfaces to be asynchronous from the start. We should definitely address this before expanding our application any further.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec43"/>Consuming asynchronous interfaces</h2></div></div></div><p>The games<a id="id294" class="indexterm"/> service is called by the games<a id="id295" class="indexterm"/> route, the index route, and by our tests. Let's look at the corresponding changes to each of these in turn. The following code is from <code class="literal">src/routes/games.js</code>:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const service = require('../service/games.js');

router.post('/', function(req, res, next) {
    let word = req.body.word;
    if (word &amp;&amp; /^[A-Za-z]{3,}$/.test(word)) {
<strong>        service.create(req.user.id, word, (err, game) =&gt; {</strong>
<strong>            if (err) {</strong>
<strong>                next(err);</strong>
<strong>            } else {</strong>
<strong>                res.redirect(`/games/${game.id}/created`);</strong>
<strong>            }</strong>
<strong>        });</strong>
    } else {
        res.status(400).send('Word must be at least three characters long and contain only letters');
    }
});

<strong>const checkGameExists = function(id, res, onSuccess, onError) {</strong>
<strong>    service.get(id, function(err, game) {</strong>
<strong>        if (err) {</strong>
<strong>            onError(err);</strong>
<strong>        } else {</strong>
<strong>            if (game) {</strong>
<strong>                onSuccess(game);</strong>
<strong>            } else {</strong>
<strong>                res.status(404).send('Non-existent game ID');</strong>
<strong>            }</strong>
<strong>        }</strong>
<strong>    });</strong>
<strong>};</strong>

router.get('/:id', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; { ... },
<strong>        next);</strong>
});

router.post('/:id/guesses', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; { ... },
<strong>        next);</strong>
});

router.delete('/:id', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; {
            if (game.setBy === req.user.id) {
<strong>                game.remove((err) =&gt; {</strong>
<strong>                    if (err) {</strong>
<strong>                        next(err);</strong>
<strong>                    } else {</strong>
<strong>                        res.send();</strong>
<strong>                    }</strong>
<strong>                });</strong>
            } else {
                res.status(403).send('You don't have permission...');
            }
        },
<strong>        next);</strong>
});

router.get('/:id/created', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; res.render('createdGame', game),
<strong>        next);</strong>
});

module.exports = router;</pre></div><p>In this <a id="id296" class="indexterm"/>case, the changes are straightforward. Each call to a games service function now passes in a callback. The callback<a id="id297" class="indexterm"/> contains the logic that used to follow the call to the games service function. Each callback also needs to handle the possibility of an error value. In this case, we simply pass it to the Express <code class="literal">next</code> callback so it will be handled by our global error handler.</p><p>Although these changes are straightforward, they have introduced some repetitive boilerplate to our code. This is even more of a problem in the index route; take a look at the code from <code class="literal">src/routes/index.js</code>:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();
var games = require('../service/games.js');

router.get('/', function(req, res, next) {
<strong>  games.createdBy(req.user.id, (err, createdGames) =&gt; {</strong>
<strong>    if (err) {</strong>
<strong>      next(err);</strong>
<strong>    } else {</strong>
<strong>      games.availableTo(req.user.id, (err, availableGames) =&gt; {</strong>
<strong>        if (err) {</strong>
<strong>          next(err);</strong>
<strong>        } else {</strong>
<strong>          res.render('index', {</strong>
<strong>            title: 'Hangman',</strong>
<strong>            userId: req.user.id,</strong>
<strong>            createdGames: createdGames,</strong>
<strong>            availableGames: availableGames,</strong>
<strong>            partials: { createdGame: 'createdGame' }</strong>
<strong>          });</strong>
<strong>        }</strong>
<strong>      });</strong>
<strong>    }</strong>
  });});

module.exports = router;</pre></div><p>Here, we need to combine the result of two different asynchronous calls. This leads to nested callbacks. We also have to repeat the error-handling code at each stage. Note also that we only start the second asynchronous operation after the first one completes. It would be better to start the operations in parallel.</p><p>Recall that, <a id="id298" class="indexterm"/>while JavaScript itself is single-threaded, asynchronous operations may perform work in parallel, for <a id="id299" class="indexterm"/>example, network, disk, and other I/O operations. Running multiple operations in parallel would need even more complicated (and error-prone) boilerplate code. For an example of how this might work, consider the changes to make the <code class="literal">beforeEach</code> function in the games service test asynchronous. The following code is from <code class="literal">src/test/services/games.js</code>:</p><div><pre class="programlisting">describe('Game service', function() {
    let firstUserId = 'user-id-1';
    let secondUserId = 'user-id-2';
    
<strong>    beforeEach(function(done) {</strong>
<strong>        service.availableTo('not-a-user', (err, gamesAdded) =&gt; {</strong>
<strong>            let gamesDeleted = 0;</strong>
<strong>            if (gamesAdded.length === 0) {</strong>
<strong>                done();</strong>
<strong>            }</strong>
<strong>            gamesAdded.forEach(game =&gt; {</strong>
<strong>                game.remove(() =&gt; {</strong>
<strong>                    if (++gamesDeleted === gamesAdded.length) {</strong>
<strong>                        done();</strong>
<strong>                    }</strong>
<strong>                });</strong>
<strong>            });</strong>
<strong>        });</strong>
<strong>    });</strong>

    ...
});</pre></div><p>Here, we need to make an unknown number of calls to the asynchronous remove method. The <code class="literal">done</code> callback must be invoked when they are all complete. There are several ways of achieving this, but they all involve additional boilerplate. The approach here is the simplest possible, keeping count of the number of complete operations. Also note that we are omitting error handling, since this is test code. In production code, we would have to worry about error handling as well, making things even more complicated.</p><div><h3 class="title"><a id="note10"/>Note</h3><p>There are other changes to the tests to make use of the new asynchronous interface of the games service. They are excluded here for brevity. They are similar to the changes in <code class="literal">index.js</code>. You can see a full set of changes by viewing this chapter's first commit in the Git repository at <a class="ulink" href="https://github.com/NodeJsForDevelopers/chapter08">https://github.com/NodeJsForDevelopers/chapter08</a>.</p></div><p>This all<a id="id300" class="indexterm"/> seems quite unsatisfactory. Our code has become more complicated, repetitive, and harder to read. Fortunately, we can address these issues by using a different approach to writing asynchronous code.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec42"/>Writing cleaner asynchronous code using promises</h1></div></div></div><p>
<strong>Promises</strong> are <a id="id301" class="indexterm"/>an alternative pattern to callbacks for<a id="id302" class="indexterm"/> writing asynchronous<a id="id303" class="indexterm"/> code. A promise represents an operation that hasn't completed yet but is expected to do so in the future. As the name <em>promise</em> suggests, a promise is a contract to eventually provide a value or a reason for failure (that is, an error). You may already be familiar with this pattern from Tasks in .NET or Futures in Java. A promise has three possible states:</p><div><ul class="itemizedlist"><li class="listitem"><strong>pending</strong> represents<a id="id304" class="indexterm"/> an in-progress operation</li><li class="listitem"><strong>fulfilled</strong> representing <a id="id305" class="indexterm"/>a successful operation, with a result value</li><li class="listitem"><strong>rejected</strong> representing <a id="id306" class="indexterm"/>an unsuccessful operation, with a failure reason</li></ul></div><p>When executing a single operation, the callback-based and promise-based approaches appear quite similar. The power of promises comes when combining asynchronous operations.</p><p>Consider an example where we have asynchronous library functions for obtaining, processing, and aggregating data. We want to perform these operations in turn then display the result, handling errors as we go. Using callbacks, it might look like this (in non-runnable, fictional code):</p><div><pre class="programlisting">lib.getInitialData(function(e, initialData) {
  if (e) {
    console.log('Error: ' + e);
  } else {
    lib.processData(initialData, (e, processedData) =&gt; {
      if (e) {
        console.log('Error: ' + e);
      } else {
        lib.aggregateData(processedData, (e, aggregatedData) =&gt; {
          if (e) {
            console.log('Error: ' + e);
          } else {
            console.log('Success! Result=' + aggregatedData);
          }
        });
      }
    });
  }
});</pre></div><p>This has<a id="id307" class="indexterm"/> many of the same problems we <a id="id308" class="indexterm"/>encountered in our own code in the previous section: nested callbacks, extra boilerplate, and repetitive error-handling. If these functions instead returned promises, the equivalent of the above code would be as follows:</p><div><pre class="programlisting">lib.getInitialData()
    .then(lib.processData)
    .then(lib.aggregateData)
    .then(function(aggregatedData) {
        console.log('Success! Result=' + result);
    }, function(error) {
        console.log('Error: ' + error);
    });</pre></div><p>The <code class="literal">then</code> function applies a function to the resulting value of a promise, returning a new promise. In this way, we construct a chain of promises representing a series of operations.</p><p>The <code class="literal">then</code> function takes two arguments, which are both callbacks. If the asynchronous operation returns an error, the second argument will be invoked instead. In the above example, if the <code class="literal">library.aggregateData</code> call fails, then we will log an error.</p><p>If the second <code class="literal">then</code> callback parameter is omitted, any errors propagate along the chain of promises. In the above example, this means that if the <code class="literal">library.processData</code> call fails, then <code class="literal">library.aggregateData</code> will not be called and our error-logging callback will still be invoked.</p><p>If you only care about the error case, you can just specify an error callback using the <code class="literal">catch</code> function instead of <code class="literal">then</code>. You can also use this together with propagation to rewrite the preceding code more clearly:</p><div><pre class="programlisting">library.getInitialData()
    .then(library.processData)
    .then(library.aggregateData)
    .then(function(aggregatedData) {
        console.log('Success! Result=' + result);
<strong>    })</strong>
<strong>    .catch(function(error) {</strong>
<strong>        console.log('Error: ' + error);</strong>
    });</pre></div><p>Here, errors<a id="id309" class="indexterm"/> at any point propagate to a <a id="id310" class="indexterm"/>final promise which we check for errors. Note that this rewritten version would also catch any errors thrown by our success-logging callback, which the preceding version would not have done. You should always call <code class="literal">catch</code> at the end of a promise chain, unless you are returning the resulting promise object to be consumed elsewhere.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec44"/>Implementing promise-based asynchronous code</h2></div></div></div><p>Let's <a id="id311" class="indexterm"/>apply the promise<a id="id312" class="indexterm"/> pattern to our existing application. First, we'll need to update our game service API to expose promises instead of callbacks. As before, this is straightforward since our game service doesn't actually use any asynchronous operations in its implementation (yet). A promised-based version of our games service looks like the following (in <code class="literal">src/services/games.js</code>):</p><div><pre class="programlisting">'use strict';

const games = [];
let currentId = 1;

class Game {
    ...
    
<strong>    remove() {</strong>
        games.splice(games.indexOf(this), 1);
<strong>        return Promise.resolve();</strong>
    }
}

<strong>module.exports.create = (userId, word) =&gt; {</strong>
    const newGame = new Game(nextId++, userId, word); 
    games.push(newGame);
<strong>    return Promise.resolve(newGame);</strong>
};
<strong>module.exports.get = (id) =&gt;</strong>
<strong>    Promise.resolve(</strong>
<strong>        games.find(game =&gt; game.id === parseInt(id, 10)));</strong>
<strong>module.exports.createdBy = (userId) =&gt;</strong>
<strong>    Promise.resolve(games.filter(game =&gt; game.setBy === userId));</strong>
<strong>module.exports.availableTo = (userId) =&gt;</strong>
<strong>    Promise.resolve(games.filter(game =&gt; game.setBy !== userId));</strong>
</pre></div><p>Creating a promise-based interface is even simpler than a callback-based one. We can create a <a id="id313" class="indexterm"/>promise for <a id="id314" class="indexterm"/>an already known value using the <code class="literal">Promise.resolve()</code> function. Each function in our games service looks much like the original synchronous version, just with an extra call to <code class="literal">Promise.resolve</code>.</p><div><h3 class="title"><a id="note11"/>Note</h3><p>If you pass a promise argument to <code class="literal">Promise.resolve</code>, then you get back a promise that behaves like the original argument. If you pass any other value, you get an already resolved promise for that value. This can be useful if you need to operate on a variable that might be a promise or a value. You can pass it to <code class="literal">Promise.resolve</code>, then treat it consistently as a promise.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec09"/>Consuming the promise pattern</h3></div></div></div><p>Now we <a id="id315" class="indexterm"/>need to update the rest of our codebase to use promises. Let's look through the same files as before, starting with the games route. See the following code from <code class="literal">src/routes/games.js</code>:</p><div><pre class="programlisting">'use strict';

const express = require('express');
const router = express.Router();
const service = require('../service/games.js');

router.post('/', function(req, res, next) {
    let word = req.body.word;
    if (word &amp;&amp; /^[A-Za-z]{3,}$/.test(word)) {
<strong>        service.create(req.user.id, word)</strong>
<strong>            .then(game =&gt;</strong>
<strong>                res.redirect(`/games/${game.id}/created`))</strong>
<strong>            .catch(next);</strong>
    } else {
        res.status(400).send('Word must be at least three characters long and contain only letters');
    }
});

<strong>const checkGameExists = function(id, res, onSuccess, onError) {</strong>
<strong>    service.get(id)</strong>
<strong>        .then(game =&gt; {</strong>
<strong>            if (game) {</strong>
<strong>                onSuccess(game);</strong>
<strong>            } else {</strong>
<strong>                res.status(404).send('Non-existent game ID');</strong>
<strong>            }</strong>
<strong>        })</strong>
<strong>        .catch(onError);</strong>
<strong>};</strong>

...

router.delete('/:id', function(req, res, next) {
    checkGameExists(
        req.params.id,
        res,
        game =&gt; {
            if (game.setBy === req.user.id) {
<strong>                game.remove()</strong>
<strong>                    .then(() =&gt; res.send())</strong>
<strong>                    .catch(next);</strong>
            } else {
                res.status(403).send('You do not have permission to delete this game');
            }
        },
        next);
});</pre></div><p>This file <a id="id316" class="indexterm"/>was the simplest before, so shows the least difference here. We still have a little repetition of boilerplate (for example, the <code class="literal">catch</code> call). Still, the promise-based approach is more compact and readable than with callbacks. Now let's look at the index route code from <code class="literal">src/routes/index.js</code>:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();
var games = require('../service/games.js');

router.get('/', function(req, res, next) {
<strong>    games.createdBy(req.user.id)</strong>
<strong>        .then(gamesCreatedByUser =&gt; </strong>
<strong>            games.availableTo(req.user.id)</strong>
<strong>                .then(gamesAvailableToUser =&gt; {</strong>
<strong>                    res.render('index', {</strong>
<strong>                        title: 'Hangman',</strong>
<strong>                        userId: req.user.id,</strong>
<strong>                        createdGames: gamesCreatedByUser,</strong>
<strong>                        availableGames: gamesAvailableToUser</strong>
<strong>                    });</strong>
<strong>                }))</strong>
<strong>        .catch(next);</strong>
});

module.exports = router;</pre></div><p>This is a little better. There is less repetition, but still some nesting and boilerplate. Note that the <a id="id317" class="indexterm"/>outermost <code class="literal">then</code> callback returns a promise (chained from <code class="literal">games.availableTo</code>). When a <code class="literal">then</code> callback returns a promise, this is effectively flattened, so the overall promise returns the value of the inner promise. This flattening also applies to the propagation of errors, so we don't need to call <code class="literal">catch</code> on the inner promise explicitly.</p><p>This code is still a little confusing to follow. There is actually a way to make it much more readable, which we'll come back to shortly. Let's first look at the <code class="literal">beforeEach</code> function in the games service test in the following code from <code class="literal">test/service/games.js</code>:</p><div><pre class="programlisting">describe('Game service', function() {
    let firstUserId = 'user-id-1';
    let secondUserId = 'user-id-2';
    
    beforeEach(function(done) {
<strong>        service.availableTo('non-existent-user')</strong>
<strong>            .then(games =&gt; games.map(game =&gt; game.remove()))</strong>
<strong>            .then(gamesRemoved =&gt; Promise.all(gamesRemoved))</strong>
<strong>            .then(() =&gt; done(), done);</strong>
    });
});</pre></div><p>This has become much shorter and more linear. Let's break down what each line does:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">service.availableTo</code> returns a promise of an array of games</li><li class="listitem">The first <code class="literal">then</code> callback uses <code class="literal">array.map</code> to convert this into a <em>promise of an array of promises</em> of delete operations</li><li class="listitem">The next <code class="literal">then</code> callback uses <code class="literal">Promise.all</code> to convert this into a single promise for the whole array of delete operations<div><h3 class="title"><a id="note12"/>Note</h3><p>The <code class="literal">Promise.all</code> function takes an array of promises and returns a promise that resolves when all of the promises in the array have resolved or is rejected as soon as any promise in the array is rejected.</p></div></li><li class="listitem">The final <code class="literal">then</code> callback is invoked when the promise returned from <code class="literal">Promise.all</code> resolves, that is, when all the delete operations are complete, and invokes Mocha's <code class="literal">done</code> callback</li></ul></div><p>Note that unlike with the callback-based approach, it is also trivial to implement error handling. We<a id="id318" class="indexterm"/> just pass in the <code class="literal">done</code> callback as the error handler (second argument) to the final <code class="literal">then</code> call. We can take a similar approach in the tests themselves as we've done here with the <code class="literal">beforeEach</code> callback. Again, the updates to the tests are omitted for brevity, but you can find them in the book's companion code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec45"/>Parallelising operations using promises</h2></div></div></div><p>We can <a id="id319" class="indexterm"/>also make use of the <code class="literal">Promise.all</code> function to simplify the index route. Recall that our code is invoking the<a id="id320" class="indexterm"/> two asynchronous operations one after the other. In the callback-based approach, attempting to execute these in parallel would have made the code even more complicated. With promises, it actually makes our code more readable:</p><div><pre class="programlisting">var express = require('express');
var router = express.Router();
var games = require('../service/games.js');

router.get('/', function(req, res, next) {
<strong>    Promise.all([</strong>
<strong>        games.createdBy(req.user.id),</strong>
<strong>        games.availableTo(req.user.id)</strong>
<strong>    ])</strong>
<strong>        .then(results =&gt; {</strong>
<strong>            res.render('index', {</strong>
<strong>                        title: 'Hangman',</strong>
<strong>                        userId: req.user.id,</strong>
<strong>                        createdGames: results[0],</strong>
<strong>                        availableGames: results[1]</strong>
<strong>                    });</strong>
<strong>                })</strong>
<strong>        .catch(next);</strong>
});

module.exports = router;</pre></div><p>This is shorter and much easier to understand. We kick off two asynchronous operations to load data, then make use of the data as soon as both operations have completed.</p><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The only slight drawback of the preceding approach is that we have to get each of the two values back out of the array by their index. In Node.js v6 or higher, we could avoid this and make the code more readable still by using <strong>destructuring </strong>to <a id="id321" class="indexterm"/>assign <a id="id322" class="indexterm"/>two named parameters from the values in the array, as follows:</p><div><pre class="programlisting">        .then(([created, available]) =&gt; { ...</pre></div><p>This isn't used in the example above for back-compatibility with Node.js v4. We will discuss destructuring in more detail in <a class="link" title="Chapter 14. Node.js and Beyond" href="part0081.xhtml#aid-2D7TI1">Chapter 14</a>, <em>Node.js and Beyond</em>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Combining asynchronous programming patterns</h1></div></div></div><p>Promises<a id="id323" class="indexterm"/> allow us to address some of the shortcomings of the callback pattern and write more readable code. Now we have a new problem, though. One of the merits of Node.js is the consistent approach to asynchronous programming. We seem to have negated this by introducing promises as well as the conventional callback pattern.</p><p>Furthermore, although native promises are new to ECMAScript 2015, the concept is not new. There are many pre-existing libraries that provide their own implementation of promises.</p><p>Fortunately, these competing approaches to asynchronous programming are actually very consistent. The biggest value of the consistency in the Node.js-style callback pattern comes from the following:</p><div><ul class="itemizedlist"><li class="listitem">All library functions are asynchronous (non-blocking) by default</li><li class="listitem">All asynchronous operations return a single value or an error</li></ul></div><p>Promises are completely consistent with the above points. There is also excellent compatibility between different implementations of promises in JavaScript. This is thanks to the Promises/A+ specification (<a class="ulink" href="http://promisesaplus.com">http://promisesaplus.com</a>). This essentially defines the behavior<a id="id324" class="indexterm"/> of the <code class="literal">then</code> method. Any promise library you are likely to come across will follow this spec. Native JavaScript promises are also designed to be compatible with it. These means that all of these libraries and native JavaScript promises are interoperable.</p><p>So all libraries using callbacks follow the same convention and all promise libraries follow the same specification. The only issue remaining is converting between promises and callbacks. There are several promise libraries that can do this for us.</p><p>If you just want to convert a few standard callback functions to promises, you can use <code class="literal">denodeify</code>, which can be installed using npm. Our <code class="literal">fs.stat</code> example from earlier would look like this:</p><div><pre class="programlisting">const denodeify = require('denodeify');
const stat = denodeify(require('fs').stat));
stat('/hello/world')
    .then(stats =&gt; console.log('File last updated at: ' + stats.mtime));</pre></div><p>You will<a id="id325" class="indexterm"/> also find that many libraries expose functions that can return a promise or accept a callback and so can be invoked with either pattern.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to expose the standard Node.js callback interface in our own modules. We have made use of promises to produce more readable asynchronous code. Finally, we have seen how we can use promises together with standard Node.js callbacks.</p><p>Now that we can implement our own asynchronous APIs, we can expand on our application and start making use of other libraries that provide asynchronous interfaces. In the next chapter, we will make use of this to introduce persistent storage to our application.</p></div></body></html>