<html><head></head><body>
        

                            
                    <h1 class="header-title">Building Reusable Web Components</h1>
                
            
            
                
<p>In the previous chapter, we talked about styling our Web Components, along with understanding how accessibility plays a vital role in creating a good component. We then talked about the Gold Standard Checklist and looked into unit testing. </p>
<p>In this chapter, we will be looking deep into reusability and how we can publish our Web Components on a platform for maximum reusability. We will also cover a few examples on responsive Web Components. We did look into styling, and while the concept of responsive CSS is not something new, the use of responsive styles could make a component look even better and more reusable.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h1">The concept of reusability</li>
<li class="h1">Responsive Web Components</li>
<li class="h1">Publishing Web Components</li>
<li class="h1">Extending Web Components - slots</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The concept of reusability</h1>
                
            
            
                
<p>Before we even dive into the concept of reusability in Web Components, let's take a look at what reusability is with the help of an example. Let's take an example of an operating system, say Windows 10. Now, we all know there are a lot of computers. Some with the same hardware and some with different. But what makes this piece of software (Windows 10) reusable is its ability to being used again and again and in different scenarios without any issues. The exact same thing can be made to work for a Web Component. </p>
<p>Yes, Web Components can be made extremely reusable. Let's say we have a Web Component <kbd>&lt;custom-header&gt;</kbd>. As the name indicates, it is a header. And most of the sites that we have ever visited have one or the other version of the same functional header. The functionalities are as follows:</p>
<ol>
<li>Show the logo.</li>
<li>Clicking on the logo should drop the user to <kbd>index.html</kbd>.</li>
<li>Show the name of the company.</li>
<li>Show user stats, that is, if the user is not logged in, show the login drop-down menu. If the user is logged in, show account-related links.</li>
<li>Show Help links.</li>
<li>Show About us and Contact us links.</li>
<li>Provide a default background for the header.</li>
<li>The header can be sticky at the top.</li>
</ol>
<p>These points all show us various ways a header can be customized and implemented. We can very well convert these points to an attribute list while designing the Web Component:</p>
<pre>&lt;custom-header<br/>  logo-url="icon.png"<br/>  logo-alt-text="Company X logo"<br/>  company-name-text="Company X"<br/>  is-logged-in="user23411"<br/>  help-link="/help.html"<br/>  help-link-text="Help and Support"<br/>  contact-us-link="/contact.html"<br/>  contact-us-alt-text="Contact Us"<br/>  background-color="#000000"<br/>  text-color="#ffffff"<br/>  is-sticky="true"&gt;<br/>&lt;/custom-header&gt;</pre>
<p>Or if the user is not logged in, it can be left empty like this:</p>
<pre>&lt;custom-header<br/>  logo-url="icon.png"<br/>  logo-alt-text="Company X logo"<br/>  company-name-text="Company X"<br/>  is-logged-in=""<br/>  help-link="/help.html"<br/>  help-link-text="Help and Support"<br/>  contact-us-link="/contact.html"<br/>  contact-us-alt-text="Contact Us"<br/>  background-color="#000000"<br/>  text-color="#ffffff"<br/>  is-sticky="true"&gt;<br/>&lt;/custom-header&gt;</pre>
<p>All these attributes make the Web Component extremely reusable. The person who is going to use this component will simply need to import it and provide the values of these attributes without coding anything extra.</p>
<p>Let's take a look at another, but complex, example. Let us say you are building a music player. A Web Component <kbd>&lt;music-player&gt;</kbd> may have a bunch of attributes that make it extremely reusable. The common ones are as follows:</p>
<ul>
<li>Name of the song</li>
<li>URL of the song</li>
<li>Player color/contrast options</li>
<li>Is playing, to tell whether the player is playing or not</li>
<li>Play on load, to tell whether the player should start playing as soon as the player loads</li>
<li>Show or hide playlist</li>
</ul>
<p>And the uncommon ones could be as follows:</p>
<ul>
<li>Player size could be set to large, medium, or small</li>
<li>Bottom sticky or top sticky, just like <kbd>Soundcloud</kbd> does</li>
<li>Like or dislike song</li>
</ul>
<p>Knowing these attributes and being able to implement them plays a very important role in creating a reusable component. A user looking for a music player with the ability to show liked or disliked songs will end up using the above-mentioned <kbd>&lt;music-player&gt;</kbd> component rather than something else.</p>
<p>The concept of reusability can be and should be applied to all the Web Components. It not only allows the Web Component to be used in more scenarios, it also makes it more maintainable, since we are making sure that it works in more scenarios. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Responsive Web Components</h1>
                
            
            
                
<p class="mce-root">In the last chapter, we talked about adding styles to our Web Component to make it look beautiful. This time, we will take a look at it from a reusability perspective. What if a person who is trying to reuse our Web Component decides to use it in an inline tag, or what if the Web Component is used as a full-width component? Let us look into how our Web Component would be displayed inside different box models and how it would look on different screen sizes. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building &lt;profile-info&gt; Web Component</h1>
                
            
            
                
<p>Let us take a look at an example Web Component. Let's say we have a Web Component called <kbd>&lt;profile-info&gt;</kbd>. And the purpose of this Web Component is to show information about an employee. The information could be name, designation, ID number, profile picture, and a card background color to state whether the employee is a full-time employee, a part-time employee, or a contractor.</p>
<p>The HTML structure for this <kbd>&lt;profile-info&gt;</kbd> component would look something like this:</p>
<pre>&lt;profile-info<br/>  name="John Doe"<br/>  designation="Frontend Engineer - Marketing"<br/>  id-number="PRC-1455"<br/>  picture-src="img/john-doe.png"<br/>  employee-type="ft"&gt;<br/>&lt;/profile-info&gt;</pre>
<p>From the list of attributes, we can see that it needs a name, designation, ID number, picture link, and employee type. This is what it needs to do in terms of functionality. In terms of look and feel, it needs to look like a card with rounded profile picture, along with all the remaining information. And based on the resolution of the screen, it needs be either full-width, or if the screen is that of a mobile device, it should be shown in the form of a card.</p>
<p>Let's do a mobile first approach on the Web Component, and start writing the code:</p>
<pre>export default class ProfileInfo extends HTMLElement {<br/>  constructor() {<br/><br/>    // We are not even going to touch this.<br/>    super();<br/><br/>    // lets create our shadow root<br/>    this.shadowObj = this.attachShadow({mode: 'open'});<br/><br/>    // Then lets render the template<br/>    this.render();<br/>  }<br/><br/>  render() {<br/>    this.shadowObj.innerHTML = this.getTemplate();<br/>  }<br/><br/>  getTemplate() {<br/>    // Show HTML Here<br/>  }<br/>}</pre>
<p>This is the most basic part that we have covered in the previous chapters. We are simply creating the component skeleton and making sure that the HTML for the shadow DOM is retrieved from the <kbd>getTemplate()</kbd> method.</p>
<p>For the mobile view, the card should look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5d250889-7a41-43d8-84b9-8cabcf4e6ea2.png" style="width:14.83em;height:20.58em;"/></p>
<p>The HTML structure would look something like this:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;div class="profile-info__container"&gt;<br/>      &lt;img class="profile-info__picture"<br/>        src="img/${this.getAttribute('picture-src')}" /&gt;<br/>      &lt;div class="profile-info__text"&gt;<br/>        &lt;div class="profile-info__name"&gt;<br/>          ${this.getAttribute('name')}<br/>        &lt;/div&gt;<br/>        &lt;div class="profile-info__designation"&gt;<br/>          ${this.getAttribute('designation')}<br/>        &lt;/div&gt;<br/>        &lt;div class="profile-info__id-number"&gt;<br/>          ${this.getAttribute('id-number')}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>}</pre>
<p>If you take a look at the class names, they are all using BEM patterns.</p>
<p>If you have no idea as to what BEM is, the full form of BEM is Block Element Modifier. It is a methodology of using logical and reusable CSS classes for modular HTML blocks. If you would like to look into it, feel free to look at the following link: <a href="http://getbem.com/" target="_blank">http://getbem.com/</a>.</p>
<p>Now, let us take a look at the CSS required to build this card. I am wrapping the CSS inside another method called <kbd>getStyles()</kbd> and then I am including it inside the <kbd>getTemplate()</kbd> method:</p>
<pre>getStyles() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>        font-family: sans-serif;<br/>      }<br/>      :host(.profile-info__emp-type-ft) {<br/>        background-color: #7bb57b;<br/>      }<br/>      :host(.profile-info__emp-type-pt) {<br/>        background-color: #ffc107;<br/>      }<br/>      :host(.profile-info__emp-type-ct) {<br/>        background-color: #03a9f4;<br/>      }<br/><br/>      .profile-info__container {<br/>        display: flex;<br/>        color: white;<br/>        flex-direction: column;<br/>        text-align: center;<br/>      }<br/>      .profile-info__picture {<br/>        border-radius: 50%;<br/>        width: 80vw;<br/>        height: 80vw;<br/>        margin: 10px auto;<br/>      }<br/>      .profile-info__text {<br/>        padding: 10px;<br/>        flex: 1;<br/>      }<br/>      .profile-info__name {<br/>        font-size: 28px;<br/>      }<br/>      .profile-info__designation {<br/>        font-size: 22px;<br/>        margin-top: 10px;<br/>      }<br/>      .profile-info__id-number {<br/>        margin-top: 10px;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>And let's add the <kbd>getStyle()</kbd> method to the <kbd>getTemplate()</kbd> method:</p>
<pre>getTemplate() {<br/>  return `<br/>    ...<br/>    ...<br/>    ...<br/>    ${this.getStyles()}<br/>  `;<br/>}</pre>
<p>If you look inside the <kbd>getStyles()</kbd> method, we have these classes: </p>
<ul>
<li><kbd>:host(.profile-info__emp-type-ft)</kbd>, </li>
<li><kbd>:host(.profile-info__emp-type-pt)</kbd>, and </li>
<li><kbd>:host(.profile-info__emp-type-ct)</kbd>.</li>
</ul>
<p>These change the color of the card on the basis of employee type, that is, full-time, part-time, or contractor, respectively.</p>
<p>But we still have no way to add these classes, so we create a new function called <kbd>updateCardBackground()</kbd> that will be responsible for adding the associated class to the Web Component. And then we will call this class inside the <kbd>render()</kbd> method:</p>
<pre>updateCardBackground() {<br/>  this.classList.add(`profile-info__emp-type-${this.getAttribute('employee-type')}`);<br/>}<br/><br/>render() {<br/>  this.shadowObj.innerHTML = this.getTemplate();<br/><br/>  this.updateCardBackground();<br/>}</pre>
<p>It is doing nothing but getting the employee type from the attribute and then adding it to the class name of the host. </p>
<p>So if the employee is full-time, then the class becomes <kbd>.profile-info__emp-type-ft</kbd>; if the employee is part-time, then the class becomes <kbd>.profile-info__emp-type-pt</kbd>; and if the employee is a contractor, the class becomes <kbd>.profile-info__emp-type-ct</kbd>. Notice how it is grabbing the employee type from the attribute and appending it to the end of the string <kbd>.profile-info__emp-type-</kbd>.</p>
<p>Now that we are done with creating the component and styling it, let's add the CSS for larger screens, say tablet and desktop. For the sake of simplicity, we will use the same CSS for desktop and tablet. So, let's add the following CSS to our <kbd>getStyles()</kbd> method:</p>
<pre>@media screen and (min-width: 650px) {<br/>  .profile-info__container {<br/>    flex-direction: row;<br/>    text-align: left;<br/>  }<br/>  .profile-info__picture {<br/>    width: 100px;<br/>    height: 100px;<br/>    margin: 10px;<br/>  }<br/>}</pre>
<p class="mce-root"/>
<p>This makes sure that the Web Component looks like it's from a contact book, the way we see on desktops. And it will show up only when the screen size is more than <kbd>650px</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6c1cdbbf-2229-4c29-b775-83d8518fc7a4.png" style="width:23.67em;height:6.42em;"/></p>
<p>If you are building the Web Component along with this tutorial, try changing the width of the screen.</p>
<p>You can use a similar approach with any of the Web Components and make sure that it looks good when moved from one screen size to another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Publishing Web Components</h1>
                
            
            
                
<p class="mce-root">If you are developing a Web Component, whether it is for a company, a side project or something that is open source and publicly available, you can make it available for use by other people or team members very easily by publishing your Web Component on the web.</p>
<p>But even before you can publish, you need to make sure that the following steps are completed:</p>
<ul>
<li>Your component can be installed via <kbd>npm</kbd></li>
<li>A proper README file is present in the repository of your component with steps to use and attributes that can be changed</li>
<li>A demo folder of a working example with <kbd>index.html</kbd> file</li>
</ul>
<p>Let's prepare our file for <kbd>npm</kbd>. In order to do that, let's do a quick <kbd>npm init</kbd> inside the <kbd>repo</kbd> directory with the help of a terminal. I am going to do it with the <kbd>&lt;profile-info&gt;</kbd> component that we discussed in the previous section. That will generate a <kbd>package.json</kbd> file that looks something like this:</p>
<pre>{<br/>  "name": "profile-info",<br/>  "version": "0.0.1",<br/>  "description": "A webcomponent that shows information about an employee in the form of a profile card.",<br/>  "main": "ProfileInfo.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "keywords": [<br/>    "webcomponent",<br/>    "component",<br/>    "profile",<br/>    "info",<br/>    "employee"<br/>  ],<br/>  "author": "Prateek Jadhwani",<br/>  "license": "ISC",<br/>  "repository": "https://github.com/prateekjadhwani/profile-info"<br/>}</pre>
<p>We will then create a <kbd>ReadMe.md</kbd> file in our component directory. And add the following text at the top:</p>
<pre class="style-scope catalog-publish"><strong>[![Published on webcomponents.org](https://img.shields.io/badge/webcomponents.org-published-blue.svg)](https://www.webcomponents.org/element/owner/my-element)</strong></pre>
<p>I added mine with the following:</p>
<pre class="mce-root"><strong>[![Published on webcomponents.org](https://img.shields.io/badge/webcomponents.org-published-blue.svg)](https://www.webcomponents.org/element/prateekjadhwani/profile-info)</strong></pre>
<p>This will create a published on webcomponents.org site badge that can be viewed by people visiting your GitHub or GitLab page. And it looks something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bc661f12-04a0-4af5-929b-afff7243dc56.png" style="width:43.00em;height:11.08em;"/></p>
<p>Once this is done, we can set up our <kbd>Readme.md</kbd> file for a demo section. </p>
<p>You can add to the <kbd>Readme.md</kbd> file about the attributes, and how it can be used as shown here:</p>
<pre>```html<br/>&lt;profile-info<br/>  name="John Doe"<br/>  designation="Frontend Engineer - Marketing"<br/>  id-number="PRC-1455"<br/>  picture-src="img/john-doe.png"<br/>  employee-type="ft"&gt;<br/>&lt;/profile-info&gt;<br/>```</pre>
<p>Now you are ready to publish your Web Component on to the NPM JS site. Just type <kbd>npm publish</kbd> and it will push your code onto the site. </p>
<p>You can find the <kbd>&lt;profile-info&gt;</kbd> Web Component here at <a href="https://www.npmjs.com/package/profile-info" target="_blank">https://www.npmjs.com/package/profile-info:</a></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fb14233f-c25c-43e2-8d1b-2499fae8c7b9.png" style="width:56.75em;height:35.08em;"/></p>
<p>Once you are done with this, you can simply go to <a href="https://www.webcomponents.org/publish" target="_blank">https://www.webcomponents.org/publish</a> and scroll down to the section where it says Ready To Publish?, and simply put your npm package name and click on the Publish button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7303accc-908e-485a-ad10-0ebf72a44249.png" style="width:50.92em;height:19.92em;"/></p>
<p>This will publish your Web Component, which can be used by anyone. Now your component is available to be distributed across the web.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending Web Components – slots</h1>
                
            
            
                
<p>Till now, we have used Web Components with no HTML content inside them. That is, when we import an HTML tag for a Web Component that we created, we have never placed any other HTML tag inside it, for example:</p>
<pre>&lt;custom header&gt;<br/>    &lt;!-- no html here --&gt;<br/>&lt;/custom-header&gt;</pre>
<p>This creates a huge limitation on the Web Component that we are creating. In the <kbd>&lt;custom header&gt;</kbd> component, we failed to add dynamic links. You can argue that we can place link data in the form of attributes and then we can run a loop inside our component definition and build the links. But what if we want a button instead of links? What if we want to show user points instead of the button? So, not being able to do these things is a limitation.</p>
<p class="mce-root"/>
<p>In this section, we will extend our current knowledge of Web Components and use the concept of slots to put HTML content inside our Web Components. A slot is a placeholder for any HTML markup that can be placed inside a Web Component. A slot can have a name, and this slot can have HTML or plain text that can be used inside our component.</p>
<p>We will start with the Web Component that we have already worked on, <kbd>&lt;company-header&gt;</kbd>. The <kbd>getTemplate()</kbd> method of this component is as follows:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;a href="/"&gt;<br/>      &lt;img class="icon" src="img/${this.getAttribute('icon')}" /&gt;<br/>    &lt;/a&gt;<br/>    &lt;h1 class="heading"&gt;${this.getAttribute('page-name')}&lt;/h1&gt;<br/>    &lt;div&gt;<br/>      &lt;a class="header-links" href="/home.html"&gt;Home&lt;/a&gt;<br/>      &lt;a class="header-links" href="/aboutus.html"&gt;About Us&lt;/a&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>}</pre>
<p>In the preceding code, we can see that there are two links, <kbd>Home</kbd> and <kbd>About Us</kbd>. If we want to add one more link to this, we will need to modify the definition of the Web Component, which will in turn create problems with maintaining it and we will have to create a new version of it every time we want to add a new link. </p>
<p>In order to solve this problem, we will use slots. We will replace that whole <kbd>div</kbd> that contains the links with a slot of name <kbd>other-links</kbd>. Let's take a look at the code:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;a href="/"&gt;<br/>      &lt;img class="icon" src="img/${this.getAttribute('icon')}" /&gt;<br/>    &lt;/a&gt;<br/>    &lt;h1 class="heading"&gt;${this.getAttribute('page-name')}&lt;/h1&gt;<br/>    &lt;div&gt;<br/>      &lt;slot name="other-links"&gt;&lt;/slot&gt;<br/>    &lt;/div&gt;<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p>This way, we can create a slot that can be filled when we use the Web Component:</p>
<pre>&lt;company-header icon="icon.png" page-name="My Page"&gt;<br/>    &lt;ul slot="other-links" class="header-links__container"&gt;<br/>      &lt;li&gt;<br/>        &lt;a class="header-links" href="/home.html"&gt;Home&lt;/a&gt;<br/>      &lt;/li&gt;<br/>      &lt;li&gt;<br/>        &lt;a class="header-links" href="/aboutus.html"&gt;About Us&lt;/a&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>&lt;/company-header&gt;</pre>
<p class="mce-root">And here, we are filling the slot with a <kbd>&lt;ul&gt;</kbd> tag that has a <kbd>slot</kbd> attribute with a value <kbd>other-links</kbd>. You can have any HTML you want inside this slot. You can even replace it with plain text.</p>
<p>In a Web Component, there can be any number of slots. It totally depends on your use case. But, let us take a look at another example, where we use three slots.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating &lt;my-article&gt; Web Component</h1>
                
            
            
                
<p class="mce-root">Let's create a Web Component called <kbd>&lt;my-article&gt;</kbd> that has three slots: <kbd>author</kbd>, <kbd>article-heading</kbd>, and <kbd>article</kbd>. The definition of the Web Component is as follows starting with the template:</p>
<pre>getTemplate() {<br/>  return `<br/>    &lt;h1 class="article-heading"&gt;<br/>      &lt;slot name="article-heading"&gt;&lt;/slot&gt;<br/>    &lt;/h1&gt;<br/>    &lt;div class="article-author"&gt;<br/>      &lt;slot name="author"&gt;&lt;/slot&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="article-content"&gt;<br/>      &lt;slot name="article"&gt;&lt;/slot&gt;<br/>    &lt;/div&gt;<br/>    ${this.getStyle()}<br/>  `;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, there are three slots. One for heading, one for author name, and one for content. The <kbd>getStyle()</kbd> method looks something like this:</p>
<pre>getStyle() {<br/>  return `<br/>    &lt;style&gt;<br/>      :host {<br/>        display: block;<br/>        background: #e4f4fb;<br/>        padding: 10px;<br/>      }<br/>      .article-heading {<br/>        text-align: right;<br/>        text-transform: lowercase;<br/>        font-size: 50px;<br/>        margin-bottom: 0;<br/>      }<br/>      .article-author {<br/>        text-align: right;<br/>        text-transform: lowercase;<br/>        font-style: italic;<br/>        font-size: 22px;<br/>        padding-bottom: 20px;<br/>        border-bottom: 2px solid black;<br/>      }<br/>      .article-content {<br/>        line-height: 1.5;<br/>        margin-top: 20px;<br/>      }<br/>      .article-content::first-letter {<br/>        font-size: 50px;<br/>        line-height: 0;<br/>      }<br/>    &lt;/style&gt;<br/>  `;<br/>}</pre>
<p>And when we try to use it, it looks something like this:</p>
<pre>&lt;my-article&gt;<br/>  &lt;span slot="article-heading"&gt;A random article&lt;/span&gt;<br/>  &lt;span slot="author"&gt;Prateek Jadhwani&lt;/span&gt;<br/>  &lt;div slot="article"&gt;<br/>    &lt;p&gt;This is a demo paragraph&lt;/p&gt;<br/>    &lt;p&gt;This is another demo paragraph&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/my-article&gt;</pre>
<p class="mce-root"/>
<p>We can of course change the order of the slots while calling the <kbd>&lt;my-article&gt;</kbd> tag and it will still work as per the definition. The output will look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/cc21c5c7-20f5-4976-82cb-475a0cbc8d67.png" style="width:35.75em;height:16.75em;"/></p>
<p>As you can see, we do not have to worry about the look and feel of the content, as long as the classes inside the Web Component are taking care of the styling. This also shows that it is up to the user to use any number of slots. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we talked about reusability and how we can make sure that our Web Component is as reusable as possible. We even looked at how responsiveness can be incorporated inside a Web Component for maximum reuse.</p>
<p>We learned how to publish our Web Component on the internet as well as a new way of letting dynamic content inside a Web Component with the help of slots.</p>
<p>In the next chapter, we will look into state management, attributes, and how event handling works in a Web Component.</p>


            

            
        
    </body></html>