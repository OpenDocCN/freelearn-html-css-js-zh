- en: Chapter 12. Creating Maps with GeoJSON and TopoJSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3.js provides extensive capabilities for creating maps and to facilitate you
    in presenting data as part of the map or as an overlay. The functions for mapping
    within D3.js leverage a data format known as GeoJSON, a form of JSON that encodes
    geographic information.
  prefs: []
  type: TYPE_NORMAL
- en: Another common type of data for maps in D3.js is TopoJSON. TopoJSON is a more
    compressed form of GeoJSON. Both these formats are used to represent the cartographic
    information required to create a map, and D3.js processes this data and performs
    its usual magic of converting this information into SVG paths that visualize the
    map.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter wills start with a brief overview of GeoJSON and TopoJSON. This
    will give you the foundation to understand how maps are represented and rendered
    with D3.js. We will then jump into many examples using both data formats for rendering
    maps of various types, coloring the geometries within the map based upon data,
    and for overlaying information at specific locations on those maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific topics that we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of TopoJSON and GeoJSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a map of the United States with GeoJSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TopoJSON to draw the countries of the world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling the geometries that comprise a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panning and zooming of a map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with a globe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the boundaries of geometries on `mouseover` events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding symbols to a map at specific locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering maps of regions based upon data (using a choropleth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing TopoJSON and GeoJSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every map example in D3.js will use either **GeoJSON** or **TopoJSON**.
    GeoJSON is an open, standard, JSON-based format for representing basic geographical
    features as well as the non-spatial properties for those features (such as the
    name of a city or a landmark).
  prefs: []
  type: TYPE_NORMAL
- en: 'The core geometries in GeoJSON are points, line strings, and polygons. The
    basic description of a GeoJSON entity uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the four basic types of geometry types available in GeoJSON.
    A **point** represents a position in two-dimensional space, and consists of a
    pair of one latitude and longitude. A point is normally used to specify the location
    of a feature on a map (such as a building):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Representative GeoJSON |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Introducing TopoJSON and GeoJSON](img/B04230_12_01.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`LineString` describes a sequence of points which have a line drawn between
    them, starting at the first, through all intermediate points, and ending at the
    last coordinate. The name conjures up visions of stretching a string caught between
    all the points. These shapes are normally used to represent items such as, roads
    or rivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Representative GeoJSON |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Introducing TopoJSON and GeoJSON](img/B04230_12_02.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **polygon** is a closed shape normally consisting of three or more points,
    where the last point is the same as the first and forms a closed shape. The JSON
    representation is shown as follows; note that the coordinates are an array of
    arrays of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Representative GeoJSON |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Introducing TopoJSON and GeoJSON](img/B04230_12_03.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of an array of arrays of tuples is to allow multiple polygons to
    be defined, which exclude each other, thereby allowing the exclusions of one or
    more polygonal regions within one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Representative GeoJSON |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Introducing TopoJSON and GeoJSON](img/B04230_12_04.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to define multi-part geometries where a particular geometry
    type is reused, and where the coordinates describe multiple instances of the type
    of geometry. These types are the previous types prefaced with *Multi*—`MultiPoint`,
    `MultiLineString`, and `MultiPolygon`. Each is demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example | Representative GeoJSON |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MultiPoint | ![Introducing TopoJSON and GeoJSON](img/B04230_12_05.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| MultiLineString | ![Introducing TopoJSON and GeoJSON](img/B04230_12_06.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| MultiPolygon | ![Introducing TopoJSON and GeoJSON](img/B04230_12_08.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'These basic geometries can be wrapped within a **feature**. A feature contains
    a geometry and also a set of properties. As an example, the following defines
    a feature which consists of a point geometry, and which has a single property,
    `name`, which can be used to describe a name for that feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go up one more level in the hierarchy, and define what is known as a
    **feature** **collection**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By combining geometries, features, and feature collections, it is possible to
    describe very complex shapes such as maps.
  prefs: []
  type: TYPE_NORMAL
- en: But one of the problems with GeoJSON is that it is very verbose, and particular
    geometries and features cannot be reused. If the same geometry is required in
    multiple locations, it must be completely specified a second time.
  prefs: []
  type: TYPE_NORMAL
- en: To help fix this situation, TopoJSON was created. TopoJSON provides additional
    constructs for the encoding of topology and reuse. Instead of discretely describing
    each geometry, TopoJSON allows you to define geometries, and then stitch them
    together using concepts known as **arcs**.
  prefs: []
  type: TYPE_NORMAL
- en: Arcs allows TopoJSON to eliminate redundancy, and to provide a much more compact
    representation as compared to GeoJSON. It is stated that TopoJSON can commonly
    provide 80 percent compression over GeoJSON. With every millisecond of the download
    time of a web page being important, this can be significant for user experience
    when using large sets of geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full explanation of TopoJSON is a bit beyond the scope of this book, but
    to briefly demonstrate it, we can look at the following and briefly examine its
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This TopoJSON object has three properties: `type`, `objects`, and `arcs`. The
    value of `type` is always `"topology"`. The `objects` property consists of a geometry
    collection similar to those in GeoJSON, with the difference that instead of specifying
    coordinates, the object can, instead, specify one or more arcs.'
  prefs: []
  type: TYPE_NORMAL
- en: Arcs are the big difference in TopoJSON versus GeoJSON, and represent the means
    of reuse. The arcs property provides an array of arrays of positions, where a
    position is essentially a coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: These arcs are referenced by geometries of 0-based array semantics. Hence, the
    `LineString` geometry in the preceding code is referencing the first arc in the
    topology object by specifying `arcs[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: The polygon object is referencing an arc with value `-2`. A negative arc value
    specifies that the one's complement of the arc that should be utilized. This essentially
    infers that the positions in the arc should be reversed. Therefore, `-2` instructs
    to get the reversed position of the second arc. This is one of the strategies
    that TopoJSON uses to reuse and compress data.
  prefs: []
  type: TYPE_NORMAL
- en: There are other options, such as transforms and bounding boxes, and other rules.
    For a more detailed specification, please see [https://github.com/mbostock/topojson-specification](https://github.com/mbostock/topojson-specification).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important thing to note about TopoJSON is that D3.js itself only uses GeoJSON
    data. To use data in the TopoJSON format, you will need to use the TopoJSON plugin
    available at [https://github.com/mbostock/topojson](https://github.com/mbostock/topojson).
    This plugin will convert TopoJSON into GeoJSON that can be used by D3.js functions,
    thereby affording the capabilities of TopoJSON to your D3.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map of the United States
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first examples will examine creating a map of the United States. We will
    start with an example that loads the data and gets the map rendered, and then
    we will examine styling the map to make it more visible, followed by examples
    of modifying the projection used to render the content more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first map of the United States with GeoJSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first map will render the United States. We will use a GeoJSON data file,
    `us-states.json`, available at [https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-states.json](https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-states.json).
    The following are the first few lines of this file, and demonstrate how the shapes
    of the states are organized within the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`FeatureCollection` at the top level consists of an array of features, each
    element of which is a state (or territory) as well as Washington D.C. Each state
    is a feature, has a single property `Name`, and a polygon geometry representing
    the outline of the state expressed in latitude and longitude tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the example is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.1): [http://goo.gl/dzKsVd](http://goo.gl/dzKsVd)'
  prefs: []
  type: TYPE_NORMAL
- en: 'On opening the URL, you will see the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our first map of the United States with GeoJSON](img/B04230_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code required to take this data and render a map is sublimely simple (by
    design). It begins by creating the main SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'GeoJSON is simply JSON and can be loaded with `d3.json()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the data, we can then create a `d3.geo.path()`. This object has
    the smarts for taking the features in the GeoJSON and converting them into an
    SVG path. The code then adds a path to the main SVG element, binds the data, and
    sets the `d` property of the path to our `d3.geo.path()` object.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, with just a few lines of code, we have drawn a map of the United States!
  prefs: []
  type: TYPE_NORMAL
- en: Styling the map of the United States
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, this image is dark, and the borders between the states are not particularly
    visible. We can change this by providing a style for the fill and stroke values
    used to render the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this example is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.2): [https://goo.gl/chhKjz](https://goo.gl/chhKjz)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When opening this URL, you will see the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the map of the United States](img/B04230_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only change to the previous example is to set the fill to transparent,
    and the borders to black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the albersUsa projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have a few questions about the map in the previous two examples. First,
    how is the map scaled to the size of the SVG element? Second, can I change this
    scale? And why are Alaska and Hawaii drawn down where Mexico would normally be?
  prefs: []
  type: TYPE_NORMAL
- en: These are related to some underlying assumptions about a **projection**. A projection
    is a way of taking geographic data, which is 2D data (latitude and longitude),
    but which is really on a three dimensional sphere (the earth), and rendering it
    onto a 2D surface with specific dimensions (your computer screen or viewport in
    the browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, D3.js made some implicit assumptions on these factors. To
    help exemplify these assumptions, suppose we change the SVG element to be of size
    500 x 250\. When running this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the albersUsa projection](img/B04230_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code that creates this is available at the following location. The only
    change from the previous example is that the height and width of the SVG element
    have each been halved:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.3): [http://goo.gl/41wyCY](http://goo.gl/41wyCY)'
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the actual rendering is the same size, and we have clipped
    the lower and rightmost three-quarters of the map due to the smaller container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this? It is because, by default, D3.js uses a projection known as an
    **albersUsa** projection, which has a number of assumptions that come with it:'
  prefs: []
  type: TYPE_NORMAL
- en: The dimensions of the resulting map are 1024 x 728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map is centered at half of the width and height (512, 364)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The projection also places Alaska and Hawaii in the lower-left side of the map
    (aha!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change these assumptions, we can create our own `albersUsa` projection using
    a `d3.geo.albersUsa()` projection object. This object can be used to specify both
    a translation and scaling of the rendering of the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates an `albersUsa` projection and centers the map:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.4): [http://goo.gl/1e4DGp](http://goo.gl/1e4DGp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the albersUsa projection](img/B04230_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code creates a `d3.geo.albersUsa` projection, and tells it to center the
    map of the United States at `[width/2, height/2]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The projection object then needs to be assigned to the `d3.geo.path()` object
    using its `.projection()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have translated the center of the map, but the scale is still the same size.
    To change the scale, we use the projection''s `.scale()` function. The following
    example sets the scale to the width, telling D3.js that the width of the map should
    not be 1024, but the value of `width` and `height`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.5): [http://goo.gl/O51jPN](http://goo.gl/O51jPN)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example results in a properly scaled map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the albersUsa projection](img/B04230_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only difference in the code is the call to `.scale()` on the projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we only pass a single value to scale. The projection scales along
    the width, and then automatically and proportionately along the height.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a flat map of the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **albersUsa** projection is one of many D3.js supplied projection objects.
    You can see the full list of these projections at [https://github.com/mbostock/d3/wiki/Geo-Projections](https://github.com/mbostock/d3/wiki/Geo-Projections).
  prefs: []
  type: TYPE_NORMAL
- en: We don't have space to demonstrate all of these in this book, but a few are
    worth the effort to demonstrate a couple of TopoJSON concepts. Specifically, we
    will demonstrate the rendering of a map of the countries of the world, sourced
    from TopoJSON, and projected onto both flat and spherical surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For data in these examples, will use the `world-110m.json` data file provided
    with the TopoJSON data library source code available at [https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/world-110m.json](https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/world-110m.json).
  prefs: []
  type: TYPE_NORMAL
- en: This data represents country data with features, specified at a 110-meter resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and rendering with TopoJSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s examine loading and rendering of TopoJSON. The following example
    demonstrates the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.6): [http://goo.gl/aLhKKe](http://goo.gl/aLhKKe)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code does not vary much from the previous example. The change comes after
    the data is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The example still uses a `d3.geo.path()` object, but this object cannot directly
    be given the TopoJSON. What needs to be done is to first extract the portion of
    this data that represents the countries, which is done by calling the `topojson.feature()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `topojson` variable is globally declared in the `topojson.js` file. Its
    `.feature()` function, when given a TopoJSON object (in this case, `world`), and
    a `GeometryCollection` (in this case, `world.objects.countries`), returns a GeoJSON
    feature that can be used by a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The selection to render the map then binds to this result, giving us the following
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading and rendering with TopoJSON](img/B04230_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whoops! That's not what we expected (but as we will see, it is exactly what
    we coded). Why is everything globed together? It is because we are still using
    the default projection, a `d3.geo.albersUsa()` projection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a map of the world using a Mercator projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fix this, we simply need to create a Mercator projection object, and apply
    it to the path. This is a well known projection that renders the map of the globe
    in a rectangular area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is demosntrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.7): [http://goo.gl/IWQPte](http://goo.gl/IWQPte)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference in this code is the setup of the path to use a Mercator
    projection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to give the projection object a little information about the width
    and height of our rendering, and the resulting map is now the following, which
    looks a lot more like the familiar world map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a map of the world using a Mercator projection](img/B04230_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating spherical maps with orthographic projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s change our projection to an **orthographic** projection. This projection
    maps data on to a simulated sphere. This is demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.8): [http://goo.gl/M464W8](http://goo.gl/M464W8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example simply changes the previous one by using a `d3.geo.orthographic()`
    projection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example code gives us this beautiful rendering of the planet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating spherical maps with orthographic projection](img/B04230_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you examine this closely, you will notice that it is not quite perfect. Notice
    that Australia seems to be colliding with Africa and Madagascar, and New Zealand
    is seen in the South Atlantic ocean.
  prefs: []
  type: TYPE_NORMAL
- en: This is because this projection renders through all 360 degrees of the globe,
    and we are essentially seeing through a clear globe to the backside of the land
    masses on the far side.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we can use the `.clipAngle()` function of the Mercator projection.
    The parameter is the number of degrees around the center point to which the landmasses
    should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.9): [http://goo.gl/G28ir0](http://goo.gl/G28ir0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This changes one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating spherical maps with orthographic projection](img/B04230_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It may not be apparent in the image provided in the book, but this image of
    the globe on the web page is fairly small. We can change the scaling of the rendering
    using the `.scale()` function of the projection. The default value for scale is
    150, and the corresponding values will make the rendering larger or smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example makes the globe twice as large along with setting the
    center of the globe to not be clipped by the SVG container:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.10): [http://goo.gl/EVsHgU](http://goo.gl/EVsHgU)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This orthographic projection, by default, centers the view on the globe at latitude
    and longitude (**0,0**). If we want to center on another location, we need to
    `.rotate()` the projection by a number of degrees of latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example rotates the globe to show the United States prominently:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.11): [http://goo.gl/1acSjF](http://goo.gl/1acSjF)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one change to the projection is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This change in the projection gives us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating spherical maps with orthographic projection](img/B04230_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Spicing up a globe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this globe is quite impressive for the amount of code used to create
    it, it feels a little dull. Let's differentiate the countries a little more, and
    also add the lines of latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Coloring the countries on a globe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can color the countries on the globe using a `d3.scale.category20()` color
    scale. But we can't simply rotate through the colors, as there will be cases where
    adjacent countries will be filled with the same color.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, we will take advantage of another function of TopoJSON, `topojson.neighbors()`.
    This function will return, given a set of geometries (like the countries), a data
    structure that identifies which geometries are adjacent to each other. We can
    then utilize this data to prevent the potential problem with colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.12): [http://goo.gl/9UimER](http://goo.gl/9UimER)'
  prefs: []
  type: TYPE_NORMAL
- en: The projection in this example remains the same. The remainder of the code is
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by using the same projection as the last example so that code is not
    repeated here. The following creates the data structure of the colors, the countries,
    and the neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation of the globe then uses the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our resulting globe is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coloring the countries on a globe](img/B04230_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pretty nice! But it's still lacking in the lines of longitude or latitude, and
    you can't really tell what the extents of the globe are. Let's fix that now by
    adding the lines of latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: You'll be really surprised at how easy it is to add the latitudes and longitudes.
    In D3.js, these are referred to as **graticules**. We create them by instantiating
    a `d3.geo.graticules()` object, and then by appending a separate path prior to
    the path for the countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.13): [http://goo.gl/5eJOai](http://goo.gl/5eJOai)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only code added to the previous example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The change in code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coloring the countries on a globe](img/B04230_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Voila! And as they say, easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity to maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What good is a map if the user is not able to pan and zoom around the map to
    change the focus, and take a closer look at things? Fortunately, because of D3.js,
    this becomes very simple to implement. We will look at three different examples
    of interactivity and maps:'
  prefs: []
  type: TYPE_NORMAL
- en: Panning and zooming a world map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting country borders on `mouseover`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating a globe with the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panning and zooming a world map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate panning and zooming of a world map, we will make a few modifications
    to our world Mercator projection example. These modifications will be for using
    the mouse wheel to zoom in and out, and to be able to drag the map to move it
    to another center.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible image with this version of the map code could look like the following,
    which is centered just east of Brazil, and brought up several factors of zoom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Panning and zooming a world map](img/B04230_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of considerations that we should take into account when
    panning and zooming a map:'
  prefs: []
  type: TYPE_NORMAL
- en: We can only zoom in and out between two extents so that we do not zoom out too
    far as to lose sight of the map, or too close as to get lost in a single country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can only drag the map to a certain extent to ensure that it is constrained
    and not dragged off some edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.14): [http://goo.gl/jjouGK](http://goo.gl/jjouGK)'
  prefs: []
  type: TYPE_NORMAL
- en: Much of the code is reused from the Mercator projection example, and also adds
    the code to uniquely color the countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of the main SVG element differs to allow for drag and zoom. This
    starts with creating a zoom behavior, and assigning it to the main SVG element.
    Additionally, since we need to zoom the client elements, we add a group to facilitate
    this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the main part of the code loads the data and renders the map, and
    is identical to the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `moveAndZoom` function, which will be called on any drag and zoom events,
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From these values, we need to adjust the SVG translate on the map based upon
    the current mouse position, while taking into account the scale level. We also
    do not want this to translate the map in any direction such that there is padding
    between the map and the boundaries; this is handled by combined calls to `Math.min`
    and `Math.max`.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you now have a fully pan and scan map!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that as you zoom in, the boundaries on the countries are fairly ragged.
    This is due to the 110-meter resolution of the data. To have more accurate graphics,
    use the files with the finer details. Even better, dynamically change to higher
    resolution data depending upon the zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting country borders on mouse hover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s add another interactivity effect to our map: highlighting the border
    of a country which has the mouse currently over its geometry. This will help us
    accentuate the country the user is currently examining. A quick demonstration
    of this is the following, where Peru has a thin white border:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Highlighting country borders on mouse hover](img/B04230_12_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.15): [http://goo.gl/DTtJ2A](http://goo.gl/DTtJ2A)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is implemented with a few modifications to the previous example. The modifications
    start with the creation of the top-level group element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code informs D3.js that all SVG elements contained within the group will
    have a 2-pixel white border, which is initially transparent. When we hover the
    mouse, we will make this visible on the appropriate geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to hook up mouse event handlers on each of the path elements that
    represent countries. On the `mouseover` event, we make the `stroke-opacity` opaque,
    and set it back to transparent when the mouse exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more small change that we will want to make whenever the zoom
    level changes. As the zoom level goes up, the country borders get disproportionately
    thick. To prevent this, we can add the following statement to the end of the `moveAndZoom`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is stating that the border of a country should always stay at what is visually
    `2px` thick, no matter what the zoom level.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating a globe using the mouse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interactivity can also be applied to other projections. We will examine rotating
    an orthographic globe using the mouse. The example is available at the following
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.16): [http://goo.gl/cpH0LN](http://goo.gl/cpH0LN)'
  prefs: []
  type: TYPE_NORMAL
- en: To save a little space, we won't show an image here, as it looks the same as
    the earlier example in the chapter, except that it rotates following the mouse.
    That, and the rotation effect is lost in a print medium.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the way this works is very simple. The technique involves creating two
    scales, one for longitude and the other for latitude. Longitude is calculated
    as mapping the mouse position from `0` to the width of the graphic to `-180` and
    `180` degrees of longitude. The latitude is a mapping of the vertical mouse position
    to `90` and `-90` degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When the mouse is moved over the SVG element, we capture it and scale the mouse
    position into a corresponding latitude and longitude; we then set the rotation
    of the projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It's a pretty cool little trick of mathematics and scales that allows us to
    be able to see every position on the entire globe.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final examples of working with maps will demonstrate making annotations
    to a map. The first two will demonstrate placing labels and markers on a map,
    and the third will demonstrate the use of gradient colors to color regions all
    the way down to a state level.
  prefs: []
  type: TYPE_NORMAL
- en: All of these techniques would normally involve some fairly complex math if we
    had to do it on our own, but thankfully, D3.js again comes to help us solve this
    with just a few statements.
  prefs: []
  type: TYPE_NORMAL
- en: Labelling states using centroids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The maps of the United States we''ve created up to this point feel a little
    lacking in content, as they have not had the names of the states placed over their
    geometries. It would be very helpful to many reading a map to have the names visible.
    The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.17): [http://goo.gl/3vChcR](http://goo.gl/3vChcR)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Labelling states using centroids](img/B04230_12_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is actually fairly easy to implement, with only the addition of one statement
    to our United States Mercator projection example. The following code is placed
    immediately after the `.selectAll()` statement that creates the boundaries for
    all the states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This statement creates a text element for each geometric feature in the data
    file, and sets the text to be the value of the `name` property of the geometry
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The position of the text uses a function of the path that calculates the **centroid**
    of the geometry. The centroid is the mathematical center of the geometry, and
    can be calculated using the `.centroid()` function of a path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most states, especially rectangular ones, this works well. For others with
    irregular shapes, take Michigan for example, the placement is perhaps not optimal
    for aesthetics. There are various ways to fix this, but those are beyond the scope
    of this book (a hint: it involves adding additional data to represent location
    offsets for each geometry).'
  prefs: []
  type: TYPE_NORMAL
- en: Placing symbols at specific geographic locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last example with maps that we will look at will be to place SVG elements
    on the map at specific coordinates. Specifically, we will place circles at the
    position of the 50 most populous cities, and size the circle relative to the population.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data we will use is in `us-cities.csv`, which is available at [https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-cities.csv](https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us-cities.csv).
    The data is straightforward; the following are the first few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.18): [http://goo.gl/Y9MN5q](http://goo.gl/Y9MN5q)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting visualization is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Placing symbols at specific geographic locations](img/B04230_12_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding example leverages the United States Mercator examples code. This
    example does, however, need to load two data files. To facilitate this, we will
    use a library called **queue** created by Mike Bostock to load these files asyncronously,
    and when both are complete, execute the `ready()` function. You can get this library
    and documentation at [https://github.com/mbostock/queue](https://github.com/mbostock/queue):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The map is then rendered as in the earlier examples. Then we need to place
    the circles. To do this, we will need to convert the latitude and longitude values
    to *X* and *Y* pixel locations. We can do this in D3.js using the projection object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For each circle that is created, this code calls the projection function passing
    it the latitude and longitude for each city. The return value is the `x` and `y`
    location of the pixel representing that location. So we just set the center of
    the circle to this result, and assign the circle a radius that is a scale value
    of the population.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a choropleth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last map example is for creating a **choropleth**. A choropleth is a map
    with areas filled in with different colors to reflect the underlying data values—not
    just differing colors to represent different geographic boundaries. These are
    quite common types of visuals, and they commonly show a difference in opinion
    amongst the populations in adjacent regions, or how economic factors differ along
    neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (12.19): [http://goo.gl/ZeTh4o](http://goo.gl/ZeTh4o)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting visualization is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a choropleth](img/B04230_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This choropleth represents the unemployment rate in the US counties for the
    year 2008\. The shade of blue varies from darker, representing lower unemployment,
    to lighter and higher unemployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data for unemployment is available at [https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/unemployment.tsv](https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/unemployment.tsv).
    The first few lines are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The data consists of a pair of a county identifier and the respective unemployment
    rate. The county ID will be matched to county IDs in the `us.json` file available
    at [https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us.json](https://gist.githubusercontent.com/d3byex/65a128a9a499f7f0b37d/raw/176771c2f08dbd3431009ae27bef9b2f2fb56e36/us.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'This file consists of TopoJSON describing the shape of all of the counties
    in the US, each with the same county ID in the unemployment file. A snippet of
    this file is the following, which shows for country `1001` the arcs that should
    be used to render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to quantize the unemployment rates, and then fill each geometry
    with a color mapped to that quantile. It's actually easier to do than it may seem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will map our unemployment rates into ten quantiles. The
    color used for each will be specified using a style with a specific name. These
    are declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is loaded using the `queue()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code uses an alternate form of `.defer()` for the unemployment data, which
    calls a function for each data item that is loaded (another cool thing about queue).
    This builds a `d3.map()` object (like a dictionary object) that maps the county
    ID to its unemployment rate, and we use this map later during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The county data is rendered first. To do this, we need to create a quantile
    scale which maps the domain from `0` to `0.15`. This will be used to map the unemployment
    levels to one of the styles. The range is then configured to generate the names
    of the nine styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the code creates the `albersUsa` projection and an associated path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a group to hold the shaded counties. Then, to this
    group, we will add a path for each county by binding it to the `counties` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we overlay the outlines of the states using a `white` stroke for the
    borders to help us differentiate the state borders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This particular piece of code also uses the `topojson.mesh` function to extract
    the **MultiPolygon** (GeoJSON) data for all of the states from the TopoJSON object.
  prefs: []
  type: TYPE_NORMAL
- en: And that's all! We've created a choropleth, and used a coding pattern that can
    be reused easily with other types of data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by looking briefly at GeoJSON and TopoJSON. If you do
    anything with maps in D3.js, you will be using one or both of these. We covered
    it just enough to give an understanding of its structure, and how it is used to
    define data that can be rendered as a map.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we dove into creating several maps and covered many of the concepts
    that you will use in their creation. These included loading the data, creating
    projections, and rendering the geometries within the data.
  prefs: []
  type: TYPE_NORMAL
- en: We examined two projections, Mercator and orthographic, to give an idea of how
    these present data. Along the way, we also looked at how to style elements on
    the map, filling geometries with color, and highlighting geometries on `mouseover`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we examined how to annotate our maps with labels as well as color elements
    based upon data (choropleths), and to place symbols on the map at specific geographic
    positions, with a size that is based upon the data.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, we have been pretty thorough in covering much of
    the core of D3.js, at least enough to make you very dangerous with it. But we
    have also only ever created stand-alone visualizations, ones that do not interact
    with other visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the final one of this book, we will look at combining multiple
    D3.js visualizations using AngularJS, and where those visuals also react to the
    user manipulating other content on their page.
  prefs: []
  type: TYPE_NORMAL
