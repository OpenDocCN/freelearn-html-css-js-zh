<html><head></head><body>
<div><h1 class="chapternumber">21</h1>
<h1 class="chaptertitle" id="_idParaDest-359">SportsStore: Deployment</h1>
<p class="normal1">In this chapter, I complete the SportsStore application and prepare it for deployment to a container platform. As part of the preparations, I move from the file-based SQLite database to a conventional database server and introduce an HTTPS proxy, which will allow multiple instances of the SportsStore application to receive requests and share load.</p>
<h1 class="heading" id="_idParaDest-360">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">sportsstore</code> project from <em class="italic">Chapter 20</em>. Open a new command prompt, navigate to the <code class="inlinecode">sportsstore</code> folder, and run the command shown in <em class="italic">Listing 21.1</em> to start the development tools.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 21.1: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a new browser window, navigate to <code class="inlinecode">http://localhost:5000</code>, and you will see the product catalog, as shown in <em class="italic">Figure 21.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.1: Running the application</p>
<h1 class="heading" id="_idParaDest-361">Installing Docker Desktop</h1>
<p class="normal1">There are many ways to deploy<a id="_idIndexMarker1142" class="calibre3"/> an application, and there is no way that I can describe them all. Instead, I have chosen the approach that offers the most flexibility, which is to use <em class="italic">containers</em>. Containers are lightweight virtual machines that run self-contained <em class="italic">images</em> and are built and deployed using standard tools. Containers are portable and can be deployed to private and cloud infrastructures, which makes them a good choice for most applications.</p>
<p class="normal">The most popular tool for creating and managing containers is Docker. Go to <code class="inlinecode">docker.com</code> and download and install the Docker Desktop package. Follow the installation process, reboot your machine, and run the command shown in <em class="italic">Listing 21.2</em> to check that Docker has been installed and is in your path. (The Docker installation process seems to change often, which is why I have not been more specific about the process.)</p>
<p class="normal">You will have to create an account on <code class="inlinecode">docker.com</code>; the free version of Docker contains all of the features needed for this chapter and the paid-for services are not required. </p>
<p class="packt_figref">Listing 21.2: Checking the Docker Desktop installation</p>
<pre class="programlisting1"><code class="hljs-con">docker --version
</code></pre>
<p class="normal">If Docker is installed and running, you will see a response similar to this one:</p>
<pre class="programlisting1"><code class="hljs-con">Docker version 25.0.3, build 4debf41
</code></pre>
<p class="normal">You may see a different version<a id="_idIndexMarker1143" class="calibre3"/> number, but that’s OK because the point is to make sure that Docker Desktop is up and running.</p>
<h1 class="heading" id="_idParaDest-362">Managing the database</h1>
<p class="normal1">Throughout this part of the book, the SportsStore application<a id="_idIndexMarker1144" class="calibre3"/> has been configured to automatically recreate and seed the database each time the server is started. I generally like this approach for my own projects, but it is especially useful for book examples because it ensures that the reader is always working with clean data and removes one potential cause of problems, where the code changes and becomes out of sync with the database schema.</p>
<p class="normal">In production, the database should not be reset every time the server starts, but it is still important to ensure that the database is created and seeded during the initial deployment. To extend the administration tool so that the database can be reset and reseeded, add a file named <code class="inlinecode">database_routes.ts</code> to the <code class="inlinecode">src/routes/admin</code> folder, with the content shown in <em class="italic">Listing 21.3</em>. </p>
<p class="packt_figref">Listing 21.3: The contents of the database_routes.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Router } from "express";
import { CategoryModel, ProductModel, SupplierModel }
    from "../../data/orm/models";
import { readFileSync } from "fs";
import { getConfig } from "../../config";
export const createDbManagementRoutes = (router: Router) =&gt; {
    router.get("", (req, resp) =&gt; {
        resp.render("admin/db_mgt");
    });
    router.post("/reset", async (req, resp) =&gt; {
        await ProductModel.sequelize?.drop();
        await ProductModel.sequelize?.sync();
        const data = JSON.parse(readFileSync(getConfig("catalog:orm_repo")
            .seed_file).toString());
        await ProductModel.sequelize?.transaction(async (transaction) =&gt; {
            await SupplierModel.bulkCreate(data.suppliers, { transaction });
            await CategoryModel.bulkCreate(data.categories, { transaction });
            await ProductModel.bulkCreate(data.products, { transaction });
        });
        resp.render("admin/db_mgt", {
            admin_msg: "Products database reset and seeded"
        });
    });
}
</code></pre>
<p class="normal">The handler for <code class="inlinecode">GET</code> requests<a id="_idIndexMarker1145" class="calibre3"/> renders a template named <code class="inlinecode">admin/db_mgt</code>, which will present the user with the ability to reset the database. The handler for <code class="inlinecode">POST</code> requests accesses the <code class="inlinecode">Sequelize</code> object created by the repository through the <code class="inlinecode">sequelize</code> property added to model classes, calls the <code class="inlinecode">drop</code> and <code class="inlinecode">sync</code> methods to reset the database, and then populates the database with the seed data. <em class="italic">Listing 21.4</em> enables the new routes and defines a direct navigation URL.</p>
<p class="packt_figref">Listing 21.4: Enabling routes in the index.ts file in the src/routes/admin folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, NextFunction, Request, Response, Router } from "express";
import { createAdminCatalogRoutes } from "./admin_catalog_routes";
import { createAdminOrderRoutes } from "./admin_order_routes";
import passport from "passport";
import { getConfig} from "../../config";
<strong class="screentext">import</strong><strong class="screentext"> { createDbManagementRoutes } from "./database_routes";</strong>
const users: string[] = getConfig("admin:users", []);
export const createAdminRoutes = (app: Express) =&gt; {
    // ... routes omitted for brevity...
    const authCheck = (r: Request) =&gt; users.find(u =&gt; r.user?.email === u);
    const apiAuth = (req: Request, resp: Response, next: NextFunction) =&gt; {
        if (!authCheck(req)) {
            return resp.sendStatus(401)
        }
        next();
    };
    const cat_router = Router();
    createAdminCatalogRoutes(cat_router);
    app.use("/api/products", apiAuth, cat_router);
    const order_router = Router();
    createAdminOrderRoutes(order_router);
    app.use("/api/orders", apiAuth, order_router);
    <strong class="screentext">const db_router = </strong><strong class="screentext">Router();</strong>
<strong class="screentext">    createDbManagementRoutes(db_router);</strong>
<strong class="screentext">    app.use("/api/database", apiAuth, db_router);</strong>
    const userAuth = (req: Request, resp: Response, next: NextFunction) =&gt; {
        if (!authCheck(req)) {
            return resp.redirect("/admin/signin");
        }
        next();
    };
    // ...other routes omitted for brevity...
    app.get("/admin/orders", userAuth, (req, resp) =&gt; {
        resp.locals.content = "/api/orders/table";
        resp.render("admin/admin_layout");
    })
   <strong class="screentext"> app.get("/admin/database", userAuth, (req, resp) =&gt; {</strong>
<strong class="screentext">        resp.locals.content = "</strong><strong class="screentext">/api/database";</strong>
<strong class="screentext">        resp.render("admin/admin_layout");</strong>
<strong class="screentext">    })   </strong>
}
</code></pre>
<p class="normal">Add a file named <code class="inlinecode">db_mgt.handlebars</code> to the <code class="inlinecode">templates/admin</code> folder, with the content<a id="_idIndexMarker1146" class="calibre3"/> shown in <em class="italic">Listing 21.5</em>.</p>
<p class="packt_figref">Listing 21.5: The contents of the db_mgt.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">{{&gt; admin/area_buttons mode="database"}}
&lt;div class="m-2"&gt;
    &lt;h5 class="text-danger text-center"&gt;{{admin_msg}}&lt;/h5&gt;
&lt;/div&gt;
&lt;div class="m-2 text-center"&gt;
    &lt;button class="btn btn-danger m-2"
        hx-post="/api/database/reset"
        hx-target="#content"&gt;Reset &amp; Seed Database&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p class="normal">The template contains a <code class="inlinecode">button</code> element that sends a <code class="inlinecode">POST</code> request to the handler defined in <em class="italic">Listing 21.4</em>, with an <code class="inlinecode">h5</code> element that displays a message provided by the handler. <em class="italic">Listing 21.6</em> adds a button in the <code class="inlinecode">area_buttons</code> template to include the database features in the content presented to the user.</p>
<p class="packt_figref">Listing 21.6: Adding a button in the area_buttons.handlebars file in the templates/admin folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;swap_wrapper hx-swap-oob="innerHTML:#area_buttons"&gt;
    &lt;div class="d-grid gap-2" &gt;
        &lt;button id="products_btn" class="btn {{ buttonClass "products" mode }}"
            hx-get="/api/products/table" hx-target="#content"
            hx-push-url="/admin/products"&gt;
            Products
        &lt;/button&gt;
        &lt;button id="orders_btn" class="btn {{ buttonClass "orders" mode }}"
            hx-get="/api/orders/table" hx-target="#content"
            hx-push-url="/admin/orders"&gt;
            Orders
        &lt;/button&gt;
      <strong class="screentext">  &lt;button id</strong><strong class="screentext">="db_btn" class="btn {{ buttonClass "database" mode }}"</strong>
<strong class="screentext">            hx-get="/api/database" hx-target="#content"</strong>
<strong class="screentext">            hx-push-url="</strong><strong class="screentext">/admin/database"&gt;</strong>
<strong class="screentext">            Database</strong>
<strong class="screentext">        &lt;/button&gt;</strong>
    &lt;/div&gt;
&lt;/swap_wrapper&gt;
</code></pre>
<p class="normal">Use a browser to request <code class="inlinecode">http://localhost:5000/admin</code>, authenticate using OAuth, and click the <strong class="screentext">Delete</strong> button for a few of the products. It doesn’t matter how many or which ones you remove, since the purpose is to ensure that the database is reset and reseeded. Click the <strong class="screentext">Database</strong> button, and then click <strong class="screentext">Reset &amp; Seed Database</strong>. Once the database<a id="_idIndexMarker1147" class="calibre3"/> has been reset, click the <strong class="screentext">Products</strong> button and you will see the original data, as shown in <em class="italic">Figure 21.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.2: Resetting the database</p>
<h1 class="heading" id="_idParaDest-363">Toggling the application environment</h1>
<p class="normal1">The SportsStore application will be deployed<a id="_idIndexMarker1148" class="calibre3"/> in a Docker container, which will be configured to set the application environment to <code class="inlinecode">production</code>. It is helpful to be able to switch to the production environment outside of the container in order to prepare the application for deployment. One way to do this is to set an environment variable named <code class="inlinecode">NODE_ENV</code> using the command prompt used to start Node.js, but that can be difficult to do consistently when there are multiple developers, each with their own command prompt or shell preferences, each of which deals with environment variables in its own way. A more reliable way is to rely on the <code class="inlinecode">dotenv</code> package, which reads environment variables from files.</p>
<p class="normal">Add a file named <code class="inlinecode">overrides.env</code> to the <code class="inlinecode">sportsstore</code> folder, with the content shown in <em class="italic">Listing 21.7</em>. This is a temporary file, just to confirm that the application behaves as it should before it is prepared for deployment. </p>
<p class="packt_figref">Listing 21.7: The contents of the overrides.env file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">NODE_ENV=production
</code></pre>
<p class="normal"><em class="italic">Listing 21.8</em> uses the <code class="inlinecode">dotenv</code> package to read the <code class="inlinecode">.env</code> file, which is done as soon as the application starts.</p>
<p class="packt_figref">Listing 21.8: Reading the .env file in the index.ts file in the src/config folder</p>
<pre class="programlisting"><code class="hljs-code">import { readFileSync } from "fs";
import { getEnvironment, Env } from "./environment";
import { merge } from "./merge";
import { config as dotenvconfig } from "dotenv";
<strong class="screentext">dotenvconfig({ path: "overrides.env", override: false});</strong>
const file = process.env.SERVER_CONFIG ?? "server.config.json"
const data = JSON.parse(readFileSync(file).toString());
dotenvconfig({
    path: getEnvironment().toString() + ".env"
})
try {
    const envFile = getEnvironment().toString() + "." + file;
    const envData = JSON.parse(readFileSync(envFile).toString());
    merge(data, envData);
} catch {
    // do nothing - file doesn't exist or isn't readable
}
export const getConfig = (path: string, defaultVal: any = undefined) =&gt; {
    const paths = path.split(":");
    let val = data;
    paths.forEach(p =&gt; val = val[p]);
    return val ?? defaultVal;
}
export const getSecret = (name: string) =&gt; {
    const secret = process.env[name];
    if (secret === undefined) {
        throw new Error(`Undefined secret: ${name}`);
    }
    return secret;
}
export { getEnvironment, Env };
</code></pre>
<p class="normal">You may be tempted to override the value returned by <code class="inlinecode">getEnvironment</code> in the <code class="inlinecode">config</code> module, which was created in <em class="italic">Chapter 16</em>. This will affect all of the custom <em class="italic">SportsStore</em> code, which has been written to use the <code class="inlinecode">config</code> module, but it won’t change the behavior of the third-party packages on which <em class="italic">SportsStore</em> relies. The <code class="inlinecode">NODE_ENV</code> environment variable is a widely used convention, and many packages alter their behavior based on its value. The <code class="inlinecode">express-handlebars</code> package, which integrates Handlebars templates into the Express framework, automatically compiles and caches template files when <code class="inlinecode">NODE_ENV</code> is set to production, for example.</p>
<p class="normal">The application won’t run in production<a id="_idIndexMarker1149" class="calibre3"/> mode because there are no settings for the secrets used to sign session cookies or perform OAuth requests. <em class="italic">Listing 21.9</em> adds settings to the <code class="inlinecode">overrides</code> file so that the application can be prepared for deployment.</p>
<p class="packt_figref">Listing 21.9: Adding settings in the overrides.env file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">NODE_ENV=production
<strong class="screentext">COOKIE_SECRET="sportsstoresecret"</strong>
<strong class="screentext">GOOGLE_CLIENT_ID=&lt;enter your client ID&gt;</strong>
<strong class="screentext">GOOGLE_CLIENT_SECRET=&lt;enter your secret&gt;</strong>
</code></pre>
<p class="normal">You must replace the placeholder text in <em class="italic">Listing 21.9</em> with the client ID and secret provided by Google when you configured OAuth in <em class="italic">Chapter 19</em>. The application will start without these settings, but you won’t be able to authenticate with the administration tools and populate the database.</p>
<p class="normal">Stop the application and run the command<a id="_idIndexMarker1150" class="calibre3"/> shown in <em class="italic">Listing 21.10</em> in the <code class="inlinecode">sportsstore</code> folder to start just the Node.js server. The <strong class="screentext">webpack</strong> bundler, which was useful in ensuring that the client was updated during development, is no longer required.</p>
<p class="packt_figref">Listing 21.10: Starting the Node.js server</p>
<pre class="programlisting1"><code class="hljs-con">npm run server
</code></pre>
<p class="normal">The server will still be built and restarted when there is a change, but the webpack development server isn’t started, and the <code class="inlinecode">production</code> environment configured in the <code class="inlinecode">overrides.env</code> file means that the Node.js server will handle all HTTP requests without attempting to forward them. Before moving on, check that the application is running correctly by using the browser to request <code class="inlinecode">http://localhost:5000</code>, which should produce the catalog display shown in <em class="italic">Figure 21.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.3: Running the application in production mode</p>
<h1 class="heading" id="_idParaDest-364">Using a database server</h1>
<p class="normal1">It should be clear by now<a id="_idIndexMarker1151" class="calibre3"/> that I am a huge fan of the SQLite database, which is packaged with features and is supported by every major package and framework. The main limitation of SQLite is that it can’t be readily shared between multiple Node.js servers, so it is time to move to a conventional database server that can be queried over a network. The database I am going to use in this chapter is PostgreSQL, usually referred to just as Postgres. As I noted in <em class="italic">Part 2</em>, all of the mainstream databases are good, but I picked Postgres because it is the most popular open-source database and because it is well supported by the <code class="inlinecode">Sequelize</code> ORM package. </p>
<p class="normal">The simplest way to use Postgres is by running the database server in a container.</p>
<p class="normal">Open a new command prompt and run the command shown in <em class="italic">Listing 21.11</em> to download an image for Postgres and use it to create a new container. The command may take a few moments to complete because the image has to be downloaded the first time it is used, but it will be cached for subsequent operations.</p>
<p class="packt_figref">Listing 21.11: Creating a container</p>
<pre class="programlisting"><code class="hljs-code">docker run -e POSTGRES_PASSWORD=MySecret$ -p 5432:5432 postgres:16.2
</code></pre>
<p class="normal">The <code class="inlinecode">docker run</code> command<a id="_idIndexMarker1152" class="calibre3"/> creates a new container. The <code class="inlinecode">-e</code> argument sets environment variables for the container and, in this case, is used to set the password that is used to access the database server. The <code class="inlinecode">-p</code> argument configures the network ports and is used to expose port <code class="inlinecode">5432</code> so that it can be accessed from the host operating system, allowing the database server to be used from outside of its container. Leave the command prompt open. The container will run until the <code class="inlinecode">docker run</code> command is terminated with <em class="italic">Ctrl + C</em>.</p>
<p class="normal">Run the commands shown in <em class="italic">Listing 21.12</em> in the <code class="inlinecode">sportsstore</code> folder to install the packages that will allow Sequelize to work with Postgres.</p>
<p class="packt_figref">Listing 21.12: Adding database packages</p>
<pre class="programlisting"><code class="hljs-code">npm install pg@8.11.3
npm install pg-hstore@2.3.4
</code></pre>
<p class="normal"><em class="italic">Table 21.1</em> describes these packages for quick reference.</p>
<p class="packt_figref">Table 21.1: The CookieOptions packges </p>
<table class="table-container" id="table001-18">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Name</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pg</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains support for communicating with Postgres servers.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">pg-hstore</code></p>
</td>
<td class="table-cell">
<p class="normal">This package contains support for storing JSON data in a Postgres database.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">Add a file named <code class="inlinecode">production.server.config.json</code> in the <code class="inlinecode">sportsstore</code> folder, with the content shown in <em class="italic">Listing 21.13</em>.</p>
<p class="packt_figref">Listing 21.13: The contents of the production.server.config.json in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "catalog": {
        "orm_repo": {
            "reset_db": false,
            "settings": {
                "dialect": "postgres",
                "host": "localhost",
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }
    },
    "sessions": {
        "reset_db": false,
        "orm": {
            "settings": {
                "dialect": "postgres",
                "host": "localhost",
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }       
    }
}
</code></pre>
<p class="normal">The settings in <em class="italic">Listing 21.13</em> override those defined<a id="_idIndexMarker1153" class="calibre3"/> in the <code class="inlinecode">server.config.json</code> file and are only applied when the application is in the <code class="inlinecode">production</code> environment. Both configuration sections disable resetting the database every time and provide the configuration settings to connect to the database in the container.</p>
<p class="normal">Stop the Node.js application and run the command shown in <em class="italic">Listing 21.14</em> in the <code class="inlinecode">sportstore</code> folder to start it again using the new configuration file.</p>
<p class="packt_figref">Listing 21.14: Starting the application</p>
<pre class="programlisting1"><code class="hljs-con">npm run server
</code></pre>
<p class="normal">The application should connect to the Postgres database server. Use a browser to request <code class="inlinecode">http://localhost:5000/admin</code>, authenticate using a Google account, and populate the database by clicking the <strong class="screentext">Reset &amp; Seed</strong> <strong class="screentext">Database</strong> button in the <strong class="screentext">Database</strong> section. Click the <strong class="screentext">Products</strong> selection to confirm the database has been populated, as shown in <em class="italic">Figure 21.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.4: Populating the database</p>
<p class="normal">Use <em class="italic">Ctrl + C</em> to stop both the application<a id="_idIndexMarker1154" class="calibre3"/> and the database once you have confirmed that <em class="italic">SportsStore</em> is working with Postgres.</p>
<h1 class="heading" id="_idParaDest-365">Creating the SportsStore Docker image</h1>
<p class="normal1">The next step is to prepare<a id="_idIndexMarker1155" class="calibre3"/> an image that contains Node.js, the <em class="italic">SportsStore</em> application, all of the packages that it relies on, the templates, and the configuration files. The first step is to create a file that tells Docker to ignore the <code class="inlinecode">node_modules</code> folder, which causes a slowdown in the creation of an image because all of the folders are scanned. Create a file named <code class="inlinecode">.dockerignore</code> in the <code class="inlinecode">sportsstore</code> folder, with the contents shown in <em class="italic">Listing 21.15</em>. </p>
<p class="packt_figref">Listing 21.15: The contents of the .dockerignore file in the sportsstore folder</p>
<pre class="programlisting1"><code class="hljs-con">node_modules
</code></pre>
<p class="normal">The next step is to create the file that tells Docker how to create the image. Add a file named <code class="inlinecode">Dockerfile</code> (with no file extension) to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 21.16</em>.</p>
<p class="packt_figref">Listing 21.16: The contents of the Dockerfile file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">FROM node:20.10.0
RUN mkdir -p /usr/src/sportsstore
COPY dist /usr/src/sportsstore/dist
COPY templates /usr/src/sportsstore/templates
COPY products.json /usr/src/sportsstore/
COPY server.config.json /usr/src/sportsstore/
COPY production.server.config.json /usr/src/sportsstore/
COPY package.json /usr/src/sportsstore/
WORKDIR /usr/src/sportsstore
RUN npm install --omit=dev
RUN npm install wait-for-it.sh@1.0.0
ENV NODE_ENV=production
ENV COOKIE_SECRET="sportsstoresecret"
ENV GOOGLE_CLIENT_ID=&lt;enter your ID&gt;
ENV GOOGLE_CLIENT_SECRET=&lt;enter your secret&gt;
EXPOSE 5000
ENTRYPOINT npx wait-for-it postgres:5432 &amp;&amp; node dist/server.js
</code></pre>
<p class="normal"><code class="inlinecode">Dockerfile</code> contains<a id="_idIndexMarker1156" class="calibre3"/> a series of instructions that will be used to build the image. The <code class="inlinecode">FROM</code> command tells Docker to use the image for the version of Node.js used throughout this book as the foundation for the image, which simplifies the setup process.</p>
<p class="normal">The <code class="inlinecode">COPY</code> commands tell Docker to copy files from the project into the container. The <code class="inlinecode">WORKDIR</code> command changes the working directory for subsequent commands. This command installs the packages required to run the application:</p>
<pre class="programlisting"><code class="hljs-code">...
RUN npm install --omit=dev
...
</code></pre>
<p class="normal">The <code class="inlinecode">--omit</code> argument is used to exclude the packages that were added with the <code class="inlinecode">npm install --save-dev</code> command, which means that packages such as the TypeScript compiler won’t be included in the image.</p>
<p class="normal">The command that follows installs a package that is only required when the application is deployed:</p>
<pre class="programlisting"><code class="hljs-code">...
RUN npm install wait-for-it.sh@1.0.0
...
</code></pre>
<p class="normal">Coordinating between containers can be difficult and it is important to ensure that the SportsStore application isn’t started until the database server is ready to receive requests. The <code class="inlinecode">wait-for-it </code>package waits until a TCP port has been opened and is a simple and reliable way to ensure that the application in one container is ready before another container is started.</p>
<p class="normal">The <code class="inlinecode">ENV</code> commands set the environment variables and are used to set <code class="inlinecode">production</code> mode and define the secrets used to sign cookies and perform Google OAuth requests.</p>
<p class="normal">The <code class="inlinecode">EXPOSE</code> command<a id="_idIndexMarker1157" class="calibre3"/> tells Docker to expose port <code class="inlinecode">5000</code>, which will allow the SportsStore application to receive HTTP requests. The <code class="inlinecode">ENTRYPOINT</code> command is executed when the container is started and comes in two parts. The first part uses the <code class="inlinecode">wait-for-it</code> package to block until port <code class="inlinecode">5432</code> on a server named <code class="inlinecode">postgres</code> is open. This is the name that will be given to the database when the containers are connected in the <em class="italic">Composing the application and database servers</em> section. The second part runs the <code class="inlinecode">server.js</code> file in the <code class="inlinecode">dist</code> folder, which will start the <em class="italic">SportsStore</em> application.</p>
<h2 class="heading1" id="_idParaDest-366">Preparing the application</h2>
<p class="normal1">Images are a snapshot of an application<a id="_idIndexMarker1158" class="calibre3"/> and its associated files. Before creating the image, it is important to make any final configuration changes and build the code to make sure that the JavaScript included in the image reflects the final TypeScript code.</p>
<p class="normal"><em class="italic">Listing 21.17</em> alters the name used for the Postgres server from <code class="inlinecode">localhost</code> to <code class="inlinecode">postgres</code>, which is the name that will be given to the database server when it is deployed. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">In a real project, you would also change the OAuth redirection URLs so that they contain the public domain name by which your users connect to the service. The <em class="italic">SportsStore</em> application will only be used on the development machine, and so the redirection URLs containing <code class="inlinecode">localhost</code> will continue to work, but this will not be the case for real projects.</p>
</div>
<p class="packt_figref">Listing 21.17: Changing the server name in the production.server.config.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "catalog": {
        "orm_repo": {
            "reset_db": false,
            "settings": {
                "dialect": "postgres",
               <strong class="screentext"> "host": "postgres",</strong>
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }
    },
    "sessions": {
        "reset_db": false,
        "orm": {
            "settings": {
                "dialect": "postgres",
<strong class="screentext">                "host": "postgres",</strong>
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }       
    }
}
</code></pre>
<p class="normal">Run the command<a id="_idIndexMarker1159" class="calibre3"/> shown in <em class="italic">Listing 21.18</em> in the <code class="inlinecode">sportsstore</code> folder to run the TypeScript compiler to create the final build of the code.</p>
<p class="packt_figref">Listing 21.18: Compiling the TypeScript code</p>
<pre class="programlisting1"><code class="hljs-con">npx tsc
</code></pre>
<h2 class="heading1" id="_idParaDest-367">Creating the SportsStore image</h2>
<p class="normal1">Run the command shown in <em class="italic">Listing 21.19</em> in the <code class="inlinecode">sportsstore</code> folder<a id="_idIndexMarker1160" class="calibre3"/> to create the image that contains the SportsStore application. </p>
<p class="packt_figref">Listing 21.19: Creating the sportsstore image</p>
<pre class="programlisting1"><code class="hljs-con">docker build . -t sportsstore -f Dockerfile
</code></pre>
<p class="normal">As the image is created, you will see output similar to the following:</p>
<pre class="programlisting1"><code class="hljs-con">[+] Building 25.6s (17/17) FINISHED    docker:default
 =&gt; [internal] load build definition from Dockerfile
=&gt; =&gt; transferring dockerfile: 785B
=&gt; [internal] load metadata for docker.io/library/node:20.10.0
=&gt; [auth] library/node:pull token for registry-1.docker.io
=&gt; [internal] load .dockerignore
=&gt; =&gt; transferring context: 52B
=&gt; [internal] load build context 
=&gt; =&gt; transferring context: 60.69kB
=&gt; [ 1/11] FROM docker.io/library/node:20.10.0@sha256:8d0f16fe841577f9317ab49011c6d819e1fa81f8d
=&gt; CACHED [ 2/11] RUN mkdir -p /usr/src/sportsstore
=&gt; CACHED [ 3/11] COPY dist /usr/src/sportsstore/dist
=&gt; CACHED [ 4/11] COPY templates /usr/src/sportsstore/templates
=&gt; CACHED [ 5/11] COPY products.json /usr/src/sportsstore/
=&gt; CACHED [ 6/11] COPY server.config.json /usr/src/sportsstore/
=&gt; CACHED [ 7/11] COPY production.server.config.json /usr/src/sportsstore/
=&gt; CACHED [ 8/11] COPY package.json /usr/src/sportsstore/
=&gt; CACHED [ 9/11] WORKDIR /usr/src/sportsstore
=&gt; [10/11] RUN npm install --omit=dev
=&gt; [11/11] RUN npm install wait-for-it.sh@1.0.0  
=&gt; exporting to image
=&gt; =&gt; exporting layers
=&gt; =&gt; writing image sha256:4b2f72d561dfbe21695573d7f448bc6ada3a9c4802bc5a70b8af1676e82c1fcd 
=&gt; =&gt; naming to docker.io/library/sportsstore
</code></pre>
<p class="normal">This command can take a while to run because the Node.js image must be downloaded, and the packages required by the SportsStore application have to be installed.</p>
<h1 class="heading" id="_idParaDest-368">Composing the application and database servers</h1>
<p class="normal1">The next step is to create<a id="_idIndexMarker1161" class="calibre3"/> the configuration file that specifies<a id="_idIndexMarker1162" class="calibre3"/> how the SportsStore and Postgres images will be used to create containers. This step is dependent on how the containers are going to be deployed, for which there are many options. All of the major cloud platforms provide support for using containers, and the configuration will have to be adapted to the needs and features of the target platform.</p>
<p class="normal">For this chapter, I am going to use Docker Compose, which is the built-in tool provided with Docker Desktop. You may not use Docker Compose for your projects, but it has the same core features that you will encounter regardless of how you deploy, and it makes it easy to combine and test containers to create a complete application. Add a file named <code class="inlinecode">docker-compose.yml</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 21.20</em>. </p>
<p class="packt_figref">Listing 21.20: The contents of the docker-compose.yml file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">version: "3"
volumes:
  databases:
services:
  postgres:
    image: "postgres:16.2"
    volumes:
      - databases:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=MySecret$
   
  sportsstore:
    image: "sportsstore"
    depends_on:
      - postgres
    ports:
      - 5000:5000
</code></pre>
<p class="normal">The format of the file is YAML, which is sensitive to indentation and the contents must be entered exactly as shown. Most code editors, including Visual Studio Code, include YAML syntax highlighting, which helps identify content or formatting errors.</p>
<p class="normal">The configuration in <em class="italic">Listing 21.20</em> tells Docker Compose to create two containers. The first, which will be given the name <code class="inlinecode">postgres</code>, contains the database server. This service is configured with a volume, which is the Docker feature for persisting data and, without which, the contents of the database would be lost.</p>
<p class="normal">The second, named <code class="inlinecode">sportsstore</code>, contains<a id="_idIndexMarker1163" class="calibre3"/> the application. The <code class="inlinecode">sportsstore</code> container<a id="_idIndexMarker1164" class="calibre3"/> is configured to export port <code class="inlinecode">5000</code> to the host operating system so that it can receive HTTP requests. Communication between containers uses the service names as hostnames, which is why <em class="italic">Listing 21.17</em> changes the name of the database server to <code class="inlinecode">postgres</code>.</p>
<p class="normal">Run the command shown in <em class="italic">Listing 21.21</em> in the <code class="inlinecode">sportsstore</code> folder to prepare the containers.</p>
<p class="packt_figref">Listing 21.21: Preparing the containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose build
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 21.22</em> in the <code class="inlinecode">sportsstore</code> folder to start the containers.</p>
<p class="packt_figref">Listing 21.22: Starting the containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose up
</code></pre>
<p class="normal">Docker will create and start the containers for the database server and the application and display the console messages they generate. Wait a moment to allow the containers to start up, and then use a browser to request <code class="inlinecode">http://localhost:5000</code>. The database will be empty but can be populated using the administration tools, as shown in <em class="italic">Figure 21.5</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.5: Using Docker Compose</p>
<p class="normal">The application and the database<a id="_idIndexMarker1165" class="calibre3"/> server are each running<a id="_idIndexMarker1166" class="calibre3"/> in a container and can communicate with one another. The network used for communication between containers is created and managed by Docker.</p>
<h1 class="heading" id="_idParaDest-369">Setting up an HTTPS reverse proxy</h1>
<p class="normal1">The next step is to introduce<a id="_idIndexMarker1167" class="calibre3"/> support for HTTPS, which will be handled<a id="_idIndexMarker1168" class="calibre3"/> by a proxy package named <strong class="screentext">HAProxy</strong> (<a href="https://www.haproxy.org" class="calibre3">https://www.haproxy.org</a>). There are many proxies available, but this is one that I have used for many years and have always found reliable.</p>
<p class="normal">To prepare for the proxy, copy your certificate and key files into the <code class="inlinecode">sportsstore</code> folder with the names <code class="inlinecode">cert.pem</code> and <code class="inlinecode">key.pem</code>. <em class="italic">Chapter 5</em> contains instructions for creating a free self-signed certificate, or you can copy the files from the GitHub project for this chapter, which contains a self-signed certificate that I created.</p>
<div><p class="normal">You can use a real certificate, but you must ensure that the domain name associated with the certificate resolves to the machine on which you are running the containers, which can be difficult to arrange.</p>
</div>
<p class="normal">To create the proxy<a id="_idIndexMarker1169" class="calibre3"/> configuration file, add a file named <code class="inlinecode">haproxy.cfg</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 21.23</em>. </p>
<p class="packt_figref">Listing 21.23: The contents of the haproxy.cfg file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">defaults
    mode http
    timeout connect 5000
    timeout client  50000
    timeout server  50000
resolvers dockerdns
    nameserver dns1 127.0.0.11:53
frontend localnodes
    bind *:80
    bind *:443 ssl crt /usr/local/etc/haproxy/cert.pem
    http-request redirect scheme https unless { ssl_fc }
    default_backend app
backend app
    balance roundrobin
    server-template sportsstore- 5 sportsstore:5000 check resolvers dockerdns
</code></pre>
<p class="normal">This configuration sets up the proxy to listen for requests on port <code class="inlinecode">80</code> and port <code class="inlinecode">443</code>. HTTP requests will be redirected to use HTTPS. HTTPS requests will be forwarded to SportsStore, which is located by querying the DNS provided by Docker to containers. The use of DNS allows multiple <code class="inlinecode">sportsstore</code> containers to run and for the proxy to distribute requests between them.</p>
<p class="normal">Add a file named <code class="inlinecode">Dockerfile.proxy</code> to the <code class="inlinecode">sportsstore</code> folder with the content shown in <em class="italic">Listing 21.24</em>.</p>
<p class="packt_figref">Listing 21.24: The contents of the Dockerfile.proxy file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">FROM haproxy:2.9.6
COPY haproxy.cfg /usr/local/etc/haproxy
COPY cert.pem /usr/local/etc/haproxy
COPY key.pem /usr/local/etc/haproxy/cert.pem.key
</code></pre>
<p class="normal">The <code class="inlinecode">FROM</code> command uses the <code class="inlinecode">haproxy</code> image to create the new container, and the <code class="inlinecode">COPY</code> commands include the configuration and certificate files in the image. Run the command<a id="_idIndexMarker1170" class="calibre3"/> shown in <em class="italic">Listing 21.25</em> to create an image for the proxy.</p>
<p class="packt_figref">Listing 21.25: Creating the proxy image</p>
<pre class="programlisting1"><code class="hljs-con">docker build . -t ss-proxy -f Dockerfile.proxy
</code></pre>
<h2 class="heading1" id="_idParaDest-370">Updating the OAuth URLs</h2>
<p class="normal1">The change in ports<a id="_idIndexMarker1171" class="calibre3"/> and forcing the use<a id="_idIndexMarker1172" class="calibre3"/> of HTTPS require a change to the SportsStore configuration for the OAuth redirection URLs, as shown in <em class="italic">Listing 21.26</em>. </p>
<p class="packt_figref">Listing 21.26: Updating URLs in the production.server.config.json file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "catalog": {
        "orm_repo": {
            "reset_db": false,           
            "settings": {
                "dialect": "postgres",
                "host": "postgres",
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }
    },
    "sessions": {
        "reset_db": false,
        "orm": {
            "settings": {
                "dialect": "postgres",
                "host": "postgres",
                "port": "5432",
                "username": "postgres",
                "password": "MySecret$"
            }
        }       
    },
   <strong class="screentext"> "auth": {</strong>
<strong class="screentext">        "openauth": {</strong>
<strong class="screentext">            "redirectionUrl": "https://localhost/signin-google"</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    },</strong>
<strong class="screentext">    "</strong><strong class="screentext">admin": {</strong>
<strong class="screentext">        "openauth": {</strong>
<strong class="screentext">            "redirectionUrl": "https://localhost/auth-signin-google"</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">Without these<a id="_idIndexMarker1173" class="calibre3"/> changes, the OAuth redirections<a id="_idIndexMarker1174" class="calibre3"/> won’t be received by the application. Run the command shown in <em class="italic">Listing 21.27</em> in the <code class="inlinecode">sportsstore</code> folder to update the SportsStore image to reflect the configuration changes.</p>
<p class="packt_figref">Listing 21.27: Updating the SportsStore image</p>
<pre class="programlisting1"><code class="hljs-con">docker build . -t sportsstore -f Dockerfile
</code></pre>
<h2 class="heading1" id="_idParaDest-371">Completing the configuration</h2>
<p class="normal1">The final step is to update<a id="_idIndexMarker1175" class="calibre3"/> the Docker Compose file to add the proxy and create multiple <em class="italic">SportsStore</em> containers, as shown in <em class="italic">Listing 21.28</em>. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">This configuration opens ports that are restricted on some operating systems, which means that superuser or administrator access may be required.</p>
</div>
<p class="packt_figref">Listing 21.28: Completing the configuration in the docker-compose.yml file in the sportsstore folder</p>
<pre class="programlisting"><code class="hljs-code">version: "3"
volumes:
  databases:
services:
  postgres:
    image: "postgres:16.2"
    volumes:
      - databases:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=MySecret$
   
  sportsstore:
    image: "sportsstore"
    depends_on:
      - postgres
 <strong class="screentext">   # ports:</strong>
<strong class="screentext">    #   - 5000:5000</strong>
<strong class="screentext">    deploy:</strong>
<strong class="screentext">      replicas: 5</strong>
<strong class="screentext">  proxy:</strong>
<strong class="screentext">    image: "</strong><strong class="screentext">ss-proxy"</strong>
<strong class="screentext">    ports:</strong>
<strong class="screentext">      - 80:80</strong>
<strong class="screentext">      - 443:443</strong>
</code></pre>
<p class="normal">Stop all of the existing containers by running the command shown in <em class="italic">Listing 21.29</em> in the <code class="inlinecode">sportsstore</code> folder.</p>
<p class="packt_figref">Listing 21.29: Stopping containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose down
</code></pre>
<p class="normal">Wait until the containers<a id="_idIndexMarker1176" class="calibre3"/> have stopped and then run the command shown in <em class="italic">Listing 21.30</em> in the <code class="inlinecode">sportsstore</code> folder to start the database, multiple instances of the <em class="italic">SportsStore</em> application, and the proxy. </p>
<p class="packt_figref">Listing 21.30: Starting the containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose up
</code></pre>
<p class="normal">Docker will start a total of five <em class="italic">SportsStore</em> containers, all of which will share access to the same session and catalog data. Open a browser and request <code class="inlinecode">http://localhost</code> and you will be redirected to use HTTPS instead, as shown in <em class="italic">Figure 21.6</em>. As explained in <em class="italic">Chapter 5</em>, you may have to navigate past security warnings because the certificate used by the proxy is self-signed.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_21_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 21.6: Redirecting insecure connections</p>
<p class="normal">You can populate the database<a id="_idIndexMarker1177" class="calibre3"/> using the administration tools. The proxy is configured to forward requests to each <em class="italic">SportsStore</em> container in turn, and you can see this happening in the console messages, which include the name of the container from which each message originated:</p>
<pre class="programlisting1"><code class="hljs-con">...
<strong class="hljs-slc">sportsstore-1</strong>  | Executing (default): SELECT "sid", "expires", "data", "createdAt", "updatedAt" FROM "Sessions" AS "Session" WHERE "Session"."sid" = 'eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU';
<strong class="screentext">sportsstore-1</strong>  | Executing (default): UPDATE "Sessions" SET "expires"=$1,"updatedAt"=$2 WHERE "sid" = $3; "2024-03-21 23:56:43.319 +00:00", "2024-03-21 21:56:43.319 +00:00", "eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU"
<strong class="screentext">sportsstore-5</strong>  | Executing (default): SELECT "sid", "expires", "data", "createdAt", "updatedAt" FROM "Sessions" AS "Session" WHERE "Session"."sid" = 'eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU';
<strong class="screentext">sportsstore-5</strong>  | Executing (default): UPDATE "Sessions" SET "expires"=$1,"updatedAt"=$2 WHERE "sid" = $3; "2024-03-21 23:56:43.389 +00:00", "2024-03-21 21:56:43.389 +00:00", "eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU"
<strong class="screentext">sportsstore-2</strong>  | Executing (default): SELECT "sid", "expires", "data", "createdAt", "updatedAt" FROM "Sessions" AS "Session" WHERE "Session"."sid" = 'eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU';
<strong class="screentext">sportsstore-2</strong>  | Executing (default): UPDATE "Sessions" SET "expires"=$1,"updatedAt"=$2 WHERE "sid" = $3; "2024-03-21 23:56:43.436 +00:00", "2024-03-21 21:56:43.437 +00:00", "eGtcJR_TJhkO3N0gCzXiqsdJWV4exbmU"
...
</code></pre>
<p class="normal">The configuration of the proxy detects up to five instances of the SportsStore container automatically and stops forwarding requests to containers if they become unavailable. Open a new command prompt and run the command shown in <em class="italic">Listing 21.31</em> in the <code class="inlinecode">sportsstore</code> folder to disable one of the SportsStore containers. </p>
<p class="packt_figref">Listing 21.31: Changing the number of sportsstore containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose scale sportsstore=4
</code></pre>
<p class="normal">The command displays<a id="_idIndexMarker1178" class="calibre3"/> the containers that are running and stops one of them, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
Running 6/6
Container sportsstore-postgres-1     Running
Container sportsstore-sportsstore-4  Running
Container sportsstore-sportsstore-3  Running
Container sportsstore-sportsstore-1  Running
Container sportsstore-sportsstore-2  Running
Container sportsstore-sportsstore-5  Removed
...
</code></pre>
<p class="normal">The proxy detects the change and determines that one of the containers is no longer available, producing a message like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
proxy-1        | [WARNING]  (8) : Server app/sportsstore-3 is going DOWN for maintenance (No IP for server ). 4 active and 0 backup servers left. 0 sessions active, 0 requeued, 0 remaining in queue.
...
</code></pre>
<p class="normal">The names used for the containers don’t always match up with the names used by the Docker DNS service, which is why the container that has been stopped is named <code class="inlinecode">sportsstore-sportsstore-5</code>, but the proxy reports that <code class="inlinecode">app/sportsstore-3</code> has stopped.</p>
<p class="normal">Once you are happy that the application is working correctly, run the command shown in <em class="italic">Listing 21.32</em> in the <code class="inlinecode">sportsstore</code> folder to stop all of the containers.</p>
<p class="packt_figref">Listing 21.32: Stopping the application containers</p>
<pre class="programlisting1"><code class="hljs-con">docker-compose down
</code></pre>
<p class="normal">Docker will stop all of the containers, updating the status display until all are shown as removed:</p>
<pre class="programlisting1"><code class="hljs-con">...
[+] Running 7/7
    Container sportsstore-sportsstore-2  Removed                                                                          
  Container sportsstore-proxy-1        Removed                                                                           
   Container sportsstore-sportsstore-3  Removed                                                                          
    Container sportsstore-sportsstore-1  Removed                                                                          
  Container sportsstore-sportsstore-4  Removed                                                                          
    Container sportsstore-postgres-1     Removed                                                                           
    Network sportsstore_default          Removed                                                                           
...
</code></pre>
<p class="normal">The application is containerized and the images<a id="_idIndexMarker1179" class="calibre3"/> are ready to be deployed onto a production platform.</p>
<h1 class="heading" id="_idParaDest-372">Summary</h1>
<p class="normal1">In this chapter, I completed the SportsStore application and prepared it for deployment to a container platform.</p>
<ul class="calibre4">
<li class="bulletlist">The SportsStore image contains Node.js, the code and resources, and all of the JavaScript packages required to run the application.</li>
<li class="bulletlist1">The container platform provides networking features that allow containers to communicate so that the SportsStore application can send requests to the database server using the name given to the Postgres container.</li>
<li class="bulletlist1">The container platform can manage the number of instances of a container, which allows the SportsStore application to scale up to handle a larger number of requests.</li>
<li class="bulletlist1">HTTPS requests are received by a proxy, which locates SportsStore containers using a DNS service provided by the container platform. The proxy detects when a container is down and stops forwarding requests to that container.</li>
<li class="bulletlist1">HTTP requests are redirected to HTTPS by the proxy. The SportsStore containers receive only HTTP requests.</li>
<li class="bulletlist1">Containers can be deployed to a wide range of platforms, including all of the large cloud providers, such as AWS and Azure.</li>
</ul>
<p class="normal">That’s all I have to teach you about using Node.js to create web applications. I can only hope that you have enjoyed reading this book as much as I enjoyed writing it, and I wish you every success in your Node.js projects.</p>
</div>
</body></html>