- en: Chapter 7. Deploying and Maintaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have seen the advantages of composing applications out of well
    defined components. This assembly process involves the installation of many support
    systems, from the operating system your application will run on, to the version
    of Node you will support, to the various npm modules, testing frameworks, profiling
    tools, and other subsystems that power an application. It is likely that you have
    been doing all this on a single machine—manually starting and stopping servers,
    updating configurations, and altering application code. Are you adding a new module?
    Stop the server, add the module, and restart the server.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, this sort of ad hoc development is almost impossible,
    and it remains tedious regardless. How can this process be automated and streamlined
    so that altering the number of servers being balanced or incrementally pushing
    out new deployments can be done with minimum work, thus making life simpler for
    the folks responsible for operations?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating the deployment of applications, including a look at the differences
    between continuous integration, delivery, and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Git to track local changes and triggering deployment actions via webhooks
    when appropriate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Vagrant to synchronize your local development environment with a deployed
    production server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning a server with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing continuous integration and deployment using Jenkins and working
    through a complete example of how to automate builds and deploys when the source
    code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining npm packages and dependency trees, outlining how to track version
    changes, and keeping your deployed applications up to date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that application deployment is a complex topic with many dimensions that
    are often considered within unique sets of needs. This chapter is intended as
    an introduction to some of the technologies and themes you will encounter. Also,
    note that the scaling issues discussed in [Chapter 3](ch03.html "Chapter 3. Scaling
    Node"), *Scaling Node*, are part and parcel of deployment. Also, our discussion
    in [Chapter 2](ch02.html "Chapter 2. Installing and Virtualizing Node Servers"),
    *Installing and Virtualizing Node Servers*, is relevant here. You may want to
    revisit those topics while working through the following deployment scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the most basic level, deployment involves automatically validating, preparing,
    and releasing new code into production environments. One of the simplest ways
    to set up a deployment strategy is to trigger releases whenever changes are committed
    to a Git repository through the use of **webhooks**. Paraphrasing the GitHub documentation,
    webhooks *provide a way for notifications to be delivered to an external web server
    whenever certain actions occur on a repository*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Installing and Virtualizing Node Servers"),
    *Installing and Virtualizing Node Servers*, we saw a simplified example of this
    process, where pushing changes to a Heroku instance caused your production build
    to automatically update. One problem with this simple solution is that no validation
    was performed—if you pushed bad code, your production server would blindly run
    bad code. In this section, we'll use GitHub webhooks to create a simple continuous
    deployment workflow, adding more realistic checks and balances.
  prefs: []
  type: TYPE_NORMAL
- en: We'll build a local development environment that lets developers work with a
    clone of the production server code, make changes, and see the results of those
    changes immediately. As this local **development** build uses the same repository
    as the **production** build, the build process for a chosen environment is simple
    to configure, and multiple production and/or development *boxes* can be created
    with no special effort.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a GitHub ([www.github.com](http://www.github.com))
    account if you don't already have one. Basic accounts are free and easy to set
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how GitHub webhooks work.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new folder and insert the following `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that Express 4.x is installed and includes the `body-parser` package,
    which is used to handle POST data. Next, create a basic server called `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Enter the folder you've created, and build and run the server with `npm install;
    npm start`. Visit `localhost:8082/` and you should see **"Hello World!"** in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever any file changes in a given repository, we want GitHub to push information
    about the change to `/webhook`. So, the first step is to create a GitHub repository
    for the Express server mentioned in the code. Go to your GitHub account and create
    a new repository with the name `''express-webhook''`. The following screenshot
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling webhooks](img/1403OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the repository is created, enter your local repository folder and run
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have a new GitHub repository and a local linked version. The
    next step is to configure this repository to broadcast the push event on the repository.
    Navigate to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://github.com/<your_username>/express-webhook/settings`'
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, navigate to **Webhooks & Services** | **Add webhook** (you may need
    to enter your password again). You should now see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling webhooks](img/1403OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is where you set up webhooks. Note that the `push` event is already set
    as default, and, if asked, you'll want to disable SSL verification for now. GitHub
    needs a target URL to use POST on change events. If you have your local repository
    in a location that is already web accessible, enter that now, remembering to append
    the `/webhook` route, as in [http://www.example.com/webhook](http://www.example.com/webhook).
  prefs: []
  type: TYPE_NORMAL
- en: If you are building on a local machine or on another limited network, you'll
    need to create a secure tunnel that GitHub can use. A free service to do this
    can be found at [http://localtunnel.me/](http://localtunnel.me/). Follow the instructions
    on that page, and use the custom URL provided to configure your webhook.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other good forwarding services can be found at [https://forwardhq.com/](https://forwardhq.com/)
    and [https://meetfinch.com/](https://meetfinch.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that webhooks are enabled, the next step is to test the system by triggering
    a push event. Create a new file called `readme.md` (add whatever you''d like to
    it), save it, and then run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will push changes to your GitHub repository. Return to the **Webhooks
    & Services** section for the `express-webhook` repository on GitHub. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enabling webhooks](img/1403OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a good thing! GitHub noticed your push and attempted to deliver information
    about the changes to the webhook endpoint you set, but the delivery failed as
    we haven''t configured the `/webhook` route yet—that''s to be expected. Inspect
    the failed delivery payload by clicking on the last attempt—you should see a large
    JSON file. In that payload, you''ll find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It should now be clear what sort of information GitHub will pass along whenever
    a push event happens. You can now configure the `/webhook` route in the demonstration
    Express server to parse this data and do something with that information, such
    as sending an e-mail to an administrator. For example, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next time your webhook fires, the entire JSON payload will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this to another level, breaking down the autopilot application to
    see how webhooks can be used to create a build/deploy system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a build/deploy system using webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to build a webhook-powered deployment system, we're going
    to use a starter kit for application development. Go ahead and use fork on the
    repository at [https://github.com/sandro-pasquali/autopilot.git](https://github.com/sandro-pasquali/autopilot.git).
    You now have a copy of the **autopilot** repository, which includes scaffolding
    for common Gulp tasks, tests, an Express server, and a deploy system that we're
    now going to explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The autopilot application implements special features depending on whether
    you are running it in production or in development. While autopilot is a little
    too large and complex to fully document here, we''re going to take a look at how
    major components of the system are designed and implemented so that you can build
    your own or augment existing systems. Here''s what we will examine:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create webhooks on GitHub programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to catch and read webhook payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use payload data to clone, test, and integrate changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use PM2 to safely manage and restart servers when code changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven't already used fork on the autopilot repository, do that now. Clone
    the autopilot repository onto a server or someplace else where it is web-accessible.
    Follow the instructions on how to connect and push to the fork you've created
    on GitHub, and get familiar with how to pull and push changes, commit changes,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PM2 delivers a basic deploy system that you might consider for your project
    ([https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment](https://github.com/Unitech/PM2/blob/master/ADVANCED_README.md#deployment)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the cloned autopilot repository with `npm install; npm start`. Once
    npm has installed dependencies, an interactive CLI application will lead you through
    the configuration process. Just hit the *Enter* key for all the questions, which
    will set defaults for a local development build (we''ll build in production later).
    Once the configuration is complete, a new development server process controlled
    by PM2 will have been spawned. You''ll see it listed in the PM2 manifest under
    `autopilot-dev` in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will make changes in the `/source` directory of this development build.
    When you eventually have a production server in place, you will use `git push`
    on the local changes to push them to the autopilot repository on GitHub, triggering
    a webhook. GitHub will use `POST` on the information about the change to an Express
    route that we will define on our server, which will trigger the build process.
    The build runner will `pull` your changes from GitHub into a temporary directory,
    install, build, and test the changes, and if all is well, it will replace the
    relevant files in your deployed repository. At this point, PM2 will restart, and
    your changes will be immediately available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schematically, the flow looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create webhooks on GitHub programmatically, you will need to create an access
    token. The following diagram explains the steps from A to B to C:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a build/deploy system using webhooks](img/1403OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're going to use the Node library at [https://github.com/mikedeboer/node-github](https://github.com/mikedeboer/node-github)
    to access GitHub. We'll use this package to create hooks on GitHub using the access
    token you've just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an access token, creating a webhook is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Autopilot performs this on startup, removing the need for you to manually create
    a hook.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are listening for changes. As we saw previously, GitHub will deliver
    a payload indicating what has been added, what has been deleted, and what has
    changed. The next step for the autopilot system is to integrate these changes.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that, when you use webhooks, you do not have control
    over how often GitHub will send changesets—if more than one person on your team
    can push, there is no predicting when those pushes will happen. The autopilot
    system uses Redis to manage a queue of requests, executing them in order. You
    will need to manage multiple changes in a way. For now, let's look at a straightforward
    way to build, test, and integrate changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your code bundle, visit `autopilot/swanson/push.js`. This is a process runner
    on which fork has been used by `buildQueue.js` in that same folder. The following
    information is passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL of the GitHub repository that we will clone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory to clone that repository into (`<temp directory>`/`<commit hash>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changeset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of the production repository that will be changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go ahead and read through the code. Using a few shell scripts, we will clone
    the changed repository and build it using the same commands you're used to—`npm
    install`, `npm test`, and so on. If the application builds without errors, we
    need only run through the changeset and replace the old files with the changed
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to restart our production server so that the changes reach
    our users. Here is where the real power of PM2 comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: When the autopilot system is run in production, PM2 creates a cluster of servers
    (similar to the Node `cluster` module). This is important as it allows us to restart
    the production server incrementally. As we restart one server node in the cluster
    with the newly pushed content, the other clusters continue to serve old content.
    This is essential to keeping a zero-downtime production running.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the autopilot implementation will give you a few ideas on how to
    improve this process and customize it to your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing local and deployed builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important (and often difficult) parts of the deployment process
    is ensuring that the environment an application is being developed, built, and
    tested within perfectly simulates the environment that application will be deployed
    into. In this section, you'll learn how to emulate, or virtualize, the environment
    your deployed application will run within using Vagrant. After demonstrating how
    this setup can simplify your *local* development process, we'll use Ansible to
    provision a remote instance on DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: Developing locally with Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a long while, developers would work directly on running servers or cobble
    together their own version of the production environment locally, often writing
    ad hoc scripts and tools to smoothen their development process. This is no longer
    necessary in a world of virtual machines. In this section, we will learn how to
    use Vagrant to emulate a production environment within your development environment,
    advantageously giving you a realistic *box* to work on testing code for production
    and isolating your development process from your local machine processes.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, Vagrant is used to create a virtual box emulating a production
    environment. So, we need to install Vagrant, a virtual machine, and a machine
    image. Finally, we'll need to write the configuration and provisioning scripts
    for our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://www.vagrantup.com/downloads](http://www.vagrantup.com/downloads)
    and install the right Vagrant version for your box. Do the same with VirtualBox
    here at [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'You now need to add a box to run. For this example, we''re going to use Centos
    7.0, but you can choose whichever you''d prefer. Create a new folder for this
    project, enter it, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usefully, the creators of Vagrant, HashiCorp, provide a search service for Vagrant
    boxes at [https://atlas.hashicorp.com/boxes/search](https://atlas.hashicorp.com/boxes/search).
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted to choose your virtual environment provider—select `virtualbox`.
    All relevant files and machines will now be downloaded. Note that these boxes
    are very large and may take time to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll now create a configuration file for Vagrant called `Vagrantfile`. As
    with npm, the `init` command quickly sets up a base file. Additionally, we''ll
    need to inform Vagrant of the box we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Vagrantfile is written in Ruby and defines the Vagrant environment. Open it
    up now and scan it. There is a lot of commentary, and it makes a useful read.
    Note the `config.vm.box = "chef/centos-7.0"` line, which was inserted during the
    initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start Vagrant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went as expected, your box has been booted within Virtualbox.
    To confirm that your box is running, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you see a prompt, you've just set up a virtual machine. You'll see that you
    are in the typical home directory of a CentOS environment.
  prefs: []
  type: TYPE_NORMAL
- en: To destroy your box, run `vagrant destroy`. This deletes the virtual machine
    by cleaning up captured resources. However, the next `vagrant up` command will
    need to do a lot of work to rebuild. If you simply want to shut down your machine,
    use `vagrant halt`.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant is useful as a virtualized, production-like environment for developers
    to work within. To that end, it must be configured to emulate a production environment.
    In other words, your box must be provisioned by telling Vagrant how it should
    be configured and what software should be installed whenever `vagrant up` is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy for provisioning is to create a shell script that configures our
    server directly and point the Vagrant provisioning process to that script. Add
    the following line to Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create that file with the following contents in the folder hosting Vagrantfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Destroy any running Vagrant boxes. Run Vagrant again, and you will notice in
    the output the execution of the commands in our provisioning shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this has been completed, enter your Vagrant box as the root (Vagrant boxes
    are automatically assigned the root password "vagrant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that Node v0.12.x is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s standard to allow password-less sudo for the *Vagrant* user. Run `visudo`
    and add the following line to the `sudoers` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Typically, when you are developing applications, you'll be modifying files in
    a project directory. You might bind a directory in your Vagrant box to a local
    code editor and develop in that way. Vagrant offers a simpler solution. Within
    your VM, there is a `/vagrant` folder that maps to the folder that Vagrantfile
    exists within, and these two folders are automatically synced. So, if you add
    the `server.js` file to the right folder on your local machine, that file will
    also show up in your VM's `/vagrant` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a new `test` file either in your local folder or in your
    VM's `/vagrant` folder. You'll see that file synchronized to both locations regardless
    of where it was originally created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clone our `express-webhook` repository from earlier in this chapter
    into our Vagrant box. Add the following lines to provision.sh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to Vagrantfile, which will map port `8082` on the Vagrant
    box (a guest port representing the port our hosted application listens on) to
    port `8000` on our host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to restart the Vagrant box (loading this new configuration) and
    re-provision it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take a while as `yum` installs various dependencies. When provisioning
    is complete, you should see this as the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remembering that we bound the guest port `8082` to the host port `8000`, go
    to your browser and navigate to `localhost:8000`. You should see **"Hello World!"**
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in our provisioning script, we cloned to the (shared) `/vagrant`
    folder. This means the clone of `express-webhook` should be visible in the current
    folder, which will allow you to work on the more easily accessible codebase, knowing
    it will be automatically synchronized with the version on your Vagrant box.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring your machines *by hand*, as we've done previously, doesn't scale
    well. For one, it can be overly difficult to set and manage environment variables.
    Also, writing your own provisioning scripts is error-prone and no longer necessary
    given the existence of provisioning tools, such as Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Ansible, we can define server environments using an organized syntax rather
    than ad hoc scripts, making it easier to distribute and modify configurations.
    Let''s recreate the `provision.sh` script developed earlier using Ansible **playbooks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Playbooks are Ansible''s configuration, deployment, and orchestration language.
    They can describe a policy you want your remote systems to enforce or a set of
    steps in a general IT process.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Playbooks are expressed in the **YAML** format (a human-readable data serialization
    language). To start with, we''re going to change Vagrantfile''s provisioner to
    Ansible. First, create the following subdirectories in your Vagrant folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These will be explained as we proceed through the Ansible setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the following configuration file and name it `ansible.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that Ansible **roles** can be found in the `/provisioning` folder,
    and that we want to keep a provisioning log in `ansible.log`. Roles are used to
    organize tasks and other functions into reusable files. These will be explained
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `config.vm.provision` definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Vagrant to defer to Ansible for provisioning instructions, and that
    we want the provisioning process to be verbose—we want to get feedback when the
    provisioning step is running. Also, we can see that the playbook definition, `provisioning/server.yml`,
    is expected to exist. Create that file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Playbooks can contain very complex rules. This simple file indicates that we
    are going to provision all available hosts using a single role called `common`.
    In more complex deployments, an inventory of IP addresses could be set under `hosts`,
    but, here, we just want to use a general setting for our one server. Additionally,
    the provisioning step will be provided with certain environment variables following
    the forms `env.user`, `nvm.node_version`, and so on. These variables will come
    into play when we define the `common` role, which will be to provision our Vagrant
    server with the programs necessary to build, clone, and deploy `express-webhook`.
    Finally, we assert that Ansible should run as an administrator (`sudo`) by default—this
    is necessary for the `yum` package manager on CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to define the `common` role. With Ansible, folder structures
    are important and are implied by the playbook. In our case, Ansible expects the
    role location (`./provisioning`, as defined in `ansible.cfg`) to contain the `common`
    folder (reflecting the `common` role given in the playbook), which itself must
    contain a `tasks` folder containing a `main.yml` file. These last two naming conventions
    are specific and required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is creating the `main.yml` file in `provisioning/common/tasks`.
    First, we replicate the `yum` package loaders (see the file in your code bundle
    for the full list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see a few benefits of Ansible. A human-readable description of `yum`
    tasks is provided to a looping structure that will install every item in the list.
    Next, we run the nvm installer, which simply executes the auto-installer for nvm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, here, we''re overriding the playbook''s `sudo` setting. This can
    be done on a per-task basis, which gives us the freedom to move between different
    permission levels while provisioning. We are also able to execute shell commands
    while at the same time interpolating variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Ansible provides extremely useful tools for file manipulation, and we will see
    here a very common one—updating the `.bashrc` file for a user. The `lineinfile`
    directive makes the addition of aliases, among other things, straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of the commands follow a similar pattern to implement, in a structured
    way, the provisioning directives we need for our server. All the files you will
    need are in your code bundle in the `vagrant/with_ansible` folder. Once you have
    them installed, run `vagrant up` to see Ansible in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the strengths of Ansible is the way it handles contexts. When you start
    your Vagrant build, you will notice that Ansible gathers facts, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Provisioning with Ansible](img/1403OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simply put, Ansible analyzes the context it is working in and only executes
    what is necessary to execute. If one of your tasks has already been run, the next
    time you try `vagrant provision`, that task will not run again. This is *not*
    true for shell scripts! In this way, editing playbooks and reprovisioning does
    not consume time redundantly changing what has already been changed.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a powerful tool that can be used for provisioning and much more complex
    deployment tasks. One of its great strengths is that it can run remotely—unlike
    most other tools, Ansible uses SSH to connect to remote servers and run operations.
    There is no need to install it on your production boxes. You are encouraged to
    browse the Ansible documentation at [http://docs.ansible.com/index.html](http://docs.ansible.com/index.html)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating, delivering, and deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've been looking at using deployment systems that encourage
    agile development, generally facilitating safe delivery into production environments
    of code updates in near real time. Variations in how deployments can be structured
    and/or understood, which usually depend on factors such as team size and management
    structure, are common. A brief summary of each of the three typical categories,
    **continuous integration**, **continuous delivery**, and **continuous deployment**,
    will be provided in the following sections. Finally, we'll set up a build/deploy
    system for a Node application using Jenkins, a CI server, configured to automatically
    deploy changes to a Heroku server.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous integration is the process of merging changes into a master branch
    continuously (typically, several times a day). The goal of CI is to make errors
    impatient and noisy, arriving early and failing loudly, rather than emerging later
    from much larger and more complex **bulk** merges comprising several days or weeks
    of work. Unit tests are typically run here. Note that an updated integration branch
    is not necessarily continuously deployed, though it may be. The goal is to keep
    a master branch fresh, current, and ready to be deployed when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Delivery" is the key word here. In environments where all changes must be
    tested/vetted by a quality assurance team or some other group of stakeholders
    prior to being released, changes are delivered and reviewed as they are proposed.
    While continuous delivery does not preclude delivery into production, the general
    goal is to deliver new code where it can be subjected to further functional tests,
    tests of business logic, and so on, prior to it reaching real customers.'
  prefs: []
  type: TYPE_NORMAL
- en: This test environment should be equivalent to the production environment and,
    when tests pass, there should be confidence that the changes will also be deployable
    to production. Because this stage is typically understood as preceding deployment,
    it is often described as the *staging environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Staged changes are normally deployable in one step, a single system command,
    or the click of a button in a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous deployment is the aggressive, optimistic strategy of building your
    application in a way such that it can be released into production at any time,
    typically as soon as it passes certain automated tests. This strategy generally
    leads to many releases per day and requires that the validation pipeline, which
    changes move through, is as close to production-like as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there is limited (or nonexistent) oversight of the code being released,
    continuous post-release inspection of application performance is normal. That
    is, trust but verify: push changes into production after automated testing, but
    regularly check whether your visitor counts are dropping, response times are rising,
    or other metrics are behaving abnormally.'
  prefs: []
  type: TYPE_NORMAL
- en: While similar to continuous delivery, the two should not be confused.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying with Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've learned how to use GitHub webhooks to trigger a build process whenever
    new code is pushed to a repository. From pulling and testing a changed repository
    to notifying a chat server that a new build has occurred, Jenkins helps you to
    trigger deployment workflows. As your deployment needs become more complex than
    simply testing a single branch, the benefits of a more powerful CI tool become
    apparent. Jenkins provides tools to manage build permissions, task scheduling,
    triggering deploys, displaying build logs, and more. Let's deploy an application
    using Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Jenkins, run the installer for your environment that can be found
    at [http://jenkins-ci.org/](http://jenkins-ci.org/). There are also services that
    allow you to install Jenkins in the "cloud", but we''re going to build a local
    service. Upon successful installation, a browser will open up with the Jenkins
    "home page" UI, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will use this Jenkins **dashboard** often as you manage builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Jenkins will, by default, run on port `8080`. You will, as with webhooks,
    need to map this location to a web-accessible URL directly, via proxy, via forwarding,
    or in some other way. Move to **Manage Jenkins** | **Configure System** and find
    the **Jenkins Location** section. Add the Jenkins URL, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are running Jenkins on `localhost`, jump back to earlier in this chapter
    when we discussed using forwarding services, such as [http://localtunnel.me/](http://localtunnel.me/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be warned about an unsecured Jenkins instance. This is a valid complaint!
    While we will not set up authentication, you should do so in any real production
    environment. It isn't hard. Visit **Manage Jenkins** | **Configure Global Security**
    to do so and/or visit [https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Securing+Jenkins).
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to do is configure Jenkins to work with Node.js and GitHub. From
    the dashboard, navigate to **Manage Jenkins** | **Manage Plugins** | **Available**.
    You should see a list of available plugins, from which you will search for and
    install *NodeJS Plugin* and *GitHub Plugin*. This may take a while as these plugins,
    and their dependencies, are installed. If any of the installs prompt you to restart
    Jenkins, you will find instructions on how to do that in the installs list provided
    further on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The key integration that we'll have to do is with GitHub. In a new browser window,
    visit your GitHub account and generate a new access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the generated key. You will now give Jenkins this access token so that
    it can perform operations on GitHub on your behalf, in particular around webhooks.
    Return to **Manage Jenkins** | **Configure**, and add this OAuth token and your
    user information to the **GitHub Web Hook** section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run **Test Credential** to ensure that Jenkins can connect to GitHub using the
    token you've provided.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to provide our GitHub credentials to Jenkins so that it can
    pull our repository when changes happen. Navigate to **Credentials** and click
    on **Global credentials**. Select **Username with Password** and add your credentials,
    which will ensure that you give these credentials a useful name (you'll need to
    refer to these credentials later).
  prefs: []
  type: TYPE_NORMAL
- en: Because you have already built your own webhook-powered CI system, it may already
    be apparent to you why Jenkins is being configured in this way. In the end, we
    are configuring Jenkins to respond to push events on a GitHub repository, pull
    the changed repository, and automatically build it. To that end, we will need
    to provision Jenkins so that it is configured with Node and can, therefore, build
    Node repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Configure System** and add a NodeJS installation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will now configure the Node environment that Jenkins will use. You should
    match that environment with the environment your production servers will run in.
    Click on **Add NodeJS** and follow the instructions. You can select **Install
    automatically** and, when presented with installer options, select **Install from
    nodejs.org**. Make sure that you add any global npm packages you need—tools such
    as gulp, pm2, mocha, and others that are necessary to your build environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would rather manage the install yourself, just use the "Run Shell command"
    option and something like the following command, adding any global installs you''d
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember to save your changes!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re almost done configuring Jenkins for CI. The last step is to create a
    build project. Navigate to **New Item**, add a useful item name in the **Item
    name** field, select **Freestyle project**, and click on **OK**. Now, navigate
    to **Source Code Management**, select **Git**, add a GitHub repository name, select
    the credentials to access that repository, click on **Save**, and you''ll be ready
    to build, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Return to the Jenkins dashboard, and you''ll see your build project listed.
    Click on the name, and select **Build Now** from the menu on the left-hand side.
    If all goes well, you''ll see a build history table quickly populate, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building and deploying with Jenkins](img/1403OS_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the number and, if all is well, you'll see information on your build,
    indicating *no changes* (you have just pulled off a masterstroke), some information
    about the Git revision number, and so on. Now, the real test—make a change to
    your GitHub repository, either by pushing a change or simply editing a file using
    GitHub's editing tools. If you return to the dashboard, you will see that Jenkins
    has added a new build to **Build Queue**; shortly the build will complete, and
    you'll see the changes you've just made listed in your project's build history.
    You've just created a CI environment for your project!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to deploy. We'll use Heroku to deploy, but feel free to try your
    provider of choice—as long as it *speaks* Git, Jenkins will be able to push your
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It might be useful to return to [Chapter 2](ch02.html "Chapter 2. Installing
    and Virtualizing Node Servers"), *Installing and Virtualizing Node Servers*, and
    refresh your memory about how to build on Heroku. At the very least, you will
    need to install Heroku Toolbelt and authenticate. Once you are connected to Heroku
    via the toolbelt, clone the `express-webhook` repository we created earlier and
    enter that folder. Now, run `heroku create` to build a machine on Heroku. You
    should receive both a URL and a Git endpoint resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to push something for that server to run. Execute the following
    command to push the `express-webhook` application to Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The express-webhook application is now deployed to Heroku. Heroku will have
    automatically built and started the application. Go ahead and visit the URL we
    received before in a browser. The next step is to use Jenkins to automatically
    deploy to Heroku whenever you make changes to the application repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now connected to two Git repositories, which you can see by running
    `git remote -v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `origin` URL is our GitHub repository, and `heroku` represents the Git repository
    maintained by Heroku. We'll synchronize these two via Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Jenkins will eventually be doing the pushing for us, we need to give it
    permission to access your Heroku box. What we''re going to do is generate a key
    pair for the `jenkins` user and associate these local SSH keys with Heroku, allowing
    Jenkins to perform pushes and so on. Log in as the `jenkins` user, and run the
    following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Jenkins can now authenticate with Heroku. All that is left to do is inform Jenkins
    about the Heroku repository and to instruct Jenkins to deploy to Heroku whenever
    it is informed, via the webhook we configured earlier, that changes have been
    made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your Jenkins project, click on **Configure**, and add the Heroku
    Git endpoint as another repository to the **Source Code Management** section by
    clicking on **Add Repository**. Fill in the **Repository URL** field to match
    the one you received earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to Heroku](img/1403OS_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you will *not* fill in **Credentials** as we've earlier linked Jenkins
    to Heroku using SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click on the "Advanced" button underneath the new repository, and give
    it a name—you''ll need this for the next step. Here we use **heroku**, but it
    can be anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to Heroku](img/1403OS_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, Jenkins has been made aware of our GitHub repo and our Heroku repo. The
    final step is to configure Jenkins to push GitHub changes to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to **Post-build Actions** in your Jenkins project. Click on **Add
    post-build action** and select **Git publisher**. Fill out the form provided exactly
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to Heroku](img/1403OS_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are telling Jenkins to push to the `master` branch of the `express-webhook`
    GitHub repository to `heroku` after each successful build. This is the deploy
    step. Save your changes—you're done!
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that everything is working, modify the default route of `server.js`
    in your local clone of `express-webhook` such that it produces a different message,
    and push that change to GitHub. If you return to the Jenkins dashboard, you will
    soon see something like the following progress indicator on the build status of
    your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying to Heroku](img/1403OS_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If all goes well, your project will be listed on the dashboard as having been
    successfully built. If you refresh your Heroku URL, you will also see the changes
    you've made. Congratulations on successfully setting up continuous deployment
    for your project!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the structure set up for CI and deployment, start adding tests
    and other build steps and run them either in your Node environment or using the
    many Jenkins tools available to you. Happy building!
  prefs: []
  type: TYPE_NORMAL
- en: Package maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript itself does not provide a native package management system; npm does
    this job for Node applications. A good package management strategy is, therefore,
    a key part of a good deployment strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Packages offer the benefit of encapsulation. Running packages are accessible
    only through the API they've exported. This isolation reduces the number of potential
    bugs in a system, thus guarding the core functionality from accidental alteration.
    However, given that (opaque) packages can themselves require other packages as
    dependencies, the full dependency graph of an application can be difficult for
    a developer to easily see. For example, if the functionality of a package you
    have implemented suddenly changes, how do you debug it? Is the error in the package?
    Is it in one of its dependent packages?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding *what is going on* in your npm dependency graph is essential when
    you are deploying Node applications. In this section, we will look at ways to
    stay up to date on package updates, use Git to manage private packages, track
    the health of an *entire* dependency graph, and look at best practices to set
    version rules in your application's `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Semver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Semantic Versioning** (**Semver**) is simply a set of rules that have been
    proposed to govern how dependencies in a system are declared. Npm enforces these
    rules in its package manager, so understanding how they govern dependency management
    is what will be discussed here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example the following npm package file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each dependency is given a version number corresponding to a version in the
    npm repository. Some of these numbers are further modified by tokens, for example,
    a caret (`^`) or a tilde (`~`), as well as version ranges. Let's look at what
    each segment of semantically versioned numbers signify and how various tokens
    are used to modulate those segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A version number is broken into three segments, which are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Semver](img/1403OS_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Semver concretely describes allowable package version ranges as well as implying
    the current stability or state of a package—whether the package is stable, whether
    it is mature, and so on. The numbering proceeds in order: 1.0.1 precedes 1.0.2,
    which precedes 2.0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The significance of the changes that Semver describes proceeds from left to
    right, where a change in the major version of a package typically describes changes
    that break compatibility with lower versions—2.0 is not compatible with 1.0\.
    According to [semver.org](http://semver.org), you should use version numbers in
    this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when
    you make incompatible API changes, MINOR version when you add functionality in
    a backwards-compatible manner, and PATCH version when you make backwards-compatible
    bug fixes."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then, Semver allows you to set acceptable range limits on the versions of dependencies
    in your application with an eye toward providing useful indications of the level
    of impact implied by version changes. Some common usage examples are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '"3" indicates that only the major version (3) must be satisfied, ignoring minor
    or patch values—3.0.0, 3.6.3, and 3.99.99 are all acceptable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"3.4.5" indicates that *only* that version is acceptable, with no variation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"<, <=, > and >=" range comparators work as expected in many programming languages
    and can be used to set controlled ranges. >= 3.0.1 <= 3.2.1 accepts 3.0.2 and
    3.1.9 but not 3.0.0 or 3.2.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.3.4 >= 3.0.1 <= 3.2.1 accepts the version range as described in the preceding
    point *or* the 1.3.4 version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being equivalent to >= 0.0.0, "*" indicates that *any* version is acceptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyphen ranges (-) describe inclusive sets. The hyphen range 1.0.0 - 2.0.0 matches
    any package with a major version of 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x-ranges provide a shorthand for minor and patch ranges; 1.2.x is equivalent
    to >= 1.2.0 <= 1.3.0 and 1.x is equivalent to >= 1.0.0 <= 2.0.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilde(~) ranges allow patch-level changes if a minor version is specified and
    minor-level changes if it is not. ~1.3.2 is equivalent to >= 1.3.2 < 1.4.0, ~1.3
    is equivalent to >= 1.3.0 < 1.4.0, and ~1 is equivalent to >= 1.0.0 < 2.0.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caret(^) ranges allow changes that do not modify the leftmost nonzero digit.
    ^1.2.0 is equivalent to >= 1.2.0 <= 2.0.0, ^0.2.1 is equivalent to >= 0.2.1 <=
    0.3.0, and ^0.0.2 is equivalent to >= 0.0.2 < 0.0.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details, visit [https://github.com/npm/node-semver](https://github.com/npm/node-semver)
    and [https://docs.npmjs.com/misc/semver](https://docs.npmjs.com/misc/semver).
    A useful tool to check versions for specific packages against Semver tuples can
    be found at [http://semver.npmjs.com/](http://semver.npmjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: As we saw when we were using the `npm install <packagename> --save` construct,
    npm defaults to caret prefixing—npm will assign the newly installed dependency
    a version of `^<latest version>` in `package.json`. If you'd like to have a default
    tilde prefix, use `npm config set save-prefix="~"`.
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature of Semver for maintainability is prerelease tags.
    These tags allow you to release a package version that is not ready for production
    (prerelease), which you might do in order to get it in the hands of other people
    on your team, beta testers, and so on, while ensuring that the default version
    will be installed on a "normal" install.
  prefs: []
  type: TYPE_NORMAL
- en: When you publish an npm package, you can use the `--tag` argument to tag that
    release. The published package is now no longer tagged as "latest" but as whichever
    tag you've assigned it. Let's say we tagged the **alpha.7** package (and changed
    the version field of the package with `npm version <version>-alpha.7`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the case where that package is being listed as a dependency somewhere
    in *userland*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When this package is installed, npm will install the alpha.7 package—Semver
    ranges would apply as alpha.7 is greater than alpha.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our package in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, the alpha.7 package will *not* be installed. In this
    way, we can see that by the Semver rule, prerelease tags only apply if the comparator
    (what you've set as the version of the package) also contains a prerelease tag.
    In this way, you can safely release experimental breaking changes in tagged packages
    as only someone who is fully aware of the tag name (and its alpha nature) would
    do the work required to be done to use it, while others continue to use production
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Managing packages with npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important (and tricky) application management strategies you
    will deploy is choosing packages and updating package versions. In this section,
    good strategies to maintain your npm packages will be discussed—how to keep your
    packages up to date, how to lock dependencies, how to load packages from Git repositories
    rather than npm, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, you'll want to balance the relative safety of the rigid Semver constraints
    with the need to stay as up to date as possible with the latest version of an
    important package and to keep your dependency tree predictable and clean. Developing
    a good strategy here will help with application maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following six aspects of package maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining awareness of the full npm dependency tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking divergence between the latest version and the installed version of
    a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing unused packages defined in your package file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that all needed dependencies are installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the dependencies you need are the ones you have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using private or other modules not held in the npm repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other package management systems enforce the rule that a single version of a
    package exists across all dependencies; npm does not. Packages typically require
    other packages, so multiple versions of the same package can enter into an npm
    build. An application may have A and B dependencies, with the A package requiring
    version 1.0.1 of the C package, and with the B package requiring version 2.0.1
    of the C package.
  prefs: []
  type: TYPE_NORMAL
- en: Think about what it means to say that, on every npm install, there is limited
    (often barely thought out) control over the package versions inserted into a dependency
    tree—there is no guarantee that your application will run the same code at any
    given time. What's been installed at one moment may fundamentally change if you
    reinstall one hour later or even one second later. That's an extraordinary level
    of risk to introduce into production systems—similar to a software manager being
    indifferent to who makes changes, where, or when.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is getting a full breakdown of what has been installed. Use
    `npm ls` for this, which returns something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want this tree to be represented as JSON, use the `--json` flag: `npm
    ls --json`. To include the contents of each package''s `description` field in
    the output, use `npm ls --long`. You can use `npm ls -g` to get this tree for
    *globally* installed packages. If you''d just like to know which packages are
    installed globally, try `` ls `npm root -g` ``.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping up to date on the current versions of the installed packages is something
    you should be doing regularly. It doesn''t take long for the version of a package
    to become outdated. Npm provides the `npm outdated` tool for this purpose (here,
    it is used with the `--long` "extended information" argument). The following screenshot
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing packages with npm](img/1403OS_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we see that the `package.json` file within the `node_modules/redis` folder
    of our application is at version 0.8.2 (**current**), that the **latest** version
    is 0.12.1, and that the **wanted** Semver for *redis* in the root `package.json`
    file will match up to version 0.12.1\. This indicates that it has been quite a
    while since `npm install` was run within this application. A very useful global
    tool to perform these sorts of checks is `npm-check` ([https://github.com/dylang/npm-check](https://github.com/dylang/npm-check)),
    which delivers more detailed information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing packages with npm](img/1403OS_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, this tool offers an interactive UI that will automatically update
    the packages you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of residue that accumulates over time is unused packages. These
    can be installed in `node_modules` but no longer linked, or these can be defined
    for a package but not required anywhere in the application's code.
  prefs: []
  type: TYPE_NORMAL
- en: To remove packages that are *installed* but no longer listed in `package.json`,
    you can use `npm prune`. Note that this is simply a technique for cleaning up
    the `node_modules` folder within an individual package's folder; it is not a smart,
    global tool to remove unused packages across the entire tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dependency-check` module ([https://github.com/maxogden/dependency-check](https://github.com/maxogden/dependency-check))
    is another tool to find unnecessary packages. Assuming that such an unused dependency
    exists, dependency-check will find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, packages may be required in the application code but not listed
    in a package file. This happens occasionally, when a necessary package is installed
    during development but not saved to `package.json`, possibly because the user
    forgets to use the `--save` option or for some other reason. The `dependency-check`
    command will walk all files in your codebase and find such cases, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is expected that the entry point to your application is listed
    in `package.json` as `dependency-check` needs to know where your application tree
    is rooted. You should, therefore, ensure that your packages all have a `main`
    attribute pointing to an existing file. If you need to add further files to check,
    use the `--entry` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To have a `main` entry point to your application is an important general practice
    that you should follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final tool that can help speed up your npm builds is `npm dedupe`. When
    triggered, npm attempts to reduce the number of redundant package installs, "flattening"
    the tree somewhat, and, therefore, reducing install time. Consider this dependency
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the A package depends on the B and D packages, which each depend on the
    C package. Normally, C would be installed twice, once for each parent. However,
    if the Semver that B and D use to target C matches a single version of C, npm
    will reduce the tree in a way that both B and D pull from pull from the same,
    single, installed version of C. Note that Semver rules still apply—npm will not
    break version requirements solely to reduce the number of installs required.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear that many of the tools we've been looking at would fit nicely
    into a build/deploy process, issuing a warning if, for example, a given package
    is not used or is out of date. npm is itself an npm package ([https://github.com/npm/npm](https://github.com/npm/npm))—try
    using npm programmatically within your build process to perform some of these
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a dependency tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All dependencies are not created equal. Some are necessary when in development
    mode but are not meaningful in production. The location and versions of dependencies
    can also vary as you may not always use packages in the npm repository, or you
    may want to use specialized versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of dependencies used in npm package files: **dependencies**,
    **devDependencies**, and **peerDependencies**. Let''s look at the differences.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple dependencies are likely what you're most familiar with. These dependencies
    are *always* installed, regardless of context. You should place dependencies that
    *must* exist in this collection, typically the packages your production build
    will need.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are developing and building, you will often use tools, such as Mocha
    or gulp. Once a validated build is ready to be placed in production, however,
    there is no need for those packages to accompany it. The packages you do not need
    in production should be placed in the devDependencies collection. While npm will
    always install both dependencies and devDependencies, you can (and should) exclude
    devDependencies from the deploy install using the `--production` flag, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Usefully, if you run the `npm config set production` command, the `~/.npmrc`
    file will be updated such that all future installs will automatically set the
    `--production` flag. For example, your provisioner can do this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, peerDependencies deals with the case of plugins. You''re familiar
    with various Grunt plugins. While these are loaded via the npm ecosystem, they
    need their host program (Grunt) in order to function. You might think that each
    of these plugins should just `require(''grunt'')`—but which version of Grunt?
    Any one of these plugins may depend on a specific version of its host program,
    but those host programs are also direct dependencies of the package. So, consider
    this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding declaration leads to a dangerous conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, peerDependencies should be used in plugin-type packages that have specific
    host-program needs, allowing the plugin to "carry along" their needed host. If
    npm attempts to install a different version of that host program, an error is
    thrown. This, of course, leads to another problem—any given plugin can cause an
    install to fail if its required host program is not version-compatible with the
    one the main application is demanding. The complexities of peerDependencies remain
    an ongoing discussion in the Node community ([https://github.com/npm/npm/issues/5080](https://github.com/npm/npm/issues/5080)).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, npm does not put many limits on package versions, allowing multiple
    versions of the same package to exist simultaneously and, indeed, for versions
    (and, therefore, package functionality) to change unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to secure your application''s state is to lock a dependency tree using
    `npm shrinkwrap`. This command will trigger npm to generate the `npm-shrinkwrap.json`
    file containing explicit references to specific versions. The file generated contains
    definitions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It should be clear how this syntax ensures that future installs will be identical.
    Note that this is a heavy-handed approach that you probably don't need very often.
    However, in production situations where you are deploying identical code across
    multiple machines, shrinkwrapped "bundles" may be exactly what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option to ensure visibility in the behavior of your packages is to
    control them in their entirety. You are able to link dependencies to Git repositories,
    either public or private. For example, you can load Express directly from its
    GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: npm assumes GitHub, so you are able to use the compressed syntax, as shown in
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also link to a private Git repository using `https/oauth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use SSH as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The npm package manager is an essential part of the Node ecosystem, and Node
    applications are typically composed of dozens, even hundreds, of packages. Developing
    a strategy around package management is an important consideration if you plan
    to release and maintain a large-scale Node application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deploy a local build into a production-ready
    environment. The powerful Git webhook tool was demonstrated as a way of creating
    a continuous integration environment, and this knowledge was carried forward into
    the creation of a full build/deploy pipeline that connected a GitHub repository
    to a Heroku deployment via a CI environment configured using Jenkins. We also
    covered the semantic versioning system that npm uses and even how to use Semver,
    npm methods, and some helper libraries to keep our package trees clean and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: From basic JavaScript programs to the deployment of full applications, in this
    book, we took a tour of Node's design and goals. We've worked through ways in
    which Node's event-driven architecture influences how we design networked software
    by building on the foundational concept of streams. With an eye toward the creation
    of fast, deployable systems, we worked through virtualization strategies, compiler
    optimizations, load balancing, and vertical and horizontal scaling strategies.
    Additionally, the power of composing software out of small, focused programs was
    considered by introducing the power of micro services, interprocess messaging,
    and queues as one way to build distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that software is written by fallible humans, we also covered
    strategies for testing and maintaining running applications, learning to expect
    failure, and planning for it, with the help of both native and third-party logging
    and monitoring tools. We learned debugging techniques and optimization strategies
    aimed at reducing bottlenecks at the local and network levels and also how to
    find their source when they inevitably appear. With the goal of making development
    simpler, we looked at how to make effective use of integration tools and versioning
    systems, provision virtual machines and test with headless browsers, enable developers
    to work freely and take risks, and push changes with the confidence that smart
    deployment strategies confer. Constructing a smart build pipeline, you learned
    about the power of full-stack JavaScript, transpilation, live updates, and continuous
    testing and integration.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to modify and extend the example code to improve it or, otherwise,
    change it to your needs. The hope is that, as you come to appreciate the power
    of Node.js, the npm ecosystem, and open source software, you will begin to naturally
    design your applications so that they will require few changes when pushed into
    production, and that you will share your discoveries so that others can do the
    same thing.
  prefs: []
  type: TYPE_NORMAL
