- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Deep Dive into Data Loading
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨数据加载
- en: Every application ever created has been driven by data. Without data to process,
    an application is effectively useless. That’s why it’s very important for developers
    to have a firm understanding of how to manage the retrieval of that data for their
    application. When working with SvelteKit, this is done by exporting a `load()`
    function in page or layout files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个创建过的应用程序都是由数据驱动的。没有数据来处理，应用程序实际上是没有用的。这就是为什么开发者对如何管理他们应用程序的数据检索有一个牢固的理解非常重要。当使用SvelteKit时，这是通过在页面或布局文件中导出`load()`函数来完成的。
- en: In the previous chapter, we briefly touched on `load()`. In this chapter, we’ll
    analyze it further by discussing how it works and by looking at more practical,
    real-world examples of making use of it. We’ll create an example of forcing `load()`
    in the client only as well as covering some key details to remember when using
    `load()`. We’ll also use `load()` in layouts to showcase how it can make data
    portable across our application. Finally, we’ll look at an example of making use
    of some of the data provided in a server `load()` function that is unavailable
    in universal `load()` functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了`load()`。在本章中，我们将通过讨论其工作原理以及查看更多实际、真实世界的示例来进一步分析它。我们将创建一个仅在客户端强制执行`load()`的示例，并介绍使用`load()`时需要记住的一些关键细节。我们还将使用`load()`在布局中展示它如何使数据在我们的应用程序中可移植。最后，我们将查看一个示例，展示如何利用服务器`load()`函数提供的一些数据，这些数据在通用`load()`函数中不可用。
- en: 'We’re going to cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Loading in Clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端加载
- en: Loading in Layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布局中加载
- en: Destructuring RequestEvent
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构RequestEvent
- en: By the time you’ve finished this chapter, you’ll be comfortable with all the
    various ways you can load data in your SvelteKit application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章学习后，你将能够熟练地在SvelteKit应用程序中以各种方式加载数据。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter05).
- en: Loading in Clients
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端加载
- en: While discussing *Creating Server Pages* in the previous chapter, we covered
    how a `load()` function exported from `+page.js` will run on both the client and
    the server. When we want to ensure load is only run on the server, we move it
    to `+page.server.js`. But what if you’re trying to build an offline-ready application?
    You may be building a `load()` functions to run on the client and not on the server.
    How can we do that when a `load()` function from `+page.js` runs in both environments?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论*创建服务器页面*时，我们介绍了从`+page.js`导出的`load()`函数将在客户端和服务器上运行。当我们想要确保`load()`只在服务器上运行时，我们将它移动到`+page.server.js`。但如果你正在尝试构建一个离线准备好的应用程序呢？你可能正在构建一个仅在客户端上运行的`load()`函数，而不是在服务器上。当`+page.js`中的`load()`函数在两个环境中运行时，我们如何做到这一点？
- en: Again, think back to the *Creating Server Pages* section in the previous chapter
    where we discussed page options, and you’ll remember the `ssr` option. When exported,
    this constant will disable or enable `load()` function in `+page.js` run only
    in the client, we can add `export const ssr = false;`. Let’s go back to our `fetch`
    example from [*Chapter 3*](B19024_03_Final_AM.xhtml#_idTextAnchor051) and modify
    it to demonstrate this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回想一下上一章中*创建服务器页面*部分，我们讨论了页面选项，并且你会记得`ssr`选项。当导出时，这个常量将禁用或启用`+page.js`中的`load()`函数，使其仅在客户端运行，我们可以添加`export
    const ssr = false;`。让我们回到我们的`fetch`示例[*第3章*](B19024_03_Final_AM.xhtml#_idTextAnchor051)并修改它以展示这一点。
- en: 'Before making this adjustment, ensure the `console.log(''got response'')` function
    still exists. Open the `/fetch` route in your browser and confirm the output is
    shown in both the browser console and your development server. Once you’ve done
    so, disable SSR on the page by exporting the `ssr` page option:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此调整之前，请确保`console.log('got response')`函数仍然存在。在浏览器中打开`/fetch`路由，并确认输出显示在浏览器控制台和你的开发服务器上。完成这些操作后，通过导出`ssr`页面选项来禁用页面上的SSR：
- en: src/routes/fetch/+page.js
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/fetch/+page.js
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is identical to when we saw it earlier, except that on line 3,
    we’ve added `export const ssr = false;`. This page option effectively disables
    SSR for the page, meaning that `load()` is only ever run in the client. You’ll
    notice the `console.log()` call isn’t output to the development server anymore
    but does show in the browser console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与我们之前看到的例子相同，只是在第3行，我们添加了 `export const ssr = false;`。这个页面选项有效地禁用了页面的SSR（服务器端渲染），意味着
    `load()` 只会在客户端运行。你会注意到 `console.log()` 调用不再输出到开发服务器，但会在浏览器控制台中显示。
- en: 'From here on out, we’ll differentiate `load()` functions as either `load()`
    functions are run on the server in `+page.server.js`, which means that universal
    `load()` functions are run from `+page.js`. At a high level, they are functionally
    identical. But there are a few idiosyncrasies to mention:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将区分 `load()` 函数，即 `load()` 函数是在服务器上的 `+page.server.js` 中运行的，这意味着通用 `load()`
    函数是从 `+page.js` 中运行的。从高层次来看，它们在功能上是相同的。但还有一些特殊之处需要提及：
- en: Both universal and server `load()` functions can access data related to the
    request that called it.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用和服务器 `load()` 函数都可以访问与调用它的请求相关的数据。
- en: A server `load()` function will have access to more request data, such as cookies
    and the client IP address.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器 `load()` 函数将能够访问更多请求数据，例如cookie和客户端IP地址。
- en: Universal `load()` functions always return an object. The values of that object
    may be nearly anything.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用 `load()` 函数始终返回一个对象。该对象的值可以是几乎任何东西。
- en: Server `load()` functions *must* return data that can be serialized by the `devalue`
    package (essentially, anything that can be converted into JSON). Find out more
    about `devalue` at [https://github.com/rich-harris/devalue](https://github.com/rich-harris/devalue).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器 `load()` 函数*必须*返回可以被 `devalue` 包序列化的数据（基本上，任何可以转换为JSON的东西）。更多关于 `devalue`
    的信息请访问 [https://github.com/rich-harris/devalue](https://github.com/rich-harris/devalue)。
- en: Universal Load Timing
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通用负载时间
- en: It should be mentioned that on the first render, `load()` will execute on the
    server and client. Each subsequent request will then be executed in the client
    only. To demonstrate this behavior, navigate your browser to a route that has
    `load()` run from a `+page.js` file, like our `/fetch` example from [*Chapter
    3*](B19024_03_Final_AM.xhtml#_idTextAnchor051). Observe the console output in
    the server as well as the client when initially opening the `/fetch` page in your
    browser. Navigating to another route and back will show the output only in the
    client.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，在第一次渲染时，`load()` 将在服务器和客户端执行。然后，每个后续请求都将在客户端执行。为了演示这种行为，请将你的浏览器导航到一个从
    `+page.js` 文件中运行 `load()` 的路由，例如我们来自 [*第3章*](B19024_03_Final_AM.xhtml#_idTextAnchor051)
    的 `/fetch` 示例。观察在浏览器中首次打开 `/fetch` 页面时服务器和客户端的输出控制台。导航到另一个路由然后再返回将只显示客户端的输出。
- en: One final note about calling `load()`; it will always be invoked at runtime
    unless you have specified that the page should be prerendered by way of page options.
    If you have decided to prerender the page, then `load()` will be called at build
    time. Remember that pages should only be prerendered if the static HTML shown
    should be the same for each user to access the page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于调用 `load()` 的最后一点说明；除非你指定页面应该通过页面选项预先渲染，否则它将在运行时始终被调用。如果你决定预先渲染页面，那么 `load()`
    将在构建时被调用。记住，页面应该只在静态HTML对于每个访问页面的用户都相同的情况下才进行预先渲染。
- en: We’ve just covered how `load()` can be forced to run only on the client and
    some details about how it works. With all of this new information as well as the
    information from previous chapters, you should feel relatively comfortable about
    the fundamentals of `load()`. Let’s expand on it and take a look at how it might
    be used in a layout template.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了如何强制 `load()` 只在客户端运行以及它的一些工作细节。结合所有这些新信息以及前几章的信息，你应该对 `load()` 的基础知识感到相对舒适。让我们进一步探讨，看看它如何在布局模板中使用。
- en: Loading in Layouts
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载布局
- en: So far, we’ve only looked at `load()` being used in `+page.js` or `+page.server.js`
    files, but it can also be utilized in `+layout.js` or `+layout.server.js` files.
    While layouts cannot export actions, they are otherwise functionally identical
    to page files. This means that previously mentioned page options (such as `ssr`)
    and `load()` functions will apply to any components nested inside of the layout.
    Another important quality to understand about `load()` functions is that because
    they are run concurrently within SvelteKit, a single page will not render until
    all requests have completed. Having a `load()` function on a page as well as a
    layout will prevent rendering until both have completed. But because they will
    be run simultaneously, any delays should be negligible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了 `load()` 在 `+page.js` 或 `+page.server.js` 文件中的使用，但它也可以在 `+layout.js`
    或 `+layout.server.js` 文件中使用。虽然布局不能导出操作，但它们在其他方面与页面文件功能相同。这意味着之前提到的页面选项（如 `ssr`）和
    `load()` 函数将适用于布局内部嵌套的任何组件。关于 `load()` 函数的另一个重要特性是，由于它们在 SvelteKit 中并发运行，单个页面将在所有请求完成之前不会渲染。在页面上以及布局上都有
    `load()` 函数将防止渲染，直到两者都完成。但由于它们将同时运行，任何延迟都应该微不足道。
- en: When loading data in a layout, the most obvious advantage of doing so is the
    ability to access that data in sibling and child pages. This means that any data
    loaded by a layout can then be accessed within an inherited `+page.svelte` file
    when it has exported the `data` variable. SvelteKit will also keep track of data
    loaded across the application and only trigger `load()` when it believes it to
    be absolutely necessary. In instances where we want to force data to be reloaded,
    we can import the `invalidate` or `invalidateAll` modules provided by `$app/navigation`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局中加载数据的最明显优势是能够访问在兄弟和子页面中的数据。这意味着布局加载的任何数据都可以在导出 `data` 变量的继承的 `+page.svelte`
    文件中访问。SvelteKit 还会跟踪应用程序中加载的数据，并且只有在它认为绝对必要时才会触发 `load()`。在我们想要强制重新加载数据的情况下，我们可以导入
    `$app/navigation` 提供的 `invalidate` 或 `invalidateAll` 模块。
- en: To demonstrate these concepts, let’s create a component alongside the navigation
    that can alert the user to unread notifications. The component will persist across
    the application header so it may be easily accessed. This makes for an ideal scenario
    showcasing loading data from a layout. We’ll also create another page that shows
    the full list of notifications to demonstrate how data loaded from a layout can
    be used in a child component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些概念，让我们创建一个与导航并列的组件，以便向用户提醒未读通知。该组件将持久存在于应用头部，以便易于访问。这为展示从布局中加载数据的理想场景提供了可能。我们还将创建另一个页面，显示通知的完整列表，以演示从布局加载数据如何在子组件中使用。
- en: 'Let’s start with the `load()` function in `+layout.js`. For simplicity’s sake,
    we’ll return the data directly within the function call instead of making a call
    to an imaginary database or API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `+layout.js` 中的 `load()` 函数开始。为了简单起见，我们将在函数调用中直接返回数据，而不是调用一个假想的数据库或 API：
- en: src/routes/+layout.js
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/+layout.js
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file consists only of the exported `load()` function, which returns an
    object containing another `notifications` object. Remember that universal `load()`
    functions can export anything so long as it resides inside an object. The `notifications`
    object is quite simple as it consists of two properties; a `count` property with
    the value of `3` and another property labeled `items`, which is just an array
    of three other objects. To show how the data isn’t loaded every time we navigate
    to a new page, we’ve included a `console.log()` call that outputs the text `notifications
    loaded`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件仅包含导出的 `load()` 函数，它返回一个包含另一个 `notifications` 对象的对象。请记住，通用的 `load()` 函数可以导出任何东西，只要它位于对象内部。`notifications`
    对象相当简单，它由两个属性组成；一个值为 `3` 的 `count` 属性，另一个标记为 `items` 的属性，它只是一个包含三个其他对象的数组。为了显示数据不是每次导航到新页面时都会加载，我们包含了一个
    `console.log()` 调用，输出文本 `notifications loaded`。
- en: 'Next, we’ll make some changes to our root layout template so it can actually
    use our freshly loaded data. For the most part, it will stay the same, but we’ll
    need to add some markup that can show the data as well as minimal styling to convey
    the concept of a **notification badge**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对我们的根布局模板进行一些更改，以便它实际上可以使用我们刚刚加载的数据。大部分将保持不变，但我们需要添加一些可以显示数据的标记以及一些基本的样式来传达**通知徽章**的概念：
- en: src/routes/+layout.svelte
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/+layout.svelte
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are some important changes to make note of in this version of `+layout.svelte`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 `+layout.svelte` 中有一些重要的更改需要注意：
- en: A new `Notify` component is imported (shown next).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入了新的`Notify`组件（如下所示）。
- en: We exported the `data` variable to make use of the data returned from `src/routes/+layout.js`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导出`data`变量以使用从`src/routes/+layout.js`返回的数据。
- en: The `notifications` `count` property is sent to the `Notify` component.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`notifications`的`count`属性发送到`Notify`组件。
- en: The markup for the `.menu` and `.notifications` elements are added to the `.nav`
    div element. This allows us to show the `Notify` component in the top-right corner
    of the page.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`.menu`和`.notifications`元素的标记添加到`.nav`div元素中。这允许我们在页面的右上角显示`Notify`组件。
- en: New styles for elements with the `.nav`, `.menu`, and `.notifications` classes
    are added to style our new markup.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为具有`.nav`、`.menu`和`.notifications`类的元素添加了新的样式，以装饰我们的新标记。
- en: 'Next, let’s look at the `Notify` component we just imported. This component
    will contain the markup that shows our notification count and links to the `/``notification`
    route:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们刚刚导入的`Notify`组件。此组件将包含显示我们的通知计数和链接到`/notification`路由的标记：
- en: src/lib/Notify.svelte
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/Notify.svelte
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This component is relatively simple. Firstly, it exports the `count` variable
    and gives it a default value of `0`. This is necessary because, while this component
    is used inside the layout, it does not exist underneath or alongside the `+layout.js`
    file we created earlier and so it does not have access to the information provided
    by the layout `load()` function. Next, this component creates a link tag to contain
    the `count` variable. And finally, it contains spartan styling to decorate our
    notification badge.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件相对简单。首先，它导出`count`变量并为其设置默认值`0`。这是必要的，因为虽然这个组件在布局中使用，但它并不位于我们之前创建的`+layout.js`文件之下或旁边，因此它无法访问布局`load()`函数提供的信息。接下来，这个组件创建一个链接标签来包含`count`变量。最后，它包含了一些基本的样式来装饰我们的通知徽章。
- en: 'Finally, let’s look at the notifications page. Because this file exists underneath
    the hierarchy of `+layout.js`, we can access `data` as if it were loaded from
    a `+page.js` file that existed alongside it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看通知页面。因为这个文件位于`+layout.js`的层次结构之下，我们可以像从与其并存的`+page.js`文件加载的数据一样访问`data`：
- en: src/routes/notifications/+page.svelte
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/notifications/+page.svelte
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This page makes use of Svelte directives: `{#if}` and `{#each}`. Since we exported
    the `data` variable at the top of the component, we can use data loaded from `src/routes/+layout.js`
    within this component. If the `count` property of the `notifications` objects
    is greater than zero, it will create the markup necessary for an unordered list.
    It then outputs the `content` property of each comment item inside a list item.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面使用了Svelte指令：`{#if}`和`{#each}`。由于我们在组件顶部导出了`data`变量，因此我们可以在此组件中使用从`src/routes/+layout.js`加载的数据。如果`notifications`对象的`count`属性大于零，它将创建必要的标记来生成一个无序列表。然后，它在一个列表项中输出每个评论项的`content`属性。
- en: Now, when you open your project in your browser, you should see a new notification
    badge displayed in the top-right corner of the app showing the value of the `count`
    property from the `notification` object. Try selecting some of the items in the
    navigation menu and see how the text **notifications loaded** isn’t output every
    time you click a link. It is shown on the initial load in both the development
    server as well as the browser console but not run again. That is because the data
    being loaded has yet to change, and SvelteKit recognizes this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你用浏览器打开你的项目时，你应该在应用的右上角看到一个新通知徽章，显示`notification`对象中`count`属性的值。尝试选择导航菜单中的某些项，看看每次点击链接时文本**notifications
    loaded**是否都会输出。它在开发服务器和浏览器控制台中首次加载时显示，但不会再次运行。这是因为正在加载的数据尚未更改，SvelteKit能够识别这一点。
- en: 'Let’s look at forcing the data to be reloaded when we click on the notification
    badge. We can do this by using `invalidateAll` imported from `$app/navigation`.
    If the `load()` function used `fetch()`, it would make sense to use the `invalidate`
    module instead. In that instance, we would force the reload by passing the URL
    specified inside of the `fetch()` call to `invalidate()`. Since we’re simply returning
    an object, we’ll need to use `invalidateAll()` to trigger the reload:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在点击通知徽章时强制重新加载数据。我们可以通过使用从`$app/navigation`导入的`invalidateAll`来实现这一点。如果`load()`函数使用了`fetch()`，那么使用`invalidate`模块是有意义的。在那个例子中，我们会通过将`fetch()`调用中指定的URL传递给`invalidate()`来强制重新加载。由于我们只是返回一个对象，我们需要使用`invalidateAll()`来触发重新加载：
- en: src/lib/Notify.svelte
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/Notify.svelte
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `Notify.svelte` component, we’ve added the import of `invalidateAll`.
    When the notification link badge is clicked, it calls `invalidateAll()`, informing
    SvelteKit to rerun all `load()` functions within the context. Now, when you click
    the notification link at the top of the page, you should see the browser console
    output **notifications loaded**. Navigating to other pages such as **About**,
    **News**, or **Home** will not produce the output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Notify.svelte`组件中，我们添加了对`invalidateAll`的导入。当点击通知链接徽章时，它会调用`invalidateAll()`，通知SvelteKit重新运行上下文中的所有`load()`函数。现在，当你点击页面顶部的通知链接时，你应该会在浏览器控制台看到输出**notifications
    loaded**。导航到其他页面，如**关于**、**新闻**或**主页**，则不会产生输出。
- en: In the future, should you find yourself building components that will be showing
    dynamic data across an application’s interface, consider the concepts we’ve just
    covered. By loading data in layout files, you can reduce the number of HTTP requests
    or database queries made, which can significantly improve the experience of the
    application for your users. And should you need to force that data to be reloaded,
    you’ll know how to go about invalidating data so SvelteKit will re-run the appropriate
    `load()` functions. Next, let’s take a look at how `load()` can be leveraged further
    to build more advanced functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果你发现自己正在构建将在应用程序界面中显示动态数据的组件，请考虑我们刚刚讨论的概念。通过在布局文件中加载数据，你可以减少HTTP请求或数据库查询的数量，这可以显著提高用户的应用程序体验。如果你需要强制重新加载数据，你将知道如何使数据无效，以便SvelteKit重新运行适当的`load()`函数。接下来，让我们看看如何进一步利用`load()`来构建更高级的功能。
- en: Destructuring RequestEvent
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构`RequestEvent`
- en: 'When it comes to `load()`, the server seems to have more information available
    to it than the client does. With so much data, it can be hard to know exactly
    all the information that is available. In short, server `load()` functions are
    called with a SvelteKit-specific `RequestEvent`. Here’s a quick breakdown of the
    properties (`prop`) and functions (`fn`) available from that object:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`load()`函数时，服务器似乎比客户端拥有更多信息。在如此多的数据中，很难确切知道所有可用的信息。简而言之，服务器的`load()`函数使用SvelteKit特定的`RequestEvent`进行调用。以下是该对象中可用的属性（`prop`）和函数（`fn`）的快速概述：
- en: '`cookies` (`prop`) – The cookies sent during the request.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies` (`prop`) – 请求期间发送的cookie。'
- en: '`fetch` (`fn`) – A compatible variant of the Web API `fetch()` function discussed
    in [*Chapter 3*](B19024_03_Final_AM.xhtml#_idTextAnchor051). It comes with the
    added benefit of allowing requests based on relative routes as well as passing
    cookies and headers through when on the same server.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch` (`fn`) – 在[*第3章*](B19024_03_Final_AM.xhtml#_idTextAnchor051)中讨论的Web
    API `fetch()`函数的兼容变体。它带来了额外的优势，允许基于相对路由进行请求，并在同一服务器上传递cookie和头部信息。'
- en: '`getClientAddress` (`fn`) – Returns the client’s IP address.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getClientAddress` (`fn`) – 返回客户端的IP地址。'
- en: '`locals` (`prop`) – Any custom data inserted into the request via SvelteKit’s
    `handle()` hook. We’ll cover that in a later chapter.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locals` (`prop`) – 通过SvelteKit的`handle()`钩子插入到请求中的任何自定义数据。我们将在后面的章节中介绍。'
- en: '`params` (`prop`) – Parameters specific to the current route, such as the article
    slug passed to the news example in the previous chapter.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params` (`prop`) – 当前路由特有的参数，例如上一章新闻示例中传递给文章的slug。'
- en: '`platform` (`prop`) – Data added by the environment adapter.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform` (`prop`) – 环境适配器添加的数据。'
- en: '`request` (`prop`) – The actual request data represented as an object.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request` (`prop`) – 实际请求数据，表示为一个对象。'
- en: '`route` (`prop`) – The identifier of the requested route.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route` (`prop`) – 请求路由的标识符。'
- en: '`setHeaders` (`fn`) – Allows for the manipulation of headers in the returned
    `Response` object.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setHeaders` (`fn`) – 允许在返回的`Response`对象中操作头部。'
- en: '`url` (`prop`) – Data about the requested URL, which we covered in [*Chapter
    3*](B19024_03_Final_AM.xhtml#_idTextAnchor051).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` (`prop`) – 关于请求URL的数据，我们在[*第3章*](B19024_03_Final_AM.xhtml#_idTextAnchor051)中讨论过。'
- en: RequestEvent demo
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请求事件演示
- en: To see this information for yourself, create the `src/routes/+layout.server.js`
    file with a `console.log()` function outputting a single passed-in argument to
    `load()`. By creating it in the root layout, you’ll be able to see how properties
    change based on the different routes accessed from your browser. The data will
    then be shown in your development console.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自查看这些信息，请创建一个包含`console.log()`函数的`src/routes/+layout.server.js`文件，该函数输出传递给`load()`的单个参数。通过在根布局中创建它，你将能够看到基于从浏览器访问的不同路由，属性是如何变化的。然后，数据将在你的开发控制台中显示。
- en: A practical example where you may find yourself needing to utilize this data
    is in the case of user authentication. Normally, after a user has authenticated,
    they are given a cookie (*for doing such a good job entering their password –
    pun intended*) to store on their device, which ensures their authentication will
    persist for the duration of their visit. If they leave the application, it can
    later be used to confirm their identity so they aren’t required to authenticate
    yet again. Let’s observe how this might be accomplished with SvelteKit. Since
    this chapter is about `load()`, we’ll build the actual form and discuss how to
    set the cookies in the next chapter. For now, we’ll simply check whether the user
    has a cookie set and set one manually in the browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个你可能需要利用这些数据的实际例子是在用户认证的情况下。通常，用户认证后，他们会被分配一个cookie（*因为他们输入密码做得很好 – 这是个双关语*）存储在他们的设备上，这确保了他们的认证将在访问期间持续有效。如果他们离开应用程序，它可以在以后用来确认他们的身份，这样他们就不需要再次进行认证。让我们观察一下SvelteKit是如何实现这一点的。由于本章是关于`load()`，我们将构建实际的表单并在下一章讨论如何设置cookie。现在，我们只需检查用户是否设置了cookie，并在浏览器中手动设置一个。
- en: 'To begin, let’s rename `src/routes/+layout.js` to `src/routes/+layout.server.js`.
    If we’re going to access cookie data, we’ll need access to the data provided by
    `RequestEvent`. By adding the logic to our root server layout, we have the added
    benefit of keeping the authentication checks in place across the entire application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将`src/routes/+layout.js`重命名为`src/routes/+layout.server.js`。如果我们打算访问cookie数据，我们需要访问`RequestEvent`提供的数据。通过将逻辑添加到我们的根服务器布局中，我们有一个额外的优势，即在整个应用程序中保持认证检查：
- en: src/routes/+layout.server.js
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/routes/+layout.server.js`'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this new version of the root layout logic, we’ve destructured the argument
    passed to `load()` since we currently only need access to the `cookies` property.
    We kept the `notifications` object we created earlier but put it inside a new
    variable called `data`. This text also omits a couple of entries for the sake
    of brevity. From there, we check whether the request sent to our application contained
    a cookie by the name of `user` with the value of `1`. If it did, we insert some
    fake user information into the `user` property of the `data` object. Normally
    at this point, we would check the cookie value against valid sessions in a database,
    and if one was found, we would then retrieve the appropriate user data and send
    that back to the client, but we’re trying to keep it simple. After all of that,
    the `data` object is returned from `load()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的根布局逻辑版本中，我们解构了传递给`load()`的参数，因为我们目前只需要访问`cookies`属性。我们保留了之前创建的`notifications`对象，但将其放入一个名为`data`的新变量中。为了简洁起见，这段文本省略了一些条目。从那里，我们检查发送到我们应用程序的请求是否包含一个名为`user`且值为`1`的cookie。如果是，我们将一些假用户信息插入到`data`对象的`user`属性中。通常在这种情况下，我们会将cookie值与数据库中的有效会话进行比对，如果找到，则检索相应的用户数据并将其发送回客户端，但我们正在尝试保持简单。完成所有这些后，`data`对象从`load()`返回。
- en: 'Next, we’ll need to actually show that the user has been successfully authenticated.
    To do this, we’ll create a new route where our user can log in:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实际展示用户已经成功认证。为此，我们将创建一个新的路由，让我们的用户可以登录：
- en: src/routes/login/+page.svelte
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/routes/login/+page.svelte`'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we covered in the last section, the data returned from `+layout.js` or `+layout.server.js`
    is made available in child components by exporting the `data` variable. Once that
    is done, we use the Svelte `{#if}` directive to check whether we have the `user`
    property set. If found, we then display the `name` property of `data.user`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中所述，从`+layout.js`或`+layout.server.js`返回的数据通过导出`data`变量在子组件中可用。一旦完成，我们使用Svelte的`{#if}`指令检查是否设置了`user`属性。如果找到，我们则显示`data.user`的`name`属性。
- en: 'Of course, nowhere in this example do we ever set a cookie. We’ll cover that
    in the next chapter so, for now, let’s manually create the cookie in our browser.
    Before doing so, navigate to the `/login` route and verify that nothing is shown
    on the page. Once you have confirmed it is a blank page, go ahead and create the
    cookie using the following steps for your browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，我们从未设置任何cookie。我们将在下一章中介绍这一点，所以现在，让我们手动在我们的浏览器中创建cookie。在这样做之前，导航到`/login`路由并验证页面上没有显示任何内容。一旦确认它是一个空白页面，请按照以下步骤为您的浏览器创建cookie：
- en: '`identity`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`。'
- en: Double-click the `1`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双击`1`。
- en: Ensure the `/` using the same steps.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的步骤确保`/`。
- en: '`identity`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`。'
- en: Select the `1`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择`1`。
- en: Ensure the `/` using the same steps.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的步骤确保`/`。
- en: Having followed these steps, you should now have the correct cookie in your
    browser. After doing so, refresh the `/login` page in your browser and you’ll
    see a message welcoming the user with the value from the `name` property specified.
    This example is quite simple and actual cookie-based login systems are functionally
    slightly more complicated; however, the concepts remain the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤操作后，你现在应该已经在浏览器中拥有了正确的cookie。完成此操作后，在浏览器中刷新`/login`页面，你会看到一个欢迎用户的消息，其中包含由`name`属性指定的值。这个例子相当简单，而实际的基于cookie的登录系统在功能上稍微复杂一些；然而，概念是相同的。
- en: While the example we covered only made use of the `cookies` property from `RequestEvent`,
    we saw how trivial it would be to access any of the other properties such as `url`
    and `params`, or even to set our own headers with the `setHeaders` function. With
    all of that data available to us, the possibilities of what could be built into
    our application are nearly limitless.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们覆盖的例子只使用了`RequestEvent`中的`cookies`属性，但我们看到了如何轻松地访问其他任何属性，例如`url`和`params`，或者甚至使用`setHeaders`函数设置我们自己的头部信息。有了所有这些数据可供我们使用，我们可以在应用程序中构建的内容的可能性几乎是无限的。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of information about `load()`. We first discussed
    how it can be done only in the client and then moved on to some finer details
    about how it works. After that, we looked at using `load()` in layouts to minimize
    the number of requests made for each page load and maximize convenient access
    to data that may be needed application-wide. We also looked at invalidating data
    in cases where we would want data to be reloaded. Finally, we covered how server
    `load()` functions are called by `RequestEvent`, which gives us access to so much
    more valuable information. That information can enable us to build cookie-based
    login functionality for our application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了关于`load()`的大量信息。我们首先讨论了它只能在客户端完成，然后转向一些关于其工作原理的更详细的内容。之后，我们探讨了在布局中使用`load()`以最小化每个页面加载时发出的请求数量，并最大化方便地访问可能需要应用范围内的数据。我们还探讨了在需要重新加载数据的情况下如何使数据失效。最后，我们介绍了服务器`load()`函数是如何通过`RequestEvent`调用的，这为我们提供了访问大量有价值信息的机会。这些信息可以让我们为我们的应用程序构建基于cookie的登录功能。
- en: Having spent this chapter learning about some of the finer details behind `load()`,
    you should feel comfortable taking a load off and relaxing. If you have any baked
    cookies to hand, I suggest you take a break from the book and treat yourself to
    some. You’ve earned it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于`load()`背后的一些更详细的细节，你应该感到轻松，可以休息一下。如果你手头有烤制的饼干，我建议你从书中休息一下，给自己一些奖励。你已经应得它了。
- en: But do come back because, in the next chapter, we’ll cover more of the finer
    details behind receiving data from users through the use of forms, making the
    forms fun, and reducing the friction of data entry by utilizing snapshots.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但请务必回来，因为在下一章中，我们将探讨更多关于通过使用表单从用户那里接收数据背后的细节，使表单变得有趣，并通过利用快照来减少数据输入的摩擦。
- en: Resources
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'devalue: [https://github.com/rich-harris/devalue](https://github.com/rich-harris/devalue)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'devalue: [https://github.com/rich-harris/devalue](https://github.com/rich-harris/devalue)'
