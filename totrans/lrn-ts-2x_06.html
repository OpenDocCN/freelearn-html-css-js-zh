<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the Runtime</h1>
                </header>
            
            <article>
                
<p>After reading this book, you will probably be eager to start a new project to put into practice everything that you have learned so far. At this point, you should be able to write a small web application using TypeScript and resolve the potential design-time issues that you might encounter.</p>
<p>However, as your new project grows, and you develop more complex features, you might encounter some runtime issues. This chapter should provide you with the missing knowledge that will help you to resolve runtime issues.</p>
<p>We have only briefly mentioned the TypeScript runtime in the preceding chapters, but depending on your background, you may already know a lot about it, because the TypeScript runtime is the JavaScript runtime.</p>
<p>TypeScript is only used at design time; the TypeScript code is then compiled into JavaScript and finally executed at runtime. The JavaScript runtime oversees the execution of the JavaScript code. It is important to understand that we will never execute TypeScript code and we will always execute JavaScript code; for this reason, when we refer to the TypeScript runtime, we will, in fact, be talking about the JavaScript runtime.</p>
<p>When we compile our TypeScript code, we will generate JavaScript code, which will be executed on the server side or the client side. It is then that we may encounter some challenging runtime issues.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The execution environment</li>
<li>The event loop</li>
<li>The <kbd>this</kbd> operator</li>
<li>Prototypes</li>
<li>Closures</li>
</ul>
<p>Let's start by learning about the execution environment.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The execution environment</h1>
                </header>
            
            <article>
                
<p>The execution environment is one of the first things that we must think about before we can start developing a TypeScript application. Once we have compiled our TypeScript code into JavaScript, it can be executed in many different environments. While most of those environments will be part of a web browser such as Chrome, Internet Explorer, or Firefox, we might also want to be able to run our code on the server side or in a desktop application in environments such as Node.js, RingoJS, or Electron.</p>
<p>It is important to keep in mind that there are some variables and objects available at runtime that are environment-specific. For example, we could create a library and access the <kbd>document.layers</kbd> variable. While <kbd>document</kbd> is part of the W3C <strong>Document Object Model</strong> (<strong>DOM</strong>) standard, the layers property is only available in Internet Explorer and is not part of the W3C DOM standard.</p>
<p>The W3C defines the DOM as follows:</p>
<div class="mce-root packt_quote">"The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure, and style of documents. The document can be further processed, and the results of that processing can be incorporated back into the presented page".</div>
<p>Similarly, we can also access a set of objects known as the <strong>Browser Object Model</strong> (<strong>BOM</strong>) from a web browser runtime environment. The BOM consists of the objects <kbd>navigator</kbd>, <kbd>history</kbd>, <kbd>screen</kbd>, <kbd>location</kbd>, and <kbd>document</kbd>, which are properties of the <kbd>window</kbd> object.</p>
<p>We need to keep in mind that the DOM is only available in web browsers. If we want to run our application in a web browser, we will be able to access the DOM and BOM. However, in environments such as Node.js or RingoJS, these APIs will not be available since they are standalone JavaScript environments completely independent of a web browser. We can also find other objects in the server-side environments (such as <kbd>process.stdin</kbd> in Node.js) that will not be available if we attempt to execute our code in a web browser.</p>
<p>We also need to keep in mind the existence of multiple versions of these JavaScript environments. In some cases, we will have to support multiple browsers and multiple versions of Node.js. The recommended practice when dealing with this problem is to add conditional statements that check for the availability of features rather than the availability of an environment or version.</p>
<div class="packt_infobox">A really good library is available that can help us to implement feature detection when developing for web browsers. The library is called <strong>Modernizr</strong> and can be downloaded at <a href="http://modernizr.com/"><span class="URLPACKT">http://modernizr.com/</span></a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the event loop</h1>
                </header>
            
            <article>
                
<p>The TypeScript runtime (JavaScript) has a concurrency model based on an <strong>event loop</strong>. This model is quite different from the model in other languages, such as C or Java. Before we focus on the event loop itself, we must understand some runtime concepts.</p>
<p>What follows is a visual representation of some important runtime concepts: heap, stack, queue, and frame:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-129 image-border" src="Images/9abf1c82-6d70-49f1-8ff4-3bf634ab7389.png" style="width:25.42em;height:25.42em;" width="528" height="528"/></div>
<p>We will now look at the role of each of these concepts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Frames</h1>
                </header>
            
            <article>
                
<p>A frame is a sequential unit of work. In the preceding diagram, the frames are represented by the blocks inside the stack.</p>
<p>When a function is invoked in JavaScript, the runtime creates a frame in the stack. The frame holds that function's arguments and local variables. When the function returns, the frame is removed from the stack. Let's look at an example:</p>
<pre>function foo(a: number): number { 
    const value = 12; 
    return value + a; 
} 
 
function bar(b: number): number { 
    const value = 4; 
    return foo(value * b); 
} </pre>
<p>After declaring the <kbd>foo</kbd> and <kbd>bar</kbd> functions, we will invoke the <kbd>bar</kbd> function:</p>
<pre>bar(21); </pre>
<p>When <kbd>bar</kbd> is executed, the runtime will create a new frame containing the arguments of <kbd>bar</kbd> and all its local variables (value). The frame (represented as blocks inside the stack) is then added to the top of the stack.</p>
<p>Internally, <kbd>bar</kbd> invokes <kbd>foo</kbd>. When <kbd>foo</kbd> is invoked, a new frame is created and allocated to the top of the stack. When the execution of <kbd>foo</kbd> is finished (<kbd>foo</kbd> has returned), the top frame is removed from the stack. When the execution of <kbd>bar</kbd> is also completed, it is removed from the stack as well.</p>
<p>Now, let's try to imagine what would happen if the <kbd>foo</kbd> function invoked the <kbd>bar</kbd> function:</p>
<pre>function foo(a: number): number { 
    const value = 12; 
    return bar(value + a); 
} 
 
function bar(b: number): number { 
    const value = 4; 
    return foo(value * b); 
} </pre>
<p>We would create a never-ending function call loop. With each function call, a new frame would be added to the stack, and eventually there would be no more space in the stack, and an error would be thrown. Most software engineers are familiar with this error, known as a <em>stack overflow</em> error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stack</h1>
                </header>
            
            <article>
                
<p>The stack contains sequential steps (frames). A stack is a data structure that represents a simple <strong>last-in-first-out</strong> (<strong>LIFO</strong>) collection of objects. Therefore, when a frame is added to the stack, it is always added to the top of the stack.</p>
<p>Since the stack is a LIFO collection, the event loop processes the frames stored in it from top to bottom. The dependencies of a frame are added to the top of it in the stack to ensure that all the dependencies of each of the frames are met.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Queue</h1>
                </header>
            
            <article>
                
<p>The queue contains a list of messages waiting to be processed. Each message is associated with a function. When the stack is empty, a message is taken out of the queue and processed. The processing consists of calling the associated function and adding the frames to the stack. The message processing ends when the stack becomes empty again.</p>
<p>In the previous runtime diagram, the blocks inside the queue represent the messages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Heap</h1>
                </header>
            
            <article>
                
<p>The heap is a memory container that is not aware of the order of the items stored in it. The heap contains all the variables and objects currently in use. It may also contain frames that are currently out of scope but have not yet been removed from memory by the garbage collector.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The event loop</h1>
                </header>
            
            <article>
                
<p>Concurrency is the ability for two or more operations to be executed simultaneously. The runtime execution takes place on one single thread, which means that we cannot achieve real concurrency.</p>
<p>The event loop follows a run-to-completion approach, which means that it will process a message from beginning to end before any other message is processed.</p>
<p>Every time a function is invoked, a new message is added to the queue. If the stack is empty, the function is processed (the frames are added to the stack).</p>
<p>When all the frames have been added to the stack, the stack is cleared from top to bottom. At the end of the process, the stack is empty, and the next message is processed.</p>
<div class="packt_infobox">Web workers can perform background tasks in a different thread. They use a separated queue, heap, and stack.</div>
<p>One of the advantages of the <kbd>event loop</kbd> is that the execution order is quite predictable and easy to follow. Another important advantage of the <kbd>event loop</kbd> approach is that it features non-blocking I/O. This means that when the application is waiting for an input and output (I/O) operation to finish, it can still process other things, such as user input.</p>
<p>A disadvantage of this approach is that, if a message (function) takes too long to complete, the application becomes unresponsive. A good practice to follow is to make message processing short and, if possible, split one message into several messages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The this operator</h1>
                </header>
            
            <article>
                
<p>In JavaScript, the <kbd>this</kbd> operator behaves a little differently compared to other languages. The value of the <kbd>this</kbd> operator is often determined by the way a function is invoked. Its value cannot be set by assignment during execution, and it may be different each time a function is invoked.</p>
<div class="packt_infobox">The <kbd>this</kbd> operator also has some differences when using the strict mode and non-strict mode. To learn more about the strict mode, refer to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"><span class="URLPACKT">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode</span></a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The this operator in the global context</h1>
                </header>
            
            <article>
                
<p>In the global context, the <kbd>this</kbd> operator will always point to the global object. In a web browser, the <kbd>window</kbd> object is the global object:</p>
<pre>console.log(this === window); // true 
this.a = 37; 
console.log(window.a); // 37 
console.log(window.document === this.document); // true 
console.log(this.document === document); // true 
console.log(window.document === document); // true </pre>
<div class="packt_infobox">The preceding example is a JavaScript example, not a TypeScript example.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The this operator in a function context</h1>
                </header>
            
            <article>
                
<p>The value of <kbd>this</kbd> inside a function depends on how the function is invoked. If we simply invoke a function in non-strict mode, the value of <kbd>this</kbd> within the function will point to the global object as follows:</p>
<pre>function f1() { 
  return this; 
} 
f1() === window; // true </pre>
<div class="packt_infobox">All examples in this sub section (that is, the <kbd>this</kbd> operator in a function context) are JavaScript examples, not TypeScript examples.</div>
<p>However, if we invoke a function in strict mode, the value of <kbd>this</kbd> within the function's body will point to <kbd>undefined</kbd> as follows:</p>
<pre>console.log(this); // global (window) 
 
function f2() { 
  "use strict"; 
  return this; // undefined 
} 
 
console.log(f2()); // undefined 
console.log(this); // window </pre>
<div class="packt_infobox"><span>ECMAScript 5's strict mode is a way to opt in to a restricted variant of JavaScript. You can learn more about the strict mode at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode</a>.</span></div>
<p>However, the value of the <kbd>this</kbd> operator inside a function invoked as an instance method points to the instance. In other words, the value of the <kbd>this</kbd> operator within a function that is part of a class points to that class:</p>
<pre>const person = { 
  age: 37, 
  getAge: function() { 
    return this.age; // this points to the instance (person) 
  } 
}; 
console.log(person.getAge()); // 37 </pre>
<p>In the preceding example, we have used object literal notation to define an object named <kbd>p</kbd>, but the same applies when declaring objects using prototypes:</p>
<pre>function Person() {} 
Person.prototype.age = 37; 
Person .prototype.getAge = function () { 
  return this.age; 
} 
const person = new Person(); 
person.age;    // 37 
person.getAge(); // 37 </pre>
<p>When a function is used as a constructor (with the <kbd>new</kbd> keyword), the <kbd>this</kbd> operator points to the object being constructed:</p>
<pre>function Person() { // function used as a constructor 
  this.age = 37; 
} 
const person = new Person(); 
console.log(person.age); // logs 37 </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The call, apply, and bind methods</h1>
                </header>
            
            <article>
                
<p>All functions inherit the <kbd>call</kbd>, <kbd>apply</kbd>, and <kbd>bind</kbd> methods from <kbd>Function.prototype</kbd>. We can use these methods to set the value of <kbd>this</kbd>.</p>
<p>The <kbd>call</kbd> and <kbd>apply</kbd> methods are almost identical; both methods allow us to invoke a function and set the value of the <kbd>this</kbd> operator within the function. The main difference between <kbd>call</kbd> and <kbd>apply</kbd> is that, while <kbd>apply</kbd> lets us invoke the function with arguments as an array, <kbd>call</kbd> requires the function parameters to be listed explicitly.</p>
<div class="packt_tip">A useful mnemonic is <em>A (</em><kbd>apply</kbd><em>) for an array and C (</em><kbd>call</kbd><em>) for a comma</em>.</div>
<p>Let's look at an example. We will start by declaring a class named <kbd>Person</kbd>. This class has two properties (<kbd>name</kbd> and <kbd>surname</kbd>) and one method (<kbd>greet</kbd>). The <kbd>greet</kbd> method uses the <kbd>this</kbd> operator to access the <kbd>name</kbd> and <kbd>surname</kbd> instance properties:</p>
<pre>class Person { 
 
  public name: string; 
  public surname: string; 
   
  public constructor(name: string, surname: string) { 
    this.name = name; 
    this.surname = surname; 
  } 
 
  public greet(city: string, country: string) { 
    // we use the "this" operator to access name and surname  
    let msg = `Hi, my name is ${this.name} ${this.surname}.`; 
    msg += `I'm from ${city} (${country}).`; 
    console.log(msg); 
  } 
 
} </pre>
<p>After declaring the <kbd>Person</kbd> class, we will create an instance:</p>
<pre>const person = new Person("remo", "Jansen"); </pre>
<p>If we invoke the <kbd>greet</kbd> method, it will work as expected:</p>
<pre>person.greet("Seville", "Spain"); </pre>
<p>Alternatively, we can invoke the method using the <kbd>call</kbd> and <kbd>apply</kbd> functions. We have supplied the <kbd>person</kbd> object as the first parameter of both functions because we want the <kbd>this</kbd> operator (inside the <kbd>greet</kbd> method) to take person as its value:</p>
<pre>person.greet.call(person, "Seville", "Spain"); 
person.greet.apply(person, ["Seville", "Spain"]); </pre>
<p>If we provide a different value to be used as the value of <kbd>this</kbd>, we will not be able to access the <kbd>name</kbd> and <kbd>surname</kbd> properties within the <kbd>greet</kbd> function:</p>
<pre><a>person.greet.call(null, "Seville", "Spain");</a> 
person.greet.apply(null, ["Seville", "Spain"]); </pre>
<p>The two preceding examples may seem useless, because the first one invoked the function directly and the second one caused unexpected behavior. The <kbd>apply</kbd> and <kbd>call</kbd> methods make sense only when we want the <kbd>this</kbd> operator to take a different value when a function is invoked:</p>
<pre><a>const valueOfThis = { name : "Anakin", surname : "Skywalker" };</a> 
person.greet.call(valueOfThis, "Mos espa", "Tatooine"); 
person.greet.apply(valueOfThis, ["Mos espa", "Tatooine"]); </pre>
<p>The <kbd>bind</kbd> method can be used to set the value of the <kbd>this</kbd> operator (within a function), regardless of how it is invoked.</p>
<p>When we invoke a function's <kbd>bind</kbd> method, it returns a new function with the same body and scope as the original function, but the <kbd>this</kbd> operator (within the body function) is permanently bound to the first argument of <kbd>bind</kbd>, regardless of how the function is being used.</p>
<p>Let's look at an example. We will start by creating an instance of the <kbd>Person</kbd> class that we declared in the previous example:</p>
<pre>const person = new Person("Remo", "Jansen"); </pre>
<p>Then, we can use bind to set the <kbd>greet</kbd> function to be a new function with the same scope and body:</p>
<pre>const greet = person.greet.bind(person); </pre>
<p>If we try to invoke the <kbd>greet</kbd> function using <kbd>bind</kbd> and <kbd>apply</kbd>, just like we did in the previous example, we will be able to observe that, this time, the <kbd>this</kbd> operator will always point to the object instance  regardless of how the function is invoked:</p>
<pre><a>greet.call(person, "Seville", "Spain");</a> 
greet.apply(person, ["Seville", "Spain"]); 
// Hi, my name is Remo Jansen. I'm from Seville Spain. 
 
greet.call(null, "Seville", "Spain"); 
greet.apply(null, ["Seville", "Spain"]); 
// Hi, my name is Remo Jansen. I'm from Seville Spain. 
 
const valueOfThis = { name: "Anakin", surname: "Skywalker" }; 
greet.call(valueOfThis, "Mos espa", "Tatooine"); 
greet.apply(valueOfThis, ["Mos espa", "Tatooine"]); 
// Hi, my name is Remo Jansen. I'm from Mos espa Tatooine. </pre>
<p>Once we bind an object to a function with <kbd>bind</kbd>, we cannot override it:</p>
<pre>const valueOfThis = { name: "Anakin", surname: "Skywalker" }; 
const greet = person.greet.bind(valueOfThis); 
greet.call(valueOfThis, "Mos espa", "Tatooine"); 
greet.apply(valueOfThis, ["Mos espa", "Tatooine"]); 
// Hi, my name is Remo Jansen. I'm from Mos espa Tatooine. </pre>
<div class="packt_infobox">Using the <kbd>bind</kbd>, <kbd>apply</kbd>, and <kbd>call</kbd> methods is often discouraged because it can lead to confusion. Modifying the default behavior of the <kbd>this</kbd> operator can lead to unexpected results. Remember to use these methods only when strictly necessary and to document your code properly to reduce the risk caused by potential maintainability issues.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prototypes</h1>
                </header>
            
            <article>
                
<p>When we compile a TypeScript program, all classes and objects become JavaScript objects. However, sometimes we may encounter an unexpected behavior at runtime, even if the compilation was completed without errors. To be able to identify and understand the cause of this behavior, we need a good understanding of the JavaScript runtime. One of the main concepts that we need to understand is how inheritance works at runtime.</p>
<p>The runtime inheritance system uses a prototypal inheritance model. In a prototypal inheritance model, objects inherit from objects, and there are no classes available. However, we can use prototypes to simulate classes. Let's see how it works.</p>
<p>At runtime, every JavaScript object has an internal property called prototype. The value of the prototype attribute is an object, which contains some attributes (data) and methods (behavior).</p>
<p>In TypeScript, we can use a class-based inheritance system:</p>
<pre>class Person { 
 
    public name: string; 
    public surname: string; 
    public age: number = 0; 
 
    public constructor(name: string, surname: string) { 
        this.name = name; 
        this.surname = surname; 
    } 
 
    public greet() { 
        let msg = `Hi! my name is ${this.name} ${this.surname}`; 
        msg += `I'm ${this.age}`; 
    } 
 
} </pre>
<p>We have defined a class named <kbd>Person</kbd>. At runtime, this class is declared using prototypes instead of classes:</p>
<pre>var Person = (function() { 
    function Person(name, surname) { 
        this.age = 0; 
        this.name = name; 
        this.surname = surname; 
    } 
    Person.prototype.greet = function() { 
        let msg = "Hi! my name is " + this.name + 
                    " " + this.surname; 
        msg += "I'm " + this.age; 
    }; 
    return Person; 
})(); </pre>
<p>The preceding code is emitted by TypeScript when we target ES5. The <kbd>class</kbd> keyword is supported by ES6 at runtime, but it is syntactic sugar. In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. This means that the <kbd>class</kbd> keyword is just a helper to make our lives as software engineers easier and, internally, prototypes are always used.</p>
<p>The TypeScript compiler wraps the object definition (we will not refer to it as a class definition because, technically, it is not a class) with an <strong>immediately invoked function expression</strong> (<strong>IIFE</strong>). Inside the IIFE, we can find a function named <kbd>Person</kbd>. If we examine the function and compare it with the TypeScript class, we will notice that it takes the same parameters that the class constructor takes in the TypeScript class. This function is used to create new instances of the <kbd>Person</kbd> class.</p>
<p>After the constructor, we can see the definition of the <kbd>greet</kbd> method. As we can see, the <kbd>prototype</kbd> attribute is used to attach the <kbd>greet</kbd> method to the <kbd>Person</kbd> class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Instance properties versus class properties</h1>
                </header>
            
            <article>
                
<p>Because JavaScript is a dynamic programming language, we can add properties and methods to an instance of an object at runtime, and they don't need to be part of the object (class) itself. Let's look at an example:</p>
<pre>function Person(name, surname) { 
      // instance properties 
      this.name = name; 
      this.surname = surname; 
} 
const person = new Person("Remo", "Jansen"); 
person.age = 27; </pre>
<p>We have defined a constructor function for an object named <kbd>person</kbd>, which takes two variables (<kbd>name</kbd> and <kbd>surname</kbd>) as arguments. Then, we have created an instance of the <kbd>Person</kbd> object and added a new property named <kbd>age</kbd> to it. We can use a <kbd>for...in</kbd> statement to check the properties of <kbd>person</kbd> at runtime:</p>
<pre>for(let property in person) { 
  console.log("property: " + property + ", value: '" + <br/>   person[property] + "'"); 
} 
// property: name, value: 'remo' 
// property: surname, value: 'jansen' 
// property: age, value: 27 
// property: greet, value: 'function (city, country) { 
//        let msg = "Hi, my name is " + this.name + " " + <br/> //this.surname; 
//        msg += "nI'm from " + city + " " + country; 
//        console.log(msg); 
//    }' </pre>
<p>All these properties are <strong>instance properties</strong> because they hold a value for each new instance. If, for example, we create a new instance of <kbd>Person</kbd>, both instances will hold their own values:</p>
<pre>let person2 = new Person("John", "Wick"); 
person2.name; // "John"  
person1.name; // "Remo" </pre>
<p>We have defined these instance properties using the <kbd>this</kbd> operator, because when a function is used as a constructor (with the <kbd>new</kbd> keyword), the <kbd>this</kbd> operator is bound to the new object being constructed.</p>
<p>This also explains why we can alternatively define instance properties through the object's prototype:</p>
<pre>Person.prototype.name = name;    // instance property  
Person.prototype.name = surname; // instance property </pre>
<p>We can also declare class-level properties and methods (also known as static properties). The main difference is that the values of class properties and methods are shared between all instances of an object.</p>
<p>Class properties are often used to store static values:</p>
<pre>function MathHelper() {  
  /* ... */  
} 
 
// class property 
MathHelper.PI = 3.14159265359; </pre>
<p>Class methods are also often used as utility functions that perform calculations upon supplied parameters and return a result:</p>
<pre>function MathHelper() { /* ... */ } 
 
// class property 
MathHelper.PI = 3.14159265359; 
 
// class method 
MathHelper.areaOfCircle = function(radius) { 
  return radius * radius * MathHelper.PI;  
} </pre>
<p>In the preceding example, we have accessed a class attribute (<kbd>PI</kbd>) from a class method (<kbd>areaOfCircle</kbd>). We can access class properties from instance methods, but we cannot access instance properties or methods from class properties or methods. We can demonstrate this by declaring <kbd>PI</kbd> as an instance property instead of a class property:</p>
<pre>function MathHelper() { 
  // instance property 
  this.PI = 3.14159265359; 
} </pre>
<p>If we then attempt to access <kbd>PI</kbd> from a class method, it will be undefined:</p>
<pre>// class method 
MathHelper.areaOfCircle = function(radius) { 
  return radius * radius * this.PI;  // this.PI is undefined 
} 
 
MathHelper.areaOfCircle(5); // NaN </pre>
<p>We are not supposed to access class methods or properties from instance methods, but there is a way to do it. We can achieve it by using the prototype's constructor property as demonstrated in the following example:</p>
<pre><a>function MathHelper () { /* ... */ }</a> 
 
// class property  
MathHelper.PI = 3.14159265359; 
 
// instance method  
MathHelper.prototype.areaOfCircle = function(radius) {  
    return radius * radius * this.constructor.PI;  
} 
 
const math = new MathHelper ();  
<a>console.log(MathHelper.areaOfCircle(5)); </a>// 78.53981633975 </pre>
<p>We can access the <kbd>PI</kbd> class property from the <kbd>areaOfCircle</kbd> instance method using the prototype's constructor property, because this property returns a reference to the object's constructor.</p>
<p>Inside <kbd>areaOfCircle</kbd>, the <kbd>this</kbd> operator returns a reference to the object's prototype:</p>
<pre>this === MathHelper.prototype </pre>
<p>The value of <kbd>this.constructor</kbd> is equal to <kbd>MathHelper.prototype.constructor</kbd> and, therefore, <kbd>MathHelper.prototype.constructor</kbd> is equal to <kbd>MathHelper</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Prototypal inheritance</h1>
                </header>
            
            <article>
                
<p>We might be wondering how the <kbd>extends</kbd> keyword works. Let's create a new TypeScript class, which inherits from the <kbd>Person</kbd> class, to understand it:</p>
<pre>class SuperHero extends Person { 
    public superpower: string; 
    public constructor( 
        name: string, 
        surname: string, 
        superpower: string 
    ) { 
        super(name, surname); 
        this.superpower = superpower; 
    } 
    public userSuperPower() { 
        return `I'm using my ${this.superpower}`; 
    } <br/>}</pre>
<p>The preceding class is named <kbd>SuperHero</kbd> and extends the <kbd>Person</kbd> class. It has one extra attribute (<kbd>superpower</kbd>) and method (<kbd>useSuperPower</kbd>). If we compile the code, we will notice the following piece of code:</p>
<pre>var __extends = this.__extends || function (d, b) { 
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; 
    function __() { this.constructor = d; } 
    __.prototype = b.prototype; 
    d.prototype = new __(); 
}; </pre>
<div class="packt_infobox">Please note that the preceding code snippet is slightly more complicated in TypeScript 2.8. We will use the code from the previous versions here because it contains fewer conditions and is easier to understand.</div>
<p>This piece of code is generated by TypeScript. Even though it is a small piece of code, it showcases almost every concept contained in this chapter, and understanding it can be quite challenging.</p>
<p>Before the function expression is evaluated for the first time, the <kbd>this</kbd> operator points to the global object, which does not contain a method named <kbd>__extends</kbd>. This means that the <kbd>__extends</kbd> variable is undefined.</p>
<p>When the function expression is evaluated for the first time, the value of the function expression (an anonymous function) is assigned to the <kbd>__extends</kbd> property in the global scope.</p>
<p>TypeScript generates the function expression one time for each TypeScript file containing the <kbd>extends</kbd> keyword. However, the function expression is only evaluated once (when the <kbd>__extends</kbd> variable is undefined). This behavior is implemented by the conditional statement in the first line:</p>
<pre>var __extends = this.__extends || function (d, b) { // ... </pre>
<p>The first time this line of code is executed, the function expression is evaluated. The value of the function expression is an anonymous function, which is assigned to the <kbd>__extends</kbd> variable in the global scope. Because we are in the global scope, <kbd>var __extends</kbd> and <kbd>this. __extends</kbd> refer to the same variable at this point.</p>
<p>When a new file is executed, the <kbd>__extends</kbd> variable is already available in the global scope, and the function expression is not evaluated. This means that the value of the function expression is only assigned to the <kbd>__extends</kbd> variable once, even if the snippet is executed multiple times.</p>
<p>Let's focus now on the <kbd>__extends</kbd> variable (the anonymous function):</p>
<pre>function (d, b) { 
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; 
    function __() { this.constructor = d; } 
    __.prototype = b.prototype; 
    d.prototype = new __(); 
} </pre>
<p>This function takes two arguments, named <kbd>d</kbd> and <kbd>b</kbd>. When we invoke it, we should pass a derived object constructor (<kbd>d</kbd>) and a base object constructor (<kbd>b</kbd>).</p>
<p>The first line inside the anonymous function iterates each class property and method from the base class and creates their copy in the derived class:</p>
<pre>for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; </pre>
<div class="packt_infobox">When we use a <kbd>for...in</kbd> statement to iterate an instance of an object to <kbd>a</kbd>, it will iterate the object's instance properties. However, if we use a <kbd>for...in</kbd> statement to iterate the properties of an object's constructor, the statement will iterate its class properties. In the preceding example, the <kbd>for...in</kbd> statement is used to inherit the object's class properties and methods. To inherit the instance properties, we will copy the object's prototype.</div>
<p>The second line declares a new constructor function named <kbd>__</kbd>, and inside it, the <kbd>this</kbd> operator is used to access its prototype:</p>
<pre>function __() { this.constructor = d; } </pre>
<p>The prototype contains a special property named <kbd>constructor</kbd>, which returns a reference to the object's constructor. The function named <kbd>__</kbd> and <kbd>this.constructor</kbd> are pointing to the same variable at this point. The value of the derived object constructor (<kbd>d</kbd>) is then assigned to the <kbd>__</kbd> constructor.</p>
<p>In the third line, the value of the prototype object from the base object constructor is assigned to the prototype of the <kbd>__</kbd> object constructor:</p>
<pre>__.prototype = b.prototype; </pre>
<p>In the last line, <kbd>new __()</kbd> is invoked, and the result is assigned to the derived class (<kbd>d</kbd>) prototype. By performing all these steps, we can invoke the following:</p>
<pre>var instance = new d(): </pre>
<p>Upon doing so, we will get an object that contains all the properties from both the derived class (<kbd>d</kbd>) and the base class (<kbd>b</kbd>). Furthermore, any instance objects constructed by the derived constructor (<kbd>d</kbd>) will be instances of the derived class while inheriting both the class and instance properties and methods from the base class (<kbd>b</kbd>).</p>
<p>We can see the function in action by examining the runtime code that defines the <kbd>SuperHero</kbd> class:</p>
<pre>var SuperHero = (function (_super) { 
    __extends(SuperHero, _super); 
    function SuperHero(name, surname, superpower) { 
        _super.call(this, name, surname); 
        this.superpower = superpower;  
    } 
    SuperHero.prototype.userSuperPower = function () { 
        return "I'm using my " + superpower; 
    }; 
    return SuperHero; 
})(Person); </pre>
<p>We can see an IIFE here again. This time, the IIFE takes the <kbd>Person</kbd> object constructor as the argument. Inside the function, we will refer to this argument using the name <kbd>_super</kbd>. Inside the IIFE, the <kbd>__extends</kbd> function is invoked and the <kbd>SuperHero</kbd> (derived class) and <kbd>_super</kbd> (base class) arguments are passed to it.</p>
<p>In the next line, we can find the declaration of the <kbd>SuperHero</kbd> object constructor and the <kbd>useSuperPower</kbd> function. We can use <kbd>SuperHero</kbd> as an argument of <kbd>__extend</kbd> before it is declared because function declarations are hoisted to the top of the scope.</p>
<div class="packt_infobox">Function expressions are not hoisted. When we assign a function to a variable in a function expression, the variable is hoisted, but its value (the function itself) is not hoisted.</div>
<p>Inside the <kbd>SuperHero</kbd> constructor, the base class (<kbd>Person</kbd>) constructor is invoked using the <kbd>call</kbd> method:</p>
<pre>_super.call(this, name, surname); </pre>
<p>As we discovered previously in this chapter, we can use <kbd>call</kbd> to set the value of the <kbd>this</kbd> operator in a function context. In this case, we are passing the <kbd>this</kbd> operator, which points to the instance of <kbd>SuperHero</kbd> being created:</p>
<pre>function Person(name, surname) { 
      // this points to the instance of SuperHero being created 
      this.name = name; 
      this.surname = surname; 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The prototype chain and property shadowing</h1>
                </header>
            
            <article>
                
<p>When we try to access a property or a method of an object, the runtime will search for that property or method in the object's properties and methods. If it is not found, the runtime will continue searching through the object's inherited properties by navigating the entire inheritance tree. Because a derived object is linked to its base object through the <kbd>prototype</kbd> property, we refer to this inheritance tree as <strong>the prototype chain</strong>.</p>
<p>Let's look at an example. We will declare two simple TypeScript classes named <kbd>Base</kbd> and <kbd>Derived</kbd>:</p>
<pre><a>class Base {</a> 
    public method1() { return 1; } 
    public method2() { return 2; } 
} 
 
class Derived extends Base { 
    public method2() { return 3; } 
    public method3() { return 4; } 
} </pre>
<p>Now we will examine the JavaScript code generated by TypeScript:</p>
<pre>var Base = (function () { 
    function Base() { 
    } 
    Base.prototype.method1 = function () { return 1; }; 
    Base.prototype.method2 = function () { return 2; }; 
    return Base; 
})(); 
var Derived = (function (_super) { 
    __extends(Derived, _super); 
    function Derived() { 
        _super.apply(this, arguments); 
    } 
    Derived.prototype.method2 = function () { return 3; }; 
    Derived.prototype.method3 = function () { return 4; }; 
    return Derived; 
})(Base); </pre>
<p>We can then create an instance of the <kbd>Derived</kbd> class:</p>
<pre>var derived = new Derived(); </pre>
<p>If we try to access the method named <kbd>method1</kbd>, the runtime will find it in the instance's properties:</p>
<pre>console.log(derived.method1); // 1 </pre>
<p>The instance also has an own property named <kbd>method2</kbd> (with value 2), but there is also an inherited property named <kbd>method2</kbd> (with value 3). The object's property (<kbd>method2</kbd> with value 3) prevents the access to the <kbd>prototype</kbd> property (<kbd>method2</kbd> with value 2). This is known as <strong>property shadowing</strong>:</p>
<pre>console.log(derived.method2); // 3 </pre>
<p>The instance does not have an own property named <kbd>method3</kbd>, but it has a property named <kbd>method3</kbd> in its prototype:</p>
<pre>console.log(derived.method3); // 4 </pre>
<p>Neither the instance nor the objects in the prototype chain (the <kbd>Base</kbd> class) have a property named <kbd>method4</kbd>:</p>
<pre>console.log(derived.method4); // error </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing the prototype of an object</h1>
                </header>
            
            <article>
                
<p>Prototypes can be accessed in three different ways:</p>
<ul>
<li><kbd>Person.prototype</kbd></li>
<li><kbd>Object.getPrototypeOf(person)</kbd></li>
<li><kbd>person.__proto__</kbd></li>
</ul>
<div class="packt_infobox">The use of <kbd>__proto__</kbd> is controversial and has been discouraged by many experienced software engineers. It was never originally included in the ECMAScript language specification, but modern browsers decided to implement it anyway. Today, the <kbd>__proto__</kbd> property has been standardized in the ECMAScript 6 language specification and will be supported in the future, but it is still a slow operation that should be avoided if performance is a concern.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The new operator</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>new</kbd> operator to generate an instance of <kbd>Person</kbd>:</p>
<pre>const person = new Person("remote", "Jansen"); </pre>
<p>When we use the new operator, the runtime creates a new object that inherits from the <kbd>Person</kbd> class prototype.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Closures</h1>
                </header>
            
            <article>
                
<p>Closures are one of the most powerful features available at runtime, but they are also one of the most misunderstood. The Mozilla developer network defines closures as follows:</p>
<div class="packt_quote">"Closures are functions that refer to independent (free) variables. In other words, the function defined in the closure 'remembers' the environment in which it was created".</div>
<p>We understand independent (free) variables as variables that persist beyond the lexical scope from which they were created. Let's look at an example:</p>
<pre><a>function makeArmy() {</a> 
    const shooters = []; 
    for (let i = 0; i &lt; 10; i++) { 
        const shooter = () =&gt; { // a shooter is a function 
            console.log(i); // which should display it's number 
        }; 
        shooters.push(shooter); 
    } 
    return shooters; 
} </pre>
<div class="packt_infobox">The preceding example is a JavaScript example, not a TypeScript example.</div>
<p>We have declared a function named <kbd>makeArmy</kbd>. Inside the function, we have created an array of functions named <kbd>shooters</kbd>. Each function in the <kbd>shooters</kbd> array will display a number, the value of which was set from the variable <kbd>i</kbd> inside a <kbd>for</kbd> statement. We will now invoke the <kbd>makeArmy</kbd> function:</p>
<pre><a>const army = makeArmy();</a>  </pre>
<p>The variable <kbd>army</kbd> should now contain the array of the function's <kbd>shooters</kbd>. However, we will notice a problem if we execute the following piece of code:</p>
<pre><a>army[0](); // 10 (expected 0)</a> 
army[5](); // 10 (expected 5) </pre>
<p>The preceding code snippet does not work as expected because we made one of the most common mistakes related to closures. When we declared the <kbd>shooter</kbd> function inside the <kbd>makeArmy</kbd> function, we created a closure without being aware of it.</p>
<p>The reason for this is that the functions assigned to <kbd>shooter</kbd> are closures; they consist of the function definition and the captured environment from the <kbd>makeArmy</kbd> function's scope. We have created ten closures, but all of them the same environment. By the time the <kbd>shooter</kbd> functions are executed, the loop has run its course, and the <kbd>i</kbd> variable (shared by all the closures) has been left pointing to the last entry (<kbd>10</kbd>).</p>
<p>One solution, in this case, is to use more closures:</p>
<pre><a>function makeArmy() {</a> 
    const shooters = []; 
    for (let i = 0; i &lt; 10; i++) { 
        ((index: number) =&gt; { 
            const shooter = () =&gt; { 
                console.log(index); 
            }; 
            shooters.push(shooter); 
        })(i); 
    } 
    return shooters; 
} 
 
const army = makeArmy(); 
army[0](); // 0 
army[5](); // 5 </pre>
<div class="packt_infobox">The preceding example is a TypeScript example, not a JavaScript example.</div>
<p>This works as expected. Rather than the shooter functions sharing a single environment, the immediately invoked function creates a new environment for each one in which <kbd>i</kbd> refers to the corresponding value.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static variables powered by closures</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned that when a variable in a closure context is shared between multiple instances of a class, the variable behaves like a static variable.</p>
<p>We will now see how we can create variables and methods that behave like a static variables. Let's start by declaring a TypeScript class named <kbd>Counter</kbd>:</p>
<pre><a>class Counter {</a> 
    private static _COUNTER = 0; 
    public increment() { 
        this._changeBy(1); 
    } 
    public decrement() { 
        this._changeBy(-1); 
    } 
    public value() { 
        return Counter._COUNTER; 
    } 
    private _changeBy(val: number) { 
        Counter._COUNTER += val; 
    } 
} </pre>
<div class="packt_infobox">The preceding example is a TypeScript example, not a JavaScript example.</div>
<p>The preceding class contains a static member named <kbd>_COUNTER</kbd>. The TypeScript compiler transforms it into the resultant code:</p>
<pre><a>var Counter = (function () {</a> 
    function Counter() { 
    } 
    Counter.prototype._changeBy = function (val) { 
        Counter._COUNTER += val; 
    }; 
    Counter.prototype.increment = function () { 
        this._changeBy(1); 
    }; 
    Counter.prototype.decrement = function () { 
        this._changeBy(-1); 
    }; 
    Counter.prototype.value = function () { 
        return Counter._COUNTER; 
    }; 
    Counter._COUNTER = 0; 
    return Counter; 
})(); </pre>
<div class="packt_infobox">The preceding example is a JavaScript example, not a TypeScript example.</div>
<p>As we can observe, the static variable is declared by the TypeScript compiler as a class property (as opposed to an <kbd>instance</kbd> property). The compiler uses a class property because class properties are shared across all instances of a class. The problem is that the private variable is not private at runtime.</p>
<p>Alternatively, we could write some JavaScript (remember that all valid JavaScript is valid TypeScript) code to emulate static properties at runtime using closures:</p>
<pre>var Counter = (function() { 
 
    // closure context 
    let _COUNTER = 0; 
 
    function changeBy(val) { 
        _COUNTER += val; 
    } 
     
    function Counter() {}; 
    
    // closure functions 
    Counter.prototype.increment = function() { 
      changeBy(1);  
    }; 
    Counter.prototype.decrement = function() { 
      changeBy(-1); 
    }; 
    Counter.prototype.value = function() { 
      return _COUNTER; 
    }; 
    return Counter; 
})(); </pre>
<div class="packt_infobox">The preceding example is a JavaScript example, not a TypeScript example.</div>
<p>The preceding code snippet declares a class named <kbd>Counter</kbd>. The class has some methods used to increment, decrement, and read the variable named <kbd>_COUNTER</kbd>. The <kbd>_COUNTER</kbd> variable itself is not part of the object prototype.</p>
<p>All the instances of the <kbd>Counter</kbd> class will share the same context, which means that the context (the variable <kbd>counter</kbd> and the function <kbd>changeBy</kbd>) will behave as a singleton.</p>
<div class="packt_infobox">The singleton pattern requires an object to be declared as a static variable to avoid the need to create its instance whenever it is required. The object instance is, therefore, shared by all the components in the application. The singleton pattern is frequently used in scenarios where it is not beneficial, introducing unnecessary restrictions in situations where a unique instance of a class is not required and introduces global state into an application.</div>
<p>Now we know how to use closures to emulate static variables:</p>
<pre><a>let counter1 = new Counter();</a> 
let counter2 = new Counter(); 
console.log(counter1.value()); // 0 
console.log(counter2.value()); // 0 
counter1.increment(); 
counter1.increment(); 
console.log(counter1.value()); // 2 
console.log(counter2.value()); // 2 (expected 0) 
counter1.decrement(); 
console.log(counter1.value()); // 1 
console.log(counter2.value()); // 1 (expected 0) </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Private members powered by closures</h1>
                </header>
            
            <article>
                
<p>In the previous section, we learned that closures can access variables that persist beyond the lexical scope from which they were created. These variables are not part of the function prototype or body, but they are part of the function context.</p>
<p>Because there is no way we can directly invoke the function context, the context variables and methods can be used to emulate private members at runtime. The main advantage of using closures to emulate private members (instead of the TypeScript private access modifier) is that closures will prevent access to private members at runtime.</p>
<p>TypeScript avoids emulating private properties at runtime because the compiler will throw an error at compilation time if we attempt to access a private member. TypeScript avoids the use of closures to emulate private members to improve the application performance. If we add or remove an access modifier to or from one of our classes, the resultant JavaScript code will not change at all. This means that the private members of a class (at design time) become public members at runtime.</p>
<p>However, it is possible to use closures to emulate private properties at runtime. Let's look at an example:</p>
<pre><a>function makeCounter() {</a> 
 
    // closure context 
    let _COUNTER = 0; 
 
    function changeBy(val: number) { 
        _COUNTER += val; 
    } 
 
    class Counter { 
        public increment() { 
            changeBy(1); 
        } 
        public decrement() { 
            changeBy(-1); 
        } 
        public value() { 
            return _COUNTER; 
        } 
    } 
} </pre>
<div class="packt_infobox">The preceding example is a TypeScript example, not a JavaScript example.</div>
<p>The preceding class is almost identical to the class that we previously declared to demonstrate how to emulate static variables at runtime using closures.</p>
<p>This time, a new closure context is created every time we invoke the <kbd>makeCounter</kbd> function, so each new instance of <kbd>Counter</kbd> will remember an independent context (<kbd>counter</kbd> and <kbd>changeBy</kbd>):</p>
<pre><a>let counter1 = makeCounter();</a> 
let counter2 = makeCounter(); 
console.log(counter1.value()); // 0 
console.log(counter2.value()); // 0 
counter1.increment(); 
counter1.increment(); 
console.log(counter1.value()); // 2 
console.log(counter2.value()); // 0 (expected 0) 
counter1.decrement(); 
console.log(counter1.value()); // 1 
console.log(counter2.value()); // 0 (expected 0)  </pre>
<p>Since the context cannot be accessed directly, we can say that the variable <kbd>counter</kbd> and the <kbd>changeBy</kbd> function are private members:</p>
<pre>console.log(counter1.counter); // undefined 
counter1.changeBy(2); // changeBy is not a function 
console.log(counter1.value()); // 1 </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have acquired a better understanding of the runtime, which allows us not only to resolve runtime issues with ease but also to be able to write better TypeScript code. A deep understanding of closures and prototypes will allow us to develop some complex features that would have not been possible to develop without this knowledge.</p>
<p>In the next chapter, we will learn about the <strong>functional programming</strong> (<strong>FP</strong>) paradigm.</p>


            </article>

            
        </section>
    </div>



  </body></html>