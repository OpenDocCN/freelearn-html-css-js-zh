- en: 'Chapter 1. Interacting with Data: DataSource, Templates, TabStrip, and Grid'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today is an exciting time to be a web developer. Web browsers and web standards
    have matured to the point that today's programmer has rich frameworks available
    to boost productivity and to reach wide audiences with less code and fewer headaches.
    HTML, CSS, and JavaScript have converged into a powerful and coherent unit that
    allows web applications to be both aesthetically and architecturally beautiful
    and elegant. Kendo UI, from Telerik, is a modern framework that embraces these
    advances and provides a set of tools to enable rich web development and configurable
    widgets, all with a familiar and accessible syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Along these same lines, development tools have been improving as well and Visual
    Studio 2012 from Microsoft is a good example. JavaScript is now a first-class
    citizen in the Microsoft world and there are many improvements for JavaScript
    development in the IDE, along with improved support for HTML5 and CSS3\. This
    is largely to support a new programming model in Windows 8 that allows web developers
    to take their skills to the Windows 8 desktop, but these improvements also directly
    benefit ASP.NET development —especially ASP.NET MVC. This is the programming environment
    that we will use throughout this book to demonstrate and learn the Kendo UI framework
    for the web.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the sample project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kendo UI for web development is a client-side, jQuery-powered JavaScript framework
    that is not dependent on any specific server technology or platform. This means
    that you can type and run the client-side examples in this book using your choice
    of tools and debugging/testing environment. However, Telerik has also released
    a great set of server-side extensions for the Microsoft ASP.NET MVC framework
    that can significantly boost productivity. To take advantage of both of these
    models, I will be using Visual Studio 2012 and the ASP.NET MVC 4 project template
    for all my demonstrations and I invite you to follow along with me. Visual Studio
    2012 Express is a freely available download from [http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview](http://www.microsoft.com/visualstudio/eng/products/visual-studio-overview),
    if you do not already have it installed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Rather download completed samples?**'
  prefs: []
  type: TYPE_NORMAL
- en: The samples that are displayed in this book are available for download and you
    can start from the completed code if you do not want to follow all of the steps
    of setting it up yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Visual Studio 2012 installed, click on **New Project** either
    from the Start page or from the **File** menu. Then choose **ASP.NET MVC 4 Web
    Application** from the **Web** group of project choices. As you can see from the
    following screenshot, I have named my project `LearningKendoUIWeb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select this and click on **OK**. The next window will display some selections
    for the type of template you want to use. I chose the basic template, but you
    can choose any of the templates other than the empty template in order to follow
    along with the examples. You do not need to create a unit test project for the
    purposes of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com) . If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will create the folder structure for your new project, and will
    copy all of the necessary files into that structure so that you can run your project
    in the debugger. Once this is complete, you will see your project tree in the
    **Solution Explorer** section of the Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our structure, it is time to download the Telerik Kendo UI
    files and place them in their proper location. Navigate to the Telerik Kendo UI
    website at [http://www.kendoui.com/download.aspx](http://www.kendoui.com/download.aspx)
    and download the 30-day free trial of the Kendo UI Complete package that includes
    the server wrappers for ASP.NET MVC. It will arrive as a ZIP file containing everything
    that you need for development with Kendo UI. Extract the contents of the ZIP file
    somewhere you will remember since you will need to reference these files throughout
    the rest of the book. This screenshot shows what the ZIP file should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to Visual Studio and right-click on the `Content` folder in the **Solution
    Explorer** and choose **Add, New Folder**. Name the new folder `kendo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `kendo` folder that you just created and create two more
    folders—`Default` and `textures`. Now, right-click on the `Default` folder and
    choose **Add, Existing Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the file dialog that displays, navigate to the folder with the unzipped Kendo
    files, then open the `Styles` folder and then the `Default` folder inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all of the files in this folder and click on the **Add** button. This
    will add all of these items to the Visual Studio project so that they show in
    **Solution Explorer** and can be managed from the Visual Studio IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, follow these same steps to add all of the items to the `textures` folder.
    Once you have these files in place, right click on the `kendo` folder in **Solution
    Explorer** again and choose **Add, Existing Item**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the dialog that displays, choose these two specific files from the `Styles`
    folder of the unzipped kendo files and add them as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kendo.common.min.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kendo.default.min.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once these two files appear in **Solution Explorer**, rename them by removing
    the .`min` portion of their file names (`kendo.default.min.css` becomes `kendo.default.css`);
    this will be explained in greater detail in next few paragraphs. The `Content`
    folder in **Solution Explorer** should look something like this when you are finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will prepare the `Scripts` folder by following some very similar steps.
    Create a `kendo` folder inside of the `Scripts` folder in **Solution Explorer**
    and then copy these files from the `js` folder of the downloaded Kendo files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery.min.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kendo.all.min.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kendo.aspnetmvc.min.jskendo.web.min.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, remove the `.min` portion of their filenames. We will, however,
    need two versions of the `kendo.aspnetmvc.js` file as will be explained later.
    Go ahead and copy the file, but only remove the <code>.min</code> portion of the
    filename from one copy. This way you will have one copy of the file with a `.min`
    filename and another copy of the file without the `.min` file name. The completed
    `kendo` folder in **Solution Explorer** should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a web developer, you are surely familiar with the exercise of referencing
    scripts and styles in the head portion of your web pages. ASP.NET MVC 4 comes
    with a great feature that enables bundling and minimization of these scripts,
    along with built-in caching, so that the browser can download these files faster
    and thereby increase the performance of your site with very little effort on your
    part. This feature also works with CDN locations, so that you can run with local
    files during debugging and still reference CDN hosted scripts or style sheets
    when your site is deployed. To enable this functionality for our sample project,
    you will need to add the following code to the `BundleConfig.cs` file in the `App_Start`
    folder of the project. First, add this code at the top of the file to enable CDN
    functionality and to save the paths of the CDN locations that we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then, add this code at the bottom of the file to create the bundles for your
    Kendo files. By passing the CDN location as the second parameter of the `ScriptBundle`
    constructor, Visual Studio will build your solution using your local files when
    debugging and will build your solution using the CDN location files when building
    in release mode. This is also where I should explain why we removed the `.min`
    portion of the JavaScript and stylesheet filenames. The bundling and minification
    features of ASP.NET MVC intentionally ignore files that include `.min` in their
    filenames during debugging. This means that none of your script references from
    the Kendo download will work during debugging because we do not have the pre-minified
    files included in our project. There are several documented ways to deal with
    this problem floating around the Internet, but the easiest way to address this
    for our project is just to rename to files to avoid the entire issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the `BundleConfig.cs` file properly configured, we can adjust
    the references in the head portion of our `_Layout.cshtml` file. The `_Layout.cshtml`
    file acts as our default master page by creating a uniform head structure for
    all of our pages and a default layout within which all the other pages place their
    specific content. Open the `_Layout.cshtml` file in the `Views`, `Shared` folder
    and make some changes. By default, it will have some script references that appear
    in the body portion of the page and some that appear in the head portion.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are undoubtedly some good reasons for doing this, but since we will have
    references to Kendo scripts in the body of our page before these script references
    would appear, we need to move everything to the head portion. Since this file
    is not very long, I have included my finished version here so that you can copy
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that I have added an `@using` statement at the top of the file, make
    sure you copy that as well since it will enable **Intellisense** on all of your
    pages. Intellisense is a feature of Visual Studio that auto-completes code as
    you write and is a great productivity booster. To fully enable this, you will
    also need to add a reference to the `Kendo.Mvc.dll` file to your Visual Studio
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: First, right-click on the **LearningKendoUIWeb** project in the Visual Studio
    **Solution Explorer** and choose **Add Reference**.![Setting up the sample project](img/4346OT_01_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on **Browse** and navigate the file dialog to the location where
    you downloaded the Kendo files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the folder named `aspnetmvc`, open the folder named `Binaries` inside it,
    and then open the folder named `Mvc3` inside that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here you will find the `Kendo.Mvc.dll` file; click on it and choose **Add**.![Setting
    up the sample project](img/4346OT_01_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this reference added, you can make the code inside it available to all
    of your web pages by adding a special entry in a file called `web.config`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This file is located in the root of your **LearningKendoUIWeb** project. Open
    `web.config` and locate the section called `namespaces`. Add the `Kendo.Web.UI`
    namespace to the list like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create a folder to hold static content in the project. Right-click the project
    name in **Solution Explorer**, choose **Add, New Folder**. Call the new folder
    `static`. This will be the location where we place all of our client-side examples
    that run apart from the MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2012 includes some good improvements in JavaScript Intellisense
    and it is going to help us as we write our code. Open the file called `"_references.js`"
    in the scripts folder and delete all of the text in it. This is the entire contents
    of my `"_references.js`" file, copy this into yours as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Visual Studio 2012 uses this file as the list of JavaScript libraries that
    it should use for Intellisense in the editor. I have included the jQuery file
    included with the Kendo zipped package and two JavaScript files that we will be
    using in the majority of our web pages. Once you have this in place, you will
    get some very helpful coding assistance in your JavaScript files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the sample project](img/4346OT_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how all of the Kendo options show up as you type JavaScript code in the
    editor? As you program the examples throughout this book, this will become something
    that you will help you.
  prefs: []
  type: TYPE_NORMAL
- en: OK, now we are ready!
  prefs: []
  type: TYPE_NORMAL
- en: KendoUI syntax styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the KendoUI framework in your web pages, you will find that there
    are two ways to add the widgets to your content. The standard method is to use
    a jQuery syntax within script elements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The convention, as shown, is to select the elements through jQuery and then
    apply a JavaScript method from the Kendo namespaces that alters the content into
    an interactive Kendo UI widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way, now available through HTML5, to add Kendo UI widgets
    to your content through a method known as declarative initialization. This is
    a practice where you typically add special attributes to your elements that start
    with "data-" and then call an initializer that reads these attributes and then
    applies the appropriate changes. See this code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This type of syntax allows for a cleaner separation between JavaScript and mark-up,
    and is important in the MVVM pattern that we will cover later in the book. It
    is also powerfully expressive and can make the code more readable, since relevant
    attributes are contained directly within the elements to which they pertain. Script
    blocks containing code do not necessarily appear beside the code actually being
    affected, which can make things difficult to trace in a complicated project.
  prefs: []
  type: TYPE_NORMAL
- en: Kendo UI MVC – basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be using ASP.NET MVC quite a bit in this book, I should define
    some important terms so that there isn't any confusion later. **MVC** stands for
    **Model-View-Controller**; so let's establish a common terminology around these.
    First, a web page is referred to as a *view* and, when using Razor syntax with
    C#, the web pages have a file extension, `cshtml`. There is also the option of
    using Visual Basic in which case the web pages have a file extension, `vbhtml`,
    but we will be using C# in this book so you won't see this in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the *controller* is a server-side classfile that is responsible for
    all of the logic used in generating the content included in a web page (view).
    The controller, along with the route table, is also responsible for establishing
    the publicly accessible URLs to which the server will respond, and enforcing which
    HTTP verbs are required to access them. In general, a controller is responsible
    for contacting any external dependencies, such as a database or web server, performing
    any necessary logic and calculations on the data retrieved from those external
    dependencies, and then packaging up all of that processed data into an object
    called the *model*.
  prefs: []
  type: TYPE_NORMAL
- en: The model, then, is an object container that contains the data that the web
    page (view) needs in order to display itself. In a properly separated system,
    the controller is the engine that performs all logic, data manipulation, user-input
    handling, authorization, and security. The view is the data presenter and is concerned
    only with the graphical representation of the data it has been given; no logic
    apart from what is required for presentation (not to say that presentation can't
    be complex). The model is the standard data format that the controller uses to
    send its final product to the view to be presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'When programming in the ASP.NET MVC environment, Kendo UI offers a rich set
    of server-side extensions for creating its widgets. Instead of typing out an HTML
    element, specifying its attributes and wiring it up to Kendo UI JavaScript, the
    entire process can be done using server-side objects that appear in the view.
    For example, creating a `DatePicker` widget in MVC Razor syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'No HTML, no JavaScript, just extension methods on the HTML class. When the
    page is generated, however, you can see what was sent to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The extension methods create all the HTML, JavaScript, and CSS information dynamically.
    You can see how the final output uses the jQuery method of selecting the input
    element and using `.kendoDatePicker(…)` to create the widget through JavaScript.
    So, although the programmer didn't type out the JavaScript, it was still necessary
    for Kendo UI to work; the MVC extensions are only wrappers around the normal Kendo
    UI client-side framework.
  prefs: []
  type: TYPE_NORMAL
- en: I should also explain that even though the view is what generates the final
    web page sent to the user's browser, it is processed on the server first. The
    Razor syntax (everything that starts with `@`) never appears in the final page
    markup, it is processed on the server in order to generate the final markup. This
    means that the Kendo MVC extension methods are really a server-side shortcut to
    creating the final markup needed to make them work as they normally would in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Programming in the MVC framework allows for a very clean separation of concerns
    within the web server itself and this, in turn, allows for a great deal of flexibility
    around how the views run and how dependent they are on server-side logic. For
    example, widgets that use data can receive this data either as embedded material
    in the view itself (a dependency on server-side logic), or they can query for
    data from the client-side by calling action methods that return JSON (less dependency
    on server-side logic).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of a server-dependent implementation, here is a strongly-typed
    view with embedded model data that can then be used by widgets on the page. A
    strongly-typed view is a view page that specifies a specific type of object that
    contains its model data. You can see the strongly-typed model object in this sample
    on the first line starting with `@model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewBag` is a dynamic object that is available to you within controller action
    methods and view pages. It is a dictionary object that can contain any data or
    objects that you need in your view pages. The controller can add anything that
    you need to `ViewBag,` and your view pages will then have access to that data
    or object just as this sample code has shown. In this case, the controller has
    attached an object called `serverData` that contains a JSON representation of
    its model data. We are using the JavaScript function called `eval()` to parse
    it into a JavaScript object and then showing on the JavaScript console what was
    inside. This is merely an example of how to embed data into the view itself without
    having to use additional network requests, such as the jQuery functions `$.get`
    or `$.ajax`, to retrieve data to display on the page; it may prove beneficial
    in some cases where network traffic needs to be weighed against immediate data
    availability that the server can provide up front.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewBag.serverData` property is filled in the controller like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in this example the controller is both filling in this `ViewBag`
    property and sending the same data to the view as a strongly-typed model; this
    isn''t necessary, but it is handy here since we can leverage the server''s `JavaScriptSerializer`
    class to create JSON for us before we send it to the view. Here is what the JavaScript
    console shows when we fill `ViewBag.serverData` with the JSON representation of
    an array of objects that have a **Name** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kendo UI MVC – basics](img/4346OT_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is far more common to request data from a separate endpoint and then use
    it once it has been retrieved. This allows for data from external sources, and
    breaks the dependency on the server to provide the data inside the page, which
    in turn means the specific server implementation is likely less important and
    less complex. jQuery provides several common and friendly ways of retrieving JSON
    data such as `$.ajax`, `$.get`, and `$.getJSON`. Kendo also provides standard
    ways of retrieving external data through configuration options on its widgets,
    often through the property method `transport.read`. We will see more about this
    in the rest of this chapter as we discuss DataSource and Grid, and throughout
    the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Managing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kendo UI framework consists of two parts—the framework components and the
    user interface (UI) widgets. Most of the content that we will cover in this book
    relates to the user interface widgets and how to use them, but we will begin with
    the important topic of how to manage data within Kendo UI. The DataSource component
    and Templates provide a good starting place and will build a foundation that we
    will use throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kendo UI Templates are script blocks that contain a small section of page markup
    that is used by other Kendo UI widgets to display repeating content. We will cover
    these first, since they will be used throughout the rest of our examples. Here
    is an example of a simple template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code would set the HTML content of the `horseDiv` to a span element
    that contained the `horseColor` value that was passed into the template function
    object. It would produce the following code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Templates can also be written within a special type of HTML script block so
    that their layout appears more naturally within the HTML content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template sample, note the lines containing the code fragments `#= variable_name
    #`. These indicate the sections of code that are interpreted by the Kendo UI Template
    engine. The variable names inside these code blocks are supplied to the template
    when it is used. The JavaScript property names that you use inside of a template
    need to be properties on the object that is passed to the template when it is
    called. Note also that the script type is `x-kendo-template` instead of `javascript`,
    this is important so that the browser will not attempt to execute the script block
    on its own. This is a code sample showing this template being initialized in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the template is created through a call to `kendo.template()`. This
    method takes the literal template code as its parameter, which is why the example
    shows a call to the jQuery statement `$("#template").html()` since this code returns
    the literal content of the template script block as it appears in the web page.
    So, in this example, it is equivalent to calling `kendo.template(''<tr><td>#=
    rank #</td>…'')`. This means that templates can also be created in-line by typing
    out the exact template code directly in the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the template object is called as a method, it needs the data passed in
    as a parameter. When the example code above runs, it produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Templates can also include JavaScript which makes it possible to do more advanced
    operations, such as iterating over an array and rendering the template for each
    item in that array individually. In this case, you supply the template with an
    array of objects instead of a single object as before. This time, using the explicit
    parameter name `data` is critical. Note how JavaScript code is surrounded by single
    `#` signs like `# javascript code #` and variable statements are surrounded by
    `#=` and then `#` as in `#= variable statement #`. Note also that the space between
    the `#` signs and the content inside is important.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Templates are an important part of building functional Kendo UI widgets, and
    they become even more useful when used in tandem with the DataSources and Grids
    as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: DataSource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kendo UI DataSource is a JavaScript object that gives data a common interface
    for the various Kendo UI widgets. The full documentation for the DataSource object
    can be found on the Kendo UI website at this address: [http://docs.kendoui.com/api/framework/datasource](http://docs.kendoui.com/api/framework/datasource).
    The DataSource is a fairly complicated object and relies on some building blocks
    that deserve explanations of their own. These building blocks are the Kendo objects
    known as Schema, Transport, and Model. Let''s address these first and then continue
    exploring the DataSource itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that when creating a DataSource object, you should
    use the `new` keyword to instantiate a new object instead of just using an object
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Model object is from the namespace `kendo.data.Model` and inherits from
    Kendo''s `ObservableObject`. It provides a known structure, or model, to the data
    that is used by a DataSource and can also be used to enable some more advanced
    functionality such as change tracking. To create a new model, you must do so through
    the method `kendo.data.Model.define()` . In this method, you pass an object that
    defines the structure of the model and sets configurable options on the data elements
    within. Here is an example of a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a model with three properties and we set the
    data type for each of them. We then created a new model object from our model
    definition and demonstrated how to access its properties through the `model.get()`
    method. We just demonstrated that the ID of the model object is defined through
    the property called `id`, and that the fields are defined through a property called
    `fields`. Within the `fields` property, these are the options that can be set
    to configure each data element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These are not all required, but they are available when you want a very specific
    configuration. Here is an example from the Kendo UI site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since the properties within a model are observable, you need to use special
    getter and setter methods to properly trigger the behaviors that other functions
    and objects are observing. To retrieve the current value of one of these properties,
    use `model_name.get()` such as `currentService.get('unitPrice')`. To set the value
    of the property and thereby change it, use `model_name.set()` such as `currentService.set('unitPrice',
    14.95)`. The concept of observable objects is a key feature of the MVVM framework
    that we will cover in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Two other methods available on model objects are `isNew` and `toJSON`. The `isNew`
    method checks if the model is new or not. This is determined by whether or not
    the `id` field is still set at the default value. If the `id` field is not set
    at the default value, the model object is not considered new. The `toJSON` method
    returns a JSON representation of the complete model's properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, as I mentioned, the model inherits from `ObservableObject`, it exposes
    three events to which you can attach custom behaviors—`change`, `get`, and `set`.
    The syntax for these is to use `model.bind()` with the name of the event and a
    function to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `schema` object within a DataSource is responsible for describing the raw
    data format. It functions at a higher level than the model, and can even contain
    a model definition within it. The Schema''s job is to instruct the DataSource
    on where to find information on errors, aggregates, data, groups, and total records
    within the raw data object that the DataSource is using. Each of these pieces
    of information exists as a property within the `schema` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code sample, each of the properties has been set to a function
    which, when passed the raw data object, will return the appropriate data from
    within that object. These properties can also be set to text fields, in which
    case the field name given must exist at the top level of the object and already
    contain the appropriate data in the appropriate format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `aggregates` property needs data returned in an object format with a structure
    something like this. Each property name inside the **aggregates** object can contain
    information on its aggregate values, such as the maximum value (**max**), minimum
    value (**min**), or the total **count**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the data has a **max** and **min** defined on the **unitPrice**
    field and a **count** defined on the **productName** field. The DataSource object
    has not calculated these values; rather they are already present in the raw data
    sent from the remote server, and the schema has indicated to the DataSource object
    where to locate them. It is possible to use a function to calculate aggregate
    values, but it is normal for the raw data to already contain these values within
    it as returned by a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said earlier, the schema can contain a model definition within it. If
    this is the case, the DataSource will call `kendo.data.Model.define` on the model
    definition for you, in order to create the model objects from the raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already defined a Model definition, you can simply reference it
    and the DataSource will use it just the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `schema` object has a `parse` property, which you can set to a function
    that will be called before the raw data is processed. This gives you a chance
    to do any pre-processing if you need it. There is also a `type` property that
    can be set to either `json` or `xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Transport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `transport` object contains properties that a DataSource can use to communicate
    with a remote server for any of its normal data functions. Those data functions
    are `create`, `destroy`, `read`, and `update` (corresponding to the different
    actions that can be taken on a record). Each of these data functions exists as
    a property object within the `transport` object and follows the same pattern of
    configuration options. I should note that not all of the data functions are required;
    only those functions that your DataSource should perform need to be defined within
    your `transport` object. This is the basic configuration structure for the `transport`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here are the different options for configuring the transport object's remote
    data operations. Each of the four properties follows the same configuration pattern,
    but in this code sample I have shown different ways of configuring them for the
    sake of example. In this first code sample, I have configured the **create** operation
    to simply send the value of an HTML element to the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have set the destroy method to use a jQuery `$.ajax` function
    to send data to the remote server instead of configuring it directly on the **destroy**
    configuration object. You can do this if you prefer the jQuery syntax and want
    to easily attach callback functions to the results of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created a function to serve as the source of data for
    the read operation. This might be useful if you need to perform some custom logic
    before receiving remote data, or if you need to bypass the remote data source
    entirely for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the configuration options you just saw are valid for any of the
    transport operations, I simply showed different operations as an example for each
    configuration. When a DataSource is configured with a transport configuration
    like this, it will use the properties and functions within these options to perform
    the related actions. It will call `read` when it is loading data, `update` when
    a record has been changed, `destroy` when a record has been deleted, and `create`
    when a new record is added.
  prefs: []
  type: TYPE_NORMAL
- en: Other DataSource properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When reading from local data, you need to reference it by using the property
    called `data` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some other properties of DataSource that we have not yet seen are more for data
    manipulation—`aggregate` , `filter` , `group` , `sort` , `page` , and `pageSize`.
    They can work on the data client-side, or they can request that the server do
    the operations by using the `serverAggregates`, `serverFiltering`, `serverGrouping`,
    `serverSorting`, and `serverPaging` properties by adding these to the DataSource
    object properties list and setting them to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `aggregate` property takes an array of fieldnames and aggregate function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` property can take a simple object, an array of simple objects,
    or a configurable object with some more logic to specify filtering that should
    be done on the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These are the different operators that can be used with the filter object. They
    can also be used when asking the server for filtering by using the `serverFiltering`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Equality**: `eq`, `==`, `isequalto`, `equals`, `equalto`, `equal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inequality**: `neq`, `!=`, `isnotequalto`, `notequals`, `notequalto`, `notequal`,
    `ne`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less**: `lt`, `<`, `islessthan`, `lessthan`, `less`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Less or Equal**: `lte`, `<=`, `islessthanorequalto`, `lessthanequal`, `le`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater**: `gt`, `>`, `isgreaterthan`, `greaterthan`, `greater`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Greater or Equal**: `gte`, `>=`, `isgreaterthanorequalto`, `greaterthanequal`,
    `ge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Starts With**: `startswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ends With**: `endswith`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contains**: `contains`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `group` and `sort` properties can take either an object or an array of
    objects to specify grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `page` and `pageSize` properties both take numbers to indicate the page
    number and records per page respectively.
  prefs: []
  type: TYPE_NORMAL
- en: DataSource methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DataSource methods are used to either change or retrieve certain elements
    of the DataSource object. Several of them are related to the same data manipulation
    properties that we just talked about—`aggregate`, `aggregates`, `filter`, `group`,
    `page`, `pageSize`, and `sort`. In each of these cases, calling the method without
    parameters will return the current value of the like-named property within the
    DataSource; calling the method with a parameter value will set the value of the
    like-named property of the DataSource to the new value passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also methods for adding and removing records. The methods `add` and
    `insert` both add a new record to the DataSource. The `add` method simply takes
    a model object or an object literal matching the current data format of the items
    in the DataSource. The `insert` method takes the same object as `add,` but also
    specifies an `index` property indicating the zero-based location at which to insert
    the new record. The `remove` method takes a model object and removes it from the
    DataSource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `at` , `get` , and `getByUid` methods retrieve specific records from the
    DataSource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetch` , `query` , `read` , `sync` , `cancelChanges` , and `view` methods
    are used for managing the current contents and structure of the DataSource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish up the list, we will look at `data`, `total` , and `totalPages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that you must call `dataSource.read()` in order for
    the DataSource object to initiate the read process and populate itself with data.
    In other words, until you call `dataSource.read()`, there is nothing to read inside
    your DataSource.
  prefs: []
  type: TYPE_NORMAL
- en: DataSource events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three events that are available on the DataSource object— `change`
    , `error` , and `requestStart` . The `change` event is fired when data is changed
    or read from the transport. The `error` event is fired any time an error occurs
    during data read or data sync; it is also fired if `schema.errors` has been set
    within the DataSource and the response from a server operation contains data in
    the field specified by `schema.errors`. The `requestStart` event is fired when
    a data request is about to start. Like other events, these can be set as part
    of the DataSource definition or later through the `bind` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you will see later, the change event can be a good place to put some code
    in order to generate markup while a DataSource is reading in new records. It is
    also the appropriate place to put any other code that should respond to changes
    in the DataSource.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with basic usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have seen the definitions of the components within a DataSource,
    we will put together our first example page to demonstrate the basic usage of
    the DataSource object in JavaScript. Add a new HTML file to the static folder
    of the project and name it `DataSource.html`. Start out by adding this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have referenced jQuery and Kendo UI Web JavaScript files in the head of
    our page. Now let''s add a template block after the `div` tag so that we can script
    the creation of additional table rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what we need is the ability to take some data and fill out that table using
    the layout as defined by this template, enter the DataSource. Add this code after
    the template script block that you just typed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's step through this code. You should recognize the first few lines where
    a Kendo template is created from the script block that you typed just a few paragraphs
    ago. After that, you see a JavaScript array of objects holding data about various
    movies. This array is going to be the raw data behind the DataSource object that
    comes next. The DataSource object is instantiated (note the `new` keyword) into
    the variable called `dataSource`. It references the `movies` array as its data
    parameter and then defines a function to handle the `change` event of the DataSource
    object. Inside this `change` event, we are using jQuery to select the `movies`
    table and then using `kendo.render()` to generate markup from our `template` variable
    for each item in our `dataSource` object. Note how the template we are using does
    not need special JavaScript to iterate over a collection; the DataSource object
    passes all of the data to the `change` event through `this.view()`. Finally, we
    call `dataSource.read()` which reads in the data and consequently fires the `change`
    event, thereby adding the content to our `movies` table.
  prefs: []
  type: TYPE_NORMAL
- en: The `kendo.render()` method takes a template function as its first argument
    and then an array of data as its second argument. It runs the data through the
    template, generating the resulting markup and returning it back to the caller.
    In the case above, we have used jQuery to set the `<tbody>` element's HTML to
    the result of this `kendo.render()`function.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to remote data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our last example was a demonstration of using local data (a JavaScript array)
    with a DataSource. It is also very common and important to use the DataSource
    with data that exists on a remote system. To simulate this, we will turn to the
    ASP.NET MVC framework to create a server for our remote data.
  prefs: []
  type: TYPE_NORMAL
- en: In the Visual Studio Solution Explorer window, right-click on the **Controllers**
    folder and choose **Add, Controller**. Name the new controller **KendoController**
    and leave the rest of the dialog that opens at its default settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding to remote data](img/4346OT_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The newly created controller class will appear in the editor portion of Visual
    Studio and you will see a generic `Index()` method sitting in the file. This method
    is known as an **action method** and is used to process an HTML response back
    to a web browser. The comment above it indicates the route and HTTP verb that
    are used to locate this action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, it shows that typing the route "Kendo", as in `http://<server-name>/Kendo/`,
    would match this action method and cause it to return its view to the browser.
    It would also work to specify `http://<server-name>/Kendo/Index` and it is usual
    to supply both the controller name, "Kendo", and the action method name, "Index",
    in a normal route. As a matter of convention, the MVC framework names all controller
    classes with the suffix "Controller", but it does not use the suffix when referring
    to the controller in an actual route (such as the path in the address bar of your
    web browser). This means that the `KendoController` class is referred to as "kendo"
    when it is part of a route. GET is the default HTTP verb that this controller
    will accept when the browser requests this route.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `KendoController`, add a `using` statement for a namespace that
    we are about to create—`LearningKendoUIWeb.Repository`. Also add `Kendo.Mvc.UI`
    and `Kendo.Mvc.Extensions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding to remote data](img/4346OT_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new action method called `RemoteData` and set it up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple method that instantiates a repository (which we will create
    in just a moment), gathers some data from that repository, and then returns it
    to the client as JSON. The second parameter to the `Json()` method notifies the
    controller class that it is acceptable to return JSON data from this method even
    though the verb is GET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **Models** folder and click on **Add, Class**. Name the
    new class `Movie.cs`. This is a very simple class to hold data about a movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new folder to the project and call it `Repository`. Add a class to this
    folder called `SampleRepository.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to add more movies to this list, the more the better. Now we have
    a simple repository class that can return a list of movie objects, so the action
    method we created in `KendoController` is finally valid. When the `RemoteData`
    action method is called, it will return the list of Movie objects as a JSON array
    of objects like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding to remote data](img/4346OT_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I have added more movies to my repository, but the structure of the result
    is the same. This is exactly the sort of data that DataSource knows how to use.
    Here is how to wire up DataSource to use it, find the line in the `RemoteData.cshtml`
    file where the `dataSource` variable is created in JavaScript and change the code
    so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the using the `data` property to point to a locally available array
    of objects, we are using the `transport` property to tell Kendo that we need to
    request the data from a remote source. In this case, all we have specified is
    how the DataSource can read remote data and that is all we need, since the only
    method call we make to the DataSource is in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These examples have only scratched the surface, but it does show the DataSource
    in action in a real page. It is hard, however, to really demonstrate a DataSource
    object in isolation. The DataSource is only actually useful when it serves a data-rich
    widget, like the Kendo UI Grid. In the pages to follow, we will explore this Grid
    widget and will be able to demonstrate a more fully configured DataSource that
    the Grid can take full advantage of. We will also see how to configure both the
    Grid and the DataSource through the MVC Razor syntax within a view page.
  prefs: []
  type: TYPE_NORMAL
- en: Page layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have discussed the DataSource and Template features of the Kendo
    UI framework, we can turn our attention to widgets that provide graphical elements
    on our web pages. Some of these widgets actually assist you in organizing the
    content or the data in your page, and the Grid is a very good example of this,
    which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kendo UI Grid is a very handy widget to be familiar with. It is an easy
    way to transform data into a usable and interactive grid that would normally take
    a full-featured server control (as in ASP.NET WebForms) or some complex and time-consuming
    JavaScript development in the page markup. In fact, it is remarkably easy to set
    up a simple example. Let''s say we have some JavaScript data like this that we
    want to display within a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to turn this into a well-formatted dynamic table, it would normally
    require some looping and HTML markup generation, probably through jQuery. With
    Kendo UI, however, all we have to do is create a `kendoGrid()` function and we
    can see some magic in action. Take note of how little code is involved to create
    a grid from this data here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the page output from this simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid](img/4346OT_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See how the code involved didn't even require a table to be present within the
    web page? Kendo UI generated everything that it needed in order to display this
    data as a grid on the page. Now we can turn our attention to creating grids that
    are more interactive and intelligent, and explore what the Kendo UI Grid widget
    has to offer in displaying data from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, we can take control of the formatting of the Grid by specifying
    properties on a `columns` object array. This object array is used to indicate
    to the Grid how to display the data appropriately so that it appears as you want
    on the page. Here is a columns object example using the Grid that we saw just
    a moment ago to demonstrate the various options available for formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the effect on the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are also simple options for enabling some dynamic interactive behaviors
    by specifying which columns are filterable or sortable. Note that these are only
    useful if the Grid, as a whole, has `pageable` and/or `sortable` set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the following screenshot, how the **Service** column has been sorted
    alphabetically and I have clicked the filter icon, which enables me to input a
    filter on the data to be displayed on the page. You can see the filter icon right
    above the open window on the screen, it looks like a small funnel. Kendo UI takes
    care of actually doing the sorting and the filtering by means of the `dataSource`
    property that we set on the Grid. This means that settings you have put in place
    on the `dataSource` that you supply to the Grid will be used by the Grid for sorting
    and filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the Grid has been configured to allow editing of data, the `columns` property
    allows you to specify a custom editor function that can be used when changing
    data in that column. This can be a useful way of giving the user an easier way
    to input a change, or even to control the sort of changes that can be made. For
    example, this updated code sample shows adding an editor function to the `Labor`
    column so that it displays a drop-down list when edited, giving the user a specific
    set of options to choose from. There are a couple of other changes here that we
    will talk about next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here is the output of the `editor` function, showing the drop-down list that
    appears when a row enters the edit mode. It is important to set the `name` attribute
    of the `<select>` element so that Kendo can bind the user's choice back to the
    `dataSource` when the edit is saved.
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When using a custom editor function like this, the `container` and `options`
    objects that are passed in have some specific properties available to them that
    can be useful to you when writing your function. The `container` object is the
    page element to which you should add any new mark-up, as we did in our example.
    The `options` object contains two properties: `options.field` and `options.model`.
    The `options.field` property contains the name of the field that you should use
    in your new mark-up so that Kendo can bind everything properly. The `options.model`
    property contains a reference to the actual model of the data being edited if
    one was specified in the `dataSource`; this gives you access to data that could
    be important when creating your custom logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional changes that appeared in the code sample were the `editable: "inline"`
    property on the Grid definition (required for editing to work; the alternative
    to `inline` is `popup`, which opens a special window for editing the record),
    and the new column that includes command buttons. The command property of a column
    object takes an array of command buttons to generate within each row. The available
    options for this array include `edit`, `create`, `destroy`, `save`, and `cancel`.
    We will return to this topic soon when we go into more detail on how to bind a
    Grid to CRUD operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all that was necessary to add these command buttons to the Grid was
    to specify the `command` property of the column object. I did not add any `<button>`
    elements to the column, nor did I create JavaScript event handlers. Kendo UI generated
    all of this necessary markup for me through the Grid widget's existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A significant portion of Grid functionality can be enabled through properties
    that describe the Grid''s current capabilities. Each of them end in -able. These
    properties are `editable` , `filterable` , `groupable` , `navigatable` , `pageable`
    , `scrollable` , `selectable` , and `sortable` . We have already seen `filterable`
    and `sortable` and that they take simple true/false values when used. We have
    also seen `editable`, but there is more that can be done with this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `groupable` property lets the user group columns by dragging them to the
    top of the screen. The `groupable` option also includes a property, `groupable.messages.empty`
    that will be displayed in an empty grouping area on a Grid. If you specify this
    `messages` property, the `groupable: true` value is assumed and does not need
    to be specified. The `navigatable` property turns on or off keyboard navigation
    within the Grid. Here is how the bottom of our Grid definition would look with
    `groupable` and `navigatable` turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output in the page when rendered with these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `pageable` option can be simply set to `true`/`false`, like several of
    the other options, but it also allows for more fine-grained control if you desire
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example code configured for paging with 10 items per page would appear
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output generated with these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `scrollable` property configures whether a Grid can have a vertical scroll
    bar within it, and is usually specified if you have restricted the height of the
    Grid on your page. It can be set to a simple Boolean value of `true/false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selectable` property indicates whether selection is enabled or disabled
    within the Grid. Its possible values are `row`, `cell`, `multiple, row`, and `multiple,
    cell`. Here is how our example Grid looks with `selectable: "multiple, cell"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I have selected some rows for display.
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `toolbar` property enables a toolbar for the Grid with a certain set of
    commands, similar to the command property of the column objects. Each toolbar
    within the `toolbar` object array can have a `name`, `template`, and `text` configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how a toolbar can be a simple text value indicating which command to implement.
    You can also specify objects to contain the configuration data that you want (as
    in the preceding screenshot). Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Columns](img/4346OT_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a lot of fundamental information so that you
    can get started creating Kendo UI-enabled web pages properly. It is essential
    to understand how to use a Template and how to use a DataSource in order to do
    much at all with the Kendo UI framework. Second to these, the Grid is an essential
    component of the Kendo UI framework and knowing how to configure it will give
    you a head start when building pages that need to display tabular data to a user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the AutoComplete widget. It allows
    you to add a word-wheel effect to input text boxes, to assist users in typing
    information that can be looked up from a data source. It is a great tool that
    many users are drawn to and will add a lot of functionality to your web pages
    without a lot of effort in writing the code.
  prefs: []
  type: TYPE_NORMAL
