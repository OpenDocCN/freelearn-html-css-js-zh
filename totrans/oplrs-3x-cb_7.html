<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Styling Features</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Styling features using symbolizers</li><li class="listitem" style="list-style-type: disc">Improving style using StyleMap and the replacement of the feature's attributes</li><li class="listitem" style="list-style-type: disc">Playing with StyleMap and the render intents</li><li class="listitem" style="list-style-type: disc">Working with unique value rules</li><li class="listitem" style="list-style-type: disc">Defining custom rules to style features</li><li class="listitem" style="list-style-type: disc">Styling clustered features</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Introduction</h1></div></div></div><p>Once we know how to work with vector layers, such as adding new features or modifying the existing ones, the question we can have in mind is: how to style them?<a class="indexterm" id="id299"/>
</p><p>The visual representation of features, the<strong> style</strong>, is one of the most important concepts in GIS applications. It is not only important from the user's experience or designer's perspective but also as an information requirement, for example, to identify features that match certain rules.<a class="indexterm" id="id300"/>
</p><p>The way we visualize features is not only important to make our application much more attractive, but also to improve the way we bring information to the user. For example, given a set of points that represent some temperatures, if we are interested on the hottest zones, we could represent them with different radius and color values. This way, a lesser radius and a color near to blue means a cold zone while a greater radius and a color near to red means a hot zone.</p><p>OpenLayers offers us a great degree of flexibility when styling features that can initially seem a bit complex. Concepts such as symbolizers, StyleMap, rules, or filters are all related with the process of styling.<a class="indexterm" id="id301"/>
</p><p>Let's see all this in the following recipes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Styling features using symbolizers</h1></div></div></div><p>To see the most basic form of styling a feature, we are going to create a little map editor that allows adding new features by specifying some few style properties:<a class="indexterm" id="id302"/>
</p><div><img alt="Styling features using symbolizers" src="img/7843_07_01.jpg"/></div><p>Each<code class="literal"> OpenLayers.Feature.Vector</code> instance can have a style associated with it. This style is called<strong> symbolizer</strong>, which is nothing more than a JavaScript object with some fields that specify the fill color, stroke, and so on. For example:<a class="indexterm" id="id303"/>
</p><div><pre class="programlisting">{ 
    fillColor: "#ee9900", 
    fillOpacity: 0.4, 
    strokeColor: "#ee9900", 
    strokeOpacity: 1, 
    strokeWidth: 1 
}
</pre></div><p>In the code, every time a feature is going to be added to the map, the code will get the fill and stroke properties from the controls on the left-hand side and will create a new symbolizer hash to be used by the new feature.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec01"/>Getting ready</h2></div></div></div><p>The source code has two main sections, one for HTML, where all the controls are placed, and a second one for the JavaScript code.<a class="indexterm" id="id304"/>
</p><p>The HTML section has plenty of codes related with the controls used to select the fill and stroke properties. These controls come from the Dojo Toolkit project (<a class="ulink" href="http://dojotoolkit.org">http://dojotoolkit.org</a>) and because they are not the goal of this recipe, we have not covered it here. We encourage the reader to take a look at it in the code bundle of the book.</p><p>Let's see the JavaScript code.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">After creating the HTML file including OpenLayers dependencies (see the<em> Getting ready</em> section for the HTML code), create the<code class="literal"> map</code> instance in the<code class="literal"> div</code> element identified by<code class="literal"> ch07_using_symbolizers</code> and add a base layer:<div><pre class="programlisting">    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_using_symbolizers");
    
    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);
    
    map.setCenter(new OpenLayers.LonLat(0,0), 3)
</pre></div></li><li class="listitem">Now, add a vector layer where new features will be placed:<div><pre class="programlisting">    var vectorLayer = new OpenLayers.Layer.Vector("Features");
    vectorLayer.events.register('beforefeatureadded', vectorLayer, setFeatureStyle);
    map.addLayer(vectorLayer);
</pre></div></li><li class="listitem">Add the<code class="literal"> OpenLayers.Control.EditingToolbar</code> control that allows to add new features to the previous vector layer:<div><pre class="programlisting">    var editingControl = new OpenLayers.Control.EditingToolbar(vectorLayer);
    map.addControl(editingControl);
</pre></div></li><li class="listitem">Add the code responsible, to get and apply the style to the new features:<div><pre class="programlisting">    function setFeatureStyle(event) {
        var fillColor = dijit.byId('fillColor').get('value');
        var fillOpacity = dijit.byId('fillOpacity').get('value')/100;
        var strokeColor = dijit.byId('strokeColor').get('value');
        var strokeWidth = dijit.byId('strokeWidth').get('value');
        var strokeOpacity = dijit.byId('strokeOpacity').get('value')/100;
        var pointRadius = dijit.byId('pointRadius').get('value');
        
        var style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
        style.fillColor = fillColor;
        style.fillOpacity = fillOpacity;
        style.strokeColor = strokeColor;
        style.strokeWidth = strokeWidth;
        style.strokeOpacity = strokeOpacity;
        style.pointRadius = pointRadius;
        
        event.feature.style = style;
    }
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec03"/>How it works...</h3></div></div></div><p>The idea is, each time a feature is added to the layer using the EditingToolbar control, create a symbolizer and apply it to the new feature.<a class="indexterm" id="id306"/>
</p><p>The first step is to register a<code class="literal"> beforefeatureadded</code> event listener in the vector layer so that we are notified each time a new feature is going to be added:</p><div><pre class="programlisting">    vectorLayer.events.register('beforefeatureadded', vectorLayer, setFeatureStyle);
</pre></div><p>The function<code class="literal"> setFeatureStyle</code> is called every time a new feature is added. An<code class="literal"> event</code> parameter is passed on each call, pointing to the feature to be added (<code class="literal">event.feature</code>) and a reference to the vector layer (<code class="literal">event.object</code>).</p><div><h3 class="title"><a id="tip06"/>Tip</h3><p>The<code class="literal"> event.object</code> references the object passed as the<code class="literal"> object</code> parameter in the<code class="literal"> event.register(event_type, object, listener)</code> method.</p></div><div><pre class="programlisting">    function setFeatureStyle(event) {
        var fillColor = dijit.byId('fillColor').get('value');
        var fillOpacity = dijit.byId('fillOpacity').get('value')/100;
        var strokeColor = dijit.byId('strokeColor').get('value');
        var strokeWidth = dijit.byId('strokeWidth').get('value');
        var strokeOpacity = dijit.byId('strokeOpacity').get('value')/100;
        var pointRadius = dijit.byId('pointRadius').get('value');
        
        var style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style['default']);
        style.fillColor = fillColor;
        style.fillOpacity = fillOpacity;
        style.strokeColor = strokeColor;
        style.strokeWidth = strokeWidth;
        style.strokeOpacity = strokeOpacity;
        style.pointRadius = pointRadius;
        
        event.feature.style = style;
    }
</pre></div><p>Once we obtain the property values from the Dojo widgets, we create a new symbolizer.</p><p>The<code class="literal"> OpenLayers.Feature.Vector</code> class defines some style symbolizers in the<code class="literal"> style</code> array property, so the quickest way is to create a copy of one of those styles (actually we have extended it) and then modify some of its properties.<a class="indexterm" id="id308"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec04"/>There's more...</h3></div></div></div><p>The question that can arise here is: what takes precedence when styling, a rule applied to a vector layer or a symbolizer applied to a single feature?</p><p>The answer is: styles goes from bottom to top, that is, if we have specified a symbolizer in a feature then it will be used to render it, otherwise, any rule or StyleMap assigned to the vector layer will be applied to its features.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec05"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Improving style using StyleMap and the replacement of feature's attributes</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Playing with StyleMap and the render intents</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Improving style using StyleMap and the replacement of feature's attributes</h1></div></div></div><p>We can summarize that there are two ways to style a feature. The first is applying a symbolizer hash directly to the feature (see the<em> Styling features using symbolizers</em> recipe). The second is applying the style to the layer so every feature contained in it becomes styled.<a class="indexterm" id="id309"/>
</p><p>The second one is the preferred way in many situations. It is a generic way to style all the features in a layer by setting some styles and rules.</p><p>This recipe shows how we can use the<code class="literal"> StyleMap</code> instances and how easily we can style all the points of a layer without applying a style on each feature. The output of this recipe should look similar to the following screenshot:</p><div><img alt="Improving style using StyleMap and the replacement of feature's attributes" src="img/7843_07_02.jpg"/></div><p>In addition, the technique we will use allows us to involve the feature's attributes to select a point radius and color, creating them all together more dynamically.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec06"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Once we have created the HTML file with OpenLayers dependencies, start creating the<code class="literal"> div</code> element that will hold the map instance:<a class="indexterm" id="id310"/><div><pre class="programlisting">&lt;div id="ch07_styleMap" style="width: 100%; height: 95%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Now, create the map instance and add a base layer:<div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_styleMap");
    
    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);
    
    map.setCenter(new OpenLayers.LonLat(0,0), 2)
</pre></div></li><li class="listitem">Now, let's start defining the style for the whole layer. First create a color palette for the points:<div><pre class="programlisting">    // Create stylemap for the layer
    var colors = ['#EBC137','#E38C2D','#DB4C2C','#771E10','#48110C'];
</pre></div></li><li class="listitem">Create a style instance from a previous symbolizer hash:<div><pre class="programlisting">    var style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style["default"]);
    style.pointRadius = "${radius}";
    style.fillColor = '${colorFunction}';
    
    var defaultStyle = new OpenLayers.Style(style, {
        context: {
            colorFunction: function(feature) {
                return colors[feature.attributes.temp];
            }
        }
    });
</pre></div></li><li class="listitem">Create a vector layer applying the desired<code class="literal"> StyleMap:</code><div><pre class="programlisting">    // Create the vector layer
    var vectorLayer = new OpenLayers.Layer.Vector("Features", {
        styleMap: new OpenLayers.StyleMap(defaultStyle)
    });
    map.addLayer(vectorLayer);
</pre></div></li><li class="listitem">Finally, create some random points. Each feature will have two attributes<code class="literal"> radius</code> and<code class="literal"> temp</code> with random values:<a class="indexterm" id="id311"/><div><pre class="programlisting">    // Create random feature points.
    var pointFeatures = [];
    for(var i=0; i&lt; 150; i++) {
        var px = Math.random() * 360 - 180;
        var py = Math.random() * 170 - 85;
    
        // Create a lonlat instance and transform it to the map projection.
        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));
        
        var pointGeometry = new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
        var pointFeature = new OpenLayers.Feature.Vector(pointGeometry);
        
        // Add random attributes
        var radius = Math.round(Math.random() * 15 + 4);
        var temp = Math.round(Math.random() * 4);
        pointFeature.attributes.radius = radius;
        pointFeature.attributes.temp = temp;

        pointFeatures.push(pointFeature);
    }
    // Add features to the layer
    vectorLayer.addFeatures(pointFeatures); 

&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec07"/>How it works...</h3></div></div></div><p>Let's go to describe first the random point features we have added to the vector layer.<a class="indexterm" id="id312"/>
</p><p>The idea is to create some random points at random places. Because of this, we create some random x-y values, transform to map coordinates, create geometry, and finally create a feature with that geometry:</p><div><pre class="programlisting">        var px = Math.random() * 360 - 180;
        var py = Math.random() * 170 - 85;
    
        // Create a lonlat instance and transform it to the map projection.
        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new OpenLayers.Projection("EPSG:4326"), new OpenLayers.Projection("EPSG:900913"));
        
        var pointGeometry = new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
        var pointFeature = new OpenLayers.Feature.Vector(pointGeometry);
</pre></div><p>In addition, we are setting in each feature, a couple of attributes <code class="literal">(radius</code> and<code class="literal"> temp)</code> with random values:<a class="indexterm" id="id313"/>
</p><div><pre class="programlisting">        // Add random attributes
        var radius = Math.round(Math.random() * 15 + 4);
        var temp = Math.round(Math.random() * 4);
        pointFeature.attributes.radius = radius;
        pointFeature.attributes.temp = temp;
</pre></div><p>These attributes will be used later in the feature's style definition.<a class="indexterm" id="id314"/>
</p><p>Let's go to describe the creation of the style for the vector layer.</p><p>We want each feature to be represented as a point using the attribute<code class="literal"> radius</code> for the point's radius and the<code class="literal"> temp</code> attribute for the point's color.</p><p>The first step is to create a symbolizer by hash copying (actually extending) that is defined at<code class="literal"> OpenLayers.Feature.Vector.style["default"])</code>.</p><div><pre class="programlisting">    var style = OpenLayers.Util.extend({}, OpenLayers.Feature.Vector.style["default"]);
</pre></div><p>If you look at the source code you will find that<code class="literal"> OpenLayers.Feature.Vector.style["default"])</code> is defined as:</p><div><pre class="programlisting">{ 
    fillColor: "#ee9900", 
    fillOpacity: 0.4, 
    hoverFillColor: "white", 
    hoverFillOpacity: 0.8, 
    strokeColor: "#ee9900", 
    strokeOpacity: 1, 
    strokeWidth: 1, 
    strokeLinecap: "round", 
    strokeDashstyle: "solid", 
    hoverStrokeColor: "red", 
    hoverStrokeOpacity: 1, 
    hoverStrokeWidth: 0.2, 
    pointRadius: 6, 
    hoverPointRadius: 1, 
    hoverPointUnit: "%", 
    pointerEvents: "visiblePainted", 
    cursor: "inherit" 
}
</pre></div><p>Once we have a fresh copy of the symbolizer, we change the<code class="literal"> fillColor</code> and<code class="literal"> pointRadius</code> properties. What is the challenge here? Well, we do not want fixed values for these properties, we want these properties to take their values from the feature's attributes they are styling.<a class="indexterm" id="id315"/>
</p><p>Fortunately, OpenLayers helps us with the<strong> attribute replacement</strong> syntax. In the same way, we can write a literal value as follows:</p><div><pre class="programlisting">pointRadius: 15
</pre></div><p>We can specify that the radius value must come from the feature's<code class="literal"> featureRadius</code> attribute:</p><div><pre class="programlisting">pointRadius: '${featureRadius}'
</pre></div><p>So in our sample, our features have the attribute<code class="literal"> radius</code> defined as a random value that can be used here:</p><div><pre class="programlisting">    style.pointRadius = "${radius}";
</pre></div><p>In the same way as we can use an attribute to be replaced as the property value, we can also set a function which must return the value to be used as the property value. This is the case for the<code class="literal"> fillColor</code> property:</p><div><pre class="programlisting">    style.fillColor = '${colorFunction}';
</pre></div><p>As we will see next, the function<code class="literal"> colorFunction</code> returns a value depending on the feature's<code class="literal"> temp</code> attribute, that is, we do not want to use the<code class="literal"> temp</code> attribute directly but a value computed from it.</p><p>Unfortunately, attribute replacement cannot be used directly in a symbolizer hash applied to a feature or layer, it only works through an<code class="literal"> OpenLayers.Style</code> instance. In addition, thanks to the<code class="literal"> OpenLayers.Style</code> instance, we can define the functions, such as<code class="literal"> colorFunction</code> to be used to compute a style property value.</p><div><h3 class="title"><a id="note58"/>Note</h3><p>Attribute replacement can only be used through an<code class="literal"> OpenLayers.Style</code> instance.</p></div><p>In the recipe, once we define the symbolizer hash, we can create an instance as follows:<a class="indexterm" id="id316"/>
</p><div><pre class="programlisting">    var defaultStyle = new OpenLayers.Style(style, {
        context: {
            colorFunction: function(feature) {
                return colors[feature.attributes.temp];
            }
        }
    });
</pre></div><p>The first parameter is the symbolizer hash that has been previously defined, which makes use of the attribute's replacement feature. The second parameter, the<code class="literal"> context</code>, is an object passed in the process of rendering features. Here we define the required functions, such as the<code class="literal"> colorFunction</code> that will be available in the rendering process, and will define the value for the<code class="literal"> fillColor</code> depending on the<code class="literal"> temp</code> attribute of each feature.</p><p>At this point, we are almost done. The only remaining thing is to create a vector layer that uses the defined<code class="literal"> OpenLayers.Style</code> instance to style the features.</p><p>The<code class="literal"> OpenLayers.Layer.Vector</code> class has a<code class="literal"> styleMap</code> property used to specify the styles to apply to the features. The<code class="literal"> OpenLayers.StyleMap</code> class can be instantiated with passing a different argument, but here we are creating it using the previously defined<code class="literal"> OpenLayers.Style</code> style:</p><div><pre class="programlisting">    var vectorLayer = new OpenLayers.Layer.Vector("Features", {
        styleMap: new OpenLayers.StyleMap(defaultStyle)
    });
    map.addLayer(vectorLayer);
</pre></div><p>Now, our recipe is complete. As we can see, there is no need to create a symbolizer and apply it to each feature. The only thing we need to do is to define a style and assign it to the vector layer.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec08"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Playing with StyleMap and render intents</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Styling features using symbolizers</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Creating features programmatically</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em> Vector Layers</em><a class="indexterm" id="id317"/></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Playing with StyleMap and the render intents</h1></div></div></div><p>There are some controls, such as<code class="literal"> SelectFeature, ModifyFeature</code>, or<code class="literal"> EditingToolbar</code>, which change the style of the feature depending on its current state, that is, if it is selected or is currently being edited. How does OpenLayers manage this? The answer is, through the<strong> render intents:</strong>
<a class="indexterm" id="id318"/>
</p><div><img alt="Playing with StyleMap and the render intents" src="img/7843_07_03.jpg"/></div><p>This recipe shows how we can modify the styles used for each render intent to change the look of our applications.</p><p>This way, features will be drawn on the map using blue instead of orange. Temporary features, those that are going to be created, will be drawn using green. Finally, those features that are selected, or are in the middle of the modification process, will be drawn using orange.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec09"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Create a new HTML file and add the OpenLayers dependencies. The first step is to add the<code class="literal"> div</code> element to hold the map instance:<a class="indexterm" id="id319"/><div><pre class="programlisting">&lt;div id="ch07_rendering_intents" style="width: 100%; height: 95%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">In the JavaScript section, initialize the map instance, add a base layer, and center the viewport:<div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_rendering_intents");
    
    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);
    
    map.setCenter(new OpenLayers.LonLat(0,0), 2)
</pre></div></li><li class="listitem">Now we are going to create three different styles:<div><pre class="programlisting">    var defaultStyle = new OpenLayers.Style({
        fillColor: "#336699",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#003366",
        strokeOpacity: 0.8,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit"
    });
    var selectStyle = new OpenLayers.Style({
        fillColor: "#ffcc00",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.6,
        strokeColor: "#ff9900",
        strokeOpacity: 0.6,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer"
    });
    var temporaryStyle = new OpenLayers.Style({
        fillColor: "#587058",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#587498",
        strokeOpacity: 0.8,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit"
    });
</pre></div></li><li class="listitem">After this, create a<code class="literal"> StyleMap</code> instance that holds the three styles created as three different render intents:<a class="indexterm" id="id320"/><div><pre class="programlisting">    var styleMap = new OpenLayers.StyleMap({
        'default': defaultStyle,
        'select': selectStyle,
        'temporary': temporaryStyle
    });
</pre></div></li><li class="listitem">Now we can create a vector layer using the previous<code class="literal"> StyleMap</code> instance:<div><pre class="programlisting">    var vectorLayer = new OpenLayers.Layer.Vector("Features", {
        styleMap: styleMap
    });
    map.addLayer(vectorLayer);
</pre></div></li><li class="listitem">Finally, we are going to add some controls to the map to allow the addition of new features and modification of the existing ones:<a class="indexterm" id="id321"/><div><pre class="programlisting">    var editingControl = new OpenLayers.Control.EditingToolbar(vectorLayer);
    var modifyControl = new OpenLayers.Control.ModifyFeature(vectorLayer, {
        toggle: true
    });
    editingControl.addControls([modifyControl]);
    map.addControl(editingControl);
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec10"/>How it works...</h3></div></div></div><p>Every vector layer can have an<code class="literal"> OpenLayers.StyleMap</code> instance associated with it. On its own, a<code class="literal"> StyleMap</code> instance stores one or more references to the<code class="literal"> OpenLayers.Style</code> instances, each one of which acts as a render intent:<a class="indexterm" id="id322"/>
</p><div><pre class="programlisting">    var styleMap = new OpenLayers.StyleMap({
        'default': defaultStyle,
        'select': selectStyle,
        'temporary': temporaryStyle
    });
</pre></div><p>Every<code class="literal"> Style</code> instance stores information about a style, and usually they are created from a symbolizer hash, as in this recipe:</p><div><pre class="programlisting">    var defaultStyle = new OpenLayers.Style({
        fillColor: "#336699",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#003366",
        strokeOpacity: 0.8,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit"
    });
</pre></div><p>Here we have defined a new style for the three render intents:<code class="literal"> default, select</code>, and<code class="literal"> temporary</code>, which are well known render intents used by most of the controls.</p><p>A<code class="literal"> StyleMap</code> can store as many render intents as we desire, we are not limited to these three commonly used render intents. For example, we can define render intents such as<code class="literal"> red</code> or<code class="literal"> hidden</code>, and associate a<code class="literal"> Style</code> for them that renders features in red or not display them at all.<a class="indexterm" id="id323"/>
</p><div><h3 class="title"><a id="tip07"/>Tip</h3><p>By setting the property<code class="literal"> display</code> to<code class="literal">"none"</code> on the style's symbolizer hash, we can hide features. This is usually used in the<code class="literal"> delete</code> render intent.</p></div><p>The render intents such as<code class="literal"> default, select</code>, and<code class="literal"> temporary</code>, are used extensively by many components within OpenLayers. This way, when a feature is rendered, the<code class="literal"> default</code> style is used. When a feature is selected using the<code class="literal"> OpenLayers.Control.SelectFeature</code> control, the<code class="literal"> select</code> render intent is used to render the features. And when we are creating a new feature with<code class="literal"> OpenLayers.Control.EditingToolbar</code> (which internally uses<code class="literal"> OpenLayers.Control.DrawFeature)</code>, the control renders the feature using the style defined on the<code class="literal"> temporary</code> render intent.</p><p>So, creating new render intents is no problem. In addition, we can create our custom controls and let them decide which render intent the layer must use to render the features.</p><p>Finally, let's briefly describe the code used to create the panel with the controls.</p><p>First, we have created an<code class="literal"> OpenLayers.Control.EditingToolbar</code> instance:</p><div><pre class="programlisting">    var editingControl = new OpenLayers.Control.EditingToolbar(vectorLayer);
</pre></div><p>This is an<code class="literal"> OpenLayers.Control.Panel</code> control containing buttons that activates/deactivates some<code class="literal"> OpenLayers.Control.DrawFeature</code> controls. Next, we have created an<code class="literal"> OpenLayers.ControlModifyFeature</code> instance, which is a single control and we have added it to the EditingToolbar control so that it becomes visible as a new button:<a class="indexterm" id="id324"/>
</p><div><pre class="programlisting">    var modifyControl = new OpenLayers.Control.ModifyFeature(vectorLayer, {
        toggle: true
    });
    editingControl.addControls([modifyControl]);
</pre></div><div><img alt="How it works..." src="img/7843_07_04.jpg"/></div><p>In the screenshot, the<code class="literal"> ModifyFeature</code> control is represented by the cross icon.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec11"/>There's more...</h3></div></div></div><p>The process to style and render a feature is complex. The following lines summarize the main steps involved in the feature styling process.</p><p>For each feature, a vector layer must render the following:<a class="indexterm" id="id325"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The method<code class="literal"> OpenLayers.Layer.Vector.drawFeature(feature, style)</code> is called. It accepts two parameters: the<code class="literal"> feature</code> to be drawn and the<code class="literal"> style</code> to be used. It can be a symbolizer or a render intent string.</li><li class="listitem" style="list-style-type: disc">If the feature has a<code class="literal"> style</code> property, it is used to render the feature.</li><li class="listitem" style="list-style-type: disc">Otherwise, if the vector layer has a<code class="literal"> style</code> property, it is used to render the feature.</li><li class="listitem" style="list-style-type: disc">Otherwise, if the<code class="literal"> style</code> argument is provided and it is a style symbolizer, then it is used to render the feature.</li><li class="listitem" style="list-style-type: disc">If the<code class="literal"> style</code> is a render intent string, then a symbolizer is created from the<code class="literal"> Style</code> property associated to the render intent using the<code class="literal"> createSymbolizer</code> method. This is where feature attributes are merged within the symbolizer.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec12"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Styling features using symbolizers</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Improving style using StyleMap and the replacement of feature's attributes</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Working with unique value rules</h1></div></div></div><p>Usually, we do not only style features by what they represent, for example a city or a village, but we style depending on their attributes, such as the number of citizens, year of foundation, and number of squares.<a class="indexterm" id="id326"/>
</p><p>To help on these cases, OpenLayers offers us the possibility to define rules to decide how to style features. For example, we can define a rule that for all features of a city with a population greater than 100,000 a point with radius 20 and color brown can be rendered, while for cities with a population less than 100,000, a point with radius 10, color orange, and semi transparent can be rendered.</p><p>Beginning in the world of the rules, the concept of<em> unique value rules</em> are the simplest case we can find. The idea is simple, apply one style or another depending on the value of a feature's attribute.</p><p>In this recipe, we are going to load a GeoJSON file, with some cities of the world, and apply a rule that will set the radius of the points depending on the popularity rank attribute (the<code class="literal"> POP_RANK</code> attribute), as shown in the following screenshot:</p><div><img alt="Working with unique value rules" src="img/7843_07_05.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec13"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start creating a new HTML file and add the OpenLayers dependencies. Add a<code class="literal"> div</code> element to hold the map instance:<div><pre class="programlisting">&lt;div id="ch07_unique_value_rules" style="width: 100%; height: 95%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Within the<code class="literal"> script</code> element, add the required code to initialize the map and add a base layer:<a class="indexterm" id="id327"/><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_unique_value_rules");
    
    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);
    
    map.setCenter(new OpenLayers.LonLat(0,0), 4)
</pre></div></li><li class="listitem">Now define different styles to be used on the<code class="literal"> POP_RANK</code> feature's attribute:<div><pre class="programlisting">    var styles = {
      7: { pointRadius: 4, label: "${POP_RANK}" },
      6: { pointRadius: 7, label: "${POP_RANK}" },
      5: { pointRadius: 10, label: "${POP_RANK}" },
      4: { pointRadius: 13, label: "${POP_RANK}" },
      3: { pointRadius: 15, label: "${POP_RANK}" },
      2: { pointRadius: 18, label: "${POP_RANK}", fillColor: "yellow" },
      1: { pointRadius: 21, label: "${POP_RANK}", fillColor: "green" }
    };
</pre></div></li><li class="listitem">Create a<code class="literal"> StyleMap</code> instance and define a unique value rule:<div><pre class="programlisting">    var styleMap = new OpenLayers.StyleMap();
    styleMap.addUniqueValueRules("default", "POP_RANK", styles);
</pre></div></li><li class="listitem">Finally, add a vector layer with some cities of the world and make use of the previous<code class="literal"> StyleMap</code> instance:<div><pre class="programlisting">    map.addLayer(new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        styleMap: styleMap,
        strategies: [new OpenLayers.Strategy.Fixed()]
    }));
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec14"/>How it works...</h3></div></div></div><p>Almost all the magic of this recipe resides in the<code class="literal"> OpenLayers.StyleMap.addUniqueValueRules()</code> method. So, the sentence:<a class="indexterm" id="id328"/>
</p><div><pre class="programlisting">    styleMap.addUniqueValueRules("default", "POP_RANK", styles);
</pre></div><p>means, apply to the<code class="literal"> default</code> render intent the specified<code class="literal"> style</code> property, depending on the value of the<code class="literal"> POP_RANK</code> attribute.</p><p>It makes more sense once we look at the hash style. Depending on the value of the<code class="literal"> POP_RANK</code>, the radius of the points representing cities will vary between<code class="literal"> 4</code> and<code class="literal"> 21:</code>
</p><div><pre class="programlisting">    var styles = {
      7: { pointRadius: 4, label: "${POP_RANK}" },
      6: { pointRadius: 7, label: "${POP_RANK}" },
      5: { pointRadius: 10, label: "${POP_RANK}" },
      4: { pointRadius: 13, label: "${POP_RANK}" },
      3: { pointRadius: 15, label: "${POP_RANK}" },
      2: { pointRadius: 18, label: "${POP_RANK}", fillColor: "yellow" },
      1: { pointRadius: 21, label: "${POP_RANK}", fillColor: "green" }
    };
</pre></div><p>Finally, we have added to the map a vector layer that uses the previously created<code class="literal"> StyleMap</code> instance where the unique value rules are defined:</p><div><pre class="programlisting">    map.addLayer(new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        styleMap: styleMap,
        strategies: [new OpenLayers.Strategy.Fixed()]
    }));
</pre></div><p>In addition, the vector layer uses an<code class="literal"> OpenLayers.Protocol.HTTP</code> instance to load the GeoJSON file and an<code class="literal"> OpenLayers.Strategy.Fixed</code> instance is used to just load the source data once.<a class="indexterm" id="id329"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec15"/>There's more...</h3></div></div></div><p>The use of unique value rules through the<code class="literal"> addUniqueValueRules()</code> method is easy, but as we can understand, it works only for a discrete value range.</p><p>Also, the flexibility is poor because it is equivalent to an<em> is equal</em> rule, where we have no way to map a range of values to the same style.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec16"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Playing with StyleMap and the render intents</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Defining custom rules to style features</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Using point features as markers</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em> Vector Layers</em></li><li class="listitem" style="list-style-type: disc">The<em> Working with popups</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em> Vector Layers</em></li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Defining custom rules to style features</h1></div></div></div><p>We will see a brief explanation before continuing with this recipe. The goal, as in the other recipes in the chapter, is to style the features of a vector layer depending on their attributes' values or their kind of feature.<a class="indexterm" id="id330"/>
</p><p>So, an<code class="literal"> OpenLayers.Layer.Vector</code> layer class can have an<code class="literal"> OpenLayers.StyleMap</code> instance associated with it, which determines the default style of the layers if it has only one<code class="literal"> OpenLayers.Style</code>, or the set of styles that can be applied for each render intent if it contains more than one<code class="literal"> OpenLayers.Style</code>. In its own way, each<code class="literal"> OpenLayers.Style</code> instance can be used in two forms:<a class="indexterm" id="id331"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Having a symbolizer hash acting as the default style to apply to the features</li><li class="listitem" style="list-style-type: disc">Having some<code class="literal"> OpenLayers.Rule</code> instances associated with it</li></ul></div><p>Here we arrive to the main concept of this recipe, the<strong> rules.</strong>
</p><p>A rule is nothing more than a join between a filter (concretely an<code class="literal"> OpenLayers.Filter)</code> and a symbolizer, if the filter matches the feature then the symbolizer is applied.</p><p>This simple thing gives us lot of flexibilities and power to style our features. In addition to the possibility to use symbolizers with attribute replacement, we can also use the set of filters OpenLayers offers us: comparison filters, spatial filters, or logical filters.</p><p>The goal of this recipe is to load a GML file with European countries and style them depending on their<code class="literal"> AREA</code> attribute, as shown in the following screenshot:<a class="indexterm" id="id332"/>
</p><div><img alt="Defining custom rules to style features" src="img/7843_07_06.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec17"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Once created an HTML file with the OpenLayers dependencies, add the<code class="literal"> div</code> element to hold the map:<a class="indexterm" id="id333"/><div><pre class="programlisting">&lt;div id="ch07_custom_rules" style="width: 100%; height: 95%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">In the JavaScript code section, initialize the map, add OpenStreetMap as the base layer, and center the map at the desired place:<div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_custom_rules");
    
    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);

    map.setCenter(new OpenLayers.LonLat(40,50).transform(new OpenLayers.Projection("EPSG:4326"), 
    new OpenLayers.Projection("EPSG:900913")), 3);
</pre></div></li><li class="listitem">Now, define five different rules to style elements based on the<code class="literal"> AREA</code> attribute of the features. The following code has the rule to check if the value is less than 10,000:<div><pre class="programlisting">    var aRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Comparison({
            type: OpenLayers.Filter.Comparison.LESS_THAN,
            property: "AREA",
            value: 10000
        }),
        symbolizer: {
            fillColor: "#EBC137",
            fillOpacity: 0.5, 
            strokeColor: "black"
        }
    });
</pre></div></li><li class="listitem">The following code has the rule to check if the value is between 10,000 and 25,000:<a class="indexterm" id="id334"/><div><pre class="programlisting">    var bRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.GREATER_THAN,
                    property: "AREA",
                    value: 10000
                }),
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
                    property: "AREA",
                    value: 25000
                })
            ]
        }),
        symbolizer: {
            fillColor: "#E38C2D",
            fillOpacity: 0.7, 
            strokeColor: "black"
        }
    });
</pre></div></li><li class="listitem">The rule to check if the value is between 25,000 and 50,000:<a class="indexterm" id="id335"/><div><pre class="programlisting">    var cRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.GREATER_THAN,
                    property: "AREA",
                    value: 25000
                }),
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
                    property: "AREA",
                    value: 50000
                })
            ]
        }),
        symbolizer: {
            fillColor: "#DB4C2C",
            fillOpacity: 0.7, 
            strokeColor: "black"
        }
    });
</pre></div></li><li class="listitem">The rule to check if the value is between 50,000 and 100,000:<div><pre class="programlisting">    var dRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.GREATER_THAN,
                    property: "AREA",
                    value: 50000
                }),
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
                    property: "AREA",
                    value: 100000
                })
            ]
        }),
        symbolizer: {
            fillColor: "#771E10",
            fillOpacity: 0.7, 
            strokeColor: "black"
        }
    });
</pre></div></li><li class="listitem">And finally, the rule to check for values greater than 100,000:<a class="indexterm" id="id336"/><div><pre class="programlisting">    var eRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Comparison({
            type: OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
            property: "AREA",
            value: 100000
        }),
        symbolizer: {
            fillColor: "#48110C",
            fillOpacity: 0.7, 
            strokeColor: "black"
        }
    });
</pre></div></li><li class="listitem">Create the style with the customary rules defined previously:<div><pre class="programlisting">    var style = new OpenLayers.Style();
    style.addRules([aRule, bRule, cRule, dRule, eRule]);
</pre></div></li><li class="listitem">Finally, create a vector layer that loads the GML file and uses the previous style:<div><pre class="programlisting">    map.addLayer(new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/europe.gml",
            format: new OpenLayers.Format.GML()
        }),
        styleMap: new OpenLayers.StyleMap(style),
        strategies: [new OpenLayers.Strategy.Fixed()]
    }));
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec18"/>How it works...</h3></div></div></div><p>As we described at the beginning of the recipe, an<code class="literal"> OpenLayers.Style</code> instance admits a set of<code class="literal"> OpenLayers.Rule</code> instances to style the features.<a class="indexterm" id="id337"/>
</p><p>Given a rule, all the features that match the specified<code class="literal"> OpenLayers.Filter</code> are styled with the specified symbolizer hash, and thanks to the filters, we have enough flexibility to create the comparison or logical filters.</p><p>In the code, we have created five filters. Let's describe two of them.</p><p>The<code class="literal"> aRule</code> rule is formed by a comparison filter that matches all the features with an<code class="literal"> AREA</code> attribute having a value less than 10,000:</p><div><pre class="programlisting">    var aRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Comparison({
            type: OpenLayers.Filter.Comparison.LESS_THAN,
            property: "AREA",
            value: 10000
        }),
        symbolizer: {
            fillColor: "#EBC137",
            fillOpacity: 0.5, 
            strokeColor: "black"
        }
    });
</pre></div><p>The<code class="literal"> bRule</code> uses a more complex rule. In this case, it is a logical<code class="literal"> AND</code> filter composed of two comparison filters. It matches all the features to check whether their<code class="literal"> AREA</code> attribute is greater than 10,000 and less than or equal to 25,000:</p><div><pre class="programlisting">    var bRule = new OpenLayers.Rule({
        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.GREATER_THAN,
                    property: "AREA",
                    value: 10000
                }),
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
                    property: "AREA",
                    value: 25000
                })
            ]
        }),
        symbolizer: {
            fillColor: "#E38C2D",
            fillOpacity: 0.7, 
            strokeColor: "black"
        }
    });
</pre></div><p>Once we have created all the desired rules, we can create an<code class="literal"> OpenLayers.Style</code> instance:<a class="indexterm" id="id338"/>
</p><div><pre class="programlisting">    var style = new OpenLayers.Style();
    style.addRules([aRule, bRule, cRule, dRule, eRule]);
</pre></div><p>Then apply it to the vector layer:</p><div><pre class="programlisting">    map.addLayer(new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/europe.gml",
            format: new OpenLayers.Format.GML()
        }),
        styleMap: new OpenLayers.StyleMap(style),
        strategies: [new OpenLayers.Strategy.Fixed()]
    }));
</pre></div><div><h3 class="title"><a id="note59"/>Note</h3><p>We have created an<code class="literal"> OpenLayers.StyleMap</code> instance passing only one style and not a style for each desired render intent. This means there will be no render intents in the layer, or expressed in other words, all the render intents will be rendered with the same style.</p></div><p>Because the vector layer must read data from a GML file in our server, we have made use of an<code class="literal"> OpenLayers.Protocol.HTTP</code> instance that loads files from the specified URL and uses an instance in the<code class="literal"> OpenLayers.Format.GML</code> format to read it.</p><p>Finally, to center the map's viewport, we needed to transform the coordinates.</p><p>Because the base layer of the map is OpenStreetMap, this makes the map's projection to become EPSG:900913, while we are specifying the center location as latitude/longitude using the EPSG:4326. Because of this we need to make a transformation:<a class="indexterm" id="id339"/>
</p><div><pre class="programlisting">  map.setCenter(new OpenLayers.LonLat(40,50).transform(new OpenLayers.Projection("EPSG:4326"), 
    new OpenLayers.Projection("EPSG:900913")), 3);
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec19"/>There's more...</h3></div></div></div><p>In our code, we have created the style with the sentences:</p><div><pre class="programlisting">    var style = new OpenLayers.Style();
    style.addRules([aRule, bRule, cRule, dRule, eRule]);
</pre></div><p>But the<code class="literal"> OpenLayers.Style</code> constructor can accept two parameters: a symbolizer hash, to be used as the default style, and a set of options where we need to specify instance properties. With this in mind we can also instantiate the style as:</p><div><pre class="programlisting">    var style = new OpenLayers.Style({
        our_default_style
    }, {
        rules: [aRule, bRule, cRule, dRule, eRule]
    });
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec20"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Working with unique value rules</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Styling features using symbolizers</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Improving style using StyleMap and the replacement of feature's attributes</em> recipe</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec07"/>Styling clustered features</h1></div></div></div><p>When working with lots of feature points, it is common to use the cluster strategy to avoid overlapping of points and improve the rendering performance.<a class="indexterm" id="id340"/>
</p><p>In this recipe we are going to show how easy it is to style a vector layer using a cluster strategy:</p><div><img alt="Styling clustered features" src="img/7843_07_07.jpg"/></div><p>Our layer vector will read a GeoJSON file with some cities of the world. The style will have the following characteristics:<a class="indexterm" id="id341"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For each cluster we will show the number of contained features</li><li class="listitem" style="list-style-type: disc">The point radius and border will depend on the number of contained features, the more features within it, the greater the radius will be</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec21"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Start adding the<code class="literal"> div</code> element for the map:<div><pre class="programlisting">&lt;div id="ch07_cluster_number_style" style="width: 100%; height: 95%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Instantiate an<code class="literal"> OpenLayers.Map</code> instance:<div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch07_cluster_number_style");
</pre></div></li><li class="listitem">Add OpenStreetMap as the base layer and center the viewport:<div><pre class="programlisting">    var osm = new OpenLayers.Layer.OSM();
    map.addLayer(osm);
    
    map.setCenter(new OpenLayers.LonLat(0,20).transform(new OpenLayers.Projection("EPSG:4326"), 
    new OpenLayers.Projection("EPSG:900913")), 2);
</pre></div></li><li class="listitem">Load the data from a GeoJSON file and apply the desired style:<div><pre class="programlisting">    var cities = new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        strategies: [new OpenLayers.Strategy.Fixed(), new OpenLayers.Strategy.Cluster({distance: 25})],
        styleMap: new OpenLayers.StyleMap({
            'default': new OpenLayers.Style({
                strokeWidth: '${strokeFunction}',
                strokeOpacity: 0.5,
                strokeColor: "#88aaaa",
                fillColor: "#99CC55",
                fillOpacity: 0.5,
                pointRadius: '${radiusfunction}',
                label: "${count}",
                fontColor: "#ffffff"
            }, {
                context: {
                    strokeFunction: function(feature) {
                        var count = feature.attributes.count;
                        var stk = Math.max(0.1 * count, 1);
                        return stk;
                    },
                    radiusFunction: function(feature) {
                        var count = feature.attributes.count;
                        var radius = Math.max(0.60 * count, 7);
                        return radius;
                    }
                }
            })
        })
    });
    map.addLayer(cities);
&lt;/script&gt;
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec22"/>How it works...</h3></div></div></div><p>After creating the map instance and adding the base layer, we have centered the viewport. Note how we have translated the coordinates from EPSG:4326 (latitude/longitude) to EPSG:900913 used by the map (implicitly used by OpenStreetMap layer):<a class="indexterm" id="id343"/>
</p><div><pre class="programlisting">    map.setCenter(new OpenLayers.LonLat(0,20).transform(new OpenLayers.Projection("EPSG:4326"), 
    new OpenLayers.Projection("EPSG:900913")), 2);
</pre></div><p>Next, we have added the vector layer:</p><div><pre class="programlisting">    var cities = new OpenLayers.Layer.Vector("World Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        strategies: [new OpenLayers.Strategy.Fixed(), new OpenLayers.Strategy.Cluster({distance: 25})],
        styleMap: new OpenLayers.StyleMap({
            'default': ...
        })
    });
</pre></div><p>To load the GeoJSON file from our server, we have used an<code class="literal"> OpenLayers.Protocol.HTTP</code> instance with the<code class="literal"> OpenLayers.Format.GeoJSON</code> format to read it.</p><p>For layer strategies, we have specified the<code class="literal"> OpenLayers.Strategy.Fixed</code> to load the content once and the<code class="literal"> OpenLayers.Strategy.Cluster({distance: 25})</code> sentence to group features. The property<code class="literal"> distance</code> sets the pixel distance that defines where two features must go into the same cluster.</p><p>At this point and, before continuing with the recipe, we need to describe how the clustering process works.</p><p>When the layer is going to be rendered, the clustering algorithm checks for each feature if they are too close to other ones. For each set of features that are too close, a new point (cluster) is created and rendered. This way the number of points to draw on the map can be reduced drastically. In addition, each cluster point feature will contain references to the set of features it represents and also a<code class="literal"> count</code> attribute with the number of features it contains.</p><p>Returning to our code, let's see the style applied to the layer, which is the most important thing in the recipe.<a class="indexterm" id="id344"/>
</p><p>First, we have set the style for the<code class="literal"> default</code> rendering intent:</p><div><pre class="programlisting">        styleMap: new OpenLayers.StyleMap({
            'default': ...
        })
</pre></div><p>This means if we use some control that changes the render intent of the layer to something different from the default, the style will probably be different.</p><div><h3 class="title"><a id="note60"/>Note</h3><p>If we create the<code class="literal"> OpenLayers.StyleMap</code> instance without passing directly the style instance, that is, without specifying a render intent, then the style will be the same for any render intent:<code class="literal"> new OpenLayers.StyleMap(our_style_here)</code>.</p></div><p>Now, let's look at the<code class="literal"> OpenLayers.Style</code> instance defined for the layer:</p><div><pre class="programlisting">new OpenLayers.Style({ 
    strokeWidth: '${strokeFunction}', 
    strokeOpacity: 0.5, 
    strokeColor: "#88aaaa", 
    fillColor: "#99CC55", 
    fillOpacity: 0.5, 
    pointRadius: '${radiusfunction}', 
    label: "${count}", 
    fontColor: "#ffffff" 
}, { 
    context: { 
        strokeFunction: function(feature) { 
            var count = feature.attributes.count; 
            var stk = Math.max(0.1 * count, 1); 
            return stk; 
        }, 
        radiusFunction: function(feature) { 
            var count = feature.attributes.count; 
            var radius = Math.max(0.60 * count, 7); 
            return radius; 
        } 
    } 
})
</pre></div><p>The constructor receives two parameters: a symbolizer hash, which defines the style properties, and a set of options.</p><p>In the symbolizer hash, we have used the attribute replacement feature:</p><div><pre class="programlisting">    strokeWidth: '${strokeFunction}', 
    ...
    pointRadius: '${radiusfunction}', 
    label: "${count}", 
    ....
</pre></div><p>The<code class="literal"> count</code> attribute is taken from the cluster point feature attributes, as we explained previously.<a class="indexterm" id="id345"/>
</p><p>On the other hand, the<code class="literal"> strokeFunction</code> and<code class="literal"> radiusFunction</code> are not attributes, but functions which are defined in the<code class="literal"> context</code> property of the<code class="literal"> OpenLayers.Style</code> options. All the symbolizer properties are evaluated against the<code class="literal"> context</code> object. So, each of the functions receives a feature reference every time the layer is going to be rendered.</p><p>In the case of<code class="literal"> radiusFunction</code>, it computes the radius for the point depending on the<code class="literal"> count</code> attribute, returning the maximum value between the range of 60 percent of<code class="literal"> count</code> or<code class="literal"> 7:</code>
</p><div><pre class="programlisting">        radiusFunction: function(feature) { 
            var count = feature.attributes.count; 
            var radius = Math.max(0.60 * count, 7); 
            return radius; 
        } 
</pre></div><p>As we can see, the use of context is powerful enough to allow us to set style properties dynamically and dependence on other feature attributes.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec23"/>See also</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<em> Improving style using StyleMap and the replacement of feature's attributes</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Defining custom rules to style features</em> recipe</li><li class="listitem" style="list-style-type: disc">The<em> Using the cluster strategy</em> recipe in<a class="link" href="ch03.html" title="Chapter 3. Working with Vector Layers"> Chapter 3</a>, <em> Vector Layers</em></li></ul></div></div></div></div></body></html>