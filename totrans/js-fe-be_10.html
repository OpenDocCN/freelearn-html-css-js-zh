<html><head></head><body>
		<div><h1 id="_idParaDest-139"><em class="italic"><a id="_idTextAnchor138"/>Chapter 7</em>: Using Express with Node.js</h1>
			<p>We saw in the previous chapter that a program for the Node.js server is an assembly of different modules. Many modules have been created by Node.js developers, which can be inserted into our programs using the <code>npm</code> utility (see <a href="B17416_06_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Using Node.js Modules</em>). One of these modules is called <strong class="bold">Express</strong>. It is one of the most used modules with Node.js because it allows you to structure server programs according to the <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) model.</p>
			<p>In this chapter, we’ll study how to create a Node.js application while respecting the characteristics of the MVC model by using the Express module.</p>
			<p>Here are the topics we will cover:</p>
			<ul>
				<li>Using the Node.js <code>http</code> module</li>
				<li>Installing the Express module</li>
				<li>The MVC pattern used by Express</li>
				<li>Using routes with Express</li>
				<li>Displaying views with Express</li>
			</ul>
			<p>Node.js integrates into its internal modules the possibility to create a web server using the <code>http</code> module internal to Node.js. We first explain how to use this <code>http</code> module, and then we will see the contribution that the external Express module makes to more easily create a web application built according to the MVC model.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%207.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%207.zip</a>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Using the Node.js http module</h1>
			<p>The <code>http</code> module is<a id="_idIndexMarker507"/> an internal Node.js module. It is, therefore, directly accessible in our programs using the <code>require("http")</code> instruction. With this module you can create a web server based on the HTTP protocol and thus display web pages in an internet browser.</p>
			<p>For creating a web server based on HTTP, we use the <code>http.createServer(callback)</code> method of the <code>http</code> module. The callback function indicated as a parameter is of the form <code>callback(req, res)</code>, in which <code>req</code> corresponds to the request received, and <code>res</code> corresponds to the response to be sent to the browser. Depending on the request received, the corresponding response will be sent.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the <code>req</code> parameter, there is, among other things, the URL of the request received, thus making it possible to return, via the <code>res</code> parameter, the correct response to the browser according to this request.</p>
			<p>Let’s see in the following program how to use the <code>createServer()</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating a web server using the http module (test.js file)</p>
			<pre class="source-code">var http = require("http");</pre>
			<pre class="source-code">var server = http.createServer(function(req, res) {</pre>
			<pre class="source-code">  // display the received request in the console</pre>
			<pre class="source-code">  console.log("Request received:", req.url);</pre>
			<pre class="source-code">  // indicate that the response is HTML in utf-8</pre>
			<pre class="source-code">  res.setHeader("Content-type", "text/html; charset=utf-8");</pre>
			<pre class="source-code">  // we always send the same response, regardless of the </pre>
			<pre class="source-code">  // request received</pre>
			<pre class="source-code">  res.write("&lt;h1&gt;")</pre>
			<pre class="source-code">  res.write("Good morning all");</pre>
			<pre class="source-code">  res.write("&lt;/h1&gt;");</pre>
			<pre class="source-code">  res.end();</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// make the server listen on port 3000 (for example)</pre>
			<pre class="source-code">server.listen(3000);</pre>
			<pre class="source-code">console.log("\nThe server was started on port 3000\n");</pre>
			<pre class="source-code">console.log("You can make a request on:");</pre>
			<pre class="source-code">console.log("<code>http://localhost:3000</code>");</pre>
			<p>The <code>createServer()</code> method<a id="_idIndexMarker508"/> returns an object, here used through the variable named <code>server</code>, on which we indicate to wait for requests coming from port <code>3000</code> (the one indicated in the <code>server.listen(port)</code> method). This means that each time URLs of the form <code>http://localhost:3000</code> are accessed via the browser, the program previously launched (with the <code>node test.js</code> command) will be activated and will display the result in the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use of the <code>server.listen(port)</code> method is mandatory because it is not enough to create a server with the <code>http.createServer()</code> method. This server must also be listening (with <code>server.listen(port )</code>) to HTTP requests addressed to it by browsers connecting to this server (here using a URL such as <code>http://localhost:3000</code>). Port <code>3000</code> is used here, but another port number could be used (provided that this port is not already used by another server, which would cause an access conflict to know to which server the request on the port is addressed).</p>
			<p>We send the response to the browser using <code>res.write(string)</code> instructions. You must finish sending the response with the <code>res.end()</code> instruction, which means that the browser has received all <a id="_idIndexMarker509"/>the elements to display (the server waits to receive the <code>res.end()</code> instruction to display all the elements sent).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>res.setHeader()</code> method is used to set HTTP header fields. Here, <code>"Content-type"</code> is set to the value <code>"text/html; charset=utf-8"</code>.</p>
			<p>Let’s launch the previous program by typing the command <code>node test.js</code>. The program displays a message, then waits for HTTP requests on port <code>3000</code>:</p>
			<div><div><img src="img/Figure_7.01_B17416.jpg" alt="Figure 7.1 – HTTP server waiting on port 3000&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – HTTP server waiting on port 3000</p>
			<p>To test the program, display the URL beginning with <code>http://localhost:3000</code> in a browser. When an HTTP request uses port <code>3000</code> (the port on which the server is listening), the callback function indicated in the <code>createServer(callback)</code> method is activated and then the response is sent to the browser.</p>
			<p>Let’s type the URL <code>http://localhost:3000</code> in the browser (see the following figure):</p>
			<div><div><img src="img/Figure_7.02_B17416.jpg" alt="Figure 7.2 – Viewing URL http://localhost:3000 in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Viewing URL http://localhost:3000 in the browser</p>
			<p>Regardless of the URL specified in the browser ( which uses port <code>3000</code>), the display in the browser remains the same. For the display to be different for different URLs, it must be considered in<a id="_idIndexMarker510"/> the callback function by using the value of <code>req.url</code>, which contains the URL typed and returns different strings according to the request received.</p>
			<p>Using the Express module makes it easy to manage the different requests received and display different results depending on the URL entered.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Installing the Express module</h1>
			<p>Since the Express<a id="_idIndexMarker511"/> module is installed using npm, we type the <code>npm install express </code>command to install it.</p>
			<div><div><img src="img/Figure_7.03_B17416.jpg" alt="Figure 7.3 – Installing the Express module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">. </p>
			<p class="figure-caption">Figure 7.3 – Installing the Express module with npm</p>
			<p>The Express module<a id="_idIndexMarker512"/> is now installed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A utility related to Express is also useful for creating the architecture of our web applications. This is the <code>"express-generator"</code> module (this module was previously included with Express but is now separate from it, hence it’s uploaded here).</p>
			<p>Let’s also install the <code>"express-generator"</code> module using the <code>npm install express-generator -g</code> command. We use the <code>-g</code> option so that the <code>express</code> command defined in this module is accessible from any directory.</p>
			<div><div><img src="img/Figure_7.04_B17416.jpg" alt="Figure 7.4 – Installing the &quot;express-generator&quot; module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Installing the “express-generator” module with npm</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can verify that the installation is correct by typing the command <code>express -h</code>. If the installation of the module is correct, help for the <code>express</code> command is displayed in the window (otherwise an error is displayed).</p>
			<p>Once these two <a id="_idIndexMarker513"/>modules are installed, you can create a first web application based on Express.</p>
			<p>To do this, type the <code>express apptest</code> command to create the application named <code>apptest</code>. You should see the following result:</p>
			<div><div><img src="img/Figure_7.05_B17416.jpg" alt="Figure 7.5 – Creating the apptest application with Express&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Creating the apptest application with Express</p>
			<p>This command <a id="_idIndexMarker514"/>creates an <code>apptest</code> directory containing the basic files to run the application. You must then type the three commands indicated at the end of the display: <code>cd apptest</code>, <code>npm install</code>, and <code>npm start</code>.</p>
			<p>Once these commands are typed, open a browser and display the URL <code>http://localhost:3000</code>.</p>
			<p>This is what you will see:</p>
			<div><div><img src="img/Figure_7.06_B17416.jpg" alt="Figure 7.6 – Default app home page created with Express&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Default app home page created with Express</p>
			<p>If we look at the source files of the application created in the <code>apptest</code> directory, we see the <code>app.js</code> and <code>package.json</code> files, as well as the <code>bin</code>, <code>node_modules</code>, <code>public</code>, <code>routes</code>, and <code>views</code> directories. These directories are those that describe the MVC architecture <a id="_idIndexMarker515"/>used by Express, which we explain below.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>The MVC pattern used by Express</h1>
			<p>The MVC model is an<a id="_idIndexMarker516"/> application architecture model allowing an application to be <a id="_idIndexMarker517"/>broken down into different parts: models, views, and the controller:</p>
			<ul>
				<li>Models <a id="_idIndexMarker518"/>correspond to the data manipulated by the application. In general, this is data from databases. Node.js is closely tied to the MongoDB database, which is explored in the next chapter.</li>
				<li>Views correspond to the visualization of data, for example, input forms and displayed lists. Each<a id="_idIndexMarker519"/> display corresponds to a view that will be in the <code>views</code> directory of the application.</li>
				<li>The controller allows<a id="_idIndexMarker520"/> navigation between the different views, depending on the data. For this, we use routes (in fact, URLs) that<a id="_idIndexMarker521"/> indicate the processing to be performed. The <code>routes</code> directory describes the routes used by the application (and the processing performed for each of them).</li>
			</ul>
			<p>We can therefore see that the MVC model makes it possible to separate the processing, the display, and the data. This <a id="_idIndexMarker522"/>split is widely used in web projects and is the one proposed by Express.</p>
			<p>Let’s first look at how routing works in Express. This corresponds to the controller part of the MVC model.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Using routes with Express</h1>
			<p>Routes indicate the<a id="_idIndexMarker523"/> processing to be performed based on the requested<a id="_idIndexMarker524"/> URL. Compared to what we wrote when using the <code>http</code> module of Node.js with the <code>createServer(callback)</code> method, this consists of writing the content of the <code>callback(req, res)</code> function according to the <code>req</code> request received.</p>
			<p>The routes are described in the <code>app.js</code> file, which is the main file created by Express. Let’s examine its content.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>The initial content of the app.js file</h2>
			<p>To understand how <a id="_idIndexMarker525"/>routes work in Express, open the <code>app.js</code> file located<a id="_idIndexMarker526"/> in the main application directory, and you will see the content of this file, like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.js file</p>
			<pre class="source-code">var createError = require('http-errors');</pre>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var path = require('path');</pre>
			<pre class="source-code">var cookieParser = require('cookie-parser');</pre>
			<pre class="source-code">var logger = require('morgan');</pre>
			<pre class="source-code">var indexRouter = require('./routes/index');</pre>
			<pre class="source-code">var usersRouter = require('./routes/users');</pre>
			<pre class="source-code">var app = express();</pre>
			<pre class="source-code">// view engine setup</pre>
			<pre class="source-code">app.set('views', path.join(__dirname, 'views'));</pre>
			<pre class="source-code">app.set('view engine', 'jade');</pre>
			<pre class="source-code">app.use(logger('dev'));</pre>
			<pre class="source-code">app.use(express.json());</pre>
			<pre class="source-code">app.use(express.urlencoded({ extended: false }));</pre>
			<pre class="source-code">app.use(cookieParser());</pre>
			<pre class="source-code">app.use(express.static(path.join(__dirname, 'public')));</pre>
			<pre class="source-code">app.use('/', indexRouter);</pre>
			<pre class="source-code">app.use('/users', usersRouter);</pre>
			<pre class="source-code">// catch 404 and forward to error handler</pre>
			<pre class="source-code">app.use(function(req, res, next) {</pre>
			<pre class="source-code">  next(createError(404));</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// error handler</pre>
			<pre class="source-code">app.use(function(err, req, res, next) {</pre>
			<pre class="source-code">  // set locals, only providing error in development</pre>
			<pre class="source-code">  res.locals.message = err.message;</pre>
			<pre class="source-code">  res.locals.error = req.app.get('env') === 'development' ? </pre>
			<pre class="source-code">  err : {};</pre>
			<pre class="source-code">  // render the error page</pre>
			<pre class="source-code">  res.status(err.status || 500);</pre>
			<pre class="source-code">  res.render('error');</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = app;</pre>
			<p>This file describes how the application built with Express works. It uses the <code>app</code> variable, which is the return from the <code>express()</code> function call and symbolizes the application. On this <code>app</code> object, the <code>use()</code> method is used many times, which makes it possible to add processing to be <a id="_idIndexMarker527"/>performed for each request received on the server.</p>
			<p>For example, <code>app.use(logger("dev"))</code> triggers the <code>logger()</code> function for each request received on the server. This is why the server console displays the URL that was requested in<a id="_idIndexMarker528"/> the browser during each request to the server.</p>
			<p>By having displayed in the browser the URLs <code>http://localhost:3000</code> and <code>http://localhost:3000/users</code>, we obtain the following in the server console.</p>
			<div><div><img src="img/Figure_7.07_B17416.jpg" alt="Figure 7.7 – Display of URLs in the server console&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Display of URLs in the server console</p>
			<p>Now, let’s look at <a id="_idIndexMarker529"/>the meaning of the lines<a id="_idIndexMarker530"/> displayed in the server console.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Different types of routes possible</h2>
			<p>In the previous figure, you’ll <a id="_idIndexMarker531"/>notice that the word <code>GET</code> is <a id="_idIndexMarker532"/>displayed in front of each URL: <code>GET /</code><code>, GET</code><code>/users</code>.</p>
			<p>The word <code>GET</code> means that the URL <code>/</code> or <code>/users</code> is accessed by an HTTP request of the <code>GET</code> type. The <code>GET</code> type is the one used when the accessed URL is displayed in the address bar of the browser, for example, when you type it directly or when you click on a link on a page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other types of HTTP requests exist. They make it possible not to display the corresponding URL in the address bar of the browser, and thus to hide it from users. For example, if the URL for deleting records from the database was visible in the browser’s address bar, it would suffice to refresh the page to continue deleting records from the database. Hence the interest in other types of HTTP requests that allow the current URL to be hidden.</p>
			<p>The other types of HTTP requests (in addition to <code>GET</code>) are mainly <code>PUT</code>, <code>POST</code>, and <code>DELETE</code> type requests. These types of requests are used in programs to signify an action to be performed on one or more<a id="_idIndexMarker533"/> pieces of data (called resources):</p>
			<ul>
				<li><code>GET</code> means reading a resource.</li>
				<li><code>POST</code> means creating a resource.</li>
				<li><code>PUT</code> means updating a resource.</li>
				<li><code>DELETE</code> means deleting a resource.</li>
			</ul>
			<p>Although multiple types of HTTP requests exist, these are the main ones. They are used to manipulate <a id="_idIndexMarker534"/>resources, allowing them to be created (<code>POST</code>), updated (<code>PUT</code>), deleted (<code>DELETE</code>), and read (<code>GET</code>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A route is the association of an HTTP request with a URL. For example, the <code>GET /users</code> route associates the <code>/users </code>URL with the <code>HTTP GET</code> request, while the <code>DELETE /users</code> route associates the same <code>/users </code>URL with the <code>HTTP DELETE</code> request. Although these routes use the same URL, they are different routes because the HTTP requests are different.</p>
			<p>Now that we’ve seen<a id="_idIndexMarker535"/> the different types of HTTP requests used, let’s look at how Express uses them internally.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Analyzing routes defined in the app.js file</h2>
			<p>The <code>app.use()</code> method is also <a id="_idIndexMarker536"/>used to define<a id="_idIndexMarker537"/> new routes, that is, to define the processing <a id="_idIndexMarker538"/>that will be performed for each new URL used (with the associated request type).</p>
			<p>The <code>app.use(url, callback)</code> method is used to define the processing to be performed when the specified URL is activated. As the type of request is not indicated here, all types of requests will activate the treatment indicated in the callback function. To indicate the type of request, you must use methods similar to <code>app.use()</code>. These are the <code>app.get()</code>, <code>app.put()</code>, <code>app.post()</code>, and <code>app.delete()</code> methods.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The callback function of the form <code>callback(req, res, next)</code> returns the response to the browser. The <code>next()</code> parameter corresponds to a function to be called at the end of the callback if the processing must continue in the next callback function (if the processing to be performed is handled by multiple callback functions).</p>
			<p>The routes already <a id="_idIndexMarker539"/>defined in <code>app.js</code> are <code>/</code> and <code>/users</code>, thus making it possible to run the processes associated with these routes. These routes are examples to show how to implement routes in the <code>app.js</code> file. The <a id="_idIndexMarker540"/>processing instructions are defined in the <code>indexRouter</code> and <code>usersRouter</code> functions. These functions are the variables<a id="_idIndexMarker541"/> used in return for the instructions <code>require('./routes/index')</code> and <code>require('./routes/users')</code>. The processing of routes is therefore done here in the <code>index.js</code> and <code>users.js</code> files defined in the <code>routes</code> directory.</p>
			<p>Let’s open these two files and analyze their contents:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">/* GET home page. */</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.render('index', { title: 'Express' });</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">users.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">/* GET users listing. */</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.send('respond with a resource');</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>Each of these files uses the <code>router.get(url, callback)</code> method, meaning that the route is associated with the <code>/</code> (it will be concatenated with the URL given in the <code>app.js</code> file), followed by the callback function of the form <code>callback(req, res, next)</code>. The <code>next</code> parameter corresponds to a function to call if the processing<a id="_idIndexMarker542"/> must continue in the callback function that follows (if such a function<a id="_idIndexMarker543"/> exists, which is not the case here).</p>
			<p>The processing <a id="_idIndexMarker544"/>performed in each of the callback functions consists of sending the response, which will be displayed in the browser. Here, we use the <code>res.send()</code> and <code>res.render()</code> methods, which allow the response to be sent:</p>
			<ul>
				<li>The <code>res.send()</code> method is similar to <code>res.end()</code> (defined in the <code>"http"</code> module of Node.js), but also allows you to indicate that you are using HTML and <code>res.send()</code> method must be made in the processing, otherwise, an error occurs.</li>
				<li>The <code>res.render()</code> method allows an external file (called a view) to be displayed. Views are written in a special language that depends on the format of the view. By default, the views used by Express are JADE files, but it is possible to use other formats.</li>
			</ul>
			<p>Here, the view displayed by the <code>res.render()</code> method corresponds to the <code>index.jade</code> file located in the <code>views</code> directory. Its contents are as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.jade file (views directory)</p>
			<pre class="source-code">extends layout</pre>
			<pre class="source-code">block content</pre>
			<pre class="source-code">  h1= title</pre>
			<pre class="source-code">  p Welcome to #{title}</pre>
			<p>This file is written using a <a id="_idIndexMarker545"/>particular syntax, called JADE. The file will be transformed into HTML code by <a id="_idIndexMarker546"/>Express before being sent to the browser (which can only interpret HTML).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Express allows files associated with <a id="_idIndexMarker547"/>views to be written using a variety of syntaxes. The most common<a id="_idIndexMarker548"/> are <strong class="bold">JADE</strong> and <strong class="bold">EJS</strong>.</p>
			<p class="callout">We will explore the JADE syntax in the <em class="italic">Displaying views with Express</em> section in this chapter.</p>
			<p>Note that the <code>app.js</code> file allows<a id="_idIndexMarker549"/> you to configure the directory associated with the views and the syntax used in the views. Here are the corresponding instructions from the <code>app.js</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Configuring views (app.js file)</p>
			<pre class="source-code">app.set('views', path.join(__dirname, 'views'));</pre>
			<pre class="source-code">app.set('view engine', 'jade');</pre>
			<p>We have described the routes already listed in the <code>app.js</code> file. Let’s see how to create new routes in this file.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Adding a new route in the app.js file</h2>
			<p>Adding a new<a id="_idIndexMarker550"/> route in the <code>app.js</code> file can be done either by writing the processing directly in the <code>app.js</code> file or by creating an external file that will be in the <code>routes</code> directory.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Any modification of the <code>app.js</code> file requires restarting the server by performing the <code>npm start</code> command; otherwise, the modifications are not taken into account.</p>
			<p>Let’s look at these two ways to create a new route.</p>
			<h3>Adding route processing directly in the app.js file</h3>
			<p>Let’s add the <code>/clients</code> route <a id="_idIndexMarker551"/>activated following a <code>app.get()</code> method to define the route:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Add the GET /clients route</p>
			<pre class="source-code">app.use('/', indexRouter);</pre>
			<pre class="source-code">app.use('/users', usersRouter);</pre>
			<pre class="source-code"><strong class="bold">app.get("/clients", function(req, res, next) {</strong></pre>
			<pre class="source-code"><strong class="bold">  res.send("&lt;h1&gt;Client list&lt;/h1&gt;");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>The result is displayed in the following figure (<em class="italic">Figure 7.8</em>).</p>
			<h3>Creating an external file to define route processing</h3>
			<p>We use the same <a id="_idIndexMarker552"/>principle as that used for the <code>GET /</code> and <code>GET /users</code> routes defined in the <code>app.js</code> file. We create the <code>clients.js</code> file in the <code>routes</code> directory, which will be included in the <code>app.js</code> file by means of the statement <code>clientsRouter = require("./routes/clients)</code>. The route is defined in <code>app.js</code> with the statement <code>app.use("/clients", clientsRouter)</code>.</p>
			<p>The <code>clients.js</code> file describing the processing performed on the route is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.send("&lt;h1&gt;Client list&lt;/h1&gt;");</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>In both cases, the result is<a id="_idIndexMarker553"/> the same, as seen in the following figure.</p>
			<div><div><img src="img/Figure_7.08_B17416.jpg" alt="Figure 7.8 – Displaying the GET /clients route&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Displaying the GET /clients route</p>
			<p>We studied the controller part of the MVC model using the route system defined in Express. Now let’s see how<a id="_idIndexMarker554"/> Express allows us to manage the view part of the MVC model.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Displaying views with Express</h1>
			<p>A view is an external file <a id="_idIndexMarker555"/>used to describe the display that you want to view. Specific <a id="_idIndexMarker556"/>syntaxes have been created to program the view, for example, JADE or EJS syntaxes.</p>
			<p>The <code>res.render(name, obj)</code> method is used to display the <code>name</code> view using any properties provided in the <code>obj</code> object. The view is a file defined in the <code>views</code> directory using JADE syntax or another.</p>
			<p>One of the features of Express is to allow you to create views using the desired syntax. The JADE syntax is offered as standard by Express, but other syntax support libraries can be added with <code>npm</code>.</p>
			<p>The JADE syntax is, therefore, the one used by default in Express. It makes it possible to replace HTML tags with their tag (for example <code>&lt;h1&gt;</code> simply becomes <code>h1</code>), and the indentation of tags in the code makes it possible to specify their nesting. It is also no longer necessary to close the tag previously opened because the indentation allows you to see the nesting of the tags.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Full JADE documentation can be found at <a href="https://jade-lang.com/">https://jade-lang.com/</a>.</p>
			<p>Let’s use JADE to display the previous client list. We create the <code>clients.jade</code> view in the <code>views</code> directory, and we indicate in <code>clients.js</code> that we display this view when accessing the <code>GET /clients</code> route:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  <strong class="bold">res.render("clients");   // display clients.jade view </strong></pre>
			<pre class="source-code"><strong class="bold">                           // (.jade extension is enabled by </strong></pre>
			<pre class="source-code"><strong class="bold">                           // default)</strong></pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>Note that if you do <a id="_idIndexMarker557"/>not indicate the file extension of the view (for example, by writing <code>res.render("clients")</code>), the extension used will be the one indicated in the<a id="_idIndexMarker558"/> instruction <code>app.set('view engine' , 'jade')</code> from <code>app.js</code>.</p>
			<p>If, on the other hand, you specify an extension to the view file, it will be the one used to display the view even if it is different from the one configured in <code>app.js</code>. The view <code>clients.jade</code> is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code">  li Bill Clinton</pre>
			<pre class="source-code">  li Barack Obama</pre>
			<pre class="source-code">  li Joe Biden</pre>
			<p>Notice the indentation of the tags. The <code>ul</code> tag is at the same level as the <code>h1</code> tag, otherwise, it would be seen as included in the <code>h1</code> tag. The <code>li</code> tags are shifted to the right to show their inclusion in the preceding <code>ul</code> tag. The offset must be at least one character. Because of the offsets, we do not use a closing tag as in HTML.</p>
			<p>Let’s restart the server with <code>npm start</code> because one of the routing files has been modified.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Editing files associated with views does not require a server restart, unlike the <code>app.js</code> file and files associated with routes (in the <code>routes</code> directory).</p>
			<p>Once the server restarts, let’s display the URL <code>http://localhost:3000</code> again:</p>
			<div><div><img src="img/Figure_7.09_B17416.jpg" alt="Figure 7.9 – View displayed using JADE syntax&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – View displayed using JADE syntax</p>
			<p>The list of clients is, in<a id="_idIndexMarker559"/> this example, entered directly into the JADE view. It is better to<a id="_idIndexMarker560"/> pass it as parameters using the second parameter of the <code>res.render(name, obj)</code> method. The <code>clients.js</code> file then becomes the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code"> <strong class="bold"> res.render("clients", { </strong></pre>
			<pre class="source-code"><strong class="bold">    clients : [</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Bill", lastname : "Clinton" },</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Barack", lastname : "Obama" },</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Joe", lastname : "Biden" },</strong></pre>
			<pre class="source-code"><strong class="bold">    ]</strong></pre>
			<pre class="source-code"><strong class="bold">  });</strong></pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>The <code>obj</code> parameter of the <code>res.render("clients", obj)</code> method is an object containing the list<a id="_idIndexMarker561"/> of clients.</p>
			<p>The <code>clients.jade</code> view <a id="_idIndexMarker562"/>uses this passed object as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code"><strong class="bold">  li #{clients[0].lastname + " " + clients[0].firstname}</strong></pre>
			<pre class="source-code"><strong class="bold">  li #{clients[1].lastname + " " + clients[1].firstname}</strong></pre>
			<pre class="source-code"><strong class="bold">  li #{clients[2].lastname + " " + clients[2].firstname}</strong></pre>
			<p>The <code>obj</code> object passed in parameters is used in the JADE view, by using its <code>clients</code> property here.</p>
			<p class="callout-heading">JADE Syntax</p>
			<p class="callout">JavaScript statements can be used in the JADE view by surrounding them with<code> #{ </code>and<code> }</code>. Anything between these two markers will be considered JavaScript code.</p>
			<p>You can also use a syntax simplification allowed by JADE, by writing the <code>=</code> sign directly after each <code>li</code> tag. This means that everything following on the line must be interpreted in JavaScript. We can use this simplification of writing here.</p>
			<p>Let’s write the <code>clients.jade</code> view as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code"><strong class="bold">  li= clients[0].lastname + " " + clients[0].firstname</strong></pre>
			<pre class="source-code"><strong class="bold">  li= clients[1].lastname + " " + clients[1].firstname</strong></pre>
			<pre class="source-code"><strong class="bold">  li= clients[2].lastname + " " + clients[2].firstname</strong></pre>
			<p>Rather than listing <a id="_idIndexMarker563"/>each element of the <code>clients</code> array in the view, you can also <a id="_idIndexMarker564"/>perform a loop using the <code>each</code> statement of the JADE syntax to iterate over a JavaScript array.</p>
			<p>The <code>clients.jade</code> view therefore becomes the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code">  each client in clients</pre>
			<pre class="source-code">    li= client.lastname + " " + client.firstname</pre>
			<p>The writing of the view is simplified, but you really have to take into account the indentations of the lines otherwise the view will not be displayed.</p>
			<div><div><img src="img/Figure_7.10_B17416.jpg" alt="Figure 7.10 – List of clients displayed by the each statement&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – List of clients displayed by the each statement</p>
			<p>We see in this <a id="_idIndexMarker565"/>example that the JADE syntax makes it easy to display lists <a id="_idIndexMarker566"/>of data in the views of the application.</p>
			<p>With this, we come to the end of this chapter.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Summary</h1>
			<p>The Express module makes it possible to structure your application efficiently by allowing (thanks to the MVC model it uses) you to separate the management of routes, the views displayed, and the management of data.</p>
			<p>We have explained how to write the views of the application using the JADE syntax provided by default by Express. Other syntaxes, for example, the EJS syntax, are also available by downloading them via <code>npm</code>. </p>
			<p>We have also seen the importance of the <code>app.js</code> file created by Express, and the use of HTTP requests such as <strong class="bold">GET</strong>, <strong class="bold">POST</strong>, <strong class="bold">PUT</strong>, and <strong class="bold">DELETE</strong>. We will see in <a href="B17416_09_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a>, <em class="italic">Integrating Vue.js with Node.js</em>, the importance of these HTTP requests to build a MEVN application (short for MongoDB, Express, Vue.js, Node.js) that manipulates the MongoDB database.</p>
			<p>Indeed, data management is often done using the <strong class="bold">MongoDB</strong> database, the use of which we will explore in the next chapter.</p>
		</div>
	</body></html>