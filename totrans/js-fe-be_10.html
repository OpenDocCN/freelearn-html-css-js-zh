<html><head></head><body>
		<div id="_idContainer142">
			<h1 id="_idParaDest-139"><em class="italic"><a id="_idTextAnchor138"/>Chapter 7</em>: Using Express with Node.js</h1>
			<p>We saw in the previous chapter that a program for the Node.js server is an assembly of different modules. Many modules have been created by Node.js developers, which can be inserted into our programs using the <strong class="source-inline">npm</strong> utility (see <a href="B17416_06_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Using Node.js Modules</em>). One of these modules is called <strong class="bold">Express</strong>. It is one of the most used modules with Node.js because it allows you to structure server programs according to the <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) model.</p>
			<p>In this chapter, we’ll study how to create a Node.js application while respecting the characteristics of the MVC model by using the Express module.</p>
			<p>Here are the topics we will cover:</p>
			<ul>
				<li>Using the Node.js <strong class="source-inline">http</strong> module</li>
				<li>Installing the Express module</li>
				<li>The MVC pattern used by Express</li>
				<li>Using routes with Express</li>
				<li>Displaying views with Express</li>
			</ul>
			<p>Node.js integrates into its internal modules the possibility to create a web server using the <strong class="source-inline">http</strong> module internal to Node.js. We first explain how to use this <strong class="source-inline">http</strong> module, and then we will see the contribution that the external Express module makes to more easily create a web application built according to the MVC model.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%207.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%207.zip</a>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Using the Node.js http module</h1>
			<p>The <strong class="source-inline">http</strong> module is<a id="_idIndexMarker507"/> an internal Node.js module. It is, therefore, directly accessible in our programs using the <strong class="source-inline">require("http")</strong> instruction. With this module you can create a web server based on the HTTP protocol and thus display web pages in an internet browser.</p>
			<p>For creating a web server based on HTTP, we use the <strong class="source-inline">http.createServer(callback)</strong> method of the <strong class="source-inline">http</strong> module. The callback function indicated as a parameter is of the form <strong class="source-inline">callback(req, res)</strong>, in which <strong class="source-inline">req</strong> corresponds to the request received, and <strong class="source-inline">res</strong> corresponds to the response to be sent to the browser. Depending on the request received, the corresponding response will be sent.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the <strong class="source-inline">req</strong> parameter, there is, among other things, the URL of the request received, thus making it possible to return, via the <strong class="source-inline">res</strong> parameter, the correct response to the browser according to this request.</p>
			<p>Let’s see in the following program how to use the <strong class="source-inline">createServer()</strong> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating a web server using the http module (test.js file)</p>
			<pre class="source-code">var http = require("http");</pre>
			<pre class="source-code">var server = http.createServer(function(req, res) {</pre>
			<pre class="source-code">  // display the received request in the console</pre>
			<pre class="source-code">  console.log("Request received:", req.url);</pre>
			<pre class="source-code">  // indicate that the response is HTML in utf-8</pre>
			<pre class="source-code">  res.setHeader("Content-type", "text/html; charset=utf-8");</pre>
			<pre class="source-code">  // we always send the same response, regardless of the </pre>
			<pre class="source-code">  // request received</pre>
			<pre class="source-code">  res.write("&lt;h1&gt;")</pre>
			<pre class="source-code">  res.write("Good morning all");</pre>
			<pre class="source-code">  res.write("&lt;/h1&gt;");</pre>
			<pre class="source-code">  res.end();</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// make the server listen on port 3000 (for example)</pre>
			<pre class="source-code">server.listen(3000);</pre>
			<pre class="source-code">console.log("\nThe server was started on port 3000\n");</pre>
			<pre class="source-code">console.log("You can make a request on:");</pre>
			<pre class="source-code">console.log("<strong class="source-inline">http://localhost:3000</strong>");</pre>
			<p>The <strong class="source-inline">createServer()</strong> method<a id="_idIndexMarker508"/> returns an object, here used through the variable named <strong class="source-inline">server</strong>, on which we indicate to wait for requests coming from port <strong class="source-inline">3000</strong> (the one indicated in the <strong class="source-inline">server.listen(port)</strong> method). This means that each time URLs of the form <strong class="source-inline">http://localhost:3000</strong> are accessed via the browser, the program previously launched (with the <strong class="source-inline">node test.js</strong> command) will be activated and will display the result in the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The use of the <strong class="source-inline">server.listen(port)</strong> method is mandatory because it is not enough to create a server with the <strong class="source-inline">http.createServer()</strong> method. This server must also be listening (with <strong class="source-inline">server.listen(port )</strong>) to HTTP requests addressed to it by browsers connecting to this server (here using a URL such as <strong class="source-inline">http://localhost:3000</strong>). Port <strong class="source-inline">3000</strong> is used here, but another port number could be used (provided that this port is not already used by another server, which would cause an access conflict to know to which server the request on the port is addressed).</p>
			<p>We send the response to the browser using <strong class="source-inline">res.write(string)</strong> instructions. You must finish sending the response with the <strong class="source-inline">res.end()</strong> instruction, which means that the browser has received all <a id="_idIndexMarker509"/>the elements to display (the server waits to receive the <strong class="source-inline">res.end()</strong> instruction to display all the elements sent).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">res.setHeader()</strong> method is used to set HTTP header fields. Here, <strong class="source-inline">"Content-type"</strong> is set to the value <strong class="source-inline">"text/html; charset=utf-8"</strong>.</p>
			<p>Let’s launch the previous program by typing the command <strong class="source-inline">node test.js</strong>. The program displays a message, then waits for HTTP requests on port <strong class="source-inline">3000</strong>:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/Figure_7.01_B17416.jpg" alt="Figure 7.1 – HTTP server waiting on port 3000&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – HTTP server waiting on port 3000</p>
			<p>To test the program, display the URL beginning with <strong class="source-inline">http://localhost:3000</strong> in a browser. When an HTTP request uses port <strong class="source-inline">3000</strong> (the port on which the server is listening), the callback function indicated in the <strong class="source-inline">createServer(callback)</strong> method is activated and then the response is sent to the browser.</p>
			<p>Let’s type the URL <strong class="source-inline">http://localhost:3000</strong> in the browser (see the following figure):</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_7.02_B17416.jpg" alt="Figure 7.2 – Viewing URL http://localhost:3000 in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Viewing URL http://localhost:3000 in the browser</p>
			<p>Regardless of the URL specified in the browser ( which uses port <strong class="source-inline">3000</strong>), the display in the browser remains the same. For the display to be different for different URLs, it must be considered in<a id="_idIndexMarker510"/> the callback function by using the value of <strong class="source-inline">req.url</strong>, which contains the URL typed and returns different strings according to the request received.</p>
			<p>Using the Express module makes it easy to manage the different requests received and display different results depending on the URL entered.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor141"/>Installing the Express module</h1>
			<p>Since the Express<a id="_idIndexMarker511"/> module is installed using npm, we type the <strong class="source-inline">npm install express </strong>command to install it.</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_7.03_B17416.jpg" alt="Figure 7.3 – Installing the Express module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">. </p>
			<p class="figure-caption">Figure 7.3 – Installing the Express module with npm</p>
			<p>The Express module<a id="_idIndexMarker512"/> is now installed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A utility related to Express is also useful for creating the architecture of our web applications. This is the <strong class="source-inline">"express-generator"</strong> module (this module was previously included with Express but is now separate from it, hence it’s uploaded here).</p>
			<p>Let’s also install the <strong class="source-inline">"express-generator"</strong> module using the <strong class="source-inline">npm install express-generator -g</strong> command. We use the <strong class="source-inline">-g</strong> option so that the <strong class="source-inline">express</strong> command defined in this module is accessible from any directory.</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_7.04_B17416.jpg" alt="Figure 7.4 – Installing the &quot;express-generator&quot; module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Installing the “express-generator” module with npm</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can verify that the installation is correct by typing the command <strong class="source-inline">express -h</strong>. If the installation of the module is correct, help for the <strong class="source-inline">express</strong> command is displayed in the window (otherwise an error is displayed).</p>
			<p>Once these two <a id="_idIndexMarker513"/>modules are installed, you can create a first web application based on Express.</p>
			<p>To do this, type the <strong class="source-inline">express apptest</strong> command to create the application named <strong class="source-inline">apptest</strong>. You should see the following result:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_7.05_B17416.jpg" alt="Figure 7.5 – Creating the apptest application with Express&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Creating the apptest application with Express</p>
			<p>This command <a id="_idIndexMarker514"/>creates an <strong class="source-inline">apptest</strong> directory containing the basic files to run the application. You must then type the three commands indicated at the end of the display: <strong class="source-inline">cd apptest</strong>, <strong class="source-inline">npm install</strong>, and <strong class="source-inline">npm start</strong>.</p>
			<p>Once these commands are typed, open a browser and display the URL <strong class="source-inline">http://localhost:3000</strong>.</p>
			<p>This is what you will see:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_7.06_B17416.jpg" alt="Figure 7.6 – Default app home page created with Express&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Default app home page created with Express</p>
			<p>If we look at the source files of the application created in the <strong class="source-inline">apptest</strong> directory, we see the <strong class="source-inline">app.js</strong> and <strong class="source-inline">package.json</strong> files, as well as the <strong class="source-inline">bin</strong>, <strong class="source-inline">node_modules</strong>, <strong class="source-inline">public</strong>, <strong class="source-inline">routes</strong>, and <strong class="source-inline">views</strong> directories. These directories are those that describe the MVC architecture <a id="_idIndexMarker515"/>used by Express, which we explain below.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>The MVC pattern used by Express</h1>
			<p>The MVC model is an<a id="_idIndexMarker516"/> application architecture model allowing an application to be <a id="_idIndexMarker517"/>broken down into different parts: models, views, and the controller:</p>
			<ul>
				<li>Models <a id="_idIndexMarker518"/>correspond to the data manipulated by the application. In general, this is data from databases. Node.js is closely tied to the MongoDB database, which is explored in the next chapter.</li>
				<li>Views correspond to the visualization of data, for example, input forms and displayed lists. Each<a id="_idIndexMarker519"/> display corresponds to a view that will be in the <strong class="source-inline">views</strong> directory of the application.</li>
				<li>The controller allows<a id="_idIndexMarker520"/> navigation between the different views, depending on the data. For this, we use routes (in fact, URLs) that<a id="_idIndexMarker521"/> indicate the processing to be performed. The <strong class="source-inline">routes</strong> directory describes the routes used by the application (and the processing performed for each of them).</li>
			</ul>
			<p>We can therefore see that the MVC model makes it possible to separate the processing, the display, and the data. This <a id="_idIndexMarker522"/>split is widely used in web projects and is the one proposed by Express.</p>
			<p>Let’s first look at how routing works in Express. This corresponds to the controller part of the MVC model.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Using routes with Express</h1>
			<p>Routes indicate the<a id="_idIndexMarker523"/> processing to be performed based on the requested<a id="_idIndexMarker524"/> URL. Compared to what we wrote when using the <strong class="source-inline">http</strong> module of Node.js with the <strong class="source-inline">createServer(callback)</strong> method, this consists of writing the content of the <strong class="source-inline">callback(req, res)</strong> function according to the <strong class="source-inline">req</strong> request received.</p>
			<p>The routes are described in the <strong class="source-inline">app.js</strong> file, which is the main file created by Express. Let’s examine its content.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>The initial content of the app.js file</h2>
			<p>To understand how <a id="_idIndexMarker525"/>routes work in Express, open the <strong class="source-inline">app.js</strong> file located<a id="_idIndexMarker526"/> in the main application directory, and you will see the content of this file, like this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">app.js file</p>
			<pre class="source-code">var createError = require('http-errors');</pre>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var path = require('path');</pre>
			<pre class="source-code">var cookieParser = require('cookie-parser');</pre>
			<pre class="source-code">var logger = require('morgan');</pre>
			<pre class="source-code">var indexRouter = require('./routes/index');</pre>
			<pre class="source-code">var usersRouter = require('./routes/users');</pre>
			<pre class="source-code">var app = express();</pre>
			<pre class="source-code">// view engine setup</pre>
			<pre class="source-code">app.set('views', path.join(__dirname, 'views'));</pre>
			<pre class="source-code">app.set('view engine', 'jade');</pre>
			<pre class="source-code">app.use(logger('dev'));</pre>
			<pre class="source-code">app.use(express.json());</pre>
			<pre class="source-code">app.use(express.urlencoded({ extended: false }));</pre>
			<pre class="source-code">app.use(cookieParser());</pre>
			<pre class="source-code">app.use(express.static(path.join(__dirname, 'public')));</pre>
			<pre class="source-code">app.use('/', indexRouter);</pre>
			<pre class="source-code">app.use('/users', usersRouter);</pre>
			<pre class="source-code">// catch 404 and forward to error handler</pre>
			<pre class="source-code">app.use(function(req, res, next) {</pre>
			<pre class="source-code">  next(createError(404));</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// error handler</pre>
			<pre class="source-code">app.use(function(err, req, res, next) {</pre>
			<pre class="source-code">  // set locals, only providing error in development</pre>
			<pre class="source-code">  res.locals.message = err.message;</pre>
			<pre class="source-code">  res.locals.error = req.app.get('env') === 'development' ? </pre>
			<pre class="source-code">  err : {};</pre>
			<pre class="source-code">  // render the error page</pre>
			<pre class="source-code">  res.status(err.status || 500);</pre>
			<pre class="source-code">  res.render('error');</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = app;</pre>
			<p>This file describes how the application built with Express works. It uses the <strong class="source-inline">app</strong> variable, which is the return from the <strong class="source-inline">express()</strong> function call and symbolizes the application. On this <strong class="source-inline">app</strong> object, the <strong class="source-inline">use()</strong> method is used many times, which makes it possible to add processing to be <a id="_idIndexMarker527"/>performed for each request received on the server.</p>
			<p>For example, <strong class="source-inline">app.use(logger("dev"))</strong> triggers the <strong class="source-inline">logger()</strong> function for each request received on the server. This is why the server console displays the URL that was requested in<a id="_idIndexMarker528"/> the browser during each request to the server.</p>
			<p>By having displayed in the browser the URLs <strong class="source-inline">http://localhost:3000</strong> and <strong class="source-inline">http://localhost:3000/users</strong>, we obtain the following in the server console.</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_7.07_B17416.jpg" alt="Figure 7.7 – Display of URLs in the server console&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Display of URLs in the server console</p>
			<p>Now, let’s look at <a id="_idIndexMarker529"/>the meaning of the lines<a id="_idIndexMarker530"/> displayed in the server console.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Different types of routes possible</h2>
			<p>In the previous figure, you’ll <a id="_idIndexMarker531"/>notice that the word <strong class="source-inline">GET</strong> is <a id="_idIndexMarker532"/>displayed in front of each URL: <strong class="source-inline">GET /</strong><strong class="source-inline">, GET</strong><strong class="bold"> </strong><strong class="source-inline">/users</strong>.</p>
			<p>The word <strong class="source-inline">GET</strong> means that the URL <strong class="source-inline">/</strong> or <strong class="source-inline">/users</strong> is accessed by an HTTP request of the <strong class="source-inline">GET</strong> type. The <strong class="source-inline">GET</strong> type is the one used when the accessed URL is displayed in the address bar of the browser, for example, when you type it directly or when you click on a link on a page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Other types of HTTP requests exist. They make it possible not to display the corresponding URL in the address bar of the browser, and thus to hide it from users. For example, if the URL for deleting records from the database was visible in the browser’s address bar, it would suffice to refresh the page to continue deleting records from the database. Hence the interest in other types of HTTP requests that allow the current URL to be hidden.</p>
			<p>The other types of HTTP requests (in addition to <strong class="source-inline">GET</strong>) are mainly <strong class="source-inline">PUT</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong> type requests. These types of requests are used in programs to signify an action to be performed on one or more<a id="_idIndexMarker533"/> pieces of data (called resources):</p>
			<ul>
				<li><strong class="source-inline">GET</strong> means reading a resource.</li>
				<li><strong class="source-inline">POST</strong> means creating a resource.</li>
				<li><strong class="source-inline">PUT</strong> means updating a resource.</li>
				<li><strong class="source-inline">DELETE</strong> means deleting a resource.</li>
			</ul>
			<p>Although multiple types of HTTP requests exist, these are the main ones. They are used to manipulate <a id="_idIndexMarker534"/>resources, allowing them to be created (<strong class="source-inline">POST</strong>), updated (<strong class="source-inline">PUT</strong>), deleted (<strong class="source-inline">DELETE</strong>), and read (<strong class="source-inline">GET</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A route is the association of an HTTP request with a URL. For example, the <strong class="source-inline">GET /users</strong> route associates the <strong class="source-inline">/users </strong>URL with the <strong class="source-inline">HTTP GET</strong> request, while the <strong class="source-inline">DELETE /users</strong> route associates the same <strong class="source-inline">/users </strong>URL with the <strong class="source-inline">HTTP DELETE</strong> request. Although these routes use the same URL, they are different routes because the HTTP requests are different.</p>
			<p>Now that we’ve seen<a id="_idIndexMarker535"/> the different types of HTTP requests used, let’s look at how Express uses them internally.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Analyzing routes defined in the app.js file</h2>
			<p>The <strong class="source-inline">app.use()</strong> method is also <a id="_idIndexMarker536"/>used to define<a id="_idIndexMarker537"/> new routes, that is, to define the processing <a id="_idIndexMarker538"/>that will be performed for each new URL used (with the associated request type).</p>
			<p>The <strong class="source-inline">app.use(url, callback)</strong> method is used to define the processing to be performed when the specified URL is activated. As the type of request is not indicated here, all types of requests will activate the treatment indicated in the callback function. To indicate the type of request, you must use methods similar to <strong class="source-inline">app.use()</strong>. These are the <strong class="source-inline">app.get()</strong>, <strong class="source-inline">app.put()</strong>, <strong class="source-inline">app.post()</strong>, and <strong class="source-inline">app.delete()</strong> methods.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The callback function of the form <strong class="source-inline">callback(req, res, next)</strong> returns the response to the browser. The <strong class="source-inline">next()</strong> parameter corresponds to a function to be called at the end of the callback if the processing must continue in the next callback function (if the processing to be performed is handled by multiple callback functions).</p>
			<p>The routes already <a id="_idIndexMarker539"/>defined in <strong class="source-inline">app.js</strong> are <strong class="source-inline">/</strong> and <strong class="source-inline">/users</strong>, thus making it possible to run the processes associated with these routes. These routes are examples to show how to implement routes in the <strong class="source-inline">app.js</strong> file. The <a id="_idIndexMarker540"/>processing instructions are defined in the <strong class="source-inline">indexRouter</strong> and <strong class="source-inline">usersRouter</strong> functions. These functions are the variables<a id="_idIndexMarker541"/> used in return for the instructions <strong class="source-inline">require('./routes/index')</strong> and <strong class="source-inline">require('./routes/users')</strong>. The processing of routes is therefore done here in the <strong class="source-inline">index.js</strong> and <strong class="source-inline">users.js</strong> files defined in the <strong class="source-inline">routes</strong> directory.</p>
			<p>Let’s open these two files and analyze their contents:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">/* GET home page. */</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.render('index', { title: 'Express' });</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">users.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">/* GET users listing. */</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.send('respond with a resource');</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>Each of these files uses the <strong class="source-inline">router.get(url, callback)</strong> method, meaning that the route is associated with the <strong class="bold">GET</strong> type request. The URL given is <strong class="source-inline">/</strong> (it will be concatenated with the URL given in the <strong class="source-inline">app.js</strong> file), followed by the callback function of the form <strong class="source-inline">callback(req, res, next)</strong>. The <strong class="source-inline">next</strong> parameter corresponds to a function to call if the processing<a id="_idIndexMarker542"/> must continue in the callback function that follows (if such a function<a id="_idIndexMarker543"/> exists, which is not the case here).</p>
			<p>The processing <a id="_idIndexMarker544"/>performed in each of the callback functions consists of sending the response, which will be displayed in the browser. Here, we use the <strong class="source-inline">res.send()</strong> and <strong class="source-inline">res.render()</strong> methods, which allow the response to be sent:</p>
			<ul>
				<li>The <strong class="source-inline">res.send()</strong> method is similar to <strong class="source-inline">res.end()</strong> (defined in the <strong class="source-inline">"http"</strong> module of Node.js), but also allows you to indicate that you are using HTML and <strong class="bold">utf-8</strong> characters. Only one call to the <strong class="source-inline">res.send()</strong> method must be made in the processing, otherwise, an error occurs.</li>
				<li>The <strong class="source-inline">res.render()</strong> method allows an external file (called a view) to be displayed. Views are written in a special language that depends on the format of the view. By default, the views used by Express are JADE files, but it is possible to use other formats.</li>
			</ul>
			<p>Here, the view displayed by the <strong class="source-inline">res.render()</strong> method corresponds to the <strong class="source-inline">index.jade</strong> file located in the <strong class="source-inline">views</strong> directory. Its contents are as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.jade file (views directory)</p>
			<pre class="source-code">extends layout</pre>
			<pre class="source-code">block content</pre>
			<pre class="source-code">  h1= title</pre>
			<pre class="source-code">  p Welcome to #{title}</pre>
			<p>This file is written using a <a id="_idIndexMarker545"/>particular syntax, called JADE. The file will be transformed into HTML code by <a id="_idIndexMarker546"/>Express before being sent to the browser (which can only interpret HTML).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Express allows files associated with <a id="_idIndexMarker547"/>views to be written using a variety of syntaxes. The most common<a id="_idIndexMarker548"/> are <strong class="bold">JADE</strong> and <strong class="bold">EJS</strong>.</p>
			<p class="callout">We will explore the JADE syntax in the <em class="italic">Displaying views with Express</em> section in this chapter.</p>
			<p>Note that the <strong class="source-inline">app.js</strong> file allows<a id="_idIndexMarker549"/> you to configure the directory associated with the views and the syntax used in the views. Here are the corresponding instructions from the <strong class="source-inline">app.js</strong> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Configuring views (app.js file)</p>
			<pre class="source-code">app.set('views', path.join(__dirname, 'views'));</pre>
			<pre class="source-code">app.set('view engine', 'jade');</pre>
			<p>We have described the routes already listed in the <strong class="source-inline">app.js</strong> file. Let’s see how to create new routes in this file.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>Adding a new route in the app.js file</h2>
			<p>Adding a new<a id="_idIndexMarker550"/> route in the <strong class="source-inline">app.js</strong> file can be done either by writing the processing directly in the <strong class="source-inline">app.js</strong> file or by creating an external file that will be in the <strong class="source-inline">routes</strong> directory.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Any modification of the <strong class="source-inline">app.js</strong> file requires restarting the server by performing the <strong class="source-inline">npm start</strong> command; otherwise, the modifications are not taken into account.</p>
			<p>Let’s look at these two ways to create a new route.</p>
			<h3>Adding route processing directly in the app.js file</h3>
			<p>Let’s add the <strong class="source-inline">/clients</strong> route <a id="_idIndexMarker551"/>activated following a <strong class="bold">GET</strong> type request. It displays the list of clients. We use the <strong class="source-inline">app.get()</strong> method to define the route:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Add the GET /clients route</p>
			<pre class="source-code">app.use('/', indexRouter);</pre>
			<pre class="source-code">app.use('/users', usersRouter);</pre>
			<pre class="source-code"><strong class="bold">app.get("/clients", function(req, res, next) {</strong></pre>
			<pre class="source-code"><strong class="bold">  res.send("&lt;h1&gt;Client list&lt;/h1&gt;");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>The result is displayed in the following figure (<em class="italic">Figure 7.8</em>).</p>
			<h3>Creating an external file to define route processing</h3>
			<p>We use the same <a id="_idIndexMarker552"/>principle as that used for the <strong class="source-inline">GET /</strong> and <strong class="source-inline">GET /users</strong> routes defined in the <strong class="source-inline">app.js</strong> file. We create the <strong class="source-inline">clients.js</strong> file in the <strong class="source-inline">routes</strong> directory, which will be included in the <strong class="source-inline">app.js</strong> file by means of the statement <strong class="source-inline">clientsRouter = require("./routes/clients)</strong>. The route is defined in <strong class="source-inline">app.js</strong> with the statement <strong class="source-inline">app.use("/clients", clientsRouter)</strong>.</p>
			<p>The <strong class="source-inline">clients.js</strong> file describing the processing performed on the route is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  res.send("&lt;h1&gt;Client list&lt;/h1&gt;");</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>In both cases, the result is<a id="_idIndexMarker553"/> the same, as seen in the following figure.</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/Figure_7.08_B17416.jpg" alt="Figure 7.8 – Displaying the GET /clients route&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Displaying the GET /clients route</p>
			<p>We studied the controller part of the MVC model using the route system defined in Express. Now let’s see how<a id="_idIndexMarker554"/> Express allows us to manage the view part of the MVC model.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Displaying views with Express</h1>
			<p>A view is an external file <a id="_idIndexMarker555"/>used to describe the display that you want to view. Specific <a id="_idIndexMarker556"/>syntaxes have been created to program the view, for example, JADE or EJS syntaxes.</p>
			<p>The <strong class="source-inline">res.render(name, obj)</strong> method is used to display the <strong class="source-inline">name</strong> view using any properties provided in the <strong class="source-inline">obj</strong> object. The view is a file defined in the <strong class="source-inline">views</strong> directory using JADE syntax or another.</p>
			<p>One of the features of Express is to allow you to create views using the desired syntax. The JADE syntax is offered as standard by Express, but other syntax support libraries can be added with <strong class="source-inline">npm</strong>.</p>
			<p>The JADE syntax is, therefore, the one used by default in Express. It makes it possible to replace HTML tags with their tag (for example <strong class="source-inline">&lt;h1&gt;</strong> simply becomes <strong class="source-inline">h1</strong>), and the indentation of tags in the code makes it possible to specify their nesting. It is also no longer necessary to close the tag previously opened because the indentation allows you to see the nesting of the tags.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Full JADE documentation can be found at <a href="https://jade-lang.com/">https://jade-lang.com/</a>.</p>
			<p>Let’s use JADE to display the previous client list. We create the <strong class="source-inline">clients.jade</strong> view in the <strong class="source-inline">views</strong> directory, and we indicate in <strong class="source-inline">clients.js</strong> that we display this view when accessing the <strong class="source-inline">GET /clients</strong> route:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code">  <strong class="bold">res.render("clients");   // display clients.jade view </strong></pre>
			<pre class="source-code"><strong class="bold">                           // (.jade extension is enabled by </strong></pre>
			<pre class="source-code"><strong class="bold">                           // default)</strong></pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>Note that if you do <a id="_idIndexMarker557"/>not indicate the file extension of the view (for example, by writing <strong class="source-inline">res.render("clients")</strong>), the extension used will be the one indicated in the<a id="_idIndexMarker558"/> instruction <strong class="source-inline">app.set('view engine' , 'jade')</strong> from <strong class="source-inline">app.js</strong>.</p>
			<p>If, on the other hand, you specify an extension to the view file, it will be the one used to display the view even if it is different from the one configured in <strong class="source-inline">app.js</strong>. The view <strong class="source-inline">clients.jade</strong> is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code">  li Bill Clinton</pre>
			<pre class="source-code">  li Barack Obama</pre>
			<pre class="source-code">  li Joe Biden</pre>
			<p>Notice the indentation of the tags. The <strong class="source-inline">ul</strong> tag is at the same level as the <strong class="source-inline">h1</strong> tag, otherwise, it would be seen as included in the <strong class="source-inline">h1</strong> tag. The <strong class="source-inline">li</strong> tags are shifted to the right to show their inclusion in the preceding <strong class="source-inline">ul</strong> tag. The offset must be at least one character. Because of the offsets, we do not use a closing tag as in HTML.</p>
			<p>Let’s restart the server with <strong class="source-inline">npm start</strong> because one of the routing files has been modified.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Editing files associated with views does not require a server restart, unlike the <strong class="source-inline">app.js</strong> file and files associated with routes (in the <strong class="source-inline">routes</strong> directory).</p>
			<p>Once the server restarts, let’s display the URL <strong class="source-inline">http://localhost:3000</strong> again:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_7.09_B17416.jpg" alt="Figure 7.9 – View displayed using JADE syntax&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – View displayed using JADE syntax</p>
			<p>The list of clients is, in<a id="_idIndexMarker559"/> this example, entered directly into the JADE view. It is better to<a id="_idIndexMarker560"/> pass it as parameters using the second parameter of the <strong class="source-inline">res.render(name, obj)</strong> method. The <strong class="source-inline">clients.js</strong> file then becomes the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.js file (routes directory)</p>
			<pre class="source-code">var express = require('express');</pre>
			<pre class="source-code">var router = express.Router();</pre>
			<pre class="source-code">router.get('/', function(req, res, next) {</pre>
			<pre class="source-code"> <strong class="bold"> res.render("clients", { </strong></pre>
			<pre class="source-code"><strong class="bold">    clients : [</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Bill", lastname : "Clinton" },</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Barack", lastname : "Obama" },</strong></pre>
			<pre class="source-code"><strong class="bold">      { firstname : "Joe", lastname : "Biden" },</strong></pre>
			<pre class="source-code"><strong class="bold">    ]</strong></pre>
			<pre class="source-code"><strong class="bold">  });</strong></pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">module.exports = router;</pre>
			<p>The <strong class="source-inline">obj</strong> parameter of the <strong class="source-inline">res.render("clients", obj)</strong> method is an object containing the list<a id="_idIndexMarker561"/> of clients.</p>
			<p>The <strong class="source-inline">clients.jade</strong> view <a id="_idIndexMarker562"/>uses this passed object as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code"><strong class="bold">  li #{clients[0].lastname + " " + clients[0].firstname}</strong></pre>
			<pre class="source-code"><strong class="bold">  li #{clients[1].lastname + " " + clients[1].firstname}</strong></pre>
			<pre class="source-code"><strong class="bold">  li #{clients[2].lastname + " " + clients[2].firstname}</strong></pre>
			<p>The <strong class="source-inline">obj</strong> object passed in parameters is used in the JADE view, by using its <strong class="source-inline">clients</strong> property here.</p>
			<p class="callout-heading">JADE Syntax</p>
			<p class="callout">JavaScript statements can be used in the JADE view by surrounding them with<strong class="source-inline"> #{ </strong>and<strong class="source-inline"> }</strong>. Anything between these two markers will be considered JavaScript code.</p>
			<p>You can also use a syntax simplification allowed by JADE, by writing the <strong class="source-inline">=</strong> sign directly after each <strong class="source-inline">li</strong> tag. This means that everything following on the line must be interpreted in JavaScript. We can use this simplification of writing here.</p>
			<p>Let’s write the <strong class="source-inline">clients.jade</strong> view as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code"><strong class="bold">  li= clients[0].lastname + " " + clients[0].firstname</strong></pre>
			<pre class="source-code"><strong class="bold">  li= clients[1].lastname + " " + clients[1].firstname</strong></pre>
			<pre class="source-code"><strong class="bold">  li= clients[2].lastname + " " + clients[2].firstname</strong></pre>
			<p>Rather than listing <a id="_idIndexMarker563"/>each element of the <strong class="source-inline">clients</strong> array in the view, you can also <a id="_idIndexMarker564"/>perform a loop using the <strong class="source-inline">each</strong> statement of the JADE syntax to iterate over a JavaScript array.</p>
			<p>The <strong class="source-inline">clients.jade</strong> view therefore becomes the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">clients.jade file (views directory)</p>
			<pre class="source-code">h1 Client list</pre>
			<pre class="source-code">ul</pre>
			<pre class="source-code">  each client in clients</pre>
			<pre class="source-code">    li= client.lastname + " " + client.firstname</pre>
			<p>The writing of the view is simplified, but you really have to take into account the indentations of the lines otherwise the view will not be displayed.</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_7.10_B17416.jpg" alt="Figure 7.10 – List of clients displayed by the each statement&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – List of clients displayed by the each statement</p>
			<p>We see in this <a id="_idIndexMarker565"/>example that the JADE syntax makes it easy to display lists <a id="_idIndexMarker566"/>of data in the views of the application.</p>
			<p>With this, we come to the end of this chapter.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Summary</h1>
			<p>The Express module makes it possible to structure your application efficiently by allowing (thanks to the MVC model it uses) you to separate the management of routes, the views displayed, and the management of data.</p>
			<p>We have explained how to write the views of the application using the JADE syntax provided by default by Express. Other syntaxes, for example, the EJS syntax, are also available by downloading them via <strong class="source-inline">npm</strong>. </p>
			<p>We have also seen the importance of the <strong class="source-inline">app.js</strong> file created by Express, and the use of HTTP requests such as <strong class="bold">GET</strong>, <strong class="bold">POST</strong>, <strong class="bold">PUT</strong>, and <strong class="bold">DELETE</strong>. We will see in <a href="B17416_09_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a>, <em class="italic">Integrating Vue.js with Node.js</em>, the importance of these HTTP requests to build a MEVN application (short for MongoDB, Express, Vue.js, Node.js) that manipulates the MongoDB database.</p>
			<p>Indeed, data management is often done using the <strong class="bold">MongoDB</strong> database, the use of which we will explore in the next chapter.</p>
		</div>
	</body></html>