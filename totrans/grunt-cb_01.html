<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Grunt" id="aid-E9OE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Grunt</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Installing the Grunt CLI</li><li class="listitem">Installing Grunt on a project</li><li class="listitem">Installing a plugin</li><li class="listitem">Setting up a basic web server</li><li class="listitem">Watching files for changes</li><li class="listitem">Setting up LiveReload</li><li class="listitem">Processing only changed files</li><li class="listitem">Importing external data</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p><span class="strong"><strong>Grunt</strong></span> is a popular new task automation framework built upon the <span class="strong"><strong>Node.js</strong></span> platform. It offers a wide range of features that allow you to streamline your project workflow and save time and energy by automating repetitive tasks, such as checking code quality, running tests, compiling templates and code, publishing to various types of services, and much more.</p><p>Task automation has been around since the beginning of software development and can probably be seen as a prominent reason for it being around at all. We're mostly writing programs to automate repetitive tasks after all.</p><p>Grunt itself is, for the most part, only a highly pluggable framework that provides a consistent interface for configuring automated tasks. The actual logic of the tasks is provided by a large variety of modules called <span class="strong"><strong>plugins</strong></span>, which make use of this framework and usually tend to specialize in a certain set of functionalities.</p><p>At the time of writing the Grunt project is more than 3 years old, has over 3,000 plugins available in the <span class="strong"><strong>npm</strong></span> public package registry, and provides tools and guides for creating or contributing to existing plugin projects.</p><p>A vast number of projects are currently making active use of Grunt in various ways, some of the most notable being the Yeoman, Modernizr, AngularJS, and JQuery projects.</p><div class="note" title="Note"><h3 class="title"><a id="tip02"/>Tip</h3><p>Be sure to pay a visit to the Grunt website, if you've not already done so. It's filled with excellent guides and documentation, and it's the best place to find the plugins you need. The website can be found at the following URL:</p><p><a class="ulink" href="http://gruntjs.com/">http://gruntjs.com/</a></p></div></div></div>
<div class="section" title="Installing the Grunt CLI" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Installing the Grunt CLI</h1></div></div></div><p>In order to make use of a Grunt configuration file, the Grunt <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) tool needs to be installed.</p><p>Command-line tools such as the Grunt CLI are usually installed globally. This means that they are installed on top of the Node.js installation that is currently active in your terminal, and not in the current project path, as is usually the case.</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>In this book, we'll work with version 0.4.x of Grunt, which requires Node.js version 0.8.x or higher.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it...</h2></div></div></div><p>The following steps will take us through installing the Grunt CLI and testing for its successful installation.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Assuming that you already have a global installation of Node.js, the following is the command to install the Grunt CLI:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --global grunt-cli</strong></span>
</pre></div></li><li class="listitem">If the installation was successful, the <code class="literal">grunt</code> command should now be available on the terminal. Test this by typing <code class="literal">grunt</code> in your terminal and confirm that it returns a message similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt-cli: The grunt command line interface. (v0.1.13)</strong></span>

<span class="strong"><strong>Fatal error: Unable to find local grunt.</strong></span>

<span class="strong"><strong>If you're seeing this message, either a Gruntfile wasn't found or grunt hasn't been installed locally to your project. For more information about installing and configuring grunt, please see the Getting Started guide:</strong></span>

<span class="strong"><strong>http://gruntjs.com/getting-started</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works...</h2></div></div></div><p>The <code class="literal">npm install</code> command looks up the <code class="literal">grunt-cli</code> package on npm's <span class="strong"><strong>public package registry</strong></span>, and proceeds to download and install it once it is found.</p><p>Using the <code class="literal">-g</code> argument along with the <code class="literal">install</code> command indicates that the package we'd like to install, should be installed globally, meaning it should be installed on the version of Node.js that is currently active in our terminal.</p><p>In a default Node.js setup, a folder for executable binaries will automatically be added as a path that should be scanned by the terminal for executable commands. This makes the <code class="literal">grunt</code> command automatically available after the installation of this package, as its executable binary is provided and indicated in the package's installation information.</p></div></div>
<div class="section" title="Setting up Grunt in a project" id="aid-G6PI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Setting up Grunt in a project</h1></div></div></div><p>For a project to make use of the Grunt framework, it will require the installation of its libraries and the setting up a bare minimum configuration file. The libraries provide the framework and tools required by all Grunt plugins, and the configuration file provides a starting point from which we can start loading plugins and adjusting their behavior.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Getting ready</h2></div></div></div><p>It's usually a good idea for a project to be packaged in a way to help keep track of dependencies, binaries, scripts, maintainers, and other important information. The standard package format for Node.js-based projects is <span class="strong"><strong>CommonJS</strong></span>.</p><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>To find out more about CommonJS, you can take a look at its specification at the following URL:</p><p><a class="ulink" href="http://wiki.commonjs.org/wiki/Packages/1.1">http://wiki.commonjs.org/wiki/Packages/1.1</a></p></div><p>At the heart of the CommonJS package, lies the <code class="literal">package.json</code> file. This file contains everything important about the package and is stored in the JSON format. The simplest way to create a <code class="literal">package.json</code> file is to use the <code class="literal">npm init</code> command. This command will ask a series of questions and generate a <code class="literal">package.json</code> file based on the answers provided. Here's an example of the questions that are asked when you run the command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>name: (grunt-book) myproject</strong></span>
<span class="strong"><strong>version: (0.0.0)</strong></span>
<span class="strong"><strong>description: My first Grunt project.</strong></span>
<span class="strong"><strong>entry point: (index.js)</strong></span>
<span class="strong"><strong>test command:</strong></span>
<span class="strong"><strong>git repository:</strong></span>
<span class="strong"><strong>keywords:</strong></span>
<span class="strong"><strong>author:</strong></span>
<span class="strong"><strong>license: (ISC)</strong></span>
</pre></div><p>After these questions are answered, a <code class="literal">package.json</code> file will be generated in the current path with the following contents:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myproject",
  "version": "0.0.0",
  "description": "My first Grunt project.",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC"
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip05"/>Tip</h3><p>Another handy guide to the <code class="literal">package.json</code> file can be found at the following URL:</p><p><a class="ulink" href="http://browsenpm.org/package.json">http://browsenpm.org/package.json</a></p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it...</h2></div></div></div><p>The following steps take us through installing the Grunt framework libraries on our project and creating a bare minimum configuration file.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we'll install the Grunt libraries in the current project path, and have it added to our project dependencies. This can all be done by using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save grunt</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip06"/>Tip</h3><p>Due to our use of the <code class="literal">--save</code> flag with the <code class="literal">install</code> command, the Grunt package will be added to the dependency list of the project's package. This can be confirmed by taking a look at the <code class="literal">dependencies</code> property inside the <code class="literal">package.json</code> file.</p><p>The <code class="literal">--save-dev</code> flag is also available for use with the <code class="literal">install</code> command when you'd like the installed packages to be added to the <code class="literal">devDependencies</code> property, which lists the dependencies to set up a development environment.</p></div></li><li class="listitem">Next, we'll set up an empty configuration file that would, at the very least, allow Grunt to run and also provides a place for future task configurations. Let's create a file called <code class="literal">Gruntfile.js</code> in the root directory of our project with the following contents:<div class="informalexample"><pre class="programlisting">module.exports = function (grunt) {
  grunt.initConfig({});
  grunt.registerTask('default', []);
};</pre></div></li><li class="listitem">Now that we have the Grunt libraries installed and a basic configuration file set up, we can use the <code class="literal">grunt</code> command to test that it's all working as expected. Running the <code class="literal">grunt</code> command in the terminal should now produce output similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Done, without errors.</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip07"/>Tip</h3><p>Running the <code class="literal">grunt</code> command without specifying any parameters will always try to run the <code class="literal">default</code> task, which in the case of our current example, is set to nothing.</p></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How it works...</h2></div></div></div><p>When the Grunt CLI tool is used, it always looks for the nearest file named <code class="literal">Gruntfile.js</code>, from which it then attempts to load configurations. Inside the configuration file, there is an exported function that receives one argument. This argument is an object that provides us with access to the Grunt framework to load, create, and configure tasks.</p><p>At this point, we have no tasks loaded or created, and no configurations defined. Our <code class="literal">default</code> task is also set to do nothing, so running the <code class="literal">grunt</code> command did nothing except report that it was successfully completed.</p></div></div>
<div class="section" title="Installing a plugin" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Installing a plugin</h1></div></div></div><p>All of the functionality that can be provided by Grunt is housed in the plugins that are made available in the form of Node.js packages. In this recipe, we'll run through the process of installing a plugin, which will prepare us for all the recipes that are to follow.</p><p>For our example, we'll install the <code class="literal">contrib-jshint (0.10.0)</code> plugin. The same steps used to install this plugin can be used to install any of the other plugins available in the plugin package index.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter Be sure to refer to it if you are not yet familiar with it's contents.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><p>The following steps take us through installing a plugin on our project and loading the tasks it contains:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first step of installing a plugin is to install the package that contains it in the current project path. For our example, we'll install the <code class="literal">contrib-jshint</code> plugin that is contained in the <code class="literal">grunt-contrib-jshint</code> package. We can install this package and add it to our project dependencies by using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save grunt-contrib-jshint</strong></span>
</pre></div></li><li class="listitem">Next, we'll have to load the tasks contained in the plugin package so they can be used in our configuration. This is done using the <code class="literal">loadNpmTasks</code> function, provided to us by the <code class="literal">grunt</code> object that is passed to us in the configuration file. After adding this, our configuration file should look similar to the following:<div class="informalexample"><pre class="programlisting">module.exports = function (grunt) {
  grunt.initConfig({});
  grunt.loadNpmTasks('grunt-contrib-jshint');
  grunt.registerTask('default', []);
};</pre></div></li><li class="listitem">Now that we have the package installed and its tasks loaded, we can use the loaded tasks in our configuration. For our example, we had the <code class="literal">jshint</code> task loaded, which enables us to use it in a manner similar to the following:<div class="informalexample"><pre class="programlisting">module.exports = function (grunt) {
  grunt.initConfig({
    jshint: {
      sample: {
        files: 'src/*.js'
      }
    }
  });
  grunt.loadNpmTasks('grunt-contrib-jshint');
  grunt.registerTask('default', []);
};</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>There's more...</h2></div></div></div><p>As you start to make use of more and more Grunt plugins, you will soon start to wonder whether there is a way to optimize the process a little. Fortunately, someone else has already gone down this road before and created the <code class="literal">load-grunt-tasks</code> utility that automates the loading of tasks from all the packages mentioned in your project dependencies. This means that we no longer need to add a <code class="literal">loadNpmTasks</code> call for each plugin we install.</p><p>The following steps illustrate the usage of this utility, continuing from the work we did earlier in the main recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the utility's package in the current project path and add it to your dependencies by using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save load-grunt-tasks</strong></span>
</pre></div></li><li class="listitem">Now we can use it in our configuration file by importing the package and passing the <code class="literal">grunt</code> object to it. Now that we're making use of this utility, we can also remove all the <code class="literal">loadNpmTasks</code> we were using to load our plugins. This should result in a configuration file similar to the following:<div class="informalexample"><pre class="programlisting">module.exports = function (grunt) {
  require('load-grunt-tasks')(grunt);
  grunt.initConfig({
    jshint: {
      sample: {
        files: 'src/*.js'
      }
    }
  });
  grunt.registerTask('default', []);
};</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip08"/>Tip</h3><p>The <code class="literal">load-grunt-tasks</code> plugin will, by default, only load plugins that have names with <code class="literal">grunt</code> at their start. This behavior can be customized by using the <code class="literal">pattern</code> option. To find out more about the <code class="literal">load-grunt-tasks</code> plugin, refer to the plugin's page at the following URL:</p><p><a class="ulink" href="https://github.com/sindresorhus/load-grunt-tasks">https://github.com/sindresorhus/load-grunt-tasks</a></p></div></li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Setting up a basic web server"><div class="titlepage" id="aid-I3QM2"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Setting up a basic web server</h1></div></div></div><p>A simple web server will always come in handy during the development process of web-based projects. They can be easily set up and used to serve web content from your local machine, so you don't have to worry about constantly deploying your experimental changes to a remote service provider.</p><p>We'll make use of the <code class="literal">contrib-connect</code> <code class="literal">(0.8.0)</code> plugin, which provides us with the ability to set up and run a simple web server based on the <span class="strong"><strong>Connect</strong></span> server framework. By default, it will only serve files from a directory, but it has the added benefit of being able to make use of the many Connect middleware plugins available.</p><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>You can read more about the Connect server framework and its middleware plugins at the following URL:</p><p><a class="ulink" href="https://github.com/senchalabs/connect">https://github.com/senchalabs/connect</a></p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter. Be sure to refer to it if you are not yet familiar with it's contents.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><p>The following steps take us through setting up a development server that serves files from a directory located in our project directory.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the package containing the <code class="literal">contrib-connect</code> plugin and loading its tasks as given in the instructions provided in the <span class="emphasis"><em>Installing a plugin</em></span> recipe of this chapter.</li><li class="listitem">With the <code class="literal">connect</code> task loaded from the plugin, we can make use of it in our configuration. To do this, we add the following to our configuration:<div class="informalexample"><pre class="programlisting">connect: {
  server: {
    options: {
      base: 'www',
      keepalive: true
    }
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip10"/>Tip</h3><p>The <code class="literal">base</code> option indicates in which directory the server should look for the files that are requested. Everything that you'd like to serve with your development server can be placed in this directory. This includes HTML pages, JavaScript source files, style sheets, images, and so on.</p><p>The <code class="literal">keepalive</code> option keeps the server running even if the requested task has finished. This is usually preferred if you're running the <code class="literal">connect</code> task on its own, but is not required if another task will be running indefinitely after it has completed.</p></div></li><li class="listitem">Let's add a simple file that we'd like to have served from our server so that we have something to test it with. Create a directory called <code class="literal">www</code> in the project root, and then a file inside it called <code class="literal">index.html</code>, with the following contents:<div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Test Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;This is a test page.&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip11"/>Tip</h3><p>Like many other web servers, the Connect server started by this task will always look for an <code class="literal">index.html</code> file in a folder if no filename is specified in the request URL.</p></div></li><li class="listitem">Now we can run our web server using the <code class="literal">grunt connect</code> command, which will produce output indicating that our server started, along with a URL of where it can be reached:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "connect:server" (connect) task</strong></span>
<span class="strong"><strong>Waiting forever...</strong></span>
<span class="strong"><strong>Started connect web server on http://0.0.0.0:8000</strong></span>
</pre></div></li><li class="listitem">Finally, we can use our favorite browser to pay a visit to the URL mentioned in the output. This would show us our example page, as served through our running server:<div class="mediaobject"><img src="../Images/image00267.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>There's more...</h2></div></div></div><p>The <code class="literal">connect</code> task provides many useful configuration options that allow us to automatically open a browser, specify the port and hostname where the server should run, serve files from more than one directory, use other Connect middleware plugins, and adding extra functionality to the created server.</p><div class="section" title="Opening the default web browser on the default URL"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Opening the default web browser on the default URL</h3></div></div></div><p>In order to automatically open our favorite web browser on the default URL that our web server provides, we can set the <code class="literal">open</code> option to <code class="literal">true</code> as we do in the following example:</p><div class="informalexample"><pre class="programlisting">options: {
  base: 'www',
  keepalive: true,
  open: true
}</pre></div></div><div class="section" title="Opening a specific web browser at a specific URL"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Opening a specific web browser at a specific URL</h3></div></div></div><p>When we'd like to use a different web browser from the default one to open a URL other than the default one, we can provide an object to the <code class="literal">open</code> option that specifies exactly what we'd like. The following code specifies a URL, the browser that should be used to open it, and a callback function that should be called once it's been opened:</p><div class="informalexample"><pre class="programlisting">options: {
  base: 'www',
  keepalive: true,
  open: {
    target: 'http://localhost:8000/test.html',
    appName: 'firefox',
    callback: function() {
      console.log('Test URL opened in Firefox!');
    }
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip12"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div class="section" title="Using a specific port"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Using a specific port</h3></div></div></div><p>The default port used by the connect task is <code class="literal">8000</code>, but if you'd like to use a different one, the <code class="literal">port</code> option can be used to specify which one you'd like it to be, which is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">options: {
  port: 3000,
  base: 'www',
  keepalive: true
}</pre></div></div><div class="section" title="Automatically selecting an available port"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Automatically selecting an available port</h3></div></div></div><p>In case you are not sure about which ports will be available when you start the server, it can be quite useful for you to have the server automatically select an open port. Setting the <code class="literal">useAvailablePort</code> option to <code class="literal">true</code> will enable this behavior. The code snippet for this is as follows:</p><div class="informalexample"><pre class="programlisting">options: {
  base: 'www',
  keepalive: true,
  useAvailablePort: true
}</pre></div></div><div class="section" title="Using a specific hostname"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Using a specific hostname</h3></div></div></div><p>In the case that you'd like the server to attach to a specific hostname and not just the default <code class="literal">0.0.0.0</code>, you can make use of the <code class="literal">hostname</code> option in the following manner:</p><div class="informalexample"><pre class="programlisting">options: {
  base: 'www',
  keepalive: true,
  hostname: 'something.else.com'
}</pre></div></div><div class="section" title="Serving files from multiple directories"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Serving files from multiple directories</h3></div></div></div><p>If you have more than one directory that contains the files that you'd like to be serving, then the <code class="literal">base</code> option can be provided with an array of directory names to look up content. Here is a code snippet for your reference:</p><div class="informalexample"><pre class="programlisting">options: {
  base: ['www', 'other'],
  keepalive: true
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip13"/>Tip</h3><p>When using an array for the <code class="literal">base</code> option, the server will look up the requested resources in each of the directories, from left to right, and return a resource as soon as it's found. If each of the two directories in the example contained an <code class="literal">index.html</code> file, a request to the root URL would return the <code class="literal">index.html</code> file in the <code class="literal">www</code> directory.</p></div></div><div class="section" title="Using middleware"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Using middleware</h3></div></div></div><p>If we'd like to use one of the many existing middleware plugins available for the Connect framework, we can set the <code class="literal">middleware</code> option to a function that modifies the middleware stack by adding the desired middleware to it.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we'll need to install the middleware that we'd like to use, which in our case is packaged along with the Connect server framework. We can install the framework package using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save connect</strong></span>
</pre></div></li><li class="listitem">Now, we alter the options of the <code class="literal">server</code> target in the <code class="literal">connect</code> task so that it adds the <code class="literal">compress</code> middleware to the stack:<div class="informalexample"><pre class="programlisting">options: {
  base: 'www',
  keepalive: true,
  middleware: function(connect, options, middlewares) {
    middlewares.push(
      require('connect').middleware.compress()
    );
    return middlewares;
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip14"/>Tip</h3><p>The <code class="literal">middleware</code> option can also be set to an array, but this will replace the default stack that is provided by the <code class="literal">connect</code> task. The default middleware allows the serving of files from the directories indicated by the <code class="literal">base</code> option.</p></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Adding functionality to the created server"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Adding functionality to the created server</h3></div></div></div><p>There are times that it would be useful to work with the server that is created by the <code class="literal">connect</code> task. A good example of this is when we'd like to enable our server to handle <span class="strong"><strong>Socket.IO</strong></span> interactions. This can be done by providing a function to the <code class="literal">onCreateServer</code> option that works with the created server in whichever way you like:</p><div class="informalexample"><pre class="programlisting">options: {   base: 'www',
  keepalive: true,
  onCreateServer: function(server, connect, options) {
    var io = require('socket.io').listen(server);
    io.sockets.on('connect', function (socket) {
      // do something with socket
    });
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip15"/>Tip</h3><p>This example assumes that you've already installed the <code class="literal">socket.io</code> package. You can find out more about <code class="literal">socket.io</code> at its website:</p><p><a class="ulink" href="http://socket.io/">http://socket.io/</a></p></div></div></div></div>
<div class="section" title="Watching files for changes"><div class="titlepage" id="aid-J2B82"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Watching files for changes</h1></div></div></div><p>Another common requirement for development environments is the need to automatically run specific tasks when certain files are changed. This is especially useful when you'd like to monitor the quality of changing code in real time, or recompile altered resources as soon as they change, so that the effect of the changes are reflected without any manual intervention.</p><p>The <code class="literal">contirb-watch</code> <code class="literal">(0.6.1)</code> plugin allows us to keep a watch on a specific set of files, and run a specified set of tasks when file events are observed.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure that we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter. Be sure to refer to it if you are not yet familiar with it's contents.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it...</h2></div></div></div><p>The following steps take us through setting up a <code class="literal">watch</code> task that initiates a code quality analysis on a JavaScript source file each time a change to the file is observed.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the package that contains the <code class="literal">contrib-watch</code> plugin and loading its tasks by following the instructions provided in the <span class="emphasis"><em>Installing a Plugin</em></span> recipe of this chapter.</li><li class="listitem">For our example, we'll make use of the <code class="literal">jshint</code> task to analyze the quality of a JavaScript source file. Let's install the <code class="literal">contrib-jshint</code> plugin and load its tasks by following the instructions provided in the <span class="emphasis"><em>Installing a Plugin</em></span> recipe of this chapter.</li><li class="listitem">We'll also need a JavaScript source file that we can watch for changes and perform a quality analysis on. Let's create a file called <code class="literal">sample.js</code> in our project root and provide it with the following contents:<div class="informalexample"><pre class="programlisting">var sample = 'Sample';
console.log(sample);</pre></div></li><li class="listitem">Now, we can set up the example <code class="literal">jshint</code> task, which we'll run using the <code class="literal">watch</code> task by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">jshint: {
  sample: {
    src: ['sample.js']
  }
}</pre></div></li><li class="listitem">With the plugin installed and the sample task configured, we can now configure a target on the <code class="literal">watch</code> task, which will run the <code class="literal">jshint</code> task every time the sample file called <code class="literal">sample.js</code> changes. This is done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.js'],
    tasks: ['jshint']
  }
}</pre></div></li><li class="listitem">Finally, we can start the task using the <code class="literal">grunt watch</code> command, which should produce the following output to confirm that it's running:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre></div></li><li class="listitem">To test our setup, we can now make some changes to the <code class="literal">sample.js</code> file and save them. This should produce output informing us of the file event similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
<span class="strong"><strong>&gt;&gt; File "sample.js" changed.</strong></span>
<span class="strong"><strong>Running "jshint:sample" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 1 file lint free.</strong></span>

<span class="strong"><strong>Done, without errors.</strong></span>
<span class="strong"><strong>Completed in 1.0s at Wed Jan 1 2014 00:00:00 GMT - Waiting...</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>There's more...</h2></div></div></div><p>The <code class="literal">watch</code> task plugin provides many more useful configuration options that allow us to watch more than one file, run a series of tasks, prevent process spawning for task runs, enable the interruption of task runs, specify the waiting period before rerunning tasks, run tasks only on specific file events, allow tasks to kill the watcher process, and run tasks once when the watcher starts up.</p><div class="section" title="Watching more than one file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Watching more than one file</h3></div></div></div><p>In case we'd like to watch more than one file, the pattern-matching capabilities of the standard Grunt <code class="literal">files</code> configuration can be used. The following configuration example will observe all the files in the project root or any of its sub directories with the <code class="literal">txt</code> extension:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['**/*.txt'],
    tasks: ['sample']
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip16"/>Tip</h3><p>You can find out more about the file's configuration and the globbing patterns it supports at the following URL:</p><p><a class="ulink" href="http://gruntjs.com/configuring-tasks#files">http://gruntjs.com/configuring-tasks#files</a></p></div></div><div class="section" title="Running a series of tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Running a series of tasks</h3></div></div></div><p>In case we'd like to run more than one task each time a file event is observed, we can just add the tasks to the array passed to the <code class="literal">tasks</code> configuration:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample', 'another', 'finally']
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip17"/>Tip</h3><p>The tasks specified in using the <code class="literal">tasks</code> configuration are run one at a time, in the order they are placed inside the array.</p></div></div><div class="section" title="Preventing process spawning for task runs"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Preventing process spawning for task runs</h3></div></div></div><p>The default behavior of the <code class="literal">watch</code> task is to start each of the triggered tasks in their own child process. This prevents failing triggered tasks from causing the <code class="literal">watch</code> task itself to fail. As a side effect, it also clones the context of the watcher process for each task. This behavior can however be disabled by setting the <code class="literal">spawn</code> option to <code class="literal">false</code>, which triggers tasks a little faster and allows them to share a context between them. The following demonstrates the configuration for this:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample'],
    options: {
      spawn: false
    }
  }
}</pre></div></div><div class="section" title="Enabling the interruption of task runs"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Enabling the interruption of task runs</h3></div></div></div><p>The default behavior for the watcher is to wait for the completion of the tasks triggered by the previous change, before waiting for changes again. By setting the <code class="literal">interrupt</code> option to <code class="literal">true</code>, the watcher will stop running tasks when a change is detected and start rerunning them. The following demonstrates the configuration for this:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample'],
    options: {
      interrupt: true
    }
  }
}</pre></div></div><div class="section" title="Specifying the waiting period before rerunning tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Specifying the waiting period before rerunning tasks</h3></div></div></div><p>The default period the watcher will wait before checking for file changes after a previous task run is <code class="literal">500ms</code>. This amount of time can be changed by setting the <code class="literal">debounceDelay</code> option to the number of milliseconds you'd like for it to wait. The following demonstrates the configuration for this:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample'],
    options: {
      debounceDelay: 1000
    }
  }
}</pre></div></div><div class="section" title="Run tasks only on specific file events"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Run tasks only on specific file events</h3></div></div></div><p>In addition to being changed, files can also be added and deleted. The default behavior of the watcher is to observe all these events, but if you'd like it to run tasks only on specific events, the <code class="literal">event</code> option can be set to either <code class="literal">changed</code>, <code class="literal">added</code>, <code class="literal">deleted</code>, or <code class="literal">all</code>.</p><p>The following example will only start the <code class="literal">sample</code> task if a file named <code class="literal">sample.txt</code> is added or deleted to the same path as the configuration file:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample'],
    options: {
      event: ['added', 'deleted']
    }
  }
}</pre></div></div><div class="section" title="Allowing tasks to kill the watcher process"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"/>Allowing tasks to kill the watcher process</h3></div></div></div><p>Warnings and failures that are raised by the tasks started by the watch task will, by default, not interrupt its execution. Setting the <code class="literal">forever</code> option to <code class="literal">false</code> will disable this behavior and allow child tasks to stop the watcher process on warnings and failures. The following demonstrates the configuration for this:</p><div class="informalexample"><pre class="programlisting">watch: {
  options: {
    forever: false
  },
  sample: {
    files: ['sample.txt'],
    tasks: ['sample']
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip18"/>Tip</h3><p>Note that the <code class="literal">forever</code> option is a task-level option only and cannot be specified for individual targets.</p></div></div><div class="section" title="Running tasks once at startup of the watcher"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec16"/>Running tasks once at startup of the watcher</h3></div></div></div><p>In the case that you'd like to run the tasks specified in the <code class="literal">tasks</code> option once the watcher starts up, and not only once file events are observed, you can set the <code class="literal">atBegin</code> option to <code class="literal">true</code>. The following demonstrates the configuration for this:</p><div class="informalexample"><pre class="programlisting">watch: {
  sample: {
    files: ['sample.txt'],
    tasks: ['sample'],
    options: {
      atBegin: true
    }
  }
}</pre></div></div></div></div>
<div class="section" title="Setting up LiveReload" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Setting up LiveReload</h1></div></div></div><p>Once you've got a development server running that serves the pages, code, and assets that make up your web application, you will notice that you constantly have to refresh the browser each time you wish to observe a change that was made.</p><p>This is where the <span class="strong"><strong>LiveReload</strong></span> tool and its constituent libraries come in handy. It's designed to automatically reload the browser's contents if a page or code file is changed, and even apply changes to CSS and images live, without refreshing the browser's contents.</p><p>We can set up LiveReload for our project with the help of two plugins that are discussed in other parts of this chapter. The development server provided by the <code class="literal">contrib-connect (0.8.0)</code> plugin can be configured to accept LiveReload triggers, and the <code class="literal">contrib-watch (0.6.1)</code> plugin to send them file events.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure that we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter. Be sure to refer to it if you are not yet familiar with it's contents.</p><p>We also make use of the <code class="literal">contrib-connect</code> and <code class="literal">contrib-watch</code> plugins in this recipe, which have each been discussed separately in the <span class="emphasis"><em>Setting up a basic web server</em></span> and <span class="emphasis"><em>Watching files for changes</em></span> recipes of this chapter. These are to be referred to if you are not yet familiar with the plugins they discuss.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it...</h2></div></div></div><p>The following steps take us through setting up a watch task that will automatically trigger a refresh when it observes changes to an HTML page that is served from a local development server.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the packages containing the <code class="literal">contrib-connect</code> and <code class="literal">contrib-watch</code> plugins and loading their tasks by following the instructions provided in the <span class="emphasis"><em>Installing a plugin</em></span> recipe of this chapter.</li><li class="listitem">For the sake of our example, we'll create a file called <code class="literal">index.html</code> in the <code class="literal">www</code> directory, which will be the file that we wish to view in a browser and have automatically updated when changes are made to it. The contents for this file follows:<div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;LiveReload Test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;First there was this.&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">Next, we'll set up our development server, which will serve the <code class="literal">index.html</code> file from the <code class="literal">www</code> directory. Along with the standard configuration, we'll set the <code class="literal">livereload</code> option to <code class="literal">true</code>, indicating that the development server should enable the browser to receive LiveReload triggers. This is all done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">connect: {
  dev: {
    options: {
      base: 'www',
      livereload: true
    }
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip19"/>Tip</h3><p>Providing the <code class="literal">true</code> value for the <code class="literal">livereload</code> option includes <code class="literal">connect-livereload</code> in the middleware stack of the connect server. The middleware in turn inserts a snippet of code in the HTML code of the pages served, which enables the browser to accept LiveReload triggers.</p><p>The <code class="literal">keepalive</code> option can be excluded from this configuration due to the watcher process that will continue to run after the server is started. This means that the Grunt process will not end, which would also have stopped the server it started.</p></div></li><li class="listitem">Now, we'll set up a watcher to observe file events in the <code class="literal">www/index.html</code> file. Along with the standard configuration, we'll set the <code class="literal">livereload</code> option to <code class="literal">true</code>, indicating that the appropriate LiveReload triggers should be sent whenever changes are observed. This is done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">watch: {
  www: {
    files: ['www/index.html'],
    options: {
      livereload: true
    }
  }
}</pre></div></li><li class="listitem">Finally, we can start our server and watcher using the <code class="literal">grunt connect watch</code> command, which should produce output indicating the start of both:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "connect:dev" (connect) task</strong></span>
<span class="strong"><strong>Started connect web server on http://0.0.0.0:8000</strong></span>

<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre></div></li><li class="listitem">Now, we can use our favorite browser to open the URL mentioned in the output, which should show us our sample page as served by the server:<div class="mediaobject"><img src="../Images/image00268.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Let's try out the LiveReload functionality by changing the <code class="literal">www/index.html</code> file and saving it. This action should produce the following output in the terminal in which the server and watcher were started:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt; File "www/index.html" changed.</strong></span>
<span class="strong"><strong>Completed in 0.001s at Wed Jan 01 2014 00:00:00 GMT – Waiting...</strong></span>
</pre></div></li><li class="listitem">Switching back to our browser that currently has the <code class="literal">http://0.0.0.0:8000</code> URL open, we should now see the updated page, without having initiated a manual refresh:<div class="mediaobject"><img src="../Images/image00269.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Processing only changed files" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Processing only changed files</h1></div></div></div><p>When running a task that processes files in one way or another, you'll soon realize that you probably don't want it to process all the files each time it is performed. This is especially true when the amount of files the task has to process becomes quite large.</p><p>This is where the <code class="literal">newer (0.7.0)</code> plugin can help out by ensuring that only the files that have changed since the task's previous run are processed, each time it is called to run. It can be used with any plugin that makes use of the standard <code class="literal">files</code> configuration and becomes especially useful when using a watcher to rerun tasks each time a file change is detected.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure that we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter. Be sure to refer to it if you are not yet familiar with it's contents.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How to do it...</h2></div></div></div><p>The following steps take us through making use of the <code class="literal">newer</code> plugin to check the code quality of only the JavaScript source files that have changed since the last run.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the package containing the <code class="literal">newer</code> plugin and loading its tasks by following the instructions provided in the <span class="emphasis"><em>Installing a plugin</em></span> recipe of this chapter.</li><li class="listitem">For the purpose of our example, we'll also install the <code class="literal">contrib-jshint</code> plugin and load its tasks by following the instructions provided in the <span class="emphasis"><em>Installing a plugin</em></span> recipe of this chapter.</li><li class="listitem">With all the required plugins installed, we can now add sample configuration for the <code class="literal">jshint</code> task, which will perform a code quality check on all the JavaScript files in the <code class="literal">src</code> directory. This is done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">jshint: {
  sample: {
    src: 'src/**/*.js'
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip20"/>Tip</h3><p>Note that the <code class="literal">jshint</code> plugin requires you to specify the files that are to be targeted by the task in the <code class="literal">src</code> configuration directly inside the target. In other cases, it is usually recommended to specify your target files using the <code class="literal">files</code> configuration.</p></div></li><li class="listitem">Now we can run the <code class="literal">jshint</code> task a couple of times using the <code class="literal">grunt jshint</code> command to observe its behavior. Each time we run it, we'll see that it scans all the files in the <code class="literal">src</code> directory. This should produce the same output each time, similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "jshint:sample" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 3 files lint free.</strong></span>
</pre></div></li><li class="listitem">In order to make use of the <code class="literal">newer</code> plugin, we prepend <code class="literal">newer:</code> to the name of the task we wish to run. On running the <code class="literal">grunt newer:jshint</code> command the first time, the <code class="literal">newer</code> plugin will cache the timestamps of the files that have been processed. This produces output similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "newer:jshint" (newer) task</strong></span>

<span class="strong"><strong>Running "newer:jshint:sample" (newer) task</strong></span>

<span class="strong"><strong>Running "jshint:sample" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 3 files lint free.</strong></span>

<span class="strong"><strong>Running "newer-postrun:jshint:sample:.cache" (newer-postrun) task</strong></span>
</pre></div></li><li class="listitem">When we run the <code class="literal">grunt newer:jshint</code> command again, we'll see that no files are processed by the <code class="literal">jshint</code> task, which produces output similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "newer:jshint" (newer) task</strong></span>

<span class="strong"><strong>Running "newer:jshint:sample" (newer) task</strong></span>
<span class="strong"><strong>No newer files to process.</strong></span>
</pre></div></li><li class="listitem">Now, we can change one of the files in the <code class="literal">src</code> directory and run the command again to see that the changed file is processed again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "newer:jshint" (newer) task</strong></span>

<span class="strong"><strong>Running "newer:jshint:sample" (newer) task</strong></span>

<span class="strong"><strong>Running "jshint:sample" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 1 file lint free.</strong></span>

<span class="strong"><strong>Running "newer-postrun:jshint:sample:1:.cache" (newer-postrun) task</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more...</h2></div></div></div><p>Processing only changed files becomes especially useful when making use of the <code class="literal">watch</code> task provided by the <code class="literal">contrib-watch</code> plugin. A <code class="literal">watch</code> task will rerun its indicated tasks every time it observes a file change, which can happen quite often during development, and can take quite a bit of time if the tasks target a large number of files.</p><p>The following steps provide an example of how to use the <code class="literal">newer</code> plugin in conjunction with <code class="literal">contrib-watch</code> and continues with the work we did in the main recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by installing the package that contains the <code class="literal">contrib-watch</code> plugin and loading its tasks by following the instructions provided in the <span class="emphasis"><em>Installing a plugin</em></span> recipe of this chapter.</li><li class="listitem">Now, we'll add a <code class="literal">watch</code> task, which will run the <code class="literal">jshint</code> task when it observes changes on any of the JavaScript files contained in the <code class="literal">src</code> directory. We'll also prepend the <code class="literal">jshint</code> task with <code class="literal">newer:</code> to indicate that we only want to process the files that actually changed. This is done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">watch: {
  jshint: {
    files: ['src/**/*.js'],
    tasks: ['newer:jshint']
  }
}</pre></div></li><li class="listitem">Now, we can start the <code class="literal">watch</code> task by using the <code class="literal">grunt watch</code> command in the terminal. This should produce output similar to the following, indicating that the watcher is running:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "watch" task</strong></span>
<span class="strong"><strong>Waiting...</strong></span>
</pre></div></li><li class="listitem">If we now change and save a file in the <code class="literal">src</code> directory, we should see output similar to the following, indicating that only the file that was changed has been processed by the <code class="literal">jshint</code> task:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt; File "src/file.js" changed.</strong></span>
<span class="strong"><strong>Running "newer:jshint" (newer) task</strong></span>

<span class="strong"><strong>Running "newer:jshint:sample" (newer) task</strong></span>

<span class="strong"><strong>Running "jshint:sample" (jshint) task</strong></span>
<span class="strong"><strong>&gt;&gt; 1 file lint free.</strong></span>

<span class="strong"><strong>Running "newer-postrun:jshint:sample:1:.cache" (newer-postrun) task</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Importing external data" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Importing external data</h1></div></div></div><p>In most coding practices, it's best practice to keep logic and data separated as much as possible. The same rule applies to the Grunt configuration logic and the data that it makes use of.</p><p>A very common use case for using data from an external source is the use of the project information contained in the <code class="literal">package.json</code> file. Information such as project names and version numbers might not change too often, but when they do, we'd probably prefer not having to look for them everywhere in the project.</p><p>Fortunately, the Grunt framework provides us with functions that allow us to easily read data from external files and store them in the configuration. This stored data can then also be easily used with the help of the string templates that are automatically processed for all configurations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>Getting ready</h2></div></div></div><p>In this example, we'll work with the basic project structure that we created in the <span class="emphasis"><em>Setting up Grunt on a project</em></span> recipe of this chapter. Be sure to refer to it if you are not yet familiar with it's contents.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How to do it...</h2></div></div></div><p>The following steps take us through making use of data from the <code class="literal">package.json</code> file when generating an optimized version of a JavaScript source file.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For our example, we'll make use of the <code class="literal">contib-uglify</code> plugin, which can be used to compress JavaScript source files. Let's install it and load its tasks for using the instructions provided in the <span class="emphasis"><em>Installing a Plugin</em></span> recipe of this chapter.</li><li class="listitem">We'll also need a simple JavaScript source file for the sake of our example. Let's create a file called <code class="literal">sample.js</code> in the root of our project directory and fill it with the following code:<div class="informalexample"><pre class="programlisting">module.exports = function () {
  var sample = 'Sample';
  console.log(sample);
};</pre></div></li><li class="listitem">Next, we'll import the data contained in our project's <code class="literal">pacakge.json</code> file by making use of the <code class="literal">grunt.file.readJSON</code> function and assigning its result to a property called <code class="literal">pkg</code> in our configuration. After adding this, our configuration object should look similar to the following:<div class="informalexample"><pre class="programlisting">{
  pkg: grunt.file.readJSON('package.json')
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip21"/>Tip</h3><p>Note that the property name <code class="literal">pkg</code> is just used for this example, and can be pretty much anything except for the names of the tasks that are available for configuration.</p></div></li><li class="listitem">Now that we have the data imported form our project package, we can set up an <code class="literal">uglify</code> task, which will compress a JavaScript source file called <code class="literal">sample.js</code>, using the version number contained in the <code class="literal">package.json</code> file as part of the resulting file's name. This is done by adding the following to our configuration:<div class="informalexample"><pre class="programlisting">uglify: {
  sample: {
    files: {
      'sample_&lt;%= pkg.version %&gt;.js': 'sample.js'
    }
  }
}</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip22"/>Tip</h3><p>Grunt makes use of the <span class="strong"><strong>Lo-Dash</strong></span> string template system. You can read more about it at the following URL:</p><p><a class="ulink" href="http://lodash.com/docs/#template">http://lodash.com/docs/#template</a></p></div></li><li class="listitem">Finally, we can use the <code class="literal">grunt uglify</code> command to test our setup, which should produce output similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "uglify:sample" (uglify) task</strong></span>
<span class="strong"><strong>File sample_0.0.0.js created: 81 B → 57 B</strong></span>
</pre></div></li><li class="listitem">We can now also take a look at our newly generated compressed version of the <code class="literal">sample.js</code> file in the <code class="literal">sample_0.0.0.js</code> file, which should have content similar to the following:<div class="informalexample"><pre class="programlisting">module.exports = function(){var a="Sample";console.log(a)};</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>There's more...</h2></div></div></div><p>The YAML format provides another popular way to store human readable data and can also be easily imported into our configuration. The following example, based on the work we did in the main recipe, demonstrates this functionality:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we'll create a simple YAML file for the purpose of our example. Let's create <code class="literal">sample.yaml</code> in our project root and give it the following content:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>version: 0.0.0</strong></span>
</pre></div></li><li class="listitem">Now all we need to do is change the call to <code class="literal">grunt.file.readJSON</code> to import our sample YAML file instead. We do this by changing the <code class="literal">pkg</code> configuration to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pkg: grunt.file.readYAML('sample.yaml')</strong></span>
</pre></div></li><li class="listitem">If we now run the Grunt <code class="literal">uglify</code> command, we should see the same result as before, with output similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Running "uglify:sample" (uglify) task</strong></span>
<span class="strong"><strong>File sample_0.0.0.js created: 81 B → 57 B</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div></div></body></html>