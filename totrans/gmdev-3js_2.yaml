- en: Chapter 2. Building a World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains the components of a Three.js scene in detail, including
    the different kinds of renderers, geometries, materials, and lighting. We will
    also build a procedurally generated city.
  prefs: []
  type: TYPE_NORMAL
- en: Geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometries are instances of `THREE.Geometry` that define the shape of an object
    in a scene. They are made up of vertices and faces (which are themselves objects
    and are accessible through the `vertices` and `faces` array properties). Vertices
    are the `THREE.Vector3` objects representing points in three-dimensional space,
    while faces are the `THREE.Face3` objects representing triangular surfaces. (All
    more complex shapes are subdivided into triangular faces for rendering purposes.)
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, dealing with vertices and faces directly is usually unnecessary because
    `THREE.Geometry` has many subclasses that help create commonly used shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 3D primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js provides a number of classes that generate common shapes. The official
    documentation for each type is available at [http://threejs.org/docs/](http://threejs.org/docs/),
    but a summary of common types is shown in the following table (some obscure, optional
    constructor parameters were omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Constructor | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Cube![3D primitives](img/8539_02_01.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a rectangular box with the specified dimensions. The `segments` parameters
    split the sides into smaller rectangles. |'
  prefs: []
  type: TYPE_TB
- en: '| Sphere![3D primitives](img/8539_02_02.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a sphere approximation created by calculating segments. |'
  prefs: []
  type: TYPE_TB
- en: '| Polyhedra (spheroids)![3D primitives](img/8539_02_03.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a sphere approximation based on shapes with 20, 8, or 4 sides, respectively;
    the `detail` parameter specifies how many times to split each edge to make more
    faces, making the shape more spherical. |'
  prefs: []
  type: TYPE_TB
- en: '| Cylinder![3D primitives](img/8539_02_04.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| `radiusSegments` is the number of edges connecting the top and bottom faces,
    down the curved surface; `heightSegments` is the number of rings of faces around
    the curved surface, and if `openEnded` is `true`, the ends of the cylinder will
    not be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| Torus![3D primitives](img/8539_02_05.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a donut shape. |'
  prefs: []
  type: TYPE_TB
- en: '| TorusKnot![3D primitives](img/8539_02_06.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a knot shape, sort of like a pretzel. `p` and `q` are integers that
    affect how many twists are in the knot. |'
  prefs: []
  type: TYPE_TB
- en: You can try changing the spinning icosahedron example we built in the last chapter
    to use different geometries by changing the `IcosahedronGeometry` constructor
    to one of the options in the preceding table. There is also a geometry viewer
    at [http://threejsplaygnd.brangerbriz.net/gui/](http://threejsplaygnd.brangerbriz.net/gui/)
    that allows you to tweak the constructor parameters to see the result and also
    copy the code required to generate the shape you're viewing.
  prefs: []
  type: TYPE_NORMAL
- en: 2D primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js also has default geometry for 2D shapes as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Constructor | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Plane |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a rectangle with the specified dimensions. The `segments` parameters
    subdivide the plane into smaller rectangles. |'
  prefs: []
  type: TYPE_TB
- en: '| Circle |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a regular polygon. |'
  prefs: []
  type: TYPE_TB
- en: '| Ring |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| It is a circle with a hole in the middle. |'
  prefs: []
  type: TYPE_TB
- en: These shapes are created along the x and y axes by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, Three.js can create lines. Almost all objects you would normally
    place in a scene will be meshes, but lines are exceptions. Consider code like
    the following, which creates a mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the preceding code, you could use the code as shown in the
    following snippet to create a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This can create some strange results for standard geometry such as `IcosahedronGeometry`
    because lines will be drawn connecting points in an unexpected order. Instead,
    you will usually want to create a custom geometry so that you can add vertices
    in your desired order.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `LineDashedMaterial` instead of `LineBasicMaterial` to make a dotted line.
  prefs: []
  type: TYPE_NORMAL
- en: Custom geometries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several default geometry types allow creating shapes based on vertices or paths
    specifically created by the developer. (You can also import geometry created in
    external programs, a topic covered in [Chapter 4](ch04.html "Chapter 4. Adding
    Detail"), *Adding Detail*.) The most basic type is the `THREE.Geometry` class
    itself. For example, you can create a triangle using the code shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, this code creates a geometry object that has no vertices or faces yet.
    Then, it adds specific vertices, where each vertex is represented by a `THREE.Vector3`
    that holds spatial coordinates on the x, y, and z axes. Next, a `THREE.Face3`
    is added into the `faces` array. The `Face3` constructor's parameters indicate
    the indices of vertices in the geometry's `vertices` array to use for the face's
    corners. Finally, the bounding sphere is computed, which triggers internal calculations
    for properties Three.js needs to track such as whether the shape is in view. If
    you have trouble getting a texture to display correctly on your custom material,
    you may also need to call `geo.computeFaceNormals()` and `geo.computeVertexNormals()`.
    These functions calculate additional information about the geometry's visual layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually creating shapes out of individual vertices can quickly get tiring;
    however, some utilities exist to help make the process faster as introduced in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Geometry | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LatheGeometry` | It revolves a shape in a circle |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.PolyhedronGeometry` | A spheroid; examples include `IcosahedronGeometry`,
    `TetrahedronGeometry`, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ExtrudeGeometry` | It starts with a 2D shape and stretches it into
    a 3D space |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ShapeGeometry` | It is a 2D shape |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.TubeGeometry` | It is a hollow cylinder |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.ParametricGeometry` | These are curved tubes |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take extruding as an example since that''s a relatively common operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach here is to create a 2D shape (`THREE.Shape`) out of (x, y) coordinates
    and then stretch it out along the z axis. The second parameter for `ExtrudeGeometry`
    is a map of options. The most important one, `amount`, controls how far to stretch
    out the shape. `bevelEnabled` controls whether the extruded edges are rounded
    or not. You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom geometries](img/8539_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An extruded triangle
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the other custom geometries are unusual in games because normally
    if you wanted to create a complex shape, you could create a model in a 3D modeling
    program and then import it into Three.js (a process covered in [Chapter 4](ch04.html
    "Chapter 4. Adding Detail"), *Adding Detail*).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a WebGL-only class called `THREE.BufferGeometry` which is faster than
    `THREE.Geometry`, but is much more difficult to work with because it stores WebGL
    buffers instead of Three.js vertices and faces. However, future developments in
    Three.js will shift the default geometry to work more like `THREE.BufferGeometry`
    under the hood so that you don't have to think about the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js can render text in 3D using geometry as well. To use this feature,
    you must include the font files after the Three.js library, but before your own
    code. For example, include the Helvetiker font using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (In production projects, you should download the fonts you want to use and include
    them locally.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js comes with several fonts in the `examples/fonts` directory. Custom
    fonts must be in the `typeface.js` format (you can convert OpenType and TrueType
    fonts to Typeface format at [http://typeface.neocracy.org/fonts.html](http://typeface.neocracy.org/fonts.html)).
    Use the following code to create text geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `THREE.TextGeometry` constructor creates a shape representing the text
    in 2D, and then extrudes it as we did with our triangle. You can see the result
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text](img/8539_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 3D text
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Materials are instances of `THREE.Material` that define how objects appear.
    There are several common material subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constructor | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshBasicMaterial`![Materials](img/8539_02_09.jpg) | It is not affected
    by lighting (a characteristic called **unlit**), so this is usually used to display
    a solid color or a wireframe. Two adjacent, same-colored, unlit surfaces are difficult
    to tell apart. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshNormalMaterial`![Materials](img/8539_02_10.jpg) | The red/green/blue
    values of the colors displayed by this material are based on the magnitude of
    the x/y/z values of the faces'' normal vectors. (A *normal* vector is perpendicular
    to a surface.) This material is unlit and useful for quickly distinguishing the
    shape of an object. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshDepthMaterial`![Materials](img/8539_02_11.jpg) | It is an unlit material
    that shows shades of gray, with brightness depending on the distance from the
    camera. It is useful when designing scenes before applying more realistic textures.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshLambertMaterial`![Materials](img/8539_02_12.jpg) | Faces are affected
    by lighting, but are not shiny. Specifically, lighting is calculated per-vertex
    and is interpolated over faces. It will appear black if there are no lights in
    the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshPhongMaterial`![Materials](img/8539_02_13.jpg) | Faces are affected
    by lighting, and can be shiny. Specifically, lighting is calculated per-*texel*
    (texture pixel), so this will be more accurate than Lambert materials when the
    light source is close to the object in question. It will appear black if there
    are no lights in the scene. |'
  prefs: []
  type: TYPE_TB
- en: '| `MeshFaceMaterial`![Materials](img/8539_02_14.jpg) | It is essentially an
    array of materials used to map different materials to different surfaces. This
    material is unique in that instantiating it is different than all the others,
    as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create three new materials we want to use, pass them in an array to
    `MeshFaceMaterial`, and then set each face on our geometry to an index of the
    `materials` array that corresponds to the material we want for that face. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `ShaderMaterial`![Materials](img/8539_02_15.jpg) | It displays a **GLSL**
    (**open Graphics Library Shading Language**) texture. GLSL is a programming language
    based on C that is used by WebGL and OpenGL to provide developers with a high-level,
    platform-agnostic way to control graphics. It is quite powerful and will be addressed
    more in [Chapter 4](ch04.html "Chapter 4. Adding Detail"), *Adding Detail*. |'
  prefs: []
  type: TYPE_TB
- en: 'All of these material constructors except `MeshFaceMaterial` take a map of
    options as their only parameter. We''ve already encountered three options from
    our icosahedron example: `color`, `wireframe`, and `wireframeLinewidth`. Additionally,
    setting the `transparency` option to `true` allows use of the `opacity` option,
    a value between zero and one indicating how see-through the material should be
    (zero is invisible, one is opaque). For materials that don''t use images, the
    other option that may be relevant is `shading`, which has a value of either `THREE.SmoothShading`
    or `THREE.FlatShading` indicating whether to blend colors of each face together,
    as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Materials](img/8539_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Left, THREE.MeshNormalMaterial({shading: THREE.FlatShading}); Right, THREE.MeshNormalMaterial({shading:
    THREE.SmoothShading});'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other properties, the most important of which is also the
    most useful: `map`. This defines the texture used to wrap over the geometry. Usually,
    using this property looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two issues to watch out for when loading images. First, if you are
    running your application locally (by double-clicking on the file, you will see
    a `file:///` URL), Chrome will prevent loading images by default for security
    reasons (to keep malicious JavaScript from accessing local files on your computer).
    You can solve this by either changing your browser's security settings or running
    the file using a local HTTP server as explained at [https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally](https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally).
    The second issue is that you cannot render images loaded from another domain in
    WebGL, also for security reasons. You can solve this by serving the image with
    the `Access-Control-Allow-Origin` header set to `null` as explained at [https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/](https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ImageUtils.loadTexture()` function loads images. Let''s use a slightly
    more advanced version to render the `earth` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter for `loadTexture` is currently unused, and the third parameter
    is a callback that is invoked when the image is successfully loaded. (A fourth
    parameter is also accepted for an error callback function.) We''ve seen all the
    rest of this code before except the `overdraw` option, which eliminates small
    gaps between the mesh''s faces that arise due to limitations of the canvas API.
    (The `WebGLRenderer` does not need this property; it can align faces more perfectly.)
    You can see the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Materials](img/8539_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earth as a sphere with a mapped texture
  prefs: []
  type: TYPE_NORMAL
- en: The image used in this example is available in the Three.js package at `examples/textures/planets/land_ocean_ice_cloud_2048.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other options for different kinds of materials that are
    too complex to address in the space we have. You can read more about them in the
    documentation for the different materials. For example, the `MeshPhongMaterial`
    documentation ([http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial](http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial))
    includes notes on producing reflective surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: A city scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground with the Three.js API. Let's tie it all together
    with a project that uses what we've learned about geometry and materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve been working with a single object in our world. If we wanted
    to move it around, we''d have to change its `position` vector. We could create
    a full scene this way by adding multiple objects and manually positioning them.
    However, for worlds with more than a few objects, this can quickly get quite tedious.
    There are several alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rectangular layout**: This method involves storing a map in some simple format
    such as a string or an image, where each character or pixel color represents a
    type of object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Procedural generation**: This method involves the use of an algorithm to
    position objects semi-randomly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Editor**: This method involves the use of an external tool to construct the
    scene, followed by exporting the result (for example, in JSON format), and importing
    it when the application executes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rectangular format is the easiest for simple game levels, and we'll be using
    it in [Chapter 3](ch03.html "Chapter 3. Exploring and Interacting"), *Exploring
    and Interacting*. [Chapter 5](ch05.html "Chapter 5. Design and Development"),
    *Design and Development* discusses the editor approach in detail. For now, let's
    try procedurally creating a city, based on an example created by *Ricardo Cabello*
    (the original Three.js author) at [http://www.mrdoob.com/lab/javascript/webgl/city/01/](http://www.mrdoob.com/lab/javascript/webgl/city/01/).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a cube and material that we''ll use as the basis for our
    city buildings. We''ll copy our geometry and material for each new building and
    scale the geometry appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The second line from the previous code snippet moves the geometry's origin (the
    point around which the geometry is scaled and rotated) to the bottom so that when
    we scale up a building, all the buildings' floors will be at the same height.
    This is done by shifting the y coordinate of every vertex and face 0.5 units up
    using a matrix that represents a vertical translation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matrices can be thought of as rectangular arrays or tables with rows and columns.
    A matrix with four rows and four columns is particularly useful for storing information
    about objects in 3D space because a single 4 x 4 matrix can represent position,
    rotation, and scale. This is the only point in this book that will mention matrices,
    so it's okay if you don't understand the underlying math; one of the reasons to
    use Three.js is to avoid having to do linear algebra manually. The transformation
    we are doing in this case is just one short way to move all the vertices and faces
    of a geometry at once without moving its origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create all our buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that's new here is the `clone()` method. Almost all Three.js
    objects can be cloned to create a copy that can be modified without altering the
    original. We are taking advantage of that to create new geometry and material
    instances based on our original instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s position the camera in a place where it can get a better view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've seen rotation a couple of times now, but it's important to recall that
    rotation is measured in radians. The conversion we perform here tilts the camera
    45 degrees down. You can also use the convenient `lookAt` method. For example,
    `camera.lookAt(new THREE.Vector3(0, 0, 0))` turns the camera to look at the default
    scene origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add a floor as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The last two parameters to `PlaneGeometry()` split the plane into a 20 x 20
    grid. This prevents Three.js from optimizing away the floor if it thinks all the
    vertices are too far out of view. Also, the plane is created along the x and y
    axes initially, so we need to rotate it by -90 degrees to make it lie flat under
    the buildings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the result, shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A city scene](img/8539_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Procedurally generated cityscape
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s optimize the scene by merging the geometries of all the buildings. To
    do this, we''ll tweak the code that spawns our many buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The key here is that we're now merging all of the building meshes into a single
    `cityGeometry` using `GeometryUtils.merge()`. This is an important optimization
    for scenes with a lot of geometry that does not move independently because the
    renderer can more intelligently batch drawing calls if it knows about all the
    vertices and faces at once instead of drawing them one mesh at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lights are instances of `THREE.Light` that affect how the `MeshLambertMaterial`
    and `MeshPhongMaterial` surfaces are illuminated. Most lights have color (specified
    in hexadecimal notation like CSS colors) and intensity (a decimal value, usually
    between zero and one, indicating how bright the light should be). There are different
    kinds of lights as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Constructor | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ambient |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| It affects all lit objects in the scene equally. |'
  prefs: []
  type: TYPE_TB
- en: '| Directional |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| For this type, all light is parallel and comes from a given direction, as
    if the source was very far away. |'
  prefs: []
  type: TYPE_TB
- en: '| Hemisphere |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| It simulates refractive lighting from the sun, sort of like two opposing
    directional lights. |'
  prefs: []
  type: TYPE_TB
- en: '| Point |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| It emanates from a specific point in space, like a lightbulb. It illuminates
    only objects within `radius`. |'
  prefs: []
  type: TYPE_TB
- en: '| Spot |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| It emanates from a specific point in space in a specific direction. It illuminates
    objects in a cone pointing in its direction of rotation, falling off exponentially
    within a distance of `radius`. |'
  prefs: []
  type: TYPE_TB
- en: 'To update our procedural city scene with lighting, let''s first change the
    buildings'' material to respond to light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll add our light to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For directional lights, the direction of the light is the direction from `light.position`
    to `light.target.position`; both are vectors that you can change, and the target
    defaults to the world's origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also change our renderer to WebGL because `CanvasRenderer` does not
    support advanced lighting features such as shadows and fog, which we''ll want
    to add momentarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final touch now that our scene has lighting, let''s add fog for a little
    ambiance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are actually two kinds of fog. `FoxExp2` gets exponentially denser with
    distance, and appropriately its parameters are color and density exponent (a small
    decimal you will need to play around with depending on the scale of your world).
    The other kind of fog is `THREE.Fog`, which gets denser linearly; its parameters
    are color, minimum distance at which fog starts appearing, and maximum distance
    beyond which objects will be occluded by fog. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences between the two kinds of fog are difficult to capture in static
    images, but the next two screenshots show a contrast between exponential falloff
    and rapid linear falloff. The following screenshot shows `FogExp2` with low density:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting](img/8539_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows `Fog` with short falloff:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lighting](img/8539_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Only the `DirectionalLight` and `PointLight` objects can cast shadows. Casting
    shadows first requires that we enable shadows on the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can also set `renderer.shadowMapSoft = true`, which will somewhat
    smooth the edges of the shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, each object that will cast or receive shadows must be explicitly set
    to do so. (Shadows are disabled by default because calculating shadows can be
    slow.) For our city scene, we''ll enable shadow receiving for our floor and both
    casting and receiving for our buildings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `castShadow` and `receiveShadow` properties do pretty much what they sound
    like—enabling casting and receiving shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we configure our `DirectionalLight` object to use shadows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the light to cast a shadow and set how dark we want it to be. The darkness
    usually ranges from `0` (no shadows) to `1` (dark shadows), but it can have other
    values; values below `0` will cause a sort of anti-shadow, where objects that
    would be in shadow are instead illuminated, and values higher than `1` will make
    shadows appear very black. Then we set the resolution of our shadows with the
    `shadowMapWidth` and `shadowMapHeight` properties, which affect the crispness
    of shadows'' edges; higher values look sharper but are more computationally expensive.
    Next, we describe the **shadow camera** that will be used to project the shadows.
    In fact, when it comes to shadows, the `DirectionalLight` and `PointLight` objects
    are analogous to the `OrthographicCamera` and `PerspectiveCamera` objects in that
    the former uses parallel projection while the latter uses perspective projection.
    Therefore, to set up our camera, we move the light to a point that is far enough
    away to be able to *see* everything we want to have a shadow. Then we describe
    the shape of the frustum with the `shadowCamera` properties; the left, right,
    top, or bottom values are the lengths of the corresponding sides of the end of
    the frustum, and the `Far` value is the distance to the end of the frustum. (Recall
    from [Chapter 1](ch01.html "Chapter 1. Hello, Three.js"), *Hello, Three.js*, that
    a frustum is a shape encompassing what a camera can *see*.) If this is difficult
    to visualize, you can display the frustum like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a wireframe shape representing the shadow projection, shown in
    the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shadows](img/8539_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A shadow camera
  prefs: []
  type: TYPE_NORMAL
- en: The `DirectionalLight` object is positioned at the peak of the red cone, the
    ends of the yellow boxes are at the `shadowCameraNear` and `shadowCameraFar` distances,
    and the edges of the box are the size of the frustum. For `PointLights`, the entire
    frustum is a cone.
  prefs: []
  type: TYPE_NORMAL
- en: Renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we switched from `CanvasRenderer` to `WebGLRenderer` in order to support
    shadows and fog. As a rule of thumb, `WebGLRenderer` is faster and has the most
    features, while `CanvasRenderer` has fewer features but broader browser support.
    One particularly nice feature of `WebGLRenderer` is that it supports antialiasing
    to smooth out jagged edges. We can enable this for our cityscape by passing the
    option in to the renderer constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, our cityscape is finally complete, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Renderers](img/8539_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A completed city
  prefs: []
  type: TYPE_NORMAL
- en: Three.js has several other renderers, most notably for CSS and SVG. These can
    be found in the `examples/js/renderers` folder and are available as `THREE.CSS3DRenderer`
    and `THREE.SVGRenderer`, respectively, if their eponymous files are included in
    your HTML document. These renderers have a smaller set of supported features and
    are not as widely used, so they are not included in the main library, but they
    can be useful for scenes with a limited amount of primitive geometry and no lighting.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this book, we'll be using the `WebGLRenderer`, so if you're
    using a version before version 11 of Internet Explorer, you should switch to Chrome
    or Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If WebGL isn't available, your game can fall back to the `CanvasRenderer` or
    just display an error message. The easiest way to do this is with the script at
    `examples/js/Detector.js`. Once the script is included on your page, you can simply
    check the `Detector.webgl` Boolean to see if WebGL is supported on the current
    system. If it's not, you can call `Detector.addGetWebGLMessage()` to explain to
    the user why your game won't run on their device and how to switch to a browser
    that supports WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to work with different kinds of geometry, materials,
    and lighting. We also learned about renderers and scenes, and completed a project
    to build a city procedurally. In the next chapter, we'll learn about ways that
    users can interact with Three.js, add some physics to the mix, and build a basic
    first-person shooter game.
  prefs: []
  type: TYPE_NORMAL
