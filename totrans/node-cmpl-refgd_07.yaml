- en: Data Storage and Retrieval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we built a small and somewhat useful application
    for storing notes, and then made it work on mobile devices. While the application
    works reasonably well, it doesn't store those notes anywhere on a long-term basis,
    meaning the notes are lost when you stop the server and, if you run multiple instances
    of Notes, each instance has its own set of notes. The typical next step is to
    introduce a database tier.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at database support in Node.js, so the user sees
    the same set of notes for any Notes instance accessed, and to reliably store notes
    for long-term retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the *Notes* application code used in the previous chapter.
    We started with a simple, in-memory data model using an array to store the notes,
    and then made it mobile friendly. In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discover logging operational and debugging information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin using the ES6 module format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement data persistence for Notes objects using several database engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to duplicate the code from the previous chapter. For instance,
    if you were working in `chap06/notes`, duplicate that to be `chap07/notes`.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage and asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By definition, external data storage systems require asynchronous code in the
    Node.js architecture. The access time to retrieve data from disk, from another
    process, or from a database, always takes sufficient time to require deferred
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: The existing `Notes` data model is an in-memory data store. In theory, in-memory
    data access does not require asynchronous code and therefore, the existing model
    module could have used regular functions rather than `async` functions.
  prefs: []
  type: TYPE_NORMAL
- en: We knew that Notes must move to using databases, and would require an asynchronous
    API to access Notes data. For that reason, the existing Notes model API uses `async`
    functions so that in this chapter, we can persist Note data to databases.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get into databases, we have to address one of the attributes of a
    high-quality software system: managing logged information, including normal system
    activity, system errors, and debugging information. Logs give us an insight into
    the behavior of the system. How much traffic is it getting? If it''s a website,
    which pages are people hitting the most? How many errors occur and of what kind?
    Do attacks occur? Are malformed requests being sent?'
  prefs: []
  type: TYPE_NORMAL
- en: Log management is also an issue. Log rotation means regularly moving the log
    file out of the way, to start with a fresh log file. You should process logged
    data to produce reports. A high priority on screening for security vulnerabilities
    is a must.
  prefs: []
  type: TYPE_NORMAL
- en: The Twelve Factor application model suggests simply sending logging information
    to the console, and then some other software system captures that output and directs
    it to a logging service. Following their advice can reduce system complexity by
    having fewer things that can break. In a later chapter, we'll use PM2 for that
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first complete a tour of information logging as it stands right now in
    Notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we used the Express Generator to initially create the *Notes* application,
    it configured an activity logging system using `morgan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is what prints the requests on the Terminal window. Visit [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Express uses the **Debug** package for debugging traces. You can
    turn these on using the `DEBUG` environment variable. We should try to use this
    package in our application code. For more information, visit [https://www.npmjs.com/package/debug](https://www.npmjs.com/package/debug).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the application might generate uncaught exceptions. The `uncaughtException`
    error needs to be captured, logged, and dealt with appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Request logging with Morgan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Morgan package has two general areas for configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Log format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it stands, Notes uses the `dev` format, which is described as a concise status
    output meant for developers. This can be used to log web requests as a way to
    measure website activity and popularity. The Apache log format already has a large
    ecosystem of reporting tools and, sure enough, Morgan can produce log files in
    this format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the format, simply change this line in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run *Notes* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To revert to the previous logging output, simply do not set this environment
    variable. If you've looked at Apache access logs, this logging format will look
    familiar. The `::1` notation at the beginning of the line is IPV6 notation for
    the `localhost`, which you may be more familiar with as `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: We can declare victory on request logging and move on to debugging messages.
    However, let's look at logging this to a file directly. While it's possible to
    capture `stdout` through a separate process, Morgan is already installed in Notes
    and it does provide the capability to direct its output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Morgan documentation suggests this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But this has a problem; it's impossible to perform log rotation without killing
    and restarting the server. Instead, we'll use their `rotating-file-stream` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add this code to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using an environment variable, `REQUEST_LOG_FILE`, to control whether
    to send the log to `stdout` or to a file. The log can go into a directory, and
    the code will automatically create that directory if it doesn't exist. By using `rotating-file-stream` ([https://www.npmjs.com/package/rotating-file-stream](https://www.npmjs.com/package/rotating-file-stream)),
    we're guaranteed to have log file rotation with no extra systems required.
  prefs: []
  type: TYPE_NORMAL
- en: The `fs-extra` module is being used because it adds Promise-based functions
    to the `fs` module ([https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)).
    In this case, `fs.ensureDir` checks if the named directory structure exists and,
    if not, the directory path is created.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can generate quite a detailed trace of what Express does by running *Notes* this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty useful if you want to debug Express. But, we can use this in our
    own code as well. It is similar to inserting `console.log` statements, but without
    having to remember to comment out the debugging code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very simple to enable debugging in a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Capturing stdout and stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Important messages can be printed to `process.stdout` or `process.stderr`, which
    can be lost if you don't capture that output. The Twelve Factor model suggests
    using a system facility to capture these output streams. With Notes, we'll use
    PM2 for that purpose, which we'll cover in [Chapter 10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml),
    *Deploying Node.js Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The `logbook` module ([https://github.com/jpillora/node-logbook](https://github.com/jpillora/node-logbook))
    offers some useful capabilities in term of not only capturing `process.stdout`
    and `process.stderr`, but sending that output to useful places.
  prefs: []
  type: TYPE_NORMAL
- en: Uncaught exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uncaught exceptions is another area where important information can be lost.
    This is easy to fix in the *Notes* application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `debug` package has a convention we're following. For an application with
    several modules, all debugger objects should use the naming pattern `app-name:module-name`.
    In this case, we used `notes:error` that will be used for all error messages.
    We could also use `notes:memory-model` or `notes:mysql-model` for debugging different
    models.
  prefs: []
  type: TYPE_NORMAL
- en: While we were setting up the handler for uncaught exceptions, it is also a good
    idea to add error logging into the error handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Unhandled Promise rejections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Promise and `async` functions automatically channels errors in a useful
    direction.  Errors will cause a Promise to flip into a *rejected* state, which
    must eventually be handled in a `.catch` method.  Since we're all human, we're
    bound to forget to ensure that all code paths handle their rejected Promise's.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, Node.js prints the following warning if it detects an unhandled
    Promise rejection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The warning goes on to say that the default handler for unhandled Promise rejection
    has been deprecated and that such Promise rejections will crash the Node process
    rather than print this message. The built-in `process` module does emit an event
    in this case, so it''s easy enough to add a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the minimum, we can print an error message such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the ES6 module format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wrote the *Notes* application using CommonJS modules, the traditional Node.js
    module format. While the application could continue using that format, the JavaScript
    community has chosen to switch to ES6 modules in both browser and Node.js code,
    and therefore it's important to switch ES6 modules so we can all get on board
    with a common module format. Let's rewrite the application using ES6 modules,
    and then write ES6 modules for anything new we add.
  prefs: []
  type: TYPE_NORMAL
- en: The changes required are large to replace `require` statements with `import`
    statements, and renaming files from `foo.js` to `foo.mjs`. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting app.js as an ES6 module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with `app.js`, changing its name to `app.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the block of `require` statements at the top to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the bottom of the script, make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's talk a little about the workaround mentioned here. There were several
    global variables automatically injected by Node.js into CommonJS modules. Those
    variables are not supported by ES6 modules. The critical variable for *Notes*
    is `__dirname`, which is used in `app.mjs` in several places. The code change
    shown here includes a workaround based on a brand new JavaScript feature that
    is available starting in Node.js 10.x, the `import.meta.url` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `import.meta` object is meant to inject useful information into an ES6 module.
    As the name implies, the `import.meta.url` variable contains the URL describing
    where the module was loaded from.  For Node.js, at this time, ES6 modules can
    only be loaded from a `file://` URL on the local filesystem. That means, if we
    extract the `pathname` of that URL, we can easily calculate the directory containing
    the module, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Why this solution? Why not use a pathname beginning with `./`?  The answer is
    that a `./` filename is evaluated relative to the process's current working directory.
    That directory is usually different from the directory containing the Node.js
    module being executed.  Therefore it is more than convenient that the Node.js
    team has added the `import.meta.url` feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern followed in most cases is this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember that Node.js uses the same module lookup algorithm in both ES6 and
    CommonJS modules. A Node.js `require` statement is synchronous, meaning that by
    the time `require` finishes, it has executed the module and is returning its `module.exports`.
    By contrast, an ES6 module is asynchronous, meaning the module may not have finished
    loading, and you can import just the required bits of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the module imports shown here are for regular Node.js modules installed
    in the `node_modules` directory, most of which are CommonJS modules. The rule
    for using `import` with a CommonJS module is that the `module.exports` object
    is treated as if it were the default export. The `import` statement shown earlier
    name the default export (or the `module.exports` object) as shown in the `import`
    statement. For a CommonJS module imported this way, you then use it as you would
    in a CommonJS context, `moduleName.functionName()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of the `debug` module is effectively the same, but is coded differently.
    In the CommonJS context, we''re told to use that module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the `module.exports` of this module is a function, which we
    immediately invoke. There isn't a syntax for ES6 modules to use the `debug` module
    in that fashion. Therefore, we had to break it apart as shown, and explicitly
    call that function.
  prefs: []
  type: TYPE_NORMAL
- en: The final point of discussion is the `import` of the two router modules. It
    was first attempted to have those modules export the `router` as the default value,
    but Express threw an error in that case. Instead, we'll rewrite these modules
    to export `router` as a named export and then use that named export as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting bin/www as an ES6 module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that `bin/www` is a script used to launch the application. It is written
    as a CommonJS script, but because `app.mjs` is now an ES6 module, `bin/www` also
    must be rewritten as an ES6 module. A CommonJS module cannot, at the time of writing,
    import an ES6 module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the top, change the `require` statements to `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've already discussed everything here except that `app.mjs` exports its `app`
    object as the default export. Therefore, we use it as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting models code as ES6 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The models directory contains two modules: `Note.js` defines the `Note` class,
    and `notes-memory.js` contains an in-memory data model. Both are easy to convert
    to ES6 modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Note.mjs`, simply make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This makes the `Note` class the default export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `notes-memory.mjs`, make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward transliteration of assigning functions to `module.exports`
    to using named exports.
  prefs: []
  type: TYPE_NORMAL
- en: By defining the `Note` class as the default export of the `Note.mjs` module,
    it `import`s nicely  into any module using that class.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting router modules as ES6 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `routes` directory contains two router modules. As it stands, each router
    module creates a `router` object, adds route functions to that object, and then
    assigns it to the `module.exports` field. That suggests we should export the `router`
    as the default export, but as we said earlier, that didn't work out right. Instead,
    we'll export `router` as a named export.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the top of each, change the `require` statement block to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It will be the same in both files. Then, at the bottom of each file, delete
    the line assigning `router` to `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn to `app.mjs` and change how the router modules are imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `router` is a named export, by default you''d import the `router` object,
    in `app.mjs`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But then we''d have a conflict since both modules define a `router` object.
    Instead, we changed the name of this object using an `as` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `router` object from each module is hence given a suitable name.
  prefs: []
  type: TYPE_NORMAL
- en: Storing notes in the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The filesystem is an often overlooked database engine. While filesystems don't
    have the sort of query features supported by database engines, they are a reliable
    place to store files. The notes schema is simple enough that the filesystem can
    easily serve as its data storage layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a function to `Note.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`JSON` is a getter, which means it gets the value of the object. In this case,
    the `note.JSON` attribute/getter, no parentheses, will simply give us the JSON
    representation of the Note. We''ll use this later for writing to JSON files.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fromJSON` is a static function, or factory method, to aid in constructing
    `Note` objects if we have a JSON string. The difference is that `JSON` is associated
    with an instance of the `Note` class, while `fromJSON` is associated with the
    class itself. The two can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a new module, `models/notes-fs.mjs`, to hold the filesystem
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `notesDir` function will be used throughout `notes-fs` to ensure that the
    directory exists. To make this simple, we're using the `fs-extra` module because
    it adds Promise-based functions to the `fs` module ([https://www.npmjs.com/package/fs-extra](https://www.npmjs.com/package/fs-extra)).
    In this case, `fs.ensureDir` verifies whether the named directory structure exists,
    and, if not, the directory path is created.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variable, `NOTES_FS_DIR`, configures a directory within which
    to store notes. We'll have one file per note and store the note as JSON. If no
    environment variable is specified, we'll fall back on using `notes-fs-data` as
    the directory name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re adding another dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename for each data file is the `key` with `.json` appended. That gives
    one limitation that filenames cannot contain the `/` character, so we test for
    that using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As is the case with the `notes-memory` module, the `create` and `update` functions
    use the exact same code. The `notesDir` function is used to ensure that the directory
    exists, then we create a `Note` object, and then write the data to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the code is very straightforward because of the `async` function.
    We aren''t checking for errors because they''ll be automatically caught by the
    `async` function and bubble out to our caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `readJSON`, read the file from the disk. It already generates the `Note`
    object, so all we have to do is return that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fs.unlink` function deletes our file. Because this module uses the filesystem,
    deleting the file is all that''s necessary to delete the `note` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The contract for `keylist` is to return a Promise that will resolve to an array
    of keys for existing note objects. Since they're stored as individual files in
    the `notesdir`, we have to read every file in that directory to retrieve its key.
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.map` constructs a new array from an existing array, namely the array
    of filenames returned by `fs.readdir`. Each entry in the constructed array is
    the `async` function, which reads the Note, returning the `key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Counting the number of notes is simply a matter of counting the number of files in
    `notesdir`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic import of ES6 modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start modifying the router functions, we have to consider how to account
    for multiple models. We currently have two modules for our data model, `notes-memory`
    and `notes-fs`, and we'll be implementing several more by the end of this chapter.
    We will need a simple method to select between the model being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several possible ways to do this. For example, in a CommonJS module,
    it''s possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This lets us set an environment variable, `NOTES_MODEL`, to select the module
    to use for the data model.
  prefs: []
  type: TYPE_NORMAL
- en: This approach does not work with the regular `import` statement, because the
    module name in an `import` statement cannot be such an expression.  The Dynamic
    Import feature now in Node.js does offer a mechanism similar to the snippet just
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic import is an `import()` function that returns a Promise that will resolve
    to the imported module. As a function-returning-a-Promise, `import()` won''t be
    useful as top-level code in the module. But, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Save that module in a file, `models/notes.mjs`. This module implements the same
    API as we'll use for all Notes model modules. The `model()` function is the key
    to dynamically selecting a notes model implementation based on an environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: This is an `async` function and therefore its return value is a Promise. The
    value of that Promise is the selected module, as loaded by `import()`. Because
    `import()` returns a Promise, we use `await` to know whether it loaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every API method follows this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `model()` returns a Promise, it''s most succinct to use an `async`
    function and use `await` to resolve the Promise. Once the Promise is resolved,
    we simply call the `methodName` function and go about our business. Otherwise,
    those API method functions would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The two implementations are equivalent, and it's clear which is the more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this `await`ing on Promise''s returned from `async` functions, it''s
    worth discussing the overhead. The worst case is on the first call to `model()`,
    because the selected notes model has not been loaded. The first time around, the
    call flow goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The API method calls `model()`, which calls `import()`, then `await`'s the module
    to finish loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API method `await`'s the Promise returned from `model()`, getting the module
    object, and it then calls the API function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller is also using `await` to receive the final result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first time around, the time is dominated by waiting on `import()` to finish
    loading the module. On subsequent calls, the module has already been loaded and
    the first step is to simply form a resolved Promise containing the module. The
    API method can then quickly get on with delegating to the actual API method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this, in `routes/index.mjs`, and in `routes/notes.mjs`, we make this
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Running the Notes application with filesystem storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `package.json`, add this to the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When you put these entries in `package.json`, make sure that you use correct
    JSON syntax. In particular, if you leave a comma at the end of the `scripts` section,
    it will fail to parse and npm will throw up an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can now run the *Notes* application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Then we can use the application at `http://localhost:3000` as before. Because
    we did not change any template or CSS files, the application will look exactly
    as you left it at the end of Chapter 6, *Implementing the Mobile-First Paradigm*.
  prefs: []
  type: TYPE_NORMAL
- en: Because debugging is turned on for `notes:*`, we'll see a log of whatever the
    *Notes* application is doing. It's easy to turn this off simply by not setting
    the `DEBUG` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now kill and restart the *Notes* application and see the exact same
    notes. You can also edit the notes at the command line using regular text editors
    such as `vi`. You can now start multiple servers on different ports and see exactly
    the same notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Then you start `server1` and `server2` in separate command windows as we did
    in [Chapter 5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml), *Your First Express
    Application*. Then, visit the two servers in separate browser windows, and you
    will see that both browser windows show the same notes.
  prefs: []
  type: TYPE_NORMAL
- en: The final check is to create a note where the key has a `/` character. Remember
    that the key is used to generate the filename where we store the note, and therefore
    the key cannot contain a `/` character. With the browser open, click on ADD Note
    and enter a note, ensuring that you use a `/` character in the `key` field. On
    clicking the Submit button, you'll see an error saying that this isn't allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Storing notes with the LevelUP data store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with actual databases, let''s look at an extremely lightweight, small-footprint
    database engine: **LevelUP**. This is a Node.js-friendly wrapper around the LevelDB
    engine developed by Google, which is normally used in web browsers for local data
    persistence. It is a non-indexed, NoSQL data store designed originally for use
    in browsers. The Node.js module, Level, uses the LevelDB API, and supports multiple
    backends, including `LevelDOWN`, which integrates the C++ LevelDB database into
    Node.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://www.npmjs.com/package/level](https://www.npmjs.com/package/level)
    for information on the module. The `level` package automatically sets up the `levelup`
    and `leveldown` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the database engine, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start creating the `models/notes-level.mjs` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `level` module gives us a `db` object through which to interact with the
    database. We're storing that object as a global within the module for ease of
    use. If the `db` object is set, we can just return it immediately. Otherwise,
    we open the database using `createIfMissing` to go ahead and create the database
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of the database defaults to `notes.level` in the current directory.
    The environment variable `LEVELDB_LOCATION` can be set, as the name implies, to
    specify the database location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `db.put` either creates a new database entry, or replaces an existing
    one. Therefore, both `update` and `create` are set to be the same function. We
    convert the Note to JSON so it can be easily stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading a Note is easy: just call `db.get` and it retrieves the data, which
    must be decoded from the JSON representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `db.get` and `db.put` did not take a callback function, and that
    we use `await` to get the results value. The functions exported by `level` can
    take a callback function, in which the callback will be invoked. Alternatively,
    if no callback function is provided, the `level` function will instead return
    a Promise for compatibility with `async` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `db.destroy` function deletes a record from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `createKeyStream` function uses an event-oriented interface similar to the
    Streams API. It will stream through every database entry, emitting events as it
    goes. A `data` event is emitted for every key in the database, while the `end`
    event is emitted at the end of the database, and the `error` event is emitted
    on errors. The effect is that there's no simple way to present this as a simple
    Promise. Instead, we invoke `createKeyStream`, let it run its course, collecting
    data as it goes. We have to wrap it inside a Promise object, and call resolve
    on the `end` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add this to `package.json` in the `scripts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can run the *Notes* application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The printout in the console will be the same, and the application will also
    look the same. You can put it through its paces and see that everything works
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Since `level` does not support simultaneous access to a database from multiple
    instances, you won't be able to use the multiple *Notes* application scenario.
    You will, however, be able to stop and restart the application at will without
    losing any notes.
  prefs: []
  type: TYPE_NORMAL
- en: Storing notes in SQL with SQLite3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with more normal databases, let's see how to use SQL from Node.js.
    First, we'll use SQLite3, a lightweight, simple-to-set-up database engine eminently
    suitable for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about that database engine, visit [http://www.sqlite.org/](http://www.sqlite.org/).
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the Node.js module, visit [https://github.com/mapbox/node-sqlite3/wiki/API](https://github.com/mapbox/node-sqlite3/wiki/API)
    or [https://www.npmjs.com/package/sqlite3](https://www.npmjs.com/package/sqlite3).
  prefs: []
  type: TYPE_NORMAL
- en: The primary advantage of SQLite3 is that it doesn't require a server; it is
    a self-contained, no-set-up-required SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: SQLite3 database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to make sure that our database is configured. We''re using this
    SQL table definition for the schema (save this as `models/schema-sqlite3.sql`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we initialize this schema before writing some code? One way is to ensure
    that the `sqlite3` package is installed through your operating system package
    management system, such as using `apt-get` on Ubuntu/Debian, and MacPorts on macOS.
    Once it''s installed, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: While we can do that, the Twelve Factor application model says we must automate
    any administrative processes in this way. To that end, we should instead write
    a little script to run an SQL operation on SQLite3 and use that to initialize
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the `sqlite3` command offers us a way to do this. Add the following
    to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the setup script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We could have written a small Node.js script to do this, and it's easy to do
    so. However, by using the tools provided by the package, we have less code to
    maintain in our own project.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite3 model code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can write code to use this database in the *Notes* application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `models/notes-sqlite3.mjs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This serves the same purpose as the `connectDB` function in `notes-level.mjs`:
    to manage the database connection. If the database is not open, it''ll go ahead
    and do so, and even make sure that the database file is created (if it doesn''t
    exist). But if it is already open, it is immediately returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: These are our `create` and `update` functions. As promised, we are now justified
    in defining the Notes model to have separate functions for `create` and `update`
    operations, because the SQL statement for each is different.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `db.run` executes an SQL query, giving us the opportunity to insert
    parameters into the query string.
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite3` module uses a parameter substitution paradigm that's common in SQL
    programming interfaces. The programmer puts the SQL query into a string, and then
    places a question mark in each place where the aim is to insert a value into the
    query string. Each question mark in the query string has to match a value in the
    array provided by the programmer. The module takes care of encoding the values
    correctly so that the query string is properly formatted, while preventing SQL
    injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `db.run` function simply runs the SQL query it is given, and does not retrieve any
    data. Because the `sqlite3` module doesn''t produce any kind of Promise, we have
    to wrap function calls in a `Promise` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To retrieve data using the `sqlite3` module, you use the `db.get`, `db.all`,
    or `db.each` functions. The `db.get` function used here returns only the first
    row of the result set. The `db.all` function returns all rows of the result set
    at once, which can be a problem for available memory if the result set is large.
    The `db.each` function retrieves one row at a time, while still allowing processing
    of the entire result set.
  prefs: []
  type: TYPE_NORMAL
- en: For the *Notes* application, using `db.get` to retrieve a note is sufficient
    because there is only one note per `notekey`. Therefore, our `SELECT` query will
    return at most one row anyway. But what if your application will see multiple
    rows in the result set? We'll see what to do about that in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, this `read` function has a bug in it. See if you can spot the error.
    We''ll read more about this in Chapter 11, *Unit Testing and Functional Testing*,
    when our testing efforts uncover the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To destroy a note, we simply execute the `DELETE FROM` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `db.all` function retrieves all rows of the result set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract for this function is to return an array of note keys. The `rows`
    object is an array of results from the database that contains the data we are
    to return, but in a different format. Therefore, we use the `map` function to
    convert the array into the format required to fulfill the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can simply use SQL to count the number of notes for us. In this case, `db.get`
    returns a row with a single column, `count`, which is the value we want to return.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes with SQLite3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we''re ready to run the *Notes* application with SQLite3\. Add the
    following code to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the *Notes* application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can now browse the application at `http://localhost:3000`, and run it through
    its paces as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because SQLite3 supports simultaneous access from multiple instances, you can
    run the multiserver example by adding this to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Then, run each of these in separate command Windows, as before.
  prefs: []
  type: TYPE_NORMAL
- en: Because we still haven't made any changes to the View templates or CSS files, the
    application will look the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use the `sqlite` command, or other SQLite3 client applications,
    to inspect the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Storing notes the ORM way with Sequelize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several popular SQL database engines, such as PostgreSQL, MySQL ([https://www.npmjs.com/package/mysql](https://www.npmjs.com/package/mysql)),
    and MariaDB ([https://www.npmjs.com/package/mariasql](https://www.npmjs.com/package/mariasql)).
    Corresponding to each are Node.js client modules similar in nature to the `sqlite3`
    module that we just used. The programmer is close to the SQL, which can be good
    in the same way that driving a stick shift car is fun. But what if we want a higher-level
    view of the database so that we can think in terms of objects rather than rows
    of a database table? **Object Relation Mapping** (**ORM**) systems provide such
    a higher-level interface and even offer the ability to use the same data model
    with several databases.
  prefs: []
  type: TYPE_NORMAL
- en: The **Sequelize** module ([http://www.sequelizejs.com/](http://www.sequelizejs.com/))
    is Promise-based, offers strong, well-developed ORM features, and can connect
    with SQLite3, MySQL, PostgreSQL, MariaDB, and MSSQL. Because Sequelize is Promise-based,
    it will fit naturally with the Promise-based application code we're writing.
  prefs: []
  type: TYPE_NORMAL
- en: A prerequisite to most SQL database engines is having access to a database server.
    In the previous section, we skirted around that issue by using SQLite3, which
    requires no database server setup. While it's possible to install a database server
    on your laptop, we want to avoid the complexity of doing so, and will use Sequelize
    to manage an SQLite3 database. We'll also see that it's simply a matter of a configuration
    file to run the same Sequelize code against a hosted database such as MySQL. In [Chapter
    10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml), *Deploying Node.js Applications*,
    we'll learn how to use Docker to easily set up any service, including database
    servers, on our laptop and deploy the exact same configuration to a live server. Most
    web hosting providers offer MySQL or PostgreSQL as part of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start on the code, let''s install two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The first obviously installs the Sequelize package. The second, `js-yaml`, is
    installed so that we can implement a YAML-formatted file to store the Sequelize
    connection configuration. YAML is a human-readable *data serialization language*,
    which simply means YAML is an easy-to-use text file format to describe data objects.
    Perhaps the best place to learn about YAML is its Wikipedia page at [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML).
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize model for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new file, `models/notes-sequelize.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The database connection is stored in the `sequlz` object, and is established
    by reading a configuration file (we'll go over this file later), and instantiating
    a Sequelize instance. The data model, `SQNote`, describes our object structure to
    Sequelize so that it can define corresponding database table(s). If `SQNote` is
    already defined, we simply return it, otherwise we define and return `SQNote`.
  prefs: []
  type: TYPE_NORMAL
- en: The Sequelize connection parameters are stored in a YAML file we specify in
    the `SEQUELIZE_CONNECT` environment variable. The line `new Sequelize(..)` opens
    the database connection. The parameters obviously contain any needed database
    name, username, password, and other options required to connect with the database.
  prefs: []
  type: TYPE_NORMAL
- en: The line `sequlz.define` is where we define the database schema. Instead of
    defining the schema as the SQL command to create the database table, we're giving
    a high-level description of the fields and their characteristics. Sequelize maps
    the object attributes into columns in tables.
  prefs: []
  type: TYPE_NORMAL
- en: We're telling Sequelize to call this schema Note, but we're using a `SQNote`
    variable to refer to that schema. That's because we already defined Note as a
    class to represent notes. To avoid a clash of names, we'll keep using the `Note`
    class, and use SQNote to interact with Sequelize about the notes stored in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Online documentation can be found at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize class: [http://docs.sequelizejs.com/en/latest/api/sequelize/](http://docs.sequelizejs.com/en/latest/api/sequelize/).
    [](http://docs.sequelizejs.com/en/latest/api/sequelize/) Defining models: [http://docs.sequelizejs.com/en/latest/api/model/](http://docs.sequelizejs.com/en/latest/api/model/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these functions to `models/notes-sequelize.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways to create a new object instance in Sequelize. The simplest is
    to call an object's `create` function (in this case, `SQNote.create`). That function
    collapses together two other functions, `build` (to create the object), and `save`
    (to write it to the database).
  prefs: []
  type: TYPE_NORMAL
- en: Updating an object instance is a little different. First, we must retrieve its
    entry from the database using the `find` operation. The `find` operation is given
    an object specifying the query. Using `find`, we retrieve one instance, whereas
    the `findAll` operation retrieves all matching instances.
  prefs: []
  type: TYPE_NORMAL
- en: For documentation on Sequelize queries, visit [http://docs.sequelizejs.com/en/latest/docs/querying/](http://docs.sequelizejs.com/en/latest/docs/querying/).
  prefs: []
  type: TYPE_NORMAL
- en: Like most or all other Sequelize functions, `SQNote.find` returns a Promise.
    Therefore, inside an `async` function, we `await` the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update operation requires two steps, the first being to `find` the corresponding
    object to read it in from the database. Once the instance is found, we can update
    its values simply with the `updateAttributes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: To read a note, we use the `find` operation again. There is the possibility
    of an empty result, and we have to throw an error to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contract for this function is to return a `Note` object. That means taking
    the fields retrieved using Sequelize and using that to create a `Note` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To destroy a note, we use the `find` operation to retrieve its instance, and
    then call its `destroy()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `keylist` function acts on all `Note` objects, we use the `findAll`
    operation. We query for the `notekey` attribute on all notes. We''re given an
    array of objects with a field named `notekey`, and we use the `.map` function
    to convert this into an array of the note keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: For the `count` function, we can just use the `count()` method to calculate
    the needed result.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Sequelize database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequelize supports the same API on several SQL database engines. The database
    connection is initialized using parameters on the Sequelize constructor. The Twelve
    Factor Application model suggests that configuration data such as this should
    be kept outside the code and injected using environment variables or a similar
    mechanism. What we'll do is use a YAML-formatted file to store the connection
    parameters, specifying the filename with an environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Sequelize library does not define any such file for storing connection parameters.
    But it's simple enough to develop such a file. Let's do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API for the Sequelize constructor is: `constructor(database: String, username:
    String, password: String, options: Object)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `connectDB` function, we wrote the constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This file, named `models/sequelize-sqlite.yaml`, provides with us a simple
    mapping that looks like this for an SQLite3 database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The YAML file is a direct mapping to the Sequelize constructor parameters. The `dbname`,
    `username`, and `password` fields in this file correspond directly to the connection
    credentials, and the `params` object gives additional parameters. There are many,
    many, possible attributes to use in the `params` field, and you can read about
    them in the Sequelize documentation at [http://docs.sequelizejs.com/manual/installation/usage.html](http://docs.sequelizejs.com/manual/installation/usage.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `dialect` field tells Sequelize what kind of database to use. For an SQLite
    database, the database filename is given in the `storage` field.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first use SQLite3, because no further setup is required. After that, we'll
    get adventurous and reconfigure our Sequelize module to use MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have a different database server available, it''s simple to
    create a corresponding configuration file. For a plausible MySQL database on your
    laptop, create a new file, such as `models/sequelize-mysql.yaml`, containing something
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is straightforward. The `username` and `password` must correspond to the
    database credentials, while `host` and `port` will specify where the database
    is hosted.  Set the database `dialect` and other connection information, and you're
    good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use MySQL, you will need to install the base MySQL driver so that Sequelize
    can use MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Running with Sequelize against other databases it supports, such as PostgreSQL, is
    just as simple. Just create a configuration file, install the Node.js driver,
    and install/configure the database engine.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Notes application with Sequelize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can get ready to run the *Notes* application using Sequelize. We can
    run this against both SQLite3 and MySQL, but let''s start with SQLite. Add this
    entry to the `scripts` entry in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As before, the application looks exactly the same because we've not changed
    the View templates or CSS files. Put it through its paces and everything should
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Sequelize, multiple *Notes* application instances is as simple as adding
    these lines to the `scripts` section of `package.json`, and then starting both
    instances as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You will be able to start both instances, use separate browser windows to visit
    both instances, and see that they show the same set of notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate using the Sequelize-based model on a given database server:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and provision the database server instance, or else get the connection
    parameters for an already-provisioned database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the corresponding Node.js driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a YAML configuration file corresponding to the connection parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create new `scripts` entries in `package.json` to automate starting Notes against
    that database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing notes in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is widely used with Node.js applications, a sign of which is the popular
    MEAN acronym: MongoDB (or MySQL), Express, Angular, and Node.js. MongoDB is one
    of the leading NoSQL databases. It is described as a *scalable, high-performance,
    open source, document-oriented database*. It uses JSON-style documents with no
    predefined, rigid schema and a large number of advanced features. You can visit
    their website for more information and documentation at [http://www.mongodb.org](http://www.mongodb.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the Node.js driver for MongoDB can be found at [https://www.npmjs.com/package/mongodb](https://www.npmjs.com/package/mongodb)
    and [http://mongodb.github.io/node-mongodb-native/](http://mongodb.github.io/node-mongodb-native/).
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose is a popular ORM for MongoDB ([http://mongoosejs.com/](http://mongoosejs.com/)).
    In this section, we'll use the native MongoDB driver instead, but Mongoose is
    a worthy alternative.
  prefs: []
  type: TYPE_NORMAL
- en: You will need a running MongoDB instance. The `compose.io` ([https://www.compose.io/](https://www.compose.io/))
    and `ScaleGrid.io` ([https://scalegrid.io/](https://scalegrid.io/)) hosted service
    providers offer hosted MongoDB services. Nowadays, it is straightforward to host
    MongoDB as a Docker container as part of a system built of other Docker containers.
    We'll do this in Chapter 11, *Unit Testing and Functional Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to set up a temporary MongoDB instance for testing on, say, your
    laptop. It is available in all the operating system package management systems,
    and the MongoDB website has instructions ([https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)).
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, it's not necessary to set up MongoDB as a background service.
    Instead, you can run a couple of simple commands to get a MongoDB instance running
    in the foreground of a command window, which you can kill and restart any time
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one command window, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In another command window, you can test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This saves a *document* in the collection named `foo`. The second command finds
    all documents in `foo`, printing them out for you. The `_id` field is added by
    MongoDB and serves as a document identifier. This is useful for testing and debugging.
    For a real deployment, your MongoDB server must be properly installed on a server.
    See the MongoDB documentation for these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB model for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've proved you have a working MongoDB server, let's get to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing the Node.js driver is as simple as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new file, `models/notes-mongodb.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MongoClient` class is used to connect with a MongoDB instance. The required
    URL, which will be specified through an environment variable, uses a straightforward
    format: `mongodb://localhost/`. The database name is specified via another environment
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation for the corresponding objects can be found at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html](http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html)
    for MongoClient and [http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html) for Db'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates the database client, and then opens the database connection. Both
    objects are returned from `connectDB` in an anonymous object. The general pattern
    for MongoDB operations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, our model methods require both `client` and `db` objects, because
    they will use both. Let''s see how that''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve `db` and `client` into individual variables using a destructuring
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB stores all documents in collections. A *collection* is a group of related
    documents, and a collection is analogous to a table in a relational database.
    This means creating a new document or updating an existing one starts by constructing
    it as a JavaScript object, and then asking MongoDB to save that object to the
    database. MongoDB automatically encodes the object into its internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: The `db.collection` method gives us a `Collection` object with which we can
    manipulate the named collection. See its documentation at [http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html).
  prefs: []
  type: TYPE_NORMAL
- en: As the method name implies, `insertOne` inserts one document into the collection.
    Likewise, the `updateOne` method first finds a document (in this case, by looking
    up the document with the matching `notekey` field), and then changes fields in
    the document as specified.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see that these methods return a Promise. The `mongodb` driver supports
    both callbacks and Promises. Many methods will invoke the callback function if
    one is provided, otherwise it returns a Promise that will deliver the results
    or errors. And, of course, since we're using `async` functions, the `await` keyword
    makes this so clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further documentation can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert: [https://docs.mongodb.org/getting-started/node/insert/](https://docs.mongodb.org/getting-started/node/insert/).
    [](https://docs.mongodb.org/getting-started/node/insert/) Update: [https://docs.mongodb.org/getting-started/node/update/](https://docs.mongodb.org/getting-started/node/update/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at reading a note from MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `mongodb` driver supports several variants of `find` operations. In this
    case, the *Notes* application ensures that there is exactly one document matching
    a given key. Therefore, we can use the `findOne` method. As the name implies,
    `findOne` will return the first matching document.
  prefs: []
  type: TYPE_NORMAL
- en: The argument to `findOne` is a query descriptor. This simple query looks for
    documents whose `notekey` field matches the requested `key`. An empty query will,
    of course, match all documents in the collection. You can match against other
    fields in a similar way, and the query descriptor can do much more. For documentation
    on queries, visit [https://docs.mongodb.org/getting-started/node/query/](https://docs.mongodb.org/getting-started/node/query/).
  prefs: []
  type: TYPE_NORMAL
- en: The `insertOne` method we used earlier also took the same kind of query descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to satisfy the contract for this function, we create a `Note` object
    and then return it to the caller. Hence, we create a Note using the data retrieved from
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the `find` variants is `findOneAndDelete`. As the name implies, it finds
    one document matching the query descriptor, and then deletes that document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using the base `find` operation and giving it an empty query so
    that it matches every document. What we're to return is an array containing the
    `notekey` for every document.
  prefs: []
  type: TYPE_NORMAL
- en: All of the `find` operations return a `Cursor` object. The documentation can
    be found at [http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Cursor object is, as the name implies, a pointer into a result set from
    a query. It has a number of useful functions related to operating on a result
    set. For example, you can skip the first few items in the results, or limit the
    size of the result set, or perform the `filter` and `map` operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cursor.forEach` method takes two callback functions. The first is called
    on every element in the result set. In this case, we can use that to record just
    the `notekey` in an array. The second callback is called after all elements in
    the result set have been processed. We use this to indicate success or failure,
    and to return the `keyz` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `forEach` uses this pattern, it does not have an option for supplying
    a Promise, and we have to create the Promise ourselves, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `count` method takes a query descriptor and, as the name implies, counts
    the number of matching documents.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Notes application with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our MongoDB model, we can get ready to run *Notes* with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now you know the drill; add this to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `MONGO_URL` environment variable is the URL to connect with your MongoDB
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the *Notes* application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can browse the application at `http://localhost:3000` and put it through
    its paces. You can kill and restart the application, and your notes will still
    be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to the `scripts` section of `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: You will be able to start two instances of the *Notes* application, and see
    that both share the same set of notes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through a real whirlwind of different database technologies.
    While we looked at the same seven functions over and over, it's useful to be exposed
    to the various data storage models and ways of getting things done. Even so, we
    only touched the surface of options for accessing databases and data storage engines from
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: By abstracting the model implementations correctly, we were able to easily switch
    data storage engines while not changing the rest of the application. We did skip
    around the issue of setting up database servers. As promised, we'll get to that
    in [Chapter 10,](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml) *Deploying Node.js
    Applications*, when we explore production deployment of Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: By focusing the model code on the purpose of storing data, both the models and
    the application should be easier to test. The application can be tested with a
    mock data module that provides known predictable notes that can be checked predictably.
    We'll look at this in more depth in Chapter 11, *Unit Testing and Functional Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on authenticating our users using OAuth2.
  prefs: []
  type: TYPE_NORMAL
