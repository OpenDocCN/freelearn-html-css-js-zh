<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Why Node.js?"><div class="titlepage" id="aid-DB7S2"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Why Node.js?</h1></div></div></div><p>Node.js is still relatively new compared to platforms such as .NET and Java, but has become very popular in a short time, and has even started influencing these platforms. This is thanks to its distinctive programming model, extensive ecosystem, and powerful tooling.</p><p>These factors make Node.js a compelling alternative to other platforms. They can also make it intimidating. Its distinctive programming model may seem quite alien compared to other platforms. The sheer range of available libraries and tools can be bewildering.</p><p>This book will guide you through Node.js so you can start using it in your applications. It will help you to understand Node.js, navigate its ecosystem, and leverage your existing development skills in this new environment.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Introducing the Node.js platform</li><li class="listitem">Seeing how its execution model works</li><li class="listitem">Exploring the Node.js ecosystem</li><li class="listitem">Looking at JavaScript as a language choice</li><li class="listitem">Considering the range of use cases for Node.js</li></ul></div><div class="section" title="What is Node.js?"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is Node.js?</h1></div></div></div><p>Node.js<a id="id0" class="indexterm"/> consists of a JavaScript engine together with low-level APIs for core server-side functionality. The execution engine is the same V8 engine developed for the Chrome web browser. Node.js takes this engine and embeds it in a standalone application that can run JavaScript outside the browser.</p><p>In Node.js, the standard APIs found in browsers to support client-side web development, such as<a id="id1" class="indexterm"/> the <span class="strong"><strong>Document Object Model</strong></span> <span class="strong"><strong>(DOM)</strong></span> and <code class="literal">XMLHttpRequest</code>, are not present. Instead, there are APIs to support general-purpose application development. These core APIs cover low-level functionality such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Networking and security</li><li class="listitem">Accessing the file system</li><li class="listitem">Defining and requiring modules</li><li class="listitem">Raising and consuming events</li><li class="listitem">Handling binary data streams</li><li class="listitem">Compression</li><li class="listitem">UTF-8 support</li><li class="listitem">Retrieving basic information about the OS</li><li class="listitem">Managing child processes</li></ul></div><p>Some of these <a id="id2" class="indexterm"/>APIs may already be familiar from developing client-side JavaScript. For example, the Timers API exposes the familiar <code class="literal">setTimeout</code> and <code class="literal">setInterval</code> functions.</p><p>Node.js also provides several tools to help with the development process. These include console logging, debugging, a <span class="strong"><strong>Read-Eval-Print Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) (or interactive console), and basic <a id="id3" class="indexterm"/>assertions for testing.</p><div class="section" title="Understanding the Node.js execution model"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Understanding the Node.js execution model</h2></div></div></div><p>The execution model of Node.js follows that of JavaScript in the browser. It is quite different from <a id="id4" class="indexterm"/>that of most general-purpose programming platforms.</p><p>Stated formally, Node.js has a single-threaded, non-blocking, event-driven execution model. We will define each of these terms in this section.</p><div class="section" title="Non-blocking"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Non-blocking</h3></div></div></div><p>Put simply, Node.js recognizes that many programmes spend most of their time waiting for other<a id="id5" class="indexterm"/> things to happen, for example, slow I/O operations<a id="id6" class="indexterm"/> such as disk access and network requests.</p><p>Node.js addresses this by making these operations non-blocking. This means that program execution can continue while they happen. For example, the filesystem API's <code class="literal">stat</code> function for retrieving statistics about a file may be called as follows:</p><div class="informalexample"><pre class="programlisting">fs.stat('/hello/world', function (error, stats) {
  console.log('File last updated at: ' + stats.mtime);
});</pre></div><p>Two arguments are passed to the <code class="literal">fs.stat</code> function: the name of the file that we are interested in, and <a id="id7" class="indexterm"/>a <span class="strong"><strong>callback function</strong></span>. The <code class="literal">fs.stat</code> call returns immediately, returning control of execution to the current thread but not returning a value. If there are further commands following the <code class="literal">fs.stat</code> call, these will then be executed. Otherwise, the thread is released to perform other work. The callback function is invoked (that is '<span class="emphasis"><em>called back</em></span>') only after the runtime has finished communicating with the filesystem. The result of the filesystem<a id="id8" class="indexterm"/> operation is passed into the callback function.</p><p>This <a id="id9" class="indexterm"/>non-blocking approach is also called <a id="id10" class="indexterm"/>
<span class="strong"><strong>asynchronous</strong></span> programming. Other platforms support this (for example, C#'s <code class="literal">async</code>/<code class="literal">await</code> keywords and .NET's Task Parallel Library). However, it is baked in to Node.js in a way that makes it simple and natural to use. Asynchronous API methods are all called in the same way as <code class="literal">fs.stat</code>. They all take a callback function that gets passed error and result arguments.</p></div><div class="section" title="Event-driven"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Event-driven</h3></div></div></div><p>The <a id="id11" class="indexterm"/>event-driven nature of Node.js describes how <a id="id12" class="indexterm"/>operations are scheduled. In typical procedural environments, a program has an entry point that executes a set of commands until completion, or enters a loop and performs some processing on each iteration.</p><p>Node.js has a built-in <a id="id13" class="indexterm"/>
<span class="strong"><strong>event loop</strong></span>, which isn't exposed to the developer. It is the job of the event loop to decide which piece of code to execute next. Typically, this will be a callback function that is ready to run in response to some other event. For example, a filesystem operation may have completed, a timeout may have expired, or a new network request may have arrived.</p><p>This built-in event loop simplifies asynchronous programming by providing a consistent approach and avoiding the need for applications to manage their own scheduling.</p></div><div class="section" title="Single-threaded"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Single-threaded</h3></div></div></div><p>The <a id="id14" class="indexterm"/>single-threaded nature of Node.js simply means<a id="id15" class="indexterm"/> that there is only one thread of execution in each process. Also, each piece of code is guaranteed to run to completion without being interrupted by other operations. This greatly simplifies development and makes programs easier to reason about. It removes the possibility for a range of concurrency issues. For example, it is not necessary to synchronize/lock access to shared in-process state as it is in Java or .NET. A process can't deadlock itself or create race conditions within its own code. Single-threaded programming is only feasible if the thread never gets blocked waiting for long-running work to complete. Thus, this simplified programming model is made possible by the non-blocking nature of Node.js.</p></div></div><div class="section" title="Introducing the Node.js ecosystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Introducing the Node.js ecosystem</h2></div></div></div><p>The built-in Node.js APIs provide a low-level core for creating applications. Applications typically only use a small number of these APIs directly. They often use third-party library modules<a id="id16" class="indexterm"/> that provide higher-level abstractions for application development.</p><p>Node.js has its<a id="id17" class="indexterm"/> own package manager, <span class="strong"><strong>npm</strong></span>. This is similar to .NET's NuGet or the package management aspects of Java's Maven. Applications specify their dependencies in a simple JSON file.</p><p>The <span class="strong"><strong>npm registry</strong></span><a id="id18" class="indexterm"/> provides a central repository for packages. This registry has grown rapidly and is already much larger (in terms of number of available <a id="id19" class="indexterm"/>packages) than the corresponding repositories for other platforms (see <a class="ulink" href="http://www.modulecounts.com/">http://www.modulecounts.com/</a>). There are hundreds of thousands of packages available, providing a vast array of functionality.</p><p>The <span class="strong"><strong>npm command line tool</strong></span> can be used to download packages and install new ones. Library <a id="id20" class="indexterm"/>dependencies are installed locally to each application. Some packages provide command-line tools, which may be installed globally rather than under a specific project.</p><p>Many frameworks available on npm are split into a small extensible core and a number of composable modules. This approach makes it easy to understand the libraries on which your application depends, avoiding the need to reason about complex heavyweight frameworks.</p><p>The consistency of calling non-blocking (asynchronous) API methods in Node.js carries through to its third-party libraries. This consistency makes it easy to build applications that are asynchronous throughout.</p></div></div></div>
<div class="section" title="Why JavaScript?" id="aid-E9OE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Why JavaScript?</h1></div></div></div><p>JavaScript is <a id="id21" class="indexterm"/>a language that can seem unintuitive compared to <a id="id22" class="indexterm"/>other popular <span class="strong"><strong>object-oriented</strong></span> (<span class="strong"><strong>OO</strong></span>) languages. It also has a number of quirks and flaws that have drawn criticism (and occasional ridicule). It might then seem a surprising choice of language for a new programming platform. This section discusses the factors that make JavaScript a more appealing choice.</p><div class="section" title="A clear canvas"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>A clear canvas</h2></div></div></div><p>The size and <a id="id23" class="indexterm"/>complexity of JavaScript is part of its appeal. The core language itself, which doesn't include APIs such as the DOM, is small and simple. This makes it easy for Node.js to establish its own styles and conventions.</p><p>The new APIs provided by Node.js and the consistent approach to asynchronous programming <a id="id24" class="indexterm"/>wouldn't be possible in a more complex language with a larger pre-existing standard class library.</p></div><div class="section" title="Functional nature"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Functional nature</h2></div></div></div><p>JavaScript was<a id="id25" class="indexterm"/> first built as a programming language for client-side functionality in the browser. This might not make it an obvious choice for general-purpose programming.</p><p>In fact, these two use cases do have something important in common. User interface code is naturally event-driven (for example, binding event handlers to button clicks). Node.js makes this a virtue by applying an event-driven approach to general-purpose programming.</p><p>JavaScript supports functions as first-class objects. This means it's easy to create functions dynamically and pass around references to them. This fits in well with the asynchronous, non-blocking approach of Node.js. In particular, it's easy to expose and use APIs based around callback functions.</p></div><div class="section" title="A bright future"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>A bright future</h2></div></div></div><p>JavaScript has<a id="id26" class="indexterm"/> received a lot of attention in the last several years as it has become more widely used for providing rich functionality on the Web. Browser vendors have put a huge amount of engineering effort into improving the performance of JavaScript. Node.js benefits from this directly via its use of Chrome's V8 engine.</p><p>The JavaScript language itself is undergoing some major changes for the better. The ECMAScript 2015 standard (previously known as ES6) represents the most significant revision of the language in its history. It introduces features that make the language more intuitive and less verbose. It also addresses flaws that JavaScript has been criticized for in the past, removing gotchas and making programs easier to reason about.</p></div></div>
<div class="section" title="When to use Node.js" id="aid-F8901"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>When to use Node.js</h1></div></div></div><p>As discussed<a id="id27" class="indexterm"/> earlier in this chapter, Node.js recognizes that I/O is a bottleneck for many applications. On most programming platforms, threads will waste time blocking on I/O operations. There are approaches developers can take to avoid this, but these all involve adding some complexity to their code. In Node.js, the platform itself provides a completely natural approach.</p><div class="section" title="Writing web applications"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Writing web applications</h2></div></div></div><p>The flagship use case for Node.js is building web applications. These are inherently event-driven as most or all processing takes place in response to HTTP requests. Also, many websites<a id="id28" class="indexterm"/> do little computational heavy-lifting of their <a id="id29" class="indexterm"/>own. They tend to perform a lot of I/O operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Streaming requests from the client</li><li class="listitem">Talking to a database, locally or over the network</li><li class="listitem">Pulling in data from remote APIs over the network</li><li class="listitem">Reading files from disk to send back to the client</li></ul></div><p>These factors make I/O operations a likely bottleneck for web applications. The non-blocking programming model of Node.js allows web applications to make the most of a single thread. As soon as any of these I/O operations starts, the thread is immediately free to pick up and start processing another request. Processing of each request continues via asynchronous callbacks when I/O operations complete. The processing thread is only kicking off and linking together these operations, never waiting for them to complete. This allows Node.js to handle a much higher rate of requests per thread than other platforms. You can also still make use of multiple threads (for example, on multi-core CPUs) by simply running multiple instances of the Node.js process.</p></div><div class="section" title="Identifying other use cases"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Identifying other use cases</h2></div></div></div><p>There are of<a id="id30" class="indexterm"/> course some applications that don't perform much I/O and are more likely to be CPU bound. Node.js would be less suitable for computationally-intensive applications. Programs that do a lot of processing of in-memory data are less concerned about I/O.</p><p>Web applications are not the only I/O-heavy applications though. Other classes of program that could be a good candidate for Node.js include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Tools that manipulate large amounts of data on disk</li><li class="listitem">Supervisor programs coordinating other software or hardware</li><li class="listitem">Non-browser GUI applications that need to respond to user input</li></ul></div><p>Node.js is especially suitable for <span class="emphasis"><em>glue</em></span> applications that pull together functionality from other remote services. The increasing popularity of microservices as an architectural pattern makes this kind of application more common.</p></div><div class="section" title="Why now?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Why now?</h2></div></div></div><p>Node.js has <a id="id31" class="indexterm"/>been around for several years, but now is the perfect time to start using it if you haven't already.</p><p>The release of Node.js v4 towards the end of 2015 consolidated the project's governance model and heralds Node.js coming to maturity. It also allows the project to keep more up to date with the V8 engine. This means that Node.js can benefit more directly from ongoing development on V8. For example, security and performance improvements to V8 will now<a id="id32" class="indexterm"/> make their way into Node.js much sooner.</p><p>As discussed earlier in this chapter, the release of the ECMAScript 2015 standard makes JavaScript a much more appealing language. It pulls in useful features from other popular OO languages and resolves a number of long-standing flaws in JavaScript.</p><p>Meanwhile, the ecosystem of third party libraries and tools around Node.js and JavaScript continues to grow. Node.js is treated as a first-class citizen by major hosting platforms. Companies such as Google and Microsoft are also throwing their weight behind JavaScript and related technologies.</p></div></div>
<div class="section" title="Summary" id="aid-G6PI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, we have understood Node.js and its distinctive execution model, explored the growing ecosystem around Node.js and JavaScript, seen the reasons for JavaScript as a language choice, and described the kinds of application that can benefit from Node.js.</p><p>Now that you know how Node.js works and when to use it, it's time to dive in and get our first Node.js application up and running.</p></div></body></html>