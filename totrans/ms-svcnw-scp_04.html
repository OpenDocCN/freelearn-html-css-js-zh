<html><head></head><body>
        

                            
                    <h1 class="header-title">Advanced Client-Side Scripting</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will explore the advanced side of client-side scripting. Here, we will take a deeper look into scripting on the client and using some of the more advanced techniques that are available.  </p>
<p>The topics we will cover in this chapter are:</p>
<ul>
<li>UI actions</li>
<li>AJAX calls</li>
<li>Advanced client script examples</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">UI actions</h1>
                
            
            
                
<p>UI actions are generally considered to be a server-side script, but they can also run as client-side script, too. We will cover an introduction to UI actions and their basic usage in the server-side basics in the next chapter. Here, though, we will look at the more advanced techniques of running UI actions on the client side.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Client-side UI actions</h1>
                
            
            
                
<p>To change a UI action to run client-side script, we first need to check the client field tick box. This brings up some additional fields, including the checkboxes to select which list versions the UI actions will be compatible with, but the main new field we are interested in is called <kbd>onClick</kbd>. </p>
<p>The <kbd>onClick</kbd> field runs the client code contained inside it when the UI action is selected. Visually, this is only a small field, and not that appropriate for code, so most developers call a function in this field and define the function in the main script field.</p>
<p>Let's look at an example of this usage. For the code in the <kbd>onClick</kbd> field, we only need to call the following function:</p>
<pre>onClick();</pre>
<p>Then, in the script field, we can define the function and contain the code we want to run inside it:</p>
<pre>function onClick() {<br/>// Write script here to run when an UI Action is selected<br/><br/>}</pre>
<p>This method of calling a function that resides in the script field is used by ServiceNow UI actions that are provided with the out-of-the-box platform.</p>
<p>We can see what these UI actions would look like in <em>Figure 4.1</em>:</p>
<div><img class="alignnone size-full wp-image-460 image-border" src="img/d8c8edf6-706f-482a-aefd-058f26360ec6.png" style="width:110.25em;height:93.83em;"/></div>
<p>Figure 4.1: Example UI action containing client-side script</p>
<p class="mce-root">In our example in <em>Figure 4.1</em>, we can see the UI action as a form button, as that is the checkbox that has been selected. The call in the <kbd>Onclick</kbd> field to the <kbd>onClick</kbd> function allows us to write as much code as we need in the script field inside our <kbd>onClick</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling server-side script</h1>
                
            
            
                
<p>Now that we have seen how to use client-side scripts in UI actions, we can look at taking this a step further and using client- and server-side script in the same UI action.</p>
<p>This can be achieved by first calling client-side script in the UI action, which then calls the UI action in the code, and therefore runs the server-side script. This is a slightly strange concept to imagine at first, so let's see how it works.</p>
<p>First, we need to take a look at the line of code that calls the UI action from the client-side code:</p>
<pre>gsftSubmit(null, g_form.getFormElement(), '&lt;ui_action_name&gt;');</pre>
<p>The preceding line of code calls the UI action, but this time, it will run it on the server side. When using this technique, you must ensure that the Action name field of the UI action is the same as the name referenced in the script. The first argument of <kbd>gsftSubmit</kbd> is for a control, but seeing as we don't want to use this, we just pass null. This second argument is to get the form; in our case, we just want to get the current HTML form. The third argument is the action name, so this needs to be our UI action action name.</p>
<p>Next, let's look at the server side of the script:</p>
<pre>if(typeof window == 'undefined')<br/>serverSideCode();<br/><br/>function serverSideCode() {<br/>//Run the server side UI Action code<br/><br/>}</pre>
<p>The first part of this code is an <kbd>if</kbd> statement to check that we are running on the server side and not the client side anymore. This little piece of code also ensures that we do not receive browser errors. If the <kbd>if</kbd> statement evaluates to true, we then call a function to run our server-side code.</p>
<p>We can use the preceding example and call the <kbd>onClick</kbd> function in our script field:</p>
<pre>function onClick() {<br/>// Write script here to run when an UI Action is selected<br/>gsftSubmit(null, g_form.getFormElement(), 'incident_ui_action');<br/><br/>}<br/><br/>if(typeof window == 'undefined')<br/>serverSideCode();<br/><br/>function serverSideCode() {<br/>//Run the server side code<br/><br/>}</pre>
<p>This now gives us a UI action that is running client- and server-side code. We will look at some further examples later on in the chapter.</p>
<p class="mce-root">This type of script can be very useful, often being used on the client side to ensure certain fields are filled in or conditions are met before submission and the server-side code is run.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AJAX calls</h1>
                
            
            
                
<p>The AJAX call is a way of calling server-side script from the client side in an efficient way. It is possible to simply use <kbd>GlideRecord</kbd> on the client side, but this is not considered best practice. It is worth remembering that every time we call the server from the client side, we have to make a round-trip from the client to the server and back again. This takes time and shows as a delay in front of the user. Therefore, we want to reduce the amount of server calls we make, and ensure that any we do are as efficient as possible.</p>
<p>An AJAX call can perform multiple <kbd>GlideRecord</kbd> queries on the server, which saves us having to perform multiple calls to the server. For the AJAX call to work, we need to have some client-side script and some server-side script. This is most commonly a client script and a script include; we'll look at script includes further in a later chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Client-side AJAX</h1>
                
            
            
                
<p>The client side of the AJAX call needs to set up the AJAX call and pass the relevant parameters to the server side. Once a response is received from the server, we can use the returned value or values to decide what changes to make. Let's have a look at how the client side of the AJAX call works:</p>
<div><div><div><div><div><div><pre>var ajaxCall = new GlideAjax('serverAjax');
ajaxCall.addParam('sysparm_name','getUserLocation');
ajaxCall.addParam('sysparm_user_id', g_form.getValue('caller_id'));
ajaxCall.getXML(ajaxResponse);

function ajaxResponse(response) {
   var answer = response.responseXML.documentElement.getAttribute("answer");
   alert(answer);
}</pre></div>
</div>
</div>
</div>
</div>
</div>
<p>The preceding example covers the calling of the AJAX call and the return function, based on the results that are returned. In the first line, we create a new AJAX call and give it the name of our script include. Following on from this, we can add parameters to send to the server.  The first one we need to include every time, as the <kbd>sysparm_name</kbd> parameter is the name of the function we want to call on the server side. </p>
<p>After that, we can send as many parameters as we like to the server side to use in the server-side script. In the example, we are sending the current caller in the <kbd>sysparm_user_id</kbd> parameter.</p>
<p>Finally, we use a <kbd>callback</kbd> function, which has the result returned to it using the <kbd>getXML</kbd> function. This allows the AJAX call to work asynchronously, and the client-side code can continue to run. You can use <kbd>getXMLWait</kbd> as a synchronous call instead, but this will stop the client from running code until the server-side code has completed, so is not best practice.</p>
<p>In the <kbd>callback</kbd> function, we make the answer variable the returned value of our server-side code. In this example, we are just showing an alert to the user of the result of our server-side script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Server-side AJAX </h1>
                
            
            
                
<p>Now that we have seen the client aspect of an AJAX call, let's have a look at the the server-side code that is required to make this work.</p>
<p>As mentioned before, we need to call the script include the same name as our AJAX call and make sure it contains a function with the name in the <kbd>sysparm_name</kbd> parameter. We also need to ensure we make the script include the client callable for the AJAX call to work, and we can do this by checking the client callable tick box on the script include:</p>
<pre>var serverAjax = Class.create();<br/>serverAjax.prototype = Object.extendsObject(AbstractAjaxProcessor, {<br/>  <br/>  getUserLocation: function getUserLocation() {<br/>    var userRecord = new GlideRecord('sys_user');<br/>    userRecord.get(this.getParameter('sysparm_user_id')); <br/>    return userRecord.location.getDisplayValue();<br/>    <br/>  } <br/>  <br/>});</pre>
<p>Here, we are using the <kbd>getUserLocation</kbd> function to return the caller's location back to the client. By using <kbd>GlideRecord</kbd> and the <kbd>get</kbd> method to obtain the user record, we can then return the location from that user record back to the client. We are using the display value to display to the user on the client; otherwise, we simply display the location record <kbd>sys_id</kbd>, which does not mean much to an end user.</p>
<p>By using AJAX calls, we can pass back single values like in our example, or multiple values if needed. An array is a good way to pass multiple values back, but you can use other methods, too, as the response is an XML document.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Script examples</h1>
                
            
            
                
<p class="mce-root">Now that we have seen some more advanced ways of using client-side script, let's look at some examples of how to use these newly learned techniques.</p>
<p>Let's first look at UI actions. We may want to use a UI action to progress states in a change record, but we want to make sure certain fields are filled in before we progress on to other states. We can use client- and server-side code to achieve this. First we use the client-side code to validate the form, and then the server-side code to perform changes to the record.</p>
<p>We can have a look at how this would work:</p>
<pre>function validateForm() {<br/>  g_form.setMandatory('justification', true);<br/>  <br/>  //Call the UI Action to run the server side script<br/>  gsftSubmit(null, g_form.getFormElement(), 'authorize');<br/>  g_form.setMandatory('justification', false);<br/>}<br/><br/>if(typeof window == 'undefined')<br/>  setToAuthorize();<br/><br/>function setToAuthorize() {<br/>  current.state = -3;  //Authorize state<br/>  current.update();<br/>  <br/>}</pre>
<p>In the example, on the client-side script, we are setting the field we want populated to <kbd>Mandatory</kbd> in the script to ensure that it is populated before the form is submitted. This is a good way of notifying the user of the additional field to fill in, as it uses the ServiceNow <kbd>Mandatory</kbd> functionality, rather than popups appearing to the user. You will notice that after the submission, we stop the field being <kbd>Mandatory</kbd>. This is so that if the user wants to simply save the form or change different field values, they are not stopped by the <kbd>justification</kbd> field still being <kbd>Mandatory</kbd>.</p>
<p>For submitting the form, we use <kbd>gsftSubmit</kbd> and the action name of our UI action, which, in this example, is <kbd>authorize</kbd>. This allows the server-side script to run our server function, <kbd>setToAuthorize</kbd>. As the <kbd>state</kbd> field uses numbers as its values, we set the field to <kbd>-3</kbd>, and, as in the example, it is good practice to add comments to let other developers know what the value equates to; and it can be a good reminder for yourself.</p>
<p>We can take a look at what this UI action would look like in <em>Figure 4.2</em>:</p>
<div><img class="alignnone size-full wp-image-461 image-border" src="img/4ca383de-7ef6-4d03-b4ac-d72cb7c0965c.png" style="width:111.67em;height:102.50em;"/></div>
<p>Figure 4.2: Authorizing UI action with client- and server-side script</p>
<p>This method of using client script to validate and server script to perform actions is very useful and works very nicely for UI actions.</p>
<p>Now let's take a look at an AJAX call example. For this example, we are going to look at a catalog item with dependencies on the variables in the catalog item. Sometimes users may have certain access that needs to be revoked, perhaps when they leave the company. When we select the user, we want to ensure that they have some kind of access; otherwise, there will be nothing for them to pick in the remaining fields, resulting in a poor user experience.</p>
<p>Let us take a look at the client-side script we would put into a catalog client script:</p>
<pre>function onChange(control, oldValue, newValue, isLoading) {<br/>  if (isLoading) {<br/>    return;<br/>  }<br/>  <br/>  //Clear the Access field when the user changes to ensure a valid selection is made.<br/>  g_form.setValue('variables.access', ''); <br/>  <br/>  if (newValue == '') {<br/>    return;<br/>  }<br/>  <br/>  //Ensure a selected user has some active access else clear field<br/>  var ga = new GlideAjax('accessCheck');<br/>  ga.addParam('sysparm_name','userHasAccess');<br/>  ga.addParam('sysparm_user', newValue);<br/>  ga.getXML(AJAXParse);<br/><br/>}<br/>  <br/>function AJAXParse(response) {<br/>  var answer = response.responseXML.documentElement.getAttribute("answer"); <br/>  if (answer == 'false') {<br/>    g_form.addErrorMessage('User has no access to remove.');<br/>    g_form.setValue('variables.user', ''); <br/>  }<br/>} </pre>
<p>This would be put inside a catalog client script as an <kbd>onChange</kbd> script, and therefore dictates our function name. When we use catalog items and variables, we have to prefix our variable names with <kbd>variables</kbd> and then the variable name to use <kbd>g_form</kbd> methods. In the example, we are using a <kbd>user</kbd> and <kbd>access</kbd> variable, and as you can see, we clear the <kbd>access</kbd> variable when the user changes so that we don't end up with a mismatch of data on the screen where a user picks some access and then back fills the user.</p>
<p>Before we initiate the AJAX call, we check that the new value of the user field is not blank. If it is, there is no use making a round-trip to the server, so we use <kbd>return</kbd>, essentially exiting the script. If the value is not blank, then we use an AJAX call, calling our script include and sending a user parameter containing the new value in the user field.</p>
<p>When a response comes back from the server, if the result is that the user has no access, then we can assume there will be no access to select and remove for the user. Therefore there would be no selections to pick in the access variable. Rather than give the user nothing to select, we can clear the user field and let the user know the user they selected has no access to remove.</p>
<p>Now that we have taken a look at the client side of this example, let's have a look at the server-side code. Remember that the script include name and function need to match up with the client code making the AJAX call:</p>
<pre>var accessCheck = Class.create();<br/>accessCheck.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {<br/>  <br/>  <br/>  /**<br/>  * Ajax Call - Returns whether a user has an active access record <br/>  */ <br/>  userHasAccess: function userHasAccess() {<br/>    <br/>    var uAccess = new GlideRecord('u_access');<br/>    uAccess.addQuery('u_user', this.getParameter('sysparm_user'));    <br/>    uAccess.query(); <br/>    if (uAccess.next()) {<br/>      return true;<br/>    } <br/>    return false;<br/>  }<br/>  <br/>});</pre>
<p>In the server script, we are using a <kbd>GlideRecord</kbd> to check a custom access table, hence the <kbd>u_ prefix</kbd> using the <kbd>sysparm_user</kbd> parameter we passed to filter the result down to only records containing that user. If we find a record of access, we return <kbd>true</kbd> back to the client and <kbd>false</kbd> if no record can be found.</p>
<p>By returning <kbd>false</kbd> back to the client-side script, we clear the user variable on the form and show an error message so that the logged-in user knows that the user they selected has no access. If we assume a suitable reference qualifier has been set up, this would stop the logged-in user selecting the access variable after selecting a user and finding no records to select.</p>
<p>Since AJAX calls are so widely used, let's take a look at another example. In this example, we will notify a user on the incident form whether the change they have selected related to the incident that still has open tasks.</p>
<p>This time, we'll use a client script to make the AJAX call. We need it to run when the change request field changes on the incident form, so we'll use an <kbd>onChange</kbd> script. Let's have a look at how this client script code will look:</p>
<pre>function onChange(control, oldValue, newValue, isLoading, isTemplate) {<br/>  if (newValue === '') {<br/>    return;<br/>  }<br/>  <br/>  //Check whether change request has open tasks<br/>  var ga = new GlideAjax('changeScripts');<br/>  ga.addParam('sysparm_name','changeHasOpenTasks');<br/>  ga.addParam('sysparm_change', newValue);<br/>  ga.getXML(AJAXCall); <br/>  <br/>}<br/><br/>function AJAXCall(response) {<br/>  var answer = response.responseXML.documentElement.getAttribute("answer");<br/>  <br/>  if (answer == 'true') {<br/>    g_form.showFieldMsg('rfc', 'Change has open tasks', 'error');<br/>  } else {<br/>    g_form.showFieldMsg('rfc', 'Change has no open tasks', 'info');<br/>  }<br/>}</pre>
<p>In this example, we see an AJAX call again, this time sending the change request selected as a parameter. We do not need to run the AJAX call when the <kbd>change</kbd> field value or <kbd>newValue</kbd> is empty, but this time, we do want our script to run on load, so we have removed the <kbd>isLoading</kbd> check from the beginning of the script. </p>
<p>When we return from the AJAX call, we are using <kbd>g_form</kbd> to show a field message which appears just below the field to show whether the change request selected has open tasks or not. </p>
<p>Now we'll take a look at the server-side script that makes this AJAX call work. A script include will be used to hold the code:</p>
<pre>var changeScripts = Class.create();<br/>changeScripts.prototype = Object.extendsObject(AbstractAjaxProcessor, {<br/><br/>  /**<br/>  * Ajax Call - Returns whether a change has open tasks <br/>  */ <br/>  changeHasOpenTasks: function changeHasOpenTasks() {<br/>    <br/>    var cTask = new GlideRecord('change_task');<br/>    cTask.addQuery('change_request', this.getParameter('sysparm_change')); <br/>    cTask.addQuery('state', 'NOT IN', '3,4'); //Closed and Cancelled<br/>    cTask.query(); <br/>    if (cTask.next()) {<br/>      return true;<br/>    } <br/>    return false;<br/>  }<br/>});</pre>
<p>In the server-side script for this example, we are using a <kbd>GlideRecord</kbd> to find all the change tasks that are still open for the change request we passed in as a parameter. In the preceding script, we are using an <kbd>addQuery</kbd> line for the <kbd>GlideRecord</kbd> where the state is not <kbd>3</kbd> or <kbd>4</kbd>, which equates to closed and canceled. This allows us to treat any other state as open, even if further active states have been added from the out-of-the-box setup.</p>
<p>This means that if any record is found, we can return <kbd>true</kbd> immediately, as we only need to know that at least one task is still open. There is no point in running through other change tasks if we find one that is still open, and this keeps the processing time down and the code more efficient.</p>
<p>Once the return value is sent back, the corresponding field message will display to the user using the client-side code. This type of AJAX call can be very useful for giving users extra detail on forms about the data they are entering.</p>
<p>The AJAX call is widely used, and I would certainly recommend becoming acquainted with it as early as possible for scripting in ServiceNow, as many requirements will need an AJAX call so they can be fulfilled. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at the advanced side of client scripting. We saw how we can use UI actions to run client-side code and run client- and then server-side code. We also took a look at the all-important AJAX call for an efficient way to call server-side code from the client. Lastly, we had a look at some examples of how to use these advanced client-side techniques.</p>
<p>We will move on to the server side in the next chapter and see how to get started writing server-side script. This includes business rules, UI actions, and access controls. We'll also look at when these scripts should be written, how to test them, and some practical examples to help you get started.</p>


            

            
        
    </body></html>