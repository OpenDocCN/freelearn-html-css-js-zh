- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a critical phase within the **software development life cycle** (**SDLC**)
    that’s integral to ensuring the software meets the required standards and functions
    as expected. Testing detects bugs introduced during development. It verifies that
    the software performs its intended functions correctly and efficiently and ensures
    the software meets user requirements and specifications. By applying tests, we
    can reduce the risks associated with software failure or malfunction.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll talk about different strategies for software testing
    within microservices. By the end, you’ll know how to write unit and integration
    tests for your microservices both in isolation and integrated with other microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing in a microservice architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing unit tests for the account microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests for the transaction microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing mocks, stubs, and spies in unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement our tests, we’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An IDE of your choice (we prefer Visual Studio Code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s GitHub repository, which can be downloaded from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript).
    Open the `Ch12` folder so that you can follow along with ease.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding testing in a microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservice architecture divides an application into smaller, loosely coupled
    services, each responsible for a specific business function. This approach offers
    numerous benefits, such as improved scalability and flexibility. However, it also
    introduces complexity, particularly in terms of testing. Comprehensive testing
    is crucial to ensure that these independent services function correctly and cohesively.
    Let’s try to understand the importance of testing in a microservice architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first reason for using tests in a microservice architecture is to ensure
    **functionality**. Each service performs a distinct function in a microservice
    architecture and is developed independently. Testing ensures that each service
    performs its intended function correctly. We mostly use unit and functional testing
    to achieve this goal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit testing** focuses on individual components within a service, verifying
    that each function works as expected. This helps us catch bugs early in the development
    process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, **functional testing** ensures that the service as a whole
    meets its functional requirements. This involves testing the service’s endpoints
    and ensuring that they return the expected results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second reason for using tests in microservices is to maintain **interoperability**.
    Microservices must communicate with each other to function as a cohesive application.
    Ensuring seamless interoperability between services is critical. To achieve this,
    we mostly focus on integration and contract testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing** focuses on interactions between services, verifying
    that data exchange and communication protocols are implemented correctly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract testing** ensures that services adhere to defined APIs or contracts.
    This is particularly important when different teams develop services independently
    as it helps maintain consistent communication standards.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third reason is **performance** assurance. Performance testing ensures
    that services operate efficiently under various load conditions, which is vital
    for maintaining a good user experience. We can achieve this goal using load testing
    and stress testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load testing** evaluates how services handle expected load levels. This helps
    identify performance bottlenecks and ensures services can handle real-world usage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress testing** examines how services perform under extreme conditions,
    such as high traffic or resource shortages. This helps in understanding the service’s
    breaking point and resilience.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing is also important for **security** validation. Security is a critical
    concern in microservice architecture as each service may handle sensitive data
    and must be protected against vulnerabilities. We can use security testing and
    penetration testing to achieve our goal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security testing** identifies vulnerabilities and ensures that services can
    protect sensitive data. This includes testing for common security issues such
    as SQL injection, **cross-site scripting** (**XSS**), and authentication flaws.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Penetration testing** simulates attacks to identify potential security gaps.
    This helps in proactively securing services against real-world threats.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microservices need to be reliable and stable, especially during updates or
    changes. Testing ensures that services remain **dependable** over time. We have
    regression and chaos testing to make sure we have reliable and stable microservices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing** ensures that new changes or updates don’t introduce
    new bugs or break existing functionality. This is crucial for maintaining service
    reliability after each deployment.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaos engineering** involves intentionally introducing failures into the
    system to test its resilience. This helps us understand how services respond to
    unexpected issues and improves overall stability.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Having understood testing as a whole, let’s move on to unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is a software testing technique that matters most when you
    want to ensure that individual units or components of the software are tested
    in isolation. The goal of unit testing is to validate that each unit of the software
    performs as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s an important aspect of software development, especially in microservices
    architectures. Node.js, with its asynchronous and event-driven nature, poses unique
    challenges and opportunities for unit testing. In this context, unit testing involves
    testing individual functions, methods, or classes within your Node.js application.
    Let’s cover the importance of unit testing for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It ensures code quality**: Unit testing helps identify bugs early in the
    development cycle, ensuring that individual units of code function as intended.
    This is particularly important in microservices, where services are designed to
    be small, independent, and modular.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It facilitates refactoring**: With a comprehensive suite of unit tests, developers
    can confidently refactor code, knowing that any changes will be verified by the
    tests. This is crucial for maintaining and improving the code base over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It supports continuous integration/continuous deployment (CI/CD)**: Unit
    tests are an integral part of CI/CD pipelines. They provide immediate feedback
    on code changes, enabling quick iterations and stable deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better documentation**: Well-written unit tests serve as documentation for
    the code. They demonstrate how individual units are expected to behave, making
    it easier for new developers to understand the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at some of the benefits of performing unit testing in Node.js microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved reliability**: Unit tests ensure that each microservice behaves
    as expected, reducing the likelihood of runtime errors and improving overall system
    reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster development cycles**: Automated unit tests speed up the development
    process by allowing developers to quickly identify and fix issues. This is particularly
    beneficial in microservices, where services are developed and deployed independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced debugging time**: With unit tests in place, bugs can be detected
    and isolated quickly, reducing the time spent on debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased confidence in code changes**: Unit tests provide a safety net for
    developers, giving them the confidence to make changes and add new features without
    breaking existing functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing in Node.js microservices enhances reliability, accelerates development
    by catching issues early, reduces debugging time, and boosts developer confidence
    in making code changes without breaking functionality. Now, let’s focus on unit
    testing packages we need to use to write unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing unit testing packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing a line of code, we need to prepare our environment. To be precise,
    we need to install the required packages to write unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Chai, Mocha, and Sinon are popular libraries that are used for testing in Node.js
    applications, including microservices. Each of these libraries has a specific
    role and they often work together to provide a comprehensive testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s talk about **Mocha**. Mocha is a feature-rich JavaScript test framework
    that runs on Node.js, making asynchronous testing simple and fun. It provides
    a testing environment where you can define your tests and run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`describe` and `it` blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allows asynchronous testing**: It supports both synchronous and asynchronous
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before`, `after`, `beforeEach`, and `afterEach`) for setting up and tearing
    down conditions for tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: It can be extended with various plugins and reporters to customize
    the testing setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install it using the `npm install --save-dev` `mocha` command.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Chai
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Chai** is a popular assertion library that’s used with Node.js, often in
    combination with testing frameworks such as Mocha. It provides a variety of interfaces
    and styles for writing tests, making it flexible and easy to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports different assertion styles, two of which we’ll look at here:'
  prefs: []
  type: TYPE_NORMAL
- en: The first and maybe the most used style is known as `expect` and `should` interfaces.
    They’re used for writing expressive and readable assertions. This style allows
    for natural language assertions, making tests easier to understand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second style is known as `assert` interface is used for writing classical
    unit test assertions. This style is more traditional and straightforward, which
    makes it suitable for developers familiar with xUnit frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can install it using the `npm install --save-dev` `chai` command.
  prefs: []
  type: TYPE_NORMAL
- en: While Chai has many features, let’s understand three of the most relevant ones.
    The first feature we’ll look at is its `chai-as-promised` for promise assertions
    and `chai-http` for HTTP assertions. The second key feature is **extensibility**.
    Chai can be extended to create custom assertions using its plugin API. This allows
    developers to add domain-specific language to their tests On the other hand, Chai
    has a cool feature known as readable and expressive syntax. Chai’s BDD-style assertions
    are designed to be readable and expressive, making tests easier to write and understand.
    Finally, Chai also **integrates** seamlessly with Mocha, providing a powerful
    combination for writing and running tests.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Sinon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sinon** is another powerful library for testing in JavaScript that’s particularly
    useful for creating spies, stubs, and mocks to control and monitor the behavior
    of functions. It’s especially valuable in unit testing to isolate the code under
    test from its dependencies, ensuring that the tests focus on the specific functionality
    being tested.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we learn how to implement unit tests, let’s take a look at some of the
    key features of Sinon:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spies**: Track and monitor the behavior of functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubs**: Replace functions with predefined behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocks**: Create fake objects with expectations for their behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fakes**: Combine the behavior of spies and stubs for simpler use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timers**: Control and simulate the passage of time in tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` and the Fetch API to test AJAX requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can install it using the `npm install --save-dev sinon` command. Sinon can
    mock functions, HTTP requests, and more, making it ideal for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Other packages in Node.js
  prefs: []
  type: TYPE_NORMAL
- en: Along with `Chai`, we have other popular assertion libraries such as Jest. **Jest**
    has its own assertion library, which is fully integrated and optimized for use
    with Jest.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing unit tests, we also need mocking and stubbing libraries. In
    unit testing, mocks and stubs are used to isolate the unit of code being tested
    by simulating the behavior of dependencies. This allows you to test the functionality
    of a specific unit without having to rely on external components, such as databases,
    network services, or other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Along with `Sinon`, we use the `Testdouble` is a minimal, standalone test double
    library for JavaScript. You can use the `npm install --save-dev testdouble` command
    to install it. Testdouble provides tools for creating, using, and verifying test
    doubles in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What should we test in unit testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before implementing unit tests in our project, we need to answer one simple
    question: what should we unit test? Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business logic**: This is the most critical part to test. Business logic
    includes the rules and operations that dictate how data is transformed, manipulated,
    and controlled. It ensures the application behaves correctly under various conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge cases**: Test the boundaries and limits of your application. This includes
    checking how the application handles unexpected, extreme, or invalid inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Ensure that the application responds correctly to error
    conditions, such as invalid input or failed operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State transitions**: If the application involves state changes (such as a
    status update), make sure these transitions occur as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return values**: Verify that functions return the correct values for given
    inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies and interactions**: While unit tests should ideally test a unit
    in isolation, it’s important to mock dependencies and verify interactions between
    components to ensure they collaborate correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know what we should test, it’s time to implement unit testing so
    that we can see it in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing unit tests for the account microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A copy of the source code for [*Chapter 7*](B09148_07.xhtml#_idTextAnchor121)
    can be found in the `Ch12` folder of this book’s GitHub repository. This chapter
    will demonstrate how to test different microservices. We’ll start with the account
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder at the same level as the `src` folder and name it `tests`.
    Our main focus here is to test the `src/services/account.js` file. It contains
    the main logic and the required business rules that are implemented in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a file called `accountservice.test.mjs` under the `tests` folder.
    Why the `.mjs` extension? This extension is used in Node.js projects to indicate
    that a JavaScript file should be treated as an `import` and `export` syntax. By
    using `.mjs`, Node.js can unambiguously determine that the file should be treated
    as an ES module, even if it exists alongside `CommonJS` files with a `.js` extension.
    This avoids confusion and potential conflicts, especially in projects that use
    both module systems. Using `.mjs` makes it explicit to developers and tools that
    the file is an ES module, helping them avoid making mistakes and misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, using the `.mjs` extension in Node.js projects helps separate ES
    modules from CommonJS modules. This ensures Node.js handles them correctly and
    keeps your code compatible with modern JavaScript standards. By using `.mjs`,
    you can simplify your module setup and make your code more future proof as JavaScript
    continues to evolve.
  prefs: []
  type: TYPE_NORMAL
- en: We plan to implement unit tests for the `account.js` file, which can be found
    in the `src /` `services` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have multiple functions inside this service. First, let’s consider some
    unit tests for the `getAccountById` function. Here’s the original function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From an implementation perspective, we haven’t implemented valid exception handling.
    We *throw* the same exception from the database layer to the API layer directly.
    It’s generally better to handle exceptions either at the lowest level (database
    layer) or at the highest level (API layer). *Lower layers* should primarily focus
    on detecting and throwing exceptions when unexpected conditions arise. This maintains
    a clean separation of concerns and prevents lower layers from exposing implementation
    details. Some exceptions, such as database connection failures or file read/write
    errors, might require immediate handling at the lowest level to prevent data corruption
    or resource leaks. For instance, if a file write operation fails due to a full
    disk, handling the exception at this level can prevent further issues. If the
    exception is expected and can be handled within the lower layer without exposing
    internal details, it’s reasonable to do so. A centralized error-handling mechanism
    at the highest layer can provide consistent error management across the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install the required packages. To do so, run the `npm install
    --save-dev mocha chai sinon` command. After installation, we’ll have the following
    `devDependencies` section in the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to import the necessary packages and functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What should we test in our account service? The first function that needs to
    be tested is `getAccountById`. We should check whether the function will return
    the exact account information if the given account exists in our database. Here’s
    our first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Well, this code may seem a little bit complicated at first glance, but the detailed
    explanation provided in this section will help you understand it with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In Mocha, the `describe` and `it` blocks are fundamental structures that are
    used to write and organize tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe` block is used to group related test cases. It helps organize
    tests into logical sections, making them easier to read and understand. It’s typically
    used to group tests related to a particular feature or function. The `describe`
    block has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`description`: A string that describes the group of tests. This description
    will appear in the test’s output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function`: A callback function that contains the test cases (using it blocks)
    and any setup/teardown logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `it` block is used to define individual test cases. Each `it` block represents
    a single test that performs a specific assertion or set of assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest `describe` blocks to create a hierarchical structure for your
    tests, making it easier to organize and understand complex test suites. Here’s
    an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In practice, you typically use `describe` to group tests by the feature or unit
    of code being tested and `it` to define the specific behaviors you expect from
    that code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to our example. Our code snippet describes a unit test for a
    service function called `getAccountById`. The test uses a mocking library called
    `Sinon` to simulate the behavior of a function named `findById` within the account
    module.
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, this test checks whether the `getAccountById` service function
    correctly retrieves an account by its ID using the `findById` function. It ensures
    that the service returns the expected account data when the ID is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a line-by-line explanation of our first unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 1* declares a test suite named `getAccountById service`. The function
    that’s passed to `describe` will contain the test cases related to `getAccountById
    service`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 2* declares the `findByIdStub` variable, which will be used later to
    hold the stub created by Sinon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 3* sets up a function to run before each test case within this `describe`
    block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `beforeEach` function in *Line 4*, `Sinon` creates a stub for the
    `findById` method of the `account` model. This stub will replace the original
    `findById` method, allowing us to control its behavior during tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 7* sets up a function to run after each test case within this `describe`
    block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `afterEach` function in *Line 8*, the `restore` method is called
    on `findByIdStub`. This restores the original `findById` method of the account
    model, ensuring that stubs don’t affect other tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 11* declares a test case with a description of `should return the account
    if found by id`. The function that’s passed to it contains the test logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 12* declares a constant, `expectedAccountId`, and assigns it a value
    of `''12345''`. This is the ID that will be used to search for the account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 13* declares a constant, `expectedAccount`, and assigns it a mock account
    object. This is the account that the stubbed `findById` method will return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 14* sets up `findByIdStub` to resolve (return a promise that resolves
    to) `expectedAccount` when it’s called with `expectedAccountId`. This simulates
    the behavior of finding an account in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 15* calls the `getAccountById` service function with `expectedAccountId`
    and awaits its result. The result is assigned to the account variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 16* asserts that the account that’s returned by the service function
    is deeply equal to `expectedAccount`. Deep equality checks that all properties
    of the objects are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 17* asserts that `findByIdStub` was called exactly once with `expectedAccountId`.
    This verifies that the service function attempted to find the account by the correct
    ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the next few unit tests inside the same `describe` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this unit test suite, two test cases have been defined for the `getAccountById`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test case, named `should return null if account not found`, sets up
    a scenario where the account with an ID of `'54321'` doesn’t exist. Here, `findByIdStub`
    is configured to return `null` when called with this ID. The test then calls `getAccountById`
    with `'54321'` and expects the result to be `null`. It also verifies that `findByIdStub`
    was called exactly once with `'54321'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test case, named `should rethrow errors from findById`, tests the
    behavior when the `findById` method throws an error. Here, `findByIdStub` is set
    up to throw `Database error` when called with ID `'98765'`. The test calls `getAccountById`
    and expects the call to throw the same error. This is verified using a try-catch
    block, where it’s checked that the caught error is equal to the expected error.
    Additionally, it verifies that `findByIdStub` was called exactly once with `'98765'`.
    These tests ensure that the `getAccountById` service correctly handles cases where
    the account isn’t found and when errors occur during database access. Please keep
    in mind that rethrowing errors should include meaningful handling, such as logging
    or adding additional context to the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tests except `updateAccountById` follow approximately the same testing
    style. In a given service, the most complex implementation exists inside the `updateAccountById`
    function. Please refer to [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074) to learn
    more about the `Account` microservice and its business cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should cover every business rule that’s implemented in our original functionality.
    Here’s the first condition that we need to cover when updating the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function ensures that an account update is meaningful by requiring at least
    one valid piece of information (name, number, type, or status) to be provided.
    If none are given, it returns an error, to enforce the business rule of avoiding
    invalid updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the unit test fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet describes a unit test for a service function called
    `updateAccountById`. This function is responsible for updating an account based
    on a given ID and update data. The test employs `Sinon` to substitute the behavior
    of the `findById` and `save` methods within the account module.
  prefs: []
  type: TYPE_NORMAL
- en: Before each test case, `Sinon` stubs are established for both the `findById`
    and `save` methods to enable controlled test scenarios. After each test, these
    stubs are restored to their original state.
  prefs: []
  type: TYPE_NORMAL
- en: The specific test case focuses on validating the error handling process when
    no update data is provided. It constructs an account ID and an empty update object.
    Subsequently, it invokes the `updateAccountById` service with these parameters
    and captures the result that’s returned.
  prefs: []
  type: TYPE_NORMAL
- en: The test then asserts that the returned result is an error object containing
    a specific error message and code, indicating the absence of valid update data.
    To ensure the correct behavior, it further verifies that neither the `findById`
    nor the `save` method was called as no account retrieval or update was necessary
    in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, this unit test guarantees that the `updateAccountById` service
    correctly handles cases where no update data is supplied, returning an appropriate
    error response without performing unnecessary operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next piece of logic in the `updateAccountById` function is defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet indicates that if the status isn’t part of the allowed
    statuses defined by the business rules, it returns an error message, preventing
    the update with an invalid or unsupported status. This ensures that only acceptable
    status changes are made, maintaining business consistency and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following unit test validates error handling for invalid status updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding unit test verifies error handling for invalid status updates in
    the `updateAccountById` service. It simulates an update with an invalid status.
    The test expects an error object with specific details when the service encounters
    this invalid input. To isolate the test, stubs prevent database interactions.
    By asserting the correct error, the test ensures the service behaves as expected
    when faced with incorrect data.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach we implemented for the preceding unit tests, we can
    test all the possible cases for our services. For more complete implementation,
    check out this book’s GitHub repository and the respective folder for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run unit tests, navigate to the root folder from the command line (for us,
    this is the `Ch12`/`accountservice` folder) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Results of the test run](img/B09148_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Results of the test run'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve demonstrated how to write tests for the Express.js project.
    The same unit testing logic is the same for Nest.js applications. You can easily
    apply the aforementioned ideas to your Nest.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for the transaction microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it’s time to demonstrate how easily you can write unit tests for your Nest.js
    applications. In this book’s GitHub repository, in the `Ch12` folder, we have
    the same transaction service we implemented in [*Chapter 7*](B09148_07.xhtml#_idTextAnchor121).
  prefs: []
  type: TYPE_NORMAL
- en: Open the `transaction.service.spec.ts` file, which can be found in the `src/test`
    folder. It contains all the essential tests to help us understand how to write
    unit tests. If you want to follow along and implement everything from scratch,
    just create a folder named `test` inside the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to install the required packages to implement unit
    testing for our project. To write unit tests for `transaction.service.js`, we
    need to install the `@nestjs/``testing` package. Here’s how you can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s been installed, create a file called `transaction.service.spec.ts`.
    First, we need to import the required references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code imports the necessary services for testing: `TransactionService`
    handles transaction logic, `PrismaService` interacts with the database, `HttpService`
    handles external HTTP requests, `KafkaService` performs message handling, and
    `CreateTransactionDto` defines the structure of transaction data. The `Test` and
    `TestingModule` imports are from the Nest.js testing module and are used to create
    a testing environment for `TransactionService`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what a simple unit test looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know about the `describe` block and its role in unit testing. The
    preceding code snippet establishes a testing environment for `TransactionService`.
    It begins by importing the necessary modules and services: `TransactionService`,
    `PrismaService` for database interactions, `HttpService` for external requests,
    `KafkaService` for message handling, and `CreateTransactionDto` for data transfer.'
  prefs: []
  type: TYPE_NORMAL
- en: A `describe` block encapsulates the tests for `TransactionService`. Inside,
    variables are declared to hold instances of the services. The `beforeEach` block
    sets up the testing module using `Test.createTestingModule`. It provides mock
    implementations for `PrismaService`, `HttpService`, and `KafkaService` to isolate
    `TransactionService` during testing. The `PrismaService` mock includes methods
    such as `create`, `findMany`, `findUnique`, and `update` to simulate database
    operations. If you open `transaction.service.ts`, you’ll realize that we use these
    methods to implement the functionalities of the transaction service. Similarly,
    the `HttpService` and `KafkaService` mocks mimic their respective functionalities
    using Jest’s `jest.fn()`. This setup allows for controlled testing of `TransactionService`
    without the need to rely on actual external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `jest.fn()` is a function provided by Jest, a popular JavaScript testing
    framework, to create mock functions. A mock function is essentially a dummy function
    that can be used to replace real functions during testing. There are a lot of
    benefits and values to using such types of functionalities in unit testing. Here
    are the benefits of using `jest.fn()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: It allows us to isolate the component or function you’re testing
    by replacing dependencies with mock functions. This helps us focus on the specific
    behavior of the code under test without being affected by external factors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verifiability**: We can assert how many times the mock function was called,
    with what arguments, and what it returned. This helps in verifying the correct
    behavior of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom implementation**: We can define the behavior of the mock function
    using mock implementation to control its return value or actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using `jest.fn()`, we can effectively test different scenarios and edge
    cases without relying on the actual implementation of the mocked function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `module.get` method is used to access the providers that were defined in
    the `TestingModule` setup. It takes the service class as an argument and returns
    an instance of that service. By calling `module.get` for each service (`TransactionService`,
    `PrismaService`, `HttpService`, and `KafkaService`), the code obtains references
    to these services, which can then be used for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: These service instances are typically used within the test cases to interact
    with the system under test and verify its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start with a simple test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet defines a basic test case to ensure the service instance is
    injected correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The `it('should be defined', () => { ... })` block creates a test case with
    a description of `should be defined` Inside this block, the `expect(service).toBeDefined();`
    assertion checks whether the `service` variable has a defined value. This is a
    fundamental test to verify that the dependency injection process has successfully
    provided an instance of `TransactionService`. If the service is `null` or `undefined`,
    the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, this test case acts as a sanity check to ensure the testing environment
    has been set up correctly before we proceed with more complex test scenarios.
    Now, let’s switch to testing the transaction creation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This test case aims to verify the `create` method of `TransactionService` under
    specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: It starts by defining a test scenario where the account status is either `new`
    or `active`. A `CreateTransactionDto` object is created with the necessary data.
    To simulate external dependencies, `httpService` and `prismaService` are mocked
    using `jest.spyOn`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `jest.spyOn` is a function in Jest that’s used to create a spy on an existing
    function. Unlike `jest.fn()`, which creates a new mock function, `jest.spyOn`
    wraps an existing function to track calls and potentially modify its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `jest.spyOn` to observe how a particular function is used within
    your code without altering its original implementation. It also records information
    about function calls, such as arguments, return values, and the number of times
    it was called. This is useful for verifying the interaction between different
    parts of our code.
  prefs: []
  type: TYPE_NORMAL
- en: While optional, we can change the behavior of the spied function. This is helpful
    when we want to control the output of the function for specific test cases. After
    testing, we can restore the original function’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `httpService.axiosRef.get` method is mocked to return a successful account
    response with an `active` status. The `prismaService.transaction.create` method
    is also mocked to return a created transaction with the `CREATE` status.
  prefs: []
  type: TYPE_NORMAL
- en: The `service.create` method is then called with the prepared `createTransactionDto`
    object. The test asserts that the returned result matches the expected transaction
    data, indicating successful creation. Additionally, it verifies that `httpService.axiosRef.get`
    was called with the correct URL to fetch account information, and `prismaService.transaction.create`
    was called with the correct data to persist the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this test case ensures that the `create` method interacts with
    `httpService` correctly to fetch account details, determines the transaction status
    based on account status, and persists the transaction to the database through
    `prismaService` with the expected data. By mocking dependencies, the test isolates
    the `create` method’s logic and verifies its behavior without relying on external
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: It should now be easy for you to understand the rest of the unit tests that
    have been implemented inside our `transaction.service.spec.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing unit tests, you may hear a lot about mocks, stubs, and spies.
    As our last topic regarding unit tests, let’s explore and understand their responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: To run all your tests, you simply need to run the `npm test` command (*Figure
    12**.2*).
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be cases where tests fail to run properly. To resolve this, please
    refer to this book’s GitHub repository and ensure that the `package-lock.json`
    file matches the package versions specified in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Running transaction tests](img/B09148_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Running transaction tests'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, we can use various building blocks for testing, such
    as mocks, stubs, and spies. Let’s try to understand and differentiate them.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing mocks, stubs, and spies in unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll spend this section comparing mocks, stubs, and spies in unit tests because
    they’re essential tools for isolating and simulating components’ behaviors during
    testing. Understanding their differences will help us choose the right approach
    to test various interactions and functionalities in the system effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Mocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **mock** is a simulated object that replaces a real dependency in a unit test.
    It’s designed to mimic the behavior of the original object but with complete control
    over its actions. Why? This isolation allows for focused testing of the code under
    scrutiny without the need to rely on external factors.
  prefs: []
  type: TYPE_NORMAL
- en: We can define exact return values, exceptions, or sequences of actions for mock
    objects. This enables us to test various scenarios and edge cases. Mocks can record
    interactions, allowing us to verify that methods were called with correct arguments,
    in the right order, and with the expected frequency. By replacing real dependencies
    with mocks, we can create a controlled environment, preventing unexpected side
    effects and ensuring test reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the benefits of using mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved test focus**: Mocks help you concentrate on the logic of the code
    being tested, without being distracted by the intricacies of external components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster test execution**: Since mocks don’t involve real interactions (such
    as database calls or network requests), tests run significantly faster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased test coverage**: Mocks allow you to test different scenarios and
    edge cases that might be difficult or impossible to reproduce in a real environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced code reliability**: By thoroughly testing code in isolation, you
    can identify and fix potential issues early in the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll look at stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the other hand, a **stub** is a simplified implementation of a component
    that’s used to replace a real component in a test. It provides canned answers
    to calls that are made during the test, focusing on the specific behavior needed
    for the test case.
  prefs: []
  type: TYPE_NORMAL
- en: A stub only contains the essential logic required for the test and returns predetermined
    values or exceptions. It typically doesn’t verify interactions or expectations.
    That is great, but when can you use them?
  prefs: []
  type: TYPE_NORMAL
- en: When you need to isolate the unit under test by providing controlled responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the behavior of the dependency isn’t critical to the test case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to speed up test execution by avoiding complex logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While both stubs and mocks are used to replace real components in tests, there’s
    a key difference. Stubs focus on providing predefined responses and don’t verify
    interactions, whereas mocks allow for more complex behavior, including expectations
    and verifying interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, stubs can be sufficient for basic testing, but as test requirements
    become more complex, mocks offer greater flexibility and control.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **spy** is a wrapper around an existing object or function that records information
    about how it’s used. Unlike stubs and mocks, which replace the original object,
    spies observe the behavior of the real object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key characteristics of spies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrap real object**: Spies can be created around existing objects or functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Record interactions**: They track method calls, arguments, and return values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify behavior**: Spies are used to ensure that methods are called correctly
    and with the expected parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use spies in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to verify that a specific method is called with certain arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to check the sequence of method calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to observe the side effects of a function without controlling
    its behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While both spies and mocks can verify interactions, there’s a key difference
    – spies observe the behavior of the real object, whereas mocks replace the real
    object with a simulated one.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, stubs provide canned responses without verifying interactions.
    Mocks replace objects and allow for complex behavior and verification. On the
    other hand, spies observe the behavior of real objects without modifying them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and implementing integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Integration tests** are an important component of a robust testing strategy
    and focus on the interactions between different parts of your application. Unlike
    unit tests, which isolate individual components, integration tests evaluate how
    these components work together as a cohesive system.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Express.js, integration tests ensure that routes, controllers,
    models, and databases interact seamlessly. They verify that data flows correctly
    between these components and that the application produces the expected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Why are integration tests essential? They help prevent integration issues, which
    can often be complex and time-consuming to debug. By testing the interactions
    between components, you can catch potential problems early in the development
    cycle, reducing the risk of unexpected behavior in production.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests aren’t a replacement for unit tests. Unit tests focus on the
    correctness of individual functions and modules, while integration tests verify
    how these components work together. A comprehensive testing strategy should include
    both unit and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: By investing time in writing effective integration tests, you can significantly
    improve the quality and reliability of your Express.js applications. They help
    prevent integration issues, increase confidence in your code base, and ultimately
    deliver a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing in Node.js microservices focuses on verifying the interactions
    between different components or services. It ensures that these components work
    together seamlessly to deliver the expected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests catch issues early in development, reducing production failures.
    By writing comprehensive integration tests, you encourage better code design and
    maintainability. Successful integration tests build confidence in the system’s
    overall reliability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let’s understand the key aspects of integration testing
    in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing boundaries**: Integration tests primarily focus on the interfaces
    between microservices. They verify data exchange, contract adherence, and error
    handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency management**: Effectively managing dependencies is essential.
    You might use mocking, stubbing, or test doubles to isolate components for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consistency**: Integration tests should validate data integrity across
    different services. This includes testing data transformations, consistency checks,
    and error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance considerations**: Integration tests can help identify performance
    bottlenecks and scalability issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having said this, it’s also important to understand exactly when you’d use
    integration testing. Let’s look at the instances when you would use this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API interactions**: Test how different microservices communicate through
    APIs, verifying request/response formats, error handling, and authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database interactions**: Ensure data is stored, retrieved, and updated correctly
    across multiple services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message queues**: Verify message delivery, processing, and error handling
    in asynchronous communication patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External systems**: Test interactions with external systems such as payment
    gateways, email services, or third-party APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long story short, integration tests in Node.js microservices verify that different
    components or services interact correctly, ensuring seamless functionality and
    preventing complex issues in production. Now, let’s implement integration tests
    for the transaction microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this subsection is to show you how you can implement integration
    tests for your Node.js services, particularly for Nest.js. The general idea of
    integration testing applies to all types of applications, regardless of whether
    you use Express.js or other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we need to install the required package to write integration tests
    for our project. Go to `Ch12/transactionservice` and run the following command
    to install the `jest` and `supertest` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already talked about the `jest` package. The `supertest` package is a
    high-level abstraction for testing HTTP servers. It makes it easy to send HTTP
    requests to your Nest.js application and inspect the responses, simulating real-world
    client behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Nest.js provides excellent integration with both Jest and Supertest, making
    it straightforward to set up and run integration tests. You can test various aspects
    of your Nest.js application, including controllers, services, and database interactions.
    Integration tests can be included in your CI/CD pipeline so that you can catch
    issues early in the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the root folder (`Ch12/transactionservice`) and create the `jest.config.js`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `jest.config.js` file is a configuration file that customizes Jest’s behavior.
    This particular configuration specifies that Jest should look for TypeScript,
    JavaScript, and JSON files (`moduleFileExtensions`). It sets the project root
    directory to `src`, defines test files as those ending with `.spec.ts`, and uses
    `ts-jest` to process TypeScript files. The configuration also enables code coverage
    reporting to `../coverage`, sets the test environment to Node.js, and executes
    `global-setup.js` before all tests and `global-teardown.js` after.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have `globalSetup` and `globalTeardown` in our Jest configuration to
    execute code before and after the entire test suite runs, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `globalSetup` runs once before all tests. It’s ideal for setting up resources
    such as databases, servers, or other external dependencies that are required for
    the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `globalTeardown` runs once after all tests have been completed. It’s
    used to clean up resources that are created in `globalSetup`, such as closing
    database connections or stopping servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the provided configuration, the scripts for these operations are located
    in the `./test/global-setup.js` and `./test/global-teardown.js` files. However,
    we don’t have these files yet. So, let’s create them. Go to the `test` folder
    and create both files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our `global-setup` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This global setup script initiates a Docker Compose environment for testing.
    It starts by logging a message, and then executes the `docker-compose up --build
    -d` command using the specified `docker-compose.tests.yml` file. Finally, it introduces
    a fifteen second delay to allow services sufficient time to start before test
    execution begins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `global-teardown` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `global-teardown` script terminates the Docker Compose environment. It
    logs a message indicating the process and then executes the `docker-compose down`
    command using the specified `docker-compose.tests.yml` file to stop all running
    containers and remove networks.
  prefs: []
  type: TYPE_NORMAL
- en: We run all dependent services from the Docker file, hence why we have a special
    file called `docker-compose.tests.yml` under `Ch12/transactionservice`. Check
    out this book’s GitHub repository for the source code for the `docker-compose.tests.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: This Docker Compose file defines a multi-container environment for a microservices
    application. It includes services for a PostgreSQL database, `PgAdmin` for database
    management, MongoDB, Zookeeper, Kafka, and a Kafka UI. The file also defines an
    account service built from a local `Dockerfile` file, configuring its dependencies
    on MongoDB and Kafka. Environment variables, ports, volumes, and network configurations
    are specified for each service. Here, `app-network` is used for internal communication
    between containers.
  prefs: []
  type: TYPE_NORMAL
- en: When writing integration tests for Nest.js applications, we often create a test
    configuration file. This configuration file specifies configuration values that
    are necessary for the test environment, such as database connections, API keys,
    or other sensitive information. You can set up in-memory or temporary databases
    for testing purposes to isolate test data and prevent conflicts with production
    data. It also helps us to configure mocking libraries or frameworks so that we
    can replace real external services with test doubles, improving test isolation
    and performance. We mostly define configuration options for testing frameworks
    or libraries, such as Jest or Supertest, to customize their behavior for integration
    tests. By centralizing test-specific configurations in a separate file, you enhance
    code organization, maintainability, and reusability. It also helps to prevent
    sensitive information from being accidentally committed to the main code base.
    Check out the `Ch12/transactionservice/test-configuration.ts` file for more content.
  prefs: []
  type: TYPE_NORMAL
- en: Our test configuration file sets up a Nest.js testing module for integration
    tests. It imports the necessary modules for database connection (`TypeOrm`), microservices
    (`ClientsModule`), and the target module (`TransactionModule`). It also configures
    a PostgreSQL database using environment variables or default values and establishes
    a Kafka client. Finally, the `testConfiguration` function compiles the testing
    module and returns it for use in integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed it yet, don’t forget to run the following command
    to make sure your test configuration will run properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `@nestjs/typeorm` is a package that seamlessly integrates `TypeORM`, a
    popular **object-relational mapper** (**ORM**), with the Nest.js framework. It
    provides a convenient way to interact with relational databases such as PostgreSQL,
    MySQL, SQLite, and others within your Nest.js application.
  prefs: []
  type: TYPE_NORMAL
- en: You must define your database tables as TypeScript classes (*entities*). Here,
    `TypeORM` handles the mapping between your code and the database schema. It supports
    features such as repositories, migrations, transactions, and more, making database
    operations efficient and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to write our simple integration test for the transaction microservice.
    The `transaction.controller.spec.ts` file can be found under `Ch12/transactionservice/src/test`
    and contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This test imports the necessary modules for testing and HTTP requests. The `beforeAll`
    hook sets up the test environment by creating a Nest.js application using the
    `testConfiguration` function, while the `afterAll` hook cleans up by closing the
    application. The test case focuses on creating a transaction. It constructs a
    transaction DTO with sample data and sends a `POST` request to the `/transaction`
    endpoint. The expected response status is `400` (*Bad Request*), indicating an
    error in the request. A timeout of `10000` milliseconds (`10` seconds) is set
    for the test. This test case verifies the basic functionality of the transaction
    creation endpoint and provides a foundation for further testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your tests, simply execute the `npm run test` command. Make sure Docker
    is running before executing any integration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Docker services](img/B09148_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Docker services'
  prefs: []
  type: TYPE_NORMAL
- en: 'When running integration tests with a Dockerized account microservice, the
    primary challenge is ensuring a consistent data state for each test. This involves
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data preparation**: Creating necessary accounts or records before each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data cleanup**: Removing test data after each test to prevent data pollution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database isolation**: Ensuring test data doesn’t interfere with other tests
    or environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle these challenges, we can use multiple solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`typeorm` and `sequelize` to create migration scripts for your account database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalSetup` or `beforeEach` hooks to populate the database with test data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalTeardown` or `afterEach` hooks to clean up the database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker volumes**: Define a Docker volume for your account microservice’s
    database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mount the volume**: Mount the volume to the container to persist data between
    test runs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Truncate or delete data**: Before each test, truncate or delete the database’s
    content to ensure a clean state.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test containers**: For complex scenarios, use a dedicated container for test
    data preparation and cleanup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestrate with Docker Compose**: Use Docker Compose to manage the relationship
    between the test container and the account microservice.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-memory databases**: For simpler scenarios, use in-memory databases such
    as SQLite for testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benefits**: Faster startup, isolation, and no need for data migration.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we’ve come to the end of this chapter! Let’s recap what we learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the critical role of testing in microservice
    architecture. Building upon our previous exploration of microservice creation,
    we emphasized the importance of rigorous testing for ensuring code quality and
    reliability. We introduced the concepts of unit and integration testing, explaining
    their distinct purposes and benefits.
  prefs: []
  type: TYPE_NORMAL
- en: To solidify our understanding, we implemented unit tests for both the account
    and transaction microservices. These tests verified the correct behavior of individual
    code units in isolation. Additionally, we explored the nuances of mocks, stubs,
    and spies, demonstrating their utility in isolating components during testing.
  prefs: []
  type: TYPE_NORMAL
- en: To assess the interactions between different microservices, we introduced integration
    testing. By combining unit tests with integration tests, we established a robust
    testing strategy for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into the practical implementation of CI/CD
    pipelines. We will explore how to utilize GitHub Actions to automate workflows
    and streamline the deployment of our microservices, particularly focusing on deploying
    to Azure Cloud. You’ll learn how to build a fully automated pipeline that ensures
    your applications are consistently ready for deployment with minimal manual intervention.
  prefs: []
  type: TYPE_NORMAL
