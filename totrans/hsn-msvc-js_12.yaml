- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Testing Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试微服务
- en: Testing is a critical phase within the **software development life cycle** (**SDLC**)
    that’s integral to ensuring the software meets the required standards and functions
    as expected. Testing detects bugs introduced during development. It verifies that
    the software performs its intended functions correctly and efficiently and ensures
    the software meets user requirements and specifications. By applying tests, we
    can reduce the risks associated with software failure or malfunction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是**软件开发生命周期（SDLC**）中的一个关键阶段，对于确保软件满足所需标准并按预期运行至关重要。测试可以检测开发过程中引入的错误。它验证软件是否正确且高效地执行其预期功能，并确保软件满足用户需求和规格。通过应用测试，我们可以降低软件故障或故障的风险。
- en: In this chapter, we’ll talk about different strategies for software testing
    within microservices. By the end, you’ll know how to write unit and integration
    tests for your microservices both in isolation and integrated with other microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论微服务内部软件测试的不同策略。到本章结束时，您将了解如何为您的微服务编写单元和集成测试，无论是独立还是与其他微服务集成。
- en: 'We’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding testing in a microservice architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解微服务架构中的测试
- en: Understanding and implementing unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现单元测试
- en: Implementing unit tests for the account microservice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为账户微服务实现单元测试
- en: Writing unit tests for the transaction microservice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为事务微服务编写单元测试
- en: Comparing mocks, stubs, and spies in unit tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中比较模拟、存根和间谍
- en: Understanding and implementing integration tests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现集成测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To implement our tests, we’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的测试，我们需要以下内容：
- en: An IDE of your choice (we prefer Visual Studio Code).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您选择的IDE（我们更喜欢Visual Studio Code）。
- en: This book’s GitHub repository, which can be downloaded from [https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript).
    Open the `Ch12` folder so that you can follow along with ease.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书可在[https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript](https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript)的GitHub仓库中下载。打开`Ch12`文件夹，以便您可以轻松地跟随。
- en: Understanding testing in a microservice architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解微服务架构中的测试
- en: 'Microservice architecture divides an application into smaller, loosely coupled
    services, each responsible for a specific business function. This approach offers
    numerous benefits, such as improved scalability and flexibility. However, it also
    introduces complexity, particularly in terms of testing. Comprehensive testing
    is crucial to ensure that these independent services function correctly and cohesively.
    Let’s try to understand the importance of testing in a microservice architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序划分为更小、松散耦合的服务，每个服务负责特定的业务功能。这种方法提供了许多好处，例如提高了可扩展性和灵活性。然而，它也引入了复杂性，尤其是在测试方面。全面的测试对于确保这些独立服务正确且协同工作至关重要。让我们尝试理解在微服务架构中测试的重要性：
- en: 'The first reason for using tests in a microservice architecture is to ensure
    **functionality**. Each service performs a distinct function in a microservice
    architecture and is developed independently. Testing ensures that each service
    performs its intended function correctly. We mostly use unit and functional testing
    to achieve this goal:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构中使用测试的第一个原因是确保**功能**。每个服务在微服务架构中执行一个独特的功能，并且是独立开发的。测试确保每个服务正确执行其预期功能。我们主要使用单元和功能测试来实现这一目标：
- en: '**Unit testing** focuses on individual components within a service, verifying
    that each function works as expected. This helps us catch bugs early in the development
    process.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**关注服务内的单个组件，验证每个函数是否按预期工作。这有助于我们在开发早期阶段捕捉到错误。'
- en: On the other hand, **functional testing** ensures that the service as a whole
    meets its functional requirements. This involves testing the service’s endpoints
    and ensuring that they return the expected results.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**功能测试**确保服务整体满足其功能要求。这涉及到测试服务的端点，并确保它们返回预期的结果。
- en: 'The second reason for using tests in microservices is to maintain **interoperability**.
    Microservices must communicate with each other to function as a cohesive application.
    Ensuring seamless interoperability between services is critical. To achieve this,
    we mostly focus on integration and contract testing:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务中使用测试的第二个原因是保持**互操作性**。微服务必须相互通信才能作为一个整体应用运行。确保服务之间无缝的互操作性至关重要。为此，我们主要关注集成和契约测试：
- en: '**Integration testing** focuses on interactions between services, verifying
    that data exchange and communication protocols are implemented correctly.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**关注服务之间的交互，验证数据交换和通信协议是否正确实现。'
- en: '**Contract testing** ensures that services adhere to defined APIs or contracts.
    This is particularly important when different teams develop services independently
    as it helps maintain consistent communication standards.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**契约测试**确保服务遵守定义的API或契约。当不同团队独立开发服务时，这尤其重要，因为它有助于保持一致的通信标准。'
- en: 'The third reason is **performance** assurance. Performance testing ensures
    that services operate efficiently under various load conditions, which is vital
    for maintaining a good user experience. We can achieve this goal using load testing
    and stress testing:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个原因是**性能**保证。性能测试确保服务在各种负载条件下高效运行，这对于维护良好的用户体验至关重要。我们可以通过负载测试和压力测试来实现这一目标：
- en: '**Load testing** evaluates how services handle expected load levels. This helps
    identify performance bottlenecks and ensures services can handle real-world usage.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**评估服务处理预期负载水平的能力。这有助于识别性能瓶颈并确保服务能够处理实际使用情况。'
- en: '**Stress testing** examines how services perform under extreme conditions,
    such as high traffic or resource shortages. This helps in understanding the service’s
    breaking point and resilience.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力测试**检查服务在极端条件下的表现，如高流量或资源短缺。这有助于了解服务的断裂点和弹性。'
- en: 'Testing is also important for **security** validation. Security is a critical
    concern in microservice architecture as each service may handle sensitive data
    and must be protected against vulnerabilities. We can use security testing and
    penetration testing to achieve our goal:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试对于**安全性**验证也很重要。在微服务架构中，安全性是一个关键问题，因为每个服务都可能处理敏感数据，必须保护其免受漏洞的侵害。我们可以使用安全测试和渗透测试来实现我们的目标：
- en: '**Security testing** identifies vulnerabilities and ensures that services can
    protect sensitive data. This includes testing for common security issues such
    as SQL injection, **cross-site scripting** (**XSS**), and authentication flaws.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全测试**识别漏洞并确保服务能够保护敏感数据。这包括测试常见的安全问题，如SQL注入、**跨站脚本攻击**（**XSS**）和身份验证缺陷。'
- en: '**Penetration testing** simulates attacks to identify potential security gaps.
    This helps in proactively securing services against real-world threats.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渗透测试**模拟攻击以识别潜在的安全漏洞。这有助于主动保护服务免受现实世界威胁。'
- en: 'Microservices need to be reliable and stable, especially during updates or
    changes. Testing ensures that services remain **dependable** over time. We have
    regression and chaos testing to make sure we have reliable and stable microservices:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务需要可靠和稳定，尤其是在更新或变更期间。测试确保服务在长时间内保持**可靠**。
- en: '**Regression testing** ensures that new changes or updates don’t introduce
    new bugs or break existing functionality. This is crucial for maintaining service
    reliability after each deployment.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**确保新的更改或更新不会引入新的错误或破坏现有功能。这对于在每次部署后维护服务可靠性至关重要。'
- en: '**Chaos engineering** involves intentionally introducing failures into the
    system to test its resilience. This helps us understand how services respond to
    unexpected issues and improves overall stability.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌工程**涉及故意引入系统故障以测试其弹性。这有助于我们了解服务如何应对意外问题并提高整体稳定性。'
- en: Having understood testing as a whole, let’s move on to unit tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在整体理解测试之后，让我们继续探讨单元测试。
- en: Understanding unit tests
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单元测试
- en: '**Unit testing** is a software testing technique that matters most when you
    want to ensure that individual units or components of the software are tested
    in isolation. The goal of unit testing is to validate that each unit of the software
    performs as expected.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种软件测试技术，当你想要确保软件的各个单元或组件在隔离状态下被测试时最为重要。单元测试的目的是验证每个软件单元是否按预期执行。'
- en: 'It’s an important aspect of software development, especially in microservices
    architectures. Node.js, with its asynchronous and event-driven nature, poses unique
    challenges and opportunities for unit testing. In this context, unit testing involves
    testing individual functions, methods, or classes within your Node.js application.
    Let’s cover the importance of unit testing for microservices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它是软件开发的重要方面，尤其是在微服务架构中。Node.js以其异步和事件驱动的特性，为单元测试带来了独特的挑战和机遇。在这种情况下，单元测试涉及测试Node.js应用程序中的单个函数、方法或类。让我们来谈谈单元测试对微服务的重要性：
- en: '**It ensures code quality**: Unit testing helps identify bugs early in the
    development cycle, ensuring that individual units of code function as intended.
    This is particularly important in microservices, where services are designed to
    be small, independent, and modular.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它确保了代码质量**：单元测试有助于在开发周期早期识别错误，确保代码单元按预期工作。这在微服务中尤为重要，因为服务被设计成小、独立和模块化。'
- en: '**It facilitates refactoring**: With a comprehensive suite of unit tests, developers
    can confidently refactor code, knowing that any changes will be verified by the
    tests. This is crucial for maintaining and improving the code base over time.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它促进了重构**：拥有全面的单元测试套件，开发者可以自信地重构代码，知道任何更改都将通过测试得到验证。这对于随着时间的推移维护和改进代码库至关重要。'
- en: '**It supports continuous integration/continuous deployment (CI/CD)**: Unit
    tests are an integral part of CI/CD pipelines. They provide immediate feedback
    on code changes, enabling quick iterations and stable deployments.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它支持持续集成/持续部署（CI/CD）**：单元测试是CI/CD管道的组成部分。它们对代码更改提供即时反馈，使快速迭代和稳定部署成为可能。'
- en: '**Better documentation**: Well-written unit tests serve as documentation for
    the code. They demonstrate how individual units are expected to behave, making
    it easier for new developers to understand the code base.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的文档**：良好的单元测试充当代码的文档。它们展示了各个单元预期如何表现，使得新开发者更容易理解代码库。'
- en: 'Let’s look at some of the benefits of performing unit testing in Node.js microservices:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在Node.js微服务中进行单元测试的一些好处：
- en: '**Improved reliability**: Unit tests ensure that each microservice behaves
    as expected, reducing the likelihood of runtime errors and improving overall system
    reliability.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高了可靠性**：单元测试确保每个微服务按预期行为，减少了运行时错误的可能性，并提高了整体系统的可靠性。'
- en: '**Faster development cycles**: Automated unit tests speed up the development
    process by allowing developers to quickly identify and fix issues. This is particularly
    beneficial in microservices, where services are developed and deployed independently.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的开发周期**：自动化的单元测试通过允许开发者快速识别和修复问题，从而加速开发过程。这在微服务中尤其有益，因为服务是独立开发和部署的。'
- en: '**Reduced debugging time**: With unit tests in place, bugs can be detected
    and isolated quickly, reducing the time spent on debugging.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少了调试时间**：有了单元测试，可以快速检测和隔离错误，从而减少调试时间。'
- en: '**Increased confidence in code changes**: Unit tests provide a safety net for
    developers, giving them the confidence to make changes and add new features without
    breaking existing functionality.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加了对代码更改的信心**：单元测试为开发者提供了一个安全网，使他们有信心进行更改和添加新功能，而不会破坏现有功能。'
- en: Unit testing in Node.js microservices enhances reliability, accelerates development
    by catching issues early, reduces debugging time, and boosts developer confidence
    in making code changes without breaking functionality. Now, let’s focus on unit
    testing packages we need to use to write unit tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js微服务中进行单元测试增强了可靠性，通过早期捕捉问题来加速开发，减少调试时间，并提高开发者对在不破坏功能的情况下进行代码更改的信心。现在，让我们专注于编写单元测试所需的单元测试包。
- en: Introducing unit testing packages
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍单元测试包
- en: Before writing a line of code, we need to prepare our environment. To be precise,
    we need to install the required packages to write unit tests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码行之前，我们需要准备我们的环境。更准确地说，我们需要安装编写单元测试所需的包。
- en: Chai, Mocha, and Sinon are popular libraries that are used for testing in Node.js
    applications, including microservices. Each of these libraries has a specific
    role and they often work together to provide a comprehensive testing framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Chai、Mocha和Sinon是Node.js应用程序（包括微服务）中常用的库，用于测试。这些库各自扮演着特定的角色，并且它们通常协同工作，提供全面的测试框架。
- en: Introducing Mocha
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Mocha
- en: First, let’s talk about **Mocha**. Mocha is a feature-rich JavaScript test framework
    that runs on Node.js, making asynchronous testing simple and fun. It provides
    a testing environment where you can define your tests and run them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the following features:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`describe` and `it` blocks.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allows asynchronous testing**: It supports both synchronous and asynchronous
    tests.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before`, `after`, `beforeEach`, and `afterEach`) for setting up and tearing
    down conditions for tests.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: It can be extended with various plugins and reporters to customize
    the testing setup.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can install it using the `npm install --save-dev` `mocha` command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Chai
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Chai** is a popular assertion library that’s used with Node.js, often in
    combination with testing frameworks such as Mocha. It provides a variety of interfaces
    and styles for writing tests, making it flexible and easy to use.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'It supports different assertion styles, two of which we’ll look at here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The first and maybe the most used style is known as `expect` and `should` interfaces.
    They’re used for writing expressive and readable assertions. This style allows
    for natural language assertions, making tests easier to understand.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second style is known as `assert` interface is used for writing classical
    unit test assertions. This style is more traditional and straightforward, which
    makes it suitable for developers familiar with xUnit frameworks.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can install it using the `npm install --save-dev` `chai` command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: While Chai has many features, let’s understand three of the most relevant ones.
    The first feature we’ll look at is its `chai-as-promised` for promise assertions
    and `chai-http` for HTTP assertions. The second key feature is **extensibility**.
    Chai can be extended to create custom assertions using its plugin API. This allows
    developers to add domain-specific language to their tests On the other hand, Chai
    has a cool feature known as readable and expressive syntax. Chai’s BDD-style assertions
    are designed to be readable and expressive, making tests easier to write and understand.
    Finally, Chai also **integrates** seamlessly with Mocha, providing a powerful
    combination for writing and running tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Sinon
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sinon** is another powerful library for testing in JavaScript that’s particularly
    useful for creating spies, stubs, and mocks to control and monitor the behavior
    of functions. It’s especially valuable in unit testing to isolate the code under
    test from its dependencies, ensuring that the tests focus on the specific functionality
    being tested.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we learn how to implement unit tests, let’s take a look at some of the
    key features of Sinon:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Spies**: Track and monitor the behavior of functions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubs**: Replace functions with predefined behaviors.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocks**: Create fake objects with expectations for their behavior.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fakes**: Combine the behavior of spies and stubs for simpler use cases.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timers**: Control and simulate the passage of time in tests.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` and the Fetch API to test AJAX requests.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`XMLHttpRequest`和Fetch API来测试AJAX请求。
- en: We can install it using the `npm install --save-dev sinon` command. Sinon can
    mock functions, HTTP requests, and more, making it ideal for unit testing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`npm install --save-dev sinon`命令来安装它。Sinon可以模拟函数、HTTP请求等，使其非常适合单元测试。
- en: Other packages in Node.js
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的其他包
- en: Along with `Chai`, we have other popular assertion libraries such as Jest. **Jest**
    has its own assertion library, which is fully integrated and optimized for use
    with Jest.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Chai`，我们还有其他流行的断言库，如`Jest`。**Jest**拥有自己的断言库，它与`Jest`完全集成并优化了使用体验。
- en: When implementing unit tests, we also need mocking and stubbing libraries. In
    unit testing, mocks and stubs are used to isolate the unit of code being tested
    by simulating the behavior of dependencies. This allows you to test the functionality
    of a specific unit without having to rely on external components, such as databases,
    network services, or other modules.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现单元测试时，我们还需要模拟和存根库。在单元测试中，模拟和存根用于通过模拟依赖项的行为来隔离正在测试的代码单元。这允许您测试特定单元的功能，而无需依赖于外部组件，如数据库、网络服务或其他模块。
- en: Along with `Sinon`, we use the `Testdouble` is a minimal, standalone test double
    library for JavaScript. You can use the `npm install --save-dev testdouble` command
    to install it. Testdouble provides tools for creating, using, and verifying test
    doubles in JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Sinon`，我们还使用`Testdouble`，这是一个用于JavaScript的最小、独立的测试替身库。您可以使用`npm install --save-dev
    testdouble`命令来安装它。Testdouble提供了创建、使用和验证JavaScript中测试替身（test doubles）的工具。
- en: What should we test in unit testing?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元测试中我们应该测试什么？
- en: 'Before implementing unit tests in our project, we need to answer one simple
    question: what should we unit test? Let’s take a look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中实施单元测试之前，我们需要回答一个简单的问题：我们应该单元测试什么？让我们来看看：
- en: '**Business logic**: This is the most critical part to test. Business logic
    includes the rules and operations that dictate how data is transformed, manipulated,
    and controlled. It ensures the application behaves correctly under various conditions.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑**：这是测试中最关键的部分。业务逻辑包括规定数据如何转换、操作和控制的规则和操作。它确保应用程序在各种条件下都能正确运行。'
- en: '**Edge cases**: Test the boundaries and limits of your application. This includes
    checking how the application handles unexpected, extreme, or invalid inputs.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界情况**：测试应用程序的边界和限制。这包括检查应用程序如何处理意外、极端或无效的输入。'
- en: '**Error handling**: Ensure that the application responds correctly to error
    conditions, such as invalid input or failed operations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：确保应用程序能够正确响应错误条件，例如无效输入或操作失败。'
- en: '**State transitions**: If the application involves state changes (such as a
    status update), make sure these transitions occur as expected.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态转换**：如果应用程序涉及状态变化（例如状态更新），请确保这些转换按预期发生。'
- en: '**Return values**: Verify that functions return the correct values for given
    inputs.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：验证函数对于给定的输入返回正确的值。'
- en: '**Dependencies and interactions**: While unit tests should ideally test a unit
    in isolation, it’s important to mock dependencies and verify interactions between
    components to ensure they collaborate correctly.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖和交互**：虽然单元测试理想情况下应该独立测试一个单元，但模拟依赖项并验证组件之间的交互对于确保它们正确协作非常重要。'
- en: Now that we know what we should test, it’s time to implement unit testing so
    that we can see it in practice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了应该测试什么，是时候实施单元测试，以便我们能在实践中看到它的效果。
- en: Implementing unit tests for the account microservice
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施账户微服务的单元测试
- en: A copy of the source code for [*Chapter 7*](B09148_07.xhtml#_idTextAnchor121)
    can be found in the `Ch12` folder of this book’s GitHub repository. This chapter
    will demonstrate how to test different microservices. We’ll start with the account
    microservice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库的`Ch12`文件夹中可以找到[*第7章*](B09148_07.xhtml#_idTextAnchor121)的源代码。本章将演示如何测试不同的微服务。我们将从账户微服务开始。
- en: Create a new folder at the same level as the `src` folder and name it `tests`.
    Our main focus here is to test the `src/services/account.js` file. It contains
    the main logic and the required business rules that are implemented in our application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`src`文件夹同一级别的位置创建一个新的文件夹，并将其命名为`tests`。我们在这里的主要重点是测试`src/services/account.js`文件。它包含应用程序中实现的主要逻辑和所需业务规则。
- en: Next, create a file called `accountservice.test.mjs` under the `tests` folder.
    Why the `.mjs` extension? This extension is used in Node.js projects to indicate
    that a JavaScript file should be treated as an `import` and `export` syntax. By
    using `.mjs`, Node.js can unambiguously determine that the file should be treated
    as an ES module, even if it exists alongside `CommonJS` files with a `.js` extension.
    This avoids confusion and potential conflicts, especially in projects that use
    both module systems. Using `.mjs` makes it explicit to developers and tools that
    the file is an ES module, helping them avoid making mistakes and misconfigurations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`tests`文件夹下创建一个名为`accountservice.test.mjs`的文件。为什么使用`.mjs`扩展名？这个扩展名在Node.js项目中用于指示一个JavaScript文件应该被视为`import`和`export`语法。通过使用`.mjs`，Node.js可以明确地确定该文件应该被视为ES模块，即使它与具有`.js`扩展名的`CommonJS`文件共存。这避免了混淆和潜在冲突，尤其是在使用两种模块系统的项目中。使用`.mjs`使开发人员和工具明确知道该文件是ES模块，帮助他们避免错误和配置错误。
- en: Simply put, using the `.mjs` extension in Node.js projects helps separate ES
    modules from CommonJS modules. This ensures Node.js handles them correctly and
    keeps your code compatible with modern JavaScript standards. By using `.mjs`,
    you can simplify your module setup and make your code more future proof as JavaScript
    continues to evolve.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在Node.js项目中使用`.mjs`扩展名有助于将ES模块与CommonJS模块分开。这确保Node.js正确处理它们，并保持您的代码与现代JavaScript标准兼容。通过使用`.mjs`，您可以简化模块设置，并使您的代码更具未来性，因为JavaScript仍在不断发展。
- en: We plan to implement unit tests for the `account.js` file, which can be found
    in the `src /` `services` folder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划为`account.js`文件实现单元测试，该文件位于`src /` `services`文件夹中。
- en: 'We have multiple functions inside this service. First, let’s consider some
    unit tests for the `getAccountById` function. Here’s the original function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务中，我们有许多函数。首先，让我们考虑对`getAccountById`函数的一些单元测试。这是原始函数：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From an implementation perspective, we haven’t implemented valid exception handling.
    We *throw* the same exception from the database layer to the API layer directly.
    It’s generally better to handle exceptions either at the lowest level (database
    layer) or at the highest level (API layer). *Lower layers* should primarily focus
    on detecting and throwing exceptions when unexpected conditions arise. This maintains
    a clean separation of concerns and prevents lower layers from exposing implementation
    details. Some exceptions, such as database connection failures or file read/write
    errors, might require immediate handling at the lowest level to prevent data corruption
    or resource leaks. For instance, if a file write operation fails due to a full
    disk, handling the exception at this level can prevent further issues. If the
    exception is expected and can be handled within the lower layer without exposing
    internal details, it’s reasonable to do so. A centralized error-handling mechanism
    at the highest layer can provide consistent error management across the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从实现的角度来看，我们还没有实现有效的异常处理。我们直接从数据库层抛出相同的异常到API层。通常，最好在最低层（数据库层）或最高层（API层）处理异常。*低层*应主要关注在出现意外条件时检测和抛出异常。这保持了关注点的清晰分离，并防止低层暴露实现细节。一些异常，如数据库连接失败或文件读写错误，可能需要在最低层立即处理，以防止数据损坏或资源泄露。例如，如果文件写入操作由于磁盘已满而失败，在此级别处理异常可以防止进一步的问题。如果异常是预期的，并且可以在低层处理而无需暴露内部细节，那么这样做是合理的。在最高层集中处理错误可以提供跨应用程序的一致错误管理。
- en: 'First, let’s install the required packages. To do so, run the `npm install
    --save-dev mocha chai sinon` command. After installation, we’ll have the following
    `devDependencies` section in the `package.json` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装所需的包。为此，运行`npm install --save-dev mocha chai sinon`命令。安装完成后，我们将在`package.json`文件中的`devDependencies`部分看到以下内容：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, it’s time to import the necessary packages and functionalities:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候导入必要的包和功能了：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What should we test in our account service? The first function that needs to
    be tested is `getAccountById`. We should check whether the function will return
    the exact account information if the given account exists in our database. Here’s
    our first test case:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在账户服务中测试什么？需要测试的第一个函数是`getAccountById`。我们应该检查如果给定的账户存在于我们的数据库中，该函数是否会返回确切的账户信息。这是我们的第一个测试用例：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Well, this code may seem a little bit complicated at first glance, but the detailed
    explanation provided in this section will help you understand it with ease.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In Mocha, the `describe` and `it` blocks are fundamental structures that are
    used to write and organize tests.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe` block is used to group related test cases. It helps organize
    tests into logical sections, making them easier to read and understand. It’s typically
    used to group tests related to a particular feature or function. The `describe`
    block has two parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`description`: A string that describes the group of tests. This description
    will appear in the test’s output.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`function`: A callback function that contains the test cases (using it blocks)
    and any setup/teardown logic.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `it` block is used to define individual test cases. Each `it` block represents
    a single test that performs a specific assertion or set of assertions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest `describe` blocks to create a hierarchical structure for your
    tests, making it easier to organize and understand complex test suites. Here’s
    an example of this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In practice, you typically use `describe` to group tests by the feature or unit
    of code being tested and `it` to define the specific behaviors you expect from
    that code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get back to our example. Our code snippet describes a unit test for a
    service function called `getAccountById`. The test uses a mocking library called
    `Sinon` to simulate the behavior of a function named `findById` within the account
    module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In simpler terms, this test checks whether the `getAccountById` service function
    correctly retrieves an account by its ID using the `findById` function. It ensures
    that the service returns the expected account data when the ID is found.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a line-by-line explanation of our first unit test:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 1* declares a test suite named `getAccountById service`. The function
    that’s passed to `describe` will contain the test cases related to `getAccountById
    service`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 2* declares the `findByIdStub` variable, which will be used later to
    hold the stub created by Sinon.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 3* sets up a function to run before each test case within this `describe`
    block.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `beforeEach` function in *Line 4*, `Sinon` creates a stub for the
    `findById` method of the `account` model. This stub will replace the original
    `findById` method, allowing us to control its behavior during tests.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 7* sets up a function to run after each test case within this `describe`
    block.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `afterEach` function in *Line 8*, the `restore` method is called
    on `findByIdStub`. This restores the original `findById` method of the account
    model, ensuring that stubs don’t affect other tests.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 11* declares a test case with a description of `should return the account
    if found by id`. The function that’s passed to it contains the test logic.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 12* declares a constant, `expectedAccountId`, and assigns it a value
    of `''12345''`. This is the ID that will be used to search for the account.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 13* declares a constant, `expectedAccount`, and assigns it a mock account
    object. This is the account that the stubbed `findById` method will return.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 14* sets up `findByIdStub` to resolve (return a promise that resolves
    to) `expectedAccount` when it’s called with `expectedAccountId`. This simulates
    the behavior of finding an account in the database.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 15* calls the `getAccountById` service function with `expectedAccountId`
    and awaits its result. The result is assigned to the account variable.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 16* asserts that the account that’s returned by the service function
    is deeply equal to `expectedAccount`. Deep equality checks that all properties
    of the objects are equal.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 17* asserts that `findByIdStub` was called exactly once with `expectedAccountId`.
    This verifies that the service function attempted to find the account by the correct
    ID.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the next few unit tests inside the same `describe` block:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this unit test suite, two test cases have been defined for the `getAccountById`
    service:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The first test case, named `should return null if account not found`, sets up
    a scenario where the account with an ID of `'54321'` doesn’t exist. Here, `findByIdStub`
    is configured to return `null` when called with this ID. The test then calls `getAccountById`
    with `'54321'` and expects the result to be `null`. It also verifies that `findByIdStub`
    was called exactly once with `'54321'`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test case, named `should rethrow errors from findById`, tests the
    behavior when the `findById` method throws an error. Here, `findByIdStub` is set
    up to throw `Database error` when called with ID `'98765'`. The test calls `getAccountById`
    and expects the call to throw the same error. This is verified using a try-catch
    block, where it’s checked that the caught error is equal to the expected error.
    Additionally, it verifies that `findByIdStub` was called exactly once with `'98765'`.
    These tests ensure that the `getAccountById` service correctly handles cases where
    the account isn’t found and when errors occur during database access. Please keep
    in mind that rethrowing errors should include meaningful handling, such as logging
    or adding additional context to the error.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tests except `updateAccountById` follow approximately the same testing
    style. In a given service, the most complex implementation exists inside the `updateAccountById`
    function. Please refer to [*Chapter 5*](B09148_05.xhtml#_idTextAnchor074) to learn
    more about the `Account` microservice and its business cases.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'We should cover every business rule that’s implemented in our original functionality.
    Here’s the first condition that we need to cover when updating the account:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function ensures that an account update is meaningful by requiring at least
    one valid piece of information (name, number, type, or status) to be provided.
    If none are given, it returns an error, to enforce the business rule of avoiding
    invalid updates.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the unit test fragment:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet describes a unit test for a service function called
    `updateAccountById`. This function is responsible for updating an account based
    on a given ID and update data. The test employs `Sinon` to substitute the behavior
    of the `findById` and `save` methods within the account module.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段描述了一个名为`updateAccountById`的服务函数的单元测试。这个函数负责根据给定的ID和更新数据更新账户。测试使用`Sinon`来替代账户模块中`findById`和`save`方法的行为。
- en: Before each test case, `Sinon` stubs are established for both the `findById`
    and `save` methods to enable controlled test scenarios. After each test, these
    stubs are restored to their original state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试用例之前，为`findById`和`save`方法建立`Sinon`存根，以实现可控的测试场景。在每个测试之后，这些存根都会恢复到它们原始的状态。
- en: The specific test case focuses on validating the error handling process when
    no update data is provided. It constructs an account ID and an empty update object.
    Subsequently, it invokes the `updateAccountById` service with these parameters
    and captures the result that’s returned.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的测试用例专注于验证没有提供更新数据时的错误处理过程。它构建了一个账户ID和一个空的更新对象。随后，它使用这些参数调用`updateAccountById`服务，并捕获返回的结果。
- en: The test then asserts that the returned result is an error object containing
    a specific error message and code, indicating the absence of valid update data.
    To ensure the correct behavior, it further verifies that neither the `findById`
    nor the `save` method was called as no account retrieval or update was necessary
    in this scenario.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后断言返回的结果是一个包含特定错误消息和代码的错误对象，表明缺少有效的更新数据。为了确保正确的行为，它进一步验证了`findById`和`save`方法都没有被调用，因为在这种情况下不需要检索或更新账户。
- en: Long story short, this unit test guarantees that the `updateAccountById` service
    correctly handles cases where no update data is supplied, returning an appropriate
    error response without performing unnecessary operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个单元测试保证了`updateAccountById`服务正确处理没有提供更新数据的情况，返回适当的错误响应而不执行不必要的操作。
- en: 'The next piece of logic in the `updateAccountById` function is defined like
    this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateAccountById`函数中的下一部分逻辑定义如下：'
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet indicates that if the status isn’t part of the allowed
    statuses defined by the business rules, it returns an error message, preventing
    the update with an invalid or unsupported status. This ensures that only acceptable
    status changes are made, maintaining business consistency and data integrity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段表明，如果状态不是由业务规则定义的允许状态之一，它将返回一个错误消息，防止使用无效或不支持的状态进行更新。这确保了只有可接受的状态更改被做出，保持业务一致性和数据完整性。
- en: 'The following unit test validates error handling for invalid status updates:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的单元测试验证了对无效状态更新的错误处理：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding unit test verifies error handling for invalid status updates in
    the `updateAccountById` service. It simulates an update with an invalid status.
    The test expects an error object with specific details when the service encounters
    this invalid input. To isolate the test, stubs prevent database interactions.
    By asserting the correct error, the test ensures the service behaves as expected
    when faced with incorrect data.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述单元测试验证了`updateAccountById`服务中对无效状态更新的错误处理。它模拟了一个使用无效状态的更新。当服务遇到这个无效输入时，测试期望一个包含特定详细信息的错误对象。为了隔离测试，存根防止了数据库交互。通过断言正确的错误，测试确保服务在面对错误数据时表现如预期。
- en: Using the same approach we implemented for the preceding unit tests, we can
    test all the possible cases for our services. For more complete implementation,
    check out this book’s GitHub repository and the respective folder for this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在前面的单元测试中实施的方法，我们可以测试我们服务的所有可能情况。为了更完整的实现，请查看本书的GitHub仓库以及本章的相关文件夹。
- en: 'To run unit tests, navigate to the root folder from the command line (for us,
    this is the `Ch12`/`accountservice` folder) and run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行单元测试，从命令行导航到根文件夹（对我们来说，这是`Ch12`/`accountservice`文件夹），并运行以下命令：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Figure 12.1: Results of the test run](img/B09148_12_1.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：测试运行结果](img/B09148_12_1.jpg)'
- en: 'Figure 12.1: Results of the test run'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：测试运行结果
- en: With that, we’ve demonstrated how to write tests for the Express.js project.
    The same unit testing logic is the same for Nest.js applications. You can easily
    apply the aforementioned ideas to your Nest.js applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经展示了如何为Express.js项目编写测试。对于Nest.js应用程序，相同的单元测试逻辑也是一样的。你可以轻松地将上述想法应用到你的Nest.js应用程序中。
- en: Writing unit tests for the transaction microservice
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为事务微服务编写单元测试
- en: Now, it’s time to demonstrate how easily you can write unit tests for your Nest.js
    applications. In this book’s GitHub repository, in the `Ch12` folder, we have
    the same transaction service we implemented in [*Chapter 7*](B09148_07.xhtml#_idTextAnchor121).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示如何轻松地为你的Nest.js应用程序编写单元测试。在这本书的GitHub仓库中，在`Ch12`文件夹中，我们有与[*第7章*](B09148_07.xhtml#_idTextAnchor121)中实现相同的交易服务。
- en: Open the `transaction.service.spec.ts` file, which can be found in the `src/test`
    folder. It contains all the essential tests to help us understand how to write
    unit tests. If you want to follow along and implement everything from scratch,
    just create a folder named `test` inside the `src` folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`transaction.service.spec.ts`文件，该文件位于`src/test`文件夹中。它包含所有必要的测试，帮助我们了解如何编写单元测试。如果你想从头开始实现所有内容，只需在`src`文件夹内创建一个名为`test`的文件夹。
- en: 'First things first, we need to install the required packages to implement unit
    testing for our project. To write unit tests for `transaction.service.js`, we
    need to install the `@nestjs/``testing` package. Here’s how you can do it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装所需的包来实现我们项目的单元测试。要为`transaction.service.js`编写单元测试，我们需要安装`@nestjs/testing`包。以下是操作步骤：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once it’s been installed, create a file called `transaction.service.spec.ts`.
    First, we need to import the required references:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，创建一个名为`transaction.service.spec.ts`的文件。首先，我们需要导入所需的引用：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code imports the necessary services for testing: `TransactionService`
    handles transaction logic, `PrismaService` interacts with the database, `HttpService`
    handles external HTTP requests, `KafkaService` performs message handling, and
    `CreateTransactionDto` defines the structure of transaction data. The `Test` and
    `TestingModule` imports are from the Nest.js testing module and are used to create
    a testing environment for `TransactionService`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码导入了测试所需的必要服务：`TransactionService`处理事务逻辑，`PrismaService`与数据库交互，`HttpService`处理外部HTTP请求，`KafkaService`执行消息处理，`CreateTransactionDto`定义了事务数据结构。`Test`和`TestingModule`导入来自Nest.js测试模块，用于为`TransactionService`创建测试环境。
- en: 'Here’s what a simple unit test looks like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的单元测试示例：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We already know about the `describe` block and its role in unit testing. The
    preceding code snippet establishes a testing environment for `TransactionService`.
    It begins by importing the necessary modules and services: `TransactionService`,
    `PrismaService` for database interactions, `HttpService` for external requests,
    `KafkaService` for message handling, and `CreateTransactionDto` for data transfer.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了`describe`块及其在单元测试中的作用。前面的代码片段为`TransactionService`建立了一个测试环境。它首先导入必要的模块和服务：`TransactionService`、用于数据库交互的`PrismaService`、用于外部请求的`HttpService`、用于消息处理的`KafkaService`以及用于数据传输的`CreateTransactionDto`。
- en: A `describe` block encapsulates the tests for `TransactionService`. Inside,
    variables are declared to hold instances of the services. The `beforeEach` block
    sets up the testing module using `Test.createTestingModule`. It provides mock
    implementations for `PrismaService`, `HttpService`, and `KafkaService` to isolate
    `TransactionService` during testing. The `PrismaService` mock includes methods
    such as `create`, `findMany`, `findUnique`, and `update` to simulate database
    operations. If you open `transaction.service.ts`, you’ll realize that we use these
    methods to implement the functionalities of the transaction service. Similarly,
    the `HttpService` and `KafkaService` mocks mimic their respective functionalities
    using Jest’s `jest.fn()`. This setup allows for controlled testing of `TransactionService`
    without the need to rely on actual external dependencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`describe`块封装了`TransactionService`的测试。在内部，声明变量以保存服务的实例。`beforeEach`块使用`Test.createTestingModule`设置测试模块。它为`PrismaService`、`HttpService`和`KafkaService`提供模拟实现，以在测试期间隔离`TransactionService`。`PrismaService`模拟包括`create`、`findMany`、`findUnique`和`update`等方法来模拟数据库操作。如果你打开`transaction.service.ts`，你会意识到我们使用这些方法来实现事务服务的功能。同样，`HttpService`和`KafkaService`模拟使用Jest的`jest.fn()`来模仿它们各自的功能。这种设置允许在不依赖实际外部依赖的情况下对`TransactionService`进行受控测试。
- en: 'Here, `jest.fn()` is a function provided by Jest, a popular JavaScript testing
    framework, to create mock functions. A mock function is essentially a dummy function
    that can be used to replace real functions during testing. There are a lot of
    benefits and values to using such types of functionalities in unit testing. Here
    are the benefits of using `jest.fn()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`jest.fn()`是由Jest，一个流行的JavaScript测试框架提供的函数，用于创建模拟函数。模拟函数本质上是一个占位函数，可以在测试期间用来替换真实函数。在单元测试中使用此类功能有很多好处和价值。以下是使用`jest.fn()`的好处：
- en: '**Isolation**: It allows us to isolate the component or function you’re testing
    by replacing dependencies with mock functions. This helps us focus on the specific
    behavior of the code under test without being affected by external factors.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：它允许我们通过用模拟函数替换依赖项来隔离你正在测试的组件或函数。这有助于我们专注于代码的特定行为，而不会受到外部因素的影响。'
- en: '**Verifiability**: We can assert how many times the mock function was called,
    with what arguments, and what it returned. This helps in verifying the correct
    behavior of the code.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可验证性**：我们可以断言模拟函数被调用的次数、调用参数以及返回值。这有助于验证代码的正确行为。'
- en: '**Custom implementation**: We can define the behavior of the mock function
    using mock implementation to control its return value or actions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义实现**：我们可以使用模拟实现来定义模拟函数的行为，以控制其返回值或操作。'
- en: 'By using `jest.fn()`, we can effectively test different scenarios and edge
    cases without relying on the actual implementation of the mocked function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`jest.fn()`，我们可以有效地测试不同的场景和边缘情况，而无需依赖于模拟函数的实际实现：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `module.get` method is used to access the providers that were defined in
    the `TestingModule` setup. It takes the service class as an argument and returns
    an instance of that service. By calling `module.get` for each service (`TransactionService`,
    `PrismaService`, `HttpService`, and `KafkaService`), the code obtains references
    to these services, which can then be used for testing purposes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`module.get`方法来访问在`TestingModule`设置中定义的提供者。它接受服务类作为参数，并返回该服务的实例。通过为每个服务（`TransactionService`、`PrismaService`、`HttpService`和`KafkaService`）调用`module.get`，代码获取了这些服务的引用，然后可以用于测试目的。
- en: These service instances are typically used within the test cases to interact
    with the system under test and verify its behavior.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务实例通常在测试用例中使用，以与被测试的系统交互并验证其行为。
- en: 'First, let’s start with a simple test case:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个简单的测试用例开始：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code snippet defines a basic test case to ensure the service instance is
    injected correctly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段定义了一个基本的测试用例，以确保服务实例被正确注入。
- en: The `it('should be defined', () => { ... })` block creates a test case with
    a description of `should be defined` Inside this block, the `expect(service).toBeDefined();`
    assertion checks whether the `service` variable has a defined value. This is a
    fundamental test to verify that the dependency injection process has successfully
    provided an instance of `TransactionService`. If the service is `null` or `undefined`,
    the test will fail.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`it(''should be defined'', () => { ... })`块创建了一个描述为`should be defined`的测试用例。在这个块内部，`expect(service).toBeDefined();`断言检查`service`变量是否有定义的值。这是一个基本的测试，用于验证依赖注入过程是否成功提供了一个`TransactionService`的实例。如果服务是`null`或`undefined`，则测试将失败。'
- en: 'Essentially, this test case acts as a sanity check to ensure the testing environment
    has been set up correctly before we proceed with more complex test scenarios.
    Now, let’s switch to testing the transaction creation process:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这个测试用例作为一个理智检查，以确保在继续进行更复杂的测试场景之前，测试环境已经正确设置。现在，让我们切换到测试事务创建过程：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This test case aims to verify the `create` method of `TransactionService` under
    specific conditions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试用例旨在验证在特定条件下`TransactionService`的`create`方法。
- en: It starts by defining a test scenario where the account status is either `new`
    or `active`. A `CreateTransactionDto` object is created with the necessary data.
    To simulate external dependencies, `httpService` and `prismaService` are mocked
    using `jest.spyOn`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先定义了一个测试场景，其中账户状态可以是`new`或`active`。使用必要的数据创建了一个`CreateTransactionDto`对象。为了模拟外部依赖，使用`jest.spyOn`来模拟`httpService`和`prismaService`。
- en: Here, `jest.spyOn` is a function in Jest that’s used to create a spy on an existing
    function. Unlike `jest.fn()`, which creates a new mock function, `jest.spyOn`
    wraps an existing function to track calls and potentially modify its behavior.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`jest.spyOn`是Jest中的一个函数，用于在现有函数上创建一个间谍。与创建新模拟函数的`jest.fn()`不同，`jest.spyOn`将现有函数包装起来以跟踪调用并可能修改其行为。
- en: We can use `jest.spyOn` to observe how a particular function is used within
    your code without altering its original implementation. It also records information
    about function calls, such as arguments, return values, and the number of times
    it was called. This is useful for verifying the interaction between different
    parts of our code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`jest.spyOn`来观察特定函数在代码中的使用情况，而不会改变其原始实现。它还记录有关函数调用信息，如参数、返回值和调用次数。这对于验证我们代码不同部分之间的交互非常有用。
- en: While optional, we can change the behavior of the spied function. This is helpful
    when we want to control the output of the function for specific test cases. After
    testing, we can restore the original function’s behavior.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是可选的，但我们也可以更改被监视函数的行为。当我们想要控制特定测试用例的函数输出时，这很有帮助。测试完成后，我们可以恢复原始函数的行为。
- en: The `httpService.axiosRef.get` method is mocked to return a successful account
    response with an `active` status. The `prismaService.transaction.create` method
    is also mocked to return a created transaction with the `CREATE` status.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpService.axiosRef.get`方法被模拟以返回一个具有`active`状态的成功的账户响应。`prismaService.transaction.create`方法也被模拟以返回一个具有`CREATE`状态的已创建交易。'
- en: The `service.create` method is then called with the prepared `createTransactionDto`
    object. The test asserts that the returned result matches the expected transaction
    data, indicating successful creation. Additionally, it verifies that `httpService.axiosRef.get`
    was called with the correct URL to fetch account information, and `prismaService.transaction.create`
    was called with the correct data to persist the transaction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`service.create`方法，并使用准备好的`createTransactionDto`对象。测试断言返回的结果与预期的交易数据匹配，表明创建成功。此外，它还验证了`httpService.axiosRef.get`是否以正确的URL调用以获取账户信息，以及`prismaService.transaction.create`是否以正确的数据调用以持久化交易。
- en: Essentially, this test case ensures that the `create` method interacts with
    `httpService` correctly to fetch account details, determines the transaction status
    based on account status, and persists the transaction to the database through
    `prismaService` with the expected data. By mocking dependencies, the test isolates
    the `create` method’s logic and verifies its behavior without relying on external
    systems.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这个测试用例确保`create`方法正确地与`httpService`交互以获取账户详情，根据账户状态确定交易状态，并通过`prismaService`使用预期数据将交易持久化到数据库。通过模拟依赖项，测试隔离了`create`方法的逻辑并验证了其行为，而不依赖于外部系统。
- en: It should now be easy for you to understand the rest of the unit tests that
    have been implemented inside our `transaction.service.spec.ts` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很容易理解我们已经在`transaction.service.spec.ts`文件内部实现的其余单元测试。
- en: When implementing unit tests, you may hear a lot about mocks, stubs, and spies.
    As our last topic regarding unit tests, let’s explore and understand their responsibilities.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现单元测试时，你可能会听到很多关于模拟、存根和间谍的内容。作为我们关于单元测试的最后一个主题，让我们探索和理解它们的职责。
- en: To run all your tests, you simply need to run the `npm test` command (*Figure
    12**.2*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行所有测试，你只需运行`npm test`命令（*图12**.2*）。
- en: 'There may be cases where tests fail to run properly. To resolve this, please
    refer to this book’s GitHub repository and ensure that the `package-lock.json`
    file matches the package versions specified in the repository:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在测试无法正确运行的情况。为了解决这个问题，请参考本书的GitHub仓库，并确保`package-lock.json`文件与仓库中指定的包版本匹配：
- en: '![Figure 12.2: Running transaction tests](img/B09148_12_2.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：运行事务测试](img/B09148_12_2.jpg)'
- en: 'Figure 12.2: Running transaction tests'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：运行事务测试
- en: As mentioned previously, we can use various building blocks for testing, such
    as mocks, stubs, and spies. Let’s try to understand and differentiate them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用各种构建块进行测试，例如模拟（mocks）、存根（stubs）和间谍（spies）。让我们尝试理解和区分它们。
- en: Comparing mocks, stubs, and spies in unit tests
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中比较模拟、存根和间谍
- en: We’ll spend this section comparing mocks, stubs, and spies in unit tests because
    they’re essential tools for isolating and simulating components’ behaviors during
    testing. Understanding their differences will help us choose the right approach
    to test various interactions and functionalities in the system effectively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中比较单元测试中的模拟、存根和间谍（spy），因为它们是在测试期间隔离和模拟组件行为的关键工具。了解它们之间的差异将帮助我们选择正确的方法，有效地测试系统中的各种交互和功能。
- en: Mocks
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: A **mock** is a simulated object that replaces a real dependency in a unit test.
    It’s designed to mimic the behavior of the original object but with complete control
    over its actions. Why? This isolation allows for focused testing of the code under
    scrutiny without the need to rely on external factors.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**是一个模拟对象，用于在单元测试中替换真实的依赖项。它旨在模仿原始对象的行为，但对其动作有完全的控制。为什么？这种隔离允许我们专注于审查代码，而无需依赖外部因素。'
- en: We can define exact return values, exceptions, or sequences of actions for mock
    objects. This enables us to test various scenarios and edge cases. Mocks can record
    interactions, allowing us to verify that methods were called with correct arguments,
    in the right order, and with the expected frequency. By replacing real dependencies
    with mocks, we can create a controlled environment, preventing unexpected side
    effects and ensuring test reliability.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为模拟对象定义确切的返回值、异常或动作序列。这使我们能够测试各种场景和边缘情况。模拟可以记录交互，使我们能够验证方法是否以正确的参数、正确的顺序和预期的频率被调用。通过用模拟替换真实依赖项，我们可以创建一个受控的环境，防止意外的副作用，并确保测试的可靠性。
- en: 'Let’s go over the benefits of using mocks:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用模拟的好处：
- en: '**Improved test focus**: Mocks help you concentrate on the logic of the code
    being tested, without being distracted by the intricacies of external components.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高测试焦点**：模拟帮助你集中精力测试代码的逻辑，而不会被外部组件的复杂性所分散。'
- en: '**Faster test execution**: Since mocks don’t involve real interactions (such
    as database calls or network requests), tests run significantly faster'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的测试执行**：由于模拟不涉及真实交互（如数据库调用或网络请求），测试运行速度显著提高'
- en: '**Increased test coverage**: Mocks allow you to test different scenarios and
    edge cases that might be difficult or impossible to reproduce in a real environment.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加测试覆盖率**：模拟允许你测试可能难以或在真实环境中无法复制的不同场景和边缘情况。'
- en: '**Enhanced code reliability**: By thoroughly testing code in isolation, you
    can identify and fix potential issues early in the development process.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强代码可靠性**：通过在隔离状态下彻底测试代码，你可以在开发早期阶段识别并修复潜在的问题。'
- en: Next, we’ll look at stubs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨存根。
- en: Stubs
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存根
- en: On the other hand, a **stub** is a simplified implementation of a component
    that’s used to replace a real component in a test. It provides canned answers
    to calls that are made during the test, focusing on the specific behavior needed
    for the test case.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**存根**是组件的简化实现，用于在测试中替换真实组件。它为测试期间发出的调用提供预制的答案，专注于测试用例所需的特定行为。
- en: A stub only contains the essential logic required for the test and returns predetermined
    values or exceptions. It typically doesn’t verify interactions or expectations.
    That is great, but when can you use them?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 存根只包含测试所需的必要逻辑，并返回预定的值或异常。它通常不验证交互或期望。这很好，但你在什么情况下可以使用它们？
- en: When you need to isolate the unit under test by providing controlled responses.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要通过提供受控的响应来隔离被测试的单元时。
- en: When the behavior of the dependency isn’t critical to the test case.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当依赖项的行为对测试用例不是关键时。
- en: When you want to speed up test execution by avoiding complex logic.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要通过避免复杂逻辑来加快测试执行速度时。
- en: While both stubs and mocks are used to replace real components in tests, there’s
    a key difference. Stubs focus on providing predefined responses and don’t verify
    interactions, whereas mocks allow for more complex behavior, including expectations
    and verifying interactions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存根和模拟都用于在测试中替换真实组件，但它们之间存在一个关键区别。存根专注于提供预定义的响应，并不验证交互，而模拟允许更复杂的行为，包括期望和验证交互。
- en: In many cases, stubs can be sufficient for basic testing, but as test requirements
    become more complex, mocks offer greater flexibility and control.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，存根（stub）可以满足基本的测试需求，但随着测试要求的日益复杂，模拟（mock）提供了更大的灵活性和控制力。
- en: Spies
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间谍
- en: A **spy** is a wrapper around an existing object or function that records information
    about how it’s used. Unlike stubs and mocks, which replace the original object,
    spies observe the behavior of the real object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**间谍**是围绕现有对象或函数的包装器，它记录有关其使用情况的信息。与存根和模拟不同，它们替换原始对象，间谍观察真实对象的行為。'
- en: 'Here are some of the key characteristics of spies:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是间谍的一些关键特性：
- en: '**Wrap real object**: Spies can be created around existing objects or functions.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装真实对象**：间谍可以围绕现有对象或函数创建。'
- en: '**Record interactions**: They track method calls, arguments, and return values.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录交互**：它们跟踪方法调用、参数和返回值。'
- en: '**Verify behavior**: Spies are used to ensure that methods are called correctly
    and with the expected parameters.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证行为**：间谍用于确保方法被正确调用，并且使用预期的参数。'
- en: 'You can use spies in the following instances:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下情况下使用间谍：
- en: When you want to verify that a specific method is called with certain arguments.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想验证特定方法是否以某些参数被调用时。
- en: When you need to check the sequence of method calls.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要检查方法调用的顺序时。
- en: When you want to observe the side effects of a function without controlling
    its behavior.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想观察函数的副作用而不控制其行为时。
- en: While both spies and mocks can verify interactions, there’s a key difference
    – spies observe the behavior of the real object, whereas mocks replace the real
    object with a simulated one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然间谍和模拟都可以验证交互，但有一个关键的区别——间谍观察真实对象的行為，而模拟用模拟对象替换真实对象。
- en: Additionally, stubs provide canned responses without verifying interactions.
    Mocks replace objects and allow for complex behavior and verification. On the
    other hand, spies observe the behavior of real objects without modifying them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，存根提供预定义的响应，而不验证交互。模拟替换对象，允许复杂的行為和验证。另一方面，间谍观察真实对象的行為而不对其进行修改。
- en: Understanding and implementing integration tests
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现集成测试
- en: '**Integration tests** are an important component of a robust testing strategy
    and focus on the interactions between different parts of your application. Unlike
    unit tests, which isolate individual components, integration tests evaluate how
    these components work together as a cohesive system.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**是稳健测试策略的重要组成部分，关注应用程序不同部分之间的交互。与隔离单个组件的单元测试不同，集成测试评估这些组件作为一个整体系统如何协同工作。'
- en: In the context of Express.js, integration tests ensure that routes, controllers,
    models, and databases interact seamlessly. They verify that data flows correctly
    between these components and that the application produces the expected outcomes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express.js 的上下文中，集成测试确保路由、控制器、模型和数据库无缝交互。它们验证数据在这些组件之间正确流动，并且应用程序产生预期的结果。
- en: Why are integration tests essential? They help prevent integration issues, which
    can often be complex and time-consuming to debug. By testing the interactions
    between components, you can catch potential problems early in the development
    cycle, reducing the risk of unexpected behavior in production.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么集成测试是必需的？它们有助于防止集成问题，这些问题通常很复杂且难以调试。通过测试组件之间的交互，你可以在开发周期早期捕捉到潜在的问题，从而降低生产中出现意外行为的风险。
- en: Integration tests aren’t a replacement for unit tests. Unit tests focus on the
    correctness of individual functions and modules, while integration tests verify
    how these components work together. A comprehensive testing strategy should include
    both unit and integration tests.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试不是单元测试的替代品。单元测试关注单个函数和模块的正确性，而集成测试验证这些组件如何协同工作。全面的测试策略应包括单元和集成测试。
- en: By investing time in writing effective integration tests, you can significantly
    improve the quality and reliability of your Express.js applications. They help
    prevent integration issues, increase confidence in your code base, and ultimately
    deliver a better user experience.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过投入时间编写有效的集成测试，你可以显著提高你的 Express.js 应用程序的质量和可靠性。它们有助于防止集成问题，增加对你代码库的信心，并最终提供更好的用户体验。
- en: Integration testing in Node.js microservices focuses on verifying the interactions
    between different components or services. It ensures that these components work
    together seamlessly to deliver the expected outcomes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 微服务的集成测试专注于验证不同组件或服务之间的交互。它确保这些组件无缝协同工作以产生预期的结果。
- en: Integration tests catch issues early in development, reducing production failures.
    By writing comprehensive integration tests, you encourage better code design and
    maintainability. Successful integration tests build confidence in the system’s
    overall reliability.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以在开发早期捕捉到问题，减少生产故障。通过编写全面的集成测试，您可以鼓励更好的代码设计和可维护性。成功的集成测试增强了系统整体可靠性的信心。
- en: 'Before we move on, let’s understand the key aspects of integration testing
    in microservices:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们了解微服务集成测试的关键方面：
- en: '**Testing boundaries**: Integration tests primarily focus on the interfaces
    between microservices. They verify data exchange, contract adherence, and error
    handling.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试边界**：集成测试主要关注微服务之间的接口。它们验证数据交换、合同遵守和错误处理。'
- en: '**Dependency management**: Effectively managing dependencies is essential.
    You might use mocking, stubbing, or test doubles to isolate components for testing.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖管理**：有效管理依赖是至关重要的。您可能需要使用模拟、存根或测试替身来隔离组件以进行测试。'
- en: '**Data consistency**: Integration tests should validate data integrity across
    different services. This includes testing data transformations, consistency checks,
    and error handling.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：集成测试应验证不同服务之间的数据完整性。这包括测试数据转换、一致性检查和错误处理。'
- en: '**Performance considerations**: Integration tests can help identify performance
    bottlenecks and scalability issues.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能考虑**：集成测试可以帮助识别性能瓶颈和可扩展性问题。'
- en: 'Having said this, it’s also important to understand exactly when you’d use
    integration testing. Let’s look at the instances when you would use this here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，了解何时使用集成测试也同样重要。让我们看看您会在这里使用集成测试的实例：
- en: '**API interactions**: Test how different microservices communicate through
    APIs, verifying request/response formats, error handling, and authentication.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API交互**：测试不同的微服务如何通过API进行通信，验证请求/响应格式、错误处理和身份验证。'
- en: '**Database interactions**: Ensure data is stored, retrieved, and updated correctly
    across multiple services.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库交互**：确保数据在多个服务中正确存储、检索和更新。'
- en: '**Message queues**: Verify message delivery, processing, and error handling
    in asynchronous communication patterns.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息队列**：验证异步通信模式中的消息投递、处理和错误处理。'
- en: '**External systems**: Test interactions with external systems such as payment
    gateways, email services, or third-party APIs.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部系统**：测试与外部系统（如支付网关、电子邮件服务或第三方API）的交互。'
- en: Long story short, integration tests in Node.js microservices verify that different
    components or services interact correctly, ensuring seamless functionality and
    preventing complex issues in production. Now, let’s implement integration tests
    for the transaction microservice.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Node.js微服务中的集成测试验证了不同的组件或服务是否正确交互，确保了无缝的功能，并防止了生产中的复杂问题。现在，让我们为事务微服务实现集成测试。
- en: The purpose of this subsection is to show you how you can implement integration
    tests for your Node.js services, particularly for Nest.js. The general idea of
    integration testing applies to all types of applications, regardless of whether
    you use Express.js or other frameworks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的目的在于向您展示如何为您的Node.js服务实现集成测试，特别是对于Nest.js。集成测试的一般思想适用于所有类型的应用程序，无论您是否使用Express.js或其他框架。
- en: 'As always, we need to install the required package to write integration tests
    for our project. Go to `Ch12/transactionservice` and run the following command
    to install the `jest` and `supertest` packages:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要安装所需的包来为我们的项目编写集成测试。转到`Ch12/transactionservice`并运行以下命令来安装`jest`和`supertest`包：
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve already talked about the `jest` package. The `supertest` package is a
    high-level abstraction for testing HTTP servers. It makes it easy to send HTTP
    requests to your Nest.js application and inspect the responses, simulating real-world
    client behavior.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`jest`包。`supertest`包是一个用于测试HTTP服务器的高级抽象。它使得向您的Nest.js应用程序发送HTTP请求并检查响应变得容易，从而模拟现实世界的客户端行为。
- en: Nest.js provides excellent integration with both Jest and Supertest, making
    it straightforward to set up and run integration tests. You can test various aspects
    of your Nest.js application, including controllers, services, and database interactions.
    Integration tests can be included in your CI/CD pipeline so that you can catch
    issues early in the development process.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Nest.js 与 Jest 和 Supertest 都有出色的集成，使得设置和运行集成测试变得简单。你可以测试 Nest.js 应用程序的各个方面，包括控制器、服务和数据库交互。集成测试可以包含在
    CI/CD 管道中，以便在开发早期阶段捕捉到问题。
- en: 'Go to the root folder (`Ch12/transactionservice`) and create the `jest.config.js`
    file with the following content:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 进入根文件夹（`Ch12/transactionservice`）并创建一个名为 `jest.config.js` 的文件，内容如下：
- en: '[PRE18]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s break down the code here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里分解一下代码：
- en: The `jest.config.js` file is a configuration file that customizes Jest’s behavior.
    This particular configuration specifies that Jest should look for TypeScript,
    JavaScript, and JSON files (`moduleFileExtensions`). It sets the project root
    directory to `src`, defines test files as those ending with `.spec.ts`, and uses
    `ts-jest` to process TypeScript files. The configuration also enables code coverage
    reporting to `../coverage`, sets the test environment to Node.js, and executes
    `global-setup.js` before all tests and `global-teardown.js` after.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.config.js` 文件是一个自定义 Jest 行为的配置文件。这个特定的配置指定了 Jest 应该查找 TypeScript、JavaScript
    和 JSON 文件（`moduleFileExtensions`）。它将项目根目录设置为 `src`，定义测试文件为以 `.spec.ts` 结尾的文件，并使用
    `ts-jest` 处理 TypeScript 文件。配置还启用了代码覆盖率报告到 `../coverage`，将测试环境设置为 Node.js，并在所有测试之前执行
    `global-setup.js`，在所有测试之后执行 `global-teardown.js`。'
- en: Next, we have `globalSetup` and `globalTeardown` in our Jest configuration to
    execute code before and after the entire test suite runs, respectively.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们在 Jest 配置中有了 `globalSetup` 和 `globalTeardown`，分别用于在整个测试套件运行之前和之后执行代码。
- en: Then, `globalSetup` runs once before all tests. It’s ideal for setting up resources
    such as databases, servers, or other external dependencies that are required for
    the tests.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`globalSetup` 在所有测试之前运行一次。它非常适合设置测试所需的数据库、服务器或其他外部依赖资源。
- en: Finally, `globalTeardown` runs once after all tests have been completed. It’s
    used to clean up resources that are created in `globalSetup`, such as closing
    database connections or stopping servers.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`globalTeardown` 在所有测试完成后运行一次。它用于清理在 `globalSetup` 中创建的资源，例如关闭数据库连接或停止服务器。
- en: In the provided configuration, the scripts for these operations are located
    in the `./test/global-setup.js` and `./test/global-teardown.js` files. However,
    we don’t have these files yet. So, let’s create them. Go to the `test` folder
    and create both files.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的配置中，这些操作的脚本位于 `./test/global-setup.js` 和 `./test/global-teardown.js` 文件中。然而，我们还没有这些文件。所以，让我们创建它们。进入
    `test` 文件夹并创建这两个文件。
- en: 'Here’s our `global-setup` file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 `global-setup` 文件：
- en: '[PRE19]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This global setup script initiates a Docker Compose environment for testing.
    It starts by logging a message, and then executes the `docker-compose up --build
    -d` command using the specified `docker-compose.tests.yml` file. Finally, it introduces
    a fifteen second delay to allow services sufficient time to start before test
    execution begins.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局设置脚本初始化一个用于测试的 Docker Compose 环境。它首先记录一条消息，然后使用指定的 `docker-compose.tests.yml`
    文件执行 `docker-compose up --build -d` 命令。最后，它引入了十五秒的延迟，以便在测试执行开始之前给服务足够的时间启动。
- en: 'Here’s the `global-teardown` file:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `global-teardown` 文件：
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `global-teardown` script terminates the Docker Compose environment. It
    logs a message indicating the process and then executes the `docker-compose down`
    command using the specified `docker-compose.tests.yml` file to stop all running
    containers and remove networks.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `global-teardown` 脚本终止 Docker Compose 环境。它记录一条消息指示过程，然后使用指定的 `docker-compose.tests.yml`
    文件执行 `docker-compose down` 命令，以停止所有正在运行的容器并删除网络。
- en: We run all dependent services from the Docker file, hence why we have a special
    file called `docker-compose.tests.yml` under `Ch12/transactionservice`. Check
    out this book’s GitHub repository for the source code for the `docker-compose.tests.yml`
    file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Docker 文件中运行所有依赖服务，这就是为什么在 `Ch12/transactionservice` 下有一个名为 `docker-compose.tests.yml`
    的特殊文件。查看这本书的 GitHub 仓库以获取 `docker-compose.tests.yml` 文件的源代码。
- en: This Docker Compose file defines a multi-container environment for a microservices
    application. It includes services for a PostgreSQL database, `PgAdmin` for database
    management, MongoDB, Zookeeper, Kafka, and a Kafka UI. The file also defines an
    account service built from a local `Dockerfile` file, configuring its dependencies
    on MongoDB and Kafka. Environment variables, ports, volumes, and network configurations
    are specified for each service. Here, `app-network` is used for internal communication
    between containers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Docker Compose文件定义了一个用于微服务应用的多个容器环境。它包括用于PostgreSQL数据库的服务、用于数据库管理的`PgAdmin`、MongoDB、Zookeeper、Kafka以及一个Kafka
    UI。文件还定义了一个由本地`Dockerfile`文件构建的账户服务，并配置了其对MongoDB和Kafka的依赖。每个服务都指定了环境变量、端口、卷和网络配置。在这里，`app-network`用于容器之间的内部通信。
- en: When writing integration tests for Nest.js applications, we often create a test
    configuration file. This configuration file specifies configuration values that
    are necessary for the test environment, such as database connections, API keys,
    or other sensitive information. You can set up in-memory or temporary databases
    for testing purposes to isolate test data and prevent conflicts with production
    data. It also helps us to configure mocking libraries or frameworks so that we
    can replace real external services with test doubles, improving test isolation
    and performance. We mostly define configuration options for testing frameworks
    or libraries, such as Jest or Supertest, to customize their behavior for integration
    tests. By centralizing test-specific configurations in a separate file, you enhance
    code organization, maintainability, and reusability. It also helps to prevent
    sensitive information from being accidentally committed to the main code base.
    Check out the `Ch12/transactionservice/test-configuration.ts` file for more content.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当为Nest.js应用编写集成测试时，我们通常会创建一个测试配置文件。这个配置文件指定了测试环境所需的配置值，例如数据库连接、API密钥或其他敏感信息。你可以为测试目的设置内存或临时数据库，以隔离测试数据并防止与生产数据冲突。这也有助于我们配置模拟库或框架，以便我们可以用测试替身替换真实的外部服务，提高测试隔离性和性能。我们主要定义测试框架或库（如Jest或Supertest）的配置选项，以自定义其集成测试的行为。通过在单独的文件中集中测试特定的配置，你可以增强代码组织、可维护性和可重用性。这也有助于防止敏感信息意外提交到主代码库。查看`Ch12/transactionservice/test-configuration.ts`文件以获取更多内容。
- en: Our test configuration file sets up a Nest.js testing module for integration
    tests. It imports the necessary modules for database connection (`TypeOrm`), microservices
    (`ClientsModule`), and the target module (`TransactionModule`). It also configures
    a PostgreSQL database using environment variables or default values and establishes
    a Kafka client. Finally, the `testConfiguration` function compiles the testing
    module and returns it for use in integration tests.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试配置文件为集成测试设置了一个Nest.js测试模块。它导入数据库连接（`TypeOrm`）、微服务（`ClientsModule`）和目标模块（`TransactionModule`）所需的必要模块。它还使用环境变量或默认值配置了一个PostgreSQL数据库，并建立了一个Kafka客户端。最后，`testConfiguration`函数编译测试模块，并将其返回以供集成测试使用。
- en: 'If you haven’t installed it yet, don’t forget to run the following command
    to make sure your test configuration will run properly:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装它，别忘了运行以下命令以确保你的测试配置可以正常运行：
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `@nestjs/typeorm` is a package that seamlessly integrates `TypeORM`, a
    popular **object-relational mapper** (**ORM**), with the Nest.js framework. It
    provides a convenient way to interact with relational databases such as PostgreSQL,
    MySQL, SQLite, and others within your Nest.js application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@nestjs/typeorm`是一个包，它无缝地将流行的**对象关系映射器**（**ORM**）`TypeORM`与Nest.js框架集成。它提供了一个方便的方式来在Nest.js应用中与关系型数据库（如PostgreSQL、MySQL、SQLite等）交互。
- en: You must define your database tables as TypeScript classes (*entities*). Here,
    `TypeORM` handles the mapping between your code and the database schema. It supports
    features such as repositories, migrations, transactions, and more, making database
    operations efficient and reliable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将你的数据库表定义为TypeScript类（*实体*）。在这里，`TypeORM`处理你的代码与数据库模式之间的映射。它支持诸如仓库、迁移、事务等功能，使数据库操作高效且可靠。
- en: 'Now, it’s time to write our simple integration test for the transaction microservice.
    The `transaction.controller.spec.ts` file can be found under `Ch12/transactionservice/src/test`
    and contains the following content:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为事务微服务编写我们的简单集成测试了。`transaction.controller.spec.ts`文件位于`Ch12/transactionservice/src/test`下，并包含以下内容：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This test imports the necessary modules for testing and HTTP requests. The `beforeAll`
    hook sets up the test environment by creating a Nest.js application using the
    `testConfiguration` function, while the `afterAll` hook cleans up by closing the
    application. The test case focuses on creating a transaction. It constructs a
    transaction DTO with sample data and sends a `POST` request to the `/transaction`
    endpoint. The expected response status is `400` (*Bad Request*), indicating an
    error in the request. A timeout of `10000` milliseconds (`10` seconds) is set
    for the test. This test case verifies the basic functionality of the transaction
    creation endpoint and provides a foundation for further testing scenarios.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'To run your tests, simply execute the `npm run test` command. Make sure Docker
    is running before executing any integration tests:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Docker services](img/B09148_12_3.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Docker services'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'When running integration tests with a Dockerized account microservice, the
    primary challenge is ensuring a consistent data state for each test. This involves
    doing the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Data preparation**: Creating necessary accounts or records before each test.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data cleanup**: Removing test data after each test to prevent data pollution.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database isolation**: Ensuring test data doesn’t interfere with other tests
    or environments.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle these challenges, we can use multiple solutions:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`typeorm` and `sequelize` to create migration scripts for your account database:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalSetup` or `beforeEach` hooks to populate the database with test data.'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globalTeardown` or `afterEach` hooks to clean up the database.'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker volumes**: Define a Docker volume for your account microservice’s
    database:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mount the volume**: Mount the volume to the container to persist data between
    test runs.'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Truncate or delete data**: Before each test, truncate or delete the database’s
    content to ensure a clean state.'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test containers**: For complex scenarios, use a dedicated container for test
    data preparation and cleanup:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestrate with Docker Compose**: Use Docker Compose to manage the relationship
    between the test container and the account microservice.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In-memory databases**: For simpler scenarios, use in-memory databases such
    as SQLite for testing:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benefits**: Faster startup, isolation, and no need for data migration.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we’ve come to the end of this chapter! Let’s recap what we learned.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the critical role of testing in microservice
    architecture. Building upon our previous exploration of microservice creation,
    we emphasized the importance of rigorous testing for ensuring code quality and
    reliability. We introduced the concepts of unit and integration testing, explaining
    their distinct purposes and benefits.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: To solidify our understanding, we implemented unit tests for both the account
    and transaction microservices. These tests verified the correct behavior of individual
    code units in isolation. Additionally, we explored the nuances of mocks, stubs,
    and spies, demonstrating their utility in isolating components during testing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们的理解，我们对账户和交易微服务都实现了单元测试。这些测试验证了单个代码单元在隔离状态下的正确行为。此外，我们还探讨了模拟、存根和间谍的细微差别，展示了它们在测试期间隔离组件的实用性。
- en: To assess the interactions between different microservices, we introduced integration
    testing. By combining unit tests with integration tests, we established a robust
    testing strategy for our microservices.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估不同微服务之间的交互，我们引入了集成测试。通过将单元测试与集成测试相结合，我们为我们的微服务建立了一个稳健的测试策略。
- en: In the next chapter, we will dive into the practical implementation of CI/CD
    pipelines. We will explore how to utilize GitHub Actions to automate workflows
    and streamline the deployment of our microservices, particularly focusing on deploying
    to Azure Cloud. You’ll learn how to build a fully automated pipeline that ensures
    your applications are consistently ready for deployment with minimal manual intervention.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 CI/CD 管道的实际实施。我们将探讨如何利用 GitHub Actions 自动化工作流程并简化微服务的部署，特别是关注部署到
    Azure 云。你将学习如何构建一个完全自动化的管道，确保你的应用程序在部署时始终保持一致，并且需要最少的手动干预。
