- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I will demonstrate how Node.js applications can use a relational
    database to store and query data. This chapter explains how to work directly with
    a database by executing SQL queries, and how to take a more hands-off approach
    with an **Object Relational Mapping** (**ORM**) package. *Table 12.1* puts this
    chapter into context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.1: Putting databases into context'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Question** | **Answer** |'
  prefs: []
  type: TYPE_TB
- en: '| What are they? | Databases are the most common means of persistently storing
    data. |'
  prefs: []
  type: TYPE_TB
- en: '| Why are they useful? | Databases can store large volumes of data and enforce
    a data structure that makes it possible to perform efficient queries. |'
  prefs: []
  type: TYPE_TB
- en: '| How are they used? | Databases are managed by database engines, which can
    be installed as npm packages, run on dedicated servers, or consumed as cloud services.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any pitfalls or limitations? | Databases can be complex and require
    additional knowledge, such as being able to formulate queries in SQL. |'
  prefs: []
  type: TYPE_TB
- en: '| Are there any alternatives? | Databases are not the only way to store data,
    but they are the most common, and, generally, the most effective because they
    are robust and scale up easily. |'
  prefs: []
  type: TYPE_TB
- en: '*Table 12.2* summarizes what we will do in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.2: Chapter summary'
  prefs: []
  type: TYPE_NORMAL
- en: '| Problem | Solution | Listing |'
  prefs: []
  type: TYPE_TB
- en: '| Store data persistently. | Use a database. | *7, 8, 12, 13* |'
  prefs: []
  type: TYPE_TB
- en: '| Simplify the process of changing how data is stored. | Use a repository layer.
    | *9–11* |'
  prefs: []
  type: TYPE_TB
- en: '| Display stored data. | Include query results when rendering templates. |
    *14, 15* |'
  prefs: []
  type: TYPE_TB
- en: '| Prevent user-submitted values from being interpreted as SQL. | Use query
    parameters. | *16, 17* |'
  prefs: []
  type: TYPE_TB
- en: '| Ensure that data is updated consistently. | Use a transaction. | *18–21*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Use a database without needing to write SQL queries. | Use an ORM package
    and describe the data used by the application using JavaScript code. | *22–25,
    27, 28* |'
  prefs: []
  type: TYPE_TB
- en: '| Perform operations that are too complex to describe using model classes.
    | Use the ORM package facility for executing SQL. | *26* |'
  prefs: []
  type: TYPE_TB
- en: '| Query for and update data using an ORM. | Use the methods defined by the
    model classes, with constraints specified using JavaScript objects. | *29–32*
    |'
  prefs: []
  type: TYPE_TB
- en: Preparing for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the `part2app` project from *Chapter 11*. To prepare for this
    chapter, *Listing 12.1* removes the client-side validation code, which won’t be
    used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.1: The contents of the client.js file in the src/client folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12.2* updates the routing configuration for the example application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.2: The contents of the server.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The new routing configuration removes entries that are no longer required.
    All the examples in this chapter use templates, and the new route matches requests
    for the default path and responds with a redirection to the `/form` URL. The new
    route uses Express support for matching URL patterns, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The pattern is required to match requests for `http://localhost:5000` and not
    requests that are handled by other routes, such as `http://localhost:5000/css/bootstrap.min.css`
    (which is handled by the static content middleware) or `http://localhost:5000/bundle.js`
    (which is forwarded to the webpack development HTTP server).
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12.3* updates the `age` template to add a field that allows the user
    to specify a number of years, just to allow more variations in the results data.
    The structure of the HTML output has been changed to introduce a two-column layout
    and use a partial template named `history`. This listing also removes the validation
    error elements, which is something that should not be done in a real project,
    but they are not needed in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.3: The contents of the age.handlebars file in the templates/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To create the partial view, add a file named `history.handlebars` to the `templates/server/partials`
    folder with the content shown in *Listing 12.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.4: The contents of the history.handlebars folder in the templates/server/partials
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The partial template displays data provided through a `history` context property
    and displays a default message when no data is available. *Listing 12.5* revises
    the code that handles the `/form` URL to remove the validation checks introduced
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.5: The contents of the forms.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the command shown in *Listing 12.6* in the `part2app` folder to start the
    development tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.6: Starting the development tools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, fill out the form, and click
    the **Submit** button, as shown in *Figure 12.1*. No data will be displayed in
    the **Recent Queries** section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Running the example application'
  prefs: []
  type: TYPE_NORMAL
- en: Using a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases allow web applications to read and write data, which can be used to
    generate responses for HTTP requests. There are many types of database, with choices
    about how data is stored and queried, how the database software is deployed, and
    how changes to data are handled.
  prefs: []
  type: TYPE_NORMAL
- en: The database market is competitive and innovative, and there are excellent commercial
    and open-source products, but my advice is that the best database is one that
    you already understand and have worked with before. Most projects can use most
    databases, and the benefit that a particular database technology confers will
    be undermined by the time taken to learn and master that technology.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have a database, it is easy to get lost in the endless options,
    and my advice is to start with something as simple as possible. For small applications,
    I recommend SQLite, which is the database I will use in this chapter. For larger
    applications, especially where multiple instances of Node.js are used to handle
    HTTP requests, I recommend one of the excellent open-source relational databases,
    such as MySQL ([https://www.mysql.com](https://www.mysql.com)) or PostgreSQL ([https://www.postgresql.org](https://www.postgresql.org)).
    You can see an example of one such database in *Part 3* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t like using the **Structured Query Language** (**SQL**), then there
    are good NoSQL databases available and a good place to start is MongoDB ([https://www.mongodb.com](https://www.mongodb.com)).
  prefs: []
  type: TYPE_NORMAL
- en: '**Database Complaints**'
  prefs: []
  type: TYPE_NORMAL
- en: I receive complaints whenever I write about choosing database products. Many
    developers have strong views about the superiority of a particular database or
    style of database and are upset when I don’t recommend their preferred product.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t that I think any particular database engine is bad. In fact, the database
    market has never been so good, to the extent that just about any database product
    can be used in just about any project with little impact on productivity or scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database engines are like automobiles: modern cars are so good that most people
    can get along with just about any car. If you already have a car, then the benefit
    of changing it is likely to be small when compared to the cost. If you don’t have
    a car, then a good place to start is with the car that most of your neighbors
    have and the local mechanics often work on. Some people get really into cars and
    have strong views about a particular make or model, and that’s fine, but it can
    be taken to excess, and most people don’t drive in a way where marginal improvements
    become significant.'
  prefs: []
  type: TYPE_NORMAL
- en: So, I absolutely understand why some developers become deeply invested in a
    particular database engine – and I respect that level of commitment and understanding
    – but most projects don’t have the kinds of data storage or processing requirements
    that make the differences between database products important.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the database package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database engine used in this chapter is SQLite. It operates within the Node.js
    process and is a good choice for applications where data doesn’t need to be shared
    between multiple instances of Node.js, which SQLite doesn’t support because it
    doesn’t run as a separate server. SQLite is widely used and is, at least according
    to [https://sqlite.org](https://sqlite.org), the most popular database engine
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Run the command shown in *Listing 12.7* in the `part2app` folder to add SQLite
    to the project. No additional TypeScript type packages are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.7: Adding the database package to the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This package includes the database engine, a Node.js API, and descriptions of
    those APIs for the TypeScript compiler. To describe the database that will be
    used in this section, add a file named `age.sql` to the `part2app` folder with
    the content shown in *Listing 12.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.8: The contents of the age.sql file in the part2app folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The SQL statements in *Listing 12.8* create three tables, which will record
    the age calculations performed by the application. The `Calculations` table keeps
    track of the age calculations that have been performed and has columns for the
    age and year values provided by the user and the future age that has been calculated.
    The `People` table keeps track of the names that users provide. The `Results`
    table keeps track of results by referencing a name and a calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The data the application works with doesn’t justify three tables, but simple
    data combined with multiple tables allows some common problems to be more easily
    demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A repository is a layer of code that isolates the database from the rest of
    the application, which makes it easier to change the way that data is read and
    written without needing to change the code that uses that data. Not everyone finds
    a repository layer useful, but my advice is to use one unless you are completely
    certain that your application’s use of data or database products won’t change.
    Create the `src/server/data` folder and add to it a file named `repository.ts`
    with the contents shown in *Listing 12.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.9: The contents of the repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Repository` interface defines methods for storing new `Result` objects,
    querying for all results, and results that have a specific name. The `Result`
    type defines properties for all of the data columns in the database tables in
    a simple, flat structure.
  prefs: []
  type: TYPE_NORMAL
- en: Projects can use data types that match the structure of the database, but that
    often means that the data that arrives from the user has to be assembled into
    a complex structure before being extracted and used to create an SQL statement,
    while the reverse process assembles data from the database into the same structure,
    only for it to be extracted for use in templates. It isn’t always possible, but
    using simple, flat data structures often simplifies development.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to implement the `Repository` interface with a class that uses
    the SQLite database engine. I am going to implement the repository in stages,
    which will make it easier to understand the relationship between the data in the
    database and the JavaScript objects in the application. To start the implementation,
    create a file named `sql_repository.ts` file in the `src/server/data` folder with
    the content shown in *Listing 12.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.10: The contents of the sql_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `SqlRepository` class implements the `Repository` interface, and its constructor
    prepares the database. The `sqlite3` module contains the database API and creates
    a new `Database` object, specifying `age.db` as the filename. The `Database` object
    provides methods for using the database and the `exec` method is used to execute
    SQL statements – in this case, to execute the statements in the `age.sql` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Real projects don’t need to execute SQL to create the database every time, but
    doing so allows the example to be reset, and it is for this reason that the SQL
    in *Listing 12.8* will drop and recreate the database tables if they already exist.
    Databases are usually initialized only when an application is deployed, and you
    can see an example of this in *Part 3* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: To make the repository available to the rest of the application, add a file
    named `index.ts` to the `src/server/data` folder with the content shown in *Listing
    12.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.11: The contents of the index.ts file in the src/server/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This file is responsible for instantiating the repository so that the rest of
    the application can access data through the `Repository` interface without needing
    to know which implementation has been used.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to implement the methods that provide access to the database,
    starting with those that query for data. Add a file named `sql_queries.ts` to
    the `src/server/data` folder, with the content shown in *Listing 12.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.12: The contents of the sql_queries.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL queries can be formulated like any other JavaScript string, and my preference
    is to avoid duplication by defining a base query and then building on it to create
    the variations needed. In this case, I have defined `baseSql` and `endSql` strings,
    which are combined to create queries, so that the query for data matching a name
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These queries use named parameters, which are denoted by a `$` sign and allow
    values to be provided when the query is executed. As I explain in the *Understanding
    SQL query parameters* section, this is a feature that should always be used and
    is supported by every database package.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am not a professional database administrator, and there are more efficient
    ways to compose queries, but using a database is easier when the queries return
    data that can be easily parsed to create JavaScript objects. In this case, the
    queries will return tables of data like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `id` | `calculationId` | `personId` | `name` | `age` | `years` | `nextage`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1` | `Alice` | `35` | `5` | `40` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `2` | `1` | `Alice` | `35` | `10` | `45` |'
  prefs: []
  type: TYPE_TB
- en: 'The SQLite package will convert the table of data into an array of JavaScript
    objects whose properties correspond to the table column names, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The structure of the data received from the database is a superset of the `Result`
    interface defined in *Listing 12.9*, which means that data received from the database
    can be used without needing further processing. *Listing 12.13* uses the SQL defined
    in *Listing 12.12* to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.13: Querying the database in the sql_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Database` object created in the constructor provides methods for querying
    the database. The `executeQuery` method uses the `Database.all` method, which
    executes a SQL query and returns all the rows that the database produces. For
    quick reference, *Table 12.3* describes the most useful methods provided by the
    `Database` class. Most of these methods accept values for query parameters, which
    I explain in the *Understanding SQL query parameters* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.3: Useful Database Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| This method executes a SQL statement with an optional set of parameters.
    No result data is returned. The optional callback function is invoked if there
    is an error or when execution is complete. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| This method executes a SQL statement with an optional set of parameters and
    passes the first result row as an object to the callback function, with type `T`.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| This method executes a SQL statement with an optional set of parameters and
    passes all result rows to the callback function as an array of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This method creates a prepared statement, which is represented with a `Statement`
    object, and can improve performance because the database doesn’t have to process
    SQL every time the query is executed. This method does not accept query parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: Displaying data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Listing 12.14* updates the code that handles HTTP requests to create an instance
    of the SQL repository and uses the methods it provides to query the database and
    pass the results to the template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.14: Using the repository in the forms.ts file in the src/server
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `async` keyword is applied to the handler functions, which allows the use
    of the `await` keyword when calling the repository methods. The results are passed
    to the template using a property named `history`, which is used to populate the
    table in *Listing 12.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.15: Populating the table in the history.handlebars file in the templates/server/partials
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000/form` and you will see that
    the right-hand side shows data from all users. Fill out and submit the form and
    only queries from that user will be displayed, as shown in *Figure 12.2*. The
    queries in the database from other users are no longer shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Querying the database'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SQL query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Care must be taken when including values received from users in SQL queries.
    As a demonstration, *Listing 12.16* alters the implementation of the `getResultsByName`
    defined by the `SQLRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.16: Including user input in the sql_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The mistake being made in this example is to include the value received from
    the form directly in the query. If the user enters `Alice` into the form, then
    the query will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the anticipated behavior, and it retrieves the queries made using that
    name. But it is easy to craft strings that alter the query. If the user enters
    `Alice" or name = "Bob`, for example, then the query will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t what the developer expects, and it means that queries made by two
    users are displayed, as shown in *Figure 12.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Executing a query with user input'
  prefs: []
  type: TYPE_NORMAL
- en: This is a benign example, but it shows that including user-supplied values directly
    in queries allows malicious users to change how queries are processed. This problem
    isn’t addressed by the HTML sanitization described in *Chapter 11* because the
    values are not sanitized until they are included in a response. Instead, databases
    provide support for *query parameters*, which allow values to be inserted into
    queries safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter is defined in the SQL query and is denoted with an initial `$`
    character, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement is combined with the base query, which means that the overall
    SQL statement looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The two query parameters are marked in bold, and they indicate values that
    will be supplied when the statement is executed by the `executeQuery` method in
    the `SqlRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12.17* reverts the changes to the `SqlRepository` class so that the
    query performed by the `getResultsByName` method uses the `executeQuery` method
    and provides query parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.17: Using query parameters in the sql_repository.ts file in the
    src/server/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The object that contains the parameter values has property names that match
    the parameters in the SQL statement: `$name` and `$limit`. The `$` sign isn’t
    the only way to denote a query parameter in SQL, but it works well with JavaScript
    because the `$` sign is allowed in variable names. It is for this reason that
    the `getResultsByName` method defines `$name` and `$limit` parameters, allowing
    the values to be passed along without needing to alter the names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is provided by the code that handles the form
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The value the user entered for the name field in the form is read from the body
    and used as the value for the `$name` query parameter. The methods described in
    *Table 12.3* automatically sanitize query parameters, so they do not alter the
    way the query is executed, as shown in *Figure 12.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: The effect of a sanitized query parameter'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to write data so that the database contains more than just
    the seed data added when the database is created. *Listing 12.18* defines SQL
    statements that will insert rows into the database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.18: Adding statements in the sql_queries.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `insertPerson` and `insertCalculation` statements will insert new rows in
    the `People` and `Calculation` tables only if there are no existing rows that
    have the same details. The `insertResult` statement creates a row in the `Results`
    table, with references to the other tables.
  prefs: []
  type: TYPE_NORMAL
- en: These statements need to be executed within a transaction to ensure consistency.
    The SQLite database engine supports transactions, but these are not exposed conveniently
    to Node.js and additional work is required to run SQL statements in a transaction.
    Add a file named `sql_helpers.ts` to the `src/server/data` folder with the content
    shown in *Listing 12.19*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.19: The contents of the sql_helpers.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `TransactionHelper` class defines an `add` method that is used to build
    up a list of SQL statements and query parameters. When the `run` method is called,
    the `BEGIN` command is sent to SQLite, and each of the SQL statements is run.
    If all the statements execute successfully, the `COMMIT` command is sent, and
    SQLite applies the changes to the database. The `ROLLBACK` command is sent if
    any of the statements fail and SQLite abandons the changes made by earlier statements.
    SQLite provides the ID of the row modified by `INSERT` statements, and the `run`
    method returns the value produced by the most recent statement. Knowing the ID
    of the most recently inserted row is generally a good idea because it makes it
    easy to query for new data, as *Chapter 14* will demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 12.20* uses the `TransactionHelper` class to perform an update by
    running the three statements from *Listing 12.18* within a SQL transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.20: Inserting data in the sql_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `saveResult` method executes the three SQL statements.
    Each statement requires a separate object for its query parameters because SQLite
    produces an error if there are unused properties in the parameters object. *Listing
    12.21* updates the handler for HTTP POST requests to write data to the database
    through the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.21: Writing data in the forms.ts file in the src/server folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using consistent names for each part of the application means that the request
    body can be used as the basis for the `Result` interface expected by the repository.
    The effect is that each new request is stored in the database and reflected in
    the response presented to the user, as shown in *Figure 12.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Writing data to the database'
  prefs: []
  type: TYPE_NORMAL
- en: Using an ORM package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of working directly with the database is that you have control
    over how every statement is written and executed. The drawback is that can be
    a complex and time-consuming process.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use an ORM package that deals with the database on behalf
    of the developer, hiding some aspects of SQL and taking care of mapping between
    the database and JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: The range of features provided by ORM packages varies widely. Some take a light-touch
    approach and focus on transforming data, but most packages deal with most aspects
    of using a database, including defining the SQL schema, creating the database,
    and even generating queries.
  prefs: []
  type: TYPE_NORMAL
- en: ORM packages can be great, but you still have to have a basic understanding
    of SQL, which is why I started this chapter with a direct-to-database example.
    ORM packages expect the developer to understand how their features will be used
    to create and use databases, and you won’t be able to get useful results or diagnose
    problems without some SQL skills.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Argument for Object Databases**'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using SQL and an ORM package is to use a database that stores
    objects directly, such as MongoDB ([https://www.mongodb.com](https://www.mongodb.com)).
    The reason that I have not covered object databases in this book is that most
    projects use relational databases, and most companies standardize on a specific
    relational database engine. Object databases can be a good choice, but they are
    not the technology that most developers end up using. SQL databases remain dominant,
    even though there are some excellent alternatives available.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM package that I use in this chapter is called Sequelize ([https://www.npmjs.com/package/sequelize](https://www.npmjs.com/package/sequelize)),
    which is the most popular JavaScript ORM package. Sequelize has a comprehensive
    set of features and supports the most popular database engines, including SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Run the command shown in *Listing 12.22* in the `part2app` folder to install
    the Sequelize package, which includes TypeScript type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.22: Installing the ORM packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Defining the database using JavaScript objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working directly with a database, the first step is to write the SQL statements
    that create the tables and the relationships between them, which is how this chapter
    started. When using an ORM, the database is described using JavaScript objects.
    Each ORM package has its own process and, for Sequelize, three steps are required.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to define the classes that will represent the data in the
    database. Add a file named `orm_models.ts` to the `src/server/data` folder, with
    the content shown in *Listing 12.23*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.23: The contents of the orm_models.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize will use each class to create a database table and each property will
    be a column in that table. These classes also describe the data in the database
    to the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: All the class properties in *Listing 12.23* are defined with the `declare` keyword,
    which tells the TypeScript compiler to behave as though the properties have been
    defined but not to include those properties in the compiled JavaScript. This is
    important because Sequelize will add getters and setters to objects to provide
    access to data, and defining properties conventionally will prevent that feature
    from working properly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The names of the model classes should be meaningful. I have chosen `Person`
    and `Calculation`, which are obvious enough, but I have used `ResultModel` to
    avoid conflicting with the name of the type used by the `Repository` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class properties whose type is a regular JavaScript type will be represented
    by regular columns in the database, such as the `name` property defined by the
    `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreationOptional<T>` type is used to describe a property that doesn’t
    have to be supplied when a new instance of the model class is created, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `id` property represents the primary key for a `Person` object when it is
    stored as a row in a database table. The database will be configured to automatically
    assign a key when a new row is stored, and so using the `CreationOptional<number>`
    type will prevent TypeScript from reporting an error when a `Person` object is
    created without an `id` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class is used to build a list of the properties defined by the class,
    which are used to enforce type safety when data is read or written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InferAttributes<Person>` type selects all of the properties defined by
    the `Person` class, while the `InferCreationAttributes<Person>` type excludes
    the properties whose type is `CreationOptional<T>`. The model classes also contain
    properties for representing relationships between tables in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `personId` and `calculationId` properties will store the primary keys of
    related data, while the `Person` and `Calculation` properties will be populated
    with objects created by Sequelize, as part of the process of making data available
    as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the data model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to tell Sequelize how each property defined by the model classes
    should be represented in the database. Add a file named `orm_helpers.ts` to the
    `src/server/data` folder, with the content shown in *Listing 12.24*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.24: The contents of the orm_helpers.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Model` base class used in *Listing 12.24* defines the `init` method, which
    accepts an object whose properties correspond to those defined by the class. Each
    property is assigned a configuration object that tells Sequelize how to represent
    the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: All three model classes have an `id` property that is configured as the primary
    key. For the other properties, a value from the `DataTypes` class is selected
    to specify the SQL data type that will be used when the database is created.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument accepted by the `init` method is used to configure the overall
    data model. Only the `sequelize` property is specified in *Listing 12.24*, which
    is a `Sequelize` object that will be created to manage the database. Other options
    are available, allowing the name of the database table to be changed, setting
    up database triggers, and configuring other database features.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the model relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Model` base class provides methods to describe the relationships between
    model classes, as shown in *Listing 12.25*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.25: Defining model relationships in the orm_helpers.ts file in the
    src/server/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize defines four kinds of *association*, which are used to describe the
    relationship between data model classes, as described in *Table 12.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.4: The Sequelize association methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| This method denotes a one-to-one relationship between the model class and
    `T`, with the foreign key defined on `T`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '| This method denotes a one-to-one relationship between the model class and
    `T`, with the foreign key defined by the model class. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| This method denotes a one-to-many relationship, with the foreign key defined
    by `T`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '| This method denotes a many-to-many relationship using a junction table. |'
  prefs: []
  type: TYPE_TB
- en: Each of the methods defined in *Table 12.4* accepts an options argument that
    is used to configure the relationship. In *Listing 12.25*, the `foreignKey` property
    is used to specify the foreign key on the `ResultModel` class for the one-to-one
    relationships with the `Person` and `Calculation` types. (There are other options,
    described at [https://sequelize.org/api/v6/identifiers.html#associations](https://sequelize.org/api/v6/identifiers.html#associations),
    and you can see a more complex example in *Chapter 15*, which uses a many-to-many
    relationship.)
  prefs: []
  type: TYPE_NORMAL
- en: Defining the seed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although ORM packages take care of a lot of the details, there can be tasks
    that are more easily performed simply by executing SQL expressions directly, rather
    than using JavaScript objects. To demonstrate, *Listing 12.26* uses SQL to seed
    the database. (Later chapters show seeding databases using JavaScript objects
    so you can compare techniques.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.26: Adding seed data in the orm_helpers.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Sequelize.query` method accepts a string containing an SQL statement. The
    statements in *Listing 12.26* create the same seed data used earlier in the chapter
    but with the addition of values for `createdAt` and `updatedAt` columns. One consequence
    of using an ORM package to create a database is that additional features and constraints
    are often introduced and Sequelize adds these columns to keep track of when table
    rows are created and modified. The queries that create the seed data use the `date()`
    function, which returns the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data models to flat objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using JavaScript objects to represent data can be a more natural development
    experience, but it can mean that the data model objects are not in the format
    expected elsewhere in the application. In the case of the example application,
    the ORM data model objects do not conform to the requirements of the `Result`
    type used by the `Repository` interface. One approach would be to modify the interface,
    but this would undermine the benefit of isolating the database from the rest of
    the application. *Listing 12.27* defines a function that transforms `ResultModel`
    objects provided by the ORM package into `Result` objects required by the `Repository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.27: Transforming data in the orm_helpers.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This kind of transformation can seem clunky, but JavaScript makes it easy to
    compose new objects in this way, and it is a useful technique that eases integration
    between modules and packages, which is something that most JavaScript projects
    have to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The plumbing is all in place and it is time to implement the `Repository` interface.
    Add a file named `orm_repository.ts` to the `src/server/data` folder with the
    content shown in *Listing 12.28*, which sets up the ORM but doesn’t yet implement
    queries or store data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.28: The contents of the orm_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Sequelize supports a range of database engines, including SQLite, and so the
    first step is to create a `Sequelize` object, providing a configuration object
    that specifies the database engine, and the options for its use. In *Listing 12.28*,
    the `dialect` option specifies SQLite and the `storage` option specifies the name
    of the file. When using an ORM, it can be useful to see the SQL queries that are
    generated, which is why the `logging` and `logQueryParameters` options are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a `Sequelize` object has been created, it can be configured. The `initModelAndDatabase`
    method calls the `initializeModels` and `defineRelationships` functions to configure
    the data model objects, and then calls these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `drop` method tells Sequelize to drop the tables in the database. This isn’t
    something that should be done in a real project, but it recreates the earlier
    examples in this chapter. The `sync` method tells Sequelize to synchronize the
    database with the data model objects, which has the effect of creating tables
    for the `ResultModel`, `Person`, and `Calculation` data. Once the tables have
    been created, the `addSeedData` function is called to add the initial data to
    the database. Some of these operations are asynchronous, which is why they are
    performed with the `await` keyword inside an `async` method.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queries in an ORM are made using an API that returns objects, without any direct
    interaction with the SQL that is sent to the database. ORM packages have different
    philosophies about how queries are expressed. With Sequelize, queries are performed
    using the data model classes, with methods that are inherited from the `Model`
    base class, the most useful of which are described in *Table 12.5*. (The full
    set of **Model** features can be found at [https://sequelize.org/api/v6/class/src/model.js~model](https://sequelize.org/api/v6/class/src/model.js~model).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.5: Useful Model methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| This method finds all matching records and presents them as model objects.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '| This method finds the first matching record and presents it as a model object.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| This method finds the record with a specified primary key. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| This method finds a matching record or creates one if there is no match.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| This method creates a new record. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '| This method updates data in the database. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '| This method updates a single row of data or creates a row if there is no
    match. |'
  prefs: []
  type: TYPE_TB
- en: The methods in *Table 12.5* are configured with a configuration object that
    changes the way the query or update is executed. The most useful configuration
    properties are described in *Table 12.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12.6: Useful query configuration properties'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '| This property loads data from related tables by following foreign keys. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '| This property is used to narrow a query, which is passed to the database
    using the SQL `WHERE` keyword. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '| This property configures the query order, which is passed to the database
    using the SQL `ORDER BY` keywords. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '| This property specifies query grouping, which is passed to the database using
    the SQL `GROUP BY` keywords. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '| This property specifies the number of records required, which is passed to
    the database using the SQL `LIMIT` keyword. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| This property performs the query within the specified transaction, as demonstrated
    in the *Writing data* section. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '| This property restricts results, so they include only the specified attributes/columns.
    |'
  prefs: []
  type: TYPE_TB
- en: '*Listing 12.29* shows a basic Sequelize query that implements the `getAllResults`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.29: Performing a Query in the orm_repository.ts File in the src/server/data
    Folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `findAll` method is called on the `ResultModel` class and is configured
    with an object that has `include`, `limit`, and `order` properties. The most important
    property is `include`, which tells Sequelize to follow foreign key relationships
    to load related data and create objects from the results. In this case, the result
    will be a `ResultModel` object whose `Person` and `Calculation` properties are
    populated. The `limit` property restricts the number of results, and the `order`
    property is used to specify how results are ordered.
  prefs: []
  type: TYPE_NORMAL
- en: The query is performed asynchronously, and the result is a `Promise` that yields
    an array of `ResultModel` objects, which are mapped to the `Result` objects required
    by the `Repository` interface using the `fromOrmModel` function defined in *Listing
    12.27*.
  prefs: []
  type: TYPE_NORMAL
- en: The `where` configuration property can be used to select specific data, as demonstrated
    in *Listing 12.30*, which implements the `getResultsByName` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.30: Searching for data in the orm_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is the same query used in *Listing 12.29* but with the addition of the
    `where` property, which tells Sequelize to follow the foreign key relationship
    and match `Person` objects using the `name` property. The syntax for the `where`
    property can take some getting used to, but you will see additional examples in
    later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Listing 12.31* completes the repository by implementing the `saveResult` method,
    which only stores `Person` and `Calculation` objects if there isn’t already matching
    data in the database and performs all of its changes using a transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.31: Writing data in the orm_repository.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `transaction` is created with the `Sequelize.transaction` method, which
    accepts a callback function that receives a `Transaction` object. The `transaction`
    property is used to enroll each operation in the transaction, which will be committed
    or rolled back automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Within the transaction, the `findOrCreate` method is used to see if there are
    `Person` and `Calculation` objects in the database that match the data received
    by the `saveResult` method. The result is the existing object, if there is one,
    or the newly created object if there is no match.
  prefs: []
  type: TYPE_NORMAL
- en: A new `ResultModel` object must be stored for every request, and this is done
    using the `create` method. The values for the `personId` and `calculationId` properties
    are set using the results from the `findOrCreate` method and the write operation
    is enrolled in the transaction. No value is required for the `id` property, which
    will be assigned by the database when the new data is stored, and which is contained
    in the result of the `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `create` method allows objects to be created and stored in a single step.
    An alternative is to use the `build` method, which creates a model object that
    isn’t stored until the `save` method is called, which allows changes to be made
    before data is written to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The benefit of using a repository is that the details of how data is stored
    can be changed without affecting the parts of the application that use that data.
    To complete the transition to the ORM package, *Listing 12.32* replaces the existing
    repository with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 12.32: Using the ORM repository in the index.ts file in the src/server/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: No other changes are required because the repository isolates data management
    from the templates and request handling code. Use a browser to request `http://localhost:5000`
    and you will see the seed data. Fill out and submit the form and you will see
    the response shown in *Figure 12.6*, showing that data has been stored in the
    database. If you examine the Node.js console output, you will see the SQL queries
    that `Sequelize` is formulating from the operations performed on the data model
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_12_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Using an ORM package'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I explained how a JavaScript web application can use a database,
    both directly using SQL and indirectly using an ORM package.
  prefs: []
  type: TYPE_NORMAL
- en: Databases are the most common choice for persistent data storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js can be used with popular database engines, for which there is a wide
    range of open-source packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases can be used directly or through packages that express data as objects
    and generate queries automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic knowledge of how databases work and the ability to understand the core
    SQL syntax makes it easier to work with databases, even when an ORM package is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, I will describe how related HTTP requests can be identified
    to create sessions.
  prefs: []
  type: TYPE_NORMAL
