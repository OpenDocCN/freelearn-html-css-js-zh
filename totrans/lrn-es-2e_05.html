<html><head></head><body>
        

                            
                    <h1 class="header-title">Modular Programming</h1>
                
            
            
                
<p class="mce-root">Modular programming is one of the most important and frequently used software design techniques. Modular programming basically means splitting your code into multiple files that are usually independent of each other. This makes it a cake-walk when managing and maintaining different modules of a program. It helps in debugging nasty bugs easily, pushing updates to a particular module, and so on.</p>
<p class="mce-root">Unfortunately, for a long time, JavaScript didn't support modules natively; that led programmers to use alternative techniques to achieve modular programming in JavaScript. However, ES6 introduced a native modular technique in JavaScript for the first time.</p>
<p class="mce-root">This chapter is all about how to create and import JavaScript modules. In this chapter, we will first learn how modules were created earlier, and then we will jump to the new built-in JavaScript module system.</p>
<p class="mce-root">In this chapter, we'll cover:</p>
<ul>
<li class="mce-root">What is modular programming?</li>
<li class="mce-root">The benefits of modular programming</li>
<li class="mce-root">The basics of IIFE modules, AMD, UMD, and CommonJS</li>
<li class="mce-root">Creating and importing ES6 modules</li>
<li>Implementing modules in browsers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">JavaScript modules 101</h1>
                
            
            
                
<p>The practice of breaking down programs and libraries into modules is called modular programming.</p>
<p>In JavaScript, a <strong>module</strong> is a collection of related objects, functions, and other components of a program or library that are wrapped together and isolated from the scope of the rest of the program or library.</p>
<p>A module exports some variables to the outside program to let it access the components wrapped by the module. To use a module, a program needs to import the module and the variables exported by the module.</p>
<p>A module can also be split into further modules called sub-modules, thus creating a module hierarchy.</p>
<p>Modular programming has many benefits. Some benefits are as follows:</p>
<ul>
<li>It keeps our code both cleanly separated and organized by splitting it into multiple modules</li>
<li>Modular programming leads to fewer global variables, that is, it eliminates the problem of global variables, because modules don't interface via the global scope, and each module has its own scope</li>
<li>It makes code reusability easier as importing and using the same modules in different projects is easier</li>
<li>It allows many programmers to collaborate on the same program or library, by making each programmer work on a particular module with a particular functionality</li>
<li>Bugs in an application can easily be easily identified as they are localized to a particular module</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing modules – the old way</h1>
                
            
            
                
<p>Before ES6, JavaScript had never supported modules natively. Developers used other techniques and third-party libraries to implement modules in JavaScript. Using <strong>Immediately-Invoked Function Expression</strong> (<strong>IIFE</strong>), <strong>Asynchronous Module Definition</strong> (<strong>AMD</strong>), CommonJS, and <strong>Universal Module Definition</strong> (<strong>UMD</strong>) are various popular ways of implementing modules in ES5. As these ways were not native to JavaScript, they had several problems. Let's take an overview of each of these old ways of implementing modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Immediately-Invoked Function Expression (IIFE)</h1>
                
            
            
                
<p>We've briefly discussed IIFE functions in earlier chapters. It is basically an anonymous function that is executed automatically. Let's take a look at one example. This is how a typical old JS module that uses IIFE looks:</p>
<pre>//Module Starts <br/><br/>(function(window){ <br/>const sum =(x, y) =&gt; x + y;<br/>const sub = (x,y) =&gt; x - y;<br/>const math = { <br/>  findSum(a, b) { return sum(a, b) }, <br/>  findSub(a,b) { return sub(a, b) }<br/>} <br/>window.math = math; <br/>})(window) <br/><br/>//Module Ends <br/><br/>console.log(math.findSum(1, 2)); //Output "3" <br/>console.log(math.findSub(1, 2)); //Output "-1"</pre>
<p>Here, we created a module using IIFE. The <kbd>sum</kbd> and <kbd>sub</kbd> variables are global to the module, but not visible outside the module. The <kbd>math</kbd> variable is exported by the module to the main program to expose the functionalities that it provides.</p>
<p>This module works completely independently of the program and can be imported by any other program by simply copying it into the source code, or importing it as a separate file (by including it as script src, or by using external libraries).</p>
<p>The reason it'll work is that ultimately you're attaching the <kbd>math</kbd> object to the window (which is global). </p>
<p>A library using IIFE, such as jQuery, wraps all of its APIs in a single IIFE module. When a program uses a jQuery library, it automatically imports the module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous Module Definition (AMD)</h1>
                
            
            
                
<p>AMD is a specification for implementing modules in the browser. AMD is designed by keeping browser limitations in mind, that is, it imports modules asynchronously to prevent blocking the loading of a webpage. As AMD is not a native browser specification, we need to use an AMD library.</p>
<p>RequireJS is the most popular AMD library. Let's see an example of how to create and import modules using RequireJS. According to the AMD specification, every module needs to be represented by a separate file. So first, create a file named <kbd>math.js</kbd> that represents a module. Here is the sample code that will be inside the module:</p>
<pre>define(function(){ <br/>  const sum = (x, y) =&gt; x + y<br/>  const sub = (x, y) =&gt; x - y<br/>  const math = { <br/>    findSum(a, b) { return sum(a,b) }, <br/>    findSub(a, b){ return sub(a, b); } <br/>  } <br/>  return math; <br/>});</pre>
<p>Here, the module exports the <kbd>math</kbd> variable to expose its functionality.</p>
<p>Now, let's create a file named <kbd>index.js</kbd>,  to act as the main program that imports the module and exported variables. Here is the code that will be inside the <kbd>index.js</kbd> file:</p>
<pre>require(["math"], function(math){ <br/>  console.log(math.findSum(1, 2)); //Output "3" <br/>  console.log(math.findSub(1, 2)); //Output "-1" <br/>}) </pre>
<p>Here, the <kbd>math</kbd> variable in the first parameter is the name of the file that is treated as the AMD module. The <kbd>.js</kbd> extension added to the file name is added automatically by RequireJS.</p>
<p>The <kbd>math</kbd> variable, which is in the second parameter, references the exported variable. Here, the module is imported asynchronously, and the callback is also executed asynchronously.</p>
<p>You can learn more about RequireJS and its usage here: <a href="http://bit.ly/requirejs-tutorials">http://bit.ly/requirejs-tutorials</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">CommonJS</h1>
                
            
            
                
<p>CommonJS is the most widely used, unofficial spec right now. CommonJS is a specification for implementing modules in Node.js. According to the CommonJS specification, every module needs to be represented by a separate file. CommonJS modules are imported <strong>synchronously</strong>. This is the reason why browsers do not use CommonJS as a module loader!</p>
<p>Let's see an example of how to create and import modules using CommonJS. First, we will create a file named <kbd>math.js</kbd> that represents a module. Here is sample code that will be inside the module:</p>
<pre>const sum =(x, y) =&gt; x + y;<br/>const sub = (x, y) =&gt; x - y;<br/>const math = { <br/>  findSum(a, b) { <br/>    return sum(a,b); <br/>  }, <br/>  findSub(a, b){ <br/>    return sub(a, b); <br/>  } <br/>} <br/><br/>exports.math = math; // or module.exports.math = math</pre>
<p>Here, the module exports the <kbd>math</kbd> variable to expose its functionality. Now, let's create a file named <kbd>index.js</kbd>,  to act as the main program that imports the module.</p>
<p>Here is the code that will be inside the <kbd>index.js</kbd> file:</p>
<pre>const math = require("./math").math; <br/>console.log(math.findSum(1, 2)); //Output "3" <br/>console.log(math.findSub(1, 2)); //Output "-1" </pre>
<p>Here, the <kbd>math</kbd> variable is the name of the file that is treated as a module. The <kbd>.js</kbd> extension to the file name is added automatically by CommonJS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">exports versus module.exports</h1>
                
            
            
                
<p>Previously, we said that you can use <kbd>exports.math</kbd> or <kbd>module.exports.math</kbd> in order to export a variable from the module. What's the difference between two?</p>
<p>Well, technically, exports and <kbd>module.exports</kbd> point to the same object. You can think about this in the following manner:</p>
<pre>exports = module.exports = { }</pre>
<p>This is how it starts. Now it doesn't matter whether you assign a property value to <kbd>module.exports</kbd> or exports because they both point to the same object. However, you must remember that it is <strong><kbd>module.exports</kbd> </strong>that is actually exported!</p>
<p>For example, consider <kbd>string1.js</kbd>, <kbd>string2.js</kbd>, and <kbd>index.js</kbd>.</p>
<p><kbd>string1.js</kbd> is shown as follows:</p>
<pre>// string1.js<br/>module.exports = () =&gt; "Amazing string" // correct export of function</pre>
<p><kbd>string2.js</kbd> is shown as follows:</p>
<pre>// string2.js<br/>exports = () =&gt; "Amazing string" // this fails to export this function</pre>
<p><kbd>index.js</kbd> is shown as follows:</p>
<pre>// index.js<br/>console.log(require('string1.js')()); // &lt;-- we're executing the imported function<br/>console.log(require('string2.js')());</pre>
<p>What do you think the output is?</p>
<p>Clearly, as we said previously, <kbd>exports</kbd> is not exported. Thus, the second call (<kbd>require('string2.js')()</kbd>) throws an error because <kbd>require('string2.js')</kbd> returns an empty object (thus you cannot execute it as a function).</p>
<p>On the other hand, when <kbd>module.exports</kbd> is changed from an object to a function, the function is exported and then invoked by the developer in the first line call <kbd>(string1.js)</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Universal Module Definition (UMD)</h1>
                
            
            
                
<p>We saw three different specifications for implementing modules. These three specifications have their own respective ways of creating and importing modules. Wouldn't it be great if we could create modules that were imported as an IIFE, AMD, or CommonJS module?</p>
<p>UMD is a set of techniques that are used to create modules that can be imported as an IIFE, CommonJS, or AMD module. Therefore, now a program can import third-party modules, irrespective of what module specification it is using.</p>
<p>The most popular UMD technique is <kbd>returnExports</kbd>. According to the <kbd>returnExports</kbd> technique, every module needs to be represented by a separate file. So, let's create a file named <kbd>math.js</kbd> that represents a module. Here is the sample code that will be inside the module:</p>
<pre>(function (root, factory) { <br/>  //Environment Detection <br/>  if (typeof define === 'function' &amp;&amp; define.amd) { <br/>    define([], factory); <br/>  } else if (typeof exports === 'object') { <br/>    module.exports = factory(); <br/>  } else { <br/>    root.returnExports = factory(); <br/>  } <br/>}(this, function () { <br/>//Module Definition <br/>  const sum = (x, y) =&gt; x + y;<br/>  const sub = (x, y) =&gt; x - y;<br/>  const math = { <br/>    findSum(a, b) { <br/>        return sum(a,b); <br/>    }, <br/>    findSub(a, b) { <br/>        return sub(a, b); <br/>    } <br/>  } <br/>return math; <br/>})<br/>);</pre>
<p>Now, you can successfully import the <kbd>math.js</kbd> module any way that you wish, for instance, by using CommonJS, RequireJS, or IIFE.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing modules – the new way</h1>
                
            
            
                
<p>There is a new way to import and export modules in JavaScript, that is the official module system. Since it is supported natively by the language, it can be referred to as the standard JavaScript module system. You should consider using the official module system in practice because it's native and thus optimized for speed and performance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Importing/exporting modules</h1>
                
            
            
                
<p>Let's say you're coding a module file and now you're ready to import it into your main file. How will you export it using the official module system? Here's how:</p>
<pre>// module.js<br/><br/>const takeSquareAndAdd2 = num =&gt; {<br/>    return num*num + 2;<br/>}<br/><br/>export { takeSquareAndAdd2 }; // #1<br/>export const someVariable = 100; // #2<br/>export function yourName(name) {<br/>    return `Your name ${name} is a nice name` <br/>}; // #3<br/>export default "Holy moly this is interesting!" // #4</pre>
<ul>
<li><kbd>#1</kbd>: We've first coded a function and then, using the <kbd>export</kbd> keyword, made it available to other modules that import this particular module.</li>
<li><kbd>#2</kbd>: You can directly declare, initialize, and export variables/functions in a single line.</li>
<li><kbd>#3</kbd>: As <kbd>#2</kbd> says, you can directly export the functions as you create them.</li>
<li><kbd>#4</kbd>: The previous three are called named exports, whereas this is a default export. We'll soon see the difference between the two.</li>
</ul>
<p>Let's see how to import this previous module in a separate file:</p>
<pre>// index.js<br/>import myString, { takeSquareAndAdd2 } from './module.js'<br/>console.log(myString) // "Holy moly this is interesting"<br/>console.log(takeSquareAndAdd2(2)) // 6</pre>
<p>Wait. What happened here? Let's study.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Named versus default exports</h1>
                
            
            
                
<p>Earlier, we saw that we used the export default: <em>Holy moly this is interesting</em>. What it does is, when we use <kbd>import &lt;varname&gt; from './module'</kbd>, it assigns <kbd>&lt;varname&gt;</kbd> the value of the default export. Therefore, see the following:</p>
<pre>// index.js<br/>import string from './module.js'<br/>console.log(string)</pre>
<p>This will console-log <em>Holy moly this is interesting</em>.</p>
<p>This is called a default export.</p>
<p>A named export, on the other hand, has a name associated with it (the variable's name or the function's name). You'll have to import a named-export variable using destructuring syntax. This is because you can think of the <kbd>export</kbd><strong> </strong>keyword as exporting a default value <em>plus</em> an object that contains all other exports you're doing (named exports).</p>
<p>Therefore, see the following:</p>
<pre>import { takeSquareAndAdd2 } from './module.js';<br/>console.log(takeSquareAndAdd2(3))</pre>
<p>This will output <kbd>11</kbd>.</p>
<p>You cannot use <kbd>var</kbd>/<kbd>let</kbd>/<kbd>const</kbd> when doing an export default; just do <kbd>export default &lt;YOUR VALUE HERE&gt;</kbd>. However, you <strong>can</strong> do <kbd>export default</kbd> followed by a function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Naming named imports</h1>
                
            
            
                
<p>You can also change the name of a named export in the module to which you're importing it. This is achieved by using the <kbd>as</kbd> keyword:</p>
<pre>import { takeSquareAndAdd2 as myFunc } from './module.js';<br/>console.log(myFunc(3))</pre>
<p>This will still produce the output <kbd>11</kbd>. This is essential when you have long module names or names that might conflict with your base code/other imported modules.</p>
<p>Similarly, you can rename some named imports, and leave the rest as it is:</p>
<pre>import { takeSquareAndAdd2 as myFunc, yourName } from './module.js';<br/>console.log(myFunc(3)) // 11<br/>console.log(yourName("Mehul")) // Your name Mehul is a nice name</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Wildcard imports</h1>
                
            
            
                
<p>What if you want to import all the exported entities in the whole module? Writing each entity's name yourself is cumbersome; also, if you do that, you'll pollute the global scope. Let's see how we can fix both of these issues.</p>
<p>Let's assume our <kbd>module.js</kbd> looks something like this:</p>
<pre>// module.js<br/>export const PI = 3.14<br/>export const sqrt3 = 1.73<br/>export function returnWhatYouSay(text) { return text; }</pre>
<p>Let's import everything at once:</p>
<pre>// index.js<br/>import * as myModule from './module.js'<br/>console.log(myModule.PI) // 3.14<br/>console.log(myModule.returnWhatYouSay("This is cool!"))</pre>
<p>The asterisk (<kbd>*</kbd>) will import everything that is exported under the scope of the <kbd>myModule</kbd> object. It makes accessing all exported variables/methods cleaner.</p>
<p>Let's quickly gather all the information about the import/export syntax in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional information on export</h1>
                
            
            
                
<p class="mce-root">We need to use the export statement in a module to export variables. The export statement comes in many different formats. Here are the formats:</p>
<ul>
<li><kbd>export {variableName}</kbd> - This format exports a variable</li>
<li><kbd>export {variableName1, variableName2, variableName3}</kbd> - This format is used to export multiple variables</li>
<li><kbd>export {variableName as myVariableName}</kbd> - This format is used to export a variable with another name, that is, an alias</li>
<li><kbd>export {variableName1 as myVariableName1, variableName2 as myVariableName2}</kbd> - This format is used to export multiple variables with different names</li>
<li><kbd>export {variableName as default}</kbd> - This format uses default as the alias</li>
<li><kbd>export {variableName as default, variableName1 as myVariableName1, variableName2}</kbd> - This format is similar to the fourth format, but it also has the default alias</li>
<li><kbd>export default function(){}</kbd> - This format works similarly to the fifth format, but here you can place an expression instead of a variable name</li>
<li><kbd>export {variableName1, variableName2} from "myAnotherModule"</kbd> - This format is used to export the exported variables of a submodule</li>
<li><kbd>export * from "myAnotherModule"</kbd> - This format is used to export all the exported variables of a submodule</li>
</ul>
<p>Here are some important things that you need to know about the export statement:</p>
<ul>
<li>An export statement can be used anywhere in a module. It's not compulsory to use it at the end of the module.</li>
<li>There can be any number of export statements in a module.</li>
<li>You cannot export variables on demand. For example, placing the export statement in the <kbd>if</kbd>...<kbd>else</kbd> condition throws an error. Therefore, we can say that the module structure needs to be static, that is, exports can be determined at compile time.</li>
<li>You cannot export the same variable name or alias multiple times. But you can export a variable multiple times with a different alias.</li>
<li>All the code inside a module is executed in strict mode by default.</li>
<li>The values of the exported variables can be changed inside the module that exported them.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional information on import</h1>
                
            
            
                
<p>To <kbd>import</kbd> a module, we need to use the <kbd>import</kbd> statement. The <kbd>import</kbd> statement comes in many different formats. Here are the formats:</p>
<pre>import x from "module-relative-path"; <br/>import {x} from "module-relative-path"; <br/>import {x1 as x2} from "module-relative-path"; <br/>import {x1, x2} from "module-relative-path"; <br/>import {x1, x2 as x3} from "module-relative-path"; <br/>import x, {x1, x2} from "module-relative-path"; <br/>import "module-relative-path"; <br/>import * as x from "module-relative-path"; <br/>import x1, * as x2 from "module-relative-path";</pre>
<p>An <kbd>import</kbd> statement consists of two parts: the variable names we want to <kbd>import</kbd> and the <kbd>relative</kbd> path of the module.</p>
<p>Here are the differences in these formats:</p>
<ul>
<li><kbd>import x from "module-relative-path"</kbd> - In this format, the default alias is imported. <kbd>x</kbd> is the alias of the default alias.</li>
<li><kbd>import {x} from "module-relative-path"</kbd> - In this format, the <kbd>x</kbd> variable is imported.</li>
<li><kbd>import {x1 as x2} from "module-relative-path"</kbd> - This format is the same as the second format. It's just that <kbd>x2</kbd> is an alias of <kbd>x1</kbd>.</li>
<li><kbd>import {x1, x2} from "module-relative-path"</kbd> - In this format, we import the <kbd>x1</kbd> and <kbd>x2</kbd> variables.</li>
<li><kbd>import {x1, x2 as x3} from "module-relative-path"</kbd> - In this format, we import the <kbd>x1</kbd> and <kbd>x2</kbd> variables. The <kbd>x3</kbd> is an alias of the <kbd>x2</kbd> variable.</li>
<li><kbd>import x, {x1, x2} from "module-relative-path"</kbd> - In this format, we import the <kbd>x1</kbd> and <kbd>x2</kbd> variable, and the default alias. The <kbd>x</kbd> is an alias of the default alias.</li>
<li><kbd>import "module-relative-path"</kbd> - In this format, we just <kbd>import</kbd> the module. We do not <kbd>import</kbd> any of the variables exported by the module.</li>
<li><kbd>import * as x from "module-relative-path"</kbd> - In this format, we <kbd>import</kbd> all the variables and wrap them in an object called <kbd>x</kbd>. Even the default alias is imported.</li>
<li><kbd>import x1, * as x2 from "module-relative-path"</kbd> - The ninth format is the same as the eighth format. Here, we give another alias to the default alias.</li>
</ul>
<p>Here are some important things that you need to know about the import statement:</p>
<ul>
<li>While importing a variable, if we import it with an alias, then to refer to that variable we have to use the alias and not the actual variable name; that is, the actual variable name will not be visible, only the alias will be visible.</li>
<li>The import statement doesn't import a copy of the exported variables; rather, it makes the variables available in the scope of the program that imports it. Therefore, if you make a change to an exported variable inside the module, then the change is visible to the program that imports it.</li>
<li>Imported variables are read-only, that is, you cannot reassign them to something else outside the scope of the module that exports them.</li>
<li>A module can only be imported once in a single instance of a JavaScript engine. If we try to import it again, then the already imported instance of the module will be used. (In other words, modules are singletons in JavaScript.)</li>
<li>We cannot import modules on demand. For example, placing the import statement in the <kbd>if</kbd>…<kbd>else</kbd> condition throws an error. Therefore, we can say that imports should be able to be determined at compile time.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Tree shaking</h1>
                
            
            
                
<p>Tree shaking is basically a term used by module bundlers such as WebPack and Rollup to convey that the import-export module syntax can be used for dead-code elimination.</p>
<p>Essentially, the new module loader system enables these module bundlers to do something known as tree shaking, where they shake the tree to get rid of the dead leaves.</p>
<p>Your JavaScript is a tree. The modules you import represent the living leaves of your tree. The dead (unused) code is represented by the brown, dead leaves of the tree. To remove dead leaves, the bundler has to shake the tree and let them fall. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How tree shaking is performed</h1>
                
            
            
                
<p>Tree shaking, used by a module bundler, eliminates unused code in the following manner:</p>
<ol>
<li>Firstly, the bundler will combine all of the imported module files (like a good bundler). Here, exports that are not imported in any file are not exported at all.</li>
<li>
<p>After that, the bundler minifies the bundle and simultaneously removes dead code. Thus, variables/functions that are not exported or used inside their respective module files are not present in the compressed bundle file. This way, tree shaking is performed.</p>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Using modules on the web</h1>
                
            
            
                
<p>Modern browsers have very recently started to implement module loaders natively. To natively use a script that imports modules, you'll have to make its <kbd>type="module"</kbd>.</p>
<p>Here's a very basic working example in Chrome 63:</p>
<pre>// index.html<br/>&lt;!doctype HTML&gt;<br/>&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;script src="img/index.js" type="module"&gt;&lt;/script&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;div id="text"&gt;&lt;/div&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;<br/><br/></pre>
<p>This is how <kbd>index.js</kbd> (the main script file) will look:</p>
<pre>// index.js<br/>import { writeText2Div as write2Div } from './module.js';<br/>write2Div('Hello world!')</pre>
<p>This is the module that <kbd>index.js</kbd> imports (in the same directory):</p>
<pre>// module.js<br/>const writeText2Div = text =&gt; document.getElementByID('text').innerText = text;<br/>export { writeText2Div };</pre>
<p>This, when tested, should show <kbd>Hello World</kbd> on the screen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we saw what modular programming is and learned different modular programming specifications. We learned about the future of modular programming and how to use it in web browsers for real projects. With the evolution of ECMAScript, we expect to see a further boost in features and performance, which will ultimately benefit both the end user and the developers.</p>
<p>In the next chapter, we're going to take a look at something known as the <strong>Reflect API</strong>,  a shining new collection of methods for interceptable JavaScript operations.</p>


            

            
        
    </body></html>