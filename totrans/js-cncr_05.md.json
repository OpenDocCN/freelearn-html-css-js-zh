["```js\n// Loads the worker script, and starts the\n// worker thread.\nvar worker = new Worker('worker.js');\n```", "```js\n// Imports the lodash library, making the global \"_\"\n// variable available in the worker context.\nimportScripts('lodash.min.js');\n\n// We can use the library within the worker now.\nconsole.log('in worker', _.at([ 1, 2, 3], 0, 2));\n// → in worker [1, 3]\n```", "```js\n// Launches the worker thread.\nvar worker = new Worker('worker.js');\n\n// Posts a message to the worker, triggering\n// any \"message\" event handlers.\nworker.postMessage('hello world');\n```", "```js\n// Setup an event listener for any \"message\"\n// events dispatched to this worker.\naddEventListener('message', (e) => {\n\n    // The posted data is accessible through\n    // the \"data\" property of the event.\n    console.log(e.type, `\"${e.data}\"`);\n    // → message \"hello world\"\n});\n```", "```js\n// Simply display the content of any\n// messages received.\naddEventListener('message', (e) => {\n    console.log('message', e.data);\n});\n```", "```js\n// Launches the worker.\nvar worker = new Worker('worker.js');\n\n// Sends a plain object.\nworker.postMessage({ hello: 'world' });\n// → message { hello: \"world\" }\n\n// Sends an array.\nworker.postMessage([ 1, 2, 3 ]);\n// → message [ 1, 2, 3 ]\n\n// Tries to send a function, results in\n// an error being thrown.\nworker.postMessage(setTimeout);\n// → Uncaught DataCloneError\n```", "```js\n// After 2 seconds, post some data back to\n// the main thread using the \"postMessage()\"\n// function.\nsetTimeout(() => {\n    postMessage('hello world');\n}, 2000);\n```", "```js\n// Launches the new worker.\nvar worker = new Worker('worker.js');\n\n// Adds an event listener for the \"message\"\n// event. Notice that the \"data\" property\n// contains the actual message payload, the\n// same way messages sent to workers do.\nworker.addEventListener('message', (e) => {\n    console.log('from worker', `\"${e.data}\"`);\n});\n```", "```js\n// This is the shared state between the pages that\n// connect to this worker.\nvar connections = 0;\n\n// Listen for pages that connect to this worker, so\n// we can setup the message ports.\naddEventListener('connect', (e) => {\n\n    // The \"source\" property represents the\n    // message port created by the page that's\n    // connecting to this worker. We have to call\n    // \"start()\" to actually establish the connection.\n    e.source.start();\n\n    // We post a message back to the page, the payload\n    // is the updated number of connections.\n    e.source.postMessage(++connections);\n});\n```", "```js\n// Launches the shared worker.\nvar worker = new SharedWorker('worker.js');\n\n// Sets up our \"message\" event handler. By connecting\n// to the shared worker, we're actually causing a\n// a message to be posted to our messaging port.\nworker.port.addEventListener('message', (e) => {\n    console.log('connections made', e.data);\n});\n\n// Starts the messaging port, indicating that we're\n// ready to start sending and receiving messages.\nworker.port.start();\n```", "```js\n// Where we store the ports of connected\n// pages so we can broadcast messages.\nvar ports = [];\n\n// Fetches a resource from the API.\nfunction fetch() {\n    var request = new XMLHttpRequest();\n\n    // When the response arrives, we only have\n    // to parse the JSON string once, and then\n    // broadcast it to any ports.\n    request.addEventListener('load', (e) => {\n        var resp = JSON.parse(e.target.responseText);\n\n        for (let port of ports) {\n            port.postMessage(resp);\n        }\n    });\n\n    request.open('get', 'api.json');\n    request.send();\n}\n\n// When a page connects to this worker, we push the\n// port to the \"ports\" array so the worker can keep\n// track of it.\naddEventListener('connect', (e) => {\n    ports.push(e.source);\n    e.source.start();\n});\n\n// Now we can \"poll\" the API, and broadcast the result\n// to any pages.\nsetInterval(fetch, 1000);\n```", "```js\n// Launch the worker.\nvar worker = new SharedWorker('worker.js');\n\n// Listen to the \"message\" event, and log\n// any data that's sent back from the worker.\nworker.port.addEventListener('message', (e) => {\n    console.log('from worker', e.data);\n});\n\n// Inform the shared worker that we're ready\n// to start receiving messages.\nworker.port.start();\n```", "```js\n// Stores the ports of any connected pages.\nvar ports = [];\n\naddEventListener('connect', (e) => {\n\n    // The received message data is distributed to any\n    // pages connected to this worker. The page code\n    // decides how to handle the data.\n    e.source.addEventListener('message', (e) => {\n        for (let port of ports) {\n            port.postMessage(e.data);\n        }\n    });\n\n    // Store the port reference for the connected page,\n    // and start communications using the \"start()\"\n    // method.\n    ports.push(e.source);\n    e.source.start();\n});\n```", "```js\n// Launch the shared worker, and store a reference\n// to the main UI element we're working with.\nvar worker = new SharedWorker('worker.js');\nvar input = document.querySelector('input');\n\n// Whenever the input value changes, post the input\n// value to the worker for other pages to consume.\ninput.addEventListener('input', (e) => {\n    worker.port.postMessage(e.target.value);\n});\n\n// When we receive input data, update the value of our\n// text input. That is, unless the value is already\n// updated.\nworker.port.addEventListener('message', (e) => {\n    if (e.data !== input.value) {\n        input.value = e.data;\n    }\n});\n\n// Starts worker communications.\nworker.port.start();\n```", "```js\n// Listens for incoming messages.\naddEventListener('message', (e) => {\n\n    // Posts a result back to the worker.\n    // We call \"indexOf()\" on the input\n    // array, looking for the \"search\" data.\n    postMessage({\n        result: e.data.array\n            .indexOf(e.data.search) > -1\n    });\n});\n```", "```js\naddEventListener('message', (e) => {\n\n    // The array that we're going to divide into\n    // 4 smaller chunks.\n    var array = e.data.array;\n\n    // Computes the size, roughly, of a quarter\n    // of the array - this is our chunk size.\n    var size = Math.floor(0.25 * array.length);\n\n    // The search data we're looking for.\n    var search = e.data.search;\n\n    // Used to divide the array into chunks in\n    // the \"while\" loop below.\n    var index = 0;\n\n    // Where our chunks go, once they've been sliced.\n    var chunks = [];\n\n    // We need to store references to our sub-workers,\n    // so we can terminate them.\n    var workers = [];\n\n    // This is for counting the number of results\n    // returned from sub-workers.\n    var results = 0;\n\n    // Splits the array into proportionally-sized chunks.\n    while (index < array.length) {\n    chunks.push(array.slice(index, index + size));\n        index += size;\n    }\n\n    // If there's anything left over (a 5th chunk),\n    // throw it into the chunk before it.\n    if (chunks.length > 4) {\n        chunks[3] = chunks[3].concat(chunks[4]);\n        chunks = chunks.slice(0, 4);\n    }\n\n    for (let chunk of chunks) {\n\n        // Launches our sub-worker and stores a\n        // reference to it in \"workers\".\n        let worker = new Worker('sub-worker.js');\n        workers.push(worker);\n\n        // The sub-worker has a result.\n        worker.addEventListener('message', (e) => {\n            results++;\n\n            // The the result is \"truthy\", we can post\n            // a response back to the main thread.\n            // Otherwise, we check if all the\n            // responses are back yet. If so, we can\n            // post a false value back. Either way, we\n            // terminate all sub-workers.\n            if (e.data.result) {\n                postMessage({\n                    search: search,\n                    result: true\n                });\n\n                workers.forEach(x => x.terminate());\n            } else if (results === 4) {\n                postMessage({\n                    search: search,\n                    result: false\n                });\n\n                workers.forEach(x => x.terminate());\n            }\n        });\n\n        // Give the worker a chunk of array to search.\n        worker.postMessage({\n            array: chunk,\n            search: search\n        });\n    }\n});\n```", "```js\n// Launches the worker...\nvar worker = new Worker('worker.js');\n\n// Generates some input data, an array\n// of numbers for 0 - 1041.\nvar input = new Array(1041)\n    .fill(true).map((v, i) => i);\n\n// When the worker responds, display the\n// results of our search. \nworker.addEventListener('message', (e) => {\n    console.log(`${e.data.search} exists?`, e.data.result);\n});\n\n// Search for an item that exists.\nworker.postMessage({\n    array: input,\n    search: 449\n});\n// → 449 exists? true\n\n// Search for an item that doesn't exist.\nworker.postMessage({\n    array: input,\n    search: 1045\n});\n// → 1045 exists? false\n```", "```js\n// When a message arrives, check if the provided\n// data is an array. If not, post a response\n// with the \"error\" property set. Otherwise,\n// compute and respond with the result.\naddEventListener('message', (e) => {\n    if (!Array.isArray(e.data)) {\n        postMessage({\n            error: 'expecting an array'\n        });\n    } else {\n        postMessage({\n            result: e.data[0]\n        });\n    }\n});\n```", "```js\n// Launches the worker.\nvar worker = new Worker('worker.js');\n\n// Listens for messages coming from the worker.\n// If we get back an error, we log the error\n// message. Otherwise, we log the successful result.\nworker.addEventListener('message', (e) => {\n    if (e.data.error) {\n        console.error(e.data.error);\n    } else {\n        console.log('result', e.data.result);\n    }\n});\n\nworker.postMessage([ 3, 2, 1 ]);\n// → result 3\n\nworker.postMessage({});\n// → expecting an array\n```", "```js\n// When a message arrays, post a response\n// that contains the \"name\" property of\n// the input data. The what if data isn't\n// defined?\naddEventListener('message', (e) => {\n    postMessage(e.data.name);\n});\n```", "```js\n// Launches our worker.\nvar worker = new Worker('worker.js');\n\n// Listen to messages sent back from the worker,\n// and log the result.\nworker.addEventListener('message', (e) => {\n    console.log('result', `\"${e.data}\"`);\n});\n\n// Listen to errors sent back from the worker,\n// and log the error message.\nworker.addEventListener('error', (e) => {\n    console.error(e.message);\n});\n\nworker.postMessage(null);\n// → Uncaught TypeError: Cannot read property 'name' of null\n\nworker.postMessage({ name: 'JavaScript' });\n// → result \"JavaScript\"\n```"]