<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Practical – Questionnaire Component</h1></div></div></div><p>We now have three practical applications under our belt. The objective has been to show the process of designing an application and think it through in a series of careful steps to create a clear picture of the project that's we're going to build. This time around, there's going to be a change of pace and rather than looking at how "we" would design and build an application, I'll be guiding you through my own process of creating a multiple-step, dynamic<a id="id431" class="indexterm"/> questionnaire component.</p><p>Here are the features of the application that will be the subject of this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A reusable package that can be included in any application</li><li class="listitem" style="list-style-type: disc">Theme variables and mixins to allow visual integration in other apps</li><li class="listitem" style="list-style-type: disc">Splitting a questionnaire into multiple steps, each with multiple questions</li><li class="listitem" style="list-style-type: disc">Construct the UI dynamically from incoming server data</li><li class="listitem" style="list-style-type: disc">A JSON object produced by the questionnaire, representing the steps, questions, and the answers that the user has provided</li><li class="listitem" style="list-style-type: disc">Use Ext JS Associations to help structure application data</li></ul></div><p>Why the step back from the all-inclusive "we" to a look at my own architecture process? I hope that it'll give you a more practical look at the thought processes that go into an application design. You can also see how there are always multiple correct paths that an architect can pursue. Sketching out these paths and investigating them before writing any code will avoid the "analysis paralysis" that hits many projects and causes them to grind to a halt when difficult questions need answers.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Application design – my way</h1></div></div></div><p>My first port of <a id="id432" class="indexterm"/>call when<a id="id433" class="indexterm"/> thinking about an application doesn't involve fancy tools or an IDE. Once the customer requirements are established, I take myself as far away from a computer as possible, wash all thoughts of JavaScript and Ext JS from my head, and remove as many distractions as possible.</p><p>With that done, I <a id="id434" class="indexterm"/>grab a large notebook and a pencil and get <a id="id435" class="indexterm"/>scribbling. I've never found a better way to quickly draft ideas than a bit of manual labor, so while I'm designing in the same way as we've seen in the previous few chapters, I can avoid getting bogged down with drawing tools and UML diagrams.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>All of this needs to be formalized in documented design decisions later. The purpose is to quickly test out ideas and avoid dead ends.</p></div></div><p>How did I start?</p><div><img src="img/5308OT_08_01.jpg" alt="Application design – my way"/></div><p>Well, it's not pretty, but <a id="id436" class="indexterm"/>you can see the relationship between this<a id="id437" class="indexterm"/> and the diagrams of UI views we saw in previous chapters. Note that the intention with these images is not to spell out the design in exacting detail, but simply to give an insight into the process I went through, warts and all! Eventually, I'll use these sketches to build something like this:</p><div><img src="img/5308OT_08_02.jpg" alt="Application design – my way"/></div><p>What are the features<a id="id438" class="indexterm"/> I picked out from this original <a id="id439" class="indexterm"/>sketch?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Questionnaire header, changing per step</li><li class="listitem" style="list-style-type: disc">Panes containing an introduction and a conclusion to the questionnaire</li><li class="listitem" style="list-style-type: disc">Panes for each of the steps making up the application</li><li class="listitem" style="list-style-type: disc">A step can have introduction text</li><li class="listitem" style="list-style-type: disc">A question needs explanation text</li><li class="listitem" style="list-style-type: disc">Navigation buttons to move between steps</li><li class="listitem" style="list-style-type: disc">A progress bar to show the number of steps completed and numbers until the end</li></ul></div><p>In addition, this component needs to be able to validate the mandatory questions in a step that have been completed before the user can move to the next step.</p><p>Rather than spending lots <a id="id440" class="indexterm"/>of time in front of a computer creating the <a id="id441" class="indexterm"/>perfect UI design, I was able to quickly flesh out an idea to see how it looked and this informed me about my design requirements.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec88"/>Data structure</h1></div></div></div><p>These initial sketches enabled me to <a id="id442" class="indexterm"/>quickly think about the <a id="id443" class="indexterm"/>underlying data powering the component. In previous chapters, we've stopped here to discuss whether the design requirements can be fulfilled by Ext JS. Instead, we're going to push ahead, put technology to one side, and just focus purely on architecture.</p><p>In some ways—as we're going with MVVM—the architecture is technology agnostic. We can create the kind of application that we want to build without feeling constrained by the framework we're using. This can be dangerous; in that, we might lose sight of particular client requirements or start drafting something that might turn out to be impossible. To this end, we introduce new checks and balances that we'll discuss in a little while.</p><p>For now, I continued with my pencil and paper to work out a data structure. As in previous cases, the UI design informs the underlying data requirements. Here's a quick insight into my design doodles:</p><div><img src="img/5308OT_08_03.jpg" alt="Data structure"/></div><p>It's the same as in<a id="id444" class="indexterm"/> previous chapters, just a bit<a id="id445" class="indexterm"/> messier! Again, don't worry about the detail. Look at the rough notes and the scribbles and realize that the initial stages of an application design are an organic process and things can (and will) take a meandering path. Here's what my doodles led to in terms of data structure:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Questionnaire<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Title</li><li class="listitem" style="list-style-type: disc">Introduction</li><li class="listitem" style="list-style-type: disc">Conclusion</li><li class="listitem" style="list-style-type: disc">Steps[]<p>Title</p><p>Introduction</p><p>Questions[]</p><p>Name</p><p>Required?</p><p>Question text</p></li></ul></div></li><li class="listitem" style="list-style-type: disc">Field type</li></ul></div><p>I'm not yet worrying<a id="id446" class="indexterm"/> about what inherits from what at this<a id="id447" class="indexterm"/> stage. I just know that I'd like to have a single questionnaire that has many steps and these steps will each have many questions. From here, I just fleshed out the fields each class needs.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec97"/>Consider carefully</h2></div></div></div><p>It's at this point I have to <a id="id448" class="indexterm"/>tell you that I lied to you. In the purest sense, it would be fantastic to think that you can sketch out the full application architecture on paper, but in reality, you will always do so with an eye on the real world. Look back to my last page of pencil doodles and you'll see a few notes like "associations" with a giant underline. That's there because I knew that the data structure I've described previously will be implemented using Ext JS associations, a feature we haven't yet used in this book, but one that can be very powerful.</p><p>As much as possible though, I've tried to push past any thoughts of detail, but trusted my knowledge of Ext JS to pop to the fore without any warning signs.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Data flow</h1></div></div></div><p>With the previous data structure <a id="id449" class="indexterm"/>in mind, I started to think more about how the <a id="id450" class="indexterm"/>information supplied from an API would flow through view models and allow me to build the user interface.</p><p>I had a feeling that validation was going to complicate the application, so I started sketching out some ideas for the parts of the UI that would be affected. The user can't proceed to the next step until the current step is valid. In this, its mandatory questions have been answered so the "next" button needs to be disabled until this happens. I started drawing again, but quickly a degree of "analysis paralysis" kicked in. How should this work? There are several Ext JS features that could help; will model validation binding work here or will it have to be manual handling of validation events. Earlier, I mentioned "checks and balances" to avoid building something that Ext JS won't support; I decided to take some time out and investigate the best way to implement this in Ext JS.</p><p>Call this a "spike" as we<a id="id451" class="indexterm"/> did in <a class="link" href="ch05.html" title="Chapter 5. Practical – a CMS Application">Chapter 5</a>, <em>Practical – a CMS Application</em>, or <a id="id452" class="indexterm"/>call it a prototype. It doesn't really matter whether we write this code and then throw it away; if it helps the process, then it's a valuable exercise. I built it standalone (outside of an MVC or MVVM structure) and it's horrible. Look at this code snippet:</p><div><pre class="programlisting">s.questions().each(function(q) {
   var input = stepForm.add({ 
          xtype: 'textfield', modelValidation: true,
          viewModel: {
                data: { question: q },
                formulas: {
                      isValid: {
                            bind: {
                                   bindTo: '{question}',
                                   deep: true
                            },
                            get: function() {
                                  return this.get('step').isValid();
                            }
                      }
                }
          },
          bind: '{question.answer}',
          fieldLabel: q.get('text')
   });
});</pre></div><p>I don't wish this code to be my worst enemy. Shouldn't every piece of code we write be pristine and well considered? In the real world, almost no one can see this code. It's to test out my ideas and find out what feels right and it doesn't have to be tidy or maintainable. It's a one-off. Here's what I wanted to test out:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Will the <code class="literal">modelValidation</code> feature be useful with auto-generated form fields?</li><li class="listitem" style="list-style-type: disc">Will I be able to bind to questions to get the validation state of the current step?</li><li class="listitem" style="list-style-type: disc">Will it feel natural to use these features or is there an easier way?</li></ul></div><p>We've seen how view models can be used to create simple declarative applications and they can be extremely powerful when used correctly. In this application, fields are being generated from API data and each field had its own question model. Propagating the validity of this model up to the relevant parts of the user interface via view models seemed like it might be difficult. What did I discover?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A view <a id="id453" class="indexterm"/>model binding trick</li><li class="listitem" style="list-style-type: disc">A slight <a id="id454" class="indexterm"/>difference of opinion with the team at Sencha regarding the way <code class="literal">modelValidation</code> behaves</li><li class="listitem" style="list-style-type: disc">A way of binding a button state to the state of an association</li></ul></div><p>This seems like a great result for this grubby code. Let's look at each point in turn.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec98"/>A binding trick</h2></div></div></div><p>This snippet of code is from<a id="id455" class="indexterm"/> the view model of a question's form field:</p><div><pre class="programlisting">formulas: {
   isValid: {
          bind: {
                bindTo: '{question}',
                deep: true
          },
          get: function() {
                return this.get('step').isValid();
          }
   }
}</pre></div><p>The view model has a question model and inherits the step model from its parent view model. We tell Ext JS that we'd like to bind to changes in the question model, deep changes, so any of its property changes and then trigger the <code class="literal">isValid</code> method on the parent step. This is great because the <code class="literal">isValid</code> method can in turn trigger changes on the parent step, propagating the state of the questions up to the step. Here's the <code class="literal">isValid</code> code:</p><div><pre class="programlisting">isValid: function() {
   var valid = true;
   this.questions().each(function(q) {
          if(q.isValid() === false) {
                valid = false;
          }
   });
   this.set('valid', valid);
   return valid;
}</pre></div><p>It checks the validity <a id="id456" class="indexterm"/>of all the child questions and sets the valid property of the step accordingly. We can then bind to this valid value and have it affect other things (such as the disabled state of the "next" button in the UI).</p><p>This is slightly counterintuitive because we're not binding directly to the <code class="literal">isValid</code> formula. Instead, we're using it to watch for changes on the question and then trigger changes on the step model.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec99"/>A difference of opinion</h2></div></div></div><p>There was a change in the<a id="id457" class="indexterm"/> behavior between Ext JS 5.0 and 5.0.1. The <code class="literal">modelValidation</code> feature matches validation in the model with validation in the form, reducing duplication of code. In Ext JS 5, when the form values change, these changes will be synchronized to the model via binding. In Ext JS 5.0.1, this synchronization will only happen when the form field is valid. The idea is that the model should never be left in an invalid state based on form changes, but the problem occurs like this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User completes the form field and it becomes valid</li><li class="listitem" style="list-style-type: disc">The form value is passed to the model's field, which in turn becomes valid</li><li class="listitem" style="list-style-type: disc">User changes the form field to make it invalid again</li><li class="listitem" style="list-style-type: disc">The change is not passed to the model, which remains valid</li></ul></div><p>This means that when binding to model value, you'll get something that doesn't reflect the real state of the UI. The model will say everything is valid when in fact the UI says differently. In the case of this application, the plan is to bind the "next" button to the model state, which will enable the button incorrectly in the preceding situation. My solution was to override this and return to the Ext JS 5.0 behavior as follows:</p><div><pre class="programlisting">Ext.form.field.Text.prototype.publishValue = function () {
    var me = this;

    // Don't check for errors when publishing the field value
    //if (me.rendered &amp;&amp; !me.getErrors().length) {
    if (me.rendered) {
        me.publishState('value', me.getValue());
    }
}</pre></div><p>An alternative <a id="id458" class="indexterm"/>workaround would be to bind the "next" button to the value of the form field rather than the model value, but in our case, we need to do further work on the model value, so it's not a great solution.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>A means to an end</h2></div></div></div><p>All of this allows you to have a chain<a id="id459" class="indexterm"/> of configuration that goes all the way from each individual question field to the question model, then to the step model, and to higher-level places in the user interface that depend on it.</p><p>When I was writing this chapter, there were other ideas kicking around in my head as to how to implement it. A solution that handles validation events and uses listeners to propagate state through the application was another approach, but it ended up being less elegant despite the final idea being a little more complicated than our previous binding code.</p><p>Ext JS allows you to watch for deep changes in associations en-masse that would help, but at the time of writing this book, this change is not documented. Hopefully, it's coming in a post-5.0.1 version!</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>You can see this change documented in the 5.0.1 release notes<a id="id460" class="indexterm"/> as EXTJS-13933 at <a class="ulink" href="http://dev.sencha.com/extjs/5.0.1/release-notes.html">http://dev.sencha.com/extjs/5.0.1/release-notes.html</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec90"/>Sketchy sketching</h1></div></div></div><p>My biggest<a id="id461" class="indexterm"/> concern<a id="id462" class="indexterm"/> of the application has been solved to my satisfaction; I won't go into any more detail on my code spike because I'll reuse some of this code later once it's been tidied up.</p><p>I moved on to working out the role of controllers in this application. What user-initiated events<a id="id463" class="indexterm"/> will we<a id="id464" class="indexterm"/> need to handle?</p><div><img src="img/5308OT_08_04.jpg" alt="Sketchy sketching"/><div><p>Initial sketches for controllers; there are several things here that didn't make it into the final version</p></div></div><p>The user can perform two main actions: completing the questionnaire itself and navigating between pages. It's the navigation that the controller will concern itself with.</p><p>At this point, I felt fairly confident that I'd fleshed out most of the tricky parts of the application. In the role of an architect, each of the diagrams and interactions that I sketched need to be turned into formal documentation in order to provide a point of reference for developers. Here's what I came up with for the UI:</p><div><img src="img/5308OT_08_05.jpg" alt="Sketchy sketching"/></div><p>There's no <a id="id465" class="indexterm"/>point in duplicating the work I've<a id="id466" class="indexterm"/> already shown you, so I won't go through each of these formalized diagrams, but it should be stressed that this isn't a step that can be skipped. As a developer, it's essential that there's a solid design document to refer back to when writing code and also to keep the architect accountable. The next step in the process is to move from pencil and paper back to the computer and start to write the code for our questionnaire component.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec91"/>Get set</h1></div></div></div><p>The questionnaire component that we'll build in this chapter will be reusable in any application. To that end, we can use an Ext JS package<a id="id467" class="indexterm"/> to create a bundle of code that can be built in the same way as a normal Ext JS application, but it can be incorporated as a component in our future applications. We discussed packages in <a class="link" href="ch03.html" title="Chapter 3. Application Structure">Chapter 3</a>, <em>Application Structure</em>, but now we'll see how they can be used in practice.</p><p>Here's how I started up the project that I used as a basis for this component and its test application:</p><div><pre class="programlisting">
<strong>sencha generate workspace ./questionnaire-space</strong>
<strong>cd questionnaire-space</strong>
<strong>sencha generate package wizard</strong>
<strong>sencha -sdk ~/Downloads/ext-5.0.1 generate app Questions ./questions</strong>
</pre></div><p>Building a package requires us to first create a workspace, so after doing so using the latest version of the SDK that I downloaded, I moved on to the <code class="literal">workspace</code> directory and issued the command to create the package itself, which I called <code class="literal">wizard</code>. Then, I created a test application that would host the package during development; I called this <code class="literal">questions</code>.</p><p>I then get the test <a id="id468" class="indexterm"/>application up and running with:</p><div><pre class="programlisting">
<strong>cd questions-space/questions</strong>
<strong>sencha app watch</strong>
</pre></div><p>The web server is now up and running at <code class="literal">http://localhost:1841/</code>. The final step is telling the test application to include the new package. I edited <code class="literal">questions-package/questions/app.json</code> and amended the <code class="literal">requires</code> member:</p><div><pre class="programlisting">// was "requires": []"requires": ["wizard"]</pre></div><p>As we gave the package the name <code class="literal">wizard</code>, just add this in the array and we're good to go.</p><p>The package we're going to build is contained at <code class="literal">questions-space/packages/wizard</code> and will start off containing most of the same directories as an Ext JS application. We can now move to this directory and start building it in just the same way as we have in the past few chapters.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec92"/>The data layer</h1></div></div></div><p>When writing the prototype, I did<a id="id469" class="indexterm"/> partially build the data classes that were <a id="id470" class="indexterm"/>required, so now let's fully flesh them out:</p><div><pre class="programlisting">// packages/wizard/src/model/Questionnaire.js
Ext.define('Wizard.model.Questionnaire', {
    extend: 'Ext.data.Model',
    fields: [
        { name: 'title' },
        { name: 'introduction' },
        { name: 'conclusion' }
    ],
    proxy: {
        type: 'rest',
        url: 'http://localhost:3000/questionnaire'
    },

    toJSON: function() {
        return this.getData(true);
    }
});</pre></div><p>Standard stuff here with one<a id="id471" class="indexterm"/> exception is that a <code class="literal">toJSON</code> method that <a id="id472" class="indexterm"/>consumes applications can override in order to obtain JSON in a format they can use for further processing. The default implementation returns the data of the questionnaire object along with its association data. Alternatively, they can override the proxy configuration to save the questionnaire data to their own server.</p><p>Let's take a look at the model I used to represent a step in the questionnaire:</p><div><pre class="programlisting">// packages/wizard/src/model/Step.js
Ext.define('Wizard.model.Step', {
    extend: 'Ext.data.Model',
    fields: [
        { name: 'title' },
        { name: 'introduction' },
        {
             name: 'questionnaireId',
             reference: {
                type: 'Wizard.model.Questionnaire',
                inverse: 'steps'
             }
         }
    ],

    isValid: function() {
        var valid = true;

        this.questions().each(function(q) {
            if(q.isValid() === false) {
                valid = false;
            }
        });

        this.set('valid', valid);
        
        return valid;
    }
});</pre></div><p>There are a couple of things to note on the <code class="literal">Step</code> model; firstly, the use of associations, which I realized would provide a really easy way to load the nested data for the whole questionnaire in a single action.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>The association is created using the <code class="literal">reference</code> option on the field with the <code class="literal">type</code> option specifying the full class name of the parent model and the inverse is the name of the association store that will be created on this parent <code class="literal">Questionnaire</code>. Ext JS 5 associations are a little confusing at first as they're always defined on the child, not the parent.</p></div></div><p>Secondly, the <code class="literal">isValid</code> method <a id="id473" class="indexterm"/>enumerates the questions belonging to this<a id="id474" class="indexterm"/> step and sets the step's own valid field according to the validity of its questions.</p><p>Finally, here's the <code class="literal">Question</code> model I built:</p><div><pre class="programlisting">// packages/wizard/src/model/Question.js
Ext.define('Wizard.model.Question', {
    extend: 'Ext.data.Model',
    fields: [
        { name: 'name' },
        { name: 'required', type: 'boolean' },
        { name: 'questionText' },
        { name: 'type' },
        { name: 'answer' },
        {
             name: 'stepId',
             reference: {
                type: 'Wizard.model.Step',
                inverse: 'questions'
             }
         }
    ],
    
    validators: { answer: 'presence' },

    getValidation: function() {
        if(this.get('required')) {
            return this.callParent();
        } else {
            return new Ext.data.Validation();
        }
    }
});</pre></div><p>Again, I have <code class="literal">child-side</code> of the <code class="literal">Step -&gt; Questions</code> association defined in the same way as <code class="literal">Questionnaire -&gt; Steps</code>. Using the <code class="literal">validators</code> config, I specify that answer should always be present, but<a id="id475" class="indexterm"/> I stumbled on a catch here that I could never <a id="id476" class="indexterm"/>have known about when just sitting down with a pencil and paper.</p><p>I really wanted to be able to add validators at runtime so that I could check the required field of the <code class="literal">Step</code> model and add the <code class="literal">presence</code> check to the answer. This enables the end user to toggle whether a particular question is required or not.</p><p>Unfortunately, after some intimate time with the Ext JS source code, it turns out that validators can only be defined on model class instances when they're defined and not on each instance of that class. Hopefully, this will be allowed in a later version—which at time of writing this book was 5.0.1—but I managed to come up with workarounds that enable this functionality.</p><p>We need to override the <code class="literal">Question</code> class's <code class="literal">getValidation</code> method. In the event that required is <code class="literal">true</code>, I call the <code class="literal">getValidation</code> on the superclass to proceed with validation normally. However, if it's <code class="literal">false</code>, I return a new <code class="literal">Ext.data.Validation</code> instance, but don't actually run its validation in effect, providing the same result as if the validation had passed.</p><p>While this works, and it's simple, it's one of these things that should be revisited with each new Ext JS version to see whether there's a more elegant way of solving the issue. I recommend code like this should be commented to let others know exactly why the workaround is needed and which version it applies to.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec93"/>The payload</h1></div></div></div><p>An interesting feature of<a id="id477" class="indexterm"/> associations is that it allows for the use of <a id="id478" class="indexterm"/>nested data. By loading data for the questionnaire and its steps and questions as a single JSON object, the child's steps and questions association will be populated too. For example, take a look at this JSON:</p><div><pre class="programlisting">{
    "id": 1,
    "title": "Quiz Questions!"
    "introduction": "Welcome!",
    "conclusion": "Thanks!",
    "steps": [
        {
            "id": 1,
            "title": "Round 1"
            "introduction": "Welcome to Round One!",
            "questionnaireId": 1,
            "questions": [{
                "id": 1,
                "questionText": "Turku is the third largest city by population of which European country?",
                "required": true,
                "stepId": 1,
                "type": "textfield"
            }],
        }
    ]
}</pre></div><p>This object includes data for the questionnaire with an array of child steps. The steps have their own array of questions, as shown here:</p><div><pre class="programlisting">Questionnaire.load(1, {
    success: function(q) {
        console.log(q.steps().first().get('title'));
    }
});</pre></div><p>If we load this, we would see "round 1" logged to the console. Some might question why we bother using models at all; we could use <code class="literal">Ext.Ajax</code> to load the JSON object directly into a view model. Models allow us to use validation and let us augment each <code class="literal">Model</code> instance with utility methods. The stores that are auto created on parent models give us shortcut methods to enumerate the records within and find individual child records.</p><p>There's a little bit of overhead <a id="id479" class="indexterm"/>in setting up and working with models here, but<a id="id480" class="indexterm"/> it's worth it in the long run.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec94"/>The wizard component</h1></div></div></div><p>I felt pretty good about the<a id="id481" class="indexterm"/> data layer I'd built. It was frustrating to<a id="id482" class="indexterm"/> have spent time trying to work around this limitation to validators that I found, but the final result works well. It was time to move on to the user interface, starting with the main container for the questionnaire wizard:</p><div><pre class="programlisting">// packages/wizard/src/view/Wizard.js
Ext.define('Wizard.view.wizard.Wizard', {
    extend: 'Ext.Panel',
    xtype: 'wizard',
    requires: [
        'Wizard.model.Questionnaire',
        'Wizard.model.Step',
        'Wizard.model.Question'
    ],
    ui: 'wizard',
    bodyCls: 'wizard-body',

    viewModel: 'wizard',
    controller: 'wizard',
    
    layout: 'card',
    
    config: {
        questionnaire: null
    },
    bind: {
        questionnaire: '{questionnaire}',
        activeItem: '{currentPosition}',
        title: '{questionnaire.title}'
    },

    applyQuestionnaire: function(questionnaire) {
        if(!questionnaire) {
            return;
        }

        var intro = questionnaire.get('introduction'),
            conclusion = questionnaire.get('conclusion');

        this.add({ html: intro });

        questionnaire.steps().each(this.addStepPane, this);

        this.add({ html: conclusion });

        return questionnaire;
    },

    setActiveItem: function() {   
        if(this.items.length &gt; 0) {
            this.callParent(arguments);
        }
    },

    addStepPane: function(step, i) {
        this.add({
            xtype: 'wizard-step',
            viewModel: {
                data: { step: step }
            },
            bind: { step: '{step}' }
        });
    },

    load: function(id) {
        this.getViewModel().setLinks({
            questionnaire: {
                type: 'Wizard.model.Questionnaire',
                id: 1
            }
        });
    },

    dockedItems: [
        { xtype: 'wizard-navigation', dock: 'bottom' },
        {
            xtype: 'wizard-progress', dock: 'bottom',
            bind: '{questionnaire.steps}'
        }
    ]
});</pre></div><p>I'll break down each <a id="id483" class="indexterm"/>of the important parts of this code <a id="id484" class="indexterm"/>and try and explain the design decisions behind them.</p><p>The <code class="literal">ui</code> and <code class="literal">bodyCls</code> options are set as a way of hooking into this component via theming and CSS later. In particular, the <code class="literal">ui</code> option is a great way of reusing parts of the Ext JS theming system with your own components. We'll revisit this towards the end of the chapter.</p><p>After configuring the <code class="literal">viewModel</code>, <code class="literal">controller</code>, and <code class="literal">layout</code> options, I use a tactic that we've seen before, which is to create a new custom configuration option that will be used to bind to. I created a <code class="literal">questionnaire</code> config for me to bind a view model value to and you can see that bound value is also called <code class="literal">questionnaire</code>.</p><p>The final piece of the configuration puzzle is to bind the title of the questionnaire to the title of the wizard panel itself.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Do it yourself</h2></div></div></div><p>One of my favorite things about creating custom configuration options is that you get an extra hook in the form of an <code class="literal">applyOptionName</code> method. It's created automatically for each config option and is called by Ext JS before setting the value. It lets us customize or validate the configuration option and if we've bound a view model value to it, it lets us perform actions when the bound value updates.</p><p>I used this with <code class="literal">applyQuestionnaire</code>, which is used to build the items for the wizard panel when the questionnaire is bound. It performs the following three actions:</p><div><ol class="orderedlist arabic"><li class="listitem">Adds a container for the questionnaire introduction.</li><li class="listitem">Adds a container for the questionnaire conclusion.</li><li class="listitem">Adds a <code class="literal">wizard-step</code> component for each step in the questionnaire using the <code class="literal">addStepPane</code> method.</li></ol></div><p>Within <code class="literal">addStepPane</code>, the new <code class="literal">wizard-step</code> component is supplied with a view model that contains the <code class="literal">Step</code> model itself and immediately binds this to a step config option. It will be simpler to just pass in the <code class="literal">Step</code> model as a configuration option rather than using view models, but this would mean that we can't use this step in further binding formulas and it will be more awkward to react to changes in <code class="literal">Step</code>, such as validation.</p><p>The second use of apply is via <code class="literal">applyActiveItem</code>, which will be triggered every time the <code class="literal">currentPosition</code> value on the view model changes. It's used to update the panel's <code class="literal">currentPosition</code> to switch from card to card as the user progresses through questionnaire, but I added in a check to ensure the wizard's items have been initialized before doing this. Without this check, setting <code class="literal">currentPosition</code> can raise an error if <code class="literal">currentPosition</code> is <a id="id485" class="indexterm"/>changed before the items have <a id="id486" class="indexterm"/>been set up.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Wizardly tools</h2></div></div></div><p>The last piece of configuration for the main<a id="id487" class="indexterm"/> wizard panel is to create the navigation buttons and the progress indicator. I added these as <code class="literal">dockedItems</code> with the dock set at the "bottom" in order to have them in the footer of the panel. The progress bar is bound to the questionnaire's steps from the view model in order to build its step icons.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec95"/>One step forward</h1></div></div></div><p>The navigation bar<a id="id488" class="indexterm"/> allows the user not only to proceed through the<a id="id489" class="indexterm"/> questionnaire, but also return to previous steps to review them. There's a "restart" button that takes the user back to the introduction. The "finish" button will be the one we'll use to communicate back to the host application when all questions are complete.</p><p>Each of these buttons is enabled or disabled depending on the validation state of each step (and therefore each question) and the user's position in the questionnaire. Here's the code:</p><div><pre class="programlisting">// packages/wizard/src/view/Navigation.js
Ext.define('Wizard.view.wizard.Navigation', {
    extend: 'Ext.Toolbar',
    xtype: 'wizard-navigation',
    items: [
        {
            text: 'Restart', itemId: 'restart',
            bind: { disabled: '{isIntroduction}' }
        },
        {
            text: 'Previous', itemId: 'prev',
            bind: { disabled: '{isIntroduction}' }
        },
        '-&gt;',
        { 
            text: 'Next', itemId: 'next',
            bind: { disabled: '{!isNextEnabled}' }
        },
        {
            text: 'Finish', itemId: 'finish',
            bind: { disabled: '{isNotLastStep}' }
        }
    ]
});</pre></div><p>I've delegated the <a id="id490" class="indexterm"/>responsibility for enabling and disabling these <a id="id491" class="indexterm"/>buttons to a view model. As there are other components that will be interested in these values, they're going to rest at the top-level view model of the wizard. We'll take a look at this code later.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec96"/>Making progress</h1></div></div></div><p>The progress bar <a id="id492" class="indexterm"/>is a series of buttons that allows the user to<a id="id493" class="indexterm"/> determine how far they are along the questionnaire process and skip back to an earlier step. Each button needs to be aware of the user's position in the questionnaire in order to determine whether it should be enabled or disabled. The "start" and "end" buttons are fixed, wherein they are available on every questionnaire, but the numbered step buttons need to be automatically generated and bound to the steps for currently loaded questionnaire. Let's take a look at the code:</p><div><pre class="programlisting">// packages/wizard/src/view/Progress.js
Ext.define('Wizard.view.wizard.Progress', {
    extend: 'Ext.Container',
    xtype: 'wizard-progress',
    
    config: {
        steps: null
    },
    defaultBindProperty: 'steps',
    defaultType: 'button',
    baseCls: 'wizard-progress',
    layout: {
        type: 'hbox',
        pack: 'center'
    },
    
    applySteps: function(steps) {
        
        var lineHtml = '&lt;div class="wizard-progress-bar"&gt;&lt;/div&gt;',
            stepArr = steps.getData().items,
            items = this.buildProgressIcons(stepArr),
            container;

        this.removeAll();
        
        items.unshift({ text: 'Start', stepIndex: 0 });
        items.push({ 
            text: 'End', bind: {
                disabled: '{isNotLastStep}'
            }
        });

        container = this.add({
            xtype: 'container', cls: 'wizard-progress-inner',
            defaultType: 'button', items: items
        });

        container.getEl().insertHtml('afterBegin',  lineHtml);

        return steps;
    },


    buildProgressIcons: function(steps) {
        return Ext.Array.map(steps, function(step, i){
            return {
                text: i + 1, stepIndex: i + 1,
                bind: { disabled: '{!isEnabled}' },
                viewModel: {
                    formulas: {
                        isEnabled: function(get) {
                            return get('currentPosition') &gt; i;
                        }
                    }
                }
            };
        });
    }
});</pre></div><p>There's a surprising<a id="id494" class="indexterm"/> amount going on in this component. Remember <a id="id495" class="indexterm"/>that in the wizard panel, I set the <code class="literal">bind</code> config on this progress component to the questionnaire steps, and in the preceding code, you can see the custom steps configuration option—as long with the <code class="literal">defaultBindProperty</code>—that enables this.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Remember that <code class="literal">defaultBindProperty</code> allows you to avoid explicitly setting the property to bind to, and Ext JS will automatically use the default.</p></div></div><p>I'll skip over the <code class="literal">layout</code>, <code class="literal">cls</code>, and <code class="literal">defaultType</code> options and move on to the way I implemented <code class="literal">applySteps</code>. It builds an array of the following buttons:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The start button, which is always enabled</li><li class="listitem" style="list-style-type: disc">The number buttons for each step, which are only enabled if the user has advanced to that step</li><li class="listitem" style="list-style-type: disc">The end button, which is only enabled when the user is on the questionnaire conclusion</li></ul></div><p>The end button's disabled state is deferred to a binding on the parent view model. For the individual step icons, a simple view model with the <code class="literal">isEnabled</code> formula is used to toggle the disabled state based on the current active step pane.</p><p>When I was researching <a class="link" href="ch02.html" title="Chapter 2. MVC and MVVM">Chapter 2</a>, <em>MVC and MVVM</em>, I found a little snippet describing MVC in Smalltalk and the way that individual UI components would have their own controller right down to text fields and the like. While it's rare that we'd go that far in our Ext JS applications, the use of a small, one formula view model for the step icons reminded me of this concept.</p><p>My only gripe as I was writing it was that while the functionality was great, the syntax to just bind one property like this felt a little verbose. On the other hand, introducing another shorthand syntax would mean a new feature for Ext JS developers to learn; I think we have enough already!</p><p>A final point<a id="id496" class="indexterm"/> regarding this component is that I append <code class="literal">lineHtml</code> to the <a id="id497" class="indexterm"/>container and configure a couple of styling hooks. This allows for a thin line connecting the progress buttons; it's a minor visual element, but has a nice effect.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Step by step</h1></div></div></div><p>The next component to examine is<a id="id498" class="indexterm"/> the one that represents a step in the<a id="id499" class="indexterm"/> questionnaire and shows the associated questions:</p><div><pre class="programlisting">// packages/wizard/src/view/Step.js
Ext.define('Wizard.view.wizard.Step', {
    extend: 'Ext.form.Panel',
    xtype: 'wizard-step',
    cls: 'wizard-step',


    defaults: {
        labelSeparator: '', labelAlign: 'top',
        labelWidth: 250, msgTarget: 'side',
        width: '100%'
    },

    config: {
        step: null
    },

    modelValidation: true,

    applyStep: function(step) {
        
        this.add({
            xtype: 'container',
            cls: 'wizard-step-introduction',
            html: step.get('introduction')
        });

        step.questions().each(function(question) {
            this.add({
                xtype: question.get('type'),
                fieldLabel: question.get('questionText'),
                required: question.get('required'),
                bind: '{question.answer}',
                viewModel: 'progress-step'
            }).getViewModel().set('question', question);
        }, this);

        step.isValid();
    }
});</pre></div><p>There's the standard setup<a id="id500" class="indexterm"/> for <code class="literal">Ext.form.Panel</code> here, configuring <a id="id501" class="indexterm"/>labels, and so on. Once again, I created a custom step config that we bound to in the parent <code class="literal">Wizard</code> panel's <code class="literal">addStepPane</code> method and use the matching apply method to build out the contents of the form.</p><p>Note how I have set the <code class="literal">modelValidation</code> config to <code class="literal">true</code>. As a result of my prototype earlier in the chapter, I know that this is great way to avoid code duplication by creating validation on a model and have it take effect in the form UI. When building the questions for the step in <code class="literal">applyStep</code>, I make sure and bind <code class="literal">question.answer</code> to the form field value. This means that any validation on the question model's answer field will be applied to the form field UI automatically.</p><p>All of the other attributes of the form field are built dynamically from the question data, such as the label and the field type. The final thing to note here is that I use a separate view model and immediately populate it with the question. Look at the code for this view model:</p><div><pre class="programlisting">// packages/wizard/src/view/ProgressStepModel.js
Ext.define('Wizard.view.wizard.ProgressStepModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.progress-step',
    
    data: {
        question: null
    },

    formulas: {
        isValid: {
            bind: {
                bindTo: '{question}',
                deep: true
            },
            get: function() {
                return this.get('step').isValid();
            }
        }
    }
});</pre></div><p>It's nothing complicated; it's<a id="id502" class="indexterm"/> just a little bit long to define inline<a id="id503" class="indexterm"/> and so I moved it to a separate file. The code here should also look very familiar because it's the same as the code from my prototype that I showed earlier in the chapter under the heading "A Binding Trick". I knew this would come in useful!</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Questionnaire command and control</h1></div></div></div><p>Nearly all of the pieces are in place. Note <a id="id504" class="indexterm"/>that I used a lot of binding expressions in<a id="id505" class="indexterm"/> the <code class="literal">Wizard</code> component so far, but I haven't<a id="id506" class="indexterm"/> shown either the top-level view model or how the <a id="id507" class="indexterm"/>wizard deals with user interactions. I always like to keep controllers slim and the view controller here is no exception:</p><div><pre class="programlisting">// packages/wizard/src/view/WizardController.js
Ext.define('Wizard.view.wizard.WizardController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.wizard',
    listen: {
        component: {
            '#next': { click: 'onNextClick' },
            '#prev': { click: 'onPrevClick' },
            '#restart': { click: 'onRestartClick' },
            '#finish': { click: 'onFinishClick' },
            'wizard-progress button': { click: 'onStepClick' }
        }
    },

    onNextClick: function() {
        var current = this.getViewModel().get('currentPosition');
        this.getViewModel().set('currentPosition', current + 1);
    },

    onPrevClick: function() {
        var current = this.getViewModel().get('currentPosition');
        this.getViewModel().set('currentPosition', current - 1);
    },

    onRestartClick: function() {
        this.getViewModel().set('currentPosition', 0);
    },

    onFinishClick: function() {
        var q = this.getViewModel().get('questionnaire');
        this.fireEvent('wizardcomplete', q);
    },

    onStepClick: function(btn) {
        this.getViewModel().set('currentPosition', btn.stepIndex);
    }
}); </pre></div><p>The view <a id="id508" class="indexterm"/>controller listens for clicks on the navigation buttons and<a id="id509" class="indexterm"/> any enabled buttons on the progress bar, and in <a id="id510" class="indexterm"/>every case apart from <code class="literal">onFinishClick</code>, it <a id="id511" class="indexterm"/>manipulates the value of <code class="literal">currentStepIndex</code> on the view model. It doesn't have to speak to any other components, just this one value. I really like the elegance of this solution. We'll see how <code class="literal">currentStepIndex</code> influences the application when we review the wizard's view model.</p><p>The <code class="literal">onFinishClick</code> method is called when the user clicks on the finish button and raises a <code class="literal">controller-level</code> event called <code class="literal">wizardcomplete</code> with the completed questionnaire as its only argument. The host application can handle this event and retrieve the completed question data and dispose of the wizard component as it sees fit.</p><p>This is another good example of decoupling this component from its host; the wizard needs to know nothing about the application it's embedded inside. It just fires the event and forgets about it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec99"/>The wizard model</h1></div></div></div><p>The final, and in my opinion <a id="id512" class="indexterm"/>most important, part of the puzzle is <a id="id513" class="indexterm"/>the top-level view model. This is the one that the wizard panel uses directly and is available to all child components of the panel thanks to the view model inheritance. Here's the code:</p><div><pre class="programlisting">// packages/wizard/src/view/WizardModel.js
Ext.define('Wizard.view.wizard.WizardModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.wizard',

    data: {
        currentPosition: 0
    },

    formulas: {
        currentStep: function(get) {   
            var pos = get('currentPosition') – 1;
            return get('questionnaire').steps().getAt(pos);
        },

        stepCount: function(get) {
            return get('questionnaire').steps().count();
        },

        isIntroduction: function(get) {
            return get('currentPosition') === 0;
        },

        isNotLastStep: function(get) {
            return get('currentPosition') &lt; get('stepCount') + 1;
        },

        isNextEnabled: function(get) {
            // when current step is valid
            var stiv = get('currentStep') ? get('currentStep.valid') : true;

            // when not last step
            var last = get('isNotLastStep');

            return stiv &amp;&amp; last;
        }
    }
});</pre></div><p>Note that <code class="literal">currentPosition</code> is initialized at <code class="literal">0</code>, which represents the questionnaire introduction page in the UI and the first card in the wizard panel.</p><p>This one value is probably the most important in the whole application because it not only drives what is displayed on the UI through its binding to <code class="literal">activeItem</code> on the wizard panel, but also the state of the navigation and progress buttons. This is both direct—the progress component <a id="id514" class="indexterm"/>inherits and consumes <code class="literal">currentPosition</code> to <a id="id515" class="indexterm"/>set the disabled state of its buttons—and indirect, as in the way <code class="literal">isNextEnabled</code> uses it to get the <code class="literal">currentStep</code> model's validity and in turn is bound to the "next" navigation button.</p><p>Building up a couple of dependent formulae and allowing them to cascade down to child components gives a clear picture of how data flows from a single source (<code class="literal">questionnaire</code> and <code class="literal">currentPosition</code> on the wizard view model).</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec100"/>A delightful host</h1></div></div></div><p>The wizard is functionally<a id="id516" class="indexterm"/> complete and it's time to show how we can embed it in an application. Look back and you'll see that the main wizard component had the following <code class="literal">load</code> method:</p><div><pre class="programlisting">load: function(id) {
    this.getViewModel().setLinks({
        questionnaire: {
            type: 'Wizard.model.Questionnaire',
            id: id
        }
    });
}</pre></div><p>This uses the <code class="literal">links</code> feature of the view model to trigger the loading of a questionnaire using its preconfigured proxy. With this in mind, the calling code could look like this:</p><div><pre class="programlisting">Ext.define('Questions.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    requires: [
        'Wizard.view.wizard.Wizard'
    ],

    alias: 'controller.main',

    listen: {
        controller: {
            'wizard': {
                'wizardcomplete': function(q) {
                    console.log(q);
                }
            }
        }
    },

    onClickButton: function () {
        this.wizard = Ext.create('Ext.Window', {
            header: false, modal: true, layout: 'fit',
            autoShow: true, resizable: false,
            width: 800, height: 600, 
            items: [{ xtype: 'wizard' }],
        });

        this.wizard.down('wizard').load(1);
    }
});</pre></div><p>When <code class="literal">onClickButton</code> handler fires, <code class="literal">Ext.Window</code> is created containing our wizard component, and we then call the <code class="literal">load</code> method on the wizard itself, passing the ID of the questionnaire to<a id="id517" class="indexterm"/> load.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>Remember to include the wizard package in your application's <code class="literal">app.json</code>, as discussed earlier in the chapter.</p></div></div><p>The view controller also listens for the <code class="literal">wizardcomplete</code> event and can use this to get the completed questionnaire instance for further processing and could also close the wizard window. These two integration points are all that a developer needs to use the wizard in their own application, but there's one last thing that I wanted to explore when building this component: <code class="literal">theming</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Mixin the night away</h1></div></div></div><p>I wanted consumers of the <a id="id518" class="indexterm"/>wizard component to be able to customize it, but this<a id="id519" class="indexterm"/> turned out to be very simple in most cases. As the main container for the wizard is a subclass of <code class="literal">Ext.Panel</code>, all of the relevant SCSS variables for this class can be overridden and it'll take effect for the wizard's container too.</p><p>However, I wanted to create a custom look for the progress bar and in turn allow end users to customize it. To this end, I wrote a custom mixin:</p><div><pre class="programlisting">// packages/wizard/sass/src/Wizard/view/wizard/Progress.scss
@mixin wizard-progress-ui(
    $ui: null,
    $ui-border-color: #2163A3,
    $ui-background-color: #ffffff,
    $ui-button-border-width: 4px,
    $ui-button-border-radius: 20px
) {
    .wizard-progress-#{$ui} {
        padding: 10px 0;

        .#{$prefix}btn:last-child {
            margin-left: 20px;
            margin-right: 0px;
        }

        .#{$prefix}btn {
            margin: 0 10px;
        }

        .#{$prefix}btn:first-child {
            margin-right: 20px;
            margin-left: 0px;
        }

        @include extjs-button-small-ui(
            $ui: 'default',
            $border-radius: $ui-button-border-radius,
            $border-width: $ui-button-border-width,
            $background-color: $ui-background-color,
            $background-color-disabled: mix($ui-border-color, $ui-background-color, 50%),
            $border-color: $ui-border-color,
            $color: black,
            $color-disabled: shade($ui-border-color, 50%),
            $opacity-disabled: 0.9999,
            $inner-opacity-disabled: 0.9999
        );

        .wizard-progress-bar {
            width: 100%;
            background: $ui-border-color;
            height: $ui-button-border-width * 1.5;
            position: absolute;
            top: 50%;
            margin-top: -(($ui-button-border-width * 1.5) / 2);
        }
    }
}

@include wizard-progress-ui(
    $ui: 'default'
);</pre></div><p>The mixin accepts<a id="id520" class="indexterm"/> four <a id="id521" class="indexterm"/>variables, each with a default value:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$ui-border-color</code>: <code class="literal">#2163A3</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$ui-background-color</code>: <code class="literal">#ffffff</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$ui-button-border-width</code>: <code class="literal">4px</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$ui-button-border-radius</code>: <code class="literal">20px</code></li></ul></div><p>With this, not only can I style the component, but developers can also call this mixin from their own code and override colors and borders. As the mixin bases a lot of its other styles on values calculated from these variables, the various colors and sizes should always stay in keeping with these variables. For example, the following customization would result in a progress bar with thinner and less round borders with a pink coloring:</p><div><pre class="programlisting">@include wizard-progress-ui(
    $ui: 'default',
    $ui-border-color: #ff69b4,
    $ui-background-color: #ffffff,
    $ui-button-border-width: 1px,
    $ui-button-border-radius: 4px
);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec102"/>Summary</h1></div></div></div><p>In previous chapters, we walked through the design and creation of a series of applications in a formal manner, using a series of diagrams to illustrate the process. This time, I tried to give a glimpse of some of the ways I would build the system architecture and some of the techniques I use day-to-day.</p><p>In addition, we saw how a view model can become the primary point from which data flows through an application, cascading through child view models and child components, and triggering multiple UI updates via binding.</p><p>We revisited styling and showed how the Ext JS theming system allows you to build reusable mixins that give us the same modularity in our SASS code as we have in our JavaScript classes.</p><p>In the next chapter, we'll be writing a shopping application for tablet device that allows users to browse and buy items from an online store. It'll be our most complicated application yet, which marries all of the different ideas and techniques we've discussed so far.</p></div></body></html>