["```js```", "````js` `public async getAllHandler(req: Request, res: Response) {}`    `public async getOneHandler(req: Request, res: Response) {}`    `public async updateHandler(req: Request, res: Response) {}`    `public async deleteHandler(req: Request, res: Response) {}`    `}`    In this context, the ``**addHandler**`**`** method captures the data provided within the incoming request body. Subsequently, it forwards this data to the Base service by invoking the create method, which is responsible for adding the information to the database. The Base service then returns a response to this handler, signifying either a successful or unsuccessful outcome. This response is effectively transmitted as the ultimate outcome for the associated REST API operation.    Now call `**addHandler**` in role routes with change in `**roles_router.ts**` file as follows:    `//roles_router.ts`    `export class RoleRoutes {`    `private baseEndPoint = '/api/roles';`    `constructor(app: Express) {`    `const controller = new RoleController();`    `app.route(this.baseEndPoint)`    `.post(validate(validRoleInput), controller.addHandler);`    `}`    We have established routes for adding roles and incorporated middleware to validate requests before inserting data into the database.    You can test the REST APIs in Postman, cURL, or .http file with the following request and get their responses. The easiest method is to simply use VSCode, install REST Client extension, and create a new file with the .http extension and put the request as shown in *[Figure 5.1](#fig5_1)*:  ![](img/5.1.jpg)  **Figure 5.1:** Making a request using VSCode REST Client Extension    For testing the API for adding a role, we need to make a `**POST**` call to `**/api/roles**`. The preceding figure shows the way it can be called with the request body.    **REST API Add Role**    **Request**    `URL : http://127.0.0.1:3000/api/roles`    `Method: POST`    `body :`    `{`    `\"name\":\"Super Admin\",`    `\"description\":\"Having All Rights\",`    `\"rights\": \"add_role,edit_role,get_all_roles,get_details_role,`    `delete_role,`    `add_user,edit_user,get_all_users,get_details_user,delete_user,`    `add_project,edit_project,get_all_projects,get_details_project,`    `delete_project,add_task,edit_task,get_all_tasks,get_details_task,`    `delete_task,add_comment,edit_comment,get_all_comments,`    `get_details_comment,delete_comment\"`    `}`    **Response**    `{`    `\"statusCode\": 201,`    `\"status\": \"success\",`    `\"data\": {`    `\"role_id\": \"b88cc70d-ab0a-4464-9562-f6320df519f6\",`    `\"name\": \"Super Admin\",`    `\"description\": \"Having All Rights\",`    `\"rights\": \"add_role,edit_role,get_all_roles,get_details_role,`    `delete_role,add_user,edit_user,get_all_users,get_details_user,`    `delete_user,add_project,edit_project,get_all_projects,`    `get_details_project,delete_project,add_task,edit_task,get_all_tasks,`    `get_details_task,delete_task,add_comment,edit_comment,`    `get_all_comments,get_details_comment,delete_comment\",`    `\"created_at\": \"2023-08-16T16:39:14.047Z\",`    `\"updated_at\": \"2023-08-16T16:39:14.047Z\"`    `}`    `}`    In case of a unique role name, trying again with the same request gives an error as 409 conflict code:    `{`    `\"statusCode\": 409,`    `\"status\": \"error\",`    `\"message\": \"Key (name)=(Super Admin) already exists.\"`    `}`    In another case, if you change the rights as \"`**rights**`\"`**:**`\"`**no_rights**`\", it gives an error for Bad Request with 400 status as follows:    `{`    `\"statusCode\": 400,`    `\"status\": \"error\",`    `\"errors\": [`    `{`    `\"rights\": \"Invalid permission\"`    `}`    `]`    `}`    # [GetAll Roles](toc.xhtml#s150a)    Once a role has been successfully added to the database, we can proceed to retrieve the newly inserted roles from the database. So, let's change the `**getAllHandler**` method in the `**roles_controller.ts**` file using the following code:    `// roles_controller.ts`    `public async getAllHandler(req: Request, res: Response): Promise<void> {`    `const service = new RolesService();`    `const result = await service.findAll(req.query);`    `res.status(result.statusCode).json(result);`    `}`    The ``**getAllHandler**`**`** method uses the `**RolesService**` class to retrieve all roles from the database based on the query parameters in the request. The resulting data is then sent back to the client with an appropriate HTTP status code and formatted as JSON.    This `**controller**` method call in routes with change in `**roles_routes.ts**` as follows:    `// roles_routes.ts`    `app.route(this.baseEndPoint)`    `.post(validate(validRoleInput), controller.addHandler)`    `.get(controller.getAllHandler);`    By employing this approach, we establish a `**GET**` route that fetches all roles stored in the database, effectively functioning as a REST API endpoint for retrieving role data.    **REST API GetAll Roles**    **Request**    `URL : http://127.0.0.1:3000/api/roles`    `Method: GET`    `Query Params: {}`    **Response**    `{`    `\"statusCode\": 200,`    `\"status\": \"success\",`    `\"data\": [`    `{`    `\"role_id\": \"b88cc70d-ab0a-4464-9562-f6320df519f6\",`    `\"name\": \"Super Admin\",`    `\"description\": \"Having All Rights\",`    `\"rights\": \"add_role,edit_role,get_all_roles,get_details_role,delete_role,add_user,edit_user,get_all_users,get_details_user,`    `delete_user,add_project,edit_project,get_all_projects,`    `get_details_project,delete_project,add_task,edit_task,`    `get_all_tasks,get_details_task,delete_task,add_comment,`    `edit_comment,get_all_comments,get_details_comment,delete_comment\",`    `\"created_at\": \"2023-08-16T16:39:14.047Z\",`    `\"updated_at\": \"2023-08-16T16:39:14.047Z\"`    `}, {`    `\"role_id\": \"5f11a06b-e9a7-438d-9f49-757e8239e238\",`    `\"name\": \"visitor\",`    `\"description\": null,`    `\"rights\": null,`    `\"created_at\": \"2023-08-15T13:04:50.314Z\",`    `\"updated_at\": \"2023-08-15T13:04:50.314Z\"`    `}`    `]`    `}`    If you want to filter or search by exact name, you can change query params as follows:    `URL : http://127.0.0.1:5000/api/roles?name=visitor`   ````", "```` `It gives only matched data as a response, as follows`   ```js````", "```js```", "```js```", "```js```", "````` `const result = await service.update(req.params.id, user);`    `if (result.statusCode === 200) {`    `delete result.data.password;`    `}`    `res.status(result.statusCode).json(result);`    `return;`    `}`    `}`    The `**updateHandler**` function is intended to handle the updating of a user in the database.    It operates by retrieving data from the incoming HTTP request body, which is then utilized to update the corresponding role data in the database based on the user's unique identifier (`**user_id**`) as request parameter ID. The function subsequently generates a response indicating whether the update operation was successful or unsuccessful, providing details about the updated data or an appropriate error message if needed. We will never send a password data response, so delete that field from the response.    To update a user's time, we just need to validate that the `**role_ids**` are proper. So, perform the validation as follows:    `const updateValidUserInput = [`    `body('role_ids').isArray().withMessage('It must be an array of uuids of roles')`    `.custom((value: string[]) => {`    `if (value?.length > 0 && value instanceof Array) {`    `const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;`    `const isValid = value?.every(uuid => uuidPattern.test(uuid.trim()));`    `if (!isValid) {`    `throw new Error('It has invalid uuids for role');`    `}`    `}`    `return true; // Validation passed`    `})`    `];`    This method is called from the routes file by creating a new route for it as follows:    `app.route(this.baseEndPoint + '/:id')`    `.all(authorize) // Apply authorization middleware to all routes under this endpoint`    `.get(controller.getOneHandler)`    `.put(validate(updateValidUserInput), controller.updateHandler);`    **REST API Update User**    **Request**    `URL: http://127.0.0.1:3000/api/users/d166945a-f85d-485c-bdac-0c8056b3188a`    `Method: PUT`    `body :`    `{`    `\"fullname\":\"Yami Panchal\",`    `\"role_ids\":[\"b88cc70d-ab0a-4464-9562-f6320df519f6\"]`    `}`    **Response**    `{`    `\"statusCode\": 200,`    `\"status\": \"success\",`    `\"data\": {`    `\"fullname\": \"Yami Panchal\",`    `\"username\": \"yamini\",`    `\"email\": \"yamipanchal1993@gmail.com\",`    `\"created_at\": \"2023-08-18T17:57:38.744Z\",`    `\"updated_at\": \"2023-08-24T16:57:19.110Z\",`    `\"role_ids\": [`    `\"b88cc70d-ab0a-4464-9562-f6320df519f6\"`    `],`    `\"user_id\": \"d166945a-f85d-485c-bdac-0c8056b3188a\"`    `}`    `}`    Providing a valid role ID will yield a successful response, while inputting an ID that doesn't correspond to an existing database entry will result in a `**404 error**`, signifying that the requested entity was `**Not found**`.    `{`    `\"statusCode\": 404,`    `\"status\": \"error\",`    `\"message\": \"Not Found\"`    `}`    # [Delete User](toc.xhtml#s166a)    The `**delete**` functionality for users in a REST API involves the removal of a specific user from the database. This process is managed through an endpoint dedicated to user deletion. When a request is made to this endpoint, it triggers a function that handles the deletion process. The incoming request typically contains the unique identifier (`**user_id**`) of the user that needs to be deleted.    To implement the `**Delete User**` API, make the following changes in the `**deleteHandler**` code in the user controller:    `public async deleteHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req.user.rights, 'delete_user')) {`    `res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });`    `return;`    `}`    `const service = new UsersService();`    `const result = await service.delete(req.params.id);`    `res.status(result.statusCode).json(result);`    `return;`    `}`    The `**deleteHandler**` processes the request by utilizing a service that interacts with the database. This service is responsible for executing the deletion operation. If the requested user exists in the database and the deletion is successful, the function responds with a success message and an appropriate status code, such as `**200 OK**`. If the role does not exist, the function returns an error response with a status code of `**404 Not Found**`, indicating that the user was not located in the database.    This method is called from the routes file by creating a new route for it as follows:    `app.route(this.baseEndPoint + '/:id')`    `.all(authorize)`    `.get(controller.getOneHandler)`    `.put(validate(updateValidUserInput), controller.updateHandler)`    `.delete(controller.deleteHandler);`    Here, `**/:id**` will be a request parameter meant to capture the ID of the role that the user wants to delete.    **REST API Delete Role**    **Request**    `URL: http://127.0.0.1:3000/api/users/5f11a06b-e9a7-438d-9f49-757e8239e238`    `Method: DELETE`    **Response**    `{`    `\"statusCode\": 200,`    `\"status\": \"success\"`    `}`    In case of already deleted or not exist in database:    `{`    `\"statusCode\": 404,`    `\"status\": \"error\",`    `\"message\": \"Not Found\"`    `}`    # [Password Management](toc.xhtml#s167a)    Password Management involves implementing strategies and practices to secure and effectively manage user passwords within digital systems. This encompasses various methods to ensure the confidentiality and integrity of user passwords, as well as enabling users to securely create, update, and recover their passwords. Effective password management is vital for safeguarding sensitive data, preventing unauthorized access, and maintaining the overall security posture of an application or system.    # [Change Own Password](toc.xhtml#s168a)    During the user information update process, it's been observed that for security reasons, password modifications are not carried out within the same API. Therefore, a distinct API will be developed to address this security concern.    Now, create one method in the `**users_controller.ts**` file for `**changePassword**` as follows:    `// users_controller.ts`    `public async changePassword(req: Request, res: Response): Promise<void> {`    `const { oldPassword, newPassword } = req.body;`    `const service = new UsersService();`    `const findUserResult = await service.findOne(req.params.id);`    `if (findUserResult.statusCode !== 200) {`    `res.status(404).send({ statusCode: 404, status: 'error', message: 'User Not Found' });`    `return;`    `}`    `const user = findUserResult.data;`    `// check requested user_id and session user_id is same`    `if (user?.username !== req.user.username) {`    `res.status(400).send({ statusCode: 400, status: 'error', message: 'User can change only own password' });`    `return;`    `}`    `// verify old password is valid`    `const comparePasswords = await bcryptCompare(oldPassword, user.password);`    `if (!comparePasswords) {`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'oldPassword is not matched' });`    `return;`    `}`    `// Encrypt the user's new password`    `user.password = await encryptString(newPassword);`    `const result = await service.update(req.params.id, user);`    `if (result.statusCode === 200) {`    `res.status(200).json({ statusCode: 200, status: 'success', message: 'Password is updated successfully' });`    `return;`    `} else {`    `res.status(result.statusCode).json(result);`    `return;`    `}`    `}`    The `**changePassword**` function ensures that the user requesting the password change is authorized to do so, verifies the old password, securely encrypts the new password, and updates the user's password in the database.    This method is called from the `**users_routes.ts**` file, so add the following code to the route file:    `// users_routes.ts`    `const validChangePassword = [`    `body('oldPassword').trim().notEmpty().withMessage('It should be`    `required'),`    `body('newPassword')`    `.isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length')`    `.isStrongPassword({ minLowercase: 1, minUppercase: 1,`    `minSymbols: 1, minNumbers: 1 })`    `.withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.'), body('role_ids'),`    `];`    `app.route(this.baseEndPoint + '/changePassword/:id')`    `.all(authorize)`    `.post(validate(validChangePassword), controller.`    `changePassword);`    It will validate old and new Passwords with authorization.    **REST API Change Own Password**    **Request**    `URL: http://127.0.0.1:5000/api/users/changePassword/b930d02c-43af-4875-b7e9-546c9f4c23dd`    `Method: POST`    `body :`    `{`    `\"oldPassword\":\"Admin@pms1\",`    `\"newPassword\":\"Admin@pms123\"`    `}`    **Response**    `{`    `\"statusCode\": 200,`    `\"status\": \"success\",`    `\"message\": \"Password is updated successfully\"`    `}`    In case of a wrong `**oldPassword**` sent in a request, the server will respond with the following error message:    `{`    `\"statusCode\": 400,`    `\"status\": \"error\",`    `\"message\": \"oldPassword is not matched\"`    `}`    Similarly, if a wrong `**newPassword**` is sent in the request then it will result in a 400 error code, as follows:    `{`    `\"statusCode\": 400,`    `\"status\": \"error\",`    `\"errors\": [`    `{`    `\"newPassword\": \"It should include at least one uppercase`    `letter, one lowercase letter, one special symbol, and one numerical digit.\"`    `}`    `]`    `}`    In another case, if the `**user_id**` in the request URL does not match the access token passed in the Authorization, then it gives the following response:    `{`    `\"statusCode\": 400,`    `\"status\": \"error\",`    `\"message\": \"User can change only own password\"`    `}`    In this manner, users can effortlessly change their password successfully.    # [Recover Password](toc.xhtml#s169a)    The password recovery process provides a crucial safety net for users who have forgotten their account credentials or need to reset their passwords. By offering a reliable and secure way to regain access to their accounts, this feature enhances user experience and maintains the integrity of your application's security.    The password recovery process will be divided into two distinct steps. The first step involves the `**Forgot Password**` functionality, which triggers the sending of a reset link to the user's email address. In the second step, users will be able to reset their password by validating the reset link's token, thereby granting them access to set a new password.    **Forgot Password**    For sending mail to the user on forgot password, we need to install the `**nodemailer**` package. So, open the terminal with the root directory and paste the following command:    `npm install nodemailer --save`    `npm install @types/nodemailer -D`    For sending mail, you need to set up a Gmail account. If you don't have one, then create an account and afterward follow these steps:    1.  **Sign in to your Google Account**:          Start by signing in to the Gmail account from which you want to send emails using Nodemailer.           2.  **Access Security Settings**:          Click your profile picture or initials in the top-right corner of the Gmail interface. From the drop-down menu, select `**Manage your Google Account**`.           3.  **Navigate to Security**:          In the Google Account settings, navigate to the left sidebar and click `**Security**`.           4.  **App Passwords**:          Scroll down to the `**Signing in to Google**` section and find the `**App passwords**` option. Click `**App passwords**`.           5.  **Generate App Password**:          You may need to verify your identity using your Google Account password. Once verified, you'll be able to generate an app-specific password.               1.  Choose the app for which you want to generate the password. Select `**Mail**` if it's not listed and choose `**Other (Custom Name)**`.     2.  Enter a custom name for your app-specific password (for example, `**Nodemailer App**`). Click `**Generate**`.     3.  Copy the App Password:                  Google will generate a unique app-specific password for your application. Copy this password and keep it secure.                   6.  **Use App Password in Your Code:**          Replace the regular password in your code with the app-specific password you generated. This app-specific password will be used to authenticate your application with Gmail's SMTP server.              Keep in mind that app-specific passwords are only shown once when generated. If you lose the password or need to generate a new one, you'll need to repeat the process.    Now add `**email_configs**` and front URL in `**config.ts**`:    `// config.ts`    `export interface IServerConfig {`    `port: number;`    `db_config: {`    `'db': string;`    `'username': string;`    `'password': string;`    `'host': string;`    `'port': number;`    `'dbname': string;`    `};`    `email_config: {`    `'from': string;`    `'user': string;`    `'password': string;`    `};`    `front_app_url: string;`    `}`    Also, provide actual values in `**server_config.json**` file:    For example:    `\"email_config\": {`    `\"from\": \"pms-support@pms.com\",`    `\"user\": \"pmsbook2023@gmail.com\",`    `\"password\": \"*************\"`    `},`    `\"front_app_url\": \"http://127.0.0.1:5000\"`    After that, create `**email_util.ts**` in the utils directory using the following code:    `[https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/email_util.ts](https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/email_util.ts)`    The `**sendMail**` function provides a way to send emails using Gmail's SMTP server through Nodemailer. Make sure to replace the Gmail email, password, and other configurations with your actual values and customize the email content as needed.    For the `**Forgot Password**` feature, users will initiate the process by submitting their email address. To facilitate this, we will enhance the `**UsersUtil**` with a function named `**getUserByEmail**`, responsible for retrieving user information based on their email. Here's the modified `**UsersUtil**` with the added function:    `export class UsersUtil {`    `// … Existing methods and functionalities …`    `public static async getUserByEmail(email: string) {`    `try {`    `if (email) {`    `const service = new UsersService();`    ``const users = await service.customQuery(`email = '${email}'`);``    `if (users && users.length > 0) {`    `return users[0];`    `}`    `}`    `} catch (error) {`    ``console.error(`Error while getUserFromToken() => ${error.message}`);``    `}`    `return null;`    `}`    `// … Other methods …`    `}`    Now create forgot password function in the `**users_controller.ts**` file as follows:    `// users_controller.ts`    `public async forgotPassword(req: Request, res: Response): Promise<void> {`    `const { email } = req.body;`    `const emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;`    `if (!emailPattern.test(email)) {`    `res.status(400).send({ statusCode: 400, status: 'error', message: 'Invalid email' });`    `return;`    `}`    `const user: Users = await UsersUtil.getUserByEmail(email);`    `if (!user) {`    `res.status(404).send({ statusCode: 404, status: 'error', message: 'User Not Found' });`    `return;`    `}`    `// Generate a reset token for the user`    `const resetToken: string = jwt.sign({ email: user.email },`    `SERVER_CONST.JWTSECRET, {`    `expiresIn: '1h',`    `});`    `// Generate the reset link`    ``const resetLink = `${config.front_app_url}/reset-password?``    ``token=${resetToken}`;``    `const mailOptions = {`    `to: email,`    `subject: 'Password Reset',`    ``html: ` Hello ${user.username},<p>We received a request to reset your password. If you didn't initiate this request, please ignore this email.</p>``    `<p>To reset your password, please click the link below:</p>`    `<p><a href=\"${resetLink}\" style=\"background-color: #007bff; color: #ffffff; text-decoration: none; padding: 10px 20px; border-radius: 5px; display: inline-block;\">Reset Password</a></p>`    `<p>If the link doesn't work, you can copy and paste the`    `following URL into your browser:</p>`    `<p>${resetLink}</p>`    `<p>This link will expire in 1 hour for security reasons.</p>`    `<p>If you didn't request a password reset, you can safely ignore this email.</p>`    ``<p>Best regards,<br>PMS Team</p>`,``    `};`    `const emailStatus = await sendMail(mailOptions.to, mailOptions.subject, mailOptions.html);`    `if (emailStatus) {`    `res.status(200).json({ statusCode: 200, status: 'success', message: 'Reset Link sent on your mailId', data: { 'resetToken':`    `resetToken } });`    `} else {`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'something went wrong try again' });`    `}`    `return;`    `}`    The `**forgotPassword**` function takes the user's email from the request body. It attempts to retrieve a user using the `**getUserByEmail**` function from `**UsersUtil**`. If no user is found, a `**404**` response is sent, indicating \"`**User Not Found**`.\" If a user is found, a reset token is generated using JWT with the user's email and a one-hour expiration. A reset link is composed using the front-end application URL and the generated reset token. An email template is constructed with the reset link and instructions for the user. The `**sendMail**` function is called to send the email, including recipient, subject, and HTML content. If the email is successfully sent, a `**200**` response is sent with a success message and the reset token. If sending the email fails, a `**400**` response is sent with an error message.    This function is called from `**users_routes.ts**`, let's create a route for it:    `// users_routes.ts`    `export class UserRoutes {`    `//Other routes`    `…`    `app.route('/api/forgot_password')`    `.post(controller.forgotPassword);`    `}`    **REST API Forgot Password**    **Request**    `URL: http://127.0.0.1:3000/api/forgot_password`    `Method: POST`    `body: {`    `\"email\":\"yamipanchal1993@gmail.com\"`    `}`    **Response**    `{`    `\"statusCode\": 200,`    `\"status\": \"success\",`    `\"message\": \"Reset Link sent on your mailId\",`    `\"data\": {`    `\"resetToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJpYXQiOjE2OTMxNTU0MDIsImV4cCI6MTY5MzE1OTAwMn0.dM10tE43CSt8nArHjgHxRElk3IRBmdd_NHqpL5f1viU\"`    `}`    `}`    In case, if email is not passed or the requested email has no user, the server will respond with a `**400**` and `**404**` status code, respectively.    For example:    `{`    `\"statusCode\": 404,`    `\"status\": \"error\",`    `\"message\": \"User Not Found\"`    `}`    When successfully sent, the mail will look like the following:  ![](img/5.6.jpg)  **Figure 5.6:** Forgot Mail Sent Output    **Note:** In the context of the `**Forgot Password**` functionality, please note that the inclusion of the `**resetToken**` in the API response is solely for explanatory purposes. In actual practice, it is not recommended to provide the `**resetToken**` in the API response for security reasons.    # [Reset Password](toc.xhtml#s170a)    Reset password is based on the rest token given in the forgotten password. Upon clicking the reset link, users are directed to a secure web page where they can enter their new password. This page confirms the validity of the token and prompts them to create a strong password that adheres to the platform's security requirements. On the backend side, the API first validates the request token and password. If it is valid, then only the password will be reset.    Create method for `**resetPassword**` in the `**users_controller.ts**` file as follows:    `// users_controller.ts`    `public async resetPassword(req: Request, res: Response): Promise<void> {`    `const { newPassword, token } = req.body;`    `const service = new UsersService();`    `let email;`    `try {`    `const decoded = jwt.verify(token, SERVER_CONST.JWTSECRET);`    `if (!decoded) {`    `throw new Error('Invalid Reset Token');`    `}`    `email = decoded['email'];`    `} catch (error) {`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'Reset Token is invalid or expired' }).end();`    `return;`    `}`    `try {`    `const user = await UsersUtil.getUserByEmail(email);`    `if (!user) {`    `res.status(404).json({ statusCode: 404, status: 'error', message: 'User not found' }).end();`    `return;`    `}`    `// Encrypt the user's new password`    `user.password = await encryptString(newPassword);`    `const result = await service.update(user.user_id, user);`    `if (result.statusCode === 200) {`    `res.status(200).json({ statusCode: 200, status:`    `'success', message: 'Password updated successfully' });`    `} else {`    `res.status(result.statusCode).json(result).end();`    `}`    `} catch (error) {`    ``console.error(`Error while resetPassword =>``    ``${error.message}`);``    `res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal Server error' }).end();`    `}`    `}`    The `**resetPassword**` extracts the `**newPassword**` and token from the request body. It attempts to decode the token using JWT. If decoding the token fails, a `**400**` response is sent with an `**Invalid Reset Token**` error. If decoding the token succeeds, the function attempts to retrieve the user using the decoded email from the token. If no user is found, a `**404**` response is sent with a “User not found” error. If a user is found, the new password is encrypted and assigned to the user's password property. The update method of `**UsersService**` is called to update the user's information in the database. If the update is successful (status code `**200**`), a `**200**` response is sent with a success message. If the update fails, the response status and result are based on the result of the update operation. In case of any error during the process, a `**500**` response is sent with an “Internal Server Error” message.    This function is initiated from `**users_routes.ts**` as follows:    `const validResetPassword = [`    `body('token').trim().notEmpty().withMessage('It should be required'),`    `body('newPassword')`    `.isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length')`    `.isStrongPassword({ minLowercase: 1, minUppercase: 1,`    `minSymbols: 1, minNumbers: 1 })`    `.withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.'), body('role_ids'),`    `];`   ```js` `export class UserRoutes {`   ``` `//Other routes`    `…`    `app.route('/api/reset_password')`    `.post(validate(validResetPassword),`    `controller.resetPassword);`    `}`    **REST API Reset Password**    **Request**    `URL: http://127.0.0.1:3000/api/reset_password`    `Method: POST`    `body: {`    `\"newPassword\":\"Pmsbook@123\",`    `\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\\. eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJpYXQiOjE2OTMwNzc1MTYsImV4cCI6MTY5MzA4MTExNn0.tAJgxypxNm5-xVgQtusLFiYomzax2-HQSGYPBNQUtk4\"`    `}`    **Response**    `{`    `statusCode: 200, status: 'success', message: 'Password updated successfully'`    `}`    `In case of token is not valid or expired, it gives 400 error as follows:`   `` `{`    `\"statusCode\": 400,`    `\"status\": \"error\",`    `\"message\": \"Reset Token is invalid or expired\"`    `}`    Effective password management is paramount for user security. Implementing strong encryption, token-based resets, and clear policies fortifies protection and enhances user trust. We follow that standard kind of flow for password management.    # [Conclusion](toc.xhtml#s171a)    In this chapter, we covered a common base service for database operation and a base controller to perform REST API CRUD operations and other utility functions. We implemented the whole Role and User management with input validations for the PMS application. In addition, we also learned to send email functionality. In the next chapter, we will learn about the project and task core functionality of the PMS application. `` ```js ```` ```js`` `````", "``````js` ``````", "``````js``` ``````", "```` ```js````"]