<html><head></head><body>
<div id="_idContainer014" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor095" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor096" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Leveraging Behavioral Design Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Behavioral design patterns help to organize communication between objects. </span><span class="kobospan" id="kobo.3.2">This includes the ability to extend functionality without modifying these existing classes. </span><span class="kobospan" id="kobo.3.3">By implementing the behavioral design patterns covered in this chapter and how they’re used in the JavaScript ecosystem, we’ll learn to build JavaScript applications that can be extended without touching </span><span><span class="kobospan" id="kobo.4.1">existing functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">We’ll cover the following topics in </span><span><span class="kobospan" id="kobo.6.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">An understanding of the behavioral design </span><span><span class="kobospan" id="kobo.8.1">pattern classification</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">An implementation of the observer pattern and how the common Web </span><strong class="source-inline1"><span class="kobospan" id="kobo.10.1">EventTarget</span></strong><span class="kobospan" id="kobo.11.1"> API </span><span><span class="kobospan" id="kobo.12.1">exposes it</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Implementations of the state and strategy pattern, both with a class-based approach and a </span><span><span class="kobospan" id="kobo.14.1">function-based approach</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.15.1">A simplified visitor example, as well as common usage for the visitor pattern in the </span><span><span class="kobospan" id="kobo.16.1">JavaScript ecosystem</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.17.1">By the end of this chapter, you’ll be able to leverage behavioral design patterns in JavaScript to scale your code base and expose extension points </span><span><span class="kobospan" id="kobo.18.1">for functionality.</span></span></p>
<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor097" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.19.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.20.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.21.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor098" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.23.1">What are behavioral design patterns?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">Communicating between objects</span><a id="_idIndexMarker112" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.25.1"> is key to building software. </span><span class="kobospan" id="kobo.25.2">Behavioral design patterns help us organize this communication and usually decouple the possible implementations from other objects. </span><span class="kobospan" id="kobo.25.3">This makes us more able to extend our </span><span><span class="kobospan" id="kobo.26.1">code base.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">Behavioral design patterns help us follow the open/closed principle, where we can extend functionality without modifying the existing </span><span><span class="kobospan" id="kobo.28.1">implementation modules.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">All the patterns we’ll cover allow us to “add functionality” without modifying the existing consumer/concrete implementation. </span><span class="kobospan" id="kobo.29.2">In large software code bases, this is useful, since it means we can limit the scope of changes and lower the risk of breaking existing functionality. </span><span class="kobospan" id="kobo.29.3">We’re able to effectively de-correlate “adding functionality” from “changing the existing code for other unrelated functionality,” and new features and behaviors can be added without having to do modifications to </span><span><span class="kobospan" id="kobo.30.1">existing consumers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">With behavioral design patterns, new behaviors can be purely</span><a id="_idIndexMarker113" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.32.1"> additive. </span><span class="kobospan" id="kobo.32.2">The observer pattern allows multiple decoupled consumers (also called listeners). </span><span class="kobospan" id="kobo.32.3">With the state, strategy, and visitor patterns, new implementations and transitions can be added without interfering with the </span><span><span class="kobospan" id="kobo.33.1">existing ones.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">In the next section, we’ll look at our first behavioral design pattern, the observer pattern </span><span><span class="kobospan" id="kobo.35.1">in JavaScript</span><a id="_idTextAnchor099" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.36.1">.</span></span></p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor100" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.37.1">The observer pattern in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">The observer pattern</span><a id="_idIndexMarker114" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.39.1"> allows an object (the observable or subject) to maintain a list of other objects that depend on it (observers). </span><span class="kobospan" id="kobo.39.2">When a state update occurs in the subject, such as an entity object being created or updated, it notifies </span><span><span class="kobospan" id="kobo.40.1">the observer</span><a id="_idTextAnchor101" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor102" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.41.1">s.</span></span></p>
<h2 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor103" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.42.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">A sample use case for the observer pattern</span><a id="_idIndexMarker115" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.44.1"> is an in-memory queue. </span><span class="kobospan" id="kobo.44.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.45.1">Queue</span></strong><span class="kobospan" id="kobo.46.1"> instance will have the </span><strong class="source-inline"><span class="kobospan" id="kobo.47.1">subscribe</span></strong><span class="kobospan" id="kobo.48.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.49.1">unsubscribe</span></strong><span class="kobospan" id="kobo.50.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.51.1">notify</span></strong></span><span><span class="kobospan" id="kobo.52.1"> methods.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.53.1">subscribe</span></strong><span class="kobospan" id="kobo.54.1"> will add an additional “handler” function, </span><strong class="source-inline"><span class="kobospan" id="kobo.55.1">unsubscribe</span></strong><span class="kobospan" id="kobo.56.1"> will remove a particular “handler” function if it has been registered, and finally, </span><strong class="source-inline"><span class="kobospan" id="kobo.57.1">notify</span></strong><span class="kobospan" id="kobo.58.1"> will call each handler with a “message” payload. </span><span class="kobospan" id="kobo.58.2">This is the “notification of the observers” piece, where the observable or subject ensures that each registered observer </span><span><span class="kobospan" id="kobo.59.1">is notified.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.60.1">subscribe</span></strong><span class="kobospan" id="kobo.61.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.62.1">unsubscribe</span></strong><span class="kobospan" id="kobo.63.1"> turn “observer” functionality on and off, respectively. </span><strong class="source-inline"><span class="kobospan" id="kobo.64.1">subscribe</span></strong><span class="kobospan" id="kobo.65.1"> has to be used to become an “observer,” and </span><strong class="source-inline"><span class="kobospan" id="kobo.66.1">unsubscribe</span></strong><span class="kobospan" id="kobo.67.1"> is useful for situations where we don’t want to observe something anymore (for example, we’ve reached an end state). </span><span class="kobospan" id="kobo.67.2">Meanwhile, the </span><strong class="source-inline"><span class="kobospan" id="kobo.68.1">notify</span></strong><span class="kobospan" id="kobo.69.1"> method ensures that each “subscribed” observer receives </span><span><span class="kobospan" id="kobo.70.1">an update.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.71.1">A “handler” function, as the name </span><a id="_idIndexMarker116" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.72.1">suggests, is a function passed to another module to be executed at that other module’s discretion, usually in response to </span><span><span class="kobospan" id="kobo.73.1">an “event”:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.74.1">
class Queue {
  constructor() {
    this.handlers = [];
  }
  subscribe(handlerFn) {
    this.handlers.push(handlerFn);
  }
  unsubscribe(handlerFn) {
    this.handlers = this.handlers.filter((handler) =&gt;
      handler !== handlerFn);
  }
  notify(message) {
    this.handlers.forEach((handler) =&gt; {
      handler(message);
    });
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.75.1">We can implement three</span><a id="_idIndexMarker117" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.76.1"> simple “subscribers” that will, respectively, only record </span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">'CREATE'</span></strong><span class="kobospan" id="kobo.78.1"> messages, only record </span><strong class="source-inline"><span class="kobospan" id="kobo.79.1">'UPDATE'</span></strong><span class="kobospan" id="kobo.80.1"> messages, and record </span><span><span class="kobospan" id="kobo.81.1">all messages:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.82.1">
const queue = new Queue();
const createMessages = [];
queue.subscribe((message) =&gt; {
  if (message.type === 'CREATE') {
    createMessages.push(message);
  }
});
const updateMessages = [];
queue.subscribe((message) =&gt; {
  if (message.type === 'UPDATE') {
    updateMessages.push(message);
  }
});
const allMessages = [];
queue.subscribe((message) =&gt; {
  allMessages.push(message);
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.83.1">When we trigger notifications by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.84.1">notify</span></strong><span class="kobospan" id="kobo.85.1">, we can ensure that the subscribers work as expected by inspecting the arrays on which they store </span><span><span class="kobospan" id="kobo.86.1">the messages:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.87.1">
queue.notify({ type: 'CREATE', data: { user: { id: 1 } }
});
queue.notify({ type: 'CREATE', data: { user: { id: 2 } } });
queue.notify({ type: 'CREATE', data: { user: { id: 3 } } });
queue.notify({ type: 'UPDATE', data: { user: { id: 1, role:
  'ADMIN' } } });
queue.notify({
  type: 'UPDATE',
  data: { user: { id: 3, role: 'DEVELOPER' } },
});
queue.notify({ type: 'UPDATE', data: { user: { id: 3, role:
  'ADMIN' } } });
console.assert(
  createMessages.length === 3,
  '%o collects CREATE messages',
  allMessages
);
console.assert(
  updateMessages.length === 3,
  '%o collects UPDATE messages',
  allMessages
);
console.assert(
  allMessages.length === 6,
  '%o collects all message',
  allMessages
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.88.1">Note that our observer implementation</span><a id="_idIndexMarker118" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.89.1"> takes advantage of first-class support for functions in JavaScript, which means we can pass a callback function to the </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">subscribe</span></strong><span class="kobospan" id="kobo.91.1"> method, instead of </span><strong class="source-inline"><span class="kobospan" id="kobo.92.1">notify</span></strong><span class="kobospan" id="kobo.93.1"> having to call a method on </span><span><span class="kobospan" id="kobo.94.1">an instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">In programming languages with limited or no first-class function support, such as older versions of Java and PHP, the approach would’ve required passing an </span><em class="italic"><span class="kobospan" id="kobo.96.1">observer</span></em><span class="kobospan" id="kobo.97.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.98.1">subscribe</span></strong><span class="kobospan" id="kobo.99.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.100.1">notify</span></strong><span class="kobospan" id="kobo.101.1"> calling a method on each observer instance. </span><span class="kobospan" id="kobo.101.2">In JavaScript, if we don’t use “handler” functions, we’ll create an </span><strong class="source-inline"><span class="kobospan" id="kobo.102.1">observer</span></strong><span class="kobospan" id="kobo.103.1"> object that gets instantiated and has a </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">handle</span></strong><span class="kobospan" id="kobo.105.1"> function, which takes a </span><em class="italic"><span class="kobospan" id="kobo.106.1">message</span></em><span class="kobospan" id="kobo.107.1"> and implements some logic around it; in this case, it simply stores it on an </span><span><span class="kobospan" id="kobo.108.1">instance variable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.109.1">
class UpdateMessageObserver {
  constructor() {
    this.updateMessages = [];
  }
  handle(message) {
    if (message.type === 'UPDATE') {
      this.updateMessages.push(message);
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.110.1">This would require modification of the </span><strong class="source-inline"><span class="kobospan" id="kobo.111.1">Queue</span></strong><span class="kobospan" id="kobo.112.1"> class to </span><span><span class="kobospan" id="kobo.113.1">work correctly:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.114.1">
class QueueObserverObjects {
  constructor() {
    this.observers = [];
  }
  subscribe(observerObj) {
    this.observers.push(observerObj);
  }
  unsubscribe(observerObj) {
    this.observers = this.observers.filter(
      (observer) =&gt; observer !== observerObj,
    );
  }
  notify(message) {
    this.observers.forEach((observer) =&gt; {
      observer.handle(message);
    });
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.115.1">We can ensure that it does function</span><a id="_idIndexMarker119" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.116.1"> as expected by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.117.1">notify</span></strong><span class="kobospan" id="kobo.118.1"> with a few messages and checking the contents of </span><strong class="source-inline"><span class="kobospan" id="kobo.119.1">UpdateMessageObserver().updateMessages</span></strong><span class="kobospan" id="kobo.120.1">, as the following code </span><span><span class="kobospan" id="kobo.121.1">sample shows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.122.1">
const queueObserverObjects = new QueueObserverObjects();
const updateMessageObserver = new UpdateMessageObserver();
queueObserverObjects.subscribe(updateMessageObserver);
queueObserverObjects.notify({
  type: 'CREATE',
  data: { user: { id: 1 } },
});
queueObserverObjects.notify({
  type: 'UPDATE',
  data: { user: { id: 1, role: 'ADMIN' } },
});
queueObserverObjects.notify({
  type: 'UPDATE',
  data: { user: { id: 3, role: 'DEVELOPER' } },
});
console.assert(
  updateMessageObserver.updateMessages.length === 2,
  '%o collects update messages',
  updateMessageObserver.updateMessa</span><a id="_idTextAnchor104" class="pcalibre1 calibre16 pcalibre"/><a id="_idTextAnchor105" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.123.1">ges,
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.124.1">We’ve now seen how to implement the observer pattern with “handler” functions and </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">Observer</span></strong><span class="kobospan" id="kobo.126.1"> object instances, with a </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">Queue</span></strong><span class="kobospan" id="kobo.128.1"> observable. </span><span class="kobospan" id="kobo.128.2">Next, we’ll look at where the observer pattern</span><a id="_idIndexMarker120" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.129.1"> is used </span><span><span class="kobospan" id="kobo.130.1">in Jav</span><a id="_idTextAnchor106" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.131.1">aScript.</span></span></p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor107" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.132.1">Use cases of the observer pattern</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">The observer pattern is great for dealing</span><a id="_idIndexMarker121" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.134.1"> with loosely coupled events or messages. </span><span class="kobospan" id="kobo.134.2">In the context of a web application, this could be DOM events. </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">EventTarget.addEventListener()</span></strong><span class="kobospan" id="kobo.136.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">EventTarget.removeEventListener()</span></strong><span class="kobospan" id="kobo.138.1">, which are available (among others) on the </span><strong class="source-inline"><span class="kobospan" id="kobo.139.1">Window</span></strong><span class="kobospan" id="kobo.140.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.141.1">Document</span></strong><span class="kobospan" id="kobo.142.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">Element</span></strong><span class="kobospan" id="kobo.144.1"> objects, are a widely used implementation of the observer pattern. </span><span class="kobospan" id="kobo.144.2">They’re used by client-side JavaScript applications to register handlers for user interactions (for example, click, form submit, hover, </span><span><span class="kobospan" id="kobo.145.1">and mo</span><a id="_idTextAnchor108" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.146.1">useover).</span></span></p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor109" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.147.1">Limitations and improvements</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.148.1">In our queue</span><a id="_idIndexMarker122" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.149.1"> implementation, handlers</span><a id="_idIndexMarker123" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.150.1"> are readable from outside of the instance. </span><span class="kobospan" id="kobo.150.2">The handlers are an implementation detail of the queue, which we should be able to change without affecting consuming modules. </span><span class="kobospan" id="kobo.150.3">This means we want to encapsulate the handlers to make them unavailable for consumption by code outside of the </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">Queue</span></strong><span class="kobospan" id="kobo.152.1"> class. </span><span class="kobospan" id="kobo.152.2">If we keep the </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">handlers</span></strong><span class="kobospan" id="kobo.154.1"> array available, it’s possible for code outside of the </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">Queue</span></strong><span class="kobospan" id="kobo.156.1"> class to access and modify it, which means the </span><strong class="source-inline"><span class="kobospan" id="kobo.157.1">Queue</span></strong><span class="kobospan" id="kobo.158.1"> abstraction breaks down, since consumers integrate against implementation details. </span><span class="kobospan" id="kobo.158.2">This means consumers are tightly coupled to the </span><strong class="source-inline"><span class="kobospan" id="kobo.159.1">Queue</span></strong><span class="kobospan" id="kobo.160.1">’s </span><span><span class="kobospan" id="kobo.161.1">internal implementation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.162.1">Therefore, we can use a private</span><a id="_idIndexMarker124" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.163.1"> field; in modern JavaScript, that’s done</span><a id="_idIndexMarker125" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.164.1"> using the </span><strong class="source-inline"><span class="kobospan" id="kobo.165.1">#</span></strong><span class="kobospan" id="kobo.166.1"> syntax. </span><span class="kobospan" id="kobo.166.2">For handlers, it would involve a </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">#handlers</span></strong><span class="kobospan" id="kobo.168.1"> declaration in the class followed by access </span><span><span class="kobospan" id="kobo.169.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.170.1">this.#handlers</span></strong></span><span><span class="kobospan" id="kobo.171.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.172.1">
class Queue {
  #handlers;
  constructor() {
    this.#handlers = [];
  }
  subscribe(handlerFn) {
    this.#handlers.push(handlerFn);
  }
  unsubscribe(handlerFn) {
    this.#handlers = this.#handlers.filter((handler) =&gt;
      handler !== handlerFn);
  }
  notify(message) {
    this.#handlers.forEach((handler) =&gt; {
      handler(message);
    });
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.173.1">Another improvement we can make to our queue</span><a id="_idIndexMarker126" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.174.1"> is to provide a fluent interface so that we can “chain” calls. </span><span class="kobospan" id="kobo.174.2">To do this, we simply</span><a id="_idIndexMarker127" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.175.1"> need to return </span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">this</span></strong><span class="kobospan" id="kobo.177.1"> from each of the </span><strong class="source-inline"><span class="kobospan" id="kobo.178.1">subscribe</span></strong><span class="kobospan" id="kobo.179.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.180.1">unsubscribe</span></strong><span class="kobospan" id="kobo.181.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">notify</span></strong><span class="kobospan" id="kobo.183.1"> handlers. </span><span class="kobospan" id="kobo.183.2">This allows us to call the instance methods in a single “chain”; instead of using </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">queue.subscribe()</span></strong><span class="kobospan" id="kobo.185.1"> followed by </span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">queue.notify()</span></strong><span class="kobospan" id="kobo.187.1">, we can write it as a single statement – </span><span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">queue.subscribe().notify()</span></strong></span><span><span class="kobospan" id="kobo.189.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.190.1">
class Queue {
  #handlers;
  constructor() {
    this.#handlers = [];
  }
  subscribe(handlerFn) {
    this.#handlers.push(handlerFn);
    return this;
  }
  unsubscribe(handlerFn) {
    this.#handlers = this.#handlers.filter((handler) =&gt;
      handler !== handlerFn);
    return this;
  }
  notify(message) {
    this.#handlers.forEach((handler) =&gt; {
      handler(message);
    });
    return this;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.191.1">We can validate that the queue functions</span><a id="_idIndexMarker128" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.192.1"> as expected with regards to notifying</span><a id="_idIndexMarker129" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.193.1"> observers, as well as being usable with the fluent (“</span><span><span class="kobospan" id="kobo.194.1">chained”) interface:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.195.1">
const queue = new Queue();
const createMessages = [];
const updateMessages = [];
const allMessages = [];
queue
  .subscribe((message) =&gt; {
    if (message.type === 'CREATE') {
      createMessages.push(message);
    }
  })
  .subscribe((message) =&gt; {
    if (message.type === 'UPDATE') {
      updateMessages.push(message);
    }
  })
  .subscribe((message) =&gt; {
    allMessages.push(message);
  });
queue
  .notify({ type: 'CREATE', data: { user: { id: 1 } } })
  .notify({ type: 'CREATE', data: { user: { id: 2 } } })
  .notify({ type: 'CREATE', data: { user: { id: 3 } } })
  .notify({ type: 'UPDATE', data: { user: { id: 1, role:
    'ADMIN' } } })
  .notify({
    type: 'UPDATE',
    data: { user: { id: 3, role: 'DEVELOPER' } },
  })
  .notify({ type: 'UPDATE', data: { user: { id: 3, role:
    'ADMIN' } } });
console.assert(
  createMessages.length === 3,
  '%o collects CREATE messages',
  allMessages
);
console.assert(
  updateMessages.length === 3,
  '%o collects UPDATE messages',
  allMessages
);
console.assert(
  allMessages.length === 6,
  '%o collects all message',
  allMessages
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.196.1">We’ve now seen how to implement</span><a id="_idIndexMarker130" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.197.1"> the observer pattern in JavaScript </span><a id="_idIndexMarker131" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.198.1">as well as how to use private fields and a fluent interface to improve </span><span><span class="kobospan" id="kobo.199.1">our implementation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.200.1">In the next section, we’ll implement the state and</span><a id="_idTextAnchor110" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor111" class="pcalibre1 calibre6 pcalibre"/> <span><span class="kobospan" id="kobo.201.1">strategy patterns.</span></span></p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor112" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.202.1">State and strategy in JavaScript and a simplified approach</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">The state and strategy patterns</span><a id="_idIndexMarker132" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.204.1"> are closely related, in that they allow the extension of a software system‘s functionality by changing decoupled implementation objects, instead of changing the core </span><span><span class="kobospan" id="kobo.205.1">subject object.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">State allows an object to display different behavior based on what state it’s in. </span><span class="kobospan" id="kobo.206.2">This is very useful for modeling state machines. </span><span class="kobospan" id="kobo.206.3">Each state provides the same interface, and the core object calls methods on the </span><span><span class="kobospan" id="kobo.207.1">different states.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">Strategy similarly allows an object to dynamically select an implementation at runtime. </span><span class="kobospan" id="kobo.208.2">In order to do this, the implementation is injected into the object </span><span><span class="kobospan" id="kobo.209.1">and used.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.210.1">We can classify the state pattern as a subset of the strategy pattern, where the implementation is dynamically changed by the </span><span><span class="kobospan" id="kobo.211.1">state instances.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.212.1">Next, we’ll see how to implement a state machine in JavaScript with the state pattern, as well as implement an object, merging abstraction with t</span><a id="_idTextAnchor113" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.213.1">he </span><span><span class="kobospan" id="kobo.214.1">strategy pattern.</span></span></p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor114" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.215.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.216.1">For our implementation of the state pattern, we’ll use a simplified pull request/merge request/change </span><span><span class="kobospan" id="kobo.217.1">request example.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">A pull request starts in either a draft or open state. </span><span class="kobospan" id="kobo.218.2">From there, it can transition between open and draft, and then transition to a closed or merged state. </span><span class="kobospan" id="kobo.218.3">The merged state is a final state; closed can be undone by reopening the pull request, so it is </span><span><span class="kobospan" id="kobo.219.1">not final.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.220.1">To visualize the transitions from all the states, we can use a state diagram representing pull request states and allowed transitions. </span><span class="kobospan" id="kobo.220.2">In </span><span><em class="italic"><span class="kobospan" id="kobo.221.1">Figure 3</span></em></span><em class="italic"><span class="kobospan" id="kobo.222.1">.1</span></em><span class="kobospan" id="kobo.223.1">, the initial state is either draft or open. </span><span class="kobospan" id="kobo.223.2">Both of these states</span><a id="_idIndexMarker133" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.224.1"> can transition to each other. </span><span class="kobospan" id="kobo.224.2">Open can change to merged or closed, where merged is a valid end state. </span><span class="kobospan" id="kobo.224.3">Draft can also change </span><span><span class="kobospan" id="kobo.225.1">to closed.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer011">
<span class="kobospan" id="kobo.226.1"><img alt="Figure 3.1: A pull request state diagram" src="image/B19109_03_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.227.1">Figure 3.1: A pull request state diagram</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.228.1">It’s useful to sketch out our </span><strong class="source-inline"><span class="kobospan" id="kobo.229.1">PullRequest</span></strong><span class="kobospan" id="kobo.230.1"> class first. </span><span class="kobospan" id="kobo.230.2">The possible actions on our </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">PullReques</span></strong><span class="kobospan" id="kobo.232.1">t are </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">open</span></strong><span class="kobospan" id="kobo.234.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">markDraft</span></strong><span class="kobospan" id="kobo.236.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.237.1">markReadyForReview</span></strong><span class="kobospan" id="kobo.238.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.239.1">close</span></strong><span class="kobospan" id="kobo.240.1">, </span><span><span class="kobospan" id="kobo.241.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">merge</span></strong></span><span><span class="kobospan" id="kobo.243.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.244.1">To implement that state pattern, we also expose a </span><strong class="source-inline"><span class="kobospan" id="kobo.245.1">setState</span></strong><span class="kobospan" id="kobo.246.1"> method. </span><span class="kobospan" id="kobo.246.2">Each state will take the </span><strong class="source-inline"><span class="kobospan" id="kobo.247.1">PullRequest</span></strong><span class="kobospan" id="kobo.248.1"> instance as a constructor argument, and the initial states of </span><strong class="source-inline"><span class="kobospan" id="kobo.249.1">PullRequest</span></strong><span class="kobospan" id="kobo.250.1"> are either </span><strong class="source-inline"><span class="kobospan" id="kobo.251.1">DraftState</span></strong><span class="kobospan" id="kobo.252.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">OpenState</span></strong><span class="kobospan" id="kobo.254.1">, based</span><a id="_idIndexMarker134" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.255.1"> on an </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">isDraft</span></strong> <span><span class="kobospan" id="kobo.257.1">boolean parameter:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.258.1">
class PullRequest {
  constructor(isDraft = false) {
    this.state = isDraft ? </span><span class="kobospan1" id="kobo.258.2">new DraftState(this) : new
      OpenState(this);
  }
  setState(state) {
    this.state = state;
  }
  open() {
    this.state.open();
  }
  markDraft() {
    this.state.markDraft();
  }
  markReadyForReview() {
    this.state.markReadyForReview();
  }
  close() {
    this.state.close();
  }
  merge() {
    this.state.merge();
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.259.1">We’ll implement the state machine, starting with the initial and final states. </span><span class="kobospan" id="kobo.259.2">For the initial states, we have </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">DraftState</span></strong><span class="kobospan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">OpenState</span></strong><span class="kobospan" id="kobo.263.1">; for the final states, we </span><span><span class="kobospan" id="kobo.264.1">have </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">MergedState</span></strong></span><span><span class="kobospan" id="kobo.266.1">.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.267.1">DraftState</span></strong><span class="kobospan" id="kobo.268.1"> only</span><a id="_idIndexMarker135" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.269.1"> implements </span><strong class="source-inline"><span class="kobospan" id="kobo.270.1">markReadyForReview</span></strong><span class="kobospan" id="kobo.271.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">close</span></strong><span class="kobospan" id="kobo.273.1">, which transition </span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">pullRequest</span></strong><span class="kobospan" id="kobo.275.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">OpenState</span></strong><span class="kobospan" id="kobo.277.1"> or </span><span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">ClosedState</span></strong></span><span><span class="kobospan" id="kobo.279.1">, respectively:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.280.1">
class DraftState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markReadyForReview() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.281.1">OpenState</span></strong><span class="kobospan" id="kobo.282.1"> implements </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">markDraft</span></strong><span class="kobospan" id="kobo.284.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.285.1">close</span></strong><span class="kobospan" id="kobo.286.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.287.1">merge</span></strong><span class="kobospan" id="kobo.288.1">, which transitions </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">pullRequest</span></strong><span class="kobospan" id="kobo.290.1"> to </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">DraftState</span></strong><span class="kobospan" id="kobo.292.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.293.1">ClosedState</span></strong><span class="kobospan" id="kobo.294.1">, and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">MergedState</span></strong></span><span><span class="kobospan" id="kobo.296.1">, respectively:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.297.1">
class OpenState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markDraft() {
    this.pullRequest.setState(new DraftState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
  merge() {
    this.pullRequest.setState(new MergedState
      (this.pullRequest));
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.298.1">As a final state, </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">MergedState</span></strong><span class="kobospan" id="kobo.300.1"> does not implement </span><a id="_idIndexMarker136" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.301.1">any of </span><span><span class="kobospan" id="kobo.302.1">the methods:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.303.1">
class MergedState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.304.1">Finally, </span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">ClosedState</span></strong><span class="kobospan" id="kobo.306.1"> implements the </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">open</span></strong><span class="kobospan" id="kobo.308.1"> method, which transitions </span><strong class="source-inline"><span class="kobospan" id="kobo.309.1">pullRequest</span></strong> <span><span class="kobospan" id="kobo.310.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">OpenState</span></strong></span><span><span class="kobospan" id="kobo.312.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.313.1">
class ClosedState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  open() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.314.1">We can check that our pull request </span><a id="_idIndexMarker137" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.315.1">and states work </span><span><span class="kobospan" id="kobo.316.1">as expected.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.317.1">A </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">PullRequest</span></strong><span class="kobospan" id="kobo.319.1"> instantiated with </span><strong class="source-inline"><span class="kobospan" id="kobo.320.1">isDraft</span></strong><span class="kobospan" id="kobo.321.1"> set to </span><strong class="source-inline"><span class="kobospan" id="kobo.322.1">true</span></strong><span class="kobospan" id="kobo.323.1"> will begin in </span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">DraftState</span></strong><span class="kobospan" id="kobo.325.1">. </span><span class="kobospan" id="kobo.325.2">A </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">markReadyForReview</span></strong><span class="kobospan" id="kobo.327.1"> call will transition it </span><span><span class="kobospan" id="kobo.328.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">OpenState</span></strong></span><span><span class="kobospan" id="kobo.330.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.331.1">
const pullRequest1 = new PullRequest(true);
console.assert(pullRequest1.state instanceof DraftState,
  pullRequest1.state);
pullRequest1.markReadyForReview();
console.assert(pullRequest1.state instanceof OpenState,
  pullRequest1.state);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.332.1">Once a pull request is merged with </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">pullRequest.merge()</span></strong><span class="kobospan" id="kobo.334.1">, no method is available (they’ll all </span><span><span class="kobospan" id="kobo.335.1">throw errors):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.336.1">
pullRequest1.merge();
console.assert(
  captureError(() =&gt; pullRequest1.open()) instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.markReadyForReview())
    instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.close()) instanceof
    Error,
  pullRequest1.state
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.337.1">A pull request starting in the open state</span><a id="_idIndexMarker138" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.338.1"> can be closed. </span><span class="kobospan" id="kobo.338.2">Once in </span><strong class="source-inline"><span class="kobospan" id="kobo.339.1">ClosedState</span></strong><span class="kobospan" id="kobo.340.1">, it’s not possible to do anything other than execute </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">open()</span></strong><span class="kobospan" id="kobo.342.1"> on it – for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">markDraft</span></strong><span class="kobospan" id="kobo.344.1"> will fail with </span><span><span class="kobospan" id="kobo.345.1">an error:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.346.1">
const pullRequest2 = new PullRequest(false);
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);
pullRequest2.close();
console.assert(pullRequest2.state instanceof ClosedState,
  pullRequest2.state);
console.assert(
  captureError(() =&gt; pullRequest2.markDraft())
    instanceof Error,
  pullRequest2.state
);
pullRequest2.open();
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.347.1">We’ve now seen how to implement a pull request state machine using the </span><span><span class="kobospan" id="kobo.348.1">state pattern.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.349.1">Next, we’ll have a look at </span><span><span class="kobospan" id="kobo.350.1">implementing strategy.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.351.1">Our example is an </span><strong class="source-inline"><span class="kobospan" id="kobo.352.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.353.1"> class, which merges JavaScript objects. </span><span class="kobospan" id="kobo.353.2">There are multiple ways to achieve this in JavaScript, so we structure our </span><strong class="source-inline"><span class="kobospan" id="kobo.354.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.355.1"> to accept a </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">strategy</span></strong><span class="kobospan" id="kobo.357.1"> object</span><a id="_idIndexMarker139" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.358.1"> and allow updates to it with a </span><strong class="source-inline"><span class="kobospan" id="kobo.359.1">setStrategy</span></strong><span class="kobospan" id="kobo.360.1"> method. </span><span class="kobospan" id="kobo.360.2">Finally, we expose a </span><strong class="source-inline"><span class="kobospan" id="kobo.361.1">combinedObjects</span></strong><span class="kobospan" id="kobo.362.1"> method, which calls the instance’s strategy’s </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">combineObjects</span></strong><span class="kobospan" id="kobo.364.1"> method with </span><span><span class="kobospan" id="kobo.365.1">two objects:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.366.1">
class ObjectMerger {
  constructor(defaultStrategy) {
    this.strategy = defaultStrategy;
  }
  setStrategy(newStrategy) {
    this.strategy = newStrategy;
  }
  combineObjects(obj1, obj2) {
    return this.strategy.combineObjects(obj1, obj2);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.367.1">An example strategy in this case would be to use </span><strong class="source-inline"><span class="kobospan" id="kobo.368.1">Object.assign</span></strong><span class="kobospan" id="kobo.369.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.370.1">{}</span></strong><span class="kobospan" id="kobo.371.1"> (a new object literal) as the target of the assignment. </span><span class="kobospan" id="kobo.371.2">This has the benefit of not mutating the </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">obj1</span></strong><span class="kobospan" id="kobo.373.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.374.1">obj2</span></strong></span><span><span class="kobospan" id="kobo.375.1"> parameters:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.376.1">
class PureObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign({}, obj1, obj2);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.377.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.379.1"> can be instantiated with the </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">PureObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.381.1">, </span><span><span class="kobospan" id="kobo.382.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.383.1">
const objectMerger = new ObjectMerger
  (new PureObjectAssignStrategy());</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.384.1">It can then be used to merge</span><a id="_idIndexMarker140" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.385.1"> objects without mutating </span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">obj1</span></strong> <span><span class="kobospan" id="kobo.387.1">or </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.388.1">obj2</span></strong></span><span><span class="kobospan" id="kobo.389.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.390.1">
const obj1 = {
  keys: '123',
};
const obj2 = {
  keys: '456',
};
const defaultMergeStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(defaultMergeStrategyOutput.keys === '456',
  '%o has keys = 456');
console.assert(obj1.keys === '123' &amp;&amp; obj2.keys === '456',
  obj1, obj2);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.391.1">An example of a naive implementation using </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">Object.assign</span></strong><span class="kobospan" id="kobo.393.1"> that doesn’t use a new object as the assignment target (and, therefore, mutates </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">obj1</span></strong><span class="kobospan" id="kobo.395.1">) looks </span><span><span class="kobospan" id="kobo.396.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.397.1">
class MutatingObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign(obj1, obj2);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.398.1">It can be used as follows and does indeed </span><span><span class="kobospan" id="kobo.399.1">mutate </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">obj1</span></strong></span><span><span class="kobospan" id="kobo.401.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.402.1">
objectMerger.setStrategy(new
  MutatingObjectAssignStrategy());
const mutatingMergedStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(
  mutatingMergedStrategyOutput.keys === '456',
  '%o has keys = 456',
  mutatingMergedStrategyOutput
);
console.assert(
  obj1.keys === '456' &amp;&amp; obj2.keys === '456',
  'Mutates the original object obj1 %o, obj2 %o',
  obj1,
  obj2
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.403.1">An equivalent strategy</span><a id="_idIndexMarker141" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.404.1"> to our initial </span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">Object.assign({}, obj1, obj2)</span></strong><span class="kobospan" id="kobo.406.1"> strategy is to use the </span><span><span class="kobospan" id="kobo.407.1">spread syntax:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.408.1">
class ObjectSpreadStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return { ...obj1, ...obj2 };
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.409.1">We can validate that spreading </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">obj1</span></strong><span class="kobospan" id="kobo.411.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">obj2</span></strong><span class="kobospan" id="kobo.413.1"> yields the same strategy characteristics as our </span><span><span class="kobospan" id="kobo.414.1">earlier </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.415.1">PureObjectAssignStrategy</span></strong></span><span><span class="kobospan" id="kobo.416.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.417.1">
objectMerger.setStrategy(new ObjectSpreadStrategy());
const newObj1 = { keys: '123' };
const newObj2 = { keys: '456', obj1: newObj1 };
const objectSpreadStrategyOutput =
  objectMerger.combineObjects(
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.keys === '456',
  '%o has keys = 456',
  objectSpreadStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.418.1">One interesting aspect</span><a id="_idIndexMarker142" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.419.1"> is that this approach only creates a shallow clone; object references inside of the objects are copied, but the contents of the target objects are </span><span><span class="kobospan" id="kobo.420.1">the same:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.421.1">
console.assert(
  objectSpreadStrategyOutput.obj1 === newObj1,
  'Does a shallow clone so objectSpreadStrategyOutput.obj1
    references newObj1'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.422.1">We can remediate this by implementing a deep cloning strategy based </span><span><span class="kobospan" id="kobo.423.1">on </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">structuredClone</span></strong></span><span><span class="kobospan" id="kobo.425.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.426.1">
class DeepCloneObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign(structuredClone(obj1),
      structuredClone(obj2));
  }
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.427.1">DeepCloneObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.428.1"> has all the properties of </span><strong class="source-inline"><span class="kobospan" id="kobo.429.1">PureObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.430.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">ObjectSpreadStrategy</span></strong><span class="kobospan" id="kobo.432.1">, with the addition of doing a deep copy, recursively</span><a id="_idIndexMarker143" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.433.1"> copying the contents of nested objects instead of copying references to </span><span><span class="kobospan" id="kobo.434.1">those objects:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.435.1">
objectMerger.setStrategy(new DeepCloneObjectAssignStrategy());
const deepCloneStrategyOutput = objectMerger.
</span><span class="kobospan1" id="kobo.435.2">  combineObjects(newObj1, newObj2);
console.assert(
  deepCloneStrategyOutput.keys === '456',
  '%o has keys = 456',
  deepCloneStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  deepCloneStrategyOutput.obj1 !== newObj1 &amp;&amp;
    deepCloneStrategyOutput.obj1.keys === newObj1.keys,
  'Does a shallow clone so deepCloneStrategyOutput.ob</span><a id="_idTextAnchor115" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.436.1">j1
    references newObj1'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.437.1">We’ve now seen how to implement </span><a id="_idIndexMarker144" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.438.1">the state and strategy patterns. </span><span class="kobospan" id="kobo.438.2">Next, we’ll look at where the state and strategy patterns are most often used </span><span><span class="kobospan" id="kobo.439.1">in JavaScript.</span></span></p>
<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor116" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.440.1">Use cases of the state and strategy patterns</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.441.1">As mentioned earlier in the chapter, the state pattern</span><a id="_idIndexMarker145" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.442.1"> is useful for implementing </span><span><span class="kobospan" id="kobo.443.1">state machines.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.444.1">A key difference between state and strategy is that, in the state pattern, it tends to be the case that differen</span><a id="_idTextAnchor117" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.445.1">t states know about each other – for example, </span><strong class="source-inline"><span class="kobospan" id="kobo.446.1">ClosedState</span></strong><span class="kobospan" id="kobo.447.1"> creates a new instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.448.1">OpenState</span></strong><span class="kobospan" id="kobo.449.1"> to transition to it. </span><span class="kobospan" id="kobo.449.2">Similarly, </span><strong class="source-inline"><span class="kobospan" id="kobo.450.1">OpenState</span></strong><span class="kobospan" id="kobo.451.1"> is aware of all the potential states it can be transitioned to (</span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">DraftState</span></strong><span class="kobospan" id="kobo.453.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">ClosedState</span></strong><span class="kobospan" id="kobo.455.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.456.1">MergedState</span></strong><span class="kobospan" id="kobo.457.1">). </span><span class="kobospan" id="kobo.457.2">In contrast, when implementing the strategy pattern, different strategies are self-contained and not aware of each other. </span><span class="kobospan" id="kobo.457.3">For example, </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">PureObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.459.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">MutatingObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.461.1"> don’t reference </span><span><span class="kobospan" id="kobo.462.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.463.1">Strategy is useful to provide a consistent interface with different internal implementations. </span><span class="kobospan" id="kobo.463.2">It’s a useful abstraction when different implementing algorithms should be swappable</span><a id="_idIndexMarker146" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.464.1"> without an integ</span><a id="_idTextAnchor118" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.465.1">rating consumer knowing </span><span><span class="kobospan" id="kobo.466.1">about it.</span></span></p>
<h2 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor119" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.467.1">Limitations and improvements</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.468.1">In our state example, note</span><a id="_idIndexMarker147" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.469.1"> how much</span><a id="_idIndexMarker148" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.470.1"> of our code is a duplicated class constructor, which takes a </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">pullRequest</span></strong><span class="kobospan" id="kobo.472.1"> instance. </span><span class="kobospan" id="kobo.472.2">We can refactor our code by providing a </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">PullRequestBaseState</span></strong><span class="kobospan" id="kobo.474.1"> class, which throws </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">IllegalOperationError</span></strong><span class="kobospan" id="kobo.476.1"> for each of the </span><span><span class="kobospan" id="kobo.477.1">state methods:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.478.1">
class IllegalOperationError extends Error {
  constructor(stateInstance) {
    this.stateInstance = stateInstance;
    throw new Error('Illegal operation for State');
  }
}
class PullRequestBaseState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markDraft() {
    throw new IllegalOperationError(this);
  }
  markReadyForReview() {
    throw new IllegalOperationError(this);
  }
  open() {
    throw new IllegalOperationError(this);
  }
  close() {
    throw new IllegalOperationError(this);
  }
  merge() {
    throw new IllegalOperationError(this);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.479.1">This means we can define</span><a id="_idIndexMarker149" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.480.1"> our different</span><a id="_idIndexMarker150" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.481.1"> states by </span><span><span class="kobospan" id="kobo.482.1">extending </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">PullRequestBaseState</span></strong></span><span><span class="kobospan" id="kobo.484.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.485.1">
class ClosedState extends PullRequestBaseState {
  open() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
}
class DraftState extends PullRequestBaseState {
  markReadyForReview() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
}
class OpenState extends PullRequestBaseState {
  markDraft() {
    this.pullRequest.setState(new DraftState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
  merge() {
    this.pullRequest.setState(new MergedState
      (this.pullRequest));
  }
}
class MergedState extends PullRequestBaseState {}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.486.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">PullRequest</span></strong><span class="kobospan" id="kobo.488.1"> class doesn’t change, and these new state</span><a id="_idIndexMarker151" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.489.1"> implementations work</span><a id="_idIndexMarker152" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.490.1"> the same as our </span><span><span class="kobospan" id="kobo.491.1">previous implementation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.492.1">
const pullRequest1 = new PullRequest(true);
console.assert(pullRequest1.state instanceof DraftState,
  pullRequest1.state);
pullRequest1.markReadyForReview();
console.assert(pullRequest1.state instanceof OpenState,
  pullRequest1.state);
pullRequest1.merge();
console.assert(
  captureError(() =&gt; pullRequest1.open()) instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.markReadyForReview())
    instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.close()) instanceof
   Error,
  pullRequest1.state
);
const pullRequest2 = new PullRequest(false);
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);
pullRequest2.close();
console.assert(pullRequest2.state instanceof ClosedState,
  pullRequest2.state);
console.assert(
  captureError(() =&gt; pullRequest2.markDraft())
    instanceof Error,
  pullRequest2.state
);
pullRequest2.open();
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.493.1">For strategy, one thing we can leverage</span><a id="_idIndexMarker153" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.494.1"> is JavaScript’s first-class function</span><a id="_idIndexMarker154" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.495.1"> support. </span><span class="kobospan" id="kobo.495.2">Instead of implementing each strategy as an object, we can make </span><span><span class="kobospan" id="kobo.496.1">them functions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.497.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.498.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.499.1">’s implementation looks </span><span><span class="kobospan" id="kobo.500.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.501.1">
class ObjectMerger {
  constructor(defaultStrategy) {
    this.strategy = defaultStrategy;
  }
  setStrategy(newStrategy) {
    this.strategy = newStrategy;
  }
  combineObjects(obj1, obj2) {
    return this.strategy(obj1, obj2);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.502.1">We can then re-implement all our strategies </span><span><span class="kobospan" id="kobo.503.1">as functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.504.1">
function pureObjectAssignStrategy(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}
function mutatingObjectAssignStrategy(obj1, obj2) {
  return Object.assign(obj1, obj2);
}
function objectSpreadStrategy(obj1, obj2) {
  return { ...obj1, ...obj2 };
}
function deepCloneObjectAssignStrategy(obj1, obj2) {
  return Object.assign(structuredClone(obj1),
    structuredClone(obj2));
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.505.1">The function-based strategy </span><strong class="source-inline"><span class="kobospan" id="kobo.506.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.507.1"> class has the same attributes</span><a id="_idIndexMarker155" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.508.1"> as the class-based</span><a id="_idIndexMarker156" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.509.1"> one that we implemented earlier. </span><span class="kobospan" id="kobo.509.2">The constructor takes a “strategy function”, which it sets on the instance; each instance exposes a </span><strong class="source-inline"><span class="kobospan" id="kobo.510.1">setStrategy</span></strong><span class="kobospan" id="kobo.511.1"> method, which overrides the strategy function, and a </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">combineObjects</span></strong><span class="kobospan" id="kobo.513.1"> method, which we can call to </span><span><span class="kobospan" id="kobo.514.1">merge objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.515.1">This means we can use our </span><strong class="source-inline"><span class="kobospan" id="kobo.516.1">ObjectMerger</span></strong><span class="kobospan" id="kobo.517.1"> with all four function-based strategies (</span><strong class="source-inline"><span class="kobospan" id="kobo.518.1">pureObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.519.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.520.1">mutatingObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.521.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.522.1">objectSpreadStrategy</span></strong><span class="kobospan" id="kobo.523.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.524.1">deepCloneObjectAssignStrategy</span></strong><span class="kobospan" id="kobo.525.1">), as the </span><span><span class="kobospan" id="kobo.526.1">following demonstrates:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.527.1">
const objectMerger = new ObjectMerger
  (pureObjectAssignStrategy);
const obj1 = {
  keys: '123',
};
const obj2 = {
  keys: '456',
};
const defaultMergeStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(defaultMergeStrategyOutput.keys === '456',
  '%o has keys = 456');
console.assert(obj1.keys === '123' &amp;&amp; obj2.keys === '456',
  obj1, obj2);
objectMerger.setStrategy(mutatingObjectAssignStrategy);
const mutatingMergedStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(
  mutatingMergedStrategyOutput.keys === '456',
  '%o has keys = 456',
  mutatingMergedStrategyOutput
);
console.assert(
  obj1.keys === '456' &amp;&amp; obj2.keys === '456',
  'Mutates the original object obj1 %o, obj2 %o',
  obj1,
  obj2
);
objectMerger.setStrategy(objectSpreadStrategy);
const newObj1 = { keys: '123' };
const newObj2 = { keys: '456', obj1: newObj1 };
const objectSpreadStrategyOutput =
  objectMerger.combineObjects(
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.keys === '456',
  '%o has keys = 456',
  objectSpreadStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.obj1 === newObj1,
  'Does a shallow clone so objectSpreadStrategyOutput.obj1
    references newObj1'
);
objectMerger.setStrategy(deepCloneObjectAssignStrategy);
const deepCloneStrategyOutput = objectMerger.combineObjects
  (newObj1, newObj2);
console.assert(
  deepCloneStrategyOutput.keys === '456',
  '%o has keys = 456',
  deepCloneStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  deepCloneStrategyOutput.obj1 !== newObj1 &amp;&amp;
    deepCloneStrategyOutput.obj1.keys === newObj1.keys,
  'Does a shallow clone so deepCloneStrategyOutput.
</span><span class="kobospan1" id="kobo.527.2">    obj1 references newObj1'
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.528.1">We’ve shown how to implement</span><a id="_idIndexMarker157" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.529.1"> the state and strategy patterns</span><a id="_idIndexMarker158" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.530.1"> in JavaScript, as well as their limitations and improvements, which can be done using modern </span><span><span class="kobospan" id="kobo.531.1">JavaScript features.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.532.1">In the next section, we’ll introduce the visitor patte</span><a id="_idTextAnchor120" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.533.1">rn and its usage in the </span><span><span class="kobospan" id="kobo.534.1">JavaScript ecosystem.</span></span></p>
<h1 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor121" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.535.1">Visitor in JavaScript</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.536.1">The visitor design pattern</span><a id="_idIndexMarker159" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.537.1"> concerns itself with being able to add functionality to objects without modifying the structure </span><span><span class="kobospan" id="kobo.538.1">of them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.539.1">With classical inheritance, we often end up with a “base class” that is not used directly; it’s used as an “abstract class,” from which “concrete” classes inherit from our “base class.” </span><span class="kobospan" id="kobo.539.2">For example, with </span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">BankAccount</span></strong><span class="kobospan" id="kobo.541.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.542.1">BankAccountWithInterest</span></strong><span class="kobospan" id="kobo.543.1">, our class diagram would look as follows, where </span><strong class="source-inline"><span class="kobospan" id="kobo.544.1">BankAccountWithInterest</span></strong><span class="kobospan" id="kobo.545.1"> extends </span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">BankAccount</span></strong><span class="kobospan" id="kobo.547.1"> and </span><span><span class="kobospan" id="kobo.548.1">overrides </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.549.1">setBalance</span></strong></span><span><span class="kobospan" id="kobo.550.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer012">
<span class="kobospan" id="kobo.551.1"><img alt="Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount" src="image/B19109_03_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.552.1">Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.553.1">What we can do with the visitor pattern</span><a id="_idIndexMarker160" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.554.1"> is define </span><strong class="source-inline"><span class="kobospan" id="kobo.555.1">BankAccount</span></strong><span class="kobospan" id="kobo.556.1">, which accepts a visitor and an </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">InterestRateVisitor</span></strong><span class="kobospan" id="kobo.558.1"> visitor class. </span><span class="kobospan" id="kobo.558.2">As a class diagram, it looks as follows. </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">BankAccount</span></strong><span class="kobospan" id="kobo.560.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">InterestRateVisitor</span></strong><span class="kobospan" id="kobo.562.1"> are not linked via inheritance; they will be linked at runtime when </span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">InterestRateVisitor</span></strong><span class="kobospan" id="kobo.564.1"> is called by the </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">BankAccount().accept</span></strong><span class="kobospan" id="kobo.566.1"> method. </span><span class="kobospan" id="kobo.566.2">This means </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">InterestRateVisitor</span></strong><span class="kobospan" id="kobo.568.1"> knows about the structure of </span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">BankAccount</span></strong><span class="kobospan" id="kobo.570.1"> but not the other way around. </span><span class="kobospan" id="kobo.570.2">Furthermore, a visitor might not need to know the full structure of what it’s visiting, only what’s relevant to implement the </span><span><span class="kobospan" id="kobo.571.1">visitor’s functionality.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer013">
<span class="kobospan" id="kobo.572.1"><img alt="Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor" src="image/B19109_03_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.573.1">Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">We’ll now see how</span><a id="_idIndexMarker161" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.575.1"> to implement the</span><a id="_idTextAnchor122" class="pcalibre1 calibre6 pcalibre"/> <strong class="source-inline"><span class="kobospan" id="kobo.576.1">BankAccount</span></strong><span class="kobospan" id="kobo.577.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.578.1">InterestRateVisitor</span></strong></span><span><span class="kobospan" id="kobo.579.1"> scenario.</span></span></p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor123" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.580.1">Implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.581.1">To implement a visitor, let’s start</span><a id="_idIndexMarker162" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.582.1"> with a simple </span><strong class="source-inline"><span class="kobospan" id="kobo.583.1">BankAccount</span></strong><span class="kobospan" id="kobo.584.1"> class. </span><span class="kobospan" id="kobo.584.2">The constructor sets the account type (either a current account or a savings account), the currency, and the initial balance. </span><strong class="source-inline"><span class="kobospan" id="kobo.585.1">BankAccount</span></strong><span class="kobospan" id="kobo.586.1"> has a </span><strong class="source-inline"><span class="kobospan" id="kobo.587.1">setBalance</span></strong><span class="kobospan" id="kobo.588.1"> method that can set the value of an account’s balance. </span><span class="kobospan" id="kobo.588.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.589.1">accept</span></strong><span class="kobospan" id="kobo.590.1"> method will allow us to accept visitors and call their </span><strong class="source-inline"><span class="kobospan" id="kobo.591.1">visit</span></strong><span class="kobospan" id="kobo.592.1"> method on </span><span><span class="kobospan" id="kobo.593.1">the instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.594.1">
class BankAccount {
  /**
   *
   * @param {'CURRENT' | 'SAVINGS'} accountType
   * @param {String} currency
   * @param {Number} balance - balance in minor currency
     unit
   */
  constructor(accountType = 'CURRENT', currency = 'USD',
    balance = 0) {
    this.accountType = accountType;
    this.currency = currency;
    this.balance = balance;
  }
  setBalance(balance) {
    this.balance = balance;
  }
  accept(visitor) {
    visitor.visit(this);
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.595.1">A way to structure </span><strong class="source-inline"><span class="kobospan" id="kobo.596.1">InterestVisitor</span></strong><span class="kobospan" id="kobo.597.1"> is to initialize it with an interest</span><a id="_idIndexMarker163" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.598.1"> rate and currency. </span><span class="kobospan" id="kobo.598.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">visit</span></strong><span class="kobospan" id="kobo.600.1"> method takes </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">bankAccount</span></strong><span class="kobospan" id="kobo.602.1"> and, if the account matches the currency and is a savings account, applies a new balance, based on the interest rate and </span><span><span class="kobospan" id="kobo.603.1">current balance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.604.1">
class InterestVisitor {
  constructor(interestRate, currency) {
    this.interestRate = interestRate;
    this.currency = currency;
  }
  /**
   * @param {BankAccount} bankAccount
   */
  visit(bankAccount) {
    if (
      bankAccount.currency === this.currency &amp;&amp;
      bankAccount.accountType === 'SAVINGS'
    ) {
      bankAccount.setBalance((bankAccount.balance *
        this.interestRate) / 100);
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.605.1">Given a set of accounts, we can create</span><a id="_idIndexMarker164" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.606.1"> USD and GBP </span><span><strong class="source-inline"><span class="kobospan" id="kobo.607.1">InterestVisitor</span></strong></span><span><span class="kobospan" id="kobo.608.1"> instances:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.609.1">
const accounts = [
  new BankAccount('SAVINGS', 'GBP', 500),
  new BankAccount('SAVINGS', 'USD', 500),
  new BankAccount('CURRENT', 'USD', 10000),
];
const usdInterestVisitor = new InterestVisitor(105, 'USD');
const gbpInterestVisitor = new InterestVisitor(110, 'GBP');</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.610.1">We can then loop through the accounts and call the </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">accept</span></strong><span class="kobospan" id="kobo.612.1"> method with the </span><span><span class="kobospan" id="kobo.613.1">relevant visitor:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.614.1">
accounts.forEach((account) =&gt; {
  account.accept(usdInterestVisitor);
  account.accept(gbpInterestVisitor);
});
console.assert(
  accounts[0].balance === 550 &amp;&amp;
    accounts[1].balance === 525 &amp;&amp;
    acc</span><a id="_idTextAnchor124" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.615.1">ounts[2].balance === 10000,
  '%o',
  accounts
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.616.1">We’ve now seen how to implement</span><a id="_idIndexMarker165" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.617.1"> the visitor pattern in a band account scenario. </span><span class="kobospan" id="kobo.617.2">Next, we’ll look at popular use cases for the visitor pattern </span><span><span class="kobospan" id="kobo.618.1">in JavaScript.</span></span></p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor125" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.619.1">Use cases of the visitor pattern</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.620.1">The visitor pattern provides a simple interface</span><a id="_idIndexMarker166" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.621.1"> for library authors to allow consumers to extend a library’s functionality. </span><span class="kobospan" id="kobo.621.2">This is especially effective in libraries that deal with trees or other “sets of nodes”. </span><span class="kobospan" id="kobo.621.3">This explains why the visitor pattern is popular for custom plugins for parsing systems such as GraphQL implementations, or compilers such </span><span><span class="kobospan" id="kobo.622.1">as Babel.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.623.1">For example, the way to write a custom directive in Apollo Server v2 is to extend </span><span><strong class="source-inline"><span class="kobospan" id="kobo.624.1">SchemaDirectiveVisitor</span></strong></span><span><span class="kobospan" id="kobo.625.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.626.1">
import { SchemaDirectiveVisitor } from 'apollo-server';
class CustomDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    // we can replace/augment the field's resolver
       implementation here
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.627.1">The Babel compiler can be extended using a visitor. </span><span class="kobospan" id="kobo.627.2">For example, the following visitor inspects function declaration names for a given code snippet, parsed using the </span><strong class="source-inline"><span class="kobospan" id="kobo.628.1">'@</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">babel/parser'</span></strong></span><span><span class="kobospan" id="kobo.630.1"> package:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.631.1">
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';
const ast = parser.parse(`function triple(n) {
  return n * 3;
}`);
const CustomVisitor = {
  FunctionDeclaration(path) {
    console.assert(path.node.id.name === 'triple');
  },
};
traverse(ast, CustomVisitor);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.632.1">We’ve now seen how the visitor</span><a id="_idIndexMarker167" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.633.1"> pattern is used for libraries that manipulate tree data structures. </span><span class="kobospan" id="kobo.633.2">Next, we</span><a id="_idTextAnchor126" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor127" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.634.1">’ll recapitulate what we’ve learned in </span><span><span class="kobospan" id="kobo.635.1">this chapter.</span></span></p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor128" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.636.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.637.1">In this chapter, we saw how behavioral design patterns enable the extension of functionality by supporting different implementations and decoupling parts of the </span><span><span class="kobospan" id="kobo.638.1">code base.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.639.1">The observer pattern is useful to support communication with loosely coupled observable/observer pairs. </span><span class="kobospan" id="kobo.639.2">The state and strategy patterns can be used to implement state machines and swap implementations effectively. </span><span class="kobospan" id="kobo.639.3">The visitor pattern is a great way to expose an extension mechanism that’s decoupled from the structure of the objects it’s </span><span><span class="kobospan" id="kobo.640.1">operating on.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.641.1">Now that we know how to organize communication between different objects and classes with behavioral design patterns, in the next chapter, we’ll cover reactive view library patterns </span><span><span class="kobospan" id="kobo.642.1">in React.</span></span></p>
</div>
</body></html>