<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor095" class="pcalibre1 calibre6 pcalibre"/>3</h1>
<h1 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor096" class="pcalibre1 calibre6 pcalibre"/>Leveraging Behavioral Design Patterns</h1>
<p class="calibre3">Behavioral design patterns help to organize communication between objects. This includes the ability to extend functionality without modifying these existing classes. By implementing the behavioral design patterns covered in this chapter and how they’re used in the JavaScript ecosystem, we’ll learn to build JavaScript applications that can be extended without touching existing functionality.</p>
<p class="calibre3">We’ll cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">An understanding of the behavioral design pattern classification</li>
<li class="calibre11">An implementation of the observer pattern and how the common Web <strong class="source-inline1">EventTarget</strong> API exposes it</li>
<li class="calibre11">Implementations of the state and strategy pattern, both with a class-based approach and a function-based approach</li>
<li class="calibre11">A simplified visitor example, as well as common usage for the visitor pattern in the JavaScript ecosystem</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to leverage behavioral design patterns in JavaScript to scale your code base and expose extension points for functionality.</p>
<h1 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor097" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor098" class="pcalibre1 calibre6 pcalibre"/>What are behavioral design patterns?</h1>
<p class="calibre3">Communicating between objects<a id="_idIndexMarker112" class="pcalibre1 calibre6 pcalibre"/> is key to building software. Behavioral design patterns help us organize this communication and usually decouple the possible implementations from other objects. This makes us more able to extend our code base.</p>
<p class="calibre3">Behavioral design patterns help us follow the open/closed principle, where we can extend functionality without modifying the existing implementation modules.</p>
<p class="calibre3">All the patterns we’ll cover allow us to “add functionality” without modifying the existing consumer/concrete implementation. In large software code bases, this is useful, since it means we can limit the scope of changes and lower the risk of breaking existing functionality. We’re able to effectively de-correlate “adding functionality” from “changing the existing code for other unrelated functionality,” and new features and behaviors can be added without having to do modifications to existing consumers.</p>
<p class="calibre3">With behavioral design patterns, new behaviors can be purely<a id="_idIndexMarker113" class="pcalibre1 calibre6 pcalibre"/> additive. The observer pattern allows multiple decoupled consumers (also called listeners). With the state, strategy, and visitor patterns, new implementations and transitions can be added without interfering with the existing ones.</p>
<p class="calibre3">In the next section, we’ll look at our first behavioral design pattern, the observer pattern in JavaScript<a id="_idTextAnchor099" class="pcalibre1 calibre6 pcalibre"/>.</p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor100" class="pcalibre1 calibre6 pcalibre"/>The observer pattern in JavaScript</h1>
<p class="calibre3">The observer pattern<a id="_idIndexMarker114" class="pcalibre1 calibre6 pcalibre"/> allows an object (the observable or subject) to maintain a list of other objects that depend on it (observers). When a state update occurs in the subject, such as an entity object being created or updated, it notifies the observer<a id="_idTextAnchor101" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor102" class="pcalibre1 calibre6 pcalibre"/>s.</p>
<h2 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor103" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">A sample use case for the observer pattern<a id="_idIndexMarker115" class="pcalibre1 calibre6 pcalibre"/> is an in-memory queue. The <code>Queue</code> instance will have the <code>subscribe</code>, <code>unsubscribe</code>, and <code>notify</code> methods.</p>
<p class="calibre3"><code>subscribe</code> will add an additional “handler” function, <code>unsubscribe</code> will remove a particular “handler” function if it has been registered, and finally, <code>notify</code> will call each handler with a “message” payload. This is the “notification of the observers” piece, where the observable or subject ensures that each registered observer is notified.</p>
<p class="calibre3"><code>subscribe</code> and <code>unsubscribe</code> turn “observer” functionality on and off, respectively. <code>subscribe</code> has to be used to become an “observer,” and <code>unsubscribe</code> is useful for situations where we don’t want to observe something anymore (for example, we’ve reached an end state). Meanwhile, the <code>notify</code> method ensures that each “subscribed” observer receives an update.</p>
<p class="calibre3">A “handler” function, as the name <a id="_idIndexMarker116" class="pcalibre1 calibre6 pcalibre"/>suggests, is a function passed to another module to be executed at that other module’s discretion, usually in response to an “event”:</p>
<pre class="source-code">
class Queue {
  constructor() {
    this.handlers = [];
  }
  subscribe(handlerFn) {
    this.handlers.push(handlerFn);
  }
  unsubscribe(handlerFn) {
    this.handlers = this.handlers.filter((handler) =&gt;
      handler !== handlerFn);
  }
  notify(message) {
    this.handlers.forEach((handler) =&gt; {
      handler(message);
    });
  }
}</pre> <p class="calibre3">We can implement three<a id="_idIndexMarker117" class="pcalibre1 calibre6 pcalibre"/> simple “subscribers” that will, respectively, only record <code>'CREATE'</code> messages, only record <code>'UPDATE'</code> messages, and record all messages:</p>
<pre class="source-code">
const queue = new Queue();
const createMessages = [];
queue.subscribe((message) =&gt; {
  if (message.type === 'CREATE') {
    createMessages.push(message);
  }
});
const updateMessages = [];
queue.subscribe((message) =&gt; {
  if (message.type === 'UPDATE') {
    updateMessages.push(message);
  }
});
const allMessages = [];
queue.subscribe((message) =&gt; {
  allMessages.push(message);
});</pre> <p class="calibre3">When we trigger notifications by calling <code>notify</code>, we can ensure that the subscribers work as expected by inspecting the arrays on which they store the messages:</p>
<pre class="source-code">
queue.notify({ type: 'CREATE', data: { user: { id: 1 } }
});
queue.notify({ type: 'CREATE', data: { user: { id: 2 } } });
queue.notify({ type: 'CREATE', data: { user: { id: 3 } } });
queue.notify({ type: 'UPDATE', data: { user: { id: 1, role:
  'ADMIN' } } });
queue.notify({
  type: 'UPDATE',
  data: { user: { id: 3, role: 'DEVELOPER' } },
});
queue.notify({ type: 'UPDATE', data: { user: { id: 3, role:
  'ADMIN' } } });
console.assert(
  createMessages.length === 3,
  '%o collects CREATE messages',
  allMessages
);
console.assert(
  updateMessages.length === 3,
  '%o collects UPDATE messages',
  allMessages
);
console.assert(
  allMessages.length === 6,
  '%o collects all message',
  allMessages
);</pre> <p class="calibre3">Note that our observer implementation<a id="_idIndexMarker118" class="pcalibre1 calibre6 pcalibre"/> takes advantage of first-class support for functions in JavaScript, which means we can pass a callback function to the <code>subscribe</code> method, instead of <code>notify</code> having to call a method on an instance.</p>
<p class="calibre3">In programming languages with limited or no first-class function support, such as older versions of Java and PHP, the approach would’ve required passing an <em class="italic">observer</em> to <code>subscribe</code> and <code>notify</code> calling a method on each observer instance. In JavaScript, if we don’t use “handler” functions, we’ll create an <code>observer</code> object that gets instantiated and has a <code>handle</code> function, which takes a <em class="italic">message</em> and implements some logic around it; in this case, it simply stores it on an instance variable:</p>
<pre class="source-code">
class UpdateMessageObserver {
  constructor() {
    this.updateMessages = [];
  }
  handle(message) {
    if (message.type === 'UPDATE') {
      this.updateMessages.push(message);
    }
  }
}</pre> <p class="calibre3">This would require modification of the <code>Queue</code> class to work correctly:</p>
<pre class="source-code">
class QueueObserverObjects {
  constructor() {
    this.observers = [];
  }
  subscribe(observerObj) {
    this.observers.push(observerObj);
  }
  unsubscribe(observerObj) {
    this.observers = this.observers.filter(
      (observer) =&gt; observer !== observerObj,
    );
  }
  notify(message) {
    this.observers.forEach((observer) =&gt; {
      observer.handle(message);
    });
  }
}</pre> <p class="calibre3">We can ensure that it does function<a id="_idIndexMarker119" class="pcalibre1 calibre6 pcalibre"/> as expected by calling <code>notify</code> with a few messages and checking the contents of <code>UpdateMessageObserver().updateMessages</code>, as the following code sample shows:</p>
<pre class="source-code">
const queueObserverObjects = new QueueObserverObjects();
const updateMessageObserver = new UpdateMessageObserver();
queueObserverObjects.subscribe(updateMessageObserver);
queueObserverObjects.notify({
  type: 'CREATE',
  data: { user: { id: 1 } },
});
queueObserverObjects.notify({
  type: 'UPDATE',
  data: { user: { id: 1, role: 'ADMIN' } },
});
queueObserverObjects.notify({
  type: 'UPDATE',
  data: { user: { id: 3, role: 'DEVELOPER' } },
});
console.assert(
  updateMessageObserver.updateMessages.length === 2,
  '%o collects update messages',
  updateMessageObserver.updateMessa<a id="_idTextAnchor104" class="pcalibre1 calibre16 pcalibre"/><a id="_idTextAnchor105" class="pcalibre1 calibre16 pcalibre"/>ges,
);</pre> <p class="calibre3">We’ve now seen how to implement the observer pattern with “handler” functions and <code>Observer</code> object instances, with a <code>Queue</code> observable. Next, we’ll look at where the observer pattern<a id="_idIndexMarker120" class="pcalibre1 calibre6 pcalibre"/> is used in Jav<a id="_idTextAnchor106" class="pcalibre1 calibre6 pcalibre"/>aScript.</p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor107" class="pcalibre1 calibre6 pcalibre"/>Use cases of the observer pattern</h2>
<p class="calibre3">The observer pattern is great for dealing<a id="_idIndexMarker121" class="pcalibre1 calibre6 pcalibre"/> with loosely coupled events or messages. In the context of a web application, this could be DOM events. <code>EventTarget.addEventListener()</code> and <code>EventTarget.removeEventListener()</code>, which are available (among others) on the <code>Window</code>, <code>Document</code>, and <code>Element</code> objects, are a widely used implementation of the observer pattern. They’re used by client-side JavaScript applications to register handlers for user interactions (for example, click, form submit, hover, and mo<a id="_idTextAnchor108" class="pcalibre1 calibre6 pcalibre"/>useover).</p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor109" class="pcalibre1 calibre6 pcalibre"/>Limitations and improvements</h2>
<p class="calibre3">In our queue<a id="_idIndexMarker122" class="pcalibre1 calibre6 pcalibre"/> implementation, handlers<a id="_idIndexMarker123" class="pcalibre1 calibre6 pcalibre"/> are readable from outside of the instance. The handlers are an implementation detail of the queue, which we should be able to change without affecting consuming modules. This means we want to encapsulate the handlers to make them unavailable for consumption by code outside of the <code>Queue</code> class. If we keep the <code>handlers</code> array available, it’s possible for code outside of the <code>Queue</code> class to access and modify it, which means the <code>Queue</code> abstraction breaks down, since consumers integrate against implementation details. This means consumers are tightly coupled to the <code>Queue</code>’s internal implementation.</p>
<p class="calibre3">Therefore, we can use a private<a id="_idIndexMarker124" class="pcalibre1 calibre6 pcalibre"/> field; in modern JavaScript, that’s done<a id="_idIndexMarker125" class="pcalibre1 calibre6 pcalibre"/> using the <code>#</code> syntax. For handlers, it would involve a <code>#handlers</code> declaration in the class followed by access to <code>this.#handlers</code>:</p>
<pre class="source-code">
class Queue {
  #handlers;
  constructor() {
    this.#handlers = [];
  }
  subscribe(handlerFn) {
    this.#handlers.push(handlerFn);
  }
  unsubscribe(handlerFn) {
    this.#handlers = this.#handlers.filter((handler) =&gt;
      handler !== handlerFn);
  }
  notify(message) {
    this.#handlers.forEach((handler) =&gt; {
      handler(message);
    });
  }
}</pre> <p class="calibre3">Another improvement we can make to our queue<a id="_idIndexMarker126" class="pcalibre1 calibre6 pcalibre"/> is to provide a fluent interface so that we can “chain” calls. To do this, we simply<a id="_idIndexMarker127" class="pcalibre1 calibre6 pcalibre"/> need to return <code>this</code> from each of the <code>subscribe</code>, <code>unsubscribe</code>, and <code>notify</code> handlers. This allows us to call the instance methods in a single “chain”; instead of using <code>queue.subscribe()</code> followed by <code>queue.notify()</code>, we can write it as a single statement – <code>queue.subscribe().notify()</code>:</p>
<pre class="source-code">
class Queue {
  #handlers;
  constructor() {
    this.#handlers = [];
  }
  subscribe(handlerFn) {
    this.#handlers.push(handlerFn);
    return this;
  }
  unsubscribe(handlerFn) {
    this.#handlers = this.#handlers.filter((handler) =&gt;
      handler !== handlerFn);
    return this;
  }
  notify(message) {
    this.#handlers.forEach((handler) =&gt; {
      handler(message);
    });
    return this;
  }
}</pre> <p class="calibre3">We can validate that the queue functions<a id="_idIndexMarker128" class="pcalibre1 calibre6 pcalibre"/> as expected with regards to notifying<a id="_idIndexMarker129" class="pcalibre1 calibre6 pcalibre"/> observers, as well as being usable with the fluent (“chained”) interface:</p>
<pre class="source-code">
const queue = new Queue();
const createMessages = [];
const updateMessages = [];
const allMessages = [];
queue
  .subscribe((message) =&gt; {
    if (message.type === 'CREATE') {
      createMessages.push(message);
    }
  })
  .subscribe((message) =&gt; {
    if (message.type === 'UPDATE') {
      updateMessages.push(message);
    }
  })
  .subscribe((message) =&gt; {
    allMessages.push(message);
  });
queue
  .notify({ type: 'CREATE', data: { user: { id: 1 } } })
  .notify({ type: 'CREATE', data: { user: { id: 2 } } })
  .notify({ type: 'CREATE', data: { user: { id: 3 } } })
  .notify({ type: 'UPDATE', data: { user: { id: 1, role:
    'ADMIN' } } })
  .notify({
    type: 'UPDATE',
    data: { user: { id: 3, role: 'DEVELOPER' } },
  })
  .notify({ type: 'UPDATE', data: { user: { id: 3, role:
    'ADMIN' } } });
console.assert(
  createMessages.length === 3,
  '%o collects CREATE messages',
  allMessages
);
console.assert(
  updateMessages.length === 3,
  '%o collects UPDATE messages',
  allMessages
);
console.assert(
  allMessages.length === 6,
  '%o collects all message',
  allMessages
);</pre> <p class="calibre3">We’ve now seen how to implement<a id="_idIndexMarker130" class="pcalibre1 calibre6 pcalibre"/> the observer pattern in JavaScript <a id="_idIndexMarker131" class="pcalibre1 calibre6 pcalibre"/>as well as how to use private fields and a fluent interface to improve our implementation.</p>
<p class="calibre3">In the next section, we’ll implement the state and<a id="_idTextAnchor110" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor111" class="pcalibre1 calibre6 pcalibre"/> strategy patterns.</p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor112" class="pcalibre1 calibre6 pcalibre"/>State and strategy in JavaScript and a simplified approach</h1>
<p class="calibre3">The state and strategy patterns<a id="_idIndexMarker132" class="pcalibre1 calibre6 pcalibre"/> are closely related, in that they allow the extension of a software system‘s functionality by changing decoupled implementation objects, instead of changing the core subject object.</p>
<p class="calibre3">State allows an object to display different behavior based on what state it’s in. This is very useful for modeling state machines. Each state provides the same interface, and the core object calls methods on the different states.</p>
<p class="calibre3">Strategy similarly allows an object to dynamically select an implementation at runtime. In order to do this, the implementation is injected into the object and used.</p>
<p class="calibre3">We can classify the state pattern as a subset of the strategy pattern, where the implementation is dynamically changed by the state instances.</p>
<p class="calibre3">Next, we’ll see how to implement a state machine in JavaScript with the state pattern, as well as implement an object, merging abstraction with t<a id="_idTextAnchor113" class="pcalibre1 calibre6 pcalibre"/>he strategy pattern.</p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor114" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">For our implementation of the state pattern, we’ll use a simplified pull request/merge request/change request example.</p>
<p class="calibre3">A pull request starts in either a draft or open state. From there, it can transition between open and draft, and then transition to a closed or merged state. The merged state is a final state; closed can be undone by reopening the pull request, so it is not final.</p>
<p class="calibre3">To visualize the transitions from all the states, we can use a state diagram representing pull request states and allowed transitions. In <em class="italic">Figure 3</em><em class="italic">.1</em>, the initial state is either draft or open. Both of these states<a id="_idIndexMarker133" class="pcalibre1 calibre6 pcalibre"/> can transition to each other. Open can change to merged or closed, where merged is a valid end state. Draft can also change to closed.</p>
<div><div><img alt="Figure 3.1: A pull request state diagram" src="img/B19109_03_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1: A pull request state diagram</p>
<p class="calibre3">It’s useful to sketch out our <code>PullRequest</code> class first. The possible actions on our <code>PullReques</code>t are <code>open</code>, <code>markDraft</code>, <code>markReadyForReview</code>, <code>close</code>, and <code>merge</code>.</p>
<p class="calibre3">To implement that state pattern, we also expose a <code>setState</code> method. Each state will take the <code>PullRequest</code> instance as a constructor argument, and the initial states of <code>PullRequest</code> are either <code>DraftState</code> or <code>OpenState</code>, based<a id="_idIndexMarker134" class="pcalibre1 calibre6 pcalibre"/> on an <code>isDraft</code> boolean parameter:</p>
<pre class="source-code">
class PullRequest {
  constructor(isDraft = false) {
    this.state = isDraft ? new DraftState(this) : new
      OpenState(this);
  }
  setState(state) {
    this.state = state;
  }
  open() {
    this.state.open();
  }
  markDraft() {
    this.state.markDraft();
  }
  markReadyForReview() {
    this.state.markReadyForReview();
  }
  close() {
    this.state.close();
  }
  merge() {
    this.state.merge();
  }
}</pre> <p class="calibre3">We’ll implement the state machine, starting with the initial and final states. For the initial states, we have <code>DraftState</code> and <code>OpenState</code>; for the final states, we have <code>MergedState</code>.</p>
<p class="calibre3"><code>DraftState</code> only<a id="_idIndexMarker135" class="pcalibre1 calibre6 pcalibre"/> implements <code>markReadyForReview</code> and <code>close</code>, which transition <code>pullRequest</code> to <code>OpenState</code> or <code>ClosedState</code>, respectively:</p>
<pre class="source-code">
class DraftState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markReadyForReview() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
}</pre> <p class="calibre3"><code>OpenState</code> implements <code>markDraft</code>, <code>close</code>, and <code>merge</code>, which transitions <code>pullRequest</code> to <code>DraftState</code>, <code>ClosedState</code>, and <code>MergedState</code>, respectively:</p>
<pre class="source-code">
class OpenState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markDraft() {
    this.pullRequest.setState(new DraftState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
  merge() {
    this.pullRequest.setState(new MergedState
      (this.pullRequest));
  }
}</pre> <p class="calibre3">As a final state, <code>MergedState</code> does not implement <a id="_idIndexMarker136" class="pcalibre1 calibre6 pcalibre"/>any of the methods:</p>
<pre class="source-code">
class MergedState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
}</pre> <p class="calibre3">Finally, <code>ClosedState</code> implements the <code>open</code> method, which transitions <code>pullRequest</code> to <code>OpenState</code>:</p>
<pre class="source-code">
class ClosedState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  open() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
}</pre> <p class="calibre3">We can check that our pull request <a id="_idIndexMarker137" class="pcalibre1 calibre6 pcalibre"/>and states work as expected.</p>
<p class="calibre3">A <code>PullRequest</code> instantiated with <code>isDraft</code> set to <code>true</code> will begin in <code>DraftState</code>. A <code>markReadyForReview</code> call will transition it to <code>OpenState</code>:</p>
<pre class="source-code">
const pullRequest1 = new PullRequest(true);
console.assert(pullRequest1.state instanceof DraftState,
  pullRequest1.state);
pullRequest1.markReadyForReview();
console.assert(pullRequest1.state instanceof OpenState,
  pullRequest1.state);</pre> <p class="calibre3">Once a pull request is merged with <code>pullRequest.merge()</code>, no method is available (they’ll all throw errors):</p>
<pre class="source-code">
pullRequest1.merge();
console.assert(
  captureError(() =&gt; pullRequest1.open()) instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.markReadyForReview())
    instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.close()) instanceof
    Error,
  pullRequest1.state
);</pre> <p class="calibre3">A pull request starting in the open state<a id="_idIndexMarker138" class="pcalibre1 calibre6 pcalibre"/> can be closed. Once in <code>ClosedState</code>, it’s not possible to do anything other than execute <code>open()</code> on it – for example, <code>markDraft</code> will fail with an error:</p>
<pre class="source-code">
const pullRequest2 = new PullRequest(false);
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);
pullRequest2.close();
console.assert(pullRequest2.state instanceof ClosedState,
  pullRequest2.state);
console.assert(
  captureError(() =&gt; pullRequest2.markDraft())
    instanceof Error,
  pullRequest2.state
);
pullRequest2.open();
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);</pre> <p class="calibre3">We’ve now seen how to implement a pull request state machine using the state pattern.</p>
<p class="calibre3">Next, we’ll have a look at implementing strategy.</p>
<p class="calibre3">Our example is an <code>ObjectMerger</code> class, which merges JavaScript objects. There are multiple ways to achieve this in JavaScript, so we structure our <code>ObjectMerger</code> to accept a <code>strategy</code> object<a id="_idIndexMarker139" class="pcalibre1 calibre6 pcalibre"/> and allow updates to it with a <code>setStrategy</code> method. Finally, we expose a <code>combinedObjects</code> method, which calls the instance’s strategy’s <code>combineObjects</code> method with two objects:</p>
<pre class="source-code">
class ObjectMerger {
  constructor(defaultStrategy) {
    this.strategy = defaultStrategy;
  }
  setStrategy(newStrategy) {
    this.strategy = newStrategy;
  }
  combineObjects(obj1, obj2) {
    return this.strategy.combineObjects(obj1, obj2);
  }
}</pre> <p class="calibre3">An example strategy in this case would be to use <code>Object.assign</code> with <code>{}</code> (a new object literal) as the target of the assignment. This has the benefit of not mutating the <code>obj1</code> and <code>obj2</code> parameters:</p>
<pre class="source-code">
class PureObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign({}, obj1, obj2);
  }
}</pre> <p class="calibre3">Our <code>ObjectMerger</code> can be instantiated with the <code>PureObjectAssignStrategy</code>, as follows:</p>
<pre class="source-code">
const objectMerger = new ObjectMerger
  (new PureObjectAssignStrategy());</pre> <p class="calibre3">It can then be used to merge<a id="_idIndexMarker140" class="pcalibre1 calibre6 pcalibre"/> objects without mutating <code>obj1</code> or <code>obj2</code>:</p>
<pre class="source-code">
const obj1 = {
  keys: '123',
};
const obj2 = {
  keys: '456',
};
const defaultMergeStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(defaultMergeStrategyOutput.keys === '456',
  '%o has keys = 456');
console.assert(obj1.keys === '123' &amp;&amp; obj2.keys === '456',
  obj1, obj2);</pre> <p class="calibre3">An example of a naive implementation using <code>Object.assign</code> that doesn’t use a new object as the assignment target (and, therefore, mutates <code>obj1</code>) looks as follows:</p>
<pre class="source-code">
class MutatingObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign(obj1, obj2);
  }
}</pre> <p class="calibre3">It can be used as follows and does indeed mutate <code>obj1</code>:</p>
<pre class="source-code">
objectMerger.setStrategy(new
  MutatingObjectAssignStrategy());
const mutatingMergedStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(
  mutatingMergedStrategyOutput.keys === '456',
  '%o has keys = 456',
  mutatingMergedStrategyOutput
);
console.assert(
  obj1.keys === '456' &amp;&amp; obj2.keys === '456',
  'Mutates the original object obj1 %o, obj2 %o',
  obj1,
  obj2
);</pre> <p class="calibre3">An equivalent strategy<a id="_idIndexMarker141" class="pcalibre1 calibre6 pcalibre"/> to our initial <code>Object.assign({}, obj1, obj2)</code> strategy is to use the spread syntax:</p>
<pre class="source-code">
class ObjectSpreadStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return { ...obj1, ...obj2 };
  }
}</pre> <p class="calibre3">We can validate that spreading <code>obj1</code> and <code>obj2</code> yields the same strategy characteristics as our earlier <code>PureObjectAssignStrategy</code>:</p>
<pre class="source-code">
objectMerger.setStrategy(new ObjectSpreadStrategy());
const newObj1 = { keys: '123' };
const newObj2 = { keys: '456', obj1: newObj1 };
const objectSpreadStrategyOutput =
  objectMerger.combineObjects(
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.keys === '456',
  '%o has keys = 456',
  objectSpreadStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);</pre> <p class="calibre3">One interesting aspect<a id="_idIndexMarker142" class="pcalibre1 calibre6 pcalibre"/> is that this approach only creates a shallow clone; object references inside of the objects are copied, but the contents of the target objects are the same:</p>
<pre class="source-code">
console.assert(
  objectSpreadStrategyOutput.obj1 === newObj1,
  'Does a shallow clone so objectSpreadStrategyOutput.obj1
    references newObj1'
);</pre> <p class="calibre3">We can remediate this by implementing a deep cloning strategy based on <code>structuredClone</code>:</p>
<pre class="source-code">
class DeepCloneObjectAssignStrategy {
  constructor() {}
  combineObjects(obj1, obj2) {
    return Object.assign(structuredClone(obj1),
      structuredClone(obj2));
  }
}</pre> <p class="calibre3"><code>DeepCloneObjectAssignStrategy</code> has all the properties of <code>PureObjectAssignStrategy</code> and <code>ObjectSpreadStrategy</code>, with the addition of doing a deep copy, recursively<a id="_idIndexMarker143" class="pcalibre1 calibre6 pcalibre"/> copying the contents of nested objects instead of copying references to those objects:</p>
<pre class="source-code">
objectMerger.setStrategy(new DeepCloneObjectAssignStrategy());
const deepCloneStrategyOutput = objectMerger.
  combineObjects(newObj1, newObj2);
console.assert(
  deepCloneStrategyOutput.keys === '456',
  '%o has keys = 456',
  deepCloneStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  deepCloneStrategyOutput.obj1 !== newObj1 &amp;&amp;
    deepCloneStrategyOutput.obj1.keys === newObj1.keys,
  'Does a shallow clone so deepCloneStrategyOutput.ob<a id="_idTextAnchor115" class="pcalibre1 calibre16 pcalibre"/>j1
    references newObj1'
);</pre> <p class="calibre3">We’ve now seen how to implement <a id="_idIndexMarker144" class="pcalibre1 calibre6 pcalibre"/>the state and strategy patterns. Next, we’ll look at where the state and strategy patterns are most often used in JavaScript.</p>
<h2 id="_idParaDest-61" class="calibre7"><a id="_idTextAnchor116" class="pcalibre1 calibre6 pcalibre"/>Use cases of the state and strategy patterns</h2>
<p class="calibre3">As mentioned earlier in the chapter, the state pattern<a id="_idIndexMarker145" class="pcalibre1 calibre6 pcalibre"/> is useful for implementing state machines.</p>
<p class="calibre3">A key difference between state and strategy is that, in the state pattern, it tends to be the case that differen<a id="_idTextAnchor117" class="pcalibre1 calibre6 pcalibre"/>t states know about each other – for example, <code>ClosedState</code> creates a new instance of <code>OpenState</code> to transition to it. Similarly, <code>OpenState</code> is aware of all the potential states it can be transitioned to (<code>DraftState</code>, <code>ClosedState</code>, and <code>MergedState</code>). In contrast, when implementing the strategy pattern, different strategies are self-contained and not aware of each other. For example, <code>PureObjectAssignStrategy</code> and <code>MutatingObjectAssignStrategy</code> don’t reference each other.</p>
<p class="calibre3">Strategy is useful to provide a consistent interface with different internal implementations. It’s a useful abstraction when different implementing algorithms should be swappable<a id="_idIndexMarker146" class="pcalibre1 calibre6 pcalibre"/> without an integ<a id="_idTextAnchor118" class="pcalibre1 calibre6 pcalibre"/>rating consumer knowing about it.</p>
<h2 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor119" class="pcalibre1 calibre6 pcalibre"/>Limitations and improvements</h2>
<p class="calibre3">In our state example, note<a id="_idIndexMarker147" class="pcalibre1 calibre6 pcalibre"/> how much<a id="_idIndexMarker148" class="pcalibre1 calibre6 pcalibre"/> of our code is a duplicated class constructor, which takes a <code>pullRequest</code> instance. We can refactor our code by providing a <code>PullRequestBaseState</code> class, which throws <code>IllegalOperationError</code> for each of the state methods:</p>
<pre class="source-code">
class IllegalOperationError extends Error {
  constructor(stateInstance) {
    this.stateInstance = stateInstance;
    throw new Error('Illegal operation for State');
  }
}
class PullRequestBaseState {
  constructor(pullRequest) {
    this.pullRequest = pullRequest;
  }
  markDraft() {
    throw new IllegalOperationError(this);
  }
  markReadyForReview() {
    throw new IllegalOperationError(this);
  }
  open() {
    throw new IllegalOperationError(this);
  }
  close() {
    throw new IllegalOperationError(this);
  }
  merge() {
    throw new IllegalOperationError(this);
  }
}</pre> <p class="calibre3">This means we can define<a id="_idIndexMarker149" class="pcalibre1 calibre6 pcalibre"/> our different<a id="_idIndexMarker150" class="pcalibre1 calibre6 pcalibre"/> states by extending <code>PullRequestBaseState</code>:</p>
<pre class="source-code">
class ClosedState extends PullRequestBaseState {
  open() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
}
class DraftState extends PullRequestBaseState {
  markReadyForReview() {
    this.pullRequest.setState(new OpenState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
}
class OpenState extends PullRequestBaseState {
  markDraft() {
    this.pullRequest.setState(new DraftState
      (this.pullRequest));
  }
  close() {
    this.pullRequest.setState(new ClosedState
      (this.pullRequest));
  }
  merge() {
    this.pullRequest.setState(new MergedState
      (this.pullRequest));
  }
}
class MergedState extends PullRequestBaseState {}</pre> <p class="calibre3">The <code>PullRequest</code> class doesn’t change, and these new state<a id="_idIndexMarker151" class="pcalibre1 calibre6 pcalibre"/> implementations work<a id="_idIndexMarker152" class="pcalibre1 calibre6 pcalibre"/> the same as our previous implementation:</p>
<pre class="source-code">
const pullRequest1 = new PullRequest(true);
console.assert(pullRequest1.state instanceof DraftState,
  pullRequest1.state);
pullRequest1.markReadyForReview();
console.assert(pullRequest1.state instanceof OpenState,
  pullRequest1.state);
pullRequest1.merge();
console.assert(
  captureError(() =&gt; pullRequest1.open()) instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.markReadyForReview())
    instanceof Error,
  pullRequest1.state
);
console.assert(
  captureError(() =&gt; pullRequest1.close()) instanceof
   Error,
  pullRequest1.state
);
const pullRequest2 = new PullRequest(false);
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);
pullRequest2.close();
console.assert(pullRequest2.state instanceof ClosedState,
  pullRequest2.state);
console.assert(
  captureError(() =&gt; pullRequest2.markDraft())
    instanceof Error,
  pullRequest2.state
);
pullRequest2.open();
console.assert(pullRequest2.state instanceof OpenState,
  pullRequest2.state);</pre> <p class="calibre3">For strategy, one thing we can leverage<a id="_idIndexMarker153" class="pcalibre1 calibre6 pcalibre"/> is JavaScript’s first-class function<a id="_idIndexMarker154" class="pcalibre1 calibre6 pcalibre"/> support. Instead of implementing each strategy as an object, we can make them functions.</p>
<p class="calibre3">Our <code>ObjectMerger</code>’s implementation looks as follows:</p>
<pre class="source-code">
class ObjectMerger {
  constructor(defaultStrategy) {
    this.strategy = defaultStrategy;
  }
  setStrategy(newStrategy) {
    this.strategy = newStrategy;
  }
  combineObjects(obj1, obj2) {
    return this.strategy(obj1, obj2);
  }
}</pre> <p class="calibre3">We can then re-implement all our strategies as functions:</p>
<pre class="source-code">
function pureObjectAssignStrategy(obj1, obj2) {
  return Object.assign({}, obj1, obj2);
}
function mutatingObjectAssignStrategy(obj1, obj2) {
  return Object.assign(obj1, obj2);
}
function objectSpreadStrategy(obj1, obj2) {
  return { ...obj1, ...obj2 };
}
function deepCloneObjectAssignStrategy(obj1, obj2) {
  return Object.assign(structuredClone(obj1),
    structuredClone(obj2));
}</pre> <p class="calibre3">The function-based strategy <code>ObjectMerger</code> class has the same attributes<a id="_idIndexMarker155" class="pcalibre1 calibre6 pcalibre"/> as the class-based<a id="_idIndexMarker156" class="pcalibre1 calibre6 pcalibre"/> one that we implemented earlier. The constructor takes a “strategy function”, which it sets on the instance; each instance exposes a <code>setStrategy</code> method, which overrides the strategy function, and a <code>combineObjects</code> method, which we can call to merge objects.</p>
<p class="calibre3">This means we can use our <code>ObjectMerger</code> with all four function-based strategies (<code>pureObjectAssignStrategy</code>, <code>mutatingObjectAssignStrategy</code>, <code>objectSpreadStrategy</code>, and <code>deepCloneObjectAssignStrategy</code>), as the following demonstrates:</p>
<pre class="source-code">
const objectMerger = new ObjectMerger
  (pureObjectAssignStrategy);
const obj1 = {
  keys: '123',
};
const obj2 = {
  keys: '456',
};
const defaultMergeStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(defaultMergeStrategyOutput.keys === '456',
  '%o has keys = 456');
console.assert(obj1.keys === '123' &amp;&amp; obj2.keys === '456',
  obj1, obj2);
objectMerger.setStrategy(mutatingObjectAssignStrategy);
const mutatingMergedStrategyOutput =
  objectMerger.combineObjects(obj1, obj2);
console.assert(
  mutatingMergedStrategyOutput.keys === '456',
  '%o has keys = 456',
  mutatingMergedStrategyOutput
);
console.assert(
  obj1.keys === '456' &amp;&amp; obj2.keys === '456',
  'Mutates the original object obj1 %o, obj2 %o',
  obj1,
  obj2
);
objectMerger.setStrategy(objectSpreadStrategy);
const newObj1 = { keys: '123' };
const newObj2 = { keys: '456', obj1: newObj1 };
const objectSpreadStrategyOutput =
  objectMerger.combineObjects(
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.keys === '456',
  '%o has keys = 456',
  objectSpreadStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  objectSpreadStrategyOutput.obj1 === newObj1,
  'Does a shallow clone so objectSpreadStrategyOutput.obj1
    references newObj1'
);
objectMerger.setStrategy(deepCloneObjectAssignStrategy);
const deepCloneStrategyOutput = objectMerger.combineObjects
  (newObj1, newObj2);
console.assert(
  deepCloneStrategyOutput.keys === '456',
  '%o has keys = 456',
  deepCloneStrategyOutput
);
console.assert(
  newObj1.keys === '123' &amp;&amp; newObj2.keys === '456',
  'Does not mutate the original object newObj1 %o,
    newObj2 %o',
  newObj1,
  newObj2
);
console.assert(
  deepCloneStrategyOutput.obj1 !== newObj1 &amp;&amp;
    deepCloneStrategyOutput.obj1.keys === newObj1.keys,
  'Does a shallow clone so deepCloneStrategyOutput.
    obj1 references newObj1'
);</pre> <p class="calibre3">We’ve shown how to implement<a id="_idIndexMarker157" class="pcalibre1 calibre6 pcalibre"/> the state and strategy patterns<a id="_idIndexMarker158" class="pcalibre1 calibre6 pcalibre"/> in JavaScript, as well as their limitations and improvements, which can be done using modern JavaScript features.</p>
<p class="calibre3">In the next section, we’ll introduce the visitor patte<a id="_idTextAnchor120" class="pcalibre1 calibre6 pcalibre"/>rn and its usage in the JavaScript ecosystem.</p>
<h1 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor121" class="pcalibre1 calibre6 pcalibre"/>Visitor in JavaScript</h1>
<p class="calibre3">The visitor design pattern<a id="_idIndexMarker159" class="pcalibre1 calibre6 pcalibre"/> concerns itself with being able to add functionality to objects without modifying the structure of them.</p>
<p class="calibre3">With classical inheritance, we often end up with a “base class” that is not used directly; it’s used as an “abstract class,” from which “concrete” classes inherit from our “base class.” For example, with <code>BankAccount</code> and <code>BankAccountWithInterest</code>, our class diagram would look as follows, where <code>BankAccountWithInterest</code> extends <code>BankAccount</code> and overrides <code>setBalance</code>.</p>
<div><div><img alt="Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount" src="img/B19109_03_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2: A class diagram for BankAccountWithInterest inheriting from BankAccount</p>
<p class="calibre3">What we can do with the visitor pattern<a id="_idIndexMarker160" class="pcalibre1 calibre6 pcalibre"/> is define <code>BankAccount</code>, which accepts a visitor and an <code>InterestRateVisitor</code> visitor class. As a class diagram, it looks as follows. <code>BankAccount</code> and <code>InterestRateVisitor</code> are not linked via inheritance; they will be linked at runtime when <code>InterestRateVisitor</code> is called by the <code>BankAccount().accept</code> method. This means <code>InterestRateVisitor</code> knows about the structure of <code>BankAccount</code> but not the other way around. Furthermore, a visitor might not need to know the full structure of what it’s visiting, only what’s relevant to implement the visitor’s functionality.</p>
<div><div><img alt="Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor" src="img/B19109_03_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3: A class diagram for BankAccount and an independent InterestRateVisitor</p>
<p class="calibre3">We’ll now see how<a id="_idIndexMarker161" class="pcalibre1 calibre6 pcalibre"/> to implement the<a id="_idTextAnchor122" class="pcalibre1 calibre6 pcalibre"/> <code>BankAccount</code> and <code>InterestRateVisitor</code> scenario.</p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor123" class="pcalibre1 calibre6 pcalibre"/>Implementation</h2>
<p class="calibre3">To implement a visitor, let’s start<a id="_idIndexMarker162" class="pcalibre1 calibre6 pcalibre"/> with a simple <code>BankAccount</code> class. The constructor sets the account type (either a current account or a savings account), the currency, and the initial balance. <code>BankAccount</code> has a <code>setBalance</code> method that can set the value of an account’s balance. The <code>accept</code> method will allow us to accept visitors and call their <code>visit</code> method on the instance:</p>
<pre class="source-code">
class BankAccount {
  /**
   *
   * @param {'CURRENT' | 'SAVINGS'} accountType
   * @param {String} currency
   * @param {Number} balance - balance in minor currency
     unit
   */
  constructor(accountType = 'CURRENT', currency = 'USD',
    balance = 0) {
    this.accountType = accountType;
    this.currency = currency;
    this.balance = balance;
  }
  setBalance(balance) {
    this.balance = balance;
  }
  accept(visitor) {
    visitor.visit(this);
  }
}</pre> <p class="calibre3">A way to structure <code>InterestVisitor</code> is to initialize it with an interest<a id="_idIndexMarker163" class="pcalibre1 calibre6 pcalibre"/> rate and currency. The <code>visit</code> method takes <code>bankAccount</code> and, if the account matches the currency and is a savings account, applies a new balance, based on the interest rate and current balance:</p>
<pre class="source-code">
class InterestVisitor {
  constructor(interestRate, currency) {
    this.interestRate = interestRate;
    this.currency = currency;
  }
  /**
   * @param {BankAccount} bankAccount
   */
  visit(bankAccount) {
    if (
      bankAccount.currency === this.currency &amp;&amp;
      bankAccount.accountType === 'SAVINGS'
    ) {
      bankAccount.setBalance((bankAccount.balance *
        this.interestRate) / 100);
    }
  }
}</pre> <p class="calibre3">Given a set of accounts, we can create<a id="_idIndexMarker164" class="pcalibre1 calibre6 pcalibre"/> USD and GBP <code>InterestVisitor</code> instances:</p>
<pre class="source-code">
const accounts = [
  new BankAccount('SAVINGS', 'GBP', 500),
  new BankAccount('SAVINGS', 'USD', 500),
  new BankAccount('CURRENT', 'USD', 10000),
];
const usdInterestVisitor = new InterestVisitor(105, 'USD');
const gbpInterestVisitor = new InterestVisitor(110, 'GBP');</pre> <p class="calibre3">We can then loop through the accounts and call the <code>accept</code> method with the relevant visitor:</p>
<pre class="source-code">
accounts.forEach((account) =&gt; {
  account.accept(usdInterestVisitor);
  account.accept(gbpInterestVisitor);
});
console.assert(
  accounts[0].balance === 550 &amp;&amp;
    accounts[1].balance === 525 &amp;&amp;
    acc<a id="_idTextAnchor124" class="pcalibre1 calibre16 pcalibre"/>ounts[2].balance === 10000,
  '%o',
  accounts
);</pre> <p class="calibre3">We’ve now seen how to implement<a id="_idIndexMarker165" class="pcalibre1 calibre6 pcalibre"/> the visitor pattern in a band account scenario. Next, we’ll look at popular use cases for the visitor pattern in JavaScript.</p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor125" class="pcalibre1 calibre6 pcalibre"/>Use cases of the visitor pattern</h2>
<p class="calibre3">The visitor pattern provides a simple interface<a id="_idIndexMarker166" class="pcalibre1 calibre6 pcalibre"/> for library authors to allow consumers to extend a library’s functionality. This is especially effective in libraries that deal with trees or other “sets of nodes”. This explains why the visitor pattern is popular for custom plugins for parsing systems such as GraphQL implementations, or compilers such as Babel.</p>
<p class="calibre3">For example, the way to write a custom directive in Apollo Server v2 is to extend <code>SchemaDirectiveVisitor</code>:</p>
<pre class="source-code">
import { SchemaDirectiveVisitor } from 'apollo-server';
class CustomDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    // we can replace/augment the field's resolver
       implementation here
  }
}
'@</strong><code>babel/parser'</code> package:</pre>
<pre class="source-code">
import * as parser from '@babel/parser';
import traverse from '@babel/traverse';
const ast = parser.parse(`function triple(n) {
  return n * 3;
}`);
const CustomVisitor = {
  FunctionDeclaration(path) {
    console.assert(path.node.id.name === 'triple');
  },
};
traverse(ast, CustomVisitor);</pre> <p class="calibre3">We’ve now seen how the visitor<a id="_idIndexMarker167" class="pcalibre1 calibre6 pcalibre"/> pattern is used for libraries that manipulate tree data structures. Next, we<a id="_idTextAnchor126" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor127" class="pcalibre1 calibre6 pcalibre"/>’ll recapitulate what we’ve learned in this chapter.</p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor128" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we saw how behavioral design patterns enable the extension of functionality by supporting different implementations and decoupling parts of the code base.</p>
<p class="calibre3">The observer pattern is useful to support communication with loosely coupled observable/observer pairs. The state and strategy patterns can be used to implement state machines and swap implementations effectively. The visitor pattern is a great way to expose an extension mechanism that’s decoupled from the structure of the objects it’s operating on.</p>
<p class="calibre3">Now that we know how to organize communication between different objects and classes with behavioral design patterns, in the next chapter, we’ll cover reactive view library patterns in React.</p>
</div>
</body></html>