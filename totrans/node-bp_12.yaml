- en: Chapter 12. Developing Desktop Apps with Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 使用Node.js开发桌面应用程序
- en: 'In the previous chapter, we implemented a REST API and built a server that
    processes various requests. Most of the chapters in this book present web technologies,
    applications that work in a browser with the HTTP protocol. It''s interesting
    that Node.js can be used to produce desktop programs, and we don''t have to learn
    a new language or use a new tool. We can continue using HTML, CSS, and JavaScript.
    This is a great benefit because these technologies are easy to learn and develop.
    Node.js is also really fast: We save a lot of time when dealing with large amounts
    of written modules because we don''t have to deal with trivial problems. In this
    chapter, we will write a file browser. Our application will perform the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个REST API并构建了一个处理各种请求的服务器。本书的大部分章节都介绍了网络技术，这些技术是在浏览器中通过HTTP协议工作的应用程序。有趣的是，Node.js可以用来生成桌面程序，我们不需要学习新的语言或使用新的工具。我们可以继续使用HTML、CSS和JavaScript。这是一个很大的好处，因为这些技术易于学习和开发。Node.js也非常快：当我们处理大量编写的模块时，我们可以节省很多时间，因为我们不需要处理琐碎的问题。在本章中，我们将编写一个文件浏览器。我们的应用程序将执行以下操作：
- en: Run as a desktop program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以桌面程序运行
- en: Read the files from our hard drive and display them on the screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的硬盘读取文件并在屏幕上显示它们
- en: Display images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图片
- en: Using node-webkit
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用node-webkit
- en: There are several tools available to write desktop apps. We will use node-webkit
    ([https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)).
    It's an app runtime based on Chromium and Node.js. It's distributed as a binary
    program we run to see the result of our code. It is available for all the major
    operating systems—Linux, Windows, and Mac. So during the development, we will
    use the `nw` executable file, which is the same as using the `node` executable
    to run Node.js scripts. The `nw` file can be downloaded from the official repository
    of the tool in GitHub.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可用于编写桌面应用程序。我们将使用node-webkit（[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)）。它是一个基于Chromium和Node.js的应用程序运行时。它作为二进制程序分发，我们运行它来查看代码的结果。它适用于所有主要的操作系统——Linux、Windows和Mac。因此，在开发过程中，我们将使用`nw`可执行文件，这与使用`node`可执行文件运行Node.js脚本相同。`nw`文件可以从GitHub上该工具的官方仓库下载。
- en: 'Every desktop application written with node-webkit must contain at least two
    files: `package.json` and the main HTML file. Similar to the modules we wrote
    so far, the `package.json` file holds the configuration of our application. The
    following is a simple example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用node-webkit编写的桌面应用程序至少必须包含两个文件：`package.json`和主HTML文件。类似于我们迄今为止编写的模块，`package.json`文件包含我们应用程序的配置。以下是一个简单的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s important that we set a value for the `main` property. It should point
    to the main HTML file of our file browser. The path is relative to the location
    of the `package.json` file. The content of `index.html` will be something like
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为`main`属性设置一个值是很重要的。它应该指向文件浏览器的主HTML文件。路径相对于`package.json`文件的位置。`index.html`的内容可能如下所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is just a regular HTML page, except for the code placed between the `script`
    tags. The `document.write` method is available in every modern browser. However,
    `process` is a Node.js global object. The example is a simple one, but we can
    see the power of node-webkit. In practice, we can mix the client-side JavaScript
    with a server-side JavaScript, which is run in the context of our machine. We
    can code like we do in the Node.js environment while still having access to the
    DOM of the page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是一个普通的HTML页面，除了放置在`script`标签之间的代码。`document.write`方法在所有现代浏览器中都是可用的。然而，`process`是Node.js的全局对象。这个例子很简单，但我们能看出node-webkit的力量。在实践中，我们可以将客户端JavaScript与服务器端JavaScript混合，后者在我们的机器环境中运行。我们可以在Node.js环境中编码，同时仍然可以访问页面的DOM。 '
- en: 'The following are two ways to run the app:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用有以下两种方式：
- en: We can navigate to the directory that contains the files and run `nw ./`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以导航到包含文件的目录并运行`nw ./`
- en: We can zip the two files to `myapp.zip` for example, rename the archive to `myapp.nw`,
    and run `nw myapp.nw`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将这两个文件压缩成`myapp.zip`，例如，将存档重命名为`myapp.nw`，然后运行`nw myapp.nw`
- en: Once we are done programming, we can pack it along with the node-webkit executable.
    For end-users, this means not having to install additional software or download
    node-webkit separately. This makes the distribution much easier. There are some
    rules that we as developers should follow, for example, ship few `.dll` file (under
    Windows OS) and license files. However, it's good to know that it is possible
    to pack the project and run it on other machines without installing dependencies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成编程，我们可以将其与 node-webkit 可执行文件一起打包。对于最终用户来说，这意味着不需要安装额外的软件或单独下载 node-webkit。这使得分发变得更容易。有一些规则我们作为开发者应该遵循，例如，在
    Windows 操作系统下发送少量的 `.dll` 文件（和许可文件）。然而，了解我们可以打包项目并在其他机器上运行它而不安装依赖项是很好的。
- en: 'The steps to do this depend on the operating system and are well-defined in
    the official documentation ([https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)).
    As mentioned, node-webkit is based on Chromium. Generally, when we write a client-side
    JavaScript or CSS, we deal with a lot of problems because there are differences
    between the browsers. However, here we have only one browser and don''t have to
    think about tricky workarounds. All we have to do is write code that works under
    Webkit. We can also use almost the same developer tools panel that we have in
    Google Chrome. After launching our application, we will see the following window—
    that is, a window produced by node-webkit:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作的步骤取决于操作系统，并在官方文档中定义良好（[https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)）。如前所述，node-webkit
    基于 Chromium。通常，当我们编写客户端 JavaScript 或 CSS 时，我们会遇到很多问题，因为浏览器之间存在差异。然而，在这里我们只有一个浏览器，不需要考虑复杂的解决方案。我们只需编写在
    Webkit 下运行的代码即可。我们还可以使用与 Google Chrome 中几乎相同的开发者工具面板。启动我们的应用程序后，我们将看到以下窗口——即由
    node-webkit 生成的窗口：
- en: '![Using node-webkit](img/00070.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用 node-webkit](img/00070.jpeg)'
- en: 'There is a small button in the upper-right corner, which gives us access to
    the **Elements**, **Network**, **Sources**, **Timeline**, **Profiles**, **Resources**,
    **Audits**, and **Console** panels. When we click the button we will see a window
    like the one in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角有一个小按钮，它为我们提供了访问 **元素**、**网络**、**源代码**、**时间轴**、**配置文件**、**资源**、**审核** 和
    **控制台** 面板的权限。当我们点击该按钮时，我们会看到一个类似于以下截图的窗口：
- en: '![Using node-webkit](img/00071.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![使用 node-webkit](img/00071.jpeg)'
- en: Having the same instruments simplifies the debugging and testing processes.
    As we pointed out at the beginning of this chapter, we don't have to learn a new
    language or use different technologies. We can stick to the usual HTML, CSS, and
    JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有相同的工具简化了调试和测试过程。正如我们在本章开头所指出的，我们不必学习新的语言或使用不同的技术。我们可以坚持使用常见的 HTML、CSS 和 JavaScript。
- en: Writing the base of the application
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写应用程序的基础
- en: Before starting the actual implementation of our file browser, we must prepare
    the HTML layout, the base of the JavaScript part, and the `package.json` file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际实现我们的文件浏览器之前，我们必须准备 HTML 布局、JavaScript 部分的基座和 `package.json` 文件。
- en: Writing the package.json file
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 package.json 文件
- en: 'The `package.json` file should be placed in the main path of the project. It''s
    a file with content similar to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json` 文件应放置在项目的根目录下。它是一个包含类似以下代码内容的文件：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We already discussed the `name` and `main` properties. The `window` object is
    a desktop-specific setting; it tells node-webkit how the main application's window
    should look. In the preceding code, we set only three properties. The `width`
    and `height` properties defines the window size and `toolbar` hides or shows the
    uppermost panel, the one that makes our program look like a browser. Usually,
    we don't need it and at the end of the development cycle, we set `toolbar` to
    `false`. There are few other options we can apply, for example, `title` or `icon`.
    We can even hide the close, maximize, and minimize buttons.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 `name` 和 `main` 属性。`window` 对象是针对桌面环境的特定设置；它告诉 node-webkit 主应用程序窗口应该如何显示。在前面代码中，我们只设置了三个属性。`width`
    和 `height` 属性定义了窗口大小，`toolbar` 隐藏或显示最上面的面板，使我们的程序看起来像浏览器。通常我们不需要它，在开发周期结束时，我们将
    `toolbar` 设置为 `false`。还有一些其他选项我们可以应用，例如 `title` 或 `icon`。我们甚至可以隐藏关闭、最大化、最小化按钮。
- en: Preparing the HTML layout
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 HTML 布局
- en: 'The HTML code we start with preparing the layout is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始准备布局的 HTML 代码如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are two CSS files. The first one, `styles.css`, contains the styles written
    specifically for our application and the second one, uses the cool font icons
    from `font-awesome`, icons that are represented by a font and not an image. The
    exact content of this resource is not included in this chapter, but you can find
    it in the additional material provided with the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个CSS文件。第一个是`styles.css`，它包含为我们的应用程序编写的样式，第二个使用来自`font-awesome`的酷字体图标，这些图标由字体表示而不是图像。这个资源的确切内容不包括在本章中，但你可以从本书提供的附加材料中找到。
- en: Also, a `scripts.js` file will host the JavaScript logic of the file browser.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个`scripts.js`文件将托管文件浏览器的JavaScript逻辑。
- en: 'The application has the following two parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有两个部分：
- en: '**tree**: This is where we will show the current directory''s name and its
    content (files and folders)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树**：这是我们展示当前目录的名称及其内容（文件和文件夹）的地方'
- en: '**file info**: If a file is selected, this area will show some of its characteristics
    and the buttons to copy, move, and delete'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件信息**：如果选中了一个文件，这个区域将显示一些其特征和复制、移动和删除的按钮'
- en: 'If we run node-webkit with the preceding code, the result will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面的代码运行node-webkit，结果将如下所示：
- en: '![Preparing the HTML layout](img/00072.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![准备HTML布局](img/00072.jpeg)'
- en: Designing the JavaScript base
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计JavaScript基础
- en: 'Let''s open the `scripts.js` file and see how to structure the JavaScript code.
    At the beginning of the file, we define the required Node.js modules and a global
    variable, `root`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`scripts.js`文件，看看如何构建JavaScript代码。在文件的开头，我们定义了所需的Node.js模块和一个全局变量`root`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the `fs` module for all filesystem-related operations. The `path` module
    contains utility methods used to work with file paths. There are some differences
    between the operating systems for example, in Windows, the paths are written with
    a backslash, whereas in Linux, it uses a forward slash. The `path.normalize` method
    takes care of this by correcting the string to it proper format depending on the
    OS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`fs`模块进行所有文件系统相关的操作。`path`模块包含用于处理文件路径的实用方法。例如，操作系统之间有一些差异，例如，在Windows中，路径使用反斜杠编写，而在Linux中，它使用正斜杠。`path.normalize`方法通过根据操作系统纠正字符串到正确的格式来处理这个问题。
- en: The first folder we are going to read will be the directory the application
    is started in. Thus, we are use `process.cwd()` to get the current working directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要读取的第一个文件夹是应用程序启动的目录。因此，我们使用`process.cwd()`来获取当前工作目录。
- en: 'It''s not a good practice to work in the global scope, so we will create a
    JavaScript class called `Tree` using the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局范围内工作不是一个好的做法，因此我们将创建一个名为`Tree`的JavaScript类，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The definition in the preceding code uses the revealing module pattern, which
    is a great pattern to encapsulate the JavaScript logic. The `api` object is the
    public interface of the class and is returned at the end. The variables `el`,
    `currentLocationArea`, `treeArea`, and `fileArea` are private variables and represent
    the DOM elements on the page. They are initialized in the `init` method. It's
    a good practice to cache the queries to the DOM. By storing the elements' references
    in local variables, we avoid the additional `querySelector` calls.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的定义使用了揭示模块模式，这是一个很好的模式来封装JavaScript逻辑。`api`对象是类的公共接口，并在最后返回。变量`el`、`currentLocationArea`、`treeArea`和`fileArea`是私有变量，代表页面上的DOM元素。它们在`init`方法中初始化。缓存对DOM的查询是一个好的做法。通过将元素的引用存储在局部变量中，我们避免了额外的`querySelector`调用。
- en: 'There are two public properties: `cwd` (current working directory) and `csf`
    (current selected file). We make them public because we may need them outside
    the module. In the beginning, there is no selected file and the value of `csf`
    is `null`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个公共属性：`cwd`（当前工作目录）和`csf`（当前选中文件）。我们使它们成为公共的，因为我们可能需要在模块外部使用它们。一开始，没有选中的文件，`csf`的值是`null`。
- en: 'Similar to the development in the browser, we need an entry point. Our code
    is run in Chromium, so using `window.onload` looks like a good choice. We will
    put our initializing code inside the `onload` handler as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与在浏览器中的开发类似，我们需要一个入口点。我们的代码在Chromium中运行，所以使用`window.onload`看起来是一个不错的选择。我们将把初始化代码放在`onload`处理程序中，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We simply create an instance of our class and call the `init` method. We are
    passing the `.tree-area` parameter, the selector of the `<section>` tag, which
    will display the files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需创建我们类的一个实例并调用`init`方法。我们传递了`.tree-area`参数，这是`<section>`标签的选择器，它将显示文件。
- en: Displaying and using the working directory
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和使用工作目录
- en: In this section, we will cover the main features of our file browser. At the
    end, our application will read the current working directory. It will show its
    content and the user will be able to navigate between the shown folders.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们的文件浏览器的核心功能。最后，我们的应用程序将读取当前工作目录。它将显示其内容，用户可以在显示的文件夹之间进行导航。
- en: Displaying the current working directory
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示当前工作目录
- en: 'We put the value of `api.cwd` in the div with the `currentLocation` class.
    It is represented by the `currentLocationArea` private variable. We only need
    a function that sets the `innerHTML` property of the element:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `api.cwd` 的值放入具有 `currentLocation` 类的 div 中。它由 `currentLocationArea` 私有变量表示。我们只需要一个函数来设置元素的
    `innerHTML` 属性：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is probably the simplest function of our class. We will call it every
    time we change the directory, which can happen pretty often. It''s a good idea
    to delegate this calling to another method. Along with updating the current location
    area, we will refresh the files area too. So, it makes sense to write a `render`
    function. At the moment, the method calls only `updateCurrentLocation`, but we
    will add more functions later:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是我们类中最简单的函数。我们将每次更改目录时都调用它，这可能会很频繁。将此调用委托给另一个方法是个好主意。除了更新当前位置区域外，我们还将刷新文件区域。因此，编写一个
    `render` 函数是有意义的。目前，该方法仅调用 `updateCurrentLocation`，但我们将稍后添加更多函数：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Of course, we should call this `render` function inside the `init` method,
    which gives us the result as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们应该在 `init` 方法中调用这个 `render` 函数，这将给我们以下结果：
- en: '![Displaying the current working directory](img/00073.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![显示当前工作目录](img/00073.jpeg)'
- en: Note that now our file browser shows the directory where the process starts
    from.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们的文件浏览器显示了进程开始处的目录。
- en: Showing the files and folders
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示文件和文件夹
- en: 'In this part of the chapter, we will create a function that shows all the files
    and folders placed inside the current working directory. This may sound like an
    excellent feature, but it comes with its own problems. The major one is if we
    go to the root of our filesystem, we have to show a large number of the items
    on the screen. So, instead of building a giant tree, we will stop at the third
    level of nesting. Let''s add two new private variables:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将创建一个函数，用于显示当前工作目录内放置的所有文件和文件夹。这听起来可能是一个很棒的功能，但它也伴随着它自己的问题。主要问题是如果我们进入文件系统的根目录，我们不得不在屏幕上显示大量项目。因此，我们不会构建一个巨大的树，而会在第三层嵌套处停止。让我们添加两个新的私有变量：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `html` variable will keep the string we apply to the `innerHTML` property
    of the `treeArea` element.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`html` 变量将保持我们应用于 `treeArea` 元素的 `innerHTML` 属性的字符串。'
- en: 'Our browser will process the files and the directories differently. If the
    user selects a file, then it should display information about it such as when
    was the file created, its size, and so on. Along with that our program will provide
    few buttons for operations such as copying, moving, or deleting the file. If a
    folder is clicked, then the `api.cwd` variable should be changed and the `render`
    method should be fired. The visual representation should also be different. The
    following function will add a new item to the tree:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的浏览器将以不同的方式处理文件和目录。如果用户选择一个文件，那么应该显示有关该文件的信息，例如文件创建时间、大小等。此外，我们的程序将提供一些按钮用于操作，如复制、移动或删除文件。如果点击了一个文件夹，那么
    `api.cwd` 变量应该改变，并且应该触发 `render` 方法。视觉表示也应该不同。以下函数将向树中添加一个新项目：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `itemPath` argument contains only the name of the file or directory, while
    `fullPath` shows the absolute path to the item. Based on the `isFile` parameter,
    the icon of the appended link is properly chosen. The latest `indent` argument
    is needed to define the visual look of the tree. Without this, all the links will
    start from the left-hand side of the window. Note that we add the full path to
    the file or folder in a `data-path` attribute. We do this because later any link
    can be clicked and we need to know what is selected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemPath` 参数仅包含文件或目录的名称，而 `fullPath` 显示项目的绝对路径。根据 `isFile` 参数，将正确选择附加链接的图标。需要最新的
    `indent` 参数来定义树的视觉外观。如果没有这个参数，所有链接都将从窗口的左侧开始。请注意，我们在 `data-path` 属性中添加了文件或文件夹的完整路径。我们这样做是因为稍后任何链接都可以点击，我们需要知道选择了什么。'
- en: 'Now, we need a function that uses the `addItem` function, which accepts a path
    and goes through all the files and subdirectories. We also need some kind of recursive
    calling of the method so that we can produce a tree. As we can see in the following
    code, there is a check if we are reading directory and if yes then again the walk
    function is executed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数，该函数使用`addItem`函数，它接受一个路径并遍历所有文件和子目录。我们还需要某种递归调用方法，以便我们可以生成一个树。正如我们可以在以下代码中看到的那样，有一个检查，如果我们在读取目录，并且如果是的话，再次执行`walk`函数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because the `walk` function will be called repeatedly, we need to check whether
    it reaches the maximum level of nesting (which in our case is set to `3`); this
    is the purpose of the first few lines. Immediately after, the `fs.readdir` function
    is called. This is an asynchronous Node.js native function that returns the content
    in a passed directory. In the closure, which receives the data, we will go through
    every result and check whether the item is a file or folder. If it is a folder,
    then the `walk` function is called again. Note that we are passing the level and
    it is incremented on every call.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`walk`函数将被反复调用，我们需要检查它是否达到了最大嵌套级别（在我们的情况下设置为`3`）；这就是前几行的作用。紧接着，调用`fs.readdir`函数。这是一个异步的Node.js原生函数，它返回传递的目录中的内容。在接收数据的闭包中，我们将遍历每个结果并检查项目是文件还是文件夹。如果是文件夹，则再次调用`walk`函数。请注意，我们传递了级别，并且每次调用都会增加。
- en: 'At the end, we just need to run the `walk` method and populate the `html` variable
    with an initial value as it is done in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需运行`walk`方法，并用初始值填充`html`变量，就像以下代码中所做的那样：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the top of the file's tree, we added a link that points to the parent directory.
    This is how the user can move upward in the filesystem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件树的顶部，我们添加了一个指向父目录的链接。这就是用户如何在文件系统中向上移动的方式。
- en: 'The updated render method is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的渲染方法如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, the `updateFiles` method is called pretty often. It''s kind
    of an expensive process because it runs the `walk` function. This is also one
    of the reasons behind limiting the folder''s nesting. If we launch the application
    now, we should see the current directory at the top of the screen and its content
    in the `treeArea` element. The following screenshot is how this looks on the screen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`updateFiles`方法被调用得相当频繁。这有点昂贵，因为它运行了`walk`函数。这也是限制文件夹嵌套的原因之一。如果我们现在启动应用程序，我们应该在屏幕顶部看到当前目录，并在`treeArea`元素中看到其内容。以下截图显示了屏幕上的样子：
- en: '![Showing the files and folders](img/00074.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![显示文件和文件夹](img/00074.jpeg)'
- en: Changing the current directory
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改当前目录
- en: 'Our file browser successfully shows the files located on our hard disk. The
    next thing we want to do is to jump from one folder to another. Because we carefully
    designed our class, it is easy to implement this feature. The following two steps
    will change the directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件浏览器成功显示了位于我们硬盘上的文件。接下来，我们想要做的是从一个文件夹跳转到另一个文件夹。因为我们精心设计了我们的类，所以实现这个功能很容易。以下两个步骤将更改目录：
- en: Update the `api.cwd` variable
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`api.cwd`变量
- en: Call the `render` method
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`render`方法
- en: 'These two actions should be executed when the user clicks on some of the items
    in the tree. The very popular approach is to attach a `click` handler on every
    link and listen for user interaction. However, this will lead to some problems.
    We have to reassign the listeners every time the tree is updated; this is because
    the elements that the listeners are attached to have been replaced and are no
    longer in the DOM. A much better approach is to add only one handler on the `treeArea`
    element. When its children produce the `click` event, by default, it is bubbled
    upwards over the DOM. Moreover, because we do not catch it, it reaches the handler
    of the `treeArea` element. So the following `setEvents` function listens for the
    click events triggered in the `treeArea` object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个动作应该在用户点击树中的某些项目时执行。非常流行的方法是在每个链接上附加一个`click`处理程序并监听用户交互。然而，这将导致一些问题。每次树更新时，我们必须重新分配监听器；这是因为监听器附加到的元素已经被替换并且不再在DOM中。一个更好的方法是在`treeArea`元素上仅添加一个处理程序。当其子元素产生`click`事件时，默认情况下，它会在DOM中向上冒泡。此外，因为我们没有捕获它，所以它达到了`treeArea`元素的处理器。所以以下`setEvents`函数监听在`treeArea`对象中触发的点击事件：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The calling of `e.preventDefault` is needed because we don't want the default
    link behavior. The `href` attribute of all the `<a>` tags is set to `#`. Normally,
    this will scroll the page up to the top. However, we don't want this to happen,
    so we call `e.preventDefault`. The next check guarantees that the `click` event
    comes from the right element. This is actually really important because the user
    may click on some other element, which is still the child of `treeArea`. We expect
    to get the `<a>` or `<i>` (the icon inside the link) tag. The path to the file
    or folder is from the `data-path` attribute. To determine whether the currently
    selected item is a file, we check the value of its `class` attribute. On the other
    hand, if the user clicks on a folder, we simple trigger the `render` method; otherwise,
    a new function, `updateFileArea`, is called.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调用`e.preventDefault`是因为我们不希望执行默认的链接行为。所有`<a>`标签的`href`属性被设置为`#`。通常情况下，这将使页面滚动到顶部。然而，我们不想这样，所以我们调用`e.preventDefault`。接下来的检查确保`click`事件来自正确的元素。这实际上非常重要，因为用户可能会点击一些其他元素，而这些元素仍然是`treeArea`的子元素。我们期望获取到`<a>`或`<i>`（链接内的图标）标签。文件或文件夹的路径来自`data-path`属性。为了确定当前选中的项是否是文件，我们检查其`class`属性的值。另一方面，如果用户点击文件夹，我们简单地触发`render`方法；否则，调用一个新的函数`updateFileArea`。
- en: 'The function we just discussed (`setEvents`) is fired only once, and a proper
    place to do this is the `init` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的函数（`setEvents`）只被触发一次，而进行这一操作的正确位置是`init`方法：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Copying, moving, and deleting files
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制、移动和删除文件
- en: 'We implemented the folder switching, and the last thing to do is file processing.
    We already mentioned calling the `updateFileArea` function. It should accept the
    file path. The following code is the body of the function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了文件夹切换，接下来要做的就是文件处理。我们已经提到了调用`updateFileArea`函数。它应该接受文件路径。以下代码是该函数的主体：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function of the method is to fill the `fileArea` element with information
    about the file. We will use the same function to clear the `fileArea` element
    when the user clicks on a folder. So, if `updateFileArea` is called without any
    parameter, the information block becomes empty. The file size and created and
    modified time are available because of the native Node.js function `fs.stat`.
    Below the file''s characteristics, we place three buttons. Every button calls
    a method of the global `FileBrowser` object, which is an instance of our `Tree`
    class. Note that we do not pass the path to the file. The `copy`, `move`, and
    `del` functions will get this information from the `api.csf` variable that we
    filled earlier. The following method will be used to copy a file from one place
    to another:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的功能是将`fileArea`元素填充与文件相关的信息。当用户点击文件夹时，我们将使用相同的函数清除`fileArea`元素。因此，如果`updateFileArea`函数没有传递任何参数，信息块将变为空。文件大小、创建和修改时间可以通过原生的Node.js函数`fs.stat`获取。在文件特性的下方，我们放置了三个按钮。每个按钮都会调用全局`FileBrowser`对象的方法，该对象是我们`Tree`类的一个实例。请注意，我们没有传递文件的路径。`copy`、`move`和`del`函数将从我们之前填充的`api.csf`变量中获取这些信息。以下方法将用于将文件从一个地方复制到另一个地方：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, we know the file we want to copy, move, or delete and its absolute path.
    It is stored in `api.csf`. To copy and move, we need a destination path. The user
    should be able to pick a directory on the hard disk, and because this process
    occurs in two locations, it is a good idea to wrap it in a function—`getFolder`.
    Once this method returns the destination, we simply get the content as a stream
    and save it to another place. The following is the body of the `getFolder` helper:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道我们想要复制、移动或删除的文件及其绝对路径，它存储在`api.csf`中。为了复制和移动，我们需要一个目标路径。用户应该能够从硬盘上选择一个目录，因为这个过程发生在两个位置，所以将这个过程封装在一个函数中——`getFolder`——是个好主意。一旦这个方法返回目标路径，我们只需将内容作为流获取并保存到另一个地方。以下是`getFolder`辅助函数的主体：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Normally, the dialog to select a directory cannot be opened without user interaction.
    However, in node-webkit this is possible. As we can see in the preceding code,
    we create a new `MouseEvent` event and a new `<input>` element to dispatch this
    event. The key factor here is the `webkitdirectory` attribute, which is node-webkit
    specific, and it transforms the element from a file selector to a folder selector.
    The `getFolder` function accepts a `callback` function, which is called once the
    user selects a directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有用户交互，无法打开选择目录的对话框。然而，在node-webkit中这是可能的。正如前述代码所示，我们创建一个新的`MouseEvent`事件和一个新的`<input>`元素来分发此事件。关键因素是`webkitdirectory`属性，这是node-webkit特有的，它将元素从文件选择器转换为文件夹选择器。`getFolder`函数接受一个`callback`函数，当用户选择目录时，该函数会被调用。
- en: 'The function that deletes a file looks like following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件的函数看起来像以下代码片段：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function that deletes the file is almost the same, except that it uses `fs.unlink`
    to remove the file from the OS. At the end, the method that moves the file, combines
    both the `copy` and `del` functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件的函数几乎相同，只是它使用`fs.unlink`从操作系统中删除文件。最后，移动文件的方法结合了`copy`和`del`函数。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to copy the file and then delete it from the original location. With
    this last addition, our file browser is finished. The following screenshot shows
    how it looks when a file is selected:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复制文件，然后从原始位置删除它。有了这个最后的补充，我们的文件浏览器就完成了。以下截图显示了选择文件时的外观：
- en: '![Copying, moving, and deleting files](img/00075.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![复制、移动和删除文件](img/00075.jpeg)'
- en: Extending the application
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Our file browser looks good so far. We can see the folders and files on our
    machine and can copy, move, or delete them. Also, we did all this with only HTML,
    CSS, and JavaScript. Let's continue and add a new feature. The application we
    wrote is run by Chromium. In other words, our HTML and CSS are rendered by the
    browser, so we can easily show images in it. In the next few pages, we will create
    a program picture viewer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文件浏览器的样子看起来不错。我们可以看到机器上的文件夹和文件，并且可以复制、移动或删除它们。此外，我们只使用了HTML、CSS和JavaScript就完成了所有这些。让我们继续并添加一个新功能。我们编写的应用程序由Chromium运行。换句话说，我们的HTML和CSS由浏览器渲染，因此我们可以在其中轻松显示图像。在接下来的几页中，我们将创建一个程序图片查看器。
- en: Tweaking the updateFileArea function
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整updateFileArea函数
- en: 'The first thing to do is find out whether the currently selected file is an
    image. We will display the JPEG and PNG files, so we should check whether the
    file matches one of these extensions. Before populating the `html` variable with
    the markup, we will extract the file''s extension as it is done in the code below:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是确定当前选定的文件是否为图像。我们将显示JPEG和PNG文件，因此我们应该检查文件是否匹配这些扩展名之一。在将标记填充到`html`变量之前，我们将提取文件的扩展名，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next addition to the function is a button that is shown only if a picture
    is selected. At this point (when we have four buttons), it is good to make some
    changes in the layout to get all the buttons in one line. So far, the links were
    the `block` elements and making them `inline-block` solves the problem. The following
    screenshot shows the result:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一个补充是一个仅在选中图片时显示的按钮。到目前为止（当我们有四个按钮时），对布局做一些更改以使所有按钮都在一行中是很好的。到目前为止，链接是`block`元素，将它们改为`inline-block`解决了问题。以下截图显示了结果：
- en: '![Tweaking the updateFileArea function](img/00076.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![调整updateFileArea函数](img/00076.jpeg)'
- en: Loading a new page for the selected image
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为选定的图像加载新页面
- en: 'Similar to the other three links, the new one calls a function of the global
    `FileBrowser` object—`FileBrowser.viewImage`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他三个链接类似，新的链接调用全局`FileBrowser`对象的函数——`FileBrowser.viewImage`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Preferably, open the image in a new window. To do this, use the `window.open`
    method. This function is available in every browser. It simply loads a specific
    file/URL in a newly created pop up. As shown in the preceding code, the page that
    will be shown is stored in file called `image.html`. Also the picture''s path
    is sent as a `GET` parameter and we will read it later. The following is the code
    in the new file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在新窗口中打开图像。为此，请使用`window.open`方法。此方法在所有浏览器中均可用。它只需在新创建的弹出窗口中加载特定的文件/URL。如前述代码所示，将要显示的页面存储在名为`image.html`的文件中。同时，图片的路径作为`GET`参数发送，我们稍后会读取它。以下是在新文件中的代码：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are only two things on the page. An empty `<img>` tag and an empty `<div>`
    tag, which will display the dimensions of the picture. We should mention that
    this new page has nothing to do with the `index.html` file and the `Tree` class,
    which we used so far. It's a completely new section controlled by another JavaScript
    file—`imageviewer.js`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上只有两样东西。一个空的 `<img>` 标签和一个空的 `<div>` 标签，后者将显示图片的尺寸。我们应该指出，这个新页面与 `index.html`
    文件和 `Tree` 类无关，这是我们迄今为止使用的。这是一个完全新的部分，由另一个 JavaScript 文件——`imageviewer.js` 控制。
- en: Showing the image and its dimensions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示图像及其尺寸
- en: 'There are two difficulties we have to solve. They are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决两个困难。它们如下：
- en: The picture's path is sent via the page's URL, so we should get it from there.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片的路径是通过页面的 URL 发送的，因此我们应该从那里获取它。
- en: The picture's dimensions can be read from a client-side JavaScript, but only
    if the image is fully loaded. So, we will use Node.js.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片的尺寸可以从客户端 JavaScript 中读取，但前提是图片已完全加载。因此，我们将使用 Node.js。
- en: The `imageviewer.js` file will contain a class similar to the `scripts.js` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageviewer.js` 文件将包含一个类似于 `scripts.js` 文件的类。'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At the start of the file, we defined the Node.js modules we are going to use,
    `fs` and `path`, which have been discussed throughout this chapter. However, `image-size`
    is a new module. It accepts an image path and returns its width and height. It's
    not a native Node.js module, so we have to include it in our `package.json` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件开头，我们定义了将要使用的 Node.js 模块，`fs` 和 `path`，这些模块在本章中已讨论。然而，`image-size` 是一个新模块。它接受一个图像路径并返回其宽度和高度。它不是一个原生
    Node.js 模块，因此我们必须将其包含在我们的 `package.json` 文件中。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The node-webkit app runtime uses the same dependency format, and we have to
    call `npm install` to get the module installed in a local `node_modules` directory.
    Also, keep in mind that the application''s packing at the end should include the
    `node_modules` folder. Once everything is set up, we are ready to show the selected
    picture. That''s achieved with the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: node-webkit 应用程序运行时使用相同的依赖格式，我们必须调用 `npm install` 来在本地 `node_modules` 目录中安装模块。同时，请记住，应用程序的最终打包应该包括
    `node_modules` 文件夹。一旦一切准备就绪，我们就可以展示选定的图片。这可以通过以下代码实现：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `location.search` function returns the current URL of the page. We know
    that there is only one parameter called `file`, so we can split the string and
    use only the second element of the array, the parameter we are interested in.
    We have to use `decodeURI` because the path is URL encoded and we could receive
    a wrong value. For example, the interval is normally replaced by `%20`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`location.search` 函数返回页面的当前 URL。我们知道只有一个名为 `file` 的参数，因此我们可以分割字符串并仅使用数组的第二个元素，即我们感兴趣的参数。我们必须使用
    `decodeURI`，因为路径是 URL 编码的，我们可能会收到错误值。例如，间隔通常被替换为 `%20`。'
- en: 'We check whether the file actually exists and determine its dimensions. The
    rest involves showing the image and displaying the size as a text below the `<img>`
    tag. The following screenshot shows how the window may look like:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查文件是否实际存在并确定其尺寸。其余部分涉及显示图片并在 `<img>` 标签下方显示大小作为文本。以下截图显示了窗口可能的外观：
- en: '![Showing the image and its dimensions](img/00077.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![显示图像及其尺寸](img/00077.jpeg)'
- en: Removing the toolbar
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除工具栏
- en: 'The final thing we to do is hide the node-webkit toolbar. The user should not
    be able to see the currently opened file. We can do that by changing the `package.json`
    file using the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是隐藏 node-webkit 工具栏。用户不应该能够看到当前打开的文件。我们可以通过使用以下代码更改 `package.json`
    文件来实现：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Setting the `toolbar` property to `false` changes our application and now it
    looks more like a desktop program, as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `toolbar` 属性设置为 `false` 改变了我们的应用程序，现在它看起来更像是一个桌面程序，如下面的截图所示：
- en: '![Removing the toolbar](img/00078.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![移除工具栏](img/00078.jpeg)'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter of the book, you learned how to build a desktop file browser
    with Node.js. The most interesting aspect is that we used only HTML, CSS, and
    JavaScript. This is because, more often than not, Node.js is used in backend development.
    We explored a realm of possibilities that this wonderful technology offers. It
    works as a command-line tool, task runner, or even wrapper for desktop applications.
    The big open-source community and the well-made package manager make Node.js a
    powerful instrument for developers around the world.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，你学习了如何使用 Node.js 构建桌面文件浏览器。最有趣的地方在于，我们只使用了 HTML、CSS 和 JavaScript。这是因为，大多数情况下，Node.js
    都用于后端开发。我们探索了这个神奇技术所能提供的可能性领域。它既可以作为命令行工具，也可以作为任务运行器，甚至是桌面应用程序的包装器。庞大的开源社区和精心制作的包管理器使得
    Node.js 成为全球开发者强大的工具。
