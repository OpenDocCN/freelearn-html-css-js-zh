- en: Chapter 12. Developing Desktop Apps with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we implemented a REST API and built a server that
    processes various requests. Most of the chapters in this book present web technologies,
    applications that work in a browser with the HTTP protocol. It''s interesting
    that Node.js can be used to produce desktop programs, and we don''t have to learn
    a new language or use a new tool. We can continue using HTML, CSS, and JavaScript.
    This is a great benefit because these technologies are easy to learn and develop.
    Node.js is also really fast: We save a lot of time when dealing with large amounts
    of written modules because we don''t have to deal with trivial problems. In this
    chapter, we will write a file browser. Our application will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run as a desktop program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the files from our hard drive and display them on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using node-webkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several tools available to write desktop apps. We will use node-webkit
    ([https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)).
    It's an app runtime based on Chromium and Node.js. It's distributed as a binary
    program we run to see the result of our code. It is available for all the major
    operating systems—Linux, Windows, and Mac. So during the development, we will
    use the `nw` executable file, which is the same as using the `node` executable
    to run Node.js scripts. The `nw` file can be downloaded from the official repository
    of the tool in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every desktop application written with node-webkit must contain at least two
    files: `package.json` and the main HTML file. Similar to the modules we wrote
    so far, the `package.json` file holds the configuration of our application. The
    following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important that we set a value for the `main` property. It should point
    to the main HTML file of our file browser. The path is relative to the location
    of the `package.json` file. The content of `index.html` will be something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is just a regular HTML page, except for the code placed between the `script`
    tags. The `document.write` method is available in every modern browser. However,
    `process` is a Node.js global object. The example is a simple one, but we can
    see the power of node-webkit. In practice, we can mix the client-side JavaScript
    with a server-side JavaScript, which is run in the context of our machine. We
    can code like we do in the Node.js environment while still having access to the
    DOM of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two ways to run the app:'
  prefs: []
  type: TYPE_NORMAL
- en: We can navigate to the directory that contains the files and run `nw ./`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can zip the two files to `myapp.zip` for example, rename the archive to `myapp.nw`,
    and run `nw myapp.nw`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we are done programming, we can pack it along with the node-webkit executable.
    For end-users, this means not having to install additional software or download
    node-webkit separately. This makes the distribution much easier. There are some
    rules that we as developers should follow, for example, ship few `.dll` file (under
    Windows OS) and license files. However, it's good to know that it is possible
    to pack the project and run it on other machines without installing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to do this depend on the operating system and are well-defined in
    the official documentation ([https://github.com/rogerwang/node-webkit](https://github.com/rogerwang/node-webkit)).
    As mentioned, node-webkit is based on Chromium. Generally, when we write a client-side
    JavaScript or CSS, we deal with a lot of problems because there are differences
    between the browsers. However, here we have only one browser and don''t have to
    think about tricky workarounds. All we have to do is write code that works under
    Webkit. We can also use almost the same developer tools panel that we have in
    Google Chrome. After launching our application, we will see the following window—
    that is, a window produced by node-webkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using node-webkit](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a small button in the upper-right corner, which gives us access to
    the **Elements**, **Network**, **Sources**, **Timeline**, **Profiles**, **Resources**,
    **Audits**, and **Console** panels. When we click the button we will see a window
    like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using node-webkit](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Having the same instruments simplifies the debugging and testing processes.
    As we pointed out at the beginning of this chapter, we don't have to learn a new
    language or use different technologies. We can stick to the usual HTML, CSS, and
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the base of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting the actual implementation of our file browser, we must prepare
    the HTML layout, the base of the JavaScript part, and the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the package.json file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `package.json` file should be placed in the main path of the project. It''s
    a file with content similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We already discussed the `name` and `main` properties. The `window` object is
    a desktop-specific setting; it tells node-webkit how the main application's window
    should look. In the preceding code, we set only three properties. The `width`
    and `height` properties defines the window size and `toolbar` hides or shows the
    uppermost panel, the one that makes our program look like a browser. Usually,
    we don't need it and at the end of the development cycle, we set `toolbar` to
    `false`. There are few other options we can apply, for example, `title` or `icon`.
    We can even hide the close, maximize, and minimize buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the HTML layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML code we start with preparing the layout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are two CSS files. The first one, `styles.css`, contains the styles written
    specifically for our application and the second one, uses the cool font icons
    from `font-awesome`, icons that are represented by a font and not an image. The
    exact content of this resource is not included in this chapter, but you can find
    it in the additional material provided with the book.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a `scripts.js` file will host the JavaScript logic of the file browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application has the following two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tree**: This is where we will show the current directory''s name and its
    content (files and folders)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**file info**: If a file is selected, this area will show some of its characteristics
    and the buttons to copy, move, and delete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run node-webkit with the preceding code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the HTML layout](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Designing the JavaScript base
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open the `scripts.js` file and see how to structure the JavaScript code.
    At the beginning of the file, we define the required Node.js modules and a global
    variable, `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use the `fs` module for all filesystem-related operations. The `path` module
    contains utility methods used to work with file paths. There are some differences
    between the operating systems for example, in Windows, the paths are written with
    a backslash, whereas in Linux, it uses a forward slash. The `path.normalize` method
    takes care of this by correcting the string to it proper format depending on the
    OS.
  prefs: []
  type: TYPE_NORMAL
- en: The first folder we are going to read will be the directory the application
    is started in. Thus, we are use `process.cwd()` to get the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not a good practice to work in the global scope, so we will create a
    JavaScript class called `Tree` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The definition in the preceding code uses the revealing module pattern, which
    is a great pattern to encapsulate the JavaScript logic. The `api` object is the
    public interface of the class and is returned at the end. The variables `el`,
    `currentLocationArea`, `treeArea`, and `fileArea` are private variables and represent
    the DOM elements on the page. They are initialized in the `init` method. It's
    a good practice to cache the queries to the DOM. By storing the elements' references
    in local variables, we avoid the additional `querySelector` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two public properties: `cwd` (current working directory) and `csf`
    (current selected file). We make them public because we may need them outside
    the module. In the beginning, there is no selected file and the value of `csf`
    is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the development in the browser, we need an entry point. Our code
    is run in Chromium, so using `window.onload` looks like a good choice. We will
    put our initializing code inside the `onload` handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We simply create an instance of our class and call the `init` method. We are
    passing the `.tree-area` parameter, the selector of the `<section>` tag, which
    will display the files.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and using the working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the main features of our file browser. At the
    end, our application will read the current working directory. It will show its
    content and the user will be able to navigate between the shown folders.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the current working directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We put the value of `api.cwd` in the div with the `currentLocation` class.
    It is represented by the `currentLocationArea` private variable. We only need
    a function that sets the `innerHTML` property of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is probably the simplest function of our class. We will call it every
    time we change the directory, which can happen pretty often. It''s a good idea
    to delegate this calling to another method. Along with updating the current location
    area, we will refresh the files area too. So, it makes sense to write a `render`
    function. At the moment, the method calls only `updateCurrentLocation`, but we
    will add more functions later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we should call this `render` function inside the `init` method,
    which gives us the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the current working directory](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that now our file browser shows the directory where the process starts
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the files and folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this part of the chapter, we will create a function that shows all the files
    and folders placed inside the current working directory. This may sound like an
    excellent feature, but it comes with its own problems. The major one is if we
    go to the root of our filesystem, we have to show a large number of the items
    on the screen. So, instead of building a giant tree, we will stop at the third
    level of nesting. Let''s add two new private variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `html` variable will keep the string we apply to the `innerHTML` property
    of the `treeArea` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our browser will process the files and the directories differently. If the
    user selects a file, then it should display information about it such as when
    was the file created, its size, and so on. Along with that our program will provide
    few buttons for operations such as copying, moving, or deleting the file. If a
    folder is clicked, then the `api.cwd` variable should be changed and the `render`
    method should be fired. The visual representation should also be different. The
    following function will add a new item to the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `itemPath` argument contains only the name of the file or directory, while
    `fullPath` shows the absolute path to the item. Based on the `isFile` parameter,
    the icon of the appended link is properly chosen. The latest `indent` argument
    is needed to define the visual look of the tree. Without this, all the links will
    start from the left-hand side of the window. Note that we add the full path to
    the file or folder in a `data-path` attribute. We do this because later any link
    can be clicked and we need to know what is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a function that uses the `addItem` function, which accepts a path
    and goes through all the files and subdirectories. We also need some kind of recursive
    calling of the method so that we can produce a tree. As we can see in the following
    code, there is a check if we are reading directory and if yes then again the walk
    function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because the `walk` function will be called repeatedly, we need to check whether
    it reaches the maximum level of nesting (which in our case is set to `3`); this
    is the purpose of the first few lines. Immediately after, the `fs.readdir` function
    is called. This is an asynchronous Node.js native function that returns the content
    in a passed directory. In the closure, which receives the data, we will go through
    every result and check whether the item is a file or folder. If it is a folder,
    then the `walk` function is called again. Note that we are passing the level and
    it is incremented on every call.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, we just need to run the `walk` method and populate the `html` variable
    with an initial value as it is done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the file's tree, we added a link that points to the parent directory.
    This is how the user can move upward in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated render method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `updateFiles` method is called pretty often. It''s kind
    of an expensive process because it runs the `walk` function. This is also one
    of the reasons behind limiting the folder''s nesting. If we launch the application
    now, we should see the current directory at the top of the screen and its content
    in the `treeArea` element. The following screenshot is how this looks on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the files and folders](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Changing the current directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our file browser successfully shows the files located on our hard disk. The
    next thing we want to do is to jump from one folder to another. Because we carefully
    designed our class, it is easy to implement this feature. The following two steps
    will change the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `api.cwd` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `render` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two actions should be executed when the user clicks on some of the items
    in the tree. The very popular approach is to attach a `click` handler on every
    link and listen for user interaction. However, this will lead to some problems.
    We have to reassign the listeners every time the tree is updated; this is because
    the elements that the listeners are attached to have been replaced and are no
    longer in the DOM. A much better approach is to add only one handler on the `treeArea`
    element. When its children produce the `click` event, by default, it is bubbled
    upwards over the DOM. Moreover, because we do not catch it, it reaches the handler
    of the `treeArea` element. So the following `setEvents` function listens for the
    click events triggered in the `treeArea` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The calling of `e.preventDefault` is needed because we don't want the default
    link behavior. The `href` attribute of all the `<a>` tags is set to `#`. Normally,
    this will scroll the page up to the top. However, we don't want this to happen,
    so we call `e.preventDefault`. The next check guarantees that the `click` event
    comes from the right element. This is actually really important because the user
    may click on some other element, which is still the child of `treeArea`. We expect
    to get the `<a>` or `<i>` (the icon inside the link) tag. The path to the file
    or folder is from the `data-path` attribute. To determine whether the currently
    selected item is a file, we check the value of its `class` attribute. On the other
    hand, if the user clicks on a folder, we simple trigger the `render` method; otherwise,
    a new function, `updateFileArea`, is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function we just discussed (`setEvents`) is fired only once, and a proper
    place to do this is the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Copying, moving, and deleting files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We implemented the folder switching, and the last thing to do is file processing.
    We already mentioned calling the `updateFileArea` function. It should accept the
    file path. The following code is the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The function of the method is to fill the `fileArea` element with information
    about the file. We will use the same function to clear the `fileArea` element
    when the user clicks on a folder. So, if `updateFileArea` is called without any
    parameter, the information block becomes empty. The file size and created and
    modified time are available because of the native Node.js function `fs.stat`.
    Below the file''s characteristics, we place three buttons. Every button calls
    a method of the global `FileBrowser` object, which is an instance of our `Tree`
    class. Note that we do not pass the path to the file. The `copy`, `move`, and
    `del` functions will get this information from the `api.csf` variable that we
    filled earlier. The following method will be used to copy a file from one place
    to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we know the file we want to copy, move, or delete and its absolute path.
    It is stored in `api.csf`. To copy and move, we need a destination path. The user
    should be able to pick a directory on the hard disk, and because this process
    occurs in two locations, it is a good idea to wrap it in a function—`getFolder`.
    Once this method returns the destination, we simply get the content as a stream
    and save it to another place. The following is the body of the `getFolder` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Normally, the dialog to select a directory cannot be opened without user interaction.
    However, in node-webkit this is possible. As we can see in the preceding code,
    we create a new `MouseEvent` event and a new `<input>` element to dispatch this
    event. The key factor here is the `webkitdirectory` attribute, which is node-webkit
    specific, and it transforms the element from a file selector to a folder selector.
    The `getFolder` function accepts a `callback` function, which is called once the
    user selects a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that deletes a file looks like following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function that deletes the file is almost the same, except that it uses `fs.unlink`
    to remove the file from the OS. At the end, the method that moves the file, combines
    both the `copy` and `del` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to copy the file and then delete it from the original location. With
    this last addition, our file browser is finished. The following screenshot shows
    how it looks when a file is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Copying, moving, and deleting files](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Extending the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our file browser looks good so far. We can see the folders and files on our
    machine and can copy, move, or delete them. Also, we did all this with only HTML,
    CSS, and JavaScript. Let's continue and add a new feature. The application we
    wrote is run by Chromium. In other words, our HTML and CSS are rendered by the
    browser, so we can easily show images in it. In the next few pages, we will create
    a program picture viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the updateFileArea function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is find out whether the currently selected file is an
    image. We will display the JPEG and PNG files, so we should check whether the
    file matches one of these extensions. Before populating the `html` variable with
    the markup, we will extract the file''s extension as it is done in the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next addition to the function is a button that is shown only if a picture
    is selected. At this point (when we have four buttons), it is good to make some
    changes in the layout to get all the buttons in one line. So far, the links were
    the `block` elements and making them `inline-block` solves the problem. The following
    screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tweaking the updateFileArea function](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Loading a new page for the selected image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the other three links, the new one calls a function of the global
    `FileBrowser` object—`FileBrowser.viewImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Preferably, open the image in a new window. To do this, use the `window.open`
    method. This function is available in every browser. It simply loads a specific
    file/URL in a newly created pop up. As shown in the preceding code, the page that
    will be shown is stored in file called `image.html`. Also the picture''s path
    is sent as a `GET` parameter and we will read it later. The following is the code
    in the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are only two things on the page. An empty `<img>` tag and an empty `<div>`
    tag, which will display the dimensions of the picture. We should mention that
    this new page has nothing to do with the `index.html` file and the `Tree` class,
    which we used so far. It's a completely new section controlled by another JavaScript
    file—`imageviewer.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the image and its dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two difficulties we have to solve. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The picture's path is sent via the page's URL, so we should get it from there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The picture's dimensions can be read from a client-side JavaScript, but only
    if the image is fully loaded. So, we will use Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `imageviewer.js` file will contain a class similar to the `scripts.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At the start of the file, we defined the Node.js modules we are going to use,
    `fs` and `path`, which have been discussed throughout this chapter. However, `image-size`
    is a new module. It accepts an image path and returns its width and height. It's
    not a native Node.js module, so we have to include it in our `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The node-webkit app runtime uses the same dependency format, and we have to
    call `npm install` to get the module installed in a local `node_modules` directory.
    Also, keep in mind that the application''s packing at the end should include the
    `node_modules` folder. Once everything is set up, we are ready to show the selected
    picture. That''s achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `location.search` function returns the current URL of the page. We know
    that there is only one parameter called `file`, so we can split the string and
    use only the second element of the array, the parameter we are interested in.
    We have to use `decodeURI` because the path is URL encoded and we could receive
    a wrong value. For example, the interval is normally replaced by `%20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check whether the file actually exists and determine its dimensions. The
    rest involves showing the image and displaying the size as a text below the `<img>`
    tag. The following screenshot shows how the window may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the image and its dimensions](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Removing the toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final thing we to do is hide the node-webkit toolbar. The user should not
    be able to see the currently opened file. We can do that by changing the `package.json`
    file using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the `toolbar` property to `false` changes our application and now it
    looks more like a desktop program, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the toolbar](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter of the book, you learned how to build a desktop file browser
    with Node.js. The most interesting aspect is that we used only HTML, CSS, and
    JavaScript. This is because, more often than not, Node.js is used in backend development.
    We explored a realm of possibilities that this wonderful technology offers. It
    works as a command-line tool, task runner, or even wrapper for desktop applications.
    The big open-source community and the well-made package manager make Node.js a
    powerful instrument for developers around the world.
  prefs: []
  type: TYPE_NORMAL
