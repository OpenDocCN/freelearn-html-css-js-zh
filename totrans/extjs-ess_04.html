<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Architecting an Ext JS Application</h1></div></div></div><p>Whether you're only developing one application or plan to develop many, it's an excellent idea to consider your application architecture well in advance. The architecture is the internal structure of your application and the programming patterns employed within it.</p><p>Ultimately, following commonly used patterns provides continuity and consistency in your applications. This gives us four major advantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The framework and your applications are easier to learn</li><li class="listitem" style="list-style-type: disc">It takes less time to switch between applications</li><li class="listitem" style="list-style-type: disc">Code sharing between applications is possible</li><li class="listitem" style="list-style-type: disc">You gain consistency among your build and testing tools</li></ul></div><p>As this chapter covers application architecture with Ext JS, the core topics we're going to look at are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sencha Cmd <a id="id95" class="indexterm"/>and how it can be used to help us build our apps</li><li class="listitem" style="list-style-type: disc">The <strong>Model-View-Controller</strong> (<strong>MVC</strong>) architectural pattern</li><li class="listitem" style="list-style-type: disc">The <a id="id96" class="indexterm"/>newly introduced <strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>) architectural pattern</li><li class="listitem" style="list-style-type: disc">Cross-class communication with an event-driven model</li><li class="listitem" style="list-style-type: disc">Considerations for taking your application offline and an offline first design</li></ul></div><p>Ext JS 5 now provides support for both MVC and MVVM application architectures. Essentially, the two patterns split the application, resulting in well-organized code in a well-organized file system.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Getting the most from Sencha Cmd</h1></div></div></div><p>We <a id="id97" class="indexterm"/>described how to get started with Sencha Cmd in <a class="link" href="ch01.html" title="Chapter 1. Getting to Know Ext JS">Chapter 1</a>, <em>Getting to Know Ext JS</em>, but it is possible to do a lot more with it. In this section, we will explore some of its powerful commands and how they can speed up and improve our workflow.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Generating application components</h2></div></div></div><p>Sencha Cmd can<a id="id98" class="indexterm"/> help by generating <a id="id99" class="indexterm"/>MVC/MVVM components to speed up the development process and allow us to focus on our application's logic rather than writing repetitive code.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Generating models</h3></div></div></div><p>To <a id="id100" class="indexterm"/>add a model to your application, make <code class="literal">/path/to/MyWorkspace/BizDash</code> your current directory and run Sencha Cmd, like this:</p><div><pre class="programlisting">
<strong>cd /path/to/MyWorkspace/BizDash </strong>
<strong>sencha generate model User Name:string,Email:string,TelNumber:string</strong>
</pre></div><p>This command adds a <code class="literal">model</code> class in a <code class="literal">User.js</code> file in the <code class="literal">model</code> directory. The file looks like this:</p><div><pre class="programlisting">  fields: [
  {
    name: 'Name',
    type: 'string'
  },
  {
    name: 'Email',
    type: 'string'
  },
  {
    name: 'TelNumber',
    type: 'string'
  }
  ]
});</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Generating views</h3></div></div></div><p>Add a <a id="id101" class="indexterm"/>view to your application in the same way:</p><div><pre class="programlisting">
<strong>cd /path/to/MyWorkspace/BizDash</strong>
<strong>sencha generate view location.Map</strong>
</pre></div><p>This will generate the following files:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">app/view/Location/</code>: The folder for the classes implementing the new view</li><li class="listitem" style="list-style-type: disc"><code class="literal">Map.js</code>: The new view</li><li class="listitem" style="list-style-type: disc"><code class="literal">MapModel.js</code>: The <code class="literal">Ext.app.ViewModel</code> for the new view</li><li class="listitem" style="list-style-type: disc"><code class="literal">MapController.js</code>: The <code class="literal">Ext.app.ViewController</code> for the new view</li></ul></div><p>The output from the preceding code for <code class="literal">Map.js</code> is as follows:</p><div><pre class="programlisting">Ext.define("BizDash.view.location.Map",{
  extend: "Ext.panel.Panel",
  controller: "location-map",
  viewModel: {
    type: "location-map"
  },
  html: "Hello, World!"
});</pre></div><p>The ViewController (<code class="literal">MapController.js</code>) is:</p><div><pre class="programlisting">Ext.define('BizDash.view.location.MapController', {
  extend: 'Ext.app.ViewController',
  alias: 'controller.location-map'
});</pre></div><p>There<a id="id102" class="indexterm"/> are no required parameters in this case beyond the view name. You can, however, add a base class if desired:</p><div><pre class="programlisting">
<strong>cd /path/to/MyWorkspace/MyApp </strong>
<strong>sencha generate view -base Ext.tab.Panel location.Map</strong>
</pre></div><p>This will change the extend used by the view class to <code class="literal">Ext.tab.Panel</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Generating controllers</h3></div></div></div><p>In <a id="id103" class="indexterm"/>Ext JS 5, each view generated by Sencha Cmd has a default <code class="literal">Ext.app.ViewController</code>, so it is not necessary to generate global controllers based on <code class="literal">Ext.app.Controller</code> in most cases. If you need a new controller, you can generate one in the same basic way as with Models and Views:</p><div><pre class="programlisting">
<strong>cd /path/to/MyWorkspace/BizDash</strong>
<strong>sencha generate controller Location</strong>
</pre></div><p>This will generate a file called <code class="literal">Location.js</code> in the controller directory with the following content:</p><div><pre class="programlisting">Ext.define('BizDash.controller.Location', {
  extend: 'Ext.app.Controller'
});</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Upgrading your application</h2></div></div></div><p>As <a id="id104" class="indexterm"/>framework enhancements, features, and bug fixes are implemented, you may find yourself in a position where you wish to upgrade your application to a newer version of the framework. You can do this with the following command:</p><div><pre class="programlisting">
<strong>sencha app upgrade path/to/new/framework</strong>
</pre></div><p>This command will upgrade both, the Sencha Cmd scaffold and the framework used by the application. Complete instructions on upgrading your application are available in the framework documentation.</p><p>It is worth noting that reversing an upgrade operation isn't possible with Sencha Cmd. We recommend ensuring you are in a position to revert the upgrade changes in your version control system before starting.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Refreshing application metadata</h2></div></div></div><p>The<a id="id105" class="indexterm"/> following command regenerates the metadata file containing <em>bootstrap</em> data for the dynamic loader and class system. This must be done any time a class is added, renamed or removed.</p><div><pre class="programlisting">
<strong>sencha app refresh</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Triggering automatic builds</h2></div></div></div><p>The <code class="literal">watch</code> command<a id="id106" class="indexterm"/> is extremely useful as<a id="id107" class="indexterm"/> it watches your code base for changes (edits, deletes, and so on) and triggers a rebuild of the application to speed up the development process.</p><p>When you run the following command, a web server is started to host the application:</p><div><pre class="programlisting">
<strong>sencha app watch</strong>
</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The default port of the web server is 1841.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>MVC and MVVM</h1></div></div></div><p>The next<a id="id108" class="indexterm"/> part of the chapter is going to focus on the architectural patterns that <a id="id109" class="indexterm"/>work best with Ext JS applications. Sencha was the pioneer of MVC in web applications when it introduced the latter in the early versions of Sencha Touch. Since then, MVC (and MVVM) has gained traction and popularity in the web development community as web apps become larger, more complicated, and harder to maintain. One of the main purposes of these application architectures is to provide structure and consistency to your code base. Nowadays, most major frameworks support them, and the same is true of Ext JS.</p><p>We will explain what MVC and MVVM are, their pros and cons, and how they work in a typical Ext JS application.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>What is MVC?</h2></div></div></div><p>Model-View-Controller (MVC) is an architectural pattern for writing software. It splits the user<a id="id110" class="indexterm"/> interface of an application into three distinct parts, which helps organize the code base into logical representations of information, depending upon the function. In an Ext JS application, the end result of this paradigm is to have well-organized code and a well-organized filesystem.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Explaining the abbreviations</h3></div></div></div><p>Sometimes, MVC implementations vary slightly between applications, but in general, each part of the architecture has specific responsibilities. In MVC architecture, every object in the program is a model, a view, or a controller.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec01"/>Model</h4></div></div></div><p>The Model<a id="id111" class="indexterm"/> represents the data we are planning to use within the application. It describes a common format for the data—in most cases simple fields—but it may also contain business rules, validation logic, conversions, formatting rules, and various other functions.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec02"/>View</h4></div></div></div><p>The View<a id="id112" class="indexterm"/> visually represents the data to the user. It is defined using the standard JSON configuration of Ext JS by extending a framework component/widget. For example, a typical view may be a grid, a form, or a chart.</p><p>It is possible that more than one view may display the same data in different ways. For example, a chart and a grid look visually different even though they share the same data.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Best practices dictate that little, if any, business logic exists in the view.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec03"/>Controller</h4></div></div></div><p>The Controller<a id="id113" class="indexterm"/> is the central piece of an MVC application. It is a singular construct and responds to the events in the application and delegates commands between the Model and the View. Due to the clear separation of concerns in MVC, a controller acts as a global message bus listening for events on configured components.</p><p>The following diagram will give you a clearer picture:</p><div><img src="img/6626_04_01.jpg" alt="Controller"/></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Putting this together</h3></div></div></div><p>In your <a id="id114" class="indexterm"/>application, a user will interact with the views, which often contain data that is held in the models. The controller plays the pivotal role of monitoring the various interactions in the view and making the necessary updates to the model or view. Controllers hold almost all of the business logic of the application, leaving the views and models mostly unaware of each other. You can think of it as a Publish-Subscribe model for an application.</p><p>Ext JS has specific classes to manage controllers and models, namely <code class="literal">Ext.app.Controller</code> and <code class="literal">Ext.data.Model</code>. The views should be defined by extending framework widgets.</p><p>It's a good idea to define your model first, as it contains the data you plan on using in the application. Simply extending the <code class="literal">Ext.data.Model</code> class with basic field configurations is all that is required to get you started.</p><p>Following <a id="id115" class="indexterm"/>this, create a view by extending a component or widget. Try to avoid putting business logic in the view; instead, put the logic in the controller. For example, a button in a view should not contain event logic—it should be placed inside the controller.</p><p>Finally, create a controller by extending <code class="literal">Ext.app.Controller</code>. The controller may not be aware of the view, and in many cases, you will be required to manually get a reference to the view before you can do more work. Sencha's documentation on refs (<a class="ulink" href="http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs">http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.app.Controller-cfg-refs</a>) and Component Query (<a class="ulink" href="http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query">http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.ComponentQuery-method-query</a>) explains this in more detail.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Ext JS naming convention and directory structure</h3></div></div></div><p>Sencha uses<a id="id116" class="indexterm"/> a clearly defined naming convention to keep<a id="id117" class="indexterm"/> all our files together. For example, as was explained in <a class="link" href="ch02.html" title="Chapter 2. Mastering the Framework's Building Blocks">Chapter 2</a>, <em>Mastering the Framework's Building Blocks</em>, the class <code class="literal">BizDash.view.Main</code> correlates to a location in your filesystem. In this case, the file is called <code class="literal">Main.js</code> within the <code class="literal">view</code> directory.</p><p>Ensure that you store your models in the <code class="literal">model</code> directory, views in the <code class="literal">view</code> directory, and controllers in the <code class="literal">controller</code> directory.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>The benefits and drawbacks of using MVC</h3></div></div></div><p>There <a id="id118" class="indexterm"/>are a number of advantages of using MVC, which include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Consistency <a id="id119" class="indexterm"/>across applications, which reduces learning time</li><li class="listitem" style="list-style-type: disc">Ease of sharing code between applications</li><li class="listitem" style="list-style-type: disc">Ability to build optimized apps using Sencha's build tools when using MVC</li></ul></div><p>However, the greatest advantage of MVC architecture is that it helps developers avoid writing excessively large files that are difficult to maintain. By clearly splitting the responsibilities of each piece of the application, the classes are stored in a directory structure that's consistent and easy to work with.</p><p>Sadly, MVC architecture does come with its drawbacks. Controllers are globally scoped to the application in the Ext JS approach to MVC, which results in additional business logic to grab references to views, models, and other objects. Controllers could be written to watch any object at any time, so any given controller might have logic for both view A and view B, leading to additional confusion in large applications.</p><p>Unit testing is another issue that crops up time and time again in MVC applications. In MVC models, views and controllers are supposed to be loosely coupled, but testing a controller necessitates some knowledge of the greater application. More often than not, unit testing requires the entire application to be launched in order to test the individual pieces. This <a id="id120" class="indexterm"/>is <a id="id121" class="indexterm"/>obviously cumbersome, time-consuming, and brittle.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Don't fall into the trap of building applications with a relatively small number of controllers, each spanning thousands of lines of code. Ultimately, this causes poor performance and long-term maintenance issues.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>What is MVVM?</h2></div></div></div><p>While<a id="id122" class="indexterm"/> the MVC architecture clearly does have some major benefits, its drawbacks need addressing. The Model-View-ViewModel (MVVM) architecture is an answer. Sencha only introduced MVVM architecture support in Ext JS 5, so you will not be able to apply these principles to your Ext JS 4 or Sencha Touch 2 applications.</p><p>Ext JS 5 still offers support for MVC, so upgrading from Ext JS 4 to 5 will not break your application. Sencha decided to support MVVM in Ext JS 5 to address the drawbacks of maintainability and testing.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Addressing the concerns</h3></div></div></div><p>In <a id="id123" class="indexterm"/>theory, global controllers are very useful, but as you can see, they can be difficult to manage in practice. MVVM overcomes this by introducing a new class called <code class="literal">ViewModel</code>, which manages the data specific to the view. It does this using data bindings. This means we write less code, it's easier to maintain, and a lot easier to test.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Explaining the abbreviations</h3></div></div></div><p>Just like MVC, MVVM is another architectural pattern for writing software. It's based on the MVC pattern, so a lot of this should be familiar.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec04"/>Model</h4></div></div></div><p>The<a id="id124" class="indexterm"/> principle of a Model in MVVM architecture is the same as in MVC.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec05"/>View</h4></div></div></div><p>As with <a id="id125" class="indexterm"/>the Model, the View is also the same in MVVM as it is in MVC. The only difference is that we must set up our data bindings for the view. This is done by adding a ViewModel to the view:</p><div><pre class="programlisting">Ext.define("BizDash.view.location.Map",{
  extend: "Ext.panel.Panel",
  viewModel: {
    type: "location-map"
  }
});</pre></div><p>Unlike<a id="id126" class="indexterm"/> MVC, MVVM architecture tightly couples views to their associated ViewModels and ViewControllers.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec06"/>ViewModel</h4></div></div></div><p>The ViewModel is the key difference between MVVM and MVC. In MVC, using events, our <a id="id127" class="indexterm"/>Controller is responsible for managing the communication between a Model and a View. In MVVM, the framework does the heavy lifting behind the scenes and does this using data binding.</p><p>Data binding is simply a mechanism to connect the user interface with the business logic. For instance, when the values in the UI are changed, the underlying data value in the model also changes.</p><p>The result of introducing ViewModels is that the Model and framework perform much more work than before, which minimizes the application logic required to manipulate the View.</p><p>Have a look at the following diagram:</p><div><img src="img/6626_04_02.jpg" alt="ViewModel"/></div><p>A <a id="id128" class="indexterm"/>typical ViewModel may look like this:</p><div><pre class="programlisting">Ext.define('BizDash.view.location.MapModel', {
  extend: 'Ext.app.ViewModel',
  alias: 'viewmodel.location-map',
  data: {
    name: 'Map Location'
  }
});</pre></div><p>ViewModels provide a bridge between the Models' data and its visual representation. They are tied closely to the views and provide the data that they represent.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Business logic</h3></div></div></div><p>There's<a id="id129" class="indexterm"/> still the question of application logic, however. There are two options for this, but in general, your business logic should go in ViewControllers.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec07"/>ViewControllers</h4></div></div></div><p>A ViewController is <a id="id130" class="indexterm"/>very similar to a Controller, as it still uses a Publish-Subscribe model by listening for events. Where it differs is in how it's<a id="id131" class="indexterm"/> coupled to the view.</p><p>A ViewController is:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scoped directly to a View</li><li class="listitem" style="list-style-type: disc">Has a one-to-one relationship</li><li class="listitem" style="list-style-type: disc">Created for every instance of the View</li></ul></div><p>This drastically reduces overheads, as your application doesn't have as many events and component references floating about. Memory leaks and state management are easier to identify and maintain, as the ViewController is tied to the View that referenced it.</p><div><img src="img/6626_04_03.jpg" alt="ViewControllers"/></div><p>Your ViewController will start off looking like this:</p><div><pre class="programlisting">Ext.define('BizDash.view.location.MapController', {
  extend: 'Ext.app.ViewController',
  alias: 'controller.location-map'
});</pre></div><p>The alias defined here can be used in a View definition's controller configuration to tie the <a id="id132" class="indexterm"/>two <a id="id133" class="indexterm"/>classes together.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec08"/>Controllers</h4></div></div></div><p>You <a id="id134" class="indexterm"/>can, however, continue to use controllers for your <a id="id135" class="indexterm"/>application-wide message bus. They will continue to listen for events in multiple views just like in the MVC architecture.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Cross-class communication with events</h1></div></div></div><p>Your<a id="id136" class="indexterm"/> Ext JS application makes use of events to handle user interaction, but it is also easy to have your classes communicate with each other via events.</p><p>Ext JS is very mature in the way it handles events, as it's something that's been at the core of the framework since the beginning. It uses an observer pattern to allow your classes to publish events and others to subscribe to those events. Your subscribing class will have its logic triggered as soon as the publishing class fires the event. This paradigm is asynchronous and modular.</p><p>As we covered in <a class="link" href="ch02.html" title="Chapter 2. Mastering the Framework's Building Blocks">Chapter 2</a>, <em>Mastering the Framework's Building Blocks</em>, the event-driven logic in Ext JS is handled by the <code class="literal">Ext.mixin.Observable</code> class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Taking your application offline</h1></div></div></div><p>When <a id="id137" class="indexterm"/>building applications, developers often debate the problem of designing a system that's capable of working offline. Ext JS as a framework is designed to imitate the components and widgets one may typically see in a standard desktop environment. It gives us the tools we need to build truly rich applications and an experience that's similar, if not better, than a legacy desktop application. For web developers, the issue is that users are already used to working with software that's been designed "offline first" The same applies to many mobile or tablet apps.</p><p>Take an e-mail client as an example: the desktop clients continue to work even when your data connection is lost. You can read e-mail, search, organize folders, and do much more. On the other hand, the equivalent web-based client is not likely to fare so well. Try it yourself.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Why should we design offline first?</h2></div></div></div><p>Apart from <a id="id138" class="indexterm"/>ensuring that the web is, and remains, a viable <a id="id139" class="indexterm"/>solution for delivering applications, there are many advantages of considering taking your applications offline:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The most important fact is that <em>we go offline</em>. It might not be intended and it may not be desirable, but connectivity is sporadic and not always guaranteed. This might result in your user losing data or being unable to complete their job.</li><li class="listitem" style="list-style-type: disc">We don't have ubiquitous Internet. We've got to work within the confines of our mobile and fixed line network providers.</li><li class="listitem" style="list-style-type: disc">Mobile, remote working and accessing systems on the move are more popular than ever before. This trend is continuing, and most developers are required to consider this when developing new applications.</li><li class="listitem" style="list-style-type: disc">Performance is greatly enhanced as the user does much of the work locally, leaving your servers for other, more important tasks.</li><li class="listitem" style="list-style-type: disc">Reliability and trust are improved, as your users see the application as something that doesn't come with the usual flaws.</li><li class="listitem" style="list-style-type: disc">Finally, robustness is improved, as, for example, your server downtime doesn't necessarily mean application downtime.</li></ul></div><p>To summarize, an offline first approach will enable you to deliver a better user experience.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>What can we do about this?</h2></div></div></div><p>Different <a id="id140" class="indexterm"/>apps have different approaches and the difficulty rating of each is different. Common approaches, in order of simplest to most complex, are to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Warn the user they are offline</li><li class="listitem" style="list-style-type: disc">Provide the user cached data</li><li class="listitem" style="list-style-type: disc">Allow users minimal interaction</li><li class="listitem" style="list-style-type: disc">Allow users full interaction with a complex application</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>How can we do this?</h2></div></div></div><p>There <a id="id141" class="indexterm"/>are a number of ways to achieve this in web applications, and choosing the right method for your application isn't straightforward.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Native packaging is an option, similar to that of hybrid mobile apps. It is possible to package your web applications with tools such as Embedded WebKit, Cordova, or Chrome/Firefox apps.</li><li class="listitem" style="list-style-type: disc">Using the web app manifest to define the details and APIs present in your app.</li><li class="listitem" style="list-style-type: disc">Using<a id="id142" class="indexterm"/> AppCache is useful to have the browser cache files and resources.</li><li class="listitem" style="list-style-type: disc">ServiceWorkers are useful if you need to do background processing; for example, data syncing. It's still early days for ServiceWorkers, but these might be ideal for many JavaScript developers.</li><li class="listitem" style="list-style-type: disc">LocalStorage is great for storing data in key-value pairs. Ext JS provides excellent support for working with LocalStorage, but be wary of its browser enforced storage limitations—typically around 5 MB.</li><li class="listitem" style="list-style-type: disc">IndexedDB or WebSQL are other ways storing application data in the client side. WebSQL has been deprecated but IndexedDB is an extremely viable alternative and has excellent support from Ext JS.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Offline architecture</h2></div></div></div><p>There's a<a id="id143" class="indexterm"/> lot to consider, and it goes without saying that clearly, an offline web application requires a different architecture.</p><p>You should always plan for the worst and hope for the best.</p><p>One solution to the problem is to put all the state in the client and then sync it whenever possible. Essentially, you want to design your application to download and store files in cache on the user's hard disk and interact with locally stored data. In the background, the locally stored data is synced with your server through some form of proxy.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Syncing data</h2></div></div></div><p>Syncing<a id="id144" class="indexterm"/> data with your backend is perhaps the trickiest part of developing an application with the offline first principle. Writing a sync protocol is a difficult and time-consuming process. You should consider using frameworks and tools, such as Hoodie, PouchDB, and remoteStorage.io to alleviate the problem that syncing causes.</p><p>In order to get the best results, we recommend that you follow these guidelines:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Do it often and as soon as possible</li><li class="listitem" style="list-style-type: disc">Transfer the minimal amount of data you can get away with</li><li class="listitem" style="list-style-type: disc">Be prepared for unreliable data networks</li><li class="listitem" style="list-style-type: disc">Have <a id="id145" class="indexterm"/>a strategy to manage conflicts</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>This chapter has focused on the principles of application architecture and some of the tools we have available in Ext JS 5 applications. We have covered:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sencha Cmd to generate models, views, and controllers</li><li class="listitem" style="list-style-type: disc">MVC and MVVM architecture patterns</li><li class="listitem" style="list-style-type: disc">Cross-class communication</li><li class="listitem" style="list-style-type: disc">Working with offline data</li></ul></div><p>The next chapter will deepen your knowledge further by introducing data packages in detail. A solid understanding of data modeling and stores will stand you in good stead to develop advanced web applications.</p></div></body></html>