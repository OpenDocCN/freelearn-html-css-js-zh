["```js\nin vec4 aVertexColor;\n```", "```js\nfloat lambertTerm = 1.0;\n\nif (uUseLambert) {\n  vec3 normal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));\n  vec3 lightDirection = normalize(-uLightPosition);\n  lambertTerm = max(dot(normal, -lightDirection), 0.20);\n}\n```", "```js\nId = uLightDiffuse * uMaterialDiffuse * lambertTerm;\n```", "```js\nif (uUseVertexColor) {\n  Id = uLightDiffuse * aVertexColor * lambertTerm;\n}\nelse {\n  Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;\n}\n```", "```js\n// gl.disable(gl.DEPTH_TEST);\n// gl.enable(gl.BLEND);\n// gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n```", "```js\ngl.MAX_VERTEX_UNIFORM_VECTORS\ngl.MAX_FRAGMENT_UNIFORM_VECTORS\n```", "```js\ngetArray(type) {\n  return this.list.reduce((result, light) => {\n    result = result.concat(light[type]);\n    return result;\n  }, []);\n}\n```", "```js\n// Load up the given attributes and uniforms from the given values\nload(attributes, uniforms) {\n  this.useProgram();\n  this.setAttributeLocations(attributes);\n  this.setUniformLocations(uniforms);\n}\n```", "```js\n// Set references to attributes onto the program instance\nsetAttributeLocations(attributes) {\n  attributes.forEach(attribute => {\n    this[attribute] = this.gl.getAttribLocation(this.program, attribute);\n  });\n}\n\n// Set references to uniforms onto the program instance\nsetUniformLocations(uniforms) {\n  uniforms.forEach(uniform => {\n    this[uniform] = this.gl.getUniformLocation(this.program, uniform);\n  });\n}\n```", "```js\ngl.uniform3fv(program.uLightPosition, value);\n```", "```js\nuniform vec3 uPositionRedLight; \nuniform vec3 uPositionGreenLight; \n```", "```js\nuniform vec3 uPositionBlueLight;\n```", "```js\nout vec3 vRedRay;\nout vec3 vGreenRay;\n```", "```js\nout vec3 vBlueRay;\n```", "```js\nvec4 blueLightPosition = uModelViewMatrix * vec4(uPositionBlueLight, 1.0);\n```", "```js\nvBlueRay = vertex.xyz - blueLightPosition.xyz;\n```", "```js\nuniform vec4 uDiffuseRedLight;\nuniform vec4 uDiffuseGreenLight;\n```", "```js\nuniform vec4 uDiffuseBlueLight;\n```", "```js\nin vec3 vRedRay;\nin vec3 vGreenRay;\n```", "```js\nin vec3 vBlueRay;\n```", "```js\n// ambient Term\nvec4 Ia = uLightAmbient * uMaterialAmbient;\n```", "```js\n// diffuse Term\nvec4 Id1 = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 Id2 = vec4(0.0, 0.0, 0.0, 1.0);\n```", "```js\nvec4 Id3 = vec4(0.0, 0.0, 0.0, 1.0);\n```", "```js\nfloat lambertTermOne = dot(N, -normalize(vRedRay));\nfloat lambertTermTwo = dot(N, -normalize(vGreenRay));\n```", "```js\nfloat lambertTermThree = dot(N, -normalize(vBlueRay));\n```", "```js\nif (lambertTermOne > uCutOff) {\n  Id1 = uDiffuseRedLight * uMaterialDiffuse * lambertTermOne;\n}\n\nif (lambertTermTwo > uCutOff) {\n  Id2 = uDiffuseGreenLight * uMaterialDiffuse * lambertTermTwo;\n}\n```", "```js\nif (lambertTermThree > uCutOff) {\n  Id3 = uDiffuseBlueLight * uMaterialDiffuse * lambertTermTwo;\n}\n```", "```js\nfragColor = vec4(vec3(Ia + Id1 + Id2 + Id3), 1.0);\n```", "```js\nconst redLight = new Light('redLight');\nredLight.setPosition(redLightPosition);\nredLight.setDiffuse([1, 0, 0, 1]);\n\nconst greenLight = new Light('greenLight');\ngreenLight.setPosition(greenLightPosition);\ngreenLight.setDiffuse([0, 1, 0, 1]);\n```", "```js\nconst blue = new Light('blueLight');\nblue.setPosition([-2.5, 3, 3]);\nblue.setDiffuse([0.0, 0.0, 1.0, 1.0]);\n```", "```js\nconst uniforms = [\n  'uProjectionMatrix',\n  'uModelViewMatrix',\n  'uNormalMatrix',\n  'uMaterialDiffuse',\n  'uMaterialAmbient',\n  'uLightAmbient',\n  'uDiffuseRedLight',\n  'uDiffuseGreenLight',\n 'uDiffuseBlueLight',  'uPositionRedLight',\n  'uPositionGreenLight',\n 'uPositionBlueLight',  'uWireframe',\n  'uLightSource',\n  'uCutOff'\n];\n```", "```js\ngl.uniform3fv(program.uPositionRedLight, redLight.position);\ngl.uniform3fv(program.uPositionGreenLight, greenLight.position);\ngl.uniform3fv(program.uPositionBlueLight, blueLight.position); \ngl.uniform4fv(program.uDiffuseRedLight, redLight.diffuse);\ngl.uniform4fv(program.uDiffuseGreenLight, greenLight.diffuse);\ngl.uniform4fv(program.uDiffuseBlueLight, blueLight.diffuse);\n```", "```js\nscene.load('/common/models/geometries/sphere3.json', 'blueLight');\n```", "```js\nconst modelViewMatrix = transforms.modelViewMatrix;\n\nif (object.alias === 'redLight') {\n  mat4.translate(\n    modelViewMatrix, modelViewMatrix, \n    program.getUniform(program.uPositionRedLight)\n  );\n  object.diffuse = program.getUniform(program.uDiffuseRedLight);\n  gl.uniform1i(program.uLightSource, true);\n}\n\nif (object.alias === 'greenLight') {\n  mat4.translate(\n    modelViewMatrix, modelViewMatrix,\n    program.getUniform(program.uPositionGreenLight)\n  );\n  object.diffuse = program.getUniform(program.uDiffuseGreenLight);\n  gl.uniform1i(program.uLightSource, true);\n}\n```", "```js\nif (object.alias === 'blueLight') {\n  mat4.translate(\n    modelViewMatrix, modelViewMatrix,\n    program.getUniform(program.uPositionBlueLight)\n  );\n  object.diffuse = program.getUniform(program.uDiffuseBlueLight);\n  gl.uniform1i(program.uLightSource, true);\n}\n```", "```js\nuniform vec3 uPositionLight[3];\n```", "```js\nuniform int numLights;\nuniform vec3 uPositionLight[numLights]; // will not work\n```", "```js\nERROR: 0:12 — constant expression required\nERROR: 0:12 — array size must be a constant integer expression\n```", "```js\nconst int numLights = 3;\nuniform vec3 uPositionLight[numLights]; // will work \n```", "```js\nuniform vec4 uDiffuseLight[5];\nuniform vec4 uSpecularLight[5];\n```", "```js\nconst lightPosition1 = [0, 7, 3];\nconst lightPosition2 = [2.5, 3, 3];\nconst lightPosition3 = [-2.5, 3, 3];\n```", "```js\nconst location = gl.getUniformLocation(program, 'uPositionLight');\n```", "```js\ngl.uniform3fv(location, [0, 7, 3, 2.5, 3, 3, -2.5, 3, 3]);\n```", "```js\ngl.uniform3fv(location, [\n  [0, 7, 3],\n  [2.5, 3, 3],\n  [-2.5, 3, 3]\n]);\n```", "```js\nfor(int i = 0; i < numLights; i++) {\n  vec4 lightPosition = uModelViewMatrix * vec4(uLightPosition[i], \n   1.0);\n  vLightRay[i] = vertex.xyz - lightPosition.xyz;\n}\n```", "```js\nvec4 redLightPosition = uModelViewMatrix * vec4(uPositionRedLight, \n 1.0);\nvec4 greenLightPosition = uModelViewMatrix * \n vec4(uPositionGreenLight, 1.0);\nvec4 blueLightPosition = uModelViewMatrix * \n vec4(uPositionBlueLight, 1.0);\n\nvRedRay = vertex.xyz - redLightPosition.xyz;\nvGreenRay = vertex.xyz - greenLightPosition.xyz;\nvBlueRay = vertex.xyz - blueLightPosition.xyz;\n```", "```js\nfor(int i = 0; i < numLights; i++) {\n  L = normalize(vLightRay[i]);\n  lambertTerm = dot(N, -L);\n  if (lambertTerm > uCutOff) {\n    finalColor += uLightDiffuse[i] * uMaterialDiffuse * lambertTerm;\n  }\n}\n```", "```js\nconst uniforms = [\n  'uPerspectiveMatrix',\n  'uModelViewMatrix',\n  'uNormalMatrix',\n  'uMaterialDiffuse',\n  'uMaterialAmbient',\n  'uLightAmbient',\n  'uLightDiffuse',\n  'uLightPosition',\n  'uWireframe',\n  'uLightSource',\n  'uCutOff'\n];\n```", "```js\nconst whiteLight = new Light('whiteLight');\nwhiteLight.setPosition([0, 10, 2]);\nwhiteLight.setDiffuse([1.0, 1.0, 1.0, 1.0]);\n```", "```js\nlights.add(whiteLight);\n```", "```js\nscene.load('/common/models/geometries/sphere3.json', 'whiteLight');\n```", "```js\nif (object.alias === 'whiteLight') {\n  const whiteLight = lights.get(object.alias);\n  mat4.translate(modelViewMatrix, modelViewMatrix, \n   whiteLight.position);\n  object.diffuse = whiteLight.diffuse;\n  gl.uniform1i(program.uLightSource, true);\n}\n```", "```js\nout vec3 vNormal[numLights];\n```", "```js\nfor(int i = 0; i < numLights; i++) {\n  vec4 positionLight = uModelViewMatrix * vec4(uLightPosition[i], \n   1.0);\n  vec3 directionLight = vec3(uNormalMatrix * \n   vec4(uLightDirection[i], 1.0));\n  vNormal[i] = normal - directionLight;\n  vLightRay[i] = vertex.xyz - positionLight.xyz;\n}\n```", "```js\nN = normalize(vNormal[i]);\n```", "```js\nif (lambertTerm > uCutOff) {\n  finalColor += uLightDiffuse[i] * uMaterialDiffuse;\n}\n```", "```js\nfinalColor += uLightDiffuse[i] * uMaterialDiffuse * lambertTerm;\n```", "```js\nif (lambertTerm > uCutOff) {\n  finalColor += uLightDiffuse[i] * uMaterialDiffuse * lambertTerm;\n}\n```", "```js\nfinalColor += uLightDiffuse[i] * uMaterialDiffuse * pow(lambertTerm, 10.0 * uCutOff);\n```", "```js\ngl.enable(gl.DEPTH_TEST);\n```", "```js\ngl.disable(gl.DEPTH_TEST);\n```", "```js\ngl.enable(gl.BLEND);\n```", "```js\ncolor = S * sW + D * dW;\n```", "```js\ncolor = S.rgb * sW.rgb + D.rgb * dW.rgb;\nalpha = S.a * sW.a + D.a * dW.a;\n```", "```js\ncolor = S.rgb * S.a + D.rbg * (1.0 - S.a);\nalpha = S.a * 1.0 + D.a * 0.0;\n```", "```js\ngl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ZERO);\n```", "```js\ncolor = S * sW + D * dW;\n```", "```js\ncolor = S * sW - D  * dW;\n```", "```js\ncolor = D* dw - S * sW;\n```", "```js\ncolor = S * (sW) + D * dW;\n```", "```js\ngl.blendFunc(gl.ONE, gl.ONE);\n```", "```js\ncolor = S * 1.0 + D * 1.0;\ncolor = S + D;\n```", "```js\ngl.blendEquation(gl.FUNC_SUBTRACT);\ngl.blendFunc(gl.ONE, gl.ONE);\n```", "```js\ncolor = S * 1.0 - D * 1.0;\ncolor = S - D;\n```", "```js\ngl.blendFunc(gl.DST_COLOR, gl.ZERO);\n```", "```js\ncolor = S * D + D * 0.0;\ncolor = S * D;\n```", "```js\ncolor = S * S.a + D *(1 - S.a);\n```", "```js\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n```", "```js\ngl.enable(gl.FACE_CULLING);\n```", "```js\nif (showBackFace) {\n  gl.cullFace(gl.FRONT);\n  gl.drawElements(gl.TRIANGLES, object.indices.length, \n   gl.UNSIGNED_SHORT, 0);\n}\n\nif (showFrontFace) {\n  gl.cullFace(gl.BACK);\n  gl.drawElements(gl.TRIANGLES, object.indices.length, \n   gl.UNSIGNED_SHORT, 0);\n}\n```", "```js\ngl.enable(gl.DEPTH_TEST);\ngl.depthFunc(gl.LESS);\n```", "```js\ngl.enable(gl.BLEND);\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n```", "```js\nfunction load() {\n  scene.add(new Floor(80, 20));\n  scene.load('/common/models/ch6/cone.json', 'cone');\n  scene.load('/common/models/ch6/wall.json', 'wall', {\n    diffuse: [0.5, 0.5, 0.2, 1.0],\n    ambient: [0.2, 0.2, 0.2, 1.0]\n  });\n}\n```", "```js\nscene.traverse(object => {\n  // ...\n});\n```"]