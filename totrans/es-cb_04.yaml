- en: Working with async/await and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating promises with an async function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting the result of an async function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using async results in a Promise chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting multiple results in a series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting multiple results concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Promise.all to collect an array of async results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors when awaiting an async function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors thrown inside of Promise.all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using finally to ensure an operation is performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how Promises are a huge improvement over the
    callback pattern. But we also saw that there were still some rough edges around
    composition. Creating promises directly takes different shape functions that are
    placed later in the chain. Errors and successful results were provided in different
    ways depending on how the Promise was created. And there is still be a bit of
    inconvenient nesting.
  prefs: []
  type: TYPE_NORMAL
- en: The `async` and `await` operators were introduced with ES8\. These build on
    top of the Promise to make working with and creating Promises more seamless. In
    this chapter, we'll see how `async` and `await` can be used to create and work
    with promises in a more elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating promises with an async function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` functions are an easy way to create and work with promises. In this
    recipe, we'll see a basic form of this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-01-creating-Promise-with-async`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` with an `async` function named `someTask`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` that calls `someTask` and logs messages before and after `someTask`
    is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a `then` call off of `someTask` and log a message in the callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Start your Python web server and open the following link in your browser: `http://localhost:8000/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22b26618-1518-41a1-901a-f71d2a01e0c3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` keyword instructs the run-time that this function returns a Promise,
    rather than a result directly. By looking at the log messages, you can clearly
    see the order of operations. The first message is logged before the `async` function
    call is made. Next, the message inside of the `async` function is logged. Then
    the message after the `async` function is called. And finally, the message inside
    of the `then` callback is logged. This order is the same order of execution that
    can be seen in code using the Promise API directly.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is already an improvement over code that creates promises
    directly. In upcoming recipes, we'll see how to take advantage of `await` to retrieve
    results from these functions without the use of the Promise API. We'll also be
    looking at other situations where `async` functions provide an advantage over
    direct use of the Promise API.
  prefs: []
  type: TYPE_NORMAL
- en: Awaiting the result of async functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use `async` to create functions that resolve
    promises. However, we used the Promise API `then` callback to wait for the result.
    In many situations, we can use the `await` key word to wait for these values.
    It gets the job done, but there is a cleaner way to retrieve results from asynchronous
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to use `await` in order to return the result of
    a long-running operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `4-02-await-async-results`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` with an `async` function named `getRandomNumber` that returns
    a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` function, `main`, that calls `getRandomNumber`, waits for
    the result, and logs out the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start you Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/316680de-d8e2-445a-bd82-cc268ebe4367.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `await` within an `async` function is equivalent to using `then` in a
    Promise chain. The difference is that instead of the result being passed as an
    argument to the callback function, it is resolved as an expression. This expression
    can be assigned to the constant `result`. The value is then available for the
    rest of the block, and not limited to the body of a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty cool! Previously getting results from asynchronous code required
    the use of callbacks and methods in the Promise API. Now, with the `async` and
    `await` keywords, we can write code without nesting, making it easier to read
    and understand, while maintaining compatibility with the Promise API.
  prefs: []
  type: TYPE_NORMAL
- en: Using async results in a Promise chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use `async` and `await` to replace portions
    of the Promise API. However, there will still be cases where it is preferable
    to use the Promise API, either for clarity, structure, or incremental replacement.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how the `async` functions integrate seamlessly into
    Promise chains.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-03-async-function-Promise-chain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `async` function, `getRandomNumber`, that returns a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` function, `determinReadyToLaunch`, that returns `true` if
    its first argument is greater than `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a third `async` function, `reportResults`, that logs out different results
    if its first argument is `true` or `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` function that calls `getRandomNumber`, and a chain of the Promise
    it creates to call `determineReadyToLaunch` and `reportResults` in succession:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1f0928d4-cf2d-4296-9348-e8766f941f55.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, `async` functions resolve their results with a Promise,
    rather than directly returning a value. This means that whether an `async` function
    is used to start or continue a Promise chain, the shape can be the same.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In fact, because the results are always resolved with a Promise, `async` functions
    can be resolved as a group using `Promise.all`. You can see an example of `async`
    functions with their results joined with a `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works as expected. The functions can even be called directly
    with an argument, without needing to wrap them in a call to `Promise.resolve`.
  prefs: []
  type: TYPE_NORMAL
- en: Awaiting multiple results in a series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's necessary to arrange asynchronous operations in a series. In
    previous recipes, we've seen how to do this with `Promise.then`. In this recipe,
    we'll see how to do the same thing with the `await` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-03-async-function-Promise-chain`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `async` function, `getRandomNumber`, that returns a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` function, `determineReadyToLaunch`, that returns `true` if
    its first argument is greater than `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a third `async` function, `reportResults`, that logs out different results
    if it''s first argument is `true` or `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main` function that calls `getRandomNumber`, awaits the result, passes
    it on to `determineReadyToLaunch`, and calls `reportResults` after awaiting ready
    to launch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4a7e7dc-eb69-46b8-953a-31dee014ba29.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because our `main` function is marked as `async`, we are able to use the `await`
    operator in its body. This operator causes the function to wait for the result
    of the expression to be resolved. In our case, this means the Promise created
    by the `async` function we called is fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Once the result is fulfilled, the control flow continues to the next statement.
    If we did not use the `await` operator, the value of `randomNumber` would be a
    promise that would resolve to the returned value. We could handle this with the
    promise interface, but because we used `await` , we are able to write something
    that looks more like synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Awaiting multiple results concurrently*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awaiting multiple results concurrently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's possible to initiate multiple asynchronous operations at the
    same time. This can be desirable, for example, if multiple network requests are
    necessary in order to fetch all the data for a given page. Waiting for each request
    to finish before starting the next one wastes time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to use `await` to initiate and wait for multiple
    results concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-05-await-concurrently`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create three functions, `checkEngines`, `checkFlightPlan`, and`checkNavigationSystem`
    that log a message when they start and return a `Promise` that resolves to `true`
    if a random number is higher than a threshold after some timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Assign the returned value from each to a local variable.
    Then await the result of the Promise, and log out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/313c004a-ba9a-47f8-bac6-3dfe596750b3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll see in the output that the `checking` messages are logged immediately.
    Because all of the functions are called before the first `await` usage, the operations
    are initiated right await. This allows all the timeouts to start before any have
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: Once `await` is used, the `main` function will block until the result is resolved.
    The code synchronizes again. The results of each function are resolved in sequence,
    but the long-running portions of the code (`setTimeout`) are concurrent.
  prefs: []
  type: TYPE_NORMAL
- en: The three check functions had to return Promises manually, because we are using
    `setTimeout`. Because this function uses a callback, we can't use `async`/`await`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Promise.all to collect an array of async results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to trigger multiple asynchronous functions
    before awaiting their results. We've also seen how well the Promise API and `asyc`/`await`
    operators work together. There are some situations where it is preferable to use
    the Promise API.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to use `Promise.all` to collect the result of
    multiple asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create three functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that resolves to `true`
    if a random number is higher than a threshold after some timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Collect the results with `Promise.all`, reduce the results
    into a single ok to launch value, and log the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/42bd12c8-bdfb-48ea-90b8-cec76ebf4224.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Promise.all` returns a Promise that resolves to an array of values resolved
    from multiple values. In our case, those are the asynchronous functions we created
    in *Step 3*. Once that Promise is created, we can await the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this result, we can use the `Array.prototype.reduce` method in
    order to create a single Boolean value that can be used in a conditional.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare this recipe to the prior recipe, we can see an advantage. Adding
    another pre-launch check is as simple as adding another asynchronous function
    to the array of functions. In fact, we don't need to know ahead of time how may
    pre-launch checks have to be performed. If they all resolve to a Boolean value,
    they will work with `Promise.all`. We lose information about which step failed,
    but we'll see in future recipes how to regain this information with error handling.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible to refactor the `main` function so that the pre-check functions
    are executed implicitly. We can use the `Array.prototype.map` function to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted section shows that the asynchronous functions are called within
    a map.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `Array.reduce` to transform data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling errors thrown inside of `Promise.all`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors when awaiting an async function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've seen how to work with `async` functions that fulfill
    successfully. But, as we know, this is not always the case. We need to be able
    to handle errors that are thrown by asynchronous functions, or any functions they
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how `try-catch` blocks can handle errors that are
    thrown by `async` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `4-07- async-errors-try-catch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `async` function, `addBoosters`, that throws some error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` function, `performGuidanceDiagnostic`, that also throws an
    error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` as the `main` function that calls `addBosters` and `performGuidanceDiagnostic` and
    handles the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08491a5b-c85b-41c0-b6ea-540737741ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we `await` a result from an asynchronous function that fulfills with an
    error state, an error is thrown. To continue with the program, we need to catch
    this error. In the preceding recipe, the first asynchronous function throws so
    the second operation isn't performed, then we log the error to the console before
    exiting the `try-catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: This compares favorably with Promise chain error handling, which uses the same
    `try-catch` mechanism for error handling as synchronous code. We don't need to
    wrap synchronous code with promises so that they can work with `Promise.catch`;
    we can use the language level `try-catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll see how `try-catch` works with multiple asynchronous
    operations operating concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors thrown inside of Promise.all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a prior recipe, we saw how to use `Promise.all` to collect the results of
    multiple asynchronous functions. In an error state, `Promise.all` is even more
    interesting. Often, when dealing with multiple possible error conditions, we have
    to write a log of Boolean logic if we want to display multiple error messages.
    But, in this recipe, we'll see how we can use `Promise.all` and `try-catch` blocks
    to handle multiple error conditions concurrently, without complicated Boolean
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes  you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create three `async` functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that rejects an error
    if a random number is higher than a threshold or resolve, after some timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Await the results, and catch and log any errors that are
    thrown. Log success if no error is thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ffc6a77-7e4c-4f9f-a268-f5b7af850a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen before, `Promise.all` returns a Promise that resolves to an
    array of values resolved from multiple values, and we can `await` those values
    when they are fulfilled. When we `await` a Promise that is resolved in an error
    state, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting about the preceding code is that three asynchronous promises
    are executing concurrently. If one or more of them is fulfilled with an error,
    then one or more errors will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that only one error is ever caught and logged. As with synchronous
    code, we may potentially have multiple errors thrown by our code, but only one
    will be caught and logged by the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Using finally to ensure an operation is performed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling can get fairly complicated. There may be cases where you want
    to allow an error to continue bubbling up the call stack to be handled at a higher
    level. In those cases, you may also need to perform some cleanup tasks. Often
    this can mean resetting some shared resource, but it could also simply be logging
    the current state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to use `finally` to ensure that some code is executed,
    regardless of the error state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create three `async` functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that rejects an error
    if a random number is higher than a threshold, or resolve after some timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `asyncperformCheck` function that calls each of the functions created
    in the previous step. Await the results, and use `finally` to log a complete message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `async` as the `main` function that calls the `performCheck` function.
    Await the results, use `try-catch` to handle any errors, and log out whether the
    launch can continue or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3881018-0282-402c-963c-93b9a73dcdb1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the preceding recipe, the errors are caught by the `main` function, and
    the launch continue or abort message is displayed. In this recipe, we've grouped
    the `check` function into a single asynchronous function, `performChecks`, that
    lets us know when they have all finished.
  prefs: []
  type: TYPE_NORMAL
- en: Because `performChecks` does not have a `catch` block on the awaited Promise
    result, the errors thrown lower in the call stack bubble up to the `main` function.
    However, the `finally` block ensures that there is a message to let us know that
    the `performChecks` has completed.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine that this organization could be expanded to include multiple
    layers, and other branches of operations. Handling errors is an important task
    in large programs, and `async`/`await` allows us to use the `try-catch` blocks
    to handle errors from asynchronous and synchronous code in the same way.
  prefs: []
  type: TYPE_NORMAL
