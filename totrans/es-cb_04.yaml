- en: Working with async/await and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 async/await 和函数进行操作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating promises with an async function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步函数创建 Promise
- en: Awaiting the result of an async function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待异步函数的结果
- en: Using async results in a Promise chain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Promise 链中使用异步结果
- en: Awaiting multiple results in a series
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待一系列中的多个结果
- en: Awaiting multiple results concurrently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发等待多个结果
- en: Using Promise.all to collect an array of async results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Promise.all` 收集异步结果数组
- en: Handling errors when awaiting an async function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待异步函数时处理错误
- en: Handling errors thrown inside of Promise.all
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `Promise.all` 内部抛出的错误
- en: Using finally to ensure an operation is performed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `finally` 确保执行操作
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how Promises are a huge improvement over the
    callback pattern. But we also saw that there were still some rough edges around
    composition. Creating promises directly takes different shape functions that are
    placed later in the chain. Errors and successful results were provided in different
    ways depending on how the Promise was created. And there is still be a bit of
    inconvenient nesting.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 Promise 相比回调模式是一个巨大的改进。但我们还看到了在组合方面仍然存在一些粗糙的边缘。直接创建 Promise 需要不同的形状函数，这些函数被放置在链的后面。错误和成功的结果以不同的方式提供，这取决于
    Promise 的创建方式。而且仍然有一些不便的嵌套。
- en: The `async` and `await` operators were introduced with ES8\. These build on
    top of the Promise to make working with and creating Promises more seamless. In
    this chapter, we'll see how `async` and `await` can be used to create and work
    with promises in a more elegant way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 操作符是在 ES8 中引入的。它们建立在 Promise 的基础上，使得处理和创建 Promise 更加流畅。在本章中，我们将看到如何使用
    `async` 和 `await` 以更优雅的方式创建和处理 Promise。'
- en: Creating promises with an async function
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步函数创建 Promise
- en: The `async` functions are an easy way to create and work with promises. In this
    recipe, we'll see a basic form of this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 函数是创建和操作 Promise 的简单方法。在本食谱中，我们将看到这种基本形式。'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设你已经有一个允许你在浏览器中创建和运行 ES 模块的 workspace。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的 workspace。
- en: Create a new folder named `04-01-creating-Promise-with-async`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `04-01-creating-Promise-with-async` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件从 `main.js` 加载并运行一个 `main` 函数。
- en: 'Create a `main.js` with an `async` function named `someTask`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含名为 `someTask` 的 `async` 函数的 `main.js`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `main` that calls `someTask` and logs messages before and after `someTask`
    is executed:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用 `someTask` 并在 `someTask` 执行前后记录信息的 `main`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Chain a `then` call off of `someTask` and log a message in the callback function:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `someTask` 上链式调用 `then` 并在回调函数中记录一条信息：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Start your Python web server and open the following link in your browser: `http://localhost:8000/`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在你的浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/22b26618-1518-41a1-901a-f71d2a01e0c3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22b26618-1518-41a1-901a-f71d2a01e0c3.png)'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `async` keyword instructs the run-time that this function returns a Promise,
    rather than a result directly. By looking at the log messages, you can clearly
    see the order of operations. The first message is logged before the `async` function
    call is made. Next, the message inside of the `async` function is logged. Then
    the message after the `async` function is called. And finally, the message inside
    of the `then` callback is logged. This order is the same order of execution that
    can be seen in code using the Promise API directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 关键字指示运行时该函数返回一个 Promise，而不是直接的结果。通过查看日志信息，你可以清楚地看到操作顺序。第一条信息是在调用 `async`
    函数之前记录的。接下来，记录 `async` 函数内的信息。然后是调用 `async` 函数后的信息。最后，记录 `then` 回调函数内的信息。这个顺序与直接使用
    Promise API 的代码中可看到的执行顺序相同。'
- en: The preceding code is already an improvement over code that creates promises
    directly. In upcoming recipes, we'll see how to take advantage of `await` to retrieve
    results from these functions without the use of the Promise API. We'll also be
    looking at other situations where `async` functions provide an advantage over
    direct use of the Promise API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码已经比直接创建承诺的代码有所改进。在接下来的示例中，我们将看到如何利用 `await` 从这些函数中检索结果，而不使用 Promise API。我们还将探讨其他情况下
    `async` 函数如何比直接使用 Promise API 提供优势。
- en: Awaiting the result of async functions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待异步函数的结果
- en: In the previous recipe, we saw how to use `async` to create functions that resolve
    promises. However, we used the Promise API `then` callback to wait for the result.
    In many situations, we can use the `await` key word to wait for these values.
    It gets the job done, but there is a cleaner way to retrieve results from asynchronous
    functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何使用 `async` 创建解析承诺的函数。然而，我们使用了 Promise API 的 `then` 回调来等待结果。在许多情况下，我们可以使用
    `await` 关键字来等待这些值。这可以完成任务，但有一种更干净的方式来从异步函数中检索结果。
- en: This recipe demonstrates how to use `await` in order to return the result of
    a long-running operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了如何使用 `await` 来返回长时间运行操作的结果。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设你已经有一个允许你在浏览器中创建和运行 ES 模块的 workspace。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `4-02-await-async-results`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `4-02-await-async-results` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create a `main.js` with an `async` function named `getRandomNumber` that returns
    a random number:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.js` 的文件，其中包含一个名为 `getRandomNumber` 的 `async` 函数，该函数返回一个随机数：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create an `async` function, `main`, that calls `getRandomNumber`, waits for
    the result, and logs out the value:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main` 的 `async` 函数，该函数调用 `getRandomNumber`，等待结果，并输出值：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start you Python web server and open the following link in your browser:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/316680de-d8e2-445a-bd82-cc268ebe4367.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/316680de-d8e2-445a-bd82-cc268ebe4367.png)'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Using `await` within an `async` function is equivalent to using `then` in a
    Promise chain. The difference is that instead of the result being passed as an
    argument to the callback function, it is resolved as an expression. This expression
    can be assigned to the constant `result`. The value is then available for the
    rest of the block, and not limited to the body of a callback function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `async` 函数中使用 `await` 等同于在 Promise 链中使用 `then`。区别在于，结果不是作为回调函数的参数传递，而是作为表达式解析。这个表达式可以被分配给常量
    `result`。然后，这个值就可以在整个块中使用，而不仅限于回调函数的体内。
- en: This is pretty cool! Previously getting results from asynchronous code required
    the use of callbacks and methods in the Promise API. Now, with the `async` and
    `await` keywords, we can write code without nesting, making it easier to read
    and understand, while maintaining compatibility with the Promise API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷！以前从异步代码中获取结果需要使用回调和 Promise API 中的方法。现在，有了 `async` 和 `await` 关键字，我们可以编写无需嵌套的代码，这使得代码更容易阅读和理解，同时保持与
    Promise API 的兼容性。
- en: Using async results in a Promise chain
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Promise 链中使用异步结果
- en: In the previous recipe, we saw how to use `async` and `await` to replace portions
    of the Promise API. However, there will still be cases where it is preferable
    to use the Promise API, either for clarity, structure, or incremental replacement.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何使用 `async` 和 `await` 来替换 Promise API 的一部分。然而，仍然会有一些情况下使用 Promise
    API 更为可取，无论是为了清晰度、结构还是逐步替换。
- en: In this recipe, we'll see how the `async` functions integrate seamlessly into
    Promise chains.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到 `async` 函数如何无缝地集成到 Promise 链中。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设你已经有一个允许你在浏览器中创建和运行 ES 模块的 workspace。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `04-03-async-function-Promise-chain`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `04-03-async-function-Promise-chain` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create an `async` function, `getRandomNumber`, that returns a random number:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `getRandomNumber` 的 `async` 函数，它返回一个随机数：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create an `async` function, `determinReadyToLaunch`, that returns `true` if
    its first argument is greater than `0.5`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `determinReadyToLaunch` 的 `async` 函数，如果其第一个参数大于 `0.5`，则返回 `true`：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a third `async` function, `reportResults`, that logs out different results
    if its first argument is `true` or `false`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `reportResults` 的第三个 `async` 函数，如果其第一个参数是 `true` 或 `false`，则输出不同的结果：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `main` function that calls `getRandomNumber`, and a chain of the Promise
    it creates to call `determineReadyToLaunch` and `reportResults` in succession:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，调用 `getRandomNumber`，并创建一个 Promise 链来依次调用 `determineReadyToLaunch`
    和 `reportResults`：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/1f0928d4-cf2d-4296-9348-e8766f941f55.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f0928d4-cf2d-4296-9348-e8766f941f55.png)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As mentioned previously, `async` functions resolve their results with a Promise,
    rather than directly returning a value. This means that whether an `async` function
    is used to start or continue a Promise chain, the shape can be the same.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`async` 函数使用 Promise 解析其结果，而不是直接返回一个值。这意味着，无论 `async` 函数是用于启动还是继续 Promise
    链，其形状都可以是相同的。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In fact, because the results are always resolved with a Promise, `async` functions
    can be resolved as a group using `Promise.all`. You can see an example of `async`
    functions with their results joined with a `Promise.all`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，因为结果总是通过 Promise 解析，所以可以使用 `Promise.all` 将 `async` 函数作为一个组来解析。你可以看到使用 `Promise.all`
    将 `async` 函数及其结果连接的示例：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code works as expected. The functions can even be called directly
    with an argument, without needing to wrap them in a call to `Promise.resolve`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码按预期工作。函数甚至可以直接使用参数调用，而无需将它们包裹在 `Promise.resolve` 的调用中。
- en: Awaiting multiple results in a series
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系列中等待多个结果
- en: Sometimes it's necessary to arrange asynchronous operations in a series. In
    previous recipes, we've seen how to do this with `Promise.then`. In this recipe,
    we'll see how to do the same thing with the `await` operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候有必要按顺序安排异步操作。在之前的菜谱中，我们看到了如何使用 `Promise.then` 来做这件事。在这个菜谱中，我们将看到如何使用 `await`
    操作符来完成同样的任务。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `04-03-async-function-Promise-chain`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `04-03-async-function-Promise-chain` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html` 文件，该文件加载并运行来自 `main.js` 的 `main` 函数。
- en: 'Create an `async` function, `getRandomNumber`, that returns a random number:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 函数，名为 `getRandomNumber`，它返回一个随机数：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an `async` function, `determineReadyToLaunch`, that returns `true` if
    its first argument is greater than `0.5`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `determineReadyToLaunch` 的 `async` 函数，如果其第一个参数大于 `0.5`，则返回 `true`：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a third `async` function, `reportResults`, that logs out different results
    if it''s first argument is `true` or `false`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第三个 `async` 函数，名为 `reportResults`，如果它的第一个参数是 `true` 或 `false`，则输出不同的结果：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `main` function that calls `getRandomNumber`, awaits the result, passes
    it on to `determineReadyToLaunch`, and calls `reportResults` after awaiting ready
    to launch:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数，调用 `getRandomNumber`，等待结果，将其传递给 `determineReadyToLaunch`，并在等待启动准备就绪后调用
    `reportResults`：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/b4a7e7dc-eb69-46b8-953a-31dee014ba29.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4a7e7dc-eb69-46b8-953a-31dee014ba29.png)'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because our `main` function is marked as `async`, we are able to use the `await`
    operator in its body. This operator causes the function to wait for the result
    of the expression to be resolved. In our case, this means the Promise created
    by the `async` function we called is fulfilled.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`main`函数被标记为`async`，所以我们能够在它的主体中使用`await`运算符。这个运算符使得函数等待表达式解析的结果。在我们的例子中，这意味着我们调用的`async`函数创建的Promise得到了满足。
- en: Once the result is fulfilled, the control flow continues to the next statement.
    If we did not use the `await` operator, the value of `randomNumber` would be a
    promise that would resolve to the returned value. We could handle this with the
    promise interface, but because we used `await` , we are able to write something
    that looks more like synchronous code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结果得到满足，控制流将继续到下一个语句。如果我们没有使用`await`运算符，`randomNumber`的值将是一个承诺，它将解析为返回的值。我们可以使用承诺接口来处理这个问题，但由于我们使用了`await`，我们能够编写出更类似于同步代码的代码。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Awaiting multiple results concurrently*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同时等待多个结果*'
- en: Awaiting multiple results concurrently
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时等待多个结果
- en: Sometimes it's possible to initiate multiple asynchronous operations at the
    same time. This can be desirable, for example, if multiple network requests are
    necessary in order to fetch all the data for a given page. Waiting for each request
    to finish before starting the next one wastes time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可以同时启动多个异步操作。这可能是有益的，例如，如果需要多个网络请求来获取给定页面的所有数据。在开始下一个请求之前等待每个请求完成会浪费时间。
- en: In this recipe, we'll see how to use `await` to initiate and wait for multiple
    results concurrently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何使用`await`来并发地启动和等待多个结果。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `04-05-await-concurrently`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`04-05-await-concurrently`的新文件夹。
- en: 'Create three functions, `checkEngines`, `checkFlightPlan`, and`checkNavigationSystem`
    that log a message when they start and return a `Promise` that resolves to `true`
    if a random number is higher than a threshold after some timeout:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个函数，`checkEngines`、`checkFlightPlan`和`checkNavigationSystem`，当它们开始时记录一条消息，并在某些超时后返回一个解析为`true`的`Promise`，如果随机数高于阈值：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Assign the returned value from each to a local variable.
    Then await the result of the Promise, and log out the results:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`async`作为`main`函数，该函数调用之前步骤中创建的每个函数。将每个函数返回的值分配给一个局部变量。然后等待Promise的结果，并输出结果：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器，并在你的浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/313c004a-ba9a-47f8-bac6-3dfe596750b3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/313c004a-ba9a-47f8-bac6-3dfe596750b3.png)'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You'll see in the output that the `checking` messages are logged immediately.
    Because all of the functions are called before the first `await` usage, the operations
    are initiated right await. This allows all the timeouts to start before any have
    completed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在输出中看到`checking`消息立即被记录。因为所有函数都是在第一次`await`使用之前被调用的，所以操作是在`await`时启动的。这允许在任何一个完成之前，所有超时都开始。
- en: Once `await` is used, the `main` function will block until the result is resolved.
    The code synchronizes again. The results of each function are resolved in sequence,
    but the long-running portions of the code (`setTimeout`) are concurrent.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`await`，`main`函数将阻塞，直到结果解析。代码再次同步。每个函数的结果按顺序解析，但代码的长时间运行部分（`setTimeout`）是并发的。
- en: The three check functions had to return Promises manually, because we are using
    `setTimeout`. Because this function uses a callback, we can't use `async`/`await`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`setTimeout`，三个检查函数必须手动返回Promise。因为这个函数使用回调，所以我们不能使用`async`/`await`。
- en: Using Promise.all to collect an array of async results
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Promise.all收集异步结果数组
- en: In the previous recipe, we saw how to trigger multiple asynchronous functions
    before awaiting their results. We've also seen how well the Promise API and `asyc`/`await`
    operators work together. There are some situations where it is preferable to use
    the Promise API.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们看到了如何在等待结果之前触发多个异步函数。我们也看到了 Promise API 和 `asyc`/`await` 操作符是如何一起工作的。在某些情况下，使用
    Promise API 是更可取的。
- en: In this recipe, we'll see how to use `Promise.all` to collect the result of
    multiple asynchronous operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用 `Promise.all` 来收集多个异步操作的结果。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序，导航到你的工作区。
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `04-06-Promise-all-collect-concurrently` 的新文件夹。
- en: 'Create three functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that resolves to `true`
    if a random number is higher than a threshold after some timeout:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个函数，`checkEngines`、`checkFlightPlan` 和 `checkNavigationSystem`，当它们开始时记录一条消息，并在某些超时后返回一个解析为
    `true` 的 `Promise`，如果随机数高于阈值：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Collect the results with `Promise.all`, reduce the results
    into a single ok to launch value, and log the result:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 作为 `main` 函数，调用之前步骤中创建的每个函数。使用 `Promise.all` 收集结果，将结果缩减为一个单一的 ok
    to launch 值，并记录结果：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器，并在你的浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`。'
- en: 'You should see the following output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/42bd12c8-bdfb-48ea-90b8-cec76ebf4224.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42bd12c8-bdfb-48ea-90b8-cec76ebf4224.png)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`Promise.all` returns a Promise that resolves to an array of values resolved
    from multiple values. In our case, those are the asynchronous functions we created
    in *Step 3*. Once that Promise is created, we can await the result.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all` 返回一个解析为从多个值解析出的值的数组的一个 Promise。在我们的情况下，这些是我们创建在 *步骤 3* 中的异步函数。一旦创建了该
    Promise，我们就可以等待结果。'
- en: Once we have this result, we can use the `Array.prototype.reduce` method in
    order to create a single Boolean value that can be used in a conditional.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到这个结果，我们可以使用 `Array.prototype.reduce` 方法来创建一个单一的布尔值，这个值可以用在条件语句中。
- en: If we compare this recipe to the prior recipe, we can see an advantage. Adding
    another pre-launch check is as simple as adding another asynchronous function
    to the array of functions. In fact, we don't need to know ahead of time how may
    pre-launch checks have to be performed. If they all resolve to a Boolean value,
    they will work with `Promise.all`. We lose information about which step failed,
    but we'll see in future recipes how to regain this information with error handling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个菜谱与之前的菜谱进行比较，我们可以看到优势。添加另一个预启动检查就像向函数数组中添加另一个异步函数一样简单。实际上，我们不需要提前知道需要执行多少预启动检查。如果它们都解析为布尔值，它们将与
    `Promise.all` 一起工作。我们失去了关于哪个步骤失败的信息，但我们将看到在未来的菜谱中如何通过错误处理来恢复这些信息。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'It''s possible to refactor the `main` function so that the pre-check functions
    are executed implicitly. We can use the `Array.prototype.map` function to do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能重构 `main` 函数，使得预检查函数可以隐式执行。我们可以使用 `Array.prototype.map` 函数来完成这个任务：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The highlighted section shows that the asynchronous functions are called within
    a map.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分显示了异步函数是在 map 中调用的。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Using `Array.reduce` to transform data
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Array.reduce` 转换数据
- en: '*Handling errors thrown inside of `Promise.all`*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理 `Promise.all` 内部抛出的错误*'
- en: Handling errors when awaiting an async function
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待异步函数时处理错误
- en: So far in this chapter, we've seen how to work with `async` functions that fulfill
    successfully. But, as we know, this is not always the case. We need to be able
    to handle errors that are thrown by asynchronous functions, or any functions they
    call.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们看到了如何处理成功完成的 `async` 函数。但是，正如我们所知，这并不总是情况。我们需要能够处理异步函数或它们调用的任何函数抛出的错误。
- en: In this recipe, we'll see how `try-catch` blocks can handle errors that are
    thrown by `async` functions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到 `try-catch` 块如何处理由 `async` 函数抛出的错误。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `4-07- async-errors-try-catch`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `4-07- async-errors-try-catch` 的新文件夹。
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建一个 `index.html`，它从 `main.js` 加载并运行一个 `main` 函数。
- en: 'Create an `async` function, `addBoosters`, that throws some error:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 函数，`addBoosters`，它抛出一些错误：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create an `async` function, `performGuidanceDiagnostic`, that also throws an
    error:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 函数，`performGuidanceDiagnostic`，它也会抛出错误：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create an `async` as the `main` function that calls `addBosters` and `performGuidanceDiagnostic` and
    handles the error:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 作为 `main` 函数，该函数调用 `addBosters` 和 `performGuidanceDiagnostic` 并处理错误：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Python 网络服务器并在浏览器中打开以下链接：`http://localhost:8000/`。
- en: 'You should see the following output:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/08491a5b-c85b-41c0-b6ea-540737741ec8.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08491a5b-c85b-41c0-b6ea-540737741ec8.png)'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we `await` a result from an asynchronous function that fulfills with an
    error state, an error is thrown. To continue with the program, we need to catch
    this error. In the preceding recipe, the first asynchronous function throws so
    the second operation isn't performed, then we log the error to the console before
    exiting the `try-catch` block.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从异步函数等待一个以错误状态满足的结果时，会抛出一个错误。为了继续程序，我们需要捕获这个错误。在前面的菜谱中，第一个异步函数抛出错误，因此第二个操作没有执行，然后在退出
    `try-catch` 块之前将错误记录到控制台。
- en: This compares favorably with Promise chain error handling, which uses the same
    `try-catch` mechanism for error handling as synchronous code. We don't need to
    wrap synchronous code with promises so that they can work with `Promise.catch`;
    we can use the language level `try-catch` blocks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Promise 链错误处理相比有优势，它使用与同步代码相同的 `try-catch` 机制来处理错误。我们不需要将同步代码包装在承诺中，以便它们可以与
    `Promise.catch` 一起工作；我们可以使用语言级别的 `try-catch` 块。
- en: In the next recipe, we'll see how `try-catch` works with multiple asynchronous
    operations operating concurrently.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将看到 `try-catch` 如何与多个并发操作的多异步操作一起工作。
- en: Handling errors thrown inside of Promise.all
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 `Promise.all` 内抛出的错误
- en: In a prior recipe, we saw how to use `Promise.all` to collect the results of
    multiple asynchronous functions. In an error state, `Promise.all` is even more
    interesting. Often, when dealing with multiple possible error conditions, we have
    to write a log of Boolean logic if we want to display multiple error messages.
    But, in this recipe, we'll see how we can use `Promise.all` and `try-catch` blocks
    to handle multiple error conditions concurrently, without complicated Boolean
    logic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的菜谱中，我们看到了如何使用 `Promise.all` 来收集多个异步函数的结果。在错误状态下，`Promise.all` 更加有趣。通常，当我们处理多个可能错误条件时，如果我们想显示多个错误消息，我们必须编写布尔逻辑日志。但在本菜谱中，我们将看到如何使用
    `Promise.all` 和 `try-catch` 块来同时处理多个错误条件，而不需要复杂的布尔逻辑。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe assumes  you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行 ES 模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `04-06-Promise-all-collect-concurrently` 的新文件夹。
- en: 'Create three `async` functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that rejects an error
    if a random number is higher than a threshold or resolve, after some timeout:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个 `async` 函数，`checkEngines`、`checkFlightPlan` 和 `checkNavigationSystem`，当它们开始时记录一条消息，如果随机数高于阈值则返回一个拒绝错误的
    `Promise`，或者在超时后解析：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create an `async` as the `main` function that calls each of the functions created
    in the previous step. Await the results, and catch and log any errors that are
    thrown. Log success if no error is thrown:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `async` 作为 `main` 函数，该函数调用上一步创建的每个函数。等待结果，并捕获并记录抛出的任何错误。如果没有错误抛出，则记录成功：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器并在浏览器中打开以下链接：`http://localhost:8000/`.
- en: 'You should see the following output:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/5ffc6a77-7e4c-4f9f-a268-f5b7af850a1b.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ffc6a77-7e4c-4f9f-a268-f5b7af850a1b.png)'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we have seen before, `Promise.all` returns a Promise that resolves to an
    array of values resolved from multiple values, and we can `await` those values
    when they are fulfilled. When we `await` a Promise that is resolved in an error
    state, an exception is thrown.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，`Promise.all`返回一个解析为多个值数组的Promise，并且当它们被解析时我们可以`await`这些值。当我们`await`一个在错误状态下解析的Promise时，会抛出一个异常。
- en: What is interesting about the preceding code is that three asynchronous promises
    are executing concurrently. If one or more of them is fulfilled with an error,
    then one or more errors will be thrown.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码有趣的地方在于三个异步承诺正在并发执行。如果其中之一或多个以错误状态完成，那么将抛出一个或多个错误。
- en: You'll notice that only one error is ever caught and logged. As with synchronous
    code, we may potentially have multiple errors thrown by our code, but only one
    will be caught and logged by the `catch` block.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到只有一个错误被捕获并记录。与同步代码一样，我们的代码可能抛出多个错误，但只有一个是被`catch`块捕获并记录的。
- en: Using finally to ensure an operation is performed
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`finally`确保操作执行
- en: Error handling can get fairly complicated. There may be cases where you want
    to allow an error to continue bubbling up the call stack to be handled at a higher
    level. In those cases, you may also need to perform some cleanup tasks. Often
    this can mean resetting some shared resource, but it could also simply be logging
    the current state of the application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理可能相当复杂。可能存在你想要允许错误继续向上冒泡到调用堆栈以在更高级别处理的情况。在这些情况下，你可能还需要执行一些清理任务。通常这意味着重置一些共享资源，但也可能是简单地记录应用程序的当前状态。
- en: In this recipe, we'll see how to use `finally` to ensure that some code is executed,
    regardless of the error state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用`finally`来确保某些代码无论错误状态如何都会被执行。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you already have a workspace that allows you to create and
    run ES modules in your browser. If you don't, please see the first two chapters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你已经有一个工作区，允许你在浏览器中创建和运行ES模块。如果你没有，请参阅前两章。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open your command-line application and navigate to your workspace.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令行应用程序并导航到你的工作区。
- en: Create a new folder named `04-06-Promise-all-collect-concurrently`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`04-06-Promise-all-collect-concurrently`的新文件夹。
- en: 'Create three `async` functions, `checkEngines`, `checkFlightPlan`, and `checkNavigationSystem`
    that log a message when they start and return a `Promise` that rejects an error
    if a random number is higher than a threshold, or resolve after some timeout:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个`async`函数，`checkEngines`、`checkFlightPlan`和`checkNavigationSystem`，当它们开始时记录一条消息，并返回一个`Promise`，如果随机数高于阈值则拒绝错误，或者在超时后解析：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an `asyncperformCheck` function that calls each of the functions created
    in the previous step. Await the results, and use `finally` to log a complete message:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`asyncperformCheck`函数，调用之前步骤中创建的每个函数。等待结果，并使用`finally`记录一条完整的消息：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create an `async` as the `main` function that calls the `performCheck` function.
    Await the results, use `try-catch` to handle any errors, and log out whether the
    launch can continue or not:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`async`作为`main`函数，调用`performCheck`函数。等待结果，使用`try-catch`处理任何错误，并记录发射是否可以继续：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start your Python web server and open the following link in your browser:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的Python网络服务器并在浏览器中打开以下链接：
- en: '`http://localhost:8000/`.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/`.'
- en: 'You should see the following output:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![](img/f3881018-0282-402c-963c-93b9a73dcdb1.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3881018-0282-402c-963c-93b9a73dcdb1.png)'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As in the preceding recipe, the errors are caught by the `main` function, and
    the launch continue or abort message is displayed. In this recipe, we've grouped
    the `check` function into a single asynchronous function, `performChecks`, that
    lets us know when they have all finished.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的菜谱中所示，错误被`main`函数捕获，并显示发射继续或中止的消息。在这个菜谱中，我们将`check`函数组合成一个单独的异步函数`performChecks`，这样我们就可以知道它们何时全部完成。
- en: Because `performChecks` does not have a `catch` block on the awaited Promise
    result, the errors thrown lower in the call stack bubble up to the `main` function.
    However, the `finally` block ensures that there is a message to let us know that
    the `performChecks` has completed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`performChecks`在等待的Promise结果上没有`catch`块，所以调用堆栈中较低级别的错误会冒泡到`main`函数。然而，`finally`块确保有一个消息让我们知道`performChecks`已经完成。
- en: You can imagine that this organization could be expanded to include multiple
    layers, and other branches of operations. Handling errors is an important task
    in large programs, and `async`/`await` allows us to use the `try-catch` blocks
    to handle errors from asynchronous and synchronous code in the same way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象这个组织可以扩展到包含多个层级和其他运营分支。在大型程序中处理错误是一项重要任务，而`async`/`await`允许我们使用`try-catch`块以相同的方式处理异步和同步代码中的错误。
