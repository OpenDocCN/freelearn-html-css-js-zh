<html><head></head><body>
        

                            
                    <h1 class="header-title">Running E2E Tests</h1>
                
            
            
                
<p class="mce-root">Congratulations! You are just one step away from becoming a full stack application developer! For now, we will stop talking about Aurelia; you know the framework and have a high level of knowledge of how JavaScript works as a programming language. Now, it's time to expand our knowledge about full-stack application development. We have our FIFA WC 2018 application running on our localhost and have some unit testing implemented. Is it enough to ensure that it will work in a QA or production environment? Of course, no.</p>
<p>Unit testing is very important, but it only ensures the correct functionality of one single service. How can we ensure that all our applications (database, backend, frontend, and any other external services) are working correctly as one single application? This is what we will learn in this chapter.</p>
<p>Testing is one of the highly demanded skills for all developers nowadays. Why? It's because programming is no longer just writing code and to ensure that it works on your own PC, you need to create code that ensures this functionality and also be able to automate the testing process to create a continuous delivery pipeline.</p>
<p>We can divide the testing phase into four different levels, and we will cover each one through this chapter. Look at the following image:</p>
<div><img src="img/e592f9b9-20ca-4f76-aa30-cf8321f608a5.png" style="width:38.00em;height:17.25em;"/></div>
<p>We can refer to these layers as basic tests. Once we have covered all three layers, we can commit and push our code. Is that all? No. We have more advanced testing layers that should be performed using tools completely external to our application:</p>
<ul>
<li><strong>System testing</strong> ensures that all our business use cases are resolved and satisfied. It's like black box testing where we don't know how each method or operation is performed; we just care about the input and output. This kind of testing starts in the frontend layer, emulating common user operations and expecting some data already processed through the backend APIs and external services. You must know that system testing can be automated in your CI cycle.</li>
<li><strong>Acceptance testing</strong> is performed by real end users. They ensure that your system will support all user interactions, evaluating time, performance, and one very important aspect—your app's user experience. Commonly, this test is performed by the product owner first in an external environment called <strong>user acceptance testing</strong> (<strong>UAT</strong>).</li>
</ul>
<p>So, we can resume the testing phase in the following illustration:</p>
<div><img src="img/67ec1984-69c6-49fd-88a1-0925b0185df7.png" style="width:30.67em;height:20.75em;"/></div>
<p>We will cover each testing phase through this chapter. We've already reviewed the unit testing in the last section of <a href="" target="_blank">Chapter 4</a>, <em>Creating Components and Templates</em>, which is useful to ensure the functionality of a single component, but how can we evaluate the complete interaction between our components and other external services? It's time to go one step ahead and learn about integration testing. But even one step ahead is not enough for us, so let's go deeper and evaluate one very important but often ignored aspect of every web application: we can ensure our application functionality, but is it simple to use by our final users? UI testing will give us the answer. Finally, let's add some cool documentation to each endpoint we are exposing to be consumed by some client, even if it's web or mobile. We will show you how Swagger works and how it can generate a nice readable documentation about your API. The topics covered in this chapter are these:</p>
<ul>
<li>Integration testing</li>
<li>UI testing</li>
<li>API testing – Swagger</li>
</ul>
<p>Do not pass through this chapter; testing is a very important part of the application development life cycle. Ready? Go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integration testing – Multiple services, one application</h1>
                
            
            
                
<p>We have all our functionalities already tested. We know that our services work correctly but what about our database connection? What about our SSO? Can you confirm these services/dependencies work correctly?</p>
<p class="lead">Integration testing plays an important role in the application development cycle by verifying the correct behavior of the system. Let's explore our current application architecture:</p>
<div><img src="img/183fbeb4-5cc3-4ee3-a149-6b11ef57fec5.png" style="width:25.25em;height:21.75em;"/></div>
<p>Integration tests ensure the correct interaction across our different application layers, in this case, database connection, SSO service, and frontend application.</p>
<p>Why should you do integration tests? Well, if it's not clear yet, there are a few reasons to consider:</p>
<ul>
<li>Easy integration with daily builds in your <strong>Continuous Integration</strong> (<strong>CI</strong>) cycle. Your progress will be testable at any time.</li>
<li>Easy to test in dev/QA/UAT/Production environment. It's easy, just like running your application.</li>
<li>Tests run faster as compared to end-to-end tests.</li>
<li>Allows you to detect system-level issues. Communication between services, database connection, and so on.</li>
</ul>
<p class="mce-root">Now, let's add some integration tests to our existing express application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring applications for integration testing</h1>
                
            
            
                
<p>The only prerequisite you need is the Node runtime environment running correctly. In JavaScript, we have some tools to make integration tests, such as the following:</p>
<ul>
<li><strong>SuperTest</strong>: The best feature is its strong documentation; easy to understand and implement, you just need to write a few lines of code to start testing your application.</li>
<li><strong>Mocha</strong>: A simple JavaScript test framework. It can be executed in the web browser or in your Node environment. Since Mocha is based on JavaScript, it can execute asynchronous tests and generate very useful reports.</li>
</ul>
<p>We will use both tools together for our testing purposes.</p>
<p>With SuperTest, you gain advantages such as the following:</p>
<ul>
<li>You can simulate a multiple user interaction, storing different credentials (tokens) to switch between users.</li>
<li>You don't need to worry about delete or add mock data. SuperTest will perform the operations to clean or add data to your store.</li>
<li>The most useful feature—all these tests can be automated and integrated in your CI pipeline.</li>
</ul>
<p class="mce-root">SuperTest is a big help for productivity; also, it offers a natural way to write and test your code at the same time; it is very intuitive and human readable. Let’s go over how to quickly set it up for something like user retrieving data.</p>
<p>Where can you run SuperTest tests? Basically, you can run them in any server you want. No matter whether you are deploying on local <kbd>dev</kbd> servers or cloud providers, SuperTests can be executed from any of them, but you must know something—SuperTest includes its own express server. This server should not be running all the time, but using some external tools like nodemon, you can automatically restart your server each time we have a change and need to test it. If you don't want to run all the tests, Mocha's only specifier is a nice solution too.</p>
<p>First, we need to download our dependencies:</p>
<pre><strong>npm i supertest mocha chai -s</strong></pre>
<p>Chai allows us to choose any of the following prefixes: <kbd>should</kbd>, <kbd>expect</kbd>, or <kbd>assert</kbd>. Just like other test tools, they are all available here too.</p>
<p>We already have our <kbd>server.js</kbd> file, so you won't need to add any code there. Yes, you don't need to run any server, and this is the most beautiful advantage of SuperTest!</p>
<p>Remember that our test files should be separated from the application files. Next, create your <kbd>tests</kbd> file with the <kbd>touch tests.spec.js</kbd> command, and let's add some code:</p>
<pre class=" language-js">const app = require('./server');
const chai = require('chai');
const request = require('supertest');

var expect = chai.expect;

describe('API Tests', () =&gt; {
  it('should return football teams', function(done) {
    request(app)
      .get('/teams')
      .end(function(err, res) {
        expect(res.statusCode).to.equal(200);
        done();
      });
  });
});</pre>
<p>Let's explain what the code is doing.</p>
<p>We are importing our server, Chai and SuperTest. SuperTest includes its own <kbd>.expect()</kbd>, but we are using Chai’s syntax. The code sets a group of <kbd>API Tests</kbd> and creates one test to check whether the <kbd>/teams</kbd> endpoint returns 200 (OK) as status code. Note that the <kbd>done()</kbd> function is important to declare our asynchronous tests are complete. Of course, this is a very high-level test, and we can add more assertions such as evaluating the response's content and more. For example purposes, this is very simple to understand and know how SuperTest works.</p>
<p>Now, let’s see if it works. Run the following command:</p>
<pre><strong>npm test</strong></pre>
<p>You should get this:</p>
<pre class=" language-sh"><strong>&gt; npm test

&gt; integration-tests@1.0.0 test /Projects/worldcup-app
&gt; mocha '**/*.spec.js'

  API tests
    <img src="img/2193f6d7-59ec-471d-a8b4-c860c8a792ed.png" style="width:0.92em;height:0.92em;"/> should return football teams

  1 passing (41ms)</strong></pre>
<p>Make sure you have correctly configured the <kbd>test</kbd> command in the script section on <kbd>package.json</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mocking external dependencies</h1>
                
            
            
                
<p>Okay, you can write some integration tests. Is it enough? Not yet. Let's think. We really need to connect to external services? What if they're down? Of course, our test will fail but not for some application error. To avoid this, we will use Mocks.</p>
<p>Mocking is the technique used to simulate some object/service/component and return a predefined response when its called. We'll not connect with real services, so we'll be using <kbd>sinon.mock</kbd> to create a mock model for our Teams schema, and we'll test the expected result:</p>
<pre>// Test will pass if we get all teams
        it("should return football teams",(done) =&gt; {
            var TeamMock = sinon.mock(Team);
            var expectedResult = {status: true, team: []};
            TeamMock.expects('find').yields(null, expectedResult);
            Team.find(function (err, result) {
                TeamMock.verify(); //Verifies the team and throws an exception if it's not met 
                TeamMock.restore(); //Restore the fake created to his initial state
                expect(result.status).to.be.true;
                done();
            });
        });</pre>
<p>All okay at this point. Now, let's evaluate another very important aspect of testing, code coverage.</p>
<p>Make sure that <kbd>sinon</kbd> is downloaded in your project and imported in your current test file to make the example work, same as any external model you may need. You can find more info about <kbd>sinon</kbd> at <a href="http://sinonjs.org">http://sinonjs.org</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculating code coverage</h1>
                
            
            
                
<p>With our integration test already written and running, we have one thing pending to do. It would be an awesome thing if we could see how our tests are doing with respect to our app in terms of test coverage.</p>
<p>Let’s add code coverage to the app!</p>
<p><strong>Istanbul</strong> is a very famous JavaScript code coverage tool that computes different metrics such as statement quality, lines of code, function use, and branch coverage with module loader hooks to analyze all our code and add coverage when running tests, giving us real-time information about our application. It supports all kinds of JavaScript coverage use cases, from unit tests to functional and browser tests. The best part about this is that it is scalable.</p>
<p>Fortunately, we just need to install Istanbul and <kbd>nyc</kbd> (this last one in the command line client for <kbd>istanbul</kbd>). We just do this:</p>
<pre><strong>npm install istanbul --save-dev</strong>
<strong>npm install nyc --save-dev</strong></pre>
<p>Then, we modify our <kbd>package.json</kbd> file. This is to add test with coverage to our <kbd>script</kbd> object:</p>
<pre><strong>"test-coverage": "nyc mocha ./spec.js"</strong></pre>
<p>Then, run the following:</p>
<pre><strong>npm run test-coverage</strong></pre>
<p>You should be able to see the coverage summary of your application in the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Does our app meet our business requirements? UI testing</h1>
                
            
            
                
<p>Don't be confused, we won't test frontend application functionality. This is already tested with our unit test, so what is really UI testing? Well, it is a very long discussion. We can have many test suites configured to be executed at any time, and this will ensure that our E2E meets the business requirements already programmed. What do we mean by this? Unit and integration testing cannot evaluate all areas of a complete application, specifically the areas related to workflow and usability. Basically, all our automated tests can only verify code that exists. They cannot evaluate functionality that is maybe missing or issues related to visual elements of our application and how easy our product is to use. This is the real value of GUI testing, which is performed from the perspective of a user instead of the practical point of view of the developer. By analyzing an application from a user’s perspective, GUI testing can provide enough information to the project team to decide whether the application is ready to deploy or we need to reorganize some features to accomplish the user needs.</p>
<p>So, that being said, will I always will need a person who should be verifying a functionality manually? Yes and no. This theme is really hard to explain, because different points of view can be referenced and in some cases, contradicted. For these cases, we will focus on some very useful testing techniques in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scripted testing</h1>
                
            
            
                
<p>Just like its name, scripted testing based on prescripts elaborated by software testers to detect whether there are some functionalities not covered for the application at that moment. For example, a script doing a login, saving some data, and then retrieving it from another screen. The script defines the predefined data that the tester will use to evaluate each screen and the expected output. Then, the tester analyzes the results and reports any found defects to the application development team. Scripted testing can be performed manually by humans or can be supported by test automation through CI tools.</p>
<p>The advantage is that you can divide the work between your most experienced developers to write the scripts and the entry-level developers to run the script and analyze the data, giving maintenance and learning the business requirements.</p>
<p>The disadvantage is that it's hard to maintain if your UI changes frequently. This kind of testing is highly coupled with your business code so if it changes, the entire test should change too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploratory testing</h1>
                
            
            
                
<p>In this kind of testing, we won't use any automated script. It enforces the tester to use the application as a common user and evaluate aspects such as design, how easy our product is for the final users, how is the user experience, alternative workflows, and more. The tester may identify any failure regarding these aspects and provide valuable feedback to developers.</p>
<p>Since explanatory tests do not use scripts, there is still pre-planning. In real-life situations, commonly in session-based exploratory testing, the testers team sets goals for the planned tests and defines a time frame to perform exploratory testing in focused areas. All this information is introduced in a document called test-charter. Sessions and results of exploratory testing are documented in a report and reviewed in the daily meeting with the entire team.</p>
<p>The advantage is that testers have more time to focus on the actual testing, because the time to prepare test cases and look at boring documentation is reduced, becoming a constant challenge to find more issues and increase their business knowledge.</p>
<p>The disadvantage is that this kind of test is not auto-executable and of course, cannot be repeated to be used as a regression test. Also, you will need testers with a deep understanding of your business requirements that most of the time are hard to find. In addition, in real-time scenarios, it may be impractical to try to cover an entire application with exploratory testing since we won't find enough testers with the required knowledge about the product.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">UX testing</h1>
                
            
            
                
<p>In user experience testing, actual end users (or user representatives) evaluate an application for its ease of use, visual appearance, and ability to meet their needs. The users will explore all the applications in an isolated environment called UAT, which can be configured in a local server or some cloud provider. You must keep in mind that it does not matter where the product is deployed, it should represent the same conditions as your production environment.</p>
<p>Don’t confuse user experience testing (UX) with user acceptance testing (UAT). UAT is a testing level that verifies that a given application meets demanded requirements focusing only on business use cases. For example, in UAT, you can ensure that your Retrieve Teams button works correctly and returns the correct data well formatted. So, it's not enough? Of course no, because you don't know yet whether your button is well placed or whether it's difficult to find from the end user's perspective.</p>
<p>Okay, now that we understand how this kind of testing works, which one should we apply? All taken decisions regarding testing should target to maximize the value of the product for its final users, even by detecting bugs or unexpected features, and by ensuring functionality and usability. To achieve this goal, in real-time situations, we will need a combination of all different test techniques reviewed at this time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning our tests – Time for the truth</h1>
                
            
            
                
<p>Planning is a very important phase of any project, and this won't be an exception. It is important to have a test plan that identifies the resources available for testing and that prioritizes areas of the application to be tested before we start writing our cases. With this information, the testing team will be able to create test scenarios, test cases, and test scripts for scripted testing, documented in the test charter.</p>
<p>This is an example of the structure that our test plan should contain:</p>
<ul>
<li>Defined dates for each test</li>
<li>Required testers</li>
<li>Required resources such as servers, environments, tools, and cloud providers correctly configured to start testing</li>
<li>Target application environments, such as different screen resolutions, mobile devices, and supported browsers</li>
<li>User workflows/navigation to test</li>
<li>Testing techniques to be used, including scripted testing, exploratory testing, and user experience testing</li>
<li>Goals for testing, including the acceptance criteria to determine if a test passes or fails</li>
</ul>
<p class="mce-root CDPAlignLeft CDPAlign">Also, we can add some more sections according to our own needs:</p>
<div><img src="img/534f2510-9baf-4cf3-80e3-0cd8e5ab2b6d.png" style="width:31.67em;height:54.25em;"/></div>
<div><p class="et_pb_text_inner">Test plans can be text documents, excel tables, or a test management tool to develop the test plan to support analysis and reporting. There are many tools available, some of them to download into your private server and others to be used on a cloud provider.</p>
</div>
<p class="et_pb_text_inner">Our GUI test plan should not be considered as a full system test plan. You can also consider other aspects such as load testing, security, backup, fault tolerance, and recovery.</p>
<p>Done, we have our plan! What's next? Identify our testing priorities. For example, first of all, we need to ensure the following:</p>
<ul>
<li>Visual design</li>
<li>Security</li>
<li>Usability</li>
<li>Compliance</li>
<li>Functionality</li>
<li>Performance</li>
</ul>
<p>Now, it's time to represent it in a mental map to be understood by the entire team and perform the required tests. Check out this example:</p>
<div><img src="img/cff9be57-89ea-454f-af08-f9870377c79e.png" style="width:34.17em;height:23.08em;"/></div>
<p>The most common areas to test when we are navigating on a web application are these:</p>
<ul>
<li>Compatibility with different versions of most used browsers</li>
<li>Behavior when the user clicks on the back or refresh button (in browser)</li>
<li>Behavior after a user returns to the page using a bookmark or their browser history</li>
<li>Behavior when the user has multiple browser windows open on the UAT at the same time</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining common scenarios</h1>
                
            
            
                
<p>We can define a test scenario as a brief statement describing how an application will be used in specific real-life situations, for example, “the user will be able to log in with a valid username and password.” Commonly, test scenarios are written from development documents such as requirements or user stories, each one with the required acceptance criteria to accomplish that. If these documents are not created yet, product owners should write them and define the different scenarios and acceptance criteria to mark the product as complete.</p>
<p>Scenarios are useful because they can guide exploratory testing, giving a good understanding of a GUI event, without restricting the testing team to a specific procedure. Since it is much faster to create a test scenario instead of writing a full test case, scenarios are most used in agile environments.</p>
<p>If scenarios are used in scripted testing, they can be used as the base from which test cases can be written.</p>
<p>For example, the <em>login scenario</em> mentioned earlier can have test cases for GUI events such as the following:</p>
<ul>
<li>User enters a valid username and password</li>
<li>User enters invalid username</li>
<li>User enters valid username but invalid password</li>
<li>User tries to reset the password</li>
<li>User presses the Submit button repeatedly</li>
</ul>
<div><img src="img/11e36bd5-80ad-4c47-9c89-858d95450e3f.png" style="width:37.42em;height:24.92em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing test cases</h1>
                
            
            
                
<p>Commonly, this document starts with a brief description of a GUI event to be tested, we will still use the example about the login attempt. We should specify conditions and steps for executing the test. Finally, we need to evaluate the expected result of the test and define the acceptance criteria for determining whether the test succeeds or fails.</p>
<p>You must keep in mind some considerations such as the ones listed here:</p>
<ul>
<li>How often the user interface changes</li>
<li>How much freedom end users will have when navigating through the application</li>
<li>If you have testers with less experience, they may need more detailed procedures</li>
</ul>
<p>What to include? Good question. Similar to our planning template, we need to put our acceptance criteria organized in a document where we can check and save the evolution of each test case. Here's a very basic example:</p>
<div><img src="img/73de0547-f09d-4247-b359-afd1fd2c9826.png" style="width:59.33em;height:12.08em;"/></div>
<p>It's important that you have separated your test data for test cases. Most of the time, issues are products of validation errors in the project, so the development teams must know which parameters caused this error. Always remember that application development is a team work, so you must give all the facilities to your colleagues to get the best product.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Organizing our test – Creating scripts</h1>
                
            
            
                
<p>This is the most detailed part of our test. Here, we will define the steps and procedures to execute our test. Create sufficient test scripts to verify paths that users will take through the UAT.</p>
<p>Always remember to document the input data and the expected output; it will be very important when we have to deal with unexpected events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API test with Swagger</h1>
                
            
            
                
<p>In the last section, we were centered in the E2E testing of our entire application starting from the frontend, but what about our API itself? Remember that one API can be used to serve many client types such as web or mobile. So, don't you think it would be awesome to ensure this functionality independently from the entire application life cycle? Sure, we know you agree, and we have in mind a very nice solution to accomplish this objective—Swagger.</p>
<p>Swagger is a specification and a nice group of tools to write RESTful APIs. Based on their own web page definition:</p>
<p>"Swagger is the world’s largest framework of API developer tools for the OpenAPI Specification (OAS), enabling development across the entire API life cycle, from design and documentation, to test and deployment."</p>
<p>In the group of tools we have in Swagger, we can find these:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p">Swagger Editor: This tool will allow us to view the updated document in real time.</li>
<li class="graf graf--li graf-after--li">Swagger Codegen: A template-driven engine to generate interactive documents.</li>
<li class="graf graf--li graf-after--li">Swagger UI: Allows to visualize the RESTful API, and check input and responses. So, <em>Swagger UI</em> takes an existing JSON or YAML document and creates interactive documentation.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Swagger</h1>
                
            
            
                
<p>Let's start getting our most important dependency, Swagger. Remember that we will use NPM to download Swagger, because we will use it on a ExpressJS API. Swagger has its own implementation depending on the platform you need to document.</p>
<p>There are two very famous swagger implementations to integrate with an ExpressJS application:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p"><kbd>swagger-node-express</kbd></li>
<li class="graf graf--li graf-after--li"><kbd>swagger-ui-express</kbd></li>
</ul>
<p class="graf graf--h4 graf-after--li">The <kbd>swagger-node-express</kbd> is the official <em>Swagger</em> module for <em>Node</em>. Some of the most interesting (and not so) characteristics of this library are as follows:</p>
<ul class="postList">
<li class="graf graf--li graf-after--p">Official distribution of the Swagger API. We are fully supported by an organization working actively on the development of the product.</li>
<li class="graf graf--li graf-after--li">It is open source.</li>
<li class="graf graf--li graf-after--li">Comes with <em>Swagger Editor</em> and Swagger Codegen.</li>
<li><em>Swagger UI</em> needs to be inserted inside the code where we are adding documentation.</li>
<li>Since documentation is quite poor, you need to read the source code of some different libraries to learn and understand each argument used to configure Swagger.</li>
</ul>
<p class="graf graf--h4 graf-after--li">The <kbd>swagger-ui-express</kbd> is supported by the community, another great open source option. How does it work? This library adds a middleware to your Express.js<em> </em>application that serves the Swagger UI bound to your Swagger document. It's really easy to configure; the only thing you will need to perform is add one route to host Swagger UI, without need to copy anything manually. Documentation is really good, and we think everything you need should be there.<br/>
<br/>
Given the functionality and simplicity of this tool, we've decided to use this library instead of any other option to achieve our main goal of documenting our application.</p>
<p class="graf graf--p graf-after--p">To get started, we need to add the library to our current project:</p>
<pre><strong>npm install -save swagger-ui-express</strong></pre>
<p>Once the library is added to our project, we need to configure a route to host Swagger UI. Also, we need to load the Swagger API definition of our application. In our application, the Swagger API definition is a single file containing information about our application represented in a JSON object.</p>
<p>To create the Swagger API definition, we have used Swagger Editor. Remember that you are free to use JSON or YAML notation. Let's look at an example of the same definition in different formats:</p>
<p>In JSON it is done as follows:</p>
<pre class=" line-numbers code-collapsed language-json">{
    "swagger": "2.0",
    "info": {
        "version": "1.0.0",
        "title": "WorldCup API",
        "description": "A simple API to learn how to write FIFAWC Specification"
    },
    "schemes": [
        "http"
    ],
    "host": "localhost:3000",
    "basePath": "/",
    "paths": {
        "/teams": {
            "get": {
                "summary": "Gets team list",
                "description": "Returns a list containing all teams of the WorldCup.",
                "responses": {
                    "200": {
                        "description": "A list of Teams",
                        "schema": {
                            "type": "array",
                            "items": {
                                "teams": {
                                    "country": {
                                        "type": "string"
                                    },
                                    "trainer": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}</pre>
<p>In YAML:</p>
<pre class=" line-numbers code-collapsed language-yaml">swagger: "2.0"

info:
  version: 1.0.0
  title: WorldCup API
  description: A simple API to learn how to write FIFAWC Specification

schemes:
  - https
host: simple.api
basePath: /doc

paths:
  /teams:
    get:
      summary: Gets teams list
      description: Returns a list containing all Teams of the WorldCup.
      responses:
        200:
          description: A list of Teams
          schema:
            type: array
            items:
              properties:
                country:
                  type: string
                trainer:
                  type: string
                </pre>
<p>Both are very human readable.</p>
<p>Even if our specification file is a text that can be edited with any text editor, nowadays we have many specialized tools to achieve this, giving us some useful features such as syntax validation, format, autocomplete parameters, and more. The best option to write specification file is Swagger Editor (yes, its own tool), a powerful set of static files that allows you to write and validate Swagger specification in YAML syntax and see how your file will look rendered.</p>
<p>The created Swagger API definition will be stored in our application as a JSON object inside the <kbd>swagger.json</kbd> file. At this moment, our setup script should look like this:</p>
<pre>const swaggerUi = require('swagger-ui-express')
const swaggerDocument = require('./swagger.json'); //Our specification file

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));</pre>
<p class="graf graf--p graf-after--figure">As you can see, first middleware is setting up our Swagger server. This middleware will return static files that are needed for hosting Swagger UI. Second middleware is our setup function that will set up Swagger UI to use our predefined users parameters in the <kbd>json/yml</kbd> file.</p>
<p>Also, of course, our documentation URL is <kbd>http://localhost:3000/api-docs</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>You are now just one step away from getting the maximum knowledge about full-stack applications and all the stuff it concerns. As we said earlier, one of the most important parts, and the one that makes the difference between just a programmer and a full-stack application developer, is testing. This chapter was meant to be easily understandable and highly applicable in your day-to-day work, giving you the most modern concepts and tools used in application testing.</p>
<p>You need to remember that integration tests are the assurance process of all components working well together, such third-party systems, external databases, and asynchronous processes. Depending on which platform you use, you will have a complete ecosystem to accomplish this and get the best value from your application. The best part is that you can automate all the tests at this layer and make your deployment process safer. One thing you cannot test using script is the usability of the application. You will need real humans to interact with your product and in this layer different UI testing techniques come to the rescue. Remember that user experience is one differential when you need to offer your products to the market.</p>
<p>Finally, all the different tests need to be documented to be used by other developers to improve more features of your application. Swagger is a very nice and simple tool to generate a detailed documentation and share with your team.</p>
<p>Now we have completely covered the testing phase! You know what time it is... Let's deploy! See you in the next chapter!</p>


            

            
        
    </body></html>