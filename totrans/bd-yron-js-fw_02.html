<html><head></head><body>
<div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.2.1">Framework Organization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The existing JavaScript frameworks have many technical and structural similarities that are useful to learn as part of becoming experts in framework development. </span><span class="koboSpan" id="kobo.3.2">In this chapter, framework organization refers to the way of composing a set of abstractions and building blocks, thus creating a collection of usable interfaces that can be utilized in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We are going to learn about the following organizational topics that enable framework development </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and use:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Learning </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">about abstractions</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Building blocks of abstractions </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">in JavaScript</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Framework </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">building blocks</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Differentiating modules, libraries, </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and frameworks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">Understanding the core building blocks and aspects of framework development will help us craft our own framework and have the domain knowledge to use other frameworks to their maximum potential. </span><span class="koboSpan" id="kobo.15.2">The expectations from the users or stakeholders of a software framework are to have clear instructions with familiar application concepts, reduced complexity, and a well-defined code base. </span><span class="koboSpan" id="kobo.15.3">Let us explore how framework organization can help us satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">those expectations.</span></span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">Similar to the previous chapter, we will be using the book’s repository as an extension to this chapter. </span><span class="koboSpan" id="kobo.18.2">You can find it at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">For the code from the repository, you can use any environment that supports a terminal and runs Node.js, such as Windows, macOS, and most varieties </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">of Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">This chapter includes examples from open source frameworks – to save space, the unimportant details are omitted with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">// ...</span></strong><span class="koboSpan" id="kobo.24.1"> comment.  </span><span class="koboSpan" id="kobo.24.2">You will need familiarity with reading JavaScript code, but don’t worry if you don’t understand the whole code block. </span><span class="koboSpan" id="kobo.24.3">As part of reading the code, be sure to follow the links next to those examples to see the full implementation with all the code details. </span><span class="koboSpan" id="kobo.24.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">chapter2/README.md</span></strong><span class="koboSpan" id="kobo.26.1"> file lists the available code resources of </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">In this chapter, it is suggested to try out debugging to further our expertise in framework structures. </span><span class="koboSpan" id="kobo.28.2">The easiest way to explore that on your computer would be by downloading the latest version of Visual Studio Code </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">from </span></span><a href="http://code.visualstudio.com"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">code.visualstudio.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.32.1">Learning about abstractions</span></h1>
<p><span class="koboSpan" id="kobo.33.1">Let’s dive into the first </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.34.1">aspect of framework organization – the fundamental concept of </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">abstractions</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">One of the main conveniences of software development frameworks in web development or other fields is to provide developers with high-quality opinionated abstractions. </span><span class="koboSpan" id="kobo.36.3">This means taking a task that can span multiple lines of code, riddled with implementation gotchas, and creating a simple interface around it. </span><span class="koboSpan" id="kobo.36.4">It also means coming up with an intelligent way of structuring independent interfaces into a familiar, extensible pattern that is </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">easily usable.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">This concept of abstracting away the complexity and generalization of objects helps us define the building blocks that could be used for multiple purposes in our frameworks. </span><span class="koboSpan" id="kobo.38.2">Each abstracted object can be initialized with a custom set of properties and be utilized in many shapes when needed. </span><span class="koboSpan" id="kobo.38.3">Having this benefit of simplification and generalization in frameworks is what allows developers to focus on the business logic of the programs. </span><span class="koboSpan" id="kobo.38.4">Precisely these abstraction concepts benefit developers by eliminating complexity, repetition, and the challenges of learning new systems. </span><span class="koboSpan" id="kobo.38.5">Through abstractions, developers do not have to use or even learn the low-level components of the systems they </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">build for.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.40.1">Abstractions in computer science</span></p>
<p class="callout"><span class="koboSpan" id="kobo.41.1">In general, the concept</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.42.1"> of abstractions, a simplified representation of some complex mechanism, is essential in software development. </span><span class="koboSpan" id="kobo.42.2">This concept is taught early in programming courses and can be implemented in the high-level and low-level interfaces of large and small programs. </span><span class="koboSpan" id="kobo.42.3">Software abstractions structure many parts of these programs and dictate the program’s control flow. </span><span class="koboSpan" id="kobo.42.4">Data types and structures that define how the data is represented can be considered abstractions on top of lower-level </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">object entities.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.44.1">Some programming languages offer direct syntax to write abstract classes and interfaces. </span><span class="koboSpan" id="kobo.44.2">TypeScript offers this feature as part of its extensions to JavaScript. </span><span class="koboSpan" id="kobo.44.3">This allows developers to declare </span><em class="italic"><span class="koboSpan" id="kobo.45.1">abstract</span></em><span class="koboSpan" id="kobo.46.1"> classes, methods, and fields. </span><span class="koboSpan" id="kobo.46.2">You can find some excellent examples at </span><a href="http://www.typescriptlang.org/docs/handbook/2/classes.html"><span class="koboSpan" id="kobo.47.1">www.typescriptlang.org/docs/handbook/2/classes.html</span></a><span class="koboSpan" id="kobo.48.1"> for further reading </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">and </span></span><span class="No-Break"><a id="_idIndexMarker148"/></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">prototyping.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">If we look at the process of developing websites with bare CSS, HTML, and JavaScript technologies, we can already spot many pre-defined abstractions to make that process more easily accessible and simplified. </span><span class="koboSpan" id="kobo.51.2">For instance, HTML, with its elements combined with attributes, can quickly define hyperlinks and embed media with just a few lines of marked-up tags. </span><span class="koboSpan" id="kobo.51.3">The styling of those elements with CSS is defined by a set of styling rules targeting particular element nodes. </span><span class="koboSpan" id="kobo.51.4">We can see examples of web API abstractions in the </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Document Object Model API</span></strong><span class="koboSpan" id="kobo.53.1">, an</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.54.1"> abstraction on top of a complex tree of nested nodes defining</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.55.1"> a document structure. </span><span class="koboSpan" id="kobo.55.2">These frontend technologies provide a way for user interactions inside a web browser, which generalizes and removes the complexity of interacting with a </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">We can see a simplified pyramid of abstractions here, starting from application code that developers write on top and rules of basic logic at the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">lowest level:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.59.1"><img alt="Figure 2.1: Abstraction pyramid from higher- to lower-level structures" src="image/Figure_2.1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.60.1">Figure 2.1: Abstraction pyramid from higher- to lower-level structures</span></p>
<p><span class="koboSpan" id="kobo.61.1">This finally brings us to JavaScript, as a high-level programming language that already abstracts away complexity in many ways, such as memory management, interaction with the browser, and general object management. </span><span class="koboSpan" id="kobo.61.2">In fact, some abstractions that compile to JavaScript focus on abstracting away even the higher-level components. </span><span class="koboSpan" id="kobo.61.3">Toolkits such as GWT and programming languages such as Elm, C#, and Dart approach this higher-level abstraction process by compiling to CSS, HTML, and JavaScript. </span><span class="koboSpan" id="kobo.61.4">The language extensions for ECMAScript, such as TypeScript, hold closer to JavaScript in terms of syntax, abstract away the common pitfalls in how we write JavaScript programs, and improve the overall developer experience with the addition of a </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">compilation step.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">In </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.65.1">, we looked at several frameworks that use TypeScript, rely on another framework, or both to create a framework of a higher abstraction level. </span><span class="koboSpan" id="kobo.65.2">For example, Nuxt.js is a Vue.js framework, and it relies on TypeScript. </span><span class="koboSpan" id="kobo.65.3">In such cases, frameworks require developers to use these language extensions and their own self-defined abstractions to build the applications. </span><span class="koboSpan" id="kobo.65.4">It is interesting to ponder how deep the levels of abstractions could be nested when we are developing for the web platform and within the JavaScript ecosystem. </span><span class="koboSpan" id="kobo.65.5">On the frontend, we have the web browser, which manages the network request/response networking, draws the layout, enables interactivity, and so much more. </span><span class="koboSpan" id="kobo.65.6">The backend application services are working on top of the process and operating system infrastructure within the cloud server instances. </span><span class="koboSpan" id="kobo.65.7">The levels of abstraction keep growing as we zoom out to electricity flowing through wires, which delivers the </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.66.1">required bits for our </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Now that we are more familiar with abstractions and why they are used, we shall examine the downsides of this </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">core pattern.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.70.1">Downsides of abstractions</span></h2>
<p><span class="koboSpan" id="kobo.71.1">We have examined the</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.72.1"> benefits of abstractions, but there are some downsides to consider when utilizing or implementing abstractions. </span><span class="koboSpan" id="kobo.72.2">These factors are also true for frameworks and heavily affect framework development. </span><span class="koboSpan" id="kobo.72.3">Let’s discuss some of the ways abstractions can lead you down the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">wrong path:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">Abstractions may be incomplete – covering all the potential use cases of an underlying technology with an abstraction could be difficult. </span><span class="koboSpan" id="kobo.74.2">For instance, if you have a web application framework, this could usually be a case where a niche feature to output HTML in a certain way could not be supported. </span><span class="koboSpan" id="kobo.74.3">The niche requirements could include rendering different types of components, such as SVG animations or direct DOM manipulations. </span><span class="koboSpan" id="kobo.74.4">Frameworks offer escape hatches to avoid these issues, but there could be other cases where we have to rely on the knowledge of lower-level components, avoiding the defined abstractions. </span><span class="koboSpan" id="kobo.74.5">At the same time, an abstraction may falsely represent the low-level system, which could lead to confusion or false use of the underlying concepts. </span><span class="koboSpan" id="kobo.74.6">For instance, if a cryptographic library wrongly uses the primitives, even with the correct outcomes, it could potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">introduce bugs.</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">Abstractions introduce an extra layer of code between you and the lower-level system, possibly affecting performance. </span><span class="koboSpan" id="kobo.76.2">In the case of frontend development, this means more code to transfer over the wire – additional function calls and layers of indirection. </span><span class="koboSpan" id="kobo.76.3">In the backend scenarios, server instances use more process memory. </span><span class="koboSpan" id="kobo.76.4">The performance may also be affected by the framework’s choice of algorithms. </span><span class="koboSpan" id="kobo.76.5">These days, performance is taken seriously by framework authors and users, and regular comparisons and benchmarks help deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">these drawbacks.</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">Some of the different framework abstractions may not provide the right interfaces or enough control for the users, which could limit the system’s potential. </span><span class="koboSpan" id="kobo.78.2">It could be</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.79.1"> as simple as not supporting all the underlying methods of the lower-level interface. </span><span class="koboSpan" id="kobo.79.2">This issue can also happen if a chosen abstraction is used for something other than what it was designed for. </span><span class="koboSpan" id="kobo.79.3">This can also be a problem if the framework was designed before a certain technology was introduced. </span><span class="koboSpan" id="kobo.79.4">For </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.80.1">instance, with </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">WebAssembly</span></strong><span class="koboSpan" id="kobo.82.1"> support in certain frameworks, loading the WASM modules is not possible in some cases due to loading limitations or has to be done with external components. </span><span class="koboSpan" id="kobo.82.2">Introducing and using WebAssembly in an already established project with a lacking framework would be </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">an anti-pattern.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.84.1">Specifically, patterns and abstraction ideas change quickly in the JavaScript ecosystem. </span><span class="koboSpan" id="kobo.84.2">New tools and solutions come into existence that abstract how we manage frontend interactions and build backend services. </span><span class="koboSpan" id="kobo.84.3">This means, as project owners, we have to adjust either to the changing platform or our existing abstractions become outdated. </span><span class="koboSpan" id="kobo.84.4">This could lead to a lack of support for some functionalities or just general code breakage. </span><span class="koboSpan" id="kobo.84.5">In many circumstances, this happens when some web APIs change or evolve as the web platform introduces </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">new features.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.86.1">Another downside of abstractions is the scenario where a developer may know how to create applications with a certain framework but knows nothing about the internals of the underlying technology. </span><span class="koboSpan" id="kobo.86.2">The hidden-away complexity can lead to difficulty in troubleshooting problems and in tracking down errors in the core of the application. </span><span class="koboSpan" id="kobo.86.3">Not understanding the technology behind the scenes also limits the developer in their ability to optimize features and take advantage of </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">advanced features.</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">We may also face so-called </span><em class="italic"><span class="koboSpan" id="kobo.89.1">leaky abstractions</span></em><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">This is where the attempt to conceal some system complexity fully is not successful. </span><span class="koboSpan" id="kobo.90.3">This usually results in the details of the underlying system being revealed to the users of the abstraction. </span><span class="koboSpan" id="kobo.90.4">This phenomenon can lead to more complexity in the code with its own problems. </span><span class="koboSpan" id="kobo.90.5">The problem becomes evident when developers have to dig into the implementation details of the low-level system and try their best to figure out how the abstraction maps to the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">underlying system.</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Highly opinionated abstractions, in frameworks and in general, may cause issues when introducing additional layers of sophistication by imposing specific design choices that the developer may disagree with but is unable to change. </span><span class="koboSpan" id="kobo.92.2">These can limit the reusability </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.93.1">and flexibility of the application code. </span><span class="koboSpan" id="kobo.93.2">If we look at Next.js, it provides highly opinionated solutions for several of its features. </span><span class="koboSpan" id="kobo.93.3">For example, if you are planning to add API routes to build an API in the Next.js project, these must be mapped to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">/api/</span></strong><span class="koboSpan" id="kobo.95.1"> endpoint. </span><span class="koboSpan" id="kobo.95.2">To learn more about that, check out </span><a href="http://nextjs.org/docs/api-routes/introduction"><span class="koboSpan" id="kobo.96.1">nextjs.org/docs/api-routes/introduction</span></a><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">This is a simple example, but hopefully it illustrates this </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">drawback well.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">No matter where you introduce the use of an abstraction, it does add an extra layer of complexity and indirectness to what we are trying to interface with. </span><span class="koboSpan" id="kobo.99.2">When we add abstractions through various means, this makes our projects dependent on them. </span><span class="koboSpan" id="kobo.99.3">This dependency may create certain complications. </span><span class="koboSpan" id="kobo.99.4">With an external abstraction, we have to accept the risks and trade-offs that come with </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">using it.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">In the next section, we are going to look at the popular abstracted building blocks, which are often used in framework development and are exposed as public interfaces of frameworks. </span><span class="koboSpan" id="kobo.101.2">We will dive into the frontend browser APIs and the backend runtime modules to better understand what frameworks utilize to build their own abstractions. </span><span class="koboSpan" id="kobo.101.3">This is a useful exercise because it helps us figure out how these frameworks function and what techniques</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.102.1"> they use to combine different tools together. </span><span class="koboSpan" id="kobo.102.2">These exercises in tracing the framework organization are valuable to becoming a domain expert in frameworks and understanding the underlying technology </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">behind them.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.104.1">Building blocks of abstractions in JavaScript</span></h1>
<p><span class="koboSpan" id="kobo.105.1">In this section, we</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.106.1"> will discuss some detailed</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.107.1"> abstraction examples in JavaScript, as well as web APIs, and features that are used as the building blocks and foundational components of abstractions in frameworks. </span><span class="koboSpan" id="kobo.107.2">Framework and browser developers put a lot of thought and hard work into defining these abstractions, which allow developers to be really crafty, produce well-organized code, and build </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">great products.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.109.1">Frontend framework abstractions</span></h2>
<p><span class="koboSpan" id="kobo.110.1">With these three </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.111.1">technologies – HTML, CSS, and JavaScript – that enable website development, we </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.112.1">get plenty of building blocks that already abstract away the challenges of publishing something on the web. </span><span class="koboSpan" id="kobo.112.2">However, we do not get a particular, well-structured, opinionated way to build complex web application projects. </span><span class="koboSpan" id="kobo.112.3">This is where the frontend frameworks primarily fill the void that is lacking in the core technologies provided by the web. </span><span class="koboSpan" id="kobo.112.4">The frontend frameworks create abstractions in these </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">two cases:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.114.1">On top of existing</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.115.1"> web APIs, which are built into the web browser or a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">JavaScript runtime.</span></span></li>
<li><span class="koboSpan" id="kobo.117.1">When new abstractions are built from scratch based on the framework’s internals and opinionated definitions. </span><span class="koboSpan" id="kobo.117.2">The innovative and unique approach to these abstractions is</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.118.1"> what makes a particular framework desirable and liked </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">among developers.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.120.1">The following </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.121.1">web APIs provided by the browser engines are often abstracted by </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">frontend frameworks:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.123.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.124.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">DOM</span></strong><span class="koboSpan" id="kobo.126.1">) – This allows manipulation of the web page’s structure. </span><span class="koboSpan" id="kobo.126.2">The</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.127.1"> DOM </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.128.1">represents a tree where the nodes constrain the objects. </span><span class="koboSpan" id="kobo.128.2">The DOM API provides access and the ability to modify this logical tree. </span><span class="koboSpan" id="kobo.128.3">The user interface frameworks primarily need this to display the rendered views and handle DOM interactions and events. </span><span class="koboSpan" id="kobo.128.4">Even the frameworks that use a virtual DOM need to attach their structures to the real document to make it visible on </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the page.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Browser Object Model</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">BOM</span></strong><span class="koboSpan" id="kobo.133.1">) – This allows manipulation of browser-specific properties</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.134.1"> such as browser </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.135.1">history, location, screen, frames, navigator, and more. </span><span class="koboSpan" id="kobo.135.2">Technically, this also has access to the DOM’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">document</span></strong><span class="koboSpan" id="kobo.137.1"> property. </span><span class="koboSpan" id="kobo.137.2">The browser also provides complex APIs, such as the WebAssembly API, which lets applications include binary-code modules. </span><span class="koboSpan" id="kobo.137.3">The frameworks usually have a loader for these low-level modules as part of their </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">loader workflow.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.139.1">CSS Object Model</span></strong><span class="koboSpan" id="kobo.140.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">CSSOM</span></strong><span class="koboSpan" id="kobo.142.1">) – A set of browser APIs to dynamically manipulate, read, and </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.143.1">modify </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.144.1">page style. </span><span class="koboSpan" id="kobo.144.2">Similar to the DOM APIs, frameworks can utilize CSSOM for custom solutions for styling and animation behaviors. </span><span class="koboSpan" id="kobo.144.3">The capabilities of CSSOM allow JavaScript to control element styles and more. </span><span class="koboSpan" id="kobo.144.4">On a basic level, it offers the following programmatic access: </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">document.body.style.color = 'pink';</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">This object model also offers several method calls such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">getComputedStyle();</span></strong><span class="koboSpan" id="kobo.148.1"> to fetch information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">object’s style.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.150.1">Network APIs</span></strong><span class="koboSpan" id="kobo.151.1"> – These APIs have the ability to make asynchronous network requests using the</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.152.1"> Fetch API or </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.153.1">the XMLHttpRequest API. </span><span class="koboSpan" id="kobo.153.2">Frameworks utilize these for basic networking operations, including structuring complex requests using GraphQL. </span><span class="koboSpan" id="kobo.153.3">The networking APIs also </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.154.1">offer </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">WebSocket</span></strong><span class="koboSpan" id="kobo.156.1"> functionality. </span><span class="koboSpan" id="kobo.156.2">These APIs provide full-duplex (data can be transmitted and received simultaneously) communications with less overhead than usual networking calls, enabling applications with real-time updates and communication. </span><span class="koboSpan" id="kobo.156.3">The WebSocket API is simple enough that it can be used directly in the applications or with the inclusion of an extension package for a particular framework. </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Socket.io</span></strong><span class="koboSpan" id="kobo.158.1"> builds</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.159.1"> on top of WebSocket APIs and offers a complete low-latency solution that can coexist with the framework code. </span><span class="koboSpan" id="kobo.159.2">Finally, </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">WebRTC</span></strong><span class="koboSpan" id="kobo.161.1"> also fits</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.162.1"> into the category of networking APIs, and it enables the capturing and streaming of audio and video content in the browser. </span><span class="koboSpan" id="kobo.162.2">Similar to WebSockets, the WebRTC framework integration is usually</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.163.1"> included with an external library because it is quite a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">subtle feature.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Storage APIs</span></strong><span class="koboSpan" id="kobo.166.1"> – These APIs have the ability to store data for web application and caching purposes. </span><span class="koboSpan" id="kobo.166.2">These</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.167.1"> APIs are</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.168.1"> often utilized to store data in the local and session storages. </span><span class="koboSpan" id="kobo.168.2">They also write to browser cookies and databases, such as </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">IndexedDB</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">For </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.171.1">instance, Angular applications can include a dependency that provides a cookie service and makes it easier to read and write </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">cookie information.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.173.1">Background services</span></strong><span class="koboSpan" id="kobo.174.1"> – These</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.175.1"> include</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.176.1"> a slew of services that enable background synchronization of data, notifications, push messaging, and more. </span><span class="koboSpan" id="kobo.176.2">Web workers generally provide a way to run background-independent scripts and make use of multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">CPU cores.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Graphics APIs</span></strong><span class="koboSpan" id="kobo.179.1"> – These</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.180.1"> APIs grant the ability to</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.181.1"> render high-performance 3D and vector graphics. </span><span class="koboSpan" id="kobo.181.2">These</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.182.1"> include the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">WebGL</span></strong><span class="koboSpan" id="kobo.184.1"> APIs and </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">SVG</span></strong><span class="koboSpan" id="kobo.186.1"> elements. </span><span class="koboSpan" id="kobo.186.2">The </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.187.1">3D graphics libraries utilize the </span><em class="italic"><span class="koboSpan" id="kobo.188.1">canvas</span></em><span class="koboSpan" id="kobo.189.1"> element for rendering and can utilize the graphics hardware. </span><span class="koboSpan" id="kobo.189.2">For applications built with Vue.js, there is an additional component library called VueGL that makes it easier to create WebGL-based components. </span><span class="koboSpan" id="kobo.189.3">In terms of SVG, JSX in React is able to directly parse SVG syntax, as long as the SVG properties are</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.190.1"> converted to the camel-case </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">JavaScript syntax.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.192.1">A useful, in-depth list of web APIs that frameworks can potentially utilize can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">at </span></span><a href="http://developer.mozilla.org/docs/Web/API"><span class="No-Break"><span class="koboSpan" id="kobo.194.1">developer.mozilla.org/docs/Web/API</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.195.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Let’s now take </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.197.1">a look at a real-world frontend example </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">with Nuxt.js.</span></span></p>
<h3><span class="koboSpan" id="kobo.199.1">Real-world examples</span></h3>
<p><span class="koboSpan" id="kobo.200.1">Nuxt.js uses Vue as a </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.201.1">backbone for its frontend components. </span><span class="koboSpan" id="kobo.201.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.203.1">.2</span></em><span class="koboSpan" id="kobo.204.1">, the Nuxt.js framework has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">NuxtLink</span></strong><span class="koboSpan" id="kobo.206.1"> built-in component for creating links, which can be used in application code, and utilizes several modules from Vue, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">vue-router</span></strong><span class="koboSpan" id="kobo.208.1"> and component-building functions such </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">defineComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.212.1"><img alt="Figure 2.2: Nuxt.js and Vue framework abstraction" src="image/Figure_2.2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.213.1">Figure 2.2: Nuxt.js and Vue framework abstraction</span></p>
<p><span class="koboSpan" id="kobo.214.1">We can follow the usage of this abstraction (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.215.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.216.1">.2</span></em><span class="koboSpan" id="kobo.217.1">) in detail from an </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">example.vue</span></strong><span class="koboSpan" id="kobo.219.1"> page in </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">application code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
pages/index.vue
&lt;template&gt;
  &lt;NuxtLink to="/"&gt;Index page&lt;/NuxtLink&gt;
  &lt;NuxtLink href="https://www.packtpub.com/" target="_blank""&gt;Packt&lt;/NuxtLink&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.222.1">To run this particular code example on your computer, navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">chapter2/nuxt-js-application</span></strong><span class="koboSpan" id="kobo.224.1"> directory and run </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">npm install &amp;&amp; npm run dev</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">Refer to the included </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">chapter2/README.md</span></strong><span class="koboSpan" id="kobo.228.1"> documentation for additional details. </span><span class="koboSpan" id="kobo.228.2">Once the application is ready to run locally, you should see the URL that you can open in your browser in the terminal. </span><span class="koboSpan" id="kobo.228.3">Here’s an example of the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">successful output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
&gt; npm run dev
  &gt; Local:    http://localhost:3000/
  &gt; Network:  http://192.168.1.206:3000/</span></pre>
<p><span class="koboSpan" id="kobo.231.1">The auto-import feature of the framework allows the direct use of the component to create the two links in the template file. </span><span class="koboSpan" id="kobo.231.2">This built-in component is defined in the source of the Nuxt framework </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">at </span></span><a href="http://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts"><span class="No-Break"><span class="koboSpan" id="kobo.233.1">github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.234.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Let us take a</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.236.1"> moment to understand the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">nuxt-link</span></strong><span class="koboSpan" id="kobo.238.1"> component code, following along with the source from the framework itself. </span><span class="koboSpan" id="kobo.238.2">The code behind this particular component extends the routing behavior from Vue.js. </span><span class="koboSpan" id="kobo.238.3">It defines the typed TypeScript interfaces, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">NuxtLinkOptions</span></strong><span class="koboSpan" id="kobo.240.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">NuxtLinkProps</span></strong><span class="koboSpan" id="kobo.242.1">, to accept particular styling attributes and routing options. </span><span class="koboSpan" id="kobo.242.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">defineNuxtLink</span></strong><span class="koboSpan" id="kobo.244.1"> function returns the component with the customized routing behavior. </span><span class="koboSpan" id="kobo.244.2">Helper functions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">checkPropConflicts</span></strong><span class="koboSpan" id="kobo.246.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">resolveTrailingSlashBehavior</span></strong><span class="koboSpan" id="kobo.248.1">, address specific routing use cases. </span><span class="koboSpan" id="kobo.248.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">setup()</span></strong><span class="koboSpan" id="kobo.250.1"> function call uses the Vue 3 Composition API to enable reactive properties of the component and attach component lifecycle hooks to versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">NuxtLink</span></strong><span class="koboSpan" id="kobo.252.1"> in applications. </span><span class="koboSpan" id="kobo.252.2">More details on this API can be found in Vue.js’ documentation – </span><a href="http://vuejs.org/guide/extras/composition-api-faq.html"><span class="koboSpan" id="kobo.253.1">vuejs.org/guide/extras/composition-api-faq.html</span></a><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">The important parts are shown in a condensed </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">form here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
export type NuxtLinkProps = {
 to?: string | RouteLocationRaw
 href?: string | RouteLocationRaw
 target?: '_blank' | '_parent' | '_self' | '_top' | (
  string &amp; {}) | null
 // ...
</span><span class="koboSpan" id="kobo.256.2">}
export function defineNuxtLink (options: NuxtLinkOptions) {
 const componentName = options.componentName || 'NuxtLink'
 return defineComponent({...})
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">In the preceding component code, we see the final return statement of </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">defineComponent</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">This generates the anchor </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">&lt;a&gt;</span></strong><span class="koboSpan" id="kobo.261.1"> element that we ultimately see in the final source of the HTML structure in the web application. </span><span class="koboSpan" id="kobo.261.2">It is produced by the internal Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">function call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
return h('a', { ref: el, href, rel, target})</span></pre>
<p><span class="koboSpan" id="kobo.264.1">From the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">defineNuxtLink</span></strong><span class="koboSpan" id="kobo.266.1"> function, it is also evident that it is possible to modify some parts of the component. </span><span class="koboSpan" id="kobo.266.2">For example, we can define a component with a custom name using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">componentName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">From </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.270.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.271.1">, we’ve</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.272.1"> seen that JavaScript has much to offer for full stack frameworks. </span><span class="koboSpan" id="kobo.272.2">In the next section, we are going to look at the APIs that we can utilize as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">backend environment.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.274.1">Backend runtime abstractions</span></h2>
<p><span class="koboSpan" id="kobo.275.1">Although there are many </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.276.1">frontend </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.277.1">APIs to choose from, we are still bound by what the web browser supports. </span><span class="koboSpan" id="kobo.277.2">This is a lesser issue when we write backend services, as there are still many APIs that we can use, and we can even write our own extensions or integrate with external systems for custom use cases. </span><span class="koboSpan" id="kobo.277.3">Let’s take a look at important APIs that we can use as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">framework development.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">In this section, we will look at both </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">Node.js</span></strong><span class="koboSpan" id="kobo.281.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Deno</span></strong><span class="koboSpan" id="kobo.283.1">, as they are two runtimes that offer similar features. </span><span class="koboSpan" id="kobo.283.2">These runtimes need to handle server creation, file and process management, module packaging, and more. </span><span class="koboSpan" id="kobo.283.3">The following are some of the essential APIs that are used by the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">backend frameworks:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.285.1">Filesystem APIs</span></strong><span class="koboSpan" id="kobo.286.1"> – This has </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.287.1">the ability to read and write files and other file system entities. </span><span class="koboSpan" id="kobo.287.2">Frameworks use this heavily while storing data, loading existing files, and serving static content. </span><span class="koboSpan" id="kobo.287.3">These APIs also include file streaming and </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">asynchronous features.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.289.1">Networking</span></strong><span class="koboSpan" id="kobo.290.1"> – These are the APIs to start new server processes and accept requests. </span><span class="koboSpan" id="kobo.290.2">Includes handling of HTTP requests and other </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">request formats.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.292.1">Modules and packaging</span></strong><span class="koboSpan" id="kobo.293.1"> – These are the conventions of how modules and packages can </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">be loaded.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.295.1">Operating system APIs</span></strong><span class="koboSpan" id="kobo.296.1"> – These are the APIs to fetch information from the operating system that is running the process. </span><span class="koboSpan" id="kobo.296.2">This includes useful data about memory consumption and useful operating </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">system directories.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">Process handling</span></strong><span class="koboSpan" id="kobo.299.1"> – These APIs allow for manipulating and gathering details of the currently running process. </span><span class="koboSpan" id="kobo.299.2">These also enable sub-process creation and handling of </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">multi-process communication.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.301.1">Native modules</span></strong><span class="koboSpan" id="kobo.302.1"> – The native module APIs allow users to call out to libraries written in other native languages, such as C/C++, Rust, and others. </span><span class="koboSpan" id="kobo.302.2">In some cases, they </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.303.1">use the </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">Foreign Function Interface </span></strong><span class="koboSpan" id="kobo.305.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.306.1">FFI</span></strong><span class="koboSpan" id="kobo.307.1">). </span><span class="koboSpan" id="kobo.307.2">WebAssembly is also part of this native </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">module support.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.309.1">Worker APIs</span></strong><span class="koboSpan" id="kobo.310.1"> – Allows the spawning of additional worker threads to schedule heavy server work to happen outside of the main process. </span><span class="koboSpan" id="kobo.310.2">For instance, the Deno runtime </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.311.1">supports the </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">Web Worker API</span></strong><span class="koboSpan" id="kobo.313.1"> to provide these features, while Node.js</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.314.1"> uses its </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Worker </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.316.1">Threads</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> module.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.318.1">Console and debugging</span></strong><span class="koboSpan" id="kobo.319.1"> – This set of internal APIs allows for recording process logs. </span><span class="koboSpan" id="kobo.319.2">The debugging APIs make developing and finding issues in the running code easier. </span><span class="koboSpan" id="kobo.319.3">Paired with an editor that supports debugging operations, it can pause the debugger </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.320.1">when the framework request handler is processing </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">a request.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.322.1">These are some </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.323.1">of the APIs that backend frameworks can use as the foundation for their projects. </span><span class="koboSpan" id="kobo.323.2">For instance, the hapi.js framework is able to combine some of these APIs to create its </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Server</span></strong><span class="koboSpan" id="kobo.325.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Route</span></strong><span class="koboSpan" id="kobo.327.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Request</span></strong><span class="koboSpan" id="kobo.329.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Plugin</span></strong><span class="koboSpan" id="kobo.331.1"> modules. </span><span class="koboSpan" id="kobo.331.2">For example, its </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Core</span></strong><span class="koboSpan" id="kobo.333.1"> (</span><a href="http://hapi/lib/core.js"><span class="koboSpan" id="kobo.334.1">hapi/lib/core.js</span></a><span class="koboSpan" id="kobo.335.1">) module makes use of the operating system, networking, and </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">module-handling APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">Next, we can take a look</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.338.1"> at a detailed example of combinations of abstractions and runtime APIs in</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.339.1"> Nest.js, a framework that is familiar to us from </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.340.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.342.1">Backend framework abstractions</span></h3>
<p><span class="koboSpan" id="kobo.343.1">The Nest.js framework </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.344.1">supports the ability to provide any HTTP framework as long as there is an adapter defined to work with it. </span><span class="koboSpan" id="kobo.344.2">The existing adapters that are built right into Nest.js are </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">platform-express</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">platform-fastify</span></strong><span class="koboSpan" id="kobo.348.1">. </span><span class="koboSpan" id="kobo.348.2">The default behavior of the HTTP adapter abstraction is transparent to the developer as it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">express</span></strong><span class="koboSpan" id="kobo.350.1"> module </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">by default.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.353.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.354.1">.3</span></em><span class="koboSpan" id="kobo.355.1">, we can see the combination of all the components. </span><span class="koboSpan" id="kobo.355.2">The application code is powered by the framework that utilizes both the framework abstractions and the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">Node.js API:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.357.1"><img alt="Figure 2.3: Nest.js framework abstractions" src="image/Figure_2.3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.358.1">Figure 2.3: Nest.js framework abstractions</span></p>
<p><span class="koboSpan" id="kobo.359.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.361.1">.3</span></em><span class="koboSpan" id="kobo.362.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">main.ts</span></strong><span class="koboSpan" id="kobo.364.1"> entry point file in Nest.js starts the server and listens for </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">incoming requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
main.ts
const port = 5300;
const app = await NestFactory.create(AppModule);
await app.listen(port);</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">express-adapter</span></strong><span class="koboSpan" id="kobo.368.1">, which </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.369.1">extends from </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">AbstractHttpAdapter</span></strong><span class="koboSpan" id="kobo.371.1">, defines the set of methods required for the HTTP server, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">listen</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
import * as express from 'express';
import * as http from 'http';
import * as https from 'https';
// ...
</span><span class="koboSpan" id="kobo.375.2">export class ExpressAdapter extends AbstractHttpAdapter {
  // ...
</span><span class="koboSpan" id="kobo.375.3">  public listen(port: string | number, callback?: () =&gt;
    void): Server;
  public listen(
    port: string | number,
    hostname: string,
    callback?: () =&gt; void,
  ): Server;
  public listen(port: any, ...args: any[]): Server {
    return this.httpServer.listen(port, ...args);
  }
  // ...
</span><span class="koboSpan" id="kobo.375.4">}</span></pre>
<p><span class="koboSpan" id="kobo.376.1">The adapter code above utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">express</span></strong><span class="koboSpan" id="kobo.378.1"> framework and the internal </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">http</span></strong><span class="koboSpan" id="kobo.380.1"> APIs. </span><span class="koboSpan" id="kobo.380.2">Ultimately, this results in a class that exposes a method to set up an HTTP server. </span><span class="koboSpan" id="kobo.380.3">Even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">express</span></strong><span class="koboSpan" id="kobo.382.1"> provides the routing and HTTP helpers, it does not start the server by itself. </span><span class="koboSpan" id="kobo.382.2">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">express-adapter</span></strong><span class="koboSpan" id="kobo.384.1">, there is a direct call to </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">Node.js APIs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
initHttpServer(options) {
  const isHttpsEnabled = options &amp;&amp; options.httpsOptions;
  if (isHttpsEnabled) {
  this.httpServer = https.createServer
    (options.httpsOptions, this.getInstance());
  } else {
  this.httpServer = http.createServer(this.getInstance());
  }
   // ...
</span><span class="koboSpan" id="kobo.386.2">}</span></pre>
<p><span class="koboSpan" id="kobo.387.1">The direct call in the preceding code block figures out the type of server to start, </span><em class="italic"><span class="koboSpan" id="kobo.388.1">HTTP</span></em><span class="koboSpan" id="kobo.389.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.390.1">HTTPS</span></em><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">It also accepts a variety of </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">httpOptions</span></strong><span class="koboSpan" id="kobo.393.1"> values. </span><span class="koboSpan" id="kobo.393.2">This pattern is similar in other frameworks. </span><span class="koboSpan" id="kobo.393.3">For instance, in AdonisJS, the framework authors define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">HttpServer</span></strong><span class="koboSpan" id="kobo.395.1"> class (</span><a href="http://github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts"><span class="koboSpan" id="kobo.396.1">github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts</span></a><span class="koboSpan" id="kobo.397.1">) that creates an HTTP server and utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">createHttpServer</span></strong><span class="koboSpan" id="kobo.399.1"> utility function to call out to the runtime APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">of Node.js.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">As we dig in further to understand how existing frameworks are structured and how their abstractions work, it is important to have a way of traversing the code of these nested </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.402.1">abstractions. </span><span class="koboSpan" id="kobo.402.2">In the next section, we will cover the technique of debugging, which can help us uncover the hidden interfaces within </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">the frameworks.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.404.1">About debugging</span></h2>
<p><span class="koboSpan" id="kobo.405.1">Debugging</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.406.1"> plays an</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.407.1"> important role in software development. </span><span class="koboSpan" id="kobo.407.2">It helps us identify and resolve issues quickly. </span><span class="koboSpan" id="kobo.407.3">As part of the framework learning process, it also helps us understand how these frameworks work internally. </span><span class="koboSpan" id="kobo.407.4">By stepping through the breakpoints of the program and digging deep into the call stack, we can understand the inner workings of the internal modules. </span><span class="koboSpan" id="kobo.407.5">It also helps us navigate through multiple levels </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">of abstractions.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Node.js’ debugger integration provides a way for us to debug our programs and frameworks. </span><span class="koboSpan" id="kobo.409.2">It is a good habit to try it out on your own to get a better understanding of how the framework functions. </span><span class="koboSpan" id="kobo.409.3">For example, to debug a Nest.js application, we can utilize the Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">Code debugger:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.411.1">Open up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">nest-js-application</span></strong><span class="koboSpan" id="kobo.413.1"> project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">framework-organization</span></strong><span class="koboSpan" id="kobo.415.1"> directory of the book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">GitHub repository.</span></span></li>
<li><span class="koboSpan" id="kobo.417.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">npm install</span></strong><span class="koboSpan" id="kobo.419.1"> to get the </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">project’s dependencies.</span></span></li>
<li><span class="koboSpan" id="kobo.421.1">Set a code execution breakpoint in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">app.service.ts</span></strong><span class="koboSpan" id="kobo.423.1"> file of the application; refer to the screenshot in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.424.1">Figure </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.425.1">2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.426.1">.5</span></em><span class="koboSpan" id="kobo.427.1">. </span><span class="koboSpan" id="kobo.427.2">To set the breakpoint, hit the empty space to the left of the line number until you see a red dot. </span><span class="koboSpan" id="kobo.427.3">Once this red dot appears, that will be </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">your breakpoint.</span></span></li>
<li><span class="koboSpan" id="kobo.429.1">In Visual Studio Code, browse to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">package.json</span></strong><span class="koboSpan" id="kobo.431.1"> file, and press the </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">Debug</span></strong><span class="koboSpan" id="kobo.433.1"> button near </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.434.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">scripts</span></strong><span class="koboSpan" id="kobo.436.1"> section. </span><span class="koboSpan" id="kobo.436.2">See an example of this in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.437.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">:</span></span></li>
</ol>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.440.1"><img alt="Figure 2.4: Debug button in package.json" src="image/Figure_2.4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.441.1">Figure 2.4: Debug button in package.json</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.442.1">After pressing the </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">Debug</span></strong><span class="koboSpan" id="kobo.444.1"> button, you will be presented with a context menu of all the available </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.445.1">scripts in the project. </span><span class="koboSpan" id="kobo.445.2">Select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">start:dev</span></strong><span class="koboSpan" id="kobo.447.1"> option, which should start the application, observable in the </span><strong class="bold"><span class="koboSpan" id="kobo.448.1">Terminal</span></strong><span class="koboSpan" id="kobo.449.1"> tab of Visual Studio Code. </span><span class="koboSpan" id="kobo.449.2">Watch out for errors in the terminal log. </span><span class="koboSpan" id="kobo.449.3">For example, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">nest</span></strong><span class="koboSpan" id="kobo.451.1"> command is not found, that means you need to install the dependencies for this project using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">npm install</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.454.1">With the application running in debug mode and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">start:dev</span></strong><span class="koboSpan" id="kobo.456.1"> script, open the address at </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">http://127.0.0.1:3000</span></strong><span class="koboSpan" id="kobo.458.1"> in your browser. </span><span class="koboSpan" id="kobo.458.2">This should now pause on the extract line of </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">your breakpoint.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.460.1">If you hit a breakpoint properly in the editor, that means you successfully attached the debugger to the application. </span><span class="koboSpan" id="kobo.460.2">You can now use the call stack pane on the left (as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.462.1">.5</span></em><span class="koboSpan" id="kobo.463.1">) to navigate around the running process and browse through the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">Nest.js modules:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.465.1"><img alt="Figure 2.5: Debugging a Nest.js application" src="image/Figure_2.5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">Figure 2.5: Debugging a Nest.js application</span></p>
<p><span class="koboSpan" id="kobo.467.1">This technique is a quick way to get a view behind the scenes of a framework. </span><span class="koboSpan" id="kobo.467.2">It enables developers to quickly get a sense of how the framework functions and makes it easier to understand the nested abstractions. </span><span class="koboSpan" id="kobo.467.3">To get more from it, you can find an in-depth explanation of</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.468.1"> the</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.469.1"> Visual Studio Code debugger </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">at </span></span><a href="http://code.visualstudio.com/docs/editor/debugging"><span class="No-Break"><span class="koboSpan" id="kobo.471.1">code.visualstudio.com/docs/editor/debugging</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.472.1">.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.473.1">Framework building blocks</span></h1>
<p><span class="koboSpan" id="kobo.474.1">Just like most programming</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.475.1"> languages, JavaScript, and its extensions such as TypeScript, have the fundamental features of working with numbers, strings, Booleans, conditional logic statements, and much more. </span><span class="koboSpan" id="kobo.475.2">The more advanced features are built on top of those fundamentals. </span><span class="koboSpan" id="kobo.475.3">The frameworks utilize existing interfaces, such as events and modules. </span><span class="koboSpan" id="kobo.475.4">However, they also create their own build blocks, by defining interfaces to create components, routers, </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">and others.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">In this section, we are going to examine both existing interfaces and custom ones. </span><span class="koboSpan" id="kobo.477.2">We are going to look at some of the common interfaces, which can be combined to make a framework. </span><span class="koboSpan" id="kobo.477.3">These are the abstracted entities that solve particular problems in application development and are beneficial to </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">their users.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.479.1">Events</span></h2>
<p><span class="koboSpan" id="kobo.480.1">Event binding and events </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.481.1">are everywhere in JavaScript applications. </span><span class="koboSpan" id="kobo.481.2">They enable frontend user interfaces and interactivity through buttons, forms, pointer movement, keyboard keys, scrolling, and more. </span><span class="koboSpan" id="kobo.481.3">The concept of event binding is something that every framework handles with different syntax definitions </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
// Vanilla JavaScript
someInput.addEventListener('keyup', keyDownHandler)
// Vanilla HTML
&lt;input type="text" onkeyup="keyDownHandler()" /&gt;
// React
&lt;input type="text" value={answer} onKeyPress=
  {keyDownHandler}/&gt;
// Angular key down combination of SHIFT + ESC keys
&lt;input (keyup.shift.esc)="keyDownHandler($event)" /&gt;
// Vue key down
&lt;input @keyup.shift.esc="keyDownHandler" /&gt;</span></pre>
<p><span class="koboSpan" id="kobo.484.1">Most of the time, the event handling is very similar to original DOM events, but with a modified syntax to fit the framework abstractions better. </span><span class="koboSpan" id="kobo.484.2">Frameworks further enable event handling by providing more complex event management components. </span><span class="koboSpan" id="kobo.484.3">For example, Angular has the concept of </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">HostListener</span></strong><span class="koboSpan" id="kobo.486.1"> (</span><a href="http://angular.io/api/core/HostListener"><span class="koboSpan" id="kobo.487.1">angular.io/api/core/HostListener</span></a><span class="koboSpan" id="kobo.488.1">) to register events within </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">its components.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">On the server side, Node.js is heavily event-based because of its asynchronous, event-driven architecture and the frameworks take advantage of that. </span><span class="koboSpan" id="kobo.490.2">For example, hapi.js maintains its own event emitter package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">@hapi/podium</span></strong><span class="koboSpan" id="kobo.492.1">, which allows the developers to register custom </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">application events.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">Another example of the event handling pattern would be how the </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">Johnny-Five</span></strong><span class="koboSpan" id="kobo.496.1"> framework handles sensor data. </span><span class="koboSpan" id="kobo.496.2">If the</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.497.1"> hardware board has a GPS chip, then it will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">change</span></strong><span class="koboSpan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">navigation</span></strong><span class="koboSpan" id="kobo.501.1"> events to report the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">latest values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
board.on("ready", function() {
  const gps = new five.GPS({
    pins: {rx: 11, tx: 10}
  });
  gps.on("change", function() {
    console.log(this.altitude);
  });
  gps.on("navigation", function() {
    console.log(this.speed);
  });
});</span></pre>
<p><span class="koboSpan" id="kobo.504.1">The use of events is an important building block, which allows us to subscribe to user interaction and listen to </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.505.1">the changes or progress of some operation. </span><span class="koboSpan" id="kobo.505.2">As we are set on developing our own framework, it needs to provide a way to interact with events and abstract certain complexities </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">around them.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.507.1">Components</span></h2>
<p><span class="koboSpan" id="kobo.508.1">Many frameworks </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.509.1">provide an abstraction to create reusable components to organize the project. </span><span class="koboSpan" id="kobo.509.2">Depending on how the application is planned out, components can help split any type of application into reusable and independent pieces of code. </span><span class="koboSpan" id="kobo.509.3">These code parts can also be nested within each other. </span><span class="koboSpan" id="kobo.509.4">Depending on the required business logic, developers can define custom components, use the pre-built ones, or import a library of components that are designed for specific use. </span><span class="koboSpan" id="kobo.509.5">Once many components are nested and situated together, it is common to have some interaction between these objects. </span><span class="koboSpan" id="kobo.509.6">The components utilize data properties to render the information to the user from the current state, and in many cases, they need some properties from the parent components. </span><span class="koboSpan" id="kobo.509.7">For frameworks that use React or Vue, this means writing communication patterns that enable child-to-parent component communication and the other way around. </span><span class="koboSpan" id="kobo.509.8">This communication process can get complicated, which is why these frameworks use a unidirectional or a one-way data flow where the data updates flow from parent to child components. </span><span class="koboSpan" id="kobo.509.9">Instead of synchronizing the same state between nested components, it is advised to store the state in the most common ancestor component in </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">the chain.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">If we have a complex application, this means that we will probably end up with a lot of components, nested multiple levels deep. </span><span class="koboSpan" id="kobo.511.2">This is </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.512.1">where </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">component composition</span></strong><span class="koboSpan" id="kobo.514.1"> can help. </span><span class="koboSpan" id="kobo.514.2">Component composition is a pattern that allows for minimal code duplication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">performance improvements.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">In the following figure, we have an illustrative example of how composition can affect and reorganize a set of nested components within an application. </span><span class="koboSpan" id="kobo.516.2">The component organization pattern is very</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.517.1"> familiar to developers, so it would be a good choice to use or create a framework utilizing </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">this pattern:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.519.1"><img alt="Figure ﻿2.6: Nested versus composed components" src="image/Figure_2.6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.520.1">Figure 2.6: Nested versus composed components</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.521.1">Lifecycle methods</span></h2>
<p><span class="koboSpan" id="kobo.522.1">Lifecycle methods or</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.523.1"> events are often managed by the framework, providing the ability to execute code at particular points. </span><span class="koboSpan" id="kobo.523.2">These methods can be used to execute custom logic at different stages of components and other parts of the system, which provides flexibility to the framework interfaces. </span><span class="koboSpan" id="kobo.523.3">These lifecycle methods can be used to attach or detach additional logging, utility functions, and more during the component execution. </span><span class="koboSpan" id="kobo.523.4">Lifecycle sequence, which means the order of how these events occur, must be well documented and described in the framework. </span><span class="koboSpan" id="kobo.523.5">This is done mostly due to the fact that the lifecycle methods can have a particular naming convention and have a complex </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">runtime hierarchy.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">In Nest.js, the server framework provides lifecycle hooks to its module system. </span><span class="koboSpan" id="kobo.525.2">Some examples of that are </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">onApplicationBootstrap()</span></strong><span class="koboSpan" id="kobo.527.1">, which is called when all modules in the application have been initialized, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">onModuleInit()</span></strong><span class="koboSpan" id="kobo.529.1">, which is called when the dependencies of a module have been resolved. </span><span class="koboSpan" id="kobo.529.2">Using the TypeScript interfaces in Nest.js, we can inject code into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">onApplicationShutdown</span></strong><span class="koboSpan" id="kobo.531.1"> lifecycle event as all connections to the server close down, which can be defined </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
@Injectable()
class SomeService implements OnApplicationShutdown {
  onApplicationShutdown(processSignal: string) {
    // ...
</span><span class="koboSpan" id="kobo.533.2">  }
}</span></pre>
<p><span class="koboSpan" id="kobo.534.1">In Vue.js, given that the framework deals with rendering components, the events available cover the whole lifetime of the component. </span><span class="koboSpan" id="kobo.534.2">For instance, it has </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">beforeCreate</span></strong><span class="koboSpan" id="kobo.536.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">created</span></strong><span class="koboSpan" id="kobo.538.1"> events as the component initializes its state, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">beforeMount</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">mounted</span></strong><span class="koboSpan" id="kobo.542.1"> events as the component gets mounted to the DOM tree. </span><span class="koboSpan" id="kobo.542.2">You can find a </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.543.1">great lifecycle diagram of Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">at </span></span><a href="http://vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram"><span class="No-Break"><span class="koboSpan" id="kobo.545.1">vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.546.1">.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.547.1">Router</span></h2>
<p><span class="koboSpan" id="kobo.548.1">Both frontend and backend</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.549.1"> frameworks usually require some form of a router that navigates to different parts of the application. </span><span class="koboSpan" id="kobo.549.2">The router mechanism on the frontend follows the navigational pattern of web pages, following the browser’s URL patterns. </span><span class="koboSpan" id="kobo.549.3">On the frontend, the router is essential to transition between states or navigate to internal or external pages. </span><span class="koboSpan" id="kobo.549.4">Besides providing the routing </span><em class="italic"><span class="koboSpan" id="kobo.550.1">tree</span></em><span class="koboSpan" id="kobo.551.1"> structure, the router is also responsible for interfaces that allow components to invoke the routing behaviors – we saw an example of this via </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">NuxtLink</span></strong><span class="koboSpan" id="kobo.553.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.554.1">Real-world Examples</span></em><span class="koboSpan" id="kobo.555.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">react-router</span></strong><span class="koboSpan" id="kobo.559.1"> (</span><a href="http://reactrouter.com/main/start/overview"><span class="koboSpan" id="kobo.560.1">reactrouter.com/main/start/overview</span></a><span class="koboSpan" id="kobo.561.1">) project is a good example of everything you </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.562.1">need from a router component. </span><span class="koboSpan" id="kobo.562.2">It makes it possible to simply define the routes within a component </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
&lt;Routes&gt;
  &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
    &lt;Route index element={&lt;Login /&gt;} /&gt;
    &lt;Route path="register" element={&lt;Register /&gt;} /&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</span></pre>
<p><span class="koboSpan" id="kobo.565.1">The backend server frameworks use a server router to handle requests coming to API endpoints. </span><span class="koboSpan" id="kobo.565.2">Normally, the router interface takes different forms of endpoint URL structures and maps those into functions that process the route. </span><span class="koboSpan" id="kobo.565.3">Some good examples of an unopinionated router can be found in </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">Express.js (</span></span><a href="http://expressjs.com/guide/routing.html"><span class="No-Break"><span class="koboSpan" id="kobo.567.1">expressjs.com/guide/routing.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.568.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">From the following code example, we see the relationship between the endpoint path and the function that is able to process the request and a </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">text response:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
app.get('/framework-organization', (req, res) =&gt; {
  res.send('Learn about framework organization!')
})</span></pre>
<p><span class="koboSpan" id="kobo.572.1">From </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.573.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.574.1">, we have seen examples of file-based routing, which further simplifies the routing mechanisms </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.575.1">by just looking at the files in the application, and dynamically creating routes based on </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">those files.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.577.1">Template engine</span></h2>
<p><span class="koboSpan" id="kobo.578.1">Another essential building </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.579.1">block is the template engine. </span><span class="koboSpan" id="kobo.579.2">This engine combines the static parts of a marked-up document with the data from the application. </span><span class="koboSpan" id="kobo.579.3">Templating makes it possible to render views with various forms of data. </span><span class="koboSpan" id="kobo.579.4">With frontend frameworks, this usually means rendering the nested component hierarchy. </span><span class="koboSpan" id="kobo.579.5">The template engine’s job is to enable data binding and to bind any specified events for the interactive components, such as buttons or </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">input fields.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">With a backend framework, templating engines render the whole page or, in some cases, partials, sending them over the wire to the client for initial static rendering. </span><span class="koboSpan" id="kobo.581.2">From </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.582.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.583.1">, we have seen frameworks, such as Next.js, that are able to render the frontend components on the server side and then attach any JavaScript behaviors to the readily rendered component. </span><span class="koboSpan" id="kobo.583.2">By default, in Next.js, the pages are pre-rendered to improve search engine optimization and performance in the browser client. </span><span class="koboSpan" id="kobo.583.3">Templating is a vital building block of a framework – this is how developers create the presentation layer and mark up the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">page structure.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.585.1">Networking</span></h2>
<p><span class="koboSpan" id="kobo.586.1">Web frameworks </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.587.1">commonly provide several </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.588.1">components as networking abstractions. </span><span class="koboSpan" id="kobo.588.2">The ability to use a good networking interface can vastly improve the readability, performance, and error handling of the application. </span><span class="koboSpan" id="kobo.588.3">Here are some features that usually come as part of a good </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">networking abstraction:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.590.1">Session management</span></strong><span class="koboSpan" id="kobo.591.1"> – This is the</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.592.1"> ability to manage sessions and provide easy access to session information. </span><span class="koboSpan" id="kobo.592.2">This is included as part of networking because frontend frameworks usually rely on the backend service to fetch and parse the </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">session information.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.594.1">Error handling</span></strong><span class="koboSpan" id="kobo.595.1"> – This provides good interfaces to handle all types of possible errors that can happen during the process of making a request to </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">an endpoint.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.597.1">Caching</span></strong><span class="koboSpan" id="kobo.598.1"> – This is the mechanism that provides a caching layer to improve performance and avoid redundant queries if the data is already </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">fresh enough.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.600.1">Security</span></strong><span class="koboSpan" id="kobo.601.1"> – Often frameworks come with baked-in security features that follow the best practices. </span><span class="koboSpan" id="kobo.601.2">This includes examples such as XSS, CSRF protection, script injection prevention, and </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">input validation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.603.1">Request and response management</span></strong><span class="koboSpan" id="kobo.604.1"> – This improves the ability to make requests with the required parameters and parse the responses from </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">external systems.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.606.1">Most of these networking abstractions apply to both frontend and backend systems. </span><span class="koboSpan" id="kobo.606.2">In a full stack framework, a combination of these abstractions can vastly improve the workflow and the efficiency of the system that it </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">is supporting.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">All these abstractions are implemented in JavaScript, TypeScript, or enabled by the runtime. </span><span class="koboSpan" id="kobo.608.2">Their implementation can be provided from within three categories of code structures – as a module, library, or built into a framework. </span><span class="koboSpan" id="kobo.608.3">In the next section, we are going to explore these categories of </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">code organization.</span></span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.610.1">Differentiating modules, libraries, and frameworks</span></h1>
<p><span class="koboSpan" id="kobo.611.1">While</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.612.1"> working</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.613.1"> on </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.614.1">JavaScript</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.615.1"> applications, we </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.616.1">rely on </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.617.1">modules, libraries, and, of course, the larger frameworks. </span><span class="koboSpan" id="kobo.617.2">These structures can originate from internal and external sources, meaning they are either written by you or your team or are a dependency that is written by someone else. </span><span class="koboSpan" id="kobo.617.3">JavaScript, specifically, is in a unique position where modules, libraries, and even frameworks can be used on browser and server environments. </span><span class="koboSpan" id="kobo.617.4">For framework developers, it is important to know how to work with these JavaScript structures, because frameworks heavily rely on defining </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.618.1">and </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.619.1">using</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.620.1"> modules </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.621.1">and</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.622.1"> libraries. </span><span class="koboSpan" id="kobo.622.2">These</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.623.1"> abstractions and structures allow for better code organization, which we will be discussing in the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">next subsections.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.625.1">Modules</span></h2>
<p><span class="koboSpan" id="kobo.626.1">Developers create their </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.627.1">own modules to separate the code into multiple files or logical blocks. </span><span class="koboSpan" id="kobo.627.2">In a similar manner, modules can be imported from external sources. </span><span class="koboSpan" id="kobo.627.3">The module encapsulation wraps a block of code, providing a way for it to export various data types through strings, functions, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">data types.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">The history of how modules are defined and used in JavaScript is complicated; it ventures out to different module patterns and implementations. </span><span class="koboSpan" id="kobo.629.2">Even in modern projects, you will find inconsistent approaches to module management. </span><span class="koboSpan" id="kobo.629.3">Initially, there was no way to organize modules, so frontend JavaScript modules were wrapped in immediately invoked function expressions or objects. </span><span class="koboSpan" id="kobo.629.4">Using functions allows the hosting of all the values inside of it within a lexical scope. </span><span class="koboSpan" id="kobo.629.5">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">a sample:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.631.1">
let myModule = (function () {
  // ...
</span><span class="koboSpan" id="kobo.631.2">  return {
    someProperty: function ()  {
    // ...
</span><span class="koboSpan" id="kobo.631.3">    }
  }
})();</span></pre>
<p><span class="koboSpan" id="kobo.632.1">It was evident that the language needed some kind of a modular pattern, and this is where </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">CommonJS</span></strong><span class="koboSpan" id="kobo.634.1"> and AMD types </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.635.1">of modules were introduced. </span><span class="koboSpan" id="kobo.635.2">Defining a CommonJS module is straightforward and can be seen in use in a lot of the </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">Node.js frameworks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
module.exports = class MyModule {
  constructor(someProperty) {
    this.someProperty = someProperty;
  }
  myMethod() {
    return this.someProperty;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.638.1">For instance, hapi.js uses </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.639.1">a similar CommonJS module pattern in most of its files, which can be found in the framework repository at </span><a href="http://github.com/hapijs/hapi/tree/master/lib"><span class="koboSpan" id="kobo.640.1">github.com/hapijs/hapi/tree/master/lib</span></a><span class="koboSpan" id="kobo.641.1"> – a simple example from a list of its modules is </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">lib/compression.js</span></strong><span class="koboSpan" id="kobo.643.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">lib</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
const Zlib = require('zlib');
const Accept = require('@hapi/accept');
exports = module.exports = internals.Compression = class {
   // ...
</span><span class="koboSpan" id="kobo.646.2">   accept(request) {
        const header = request.headers['accept-encoding'];
        // ...
</span><span class="koboSpan" id="kobo.646.3">   }
};</span></pre>
<p><span class="koboSpan" id="kobo.647.1">This module provides compression functions for many hapi.js use cases. </span><span class="koboSpan" id="kobo.647.2">With some of the code omitted, we see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">exports</span></strong><span class="koboSpan" id="kobo.649.1"> keyword, which is used to make methods from this module available in </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">other files.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">These days projects may have different types of JavaScript modules that are used as part of their workflow. </span><span class="koboSpan" id="kobo.651.2">The more standard ones you will see are CommonJS and </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">ECMAScript Modules</span></strong><span class="koboSpan" id="kobo.653.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.654.1">ESM</span></strong><span class="koboSpan" id="kobo.655.1">) module files. </span><span class="koboSpan" id="kobo.655.2">We </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.656.1">saw an example of CommonJS structures earlier in this chapter with its </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">module.exports</span></strong><span class="koboSpan" id="kobo.658.1"> keywords. </span><span class="koboSpan" id="kobo.658.2">The ESM system provides </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">import</span></strong><span class="koboSpan" id="kobo.660.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">export</span></strong><span class="koboSpan" id="kobo.662.1"> keywords to manage the modules. </span><span class="koboSpan" id="kobo.662.2">To distinguish the module types, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">.cjs</span></strong><span class="koboSpan" id="kobo.664.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">.mjs</span></strong><span class="koboSpan" id="kobo.666.1"> file extensions are used to be explicit about which module system is used. </span><span class="koboSpan" id="kobo.666.2">The normal </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">.js</span></strong><span class="koboSpan" id="kobo.668.1"> extension can still be used, but then it is up to the module loading system to figure out how to load </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">these files.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Some examples of module types that you may see in the ecosystem are </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">listed here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.672.1">Universal Module Definition</span></strong><span class="koboSpan" id="kobo.673.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.674.1">UMD</span></strong><span class="koboSpan" id="kobo.675.1">) – This is the </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.676.1">module definition that tries to support all possible </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">module declarations</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.678.1">Asynchronous Module Definition</span></strong><span class="koboSpan" id="kobo.679.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.680.1">AMD</span></strong><span class="koboSpan" id="kobo.681.1">) – This is a</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.682.1"> largely deprecated system with </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">require()</span></strong><span class="koboSpan" id="kobo.684.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">define()</span></strong><span class="koboSpan" id="kobo.686.1"> functions to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">the module</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.688.1">Immediately Invoked Function Expression</span></strong><span class="koboSpan" id="kobo.689.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.690.1">IIFE</span></strong><span class="koboSpan" id="kobo.691.1">) – These are simplistic modules</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.692.1"> encapsulated by a </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">function scope</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.694.1">The module systems are slowly getting better in JavaScript, but it is something to watch out for when using various modules in frameworks and choosing the right module system to use. </span><span class="koboSpan" id="kobo.694.2">The varying</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.695.1"> usage of modules can lead to issues with loading in specific environments or can lead to some features not working </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">as intended.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.697.1">Libraries</span></h2>
<p><span class="koboSpan" id="kobo.698.1">Libraries are indispensable </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.699.1">in software development nowadays; they play an important role in supporting web development projects of any size. </span><span class="koboSpan" id="kobo.699.2">The libraries consist of a collection of useful resources that implement certain specific functionality with a well-defined interface. </span><span class="koboSpan" id="kobo.699.3">The focus of libraries is to include the encapsulation of optimized features to solve certain problems. </span><span class="koboSpan" id="kobo.699.4">Most libraries try to focus on a specific set of problems that can help their stakeholders. </span><span class="koboSpan" id="kobo.699.5">JavaScript has an abundance of open source libraries that developers cannot live without in professional projects. </span><span class="koboSpan" id="kobo.699.6">They don’t dictate any specific opinionated control flow, but instead, let the developer make use of them when needed. </span><span class="koboSpan" id="kobo.699.7">In a similar fashion to frameworks, the technological availability of the JavaScript runtime allows some of the libraries to be used in both the browser and the </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">backend environments.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">Libraries can serve as a</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.702.1"> core component used by a framework to solve certain technological challenges. </span><span class="koboSpan" id="kobo.702.2">There are many cases where we see frameworks building abstractions</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.703.1"> around the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">following libraries:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.705.1">lodash</span></strong><span class="koboSpan" id="kobo.706.1"> (</span><a href="http://lodash.com"><span class="koboSpan" id="kobo.707.1">lodash.com</span></a><span class="koboSpan" id="kobo.708.1">) – This library </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.709.1">provides a large set of utility functions for </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">common tasks</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.711.1">React</span></strong><span class="koboSpan" id="kobo.712.1"> (</span><a href="http://reactjs.org"><span class="koboSpan" id="kobo.713.1">reactjs.org</span></a><span class="koboSpan" id="kobo.714.1">) – This is an </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.715.1">extremely popular user interface component rendering library with state management that many of the frontend frameworks mentioned so far are </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">based on</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.717.1">Axios</span></strong><span class="koboSpan" id="kobo.718.1"> (</span><a href="http://axios-http.com"><span class="koboSpan" id="kobo.719.1">axios-http.com</span></a><span class="koboSpan" id="kobo.720.1">) – This is a </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.721.1">powerful HTTP client library for frontend and backend </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">JavaScript projects</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.723.1">Luxon</span></strong><span class="koboSpan" id="kobo.724.1"> (</span><a href="http://moment.github.io/luxon"><span class="koboSpan" id="kobo.725.1">moment.github.io/luxon</span></a><span class="koboSpan" id="kobo.726.1">) – This is </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.727.1">a library to manipulate date and time in JavaScript, the evolution of a popular library </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">called moment.js</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.729.1">jQuery</span></strong><span class="koboSpan" id="kobo.730.1"> (</span><a href="http://jquery.com"><span class="koboSpan" id="kobo.731.1">jquery.com</span></a><span class="koboSpan" id="kobo.732.1">) – This is more than </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.733.1">a decade old – a popular library that simplified DOM traversal and abstracted away cross-browser quirks for CSS, AJAX, </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">and more</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.735.1">Three.js</span></strong><span class="koboSpan" id="kobo.736.1"> (</span><a href="http://threejs.org"><span class="koboSpan" id="kobo.737.1">threejs.org</span></a><span class="koboSpan" id="kobo.738.1">) – This is a</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.739.1"> JavaScript 3D library that abstracts away the complexities of WebGL and 3D graphics on </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the web</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.741.1">It is a common pattern to build out additional tooling on top of existing libraries to enable applications of various types. </span><span class="koboSpan" id="kobo.741.2">For example, in </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.742.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.743.1">, we saw examples of frameworks building tooling and abstractions around React. </span><span class="koboSpan" id="kobo.743.2">If the project allows you to, it is usually a good idea </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.744.1">to utilize a library or learn from existing implementations for a solved problem rather than rebuilding or rewriting the same code. </span><span class="koboSpan" id="kobo.744.2">In the next section, we are going to compare choosing a development workflow with a set of libraries in contrast with </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">framework-driven workflows.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.746.1">Frameworks</span></h2>
<p><span class="koboSpan" id="kobo.747.1">From </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.748.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.749.1">, we already know </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.750.1">what JavaScript frameworks do and the benefits they offer. </span><span class="koboSpan" id="kobo.750.2">It is also important to understand how much frameworks rely on libraries for their workflows and features, and the differences between them. </span><span class="koboSpan" id="kobo.750.3">Both libraries and frameworks manage control flow in the applications. </span><span class="koboSpan" id="kobo.750.4">This control flow is the order and structure of how the logic in the application flows. </span><span class="koboSpan" id="kobo.750.5">With a library workflow, the existing program will have its own control flow and as part of it the library functions are executed when required. </span><span class="koboSpan" id="kobo.750.6">This existing program precisely calls out to the reusable code in the library. </span><span class="koboSpan" id="kobo.750.7">This gives full control to the developer to structure the application as they see fit, allowing for more room to fine-tune the application behavior but missing the value and structures that could potentially be gained by using </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">a framework.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">With a framework workflow, the framework dictates how the control flow should be structured. </span><span class="koboSpan" id="kobo.752.2">In this case, the developer works within the constraints of the framework and follows the often strict guidelines defined by </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">someone else.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">A good comparison would be the React library versus a JavaScript framework such as Next.js that depends on the library. </span><span class="koboSpan" id="kobo.754.2">The library just consists of functions that execute certain tasks. </span><span class="koboSpan" id="kobo.754.3">React contains logic for rendering, creating components, and other methods. </span><span class="koboSpan" id="kobo.754.4">But it is Next.js – the framework – that defines the architecture for the application, using the library methods from within to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">its features.</span></span></p>
<p><span class="koboSpan" id="kobo.756.1">Choosing the workflow of using the library within a framework makes it a powerful combination; this way, it is possible to gain the benefits of both of </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">these tools.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.758.1">Framework organization showcase</span></p>
<p class="callout"><span class="koboSpan" id="kobo.759.1">You can try out the f</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.760.1">ramework organization examples from this chapter in the book repository. </span><span class="koboSpan" id="kobo.760.2">Access the examples by cloning the repository from </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.761.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.762.1">. </span><span class="koboSpan" id="kobo.762.2">Then use your terminal to change directories into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">framework-organization</span></strong><span class="koboSpan" id="kobo.764.1"> directory of the repository and run </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">npm install</span></strong><span class="koboSpan" id="kobo.766.1"> followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">npm start</span></strong><span class="koboSpan" id="kobo.768.1">. </span><span class="koboSpan" id="kobo.768.2">Follow the guidance in the terminal and keep an eye out for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">README.md</span></strong><span class="koboSpan" id="kobo.770.1"> files in the directories for </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">extra information.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.772.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.773.1">We have looked at abstractions combined with clever API design, which together form the key to building successful frameworks. </span><span class="koboSpan" id="kobo.773.2">We have also expanded our knowledge of common framework interfaces that provide value to developers and make the application development process much more efficient and approachable. </span><span class="koboSpan" id="kobo.773.3">Understanding how modules, libraries, and frameworks are used helps us be better system architects. </span><span class="koboSpan" id="kobo.773.4">In addition, the ability to use the debugger to quickly explore how all these pieces come together in existing frameworks empowers us to be much more </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">efficient developers.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">Now that we are more familiar with various organization patterns, we can dive deeper into the specific techniques that help us architect new systems. </span><span class="koboSpan" id="kobo.775.2">In the next chapter, we are going to look at the existing and common patterns that combine the building blocks that we have learned into a </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">cohesive system.</span></span></p>
</div>
</body></html>