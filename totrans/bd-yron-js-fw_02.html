<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor030"/>2</h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Framework Organization</h1>
<p>The existing JavaScript frameworks have many technical and structural similarities that are useful to learn as part of becoming experts in framework development. In this chapter, framework organization refers to the way of composing a set of abstractions and building blocks, thus creating a collection of usable interfaces that can be utilized in application code.</p>
<p>We are going to learn about the following organizational topics that enable framework development and use:</p>
<ul>
<li>Learning about abstractions</li>
<li>Building blocks of abstractions in JavaScript</li>
<li>Framework building blocks</li>
<li>Differentiating modules, libraries, and frameworks</li>
</ul>
<p>Understanding the core building blocks and aspects of framework development will help us craft our own framework and have the domain knowledge to use other frameworks to their maximum potential. The expectations from the users or stakeholders of a software framework are to have clear instructions with familiar application concepts, reduced complexity, and a well-defined code base. Let us explore how framework organization can help us satisfy those expectations.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Technical requirements</h1>
<p>Similar to the previous chapter, we will be using the book’s repository as an extension to this chapter. You can find it at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. For the code from the repository, you can use any environment that supports a terminal and runs Node.js, such as Windows, macOS, and most varieties of Linux.</p>
<p>This chapter includes examples from open source frameworks – to save space, the unimportant details are omitted with the <code>// ...</code> comment.  You will need familiarity with reading JavaScript code, but don’t worry if you don’t understand the whole code block. As part of reading the code, be sure to follow the links next to those examples to see the full implementation with all the code details. The <code>chapter2/README.md</code> file lists the available code resources of the chapter.</p>
<p>In this chapter, it is suggested to try out debugging to further our expertise in framework structures. The easiest way to explore that on your computer would be by downloading the latest version of Visual Studio Code from <a href="http://code.visualstudio.com">code.visualstudio.com</a>.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Learning about abstractions</h1>
<p>Let’s dive into the first <a id="_idIndexMarker146"/>aspect of framework organization – the fundamental concept of <strong class="bold">abstractions</strong>. One of the main conveniences of software development frameworks in web development or other fields is to provide developers with high-quality opinionated abstractions. This means taking a task that can span multiple lines of code, riddled with implementation gotchas, and creating a simple interface around it. It also means coming up with an intelligent way of structuring independent interfaces into a familiar, extensible pattern that is easily usable.</p>
<p>This concept of abstracting away the complexity and generalization of objects helps us define the building blocks that could be used for multiple purposes in our frameworks. Each abstracted object can be initialized with a custom set of properties and be utilized in many shapes when needed. Having this benefit of simplification and generalization in frameworks is what allows developers to focus on the business logic of the programs. Precisely these abstraction concepts benefit developers by eliminating complexity, repetition, and the challenges of learning new systems. Through abstractions, developers do not have to use or even learn the low-level components of the systems they build for.</p>
<p class="callout-heading">Abstractions in computer science</p>
<p class="callout">In general, the concept<a id="_idIndexMarker147"/> of abstractions, a simplified representation of some complex mechanism, is essential in software development. This concept is taught early in programming courses and can be implemented in the high-level and low-level interfaces of large and small programs. Software abstractions structure many parts of these programs and dictate the program’s control flow. Data types and structures that define how the data is represented can be considered abstractions on top of lower-level object entities.</p>
<p class="callout">Some programming languages offer direct syntax to write abstract classes and interfaces. TypeScript offers this feature as part of its extensions to JavaScript. This allows developers to declare <em class="italic">abstract</em> classes, methods, and fields. You can find some excellent examples at <a href="http://www.typescriptlang.org/docs/handbook/2/classes.html">www.typescriptlang.org/docs/handbook/2/classes.html</a> for further reading and <a id="_idIndexMarker148"/>prototyping.</p>
<p>If we look at the process of developing websites with bare CSS, HTML, and JavaScript technologies, we can already spot many pre-defined abstractions to make that process more easily accessible and simplified. For instance, HTML, with its elements combined with attributes, can quickly define hyperlinks and embed media with just a few lines of marked-up tags. The styling of those elements with CSS is defined by a set of styling rules targeting particular element nodes. We can see examples of web API abstractions in the <strong class="bold">Document Object Model API</strong>, an<a id="_idIndexMarker149"/> abstraction on top of a complex tree of nested nodes defining<a id="_idIndexMarker150"/> a document structure. These frontend technologies provide a way for user interactions inside a web browser, which generalizes and removes the complexity of interacting with a web application.</p>
<p>We can see a simplified pyramid of abstractions here, starting from application code that developers write on top and rules of basic logic at the lowest level:</p>
<div><div><img alt="Figure 2.1: Abstraction pyramid from higher- to lower-level structures" src="img/Figure_2.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Abstraction pyramid from higher- to lower-level structures</p>
<p>This finally brings us to JavaScript, as a high-level programming language that already abstracts away complexity in many ways, such as memory management, interaction with the browser, and general object management. In fact, some abstractions that compile to JavaScript focus on abstracting away even the higher-level components. Toolkits such as GWT and programming languages such as Elm, C#, and Dart approach this higher-level abstraction process by compiling to CSS, HTML, and JavaScript. The language extensions for ECMAScript, such as TypeScript, hold closer to JavaScript in terms of syntax, abstract away the common pitfalls in how we write JavaScript programs, and improve the overall developer experience with the addition of a compilation step.</p>
<p>In <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we looked at several frameworks that use TypeScript, rely on another framework, or both to create a framework of a higher abstraction level. For example, Nuxt.js is a Vue.js framework, and it relies on TypeScript. In such cases, frameworks require developers to use these language extensions and their own self-defined abstractions to build the applications. It is interesting to ponder how deep the levels of abstractions could be nested when we are developing for the web platform and within the JavaScript ecosystem. On the frontend, we have the web browser, which manages the network request/response networking, draws the layout, enables interactivity, and so much more. The backend application services are working on top of the process and operating system infrastructure within the cloud server instances. The levels of abstraction keep growing as we zoom out to electricity flowing through wires, which delivers the <a id="_idIndexMarker151"/>required bits for our application code.</p>
<p>Now that we are more familiar with abstractions and why they are used, we shall examine the downsides of this core pattern.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Downsides of abstractions</h2>
<p>We have examined the<a id="_idIndexMarker152"/> benefits of abstractions, but there are some downsides to consider when utilizing or implementing abstractions. These factors are also true for frameworks and heavily affect framework development. Let’s discuss some of the ways abstractions can lead you down the wrong path:</p>
<ul>
<li>Abstractions may be incomplete – covering all the potential use cases of an underlying technology with an abstraction could be difficult. For instance, if you have a web application framework, this could usually be a case where a niche feature to output HTML in a certain way could not be supported. The niche requirements could include rendering different types of components, such as SVG animations or direct DOM manipulations. Frameworks offer escape hatches to avoid these issues, but there could be other cases where we have to rely on the knowledge of lower-level components, avoiding the defined abstractions. At the same time, an abstraction may falsely represent the low-level system, which could lead to confusion or false use of the underlying concepts. For instance, if a cryptographic library wrongly uses the primitives, even with the correct outcomes, it could potentially introduce bugs.</li>
<li>Abstractions introduce an extra layer of code between you and the lower-level system, possibly affecting performance. In the case of frontend development, this means more code to transfer over the wire – additional function calls and layers of indirection. In the backend scenarios, server instances use more process memory. The performance may also be affected by the framework’s choice of algorithms. These days, performance is taken seriously by framework authors and users, and regular comparisons and benchmarks help deal with these drawbacks.</li>
<li>Some of the different framework abstractions may not provide the right interfaces or enough control for the users, which could limit the system’s potential. It could be<a id="_idIndexMarker153"/> as simple as not supporting all the underlying methods of the lower-level interface. This issue can also happen if a chosen abstraction is used for something other than what it was designed for. This can also be a problem if the framework was designed before a certain technology was introduced. For <a id="_idIndexMarker154"/>instance, with <strong class="bold">WebAssembly</strong> support in certain frameworks, loading the WASM modules is not possible in some cases due to loading limitations or has to be done with external components. Introducing and using WebAssembly in an already established project with a lacking framework would be an anti-pattern.</li>
</ul>
<p>Specifically, patterns and abstraction ideas change quickly in the JavaScript ecosystem. New tools and solutions come into existence that abstract how we manage frontend interactions and build backend services. This means, as project owners, we have to adjust either to the changing platform or our existing abstractions become outdated. This could lead to a lack of support for some functionalities or just general code breakage. In many circumstances, this happens when some web APIs change or evolve as the web platform introduces new features.</p>
<ul>
<li>Another downside of abstractions is the scenario where a developer may know how to create applications with a certain framework but knows nothing about the internals of the underlying technology. The hidden-away complexity can lead to difficulty in troubleshooting problems and in tracking down errors in the core of the application. Not understanding the technology behind the scenes also limits the developer in their ability to optimize features and take advantage of advanced features.</li>
<li>We may also face so-called <em class="italic">leaky abstractions</em>. This is where the attempt to conceal some system complexity fully is not successful. This usually results in the details of the underlying system being revealed to the users of the abstraction. This phenomenon can lead to more complexity in the code with its own problems. The problem becomes evident when developers have to dig into the implementation details of the low-level system and try their best to figure out how the abstraction maps to the underlying system.</li>
<li>Highly opinionated abstractions, in frameworks and in general, may cause issues when introducing additional layers of sophistication by imposing specific design choices that the developer may disagree with but is unable to change. These can limit the reusability <a id="_idIndexMarker155"/>and flexibility of the application code. If we look at Next.js, it provides highly opinionated solutions for several of its features. For example, if you are planning to add API routes to build an API in the Next.js project, these must be mapped to an <code>/api/</code> endpoint. To learn more about that, check out <a href="http://nextjs.org/docs/api-routes/introduction">nextjs.org/docs/api-routes/introduction</a>. This is a simple example, but hopefully it illustrates this drawback well.</li>
</ul>
<p>No matter where you introduce the use of an abstraction, it does add an extra layer of complexity and indirectness to what we are trying to interface with. When we add abstractions through various means, this makes our projects dependent on them. This dependency may create certain complications. With an external abstraction, we have to accept the risks and trade-offs that come with using it.</p>
<p>In the next section, we are going to look at the popular abstracted building blocks, which are often used in framework development and are exposed as public interfaces of frameworks. We will dive into the frontend browser APIs and the backend runtime modules to better understand what frameworks utilize to build their own abstractions. This is a useful exercise because it helps us figure out how these frameworks function and what techniques<a id="_idIndexMarker156"/> they use to combine different tools together. These exercises in tracing the framework organization are valuable to becoming a domain expert in frameworks and understanding the underlying technology behind them.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Building blocks of abstractions in JavaScript</h1>
<p>In this section, we<a id="_idIndexMarker157"/> will discuss some detailed<a id="_idIndexMarker158"/> abstraction examples in JavaScript, as well as web APIs, and features that are used as the building blocks and foundational components of abstractions in frameworks. Framework and browser developers put a lot of thought and hard work into defining these abstractions, which allow developers to be really crafty, produce well-organized code, and build great products.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Frontend framework abstractions</h2>
<p>With these three <a id="_idIndexMarker159"/>technologies – HTML, CSS, and JavaScript – that enable website development, we <a id="_idIndexMarker160"/>get plenty of building blocks that already abstract away the challenges of publishing something on the web. However, we do not get a particular, well-structured, opinionated way to build complex web application projects. This is where the frontend frameworks primarily fill the void that is lacking in the core technologies provided by the web. The frontend frameworks create abstractions in these two cases:</p>
<ul>
<li>On top of existing<a id="_idIndexMarker161"/> web APIs, which are built into the web browser or a JavaScript runtime.</li>
<li>When new abstractions are built from scratch based on the framework’s internals and opinionated definitions. The innovative and unique approach to these abstractions is<a id="_idIndexMarker162"/> what makes a particular framework desirable and liked among developers.</li>
</ul>
<p>The following <a id="_idIndexMarker163"/>web APIs provided by the browser engines are often abstracted by frontend frameworks:</p>
<ul>
<li><strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) – This allows manipulation of the web page’s structure. The<a id="_idIndexMarker164"/> DOM <a id="_idIndexMarker165"/>represents a tree where the nodes constrain the objects. The DOM API provides access and the ability to modify this logical tree. The user interface frameworks primarily need this to display the rendered views and handle DOM interactions and events. Even the frameworks that use a virtual DOM need to attach their structures to the real document to make it visible on the page.</li>
<li><code>document</code> property. The browser also provides complex APIs, such as the WebAssembly API, which lets applications include binary-code modules. The frameworks usually have a loader for these low-level modules as part of their loader workflow.</li>
<li><code>document.body.style.color = 'pink';</code>. This object model also offers several method calls such as <code>getComputedStyle();</code> to fetch information about the object’s style.</li>
<li><strong class="bold">Network APIs</strong> – These APIs have the ability to make asynchronous network requests using the<a id="_idIndexMarker170"/> Fetch API or <a id="_idIndexMarker171"/>the XMLHttpRequest API. Frameworks utilize these for basic networking operations, including structuring complex requests using GraphQL. The networking APIs also <a id="_idIndexMarker172"/>offer <strong class="bold">WebSocket</strong> functionality. These APIs provide full-duplex (data can be transmitted and received simultaneously) communications with less overhead than usual networking calls, enabling applications with real-time updates and communication. The WebSocket API is simple enough that it can be used directly in the applications or with the inclusion of an extension package for a particular framework. <strong class="bold">Socket.io</strong> builds<a id="_idIndexMarker173"/> on top of WebSocket APIs and offers a complete low-latency solution that can coexist with the framework code. Finally, <strong class="bold">WebRTC</strong> also fits<a id="_idIndexMarker174"/> into the category of networking APIs, and it enables the capturing and streaming of audio and video content in the browser. Similar to WebSockets, the WebRTC framework integration is usually<a id="_idIndexMarker175"/> included with an external library because it is quite a subtle feature.</li>
<li><strong class="bold">Storage APIs</strong> – These APIs have the ability to store data for web application and caching purposes. These<a id="_idIndexMarker176"/> APIs are<a id="_idIndexMarker177"/> often utilized to store data in the local and session storages. They also write to browser cookies and databases, such as <strong class="bold">IndexedDB</strong>. For <a id="_idIndexMarker178"/>instance, Angular applications can include a dependency that provides a cookie service and makes it easier to read and write cookie information.</li>
<li><strong class="bold">Background services</strong> – These<a id="_idIndexMarker179"/> include<a id="_idIndexMarker180"/> a slew of services that enable background synchronization of data, notifications, push messaging, and more. Web workers generally provide a way to run background-independent scripts and make use of multiple CPU cores.</li>
<li><strong class="bold">Graphics APIs</strong> – These<a id="_idIndexMarker181"/> APIs grant the ability to<a id="_idIndexMarker182"/> render high-performance 3D and vector graphics. These<a id="_idIndexMarker183"/> include the <strong class="bold">WebGL</strong> APIs and <strong class="bold">SVG</strong> elements. The <a id="_idIndexMarker184"/>3D graphics libraries utilize the <em class="italic">canvas</em> element for rendering and can utilize the graphics hardware. For applications built with Vue.js, there is an additional component library called VueGL that makes it easier to create WebGL-based components. In terms of SVG, JSX in React is able to directly parse SVG syntax, as long as the SVG properties are<a id="_idIndexMarker185"/> converted to the camel-case JavaScript syntax.</li>
</ul>
<p>A useful, in-depth list of web APIs that frameworks can potentially utilize can be found at <a href="http://developer.mozilla.org/docs/Web/API">developer.mozilla.org/docs/Web/API</a>.</p>
<p>Let’s now take <a id="_idIndexMarker186"/>a look at a real-world frontend example with Nuxt.js.</p>
<h3>Real-world examples</h3>
<p>Nuxt.js uses Vue as a <a id="_idIndexMarker187"/>backbone for its frontend components. As shown in <em class="italic">Figure 2</em><em class="italic">.2</em>, the Nuxt.js framework has the <code>NuxtLink</code> built-in component for creating links, which can be used in application code, and utilizes several modules from Vue, such as the <code>vue-router</code> and component-building functions such as <code>defineComponent</code>:</p>
<div><div><img alt="Figure 2.2: Nuxt.js and Vue framework abstraction" src="img/Figure_2.2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Nuxt.js and Vue framework abstraction</p>
<p>We can follow the usage of this abstraction (<em class="italic">Figure 2</em><em class="italic">.2</em>) in detail from an <code>example.vue</code> page in application code:</p>
<pre class="source-code">
pages/index.vue
&lt;template&gt;
  &lt;NuxtLink to="/"&gt;Index page&lt;/NuxtLink&gt;
  &lt;NuxtLink href="https://www.packtpub.com/" target="_blank""&gt;Packt&lt;/NuxtLink&gt;
&lt;/template&gt;</pre>
<p>To run this particular code example on your computer, navigate to the <code>chapter2/nuxt-js-application</code> directory and run <code>npm install &amp;&amp; npm run dev</code>. Refer to the included <code>chapter2/README.md</code> documentation for additional details. Once the application is ready to run locally, you should see the URL that you can open in your browser in the terminal. Here’s an example of the successful output:</p>
<pre class="source-code">
&gt; npm run dev
  &gt; Local:    http://localhost:3000/
  &gt; Network:  http://192.168.1.206:3000/</pre>
<p>The auto-import feature of the framework allows the direct use of the component to create the two links in the template file. This built-in component is defined in the source of the Nuxt framework at <a href="http://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts">github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/components/nuxt-link.ts</a>.</p>
<p>Let us take a<a id="_idIndexMarker188"/> moment to understand the <code>nuxt-link</code> component code, following along with the source from the framework itself. The code behind this particular component extends the routing behavior from Vue.js. It defines the typed TypeScript interfaces, such as <code>NuxtLinkOptions</code> and <code>NuxtLinkProps</code>, to accept particular styling attributes and routing options. The <code>defineNuxtLink</code> function returns the component with the customized routing behavior. Helper functions, such as <code>checkPropConflicts</code> and <code>resolveTrailingSlashBehavior</code>, address specific routing use cases. The <code>setup()</code> function call uses the Vue 3 Composition API to enable reactive properties of the component and attach component lifecycle hooks to versions of <code>NuxtLink</code> in applications. More details on this API can be found in Vue.js’ documentation – <a href="http://vuejs.org/guide/extras/composition-api-faq.html">vuejs.org/guide/extras/composition-api-faq.html</a>. The important parts are shown in a condensed form here:</p>
<pre class="source-code">
export type NuxtLinkProps = {
 to?: string | RouteLocationRaw
 href?: string | RouteLocationRaw
 target?: '_blank' | '_parent' | '_self' | '_top' | (
  string &amp; {}) | null
 // ...
}
export function defineNuxtLink (options: NuxtLinkOptions) {
 const componentName = options.componentName || 'NuxtLink'
 return defineComponent({...})
}</pre>
<p>In the preceding component code, we see the final return statement of <code>defineComponent</code>. This generates the anchor <code>&lt;a&gt;</code> element that we ultimately see in the final source of the HTML structure in the web application. It is produced by the internal Vue.js function call:</p>
<pre class="source-code">
return h('a', { ref: el, href, rel, target})</pre>
<p>From the <code>defineNuxtLink</code> function, it is also evident that it is possible to modify some parts of the component. For example, we can define a component with a custom name using the <code>componentName</code> parameter.</p>
<p>From <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we’ve<a id="_idIndexMarker189"/> seen that JavaScript has much to offer for full stack frameworks. In the next section, we are going to look at the APIs that we can utilize as part of the backend environment.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Backend runtime abstractions</h2>
<p>Although there are many <a id="_idIndexMarker190"/>frontend <a id="_idIndexMarker191"/>APIs to choose from, we are still bound by what the web browser supports. This is a lesser issue when we write backend services, as there are still many APIs that we can use, and we can even write our own extensions or integrate with external systems for custom use cases. Let’s take a look at important APIs that we can use as part of framework development.</p>
<p>In this section, we will look at both <strong class="bold">Node.js</strong> and <strong class="bold">Deno</strong>, as they are two runtimes that offer similar features. These runtimes need to handle server creation, file and process management, module packaging, and more. The following are some of the essential APIs that are used by the backend frameworks:</p>
<ul>
<li><strong class="bold">Filesystem APIs</strong> – This has <a id="_idIndexMarker192"/>the ability to read and write files and other file system entities. Frameworks use this heavily while storing data, loading existing files, and serving static content. These APIs also include file streaming and asynchronous features.</li>
<li><strong class="bold">Networking</strong> – These are the APIs to start new server processes and accept requests. Includes handling of HTTP requests and other request formats.</li>
<li><strong class="bold">Modules and packaging</strong> – These are the conventions of how modules and packages can be loaded.</li>
<li><strong class="bold">Operating system APIs</strong> – These are the APIs to fetch information from the operating system that is running the process. This includes useful data about memory consumption and useful operating system directories.</li>
<li><strong class="bold">Process handling</strong> – These APIs allow for manipulating and gathering details of the currently running process. These also enable sub-process creation and handling of multi-process communication.</li>
<li><strong class="bold">Native modules</strong> – The native module APIs allow users to call out to libraries written in other native languages, such as C/C++, Rust, and others. In some cases, they <a id="_idIndexMarker193"/>use the <strong class="bold">Foreign Function Interface </strong>(<strong class="bold">FFI</strong>). WebAssembly is also part of this native module support.</li>
<li><strong class="bold">Worker APIs</strong> – Allows the spawning of additional worker threads to schedule heavy server work to happen outside of the main process. For instance, the Deno runtime <a id="_idIndexMarker194"/>supports the <strong class="bold">Web Worker API</strong> to provide these features, while Node.js<a id="_idIndexMarker195"/> uses its <strong class="bold">Worker </strong><strong class="bold">Threads</strong> module.</li>
<li><strong class="bold">Console and debugging</strong> – This set of internal APIs allows for recording process logs. The debugging APIs make developing and finding issues in the running code easier. Paired with an editor that supports debugging operations, it can pause the debugger <a id="_idIndexMarker196"/>when the framework request handler is processing a request.</li>
</ul>
<p>These are some <a id="_idIndexMarker197"/>of the APIs that backend frameworks can use as the foundation for their projects. For instance, the hapi.js framework is able to combine some of these APIs to create its <code>Server</code>, <code>Route</code>, <code>Request</code>, and <code>Plugin</code> modules. For example, its <code>Core</code> (<a href="http://hapi/lib/core.js">hapi/lib/core.js</a>) module makes use of the operating system, networking, and module-handling APIs.</p>
<p>Next, we can take a look<a id="_idIndexMarker198"/> at a detailed example of combinations of abstractions and runtime APIs in<a id="_idIndexMarker199"/> Nest.js, a framework that is familiar to us from <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>
<h3>Backend framework abstractions</h3>
<p>The Nest.js framework <a id="_idIndexMarker200"/>supports the ability to provide any HTTP framework as long as there is an adapter defined to work with it. The existing adapters that are built right into Nest.js are <code>platform-express</code> and <code>platform-fastify</code>. The default behavior of the HTTP adapter abstraction is transparent to the developer as it uses the <code>express</code> module by default.</p>
<p>In <em class="italic">Figure 2</em><em class="italic">.3</em>, we can see the combination of all the components. The application code is powered by the framework that utilizes both the framework abstractions and the Node.js API:</p>
<div><div><img alt="Figure 2.3: Nest.js framework abstractions" src="img/Figure_2.3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Nest.js framework abstractions</p>
<p>As shown in <em class="italic">Figure 2</em><em class="italic">.3</em>, the <code>main.ts</code> entry point file in Nest.js starts the server and listens for incoming requests:</p>
<pre class="source-code">
main.ts
const port = 5300;
const app = await NestFactory.create(AppModule);
await app.listen(port);</pre>
<p><code>express-adapter</code>, which <a id="_idIndexMarker201"/>extends from <code>AbstractHttpAdapter</code>, defines the set of methods required for the HTTP server, including the <code>.</code><code>listen</code> method:</p>
<pre class="source-code">
import * as express from 'express';
import * as http from 'http';
import * as https from 'https';
// ...
export class ExpressAdapter extends AbstractHttpAdapter {
  // ...
  public listen(port: string | number, callback?: () =&gt;
    void): Server;
  public listen(
    port: string | number,
    hostname: string,
    callback?: () =&gt; void,
  ): Server;
  public listen(port: any, ...args: any[]): Server {
    return this.httpServer.listen(port, ...args);
  }
  // ...
}</pre>
<p>The adapter code above utilizes the <code>express</code> framework and the internal <code>http</code> APIs. Ultimately, this results in a class that exposes a method to set up an HTTP server. Even though <code>express</code> provides the routing and HTTP helpers, it does not start the server by itself. Inside <code>express-adapter</code>, there is a direct call to Node.js APIs:</p>
<pre class="source-code">
initHttpServer(options) {
  const isHttpsEnabled = options &amp;&amp; options.httpsOptions;
  if (isHttpsEnabled) {
  this.httpServer = https.createServer
    (options.httpsOptions, this.getInstance());
  } else {
  this.httpServer = http.createServer(this.getInstance());
  }
   // ...
}</pre>
<p>The direct call in the preceding code block figures out the type of server to start, <em class="italic">HTTP</em> or <em class="italic">HTTPS</em>. It also accepts a variety of <code>httpOptions</code> values. This pattern is similar in other frameworks. For instance, in AdonisJS, the framework authors define the <code>HttpServer</code> class (<a href="http://github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts">github.com/adonisjs/core/blob/master/src/Ignitor/HttpServer/index.ts</a>) that creates an HTTP server and utilizes the <code>createHttpServer</code> utility function to call out to the runtime APIs of Node.js.</p>
<p>As we dig in further to understand how existing frameworks are structured and how their abstractions work, it is important to have a way of traversing the code of these nested <a id="_idIndexMarker202"/>abstractions. In the next section, we will cover the technique of debugging, which can help us uncover the hidden interfaces within the frameworks.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>About debugging</h2>
<p>Debugging<a id="_idIndexMarker203"/> plays an<a id="_idIndexMarker204"/> important role in software development. It helps us identify and resolve issues quickly. As part of the framework learning process, it also helps us understand how these frameworks work internally. By stepping through the breakpoints of the program and digging deep into the call stack, we can understand the inner workings of the internal modules. It also helps us navigate through multiple levels of abstractions.</p>
<p>Node.js’ debugger integration provides a way for us to debug our programs and frameworks. It is a good habit to try it out on your own to get a better understanding of how the framework functions. For example, to debug a Nest.js application, we can utilize the Visual Studio Code debugger:</p>
<ol>
<li>Open up the <code>nest-js-application</code> project in the <code>framework-organization</code> directory of the book’s GitHub repository.</li>
<li>Run <code>npm install</code> to get the project’s dependencies.</li>
<li>Set a code execution breakpoint in the <code>app.service.ts</code> file of the application; refer to the screenshot in <em class="italic">Figure </em><em class="italic">2</em><em class="italic">.5</em>. To set the breakpoint, hit the empty space to the left of the line number until you see a red dot. Once this red dot appears, that will be your breakpoint.</li>
<li>In Visual Studio Code, browse to the <code>package.json</code> file, and press the <code>scripts</code> section. See an example of this in <em class="italic">Figure 2</em><em class="italic">.4</em>:</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 2.4: Debug button in package.json" src="img/Figure_2.4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: Debug button in package.json</p>
<ol>
<li value="5">After pressing the <code>start:dev</code> option, which should start the application, observable in the <code>nest</code> command is not found, that means you need to install the dependencies for this project using <code>npm install</code>.</li>
<li>With the application running in debug mode and using the <code>start:dev</code> script, open the address at <code>http://127.0.0.1:3000</code> in your browser. This should now pause on the extract line of your breakpoint.</li>
</ol>
<p>If you hit a breakpoint properly in the editor, that means you successfully attached the debugger to the application. You can now use the call stack pane on the left (as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>) to navigate around the running process and browse through the Nest.js modules:</p>
<div><div><img alt="Figure 2.5: Debugging a Nest.js application" src="img/Figure_2.5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Debugging a Nest.js application</p>
<p>This technique is a quick way to get a view behind the scenes of a framework. It enables developers to quickly get a sense of how the framework functions and makes it easier to understand the nested abstractions. To get more from it, you can find an in-depth explanation of<a id="_idIndexMarker207"/> the<a id="_idIndexMarker208"/> Visual Studio Code debugger at <a href="http://code.visualstudio.com/docs/editor/debugging">code.visualstudio.com/docs/editor/debugging</a>.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Framework building blocks</h1>
<p>Just like most programming<a id="_idIndexMarker209"/> languages, JavaScript, and its extensions such as TypeScript, have the fundamental features of working with numbers, strings, Booleans, conditional logic statements, and much more. The more advanced features are built on top of those fundamentals. The frameworks utilize existing interfaces, such as events and modules. However, they also create their own build blocks, by defining interfaces to create components, routers, and others.</p>
<p>In this section, we are going to examine both existing interfaces and custom ones. We are going to look at some of the common interfaces, which can be combined to make a framework. These are the abstracted entities that solve particular problems in application development and are beneficial to their users.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Events</h2>
<p>Event binding and events <a id="_idIndexMarker210"/>are everywhere in JavaScript applications. They enable frontend user interfaces and interactivity through buttons, forms, pointer movement, keyboard keys, scrolling, and more. The concept of event binding is something that every framework handles with different syntax definitions as follows:</p>
<pre class="source-code">
// Vanilla JavaScript
someInput.addEventListener('keyup', keyDownHandler)
// Vanilla HTML
&lt;input type="text" onkeyup="keyDownHandler()" /&gt;
// React
&lt;input type="text" value={answer} onKeyPress=
  {keyDownHandler}/&gt;
// Angular key down combination of SHIFT + ESC keys
&lt;input (keyup.shift.esc)="keyDownHandler($event)" /&gt;
// Vue key down
&lt;input @keyup.shift.esc="keyDownHandler" /&gt;</pre>
<p>Most of the time, the event handling is very similar to original DOM events, but with a modified syntax to fit the framework abstractions better. Frameworks further enable event handling by providing more complex event management components. For example, Angular has the concept of <code>HostListener</code> (<a href="http://angular.io/api/core/HostListener">angular.io/api/core/HostListener</a>) to register events within its components.</p>
<p>On the server side, Node.js is heavily event-based because of its asynchronous, event-driven architecture and the frameworks take advantage of that. For example, hapi.js maintains its own event emitter package called <code>@hapi/podium</code>, which allows the developers to register custom application events.</p>
<p>Another example of the event handling pattern would be how the <code>change</code> and <code>navigation</code> events to report the latest values:</p>
<pre class="source-code">
board.on("ready", function() {
  const gps = new five.GPS({
    pins: {rx: 11, tx: 10}
  });
  gps.on("change", function() {
    console.log(this.altitude);
  });
  gps.on("navigation", function() {
    console.log(this.speed);
  });
});</pre>
<p>The use of events is an important building block, which allows us to subscribe to user interaction and listen to <a id="_idIndexMarker212"/>the changes or progress of some operation. As we are set on developing our own framework, it needs to provide a way to interact with events and abstract certain complexities around them.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Components</h2>
<p>Many frameworks <a id="_idIndexMarker213"/>provide an abstraction to create reusable components to organize the project. Depending on how the application is planned out, components can help split any type of application into reusable and independent pieces of code. These code parts can also be nested within each other. Depending on the required business logic, developers can define custom components, use the pre-built ones, or import a library of components that are designed for specific use. Once many components are nested and situated together, it is common to have some interaction between these objects. The components utilize data properties to render the information to the user from the current state, and in many cases, they need some properties from the parent components. For frameworks that use React or Vue, this means writing communication patterns that enable child-to-parent component communication and the other way around. This communication process can get complicated, which is why these frameworks use a unidirectional or a one-way data flow where the data updates flow from parent to child components. Instead of synchronizing the same state between nested components, it is advised to store the state in the most common ancestor component in the chain.</p>
<p>If we have a complex application, this means that we will probably end up with a lot of components, nested multiple levels deep. This is <a id="_idIndexMarker214"/>where <strong class="bold">component composition</strong> can help. Component composition is a pattern that allows for minimal code duplication, and performance improvements.</p>
<p>In the following figure, we have an illustrative example of how composition can affect and reorganize a set of nested components within an application. The component organization pattern is very<a id="_idIndexMarker215"/> familiar to developers, so it would be a good choice to use or create a framework utilizing this pattern:</p>
<div><div><img alt="Figure ﻿2.6: Nested versus composed components" src="img/Figure_2.6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: Nested versus composed components</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Lifecycle methods</h2>
<p>Lifecycle methods or<a id="_idIndexMarker216"/> events are often managed by the framework, providing the ability to execute code at particular points. These methods can be used to execute custom logic at different stages of components and other parts of the system, which provides flexibility to the framework interfaces. These lifecycle methods can be used to attach or detach additional logging, utility functions, and more during the component execution. Lifecycle sequence, which means the order of how these events occur, must be well documented and described in the framework. This is done mostly due to the fact that the lifecycle methods can have a particular naming convention and have a complex runtime hierarchy.</p>
<p>In Nest.js, the server framework provides lifecycle hooks to its module system. Some examples of that are <code>onApplicationBootstrap()</code>, which is called when all modules in the application have been initialized, and <code>onModuleInit()</code>, which is called when the dependencies of a module have been resolved. Using the TypeScript interfaces in Nest.js, we can inject code into the <code>onApplicationShutdown</code> lifecycle event as all connections to the server close down, which can be defined as follows:</p>
<pre class="source-code">
@Injectable()
class SomeService implements OnApplicationShutdown {
  onApplicationShutdown(processSignal: string) {
    // ...
  }
}</pre>
<p>In Vue.js, given that the framework deals with rendering components, the events available cover the whole lifetime of the component. For instance, it has <code>beforeCreate</code>, <code>created</code> events as the component initializes its state, and <code>beforeMount</code>, <code>mounted</code> events as the component gets mounted to the DOM tree. You can find a <a id="_idIndexMarker217"/>great lifecycle diagram of Vue.js at <a href="http://vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram">vuejs.org/guide/essentials/lifecycle.html#lifecycle-diagram</a>.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Router</h2>
<p>Both frontend and backend<a id="_idIndexMarker218"/> frameworks usually require some form of a router that navigates to different parts of the application. The router mechanism on the frontend follows the navigational pattern of web pages, following the browser’s URL patterns. On the frontend, the router is essential to transition between states or navigate to internal or external pages. Besides providing the routing <em class="italic">tree</em> structure, the router is also responsible for interfaces that allow components to invoke the routing behaviors – we saw an example of this via <code>NuxtLink</code> in the <em class="italic">Real-world Examples</em> section of this chapter.</p>
<p>The <strong class="bold">react-router</strong> (<a href="http://reactrouter.com/main/start/overview">reactrouter.com/main/start/overview</a>) project is a good example of everything you <a id="_idIndexMarker219"/>need from a router component. It makes it possible to simply define the routes within a component as follows:</p>
<pre class="source-code">
&lt;Routes&gt;
  &lt;Route path="/" element={&lt;Layout /&gt;}&gt;
    &lt;Route index element={&lt;Login /&gt;} /&gt;
    &lt;Route path="register" element={&lt;Register /&gt;} /&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;</pre>
<p>The backend server frameworks use a server router to handle requests coming to API endpoints. Normally, the router interface takes different forms of endpoint URL structures and maps those into functions that process the route. Some good examples of an unopinionated router can be found in Express.js (<a href="http://expressjs.com/guide/routing.html">expressjs.com/guide/routing.html</a>).</p>
<p>From the following code example, we see the relationship between the endpoint path and the function that is able to process the request and a text response:</p>
<pre class="source-code">
app.get('/framework-organization', (req, res) =&gt; {
  res.send('Learn about framework organization!')
})</pre>
<p>From <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we have seen examples of file-based routing, which further simplifies the routing mechanisms <a id="_idIndexMarker220"/>by just looking at the files in the application, and dynamically creating routes based on those files.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Template engine</h2>
<p>Another essential building <a id="_idIndexMarker221"/>block is the template engine. This engine combines the static parts of a marked-up document with the data from the application. Templating makes it possible to render views with various forms of data. With frontend frameworks, this usually means rendering the nested component hierarchy. The template engine’s job is to enable data binding and to bind any specified events for the interactive components, such as buttons or input fields.</p>
<p>With a backend framework, templating engines render the whole page or, in some cases, partials, sending them over the wire to the client for initial static rendering. From <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we have seen frameworks, such as Next.js, that are able to render the frontend components on the server side and then attach any JavaScript behaviors to the readily rendered component. By default, in Next.js, the pages are pre-rendered to improve search engine optimization and performance in the browser client. Templating is a vital building block of a framework – this is how developers create the presentation layer and mark up the page structure.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Networking</h2>
<p>Web frameworks <a id="_idIndexMarker222"/>commonly provide several <a id="_idIndexMarker223"/>components as networking abstractions. The ability to use a good networking interface can vastly improve the readability, performance, and error handling of the application. Here are some features that usually come as part of a good networking abstraction:</p>
<ul>
<li><strong class="bold">Session management</strong> – This is the<a id="_idIndexMarker224"/> ability to manage sessions and provide easy access to session information. This is included as part of networking because frontend frameworks usually rely on the backend service to fetch and parse the session information.</li>
<li><strong class="bold">Error handling</strong> – This provides good interfaces to handle all types of possible errors that can happen during the process of making a request to an endpoint.</li>
<li><strong class="bold">Caching</strong> – This is the mechanism that provides a caching layer to improve performance and avoid redundant queries if the data is already fresh enough.</li>
<li><strong class="bold">Security</strong> – Often frameworks come with baked-in security features that follow the best practices. This includes examples such as XSS, CSRF protection, script injection prevention, and input validation.</li>
<li><strong class="bold">Request and response management</strong> – This improves the ability to make requests with the required parameters and parse the responses from external systems.</li>
</ul>
<p>Most of these networking abstractions apply to both frontend and backend systems. In a full stack framework, a combination of these abstractions can vastly improve the workflow and the efficiency of the system that it is supporting.</p>
<p>All these abstractions are implemented in JavaScript, TypeScript, or enabled by the runtime. Their implementation can be provided from within three categories of code structures – as a module, library, or built into a framework. In the next section, we are going to explore these categories of code organization.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Differentiating modules, libraries, and frameworks</h1>
<p>While<a id="_idIndexMarker225"/> working<a id="_idIndexMarker226"/> on <a id="_idIndexMarker227"/>JavaScript<a id="_idIndexMarker228"/> applications, we <a id="_idIndexMarker229"/>rely on <a id="_idIndexMarker230"/>modules, libraries, and, of course, the larger frameworks. These structures can originate from internal and external sources, meaning they are either written by you or your team or are a dependency that is written by someone else. JavaScript, specifically, is in a unique position where modules, libraries, and even frameworks can be used on browser and server environments. For framework developers, it is important to know how to work with these JavaScript structures, because frameworks heavily rely on defining <a id="_idIndexMarker231"/>and <a id="_idIndexMarker232"/>using<a id="_idIndexMarker233"/> modules <a id="_idIndexMarker234"/>and<a id="_idIndexMarker235"/> libraries. These<a id="_idIndexMarker236"/> abstractions and structures allow for better code organization, which we will be discussing in the next subsections.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Modules</h2>
<p>Developers create their <a id="_idIndexMarker237"/>own modules to separate the code into multiple files or logical blocks. In a similar manner, modules can be imported from external sources. The module encapsulation wraps a block of code, providing a way for it to export various data types through strings, functions, and other data types.</p>
<p>The history of how modules are defined and used in JavaScript is complicated; it ventures out to different module patterns and implementations. Even in modern projects, you will find inconsistent approaches to module management. Initially, there was no way to organize modules, so frontend JavaScript modules were wrapped in immediately invoked function expressions or objects. Using functions allows the hosting of all the values inside of it within a lexical scope. Here is a sample:</p>
<pre class="source-code">
let myModule = (function () {
  // ...
  return {
    someProperty: function ()  {
    // ...
    }
  }
})();</pre>
<p>It was evident that the language needed some kind of a modular pattern, and this is where <strong class="bold">CommonJS</strong> and AMD types <a id="_idIndexMarker238"/>of modules were introduced. Defining a CommonJS module is straightforward and can be seen in use in a lot of the Node.js frameworks:</p>
<pre class="source-code">
module.exports = class MyModule {
  constructor(someProperty) {
    this.someProperty = someProperty;
  }
  myMethod() {
    return this.someProperty;
  }
};</pre>
<p>For instance, hapi.js uses <a id="_idIndexMarker239"/>a similar CommonJS module pattern in most of its files, which can be found in the framework repository at <a href="http://github.com/hapijs/hapi/tree/master/lib">github.com/hapijs/hapi/tree/master/lib</a> – a simple example from a list of its modules is <code>lib/compression.js</code> in the <code>lib</code> directory:</p>
<pre class="source-code">
const Zlib = require('zlib');
const Accept = require('@hapi/accept');
exports = module.exports = internals.Compression = class {
   // ...
   accept(request) {
        const header = request.headers['accept-encoding'];
        // ...
   }
};</pre>
<p>This module provides compression functions for many hapi.js use cases. With some of the code omitted, we see the <code>exports</code> keyword, which is used to make methods from this module available in other files.</p>
<p>These days projects may have different types of JavaScript modules that are used as part of their workflow. The more standard ones you will see are CommonJS and <code>module.exports</code> keywords. The ESM system provides <code>import</code> and <code>export</code> keywords to manage the modules. To distinguish the module types, the <code>.cjs</code> and <code>.mjs</code> file extensions are used to be explicit about which module system is used. The normal <code>.js</code> extension can still be used, but then it is up to the module loading system to figure out how to load these files.</p>
<p>Some examples of module types that you may see in the ecosystem are listed here:</p>
<ul>
<li><strong class="bold">Universal Module Definition</strong> (<strong class="bold">UMD</strong>) – This is the <a id="_idIndexMarker241"/>module definition that tries to support all possible module declarations</li>
<li><code>require()</code> and <code>define()</code> functions to manage the module</li>
<li><strong class="bold">Immediately Invoked Function Expression</strong> (<strong class="bold">IIFE</strong>) – These are simplistic modules<a id="_idIndexMarker243"/> encapsulated by a function scope</li>
</ul>
<p>The module systems are slowly getting better in JavaScript, but it is something to watch out for when using various modules in frameworks and choosing the right module system to use. The varying<a id="_idIndexMarker244"/> usage of modules can lead to issues with loading in specific environments or can lead to some features not working as intended.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Libraries</h2>
<p>Libraries are indispensable <a id="_idIndexMarker245"/>in software development nowadays; they play an important role in supporting web development projects of any size. The libraries consist of a collection of useful resources that implement certain specific functionality with a well-defined interface. The focus of libraries is to include the encapsulation of optimized features to solve certain problems. Most libraries try to focus on a specific set of problems that can help their stakeholders. JavaScript has an abundance of open source libraries that developers cannot live without in professional projects. They don’t dictate any specific opinionated control flow, but instead, let the developer make use of them when needed. In a similar fashion to frameworks, the technological availability of the JavaScript runtime allows some of the libraries to be used in both the browser and the backend environments.</p>
<p>Libraries can serve as a<a id="_idIndexMarker246"/> core component used by a framework to solve certain technological challenges. There are many cases where we see frameworks building abstractions<a id="_idIndexMarker247"/> around the following libraries:</p>
<ul>
<li><strong class="bold">lodash</strong> (<a href="http://lodash.com">lodash.com</a>) – This library <a id="_idIndexMarker248"/>provides a large set of utility functions for common tasks</li>
<li><strong class="bold">React</strong> (<a href="http://reactjs.org">reactjs.org</a>) – This is an <a id="_idIndexMarker249"/>extremely popular user interface component rendering library with state management that many of the frontend frameworks mentioned so far are based on</li>
<li><strong class="bold">Axios</strong> (<a href="http://axios-http.com">axios-http.com</a>) – This is a <a id="_idIndexMarker250"/>powerful HTTP client library for frontend and backend JavaScript projects</li>
<li><strong class="bold">Luxon</strong> (<a href="http://moment.github.io/luxon">moment.github.io/luxon</a>) – This is <a id="_idIndexMarker251"/>a library to manipulate date and time in JavaScript, the evolution of a popular library called moment.js</li>
<li><strong class="bold">jQuery</strong> (<a href="http://jquery.com">jquery.com</a>) – This is more than <a id="_idIndexMarker252"/>a decade old – a popular library that simplified DOM traversal and abstracted away cross-browser quirks for CSS, AJAX, and more</li>
<li><strong class="bold">Three.js</strong> (<a href="http://threejs.org">threejs.org</a>) – This is a<a id="_idIndexMarker253"/> JavaScript 3D library that abstracts away the complexities of WebGL and 3D graphics on the web</li>
</ul>
<p>It is a common pattern to build out additional tooling on top of existing libraries to enable applications of various types. For example, in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we saw examples of frameworks building tooling and abstractions around React. If the project allows you to, it is usually a good idea <a id="_idIndexMarker254"/>to utilize a library or learn from existing implementations for a solved problem rather than rebuilding or rewriting the same code. In the next section, we are going to compare choosing a development workflow with a set of libraries in contrast with framework-driven workflows.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Frameworks</h2>
<p>From <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we already know <a id="_idIndexMarker255"/>what JavaScript frameworks do and the benefits they offer. It is also important to understand how much frameworks rely on libraries for their workflows and features, and the differences between them. Both libraries and frameworks manage control flow in the applications. This control flow is the order and structure of how the logic in the application flows. With a library workflow, the existing program will have its own control flow and as part of it the library functions are executed when required. This existing program precisely calls out to the reusable code in the library. This gives full control to the developer to structure the application as they see fit, allowing for more room to fine-tune the application behavior but missing the value and structures that could potentially be gained by using a framework.</p>
<p>With a framework workflow, the framework dictates how the control flow should be structured. In this case, the developer works within the constraints of the framework and follows the often strict guidelines defined by someone else.</p>
<p>A good comparison would be the React library versus a JavaScript framework such as Next.js that depends on the library. The library just consists of functions that execute certain tasks. React contains logic for rendering, creating components, and other methods. But it is Next.js – the framework – that defines the architecture for the application, using the library methods from within to enable its features.</p>
<p>Choosing the workflow of using the library within a framework makes it a powerful combination; this way, it is possible to gain the benefits of both of these tools.</p>
<p class="callout-heading">Framework organization showcase</p>
<p class="callout">You can try out the f<a id="_idIndexMarker256"/>ramework organization examples from this chapter in the book repository. Access the examples by cloning the repository from <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. Then use your terminal to change directories into the <code>framework-organization</code> directory of the repository and run <code>npm install</code> followed by <code>npm start</code>. Follow the guidance in the terminal and keep an eye out for the <code>README.md</code> files in the directories for extra information.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Summary</h1>
<p>We have looked at abstractions combined with clever API design, which together form the key to building successful frameworks. We have also expanded our knowledge of common framework interfaces that provide value to developers and make the application development process much more efficient and approachable. Understanding how modules, libraries, and frameworks are used helps us be better system architects. In addition, the ability to use the debugger to quickly explore how all these pieces come together in existing frameworks empowers us to be much more efficient developers.</p>
<p>Now that we are more familiar with various organization patterns, we can dive deeper into the specific techniques that help us architect new systems. In the next chapter, we are going to look at the existing and common patterns that combine the building blocks that we have learned into a cohesive system.</p>
</div>
</body></html>