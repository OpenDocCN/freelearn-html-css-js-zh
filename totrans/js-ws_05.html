<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer111">
			</div>
		</div>
		<div class="Content" id="_idContainer112">
			<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>5. Beyond the Fundamentals</h1>
		</div>
		<div class="Content" id="_idContainer138">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to identify the difference between JavaScript's mutable and immutable types; manipulate each of the built-in data types confidently; convert data from one type to another; format data types for presentation; and differentiate between an expression and a statement.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Introduction</h1>
			<p>In the previous chapter, you were given a tour of JavaScript, its runtimes, and its history. Using a high-level topography, that chapter will have given you an idea as to what JavaScript is, what it can do, and its ubiquity within the internet software development industry.</p>
			<p>Understanding code can be difficult for beginners. JavaScript is no exception. Its flexibility, extensive language syntax, and varying coding patterns can prove daunting to the uninitiated.</p>
			<p>This chapter will take you a step closer to writing your own software applications in JavaScript. By explaining the fundamentals, you will be empowered to not only understand what scripts do, but how to reason about problems using JavaScript syntax.</p>
			<p>In this chapter, you will take a close look at JavaScript's type system. All programming languages have a type system. Types literally dictate the type of data stored in a variable or function parameter. Types are typically separated into two categories: <strong class="bold">primitive</strong> and <strong class="bold">complex</strong> types.</p>
			<p>In JavaScript, all primitive data types are immutable. This means that the value cannot be changed in memory. New values can be assigned to a variable, but the underlying data stored in memory cannot be modified directly. This differs from the case in languages such as C++, where values can be directly altered in memory using pointers and helper functions. In JavaScript, when passing a primitive value from one variable to another, the data is copied in memory to the new variable. Therefore, updating one variable does not affect the other.</p>
			<p>Complex data types work differently. They are also known as reference types. Reference types include the <strong class="bold">Object</strong> type and all of its derivatives, such as <strong class="bold">Array</strong>, <strong class="bold">Date</strong>, and <strong class="bold">Function</strong>. All reference types are passed by reference, hence the name. Therefore, if an object is modified through one reference, all the other references that share the same object will see it as updated too, since all of the references point to the same data in memory.</p>
			<p>A complex type is simply a type that has more functionality than a primitive. For instance, a <strong class="source-inline">Date</strong> value provides additional means of representation, while objects can contain many nested values, such as primitives and other complex types.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Function types will not be explained in detail in this chapter and will instead be covered in a later chapter when prototypes are introduced.</p>
			<p>All primitives, and preexisting reference types are known as built-in data types. Each of these types has a corresponding object that provides functions for manipulating that type. These functions may be applied externally to data by passing the value as a parameter to a function, or they may be applied by calling the function as if it were a method of that type. The latter is also applicable to several primitives, despite them not existing as literal objects within the JavaScript type system. However, this is made possible through the syntactical context of the data. More will be explained about this feature throughout this chapter.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Creating Variables</h1>
			<p>Variable creation is the means to assign a value to a symbol. In this circumstance, a symbol is a textual representation of the data, much like a container, which can be used to move data through your program. It also improves the legibility of your code. There are multiple ways to create variables, including assignment to the global scope or through the use of either the <strong class="source-inline">var</strong>, <strong class="source-inline">let</strong>, or <strong class="source-inline">const</strong> keywords.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor181"/>A Note on Referencing</h2>
			<p>Even at this early stage, it must be highlighted that JavaScript's referencing functionality can get rather confusing. The presence of <strong class="source-inline">closures</strong>, <strong class="source-inline">prototypes</strong>, <strong class="source-inline">global</strong> and <strong class="source-inline">local memory stacks</strong>, <strong class="source-inline">variable assignment variations</strong>, and <strong class="source-inline">function invocation options</strong> can leave even seasoned programmers scratching their heads.  Each of the aforementioned features supports JavaScript as a formidable and flexible programming language that's able to challenge most other platforms for almost any purpose. While it does deepen JavaScript's learning curve, mastering these concepts can be extremely rewarding.</p>
			<p>This chapter highlights the very basics of data referencing and attempts to not confuse matters any more than necessary. Only referencing with regard to data at the global level will be discussed.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor182"/>Global Assignment</h2>
			<p>Assigning a variable without the use of <strong class="source-inline">var</strong>, <strong class="source-inline">let</strong>, or <strong class="source-inline">const</strong> will place the variable into the global scope. This value will then be accessible anywhere in your application unless a variable of the same name exists within that scope. Redeclaring the same variable name without the use of a preceding keyword will overwrite the global reference, even if it's assigned within a different scope.</p>
			<p>Declaring globally in a browser environment is equivalent to declaring the value on the global window object as a field.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor183"/>Declaring with var</h2>
			<p>Preceding variable assignment with the <strong class="source-inline">var</strong> keyword places the variable into function scope. This means the variable only exists at the same function as the assignment, but not outside that function. Declaring with <strong class="source-inline">var</strong> in the global scope is equivalent to declaring without the <strong class="source-inline">var</strong> keyword.</p>
			<p>Redeclaring a variable with <strong class="source-inline">var</strong>, but in a nested scope, will not overwrite the variable of the same name in the outer scope.</p>
			<p>Using the <strong class="source-inline">var</strong> keyword, variables can be scoped (declared) even after they are used within the same scope.  This is due to variable hoisting. Hoisting was explained in <em class="italic">Chapter 4</em>, JavaScript Libraries and Framework<em class="italic">s</em>.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor184"/>Declaring with let</h2>
			<p>The <strong class="source-inline">let</strong> keyword has a narrower scope. While <strong class="source-inline">var</strong> is considered to be functionally scoped, the <strong class="source-inline">let</strong> keyword is block scoped. This means that variables that are created with <strong class="source-inline">var</strong> exist throughout a function's scope level, while let-declared variables are created and used at the block level, such as in <strong class="source-inline">if</strong> conditional blocks or <strong class="source-inline">for</strong> loops.</p>
			<p>For example, using <strong class="source-inline">let</strong>, a variable can be temporarily overwritten within a <strong class="source-inline">for loop</strong> while not changing a variable of the same name in the outer function. However, if <strong class="source-inline">var</strong> is used instead, the outer variable will be changed:</p>
			<p class="source-code">var a=0;</p>
			<p class="source-code">for(var a in [0, 1]);</p>
			<p class="source-code">console.log( a ); // ==&gt; a is now 1 (as modified by the loop)</p>
			<p>In the preceding example, the variable declared in the <strong class="source-inline">for loop</strong> matches the symbol declared outside of it. As such, the same variable reference is modified. However, in the following example, the result is different, as the let-declared variable only exists within the context of the for loop, meaning the outside variable of the same name is left untouched:</p>
			<p class="source-code">var a=0;</p>
			<p class="source-code">for(let a in [0, 1]);</p>
			<p class="source-code">console.log( a ); // ==&gt; a is still 0 (not modified by the loop)</p>
			<p>Contrary to <strong class="source-inline">var</strong>, let-declared variables are not hoisted. If a scope declares a variable with <strong class="source-inline">let</strong>, accessing that variable before that let declaration statement (within the same scope or in any inner scope) will raise an error (this is regardless of whether a variable with the same name has been created in an outer scope):</p>
			<p class="source-code">glob=1; {glob=2; let glob=3;}  // ==&gt; can't access lexical declaration `glob' before </p>
			<p class="source-code">initialization</p>
			<p class="source-code">glob=1; {glob=2; var glob=3;} // ==&gt; accepted syntax</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/>Declaring with const</h2>
			<p>The <strong class="source-inline">const</strong> keyword works with the same scoping and hoisting rules as the <strong class="source-inline">let</strong> keyword. The difference with <strong class="source-inline">const</strong> is that it is assumed the variable will not change throughout its lifetime. Using <strong class="source-inline">const</strong> allows the JavaScript engine to make certain optimizations at compile time since it expects the data to remain constant at runtime.</p>
			<p>It is possible to create a new variable assignment with the same name in a nested function scope, but it will not be possible to modify a variable of the same name using global scoping rules.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Declaring a variable with var or let, but without assigning a value, will result in the variable containing <strong class="source-inline">undefined</strong>. The undefined value will be covered a little later in this chapter.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Exercise 5.01: Variables and Scope</h2>
			<p>In this exercise, we will use the browser's JavaScript <strong class="bold">Read-Eval-Print Loop </strong>(<strong class="bold">REPL</strong>) to experiment with variable assignment and scope. Let's get started:</p>
			<ol>
				<li>Launch your browser and open the developer tools console. In Chrome, you can do this by pressing the <em class="italic">F12</em> key.</li>
				<li>Ensure the <strong class="source-inline">Console</strong> tab is selected:<div class="IMG---Figure" id="_idContainer113"><img alt="Figure 5.1: The Console tab&#13;&#10;" src="image/C14377_05_01.jpg"/></div><p class="figure-caption">Figure 5.1<a id="_idTextAnchor187"/>: The Console tab</p></li>
				<li>At the <strong class="source-inline">prompt</strong>, enter the following commands, pressing <em class="italic">Enter</em> at the end of each line:<p class="source-code">const i = 10;</p><p class="source-code">console.log(i);</p><p class="source-code">// -&gt;    10</p><p>The <strong class="source-inline">console.log</strong> command writes the value of <strong class="source-inline">i</strong> to the console.</p></li>
				<li>Next, create a function that also initializes a variable of the same name, as follows:<p class="source-code">const f = function() {</p><p class="source-code">    var i = 20;</p><p class="source-code">    console.log(i);</p><p class="source-code">};</p></li>
				<li>Invoke the function to print the variable that exists within the function scope. If you then print the global variable, you will see it has not been modified:<p class="source-code">f();</p><p class="source-code">// -&gt;    20</p><p class="source-code">console.log(i);</p><p class="source-code">// -&gt;    10</p></li>
				<li>N<a id="_idTextAnchor188"/>ext, try the <strong class="source-inline">let</strong> keyword:<p class="source-code">if (true) {</p><p class="source-code">    let i = 15;</p><p class="source-code">    console.log(i);</p><p class="source-code">}</p><p class="source-code">// -&gt;   15</p><p class="source-code"> console.log(i);</p><p class="source-code">// -&gt;   10</p><p>As you can see, the <strong class="source-inline">let</strong> assignment only exists for the lifetime of the block that follows the if statement.</p></li>
				<li>Close the browser tab. Open a new tab and open the console again (otherwise, you won't be able to re-assign <strong class="source-inline">i</strong> as a variable). Now, try the same with <strong class="source-inline">var</strong>. You will see that the variable declaration raises an error because it conflicts with the <strong class="source-inline">i</strong> variable outside of the conditional block:<p class="source-code">i = 10;</p><p class="source-code">if (true) {</p><p class="source-code">    var i = 15;</p><p class="source-code">    console.log(i);</p><p class="source-code">}</p><p class="source-code">// -&gt;    15</p><p class="source-code">console.log(i);</p><p class="source-code">// -&gt;    15</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer114">
					<img alt="Figure 5.2: Exercise 5.01 output&#13;&#10;" src="image/C14377_05_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Exercise 5.01 output</p>
			<p>Understanding the scope surrounding a variable is important for the correct execution of your application, as well as for minimizing bugs. Try to keep a mental note of the positioning and use of each variable as you work. Utilizing functional paradigms, as discussed in <em class="italic">Chapter 13</em>, <em class="italic">JavaScript Programming Paradigms</em>, will also help alleviate any discrepancies in variable scoping.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor189"/>Identifying a Variable's Type</h2>
			<p>So far, you have created variables and output their value to the browser's console. In order to get the most out of the content of this chapter, however, it would be helpful to be able to identify the content of a variable.  JavaScript is known as a weakly typed language because a variable can hold a <strong class="source-inline">string</strong> one moment, but then an <strong class="source-inline">integer</strong> the </p>
			<p>next. By being able to identify the type of value stored in a variable, you prevent errors occurring where you attempt to process a value you expected to be of a different type.</p>
			<p>Th<a id="_idTextAnchor190"/>e <strong class="source-inline">typeof</strong> keyword exists to do just that. By preceding a variable with the <strong class="source-inline">typeof</strong> keyword, the returned value is the type of the variable represented as a <strong class="source-inline">string</strong>.</p>
			<p>The <strong class="source-inline">typeof</strong> keyword evaluates with the following type mapping:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer115">
					<img alt="Figure 5.3: Types and responses&#13;&#10;" src="image/C14377_05_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Types and responses</p>
			<p>The <strong class="source-inline">null</strong> type evaluates as "<strong class="source-inline">object</strong>". This anomaly originates from the earliest incarnations of JavaScript where data types were tagged internally with an integer value. Object types were tagged with 0, while the <strong class="source-inline">null</strong> value existed as a <strong class="source-inline">null pointer</strong> (or <strong class="source-inline">0x00</strong> as a value). As the two expressions were identical, determining the type of <strong class="source-inline">null</strong> resulted in the same type as Object. This same anomaly still exists in JavaScript today. Therefore, when determining whether a type is an Object, we must also compare it with <strong class="source-inline">null</strong>:</p>
			<p class="source-code">var value = [1, 2, 3]; // an array - which is also an object</p>
			<p class="source-code">if (typeof value === "object" &amp;&amp; value != null) {</p>
			<p class="source-code">    console.log("value is an object");</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor191"/>Exercise 5.02: Evaluating Types from Variables</h2>
			<p>In this exercise, we will create a function that outputs the type of whatever variable is passed to it. Let's get started:</p>
			<ol>
				<li value="1">At the command prompt, enter the following line to declare the function signature:<p class="source-code">var printType = function(val) {</p><p>This function accepts a single variable, which will be the variable to analyze.</p></li>
				<li>Due to the Null value caveat, you must check for this, first. <a id="_idTextAnchor192"/>Here, compare <strong class="source-inline">val</strong> to <strong class="source-inline">Null</strong> and output the appropriate message. If the value is indeed <strong class="source-inline">Null</strong>, then the function must be returned so that no further comparisons can be made:<p class="source-code">  if (val === null) {</p><p class="source-code">    console.log("Value is null");</p><p class="source-code">    return;</p><p class="source-code">  }</p><p><a id="_idTextAnchor193"/><a id="_idTextAnchor194"/>Here, you are comparing <strong class="source-inline">val</strong> to <strong class="source-inline">Null</strong> and outputting the appropriate message. If the value is indeed <strong class="source-inline">Null</strong>, then the function must be returned so that no further comparisons can be made.</p></li>
				<li>If the value is <strong class="source-inline">not Null</strong>, then you can safely return the type of the value itself:<p class="source-code">  console.log("Value is", typeof val);</p><p class="source-code">}</p><p><strong class="source-inline">console.log(...)</strong> will output however many values are passed into it and concatenate them onto the same line. Here, you output the generic message but then concatenate it with the type of the variable. Since no value is required to be passed from this function, and as there is no more logic to perform, no return statement is required to close out the function.</p></li>
				<li>To test this function, execute it in the console with different values:<p class="source-code">printType(12);</p><p class="source-code">printType("I am a string");</p><p class="source-code">printType({});</p><p class="source-code">printType(null);</p><p>The preceding code will result in the following output:</p><p class="source-code">Value is number</p><p class="source-code">Value is string</p><p class="source-code">Value is object</p><p class="source-code">Value is null</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer116">
					<img alt="Figure 5.4: Exercise 5.02 output&#13;&#10;" src="image/C14377_05_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: Exercise 5.02 output</p>
			<p>The function you have just created is rather light in terms of introspection. It essentially enables you to determine the general type of a passed in value, but it isn't powerful enough to differentiate object types, including JavaScript's built-in objects. Whether you pass in a <strong class="source-inline">Date</strong> or an <strong class="source-inline">Array</strong>, you will get the same output.</p>
			<p>You will discover how to be more thorough in determining data types later in this module.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor195"/>Fixed Types</h1>
			<p>Fixed types are types that have no variation of value. Unlike numbers, which may have any combination of digits, an optional minus sign (for negative numbers), a decimal point, or a scientific notation, a fixed type is always one simple value or value group.</p>
			<p>In JavaScript, the available fixed types include <strong class="source-inline">null</strong>, <strong class="source-inline">undefined</strong>, and <strong class="source-inline">Booleans</strong> (<strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>). These values are <strong class="source-inline">static</strong> and cannot change. If a variable contains one of these values, it is then strictly equal to the value itself. Fixed types are more of a representation of a situation than actual data. For instance, <strong class="source-inline">true</strong> is a fixed representation of truthfulness and <strong class="source-inline">false</strong> is a fixed representation of falsehood. The values are not quantifiable in the real world but are representative of logic that software directly deals with.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor196"/>The null Value</h2>
			<p><strong class="source-inline">null</strong>, in mathematical terms, denotes a value that is not present. In JavaScript, <strong class="source-inline">null</strong> is a static value that's used to mean no value. In other languages, this would be equivalent to nil or void.</p>
			<p><strong class="source-inline">null</strong> is a useful value for dereferencing variables or for returning a value from a function when no value can be returned. For instance, a function may return an object from an array if the item is present but may return <strong class="source-inline">null</strong> if it is not.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor197"/>The undefined Value</h2>
			<p><strong class="source-inline">undefined</strong> is similar to <strong class="source-inline">null</strong> in many ways and, due to this, the two values are often misused. <strong class="source-inline">undefined</strong> is the value contained in any variable that is declared first, but not assigned a value. It is also the value that's been returned from a function that does not explicitly return a value using the <strong class="source-inline">return</strong> keyword and it is the value that's returned from a statement (an action with no resulting value).</p>
			<p>When working with <strong class="source-inline">undefined</strong>, you should always anticipate it, but never assign it to a variable or return it explicitly from a function. In such circumstances, you should use <strong class="source-inline">null</strong>.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor198"/>Boolean Values</h2>
			<p><strong class="source-inline">B<a id="_idTextAnchor199"/>oolean</strong> is a term named after George Boole, a nineteenth-century English mathematician and philosopher. It is used to denote the values <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>. These values may be assigned to variables and are strictly equivalent to their value, like null.</p>
			<p>Booleans are unique among the types supported by JavaScript because they are indirectly comparable to other types and expressions. The logical operators described in <em class="italic">Chapter 3</em>, <em class="italic">Programming Fundamentals</em>, of this book, for instance, all result in a <strong class="source-inline">Boolean</strong> value.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor200"/>Boolean Operators</h1>
			<p>Boolean operators are operators that, when combined into an expression, return a <strong class="source-inline">Boolean</strong> value. Most Boolean operators are "<strong class="source-inline">binary</strong>" operators that accept two values, each of which sit either side of the operator. Like other operators, each value can be an expression and can be of any value type. As <strong class="source-inline">Boolean</strong> operators themselves form expressions, they can be used as input to other <strong class="source-inline">Boolean</strong> operators.</p>
			<p>Boolean operators fit into two categories; namely, comparison operators and logical operators.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor201"/>Comparison Operators</h2>
			<p>Comparison operators are used for comparing one value, or the result of an expression, with another. The operator in this circumstance may be considered a rule. If the rule succeeds, then the response of the combined expression returns <strong class="source-inline">true</strong>. Otherwise, it returns <strong class="source-inline">false</strong>.</p>
			<p>Comparison operators include the following symbols:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer117">
					<img alt="Figure 5.5: Comparison operators and their descriptions&#13;&#10;" src="image/C14377_05_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: Comparison operators and their descriptions</p>
			<p>Comparison operators are often used as the condition parameters of if conditionals and while loop statements. If or while the condition expression returns true, the body block of the expression will execute.</p>
			<p>The following example expressions will all return the value true:</p>
			<p class="source-code">21 == 9+12;</p>
			<p class="source-code">false != true;</p>
			<p class="source-code">6 &gt; 1;</p>
			<p class="source-code">5 &gt;= 5;</p>
			<p class="source-code">"1" == 1;</p>
			<p>If you look at the last example in the list, you may be a little surprised. The <strong class="source-inline">==</strong> operator is a "value comparison operator". In the example shown, the numeric value 1 and the string value "1" are considered the same value.  As such, the equality operator, which is a "value comparison" operator, will compare them as equal.</p>
			<p>In order to determine whether values are of the same type, as well as the same value, "strict comparison operators" should be used:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer118">
					<img alt="Figure 5.6: Equality operators and their descriptions&#13;&#10;" src="image/C14377_05_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: Equality operators and their descriptions</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor202"/>Logical Operators</h2>
			<p>Logical operators are often used to concatenate <strong class="source-inline">Boolean</strong> expressions together. For instance, when comparing the qualities of a <strong class="source-inline">string</strong> value, you may wish to execute code if the <strong class="source-inline">string</strong> is longer than one value but shorter than another. In order to do this, you need to join two comparison expressions using the <strong class="source-inline">&amp;&amp;</strong> operator. In another condition, you may wish to execute the code if only one of the expressions is <strong class="source-inline">true</strong>, in which case, you would use the <strong class="source-inline">||</strong> operator.</p>
			<p>The following table lists each of the logical operators and what they do:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer119">
					<img alt="Figure 5.7: Logical operators and their description&#13;&#10;" src="image/C14377_05_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: Logical operators and their description</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor203"/>Exercise 5.03: Odds and Evens</h2>
			<p>In this exercise, we will process a series of numbers and output messages describing whether a number is either odd or even.</p>
			<p>We'll fulfill this exercise using a function so that you can experiment with different starting values. Let's get started:</p>
			<ol>
				<li value="1">At the command prompt, create the <strong class="source-inline">odd_or_even</strong> function with a couple of parameters:<p class="source-code">function odd_or_even(counter, last) {</p><p>The <strong class="source-inline">last</strong> parameter will be the ceiling value of the numerical series, while the <strong class="source-inline">counter</strong> parameter is both the starting value and the current index variable for each loop.</p></li>
				<li>Next, create your loop using the <strong class="source-inline">while</strong> keyword. while will process a block of code as long as the conditional expression is truthy. As the conditional in this exercise, you will simply compare <strong class="source-inline">counter</strong> with the <strong class="source-inline">last</strong> parameter:<p class="source-code">  while (counter &lt;= last) {</p><p>If the <strong class="source-inline">counter</strong> variable is ever larger than the <strong class="source-inline">last</strong> parameter, then the <strong class="source-inline">while</strong> loop will exit, which will also exit the function.</p></li>
				<li>With the <strong class="source-inline">while</strong> conditional in place, you can now begin describing the counter value with each iteration. To do this, you simply examine the value of <strong class="source-inline">counter</strong> and respond with an appropriate message, depending on its content:<p class="source-code">    if (counter % 2 == 0) { // is true if the remainder of 'counter / 2' is </p><p class="source-code">equal to zero</p><p class="source-code">      console.log(counter, "is an even number");</p><p class="source-code">    } else {</p><p class="source-code">      console.log(counter, "is an odd number");</p><p class="source-code">    }</p></li>
				<li>Now, increment the <strong class="source-inline">counter</strong> variable by <strong class="source-inline">1</strong> before you close the <strong class="source-inline">while</strong> loop block. <a id="_idTextAnchor204"/>If you fail to increment, the condition of the <strong class="source-inline">while</strong> loop would always be <strong class="source-inline">true</strong>, and the loop will never exit. Also, each iteration of the loop would process identically, which is not the result you require:<p class="source-code">  counter = counter + 1;<a id="_idTextAnchor205"/></p></li>
				<li>Close out both the <strong class="source-inline">while</strong> block and the function. There is no need to return anything from this function as we are not interested in any final values:<p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now, execute the function, passing a <strong class="source-inline">counter</strong> value and <strong class="source-inline">last</strong> value as required. The output should accurately describe all the numbers from <strong class="source-inline">counter</strong> to <strong class="source-inline">last</strong>, inclusively.<p>Here's the output:</p><p class="source-code">odd_or_even(1, 5);</p><p class="source-code">//   1 "is an odd number"</p><p class="source-code">//   2 "is an even number"</p><p class="source-code">//   3 "is an odd number"</p><p class="source-code">//   4 "is an even number"</p><p class="source-code">//   5 "is an odd number"</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer120">
					<img alt="Figure 5.8: Exercise 5.03 output&#13;&#10;" src="image/C14377_05_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: Exercise 5.03 output</p>
			<p>Have a go at changing the passed parameters when calling the function. However, be sure to keep <strong class="source-inline">counter</strong> to a value less than or equal to the <strong class="source-inline">last</strong> parameter or the <strong class="source-inline">while</strong> loop will not execute.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor206"/>Testing the Truth of Values</h2>
			<p>When writing programs with JavaScript, you will often need to compare values, typically when working with conditionals. Often, values will be compared with other values, but it is just as likely that you will need to check the truthiness of a value.</p>
			<p>Testing for truthiness can mean many things:</p>
			<ul>
				<li>Is there a value present?</li>
				<li>Are there any items in an array?</li>
				<li>Does the string have a length greater than 0?</li>
				<li>Does the passed expression return <strong class="source-inline">true</strong>?</li>
			</ul>
			<p>JavaScript provides a means to pass in a solitary value to conditional statements to test for truthiness.  However, this can sometimes be an area of confusion. For instance, examine the following example:</p>
			<p class="source-code">if (0) console.log("reached");  // doesn't succeed</p>
			<p class="source-code">console.log( 0 == false ); // prints true</p>
			<p class="source-code">console.log( 0 === false ); // prints false</p>
			<p>The <strong class="source-inline">if</strong> statement body executes if the conditional is truthy. In the first example in the preceding code, the numeric value zero is seen as falsey. As the second and third examples show, <strong class="source-inline">false</strong> is equal to numeric zero, but only non-strictly. However, in the third example, the numeric value zero is not strictly equivalent to <strong class="source-inline">false</strong>.  The reason for this is that there is a difference between a <strong class="source-inline">false</strong> value and a falsey value. A <strong class="source-inline">false</strong> value is always false, but a falsey value may be one of several values, including the following:</p>
			<ul>
				<li>false</li>
				<li><strong class="source-inline">undefined</strong></li>
				<li><strong class="source-inline">null</strong></li>
				<li>-0, +0, or NaN</li>
				<li>An <strong class="source-inline">empty</strong> string</li>
			</ul>
			<p>If the value is not in the preceding list, then it is considered truthy.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor207"/>The NOT Operator</h2>
			<p>The <strong class="source-inline">!</strong> or <strong class="source-inline">NOT</strong> operator is rather unique. It is considered a "unary" operator because it only accepts one value to the right of it. By using the <strong class="source-inline">NOT</strong> operator, you essentially negate the value that precedes it. Here's an example:</p>
			<p class="source-code">var falseValue = !true;</p>
			<p>In the preceding example, the <strong class="source-inline">falseValue</strong> variable will contain a value of <strong class="source-inline">false</strong>.</p>
			<p>A very useful feature of the <strong class="source-inline">NOT</strong> operator is the "<strong class="source-inline">double NOT</strong>." This is when two <strong class="source-inline">NOT</strong> operators are combined to double negate an expression; a true expression is negated to <strong class="source-inline">false</strong>, then back to <strong class="source-inline">true</strong>, while a <strong class="source-inline">false</strong> expression is negated to <strong class="source-inline">true</strong>, then back to <strong class="source-inline">false</strong>.</p>
			<p>When working with truthy or falsey expressions, using the <strong class="source-inline">double NOT</strong> operator alters the resulting value of these expressions to actual Boolean values. Here's an example:</p>
			<p class="source-code">if (!!1 === true) {</p>
			<p class="source-code">  console.log("this code will execute");</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor208"/>Boolean Operator Precedence</h2>
			<p>All operators have an order of execution known as "<strong class="bold">precedence</strong>." This precedence is also apparent in mathematics and is a means to ensure that expressions are executed in a predictable manner.</p>
			<p>Consider the following code:</p>
			<p class="source-code">if (true || false &amp;&amp; false)</p>
			<p>The preceding example could be read in two different ways. This is the first way:</p>
			<p class="source-code">if ((true || false) &amp;&amp; false)</p>
			<p>This is the second way:</p>
			<p class="source-code">if (true || (false &amp;&amp; false))</p>
			<p>If you follow the code from left to right, as in the first example of interpretation, it will return <strong class="source-inline">false</strong>, because the <strong class="source-inline">&amp;&amp;</strong> operator is executed last. There, the code will be reduced to the following:</p>
			<p class="source-code">   true || false &amp;&amp; false</p>
			<p class="source-code">= true &amp;&amp; false</p>
			<p class="source-code">= false</p>
			<p>The second interpretation, however, will produce a different result:</p>
			<p class="source-code">   true || false &amp;&amp; false</p>
			<p class="source-code">= true || false</p>
			<p class="source-code">= true</p>
			<p>To prevent such ambiguity, operator order precedence exists. Precedence is applicable to all the operators in the JavaScript language, but we'll list just those that are applicable to <strong class="source-inline">Boolean</strong> expressions here:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer121">
					<img alt="Figure 5.9: Boolean operators and their associativity&#13;&#10;" src="image/C14377_05_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: Boolean operators and their associativity</p>
			<p>In the preceding table, the top row has the highest precedence and so is evaluated first, while the bottom row has the lowest precedence and is evaluated last.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor209"/>Boolean Operator Associativity</h2>
			<p>In the previous table, each operator is given an associativity description.  Associativity relates to the execution direction of an expression. Most operators have "left-to-right" associativity, which means the left-hand side expression is executed before the right-hand side expression. The <strong class="source-inline">NOT</strong> operator, however, executes its right-hand expression first.</p>
			<p>Associativity can be very important, especially when side effects occur within an expression. In the following example, the expressions present on either side of a <strong class="source-inline">||</strong> operator log the parameter and return it:</p>
			<p class="source-code">function logAndReturn( value ) {</p>
			<p class="source-code">  console.log( "logAndReturn: " +value );</p>
			<p class="source-code">  return value;</p>
			<p class="source-code">}</p>
			<p class="source-code"><a id="_idTextAnchor210"/>if ( logAndReturn (true) || logAndReturn (false)) {</p>
			<p class="source-code">  console.log("|| operator returned truthy.");</p>
			<p class="source-code">}</p>
			<p>When executed, if the <strong class="source-inline">log_and_return</strong> function returns a truthy value, then only the first execution will occur and so only that call logs a message with <strong class="source-inline">log_and_return</strong>: concatenated with the value passed in. Since the <strong class="source-inline">||</strong> operator is left-to-right associative, the entire expression is considered truthy if the left-hand side returns <strong class="source-inline">true</strong>. As such, the right-hand side is never executed. For this particular operator, the right-hand side only ever executes if the left-hand side is false. This behavior is also called a short circuit.</p>
			<p>Since the side effect of <strong class="bold">logAndReturn</strong> is only logging the value, this provides a useful tool for debugging. However, consider a function that receives an object as a parameter, modifies it, and then returns a value:</p>
			<p class="source-code">// Following two variables are set to "anonymous" (simple) objects,</p>
			<p class="source-code">// each with two fields, 'name' and 'happy', set to initial values (both sad)</p>
			<p class="source-code">var john= {name: "John", happy: false};</p>
			<p class="source-code">var lucy= {name: "Lucy", happy: false};</p>
			<p class="source-code">function make_happy( person ) {</p>
			<p class="source-code">  console.log("Making " +person.name+ " happy.");</p>
			<p class="source-code">  person.happy= true;</p>
			<p class="source-code">  return true;</p>
			<p class="source-code">}</p>
			<p class="source-code">if (make_happy(john) || make_happy(lucy)) {</p>
			<p class="source-code">  console.log("John is happy: " +john.happy+ ", Lucy is happy: " +lucy.happy);</p>
			<p class="source-code">}</p>
			<p>Both objects follow the same structure and the <strong class="source-inline">make_happy</strong> function could possibly work with either object. However, when the conditional is called, only <strong class="source-inline">john</strong> will be updated since the <strong class="source-inline">||</strong> condition in the conditional expression is satisfied on its left-hand side. </p>
			<p>The right-hand side is never executed. Therefore, if the code is dependent on both objects being modified at a later date, it will fail.</p>
			<p>This same caveat is true for the <strong class="source-inline">&amp;&amp;</strong> operator. Since an <strong class="source-inline">&amp;&amp;</strong> operator expression is considered <strong class="source-inline">true</strong> if both sides are truthy, then both sides will only execute if the left-hand side execution returns <strong class="source-inline">true</strong>.</p>
			<p>The associative execution rule for the <strong class="source-inline">||</strong> operator is particularly useful when working with variables. In some circumstances, it is preferable to assign a default value to a variable if, and only if, it does not already contain a value. In this instance, using the <strong class="source-inline">||</strong> operator can make light work of this task:</p>
			<p class="source-code">distanceLimit = distanceLimit || 5;</p>
			<p>If the variable already contains a value, then it will keep that value. However, if its value is <strong class="source-inline">null</strong>, <strong class="source-inline">undefined</strong>, or some other falsey value, then it will be assigned the value 5.</p>
			<p>Similarly, using the <strong class="source-inline">&amp;&amp;</strong> operator is great if you wish to execute a function if a preceding variable is truthy:</p>
			<p class="source-code">items.length &amp;&amp; processItems(items);</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor211"/>Exercise 5.04: Free Home Delivery Eligibility Validation</h2>
			<p>In this exercise, we will create a function that will determine whether the customers of a grocery store are eligible for free home delivery. The store only delivers to customers who are located within 5 miles of the store. To make this exercise more interesting, the store recently decided to provide free delivery for customers located within 10 miles of the store, but only if those customers have an active membership for their loyalty program. Moreover, if customers are within 1 mile of the store, they aren't eligible for free home delivery, regardless of their membership status. Let's get started:</p>
			<ol>
				<li value="1">Define your function signature. The function should accept the distance of the customer's house from the store and their membership status:<p class="source-code">function isEligible(distance, membershipstatus) {</p><p>Based on the store's criteria, the function will return <strong class="source-inline">true</strong> if the customer is eligible for free delivery and <strong class="source-inline">false</strong> if they are not. Functions that describe something in a <strong class="source-inline">Boolean</strong> fashion are often labeled <strong class="source-inline">is</strong>, such as <strong class="source-inline">isValid</strong>, <strong class="source-inline">isEnabled</strong>, or <strong class="source-inline">isGoingToReturnABoolean</strong>.</p></li>
				<li>There are two ways to build the body of this function; either break the problem up into small chunks and test the parameters bit by bit or create a single conditional that detects all the appropriate outcomes. We'll work with the latter in order to appropriately demonstrate the content of this chapter thus far. The following if statement is a negative check – it checks whether a customer is not eligible for free home delivery:<p class="source-code">if (distance &lt; 1 || membershipstatus === "active" &amp;&amp; distance &gt; 10 || membershipstatus === "inactive" &amp;&amp; distance &gt; 5 ) {</p><p>This is the crux of the exercise. The <strong class="source-inline">Boolean</strong> operators are executed in the following order, but only those that are necessary to determine the overall result. First and always is the relative check for houses within <strong class="source-inline">1</strong> mile of the store. If the house is within <strong class="source-inline">1</strong> mile of the store, the overall result is <strong class="source-inline">true</strong>, and the rest of the expression is not evaluated at all. Only if the distance is <strong class="source-inline">1</strong> mile or more is the overall result not determined yet and the following goes ahead. Only if the membership status is active does the check for a distance greater than <strong class="source-inline">10</strong> miles come. Otherwise, if the membership status is inactive, there comes the check for a <strong class="source-inline">distance</strong> of greater than <strong class="source-inline">5</strong> miles. Then, those results are with the less-than-1-mile check. Due to operator precedence, no grouping using parentheses was required.</p></li>
				<li>If the conditional evaluates as truthy, then we want to report that the person is not eligible for free delivery:<p class="source-code">    return false;</p></li>
				<li>Since the function will simply halt here, if the conditional block is executed, simply return <strong class="source-inline">true</strong> for anything that slips past:<p class="source-code">  }</p><p class="source-code">  return true;</p><p class="source-code">}</p></li>
				<li>With the function complete, try different parameter variations to test it:<p class="source-code">console.log( isEligible(.5, "active") );</p><p class="source-code">// =&gt;   false</p><p class="source-code">console.log( isEligible(7, "inactive") );</p><p class="source-code">// =&gt;   false</p><p class="source-code">console.log( isEligible(7, "active") );</p><p class="source-code">// =&gt;    true</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer122">
					<img alt="Figure 5.10: Exercise 5.04 output&#13;&#10;" src="image/C14377_05_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Exercise 5.04 output</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor212"/>Why You Shouldn't Compare Boolean and Non-Boolean Expressions</h2>
			<p>While many non-Boolean values and objects are considered truthy, they may not be equal to <strong class="source-inline">Boolean</strong> <strong class="source-inline">true</strong>:</p>
			<p class="source-code">console.log( 1 == true ); // =&gt; true, but:</p>
			<p class="source-code">console.log( 2 == true ); // =&gt; false, because true first converts to 1</p>
			<p class="source-code">console.log( 2 == false ); // =&gt; also false, because false converts to 0</p>
			<p>A good rule of thumb is to convert the non-Boolean expression into a <strong class="source-inline">Boolean</strong> type with <strong class="source-inline">!!</strong> – the double negation:</p>
			<p class="source-code">console.log( !!2 == true ); // =&gt; true</p>
			<p class="source-code">console.log( !!2 == false ); // =&gt; false</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor213"/>Why You Shouldn't Chain Comparison Expressions</h2>
			<p>Repeated applications of the same operator to more than two expressions are called chaining. Usually, this is practical and clear:</p>
			<p class="source-code">console.log( 1 + 2 + 3 ); // =&gt; 6</p>
			<p class="source-code">console.log( true &amp;&amp; true &amp;&amp; false ); // =&gt; false</p>
			<p>It may also be tempting to use this process with comparison operators, but that would give a surprising, and incorrect, result. In such circumstances, the intermediary result of the first <strong class="source-inline">Boolean</strong> comparison would provide a <strong class="source-inline">Boolean</strong> outcome. Therefore, when it is compared with the next number in the chain, it will be converted by the JavaScript engine into a <strong class="source-inline">1</strong> (if it is <strong class="source-inline">true</strong>) or a <strong class="source-inline">0</strong> (if it is <strong class="source-inline">false</strong>):</p>
			<p class="source-code">console.log( 1 &lt; 3 &lt; 2 ); // 1&lt;3 =&gt; true, but then: true&lt;2 =&gt; 1&lt;2 =&gt; true!</p>
			<p>Similar confusion arises when using comparison operators:</p>
			<p class="source-code">console.log( 2==2==2 ); // 2==2 =&gt; true, but then: true==2 =&gt; 1==2 =&gt; false!</p>
			<p class="source-code">// Similarly with 0:</p>
			<p class="source-code">console.log( 0==0==0 ); // 0==0 =&gt; true, but then: true==0 =&gt; 1==0 =&gt; false!</p>
			<p class="source-code">// However, not the same with 1:</p>
			<p class="source-code">console.log( 1==1==1 ); // 1==1 =&gt; true, then: true==1 =&gt; 1==1 =&gt; true</p>
			<p>Therefore, avoid chaining any comparison operators unless you're explicitly working with <strong class="source-inline">Boolean</strong> values.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor214"/>The Ternary Operator</h2>
			<p>So far, we have looked at unary and binary operators, but another operator is also supported in JavaScript. Known simply as the ternary operator, it performs a similar role to <strong class="source-inline">if...else</strong>, but in a much more compact fashion. The <strong class="source-inline">ternary</strong> operator consists of a question mark (<strong class="source-inline">?</strong>) and a colon (<strong class="source-inline">:</strong>), which are used to denote a conditional expression <strong class="source-inline">?</strong>, a true expression with if <strong class="source-inline">false</strong> expression. For example:</p>
			<p class="source-code">var action = (score &lt; 40) ? "Fail" : "Pass";</p>
			<p>This, of course, is the same as the following:</p>
			<p class="source-code">var action;</p>
			<p class="source-code">if (score &lt; 40) {</p>
			<p class="source-code">  action = "Fail";</p>
			<p class="source-code">} else {</p>
			<p class="source-code">  action = "Pass";</p>
			<p class="source-code">}</p>
			<p>The primary difference here is that the <strong class="source-inline">ternary</strong> operator is an expression in itself. This differs from <strong class="source-inline">if</strong>, which is a statement (it does not return a value).</p>
			<p>The conditional segment of the <strong class="source-inline">ternary</strong> operator does not need to be enclosed in parentheses but is often seen as such so that it closely resembles an <strong class="source-inline">if</strong> expression. The rules for each of the three expressions are simply that they must be expressions; you cannot use <strong class="source-inline">if</strong>, <strong class="source-inline">while</strong>, or another such statement, otherwise an error will be thrown.</p>
			<p>As ternary operators are expressions, they can be nested. Each question mark segment of the operator expects a colon segment to follow, much like nesting groups of brackets. Therefore, it is possible, and acceptable, to do the following:</p>
			<p class="source-code">var status = (score &lt; 40) ? "Fail" : (score &gt; 90) ? "Outstanding Score" : "Pass";</p>
			<p>This is equivalent to the following:</p>
			<p class="source-code">var status;</p>
			<p class="source-code">if (score &lt; 40) {</p>
			<p class="source-code">  status = "Fail";</p>
			<p class="source-code">} else if (score &gt; 90) {</p>
			<p class="source-code">  status = "Outstanding Score";</p>
			<p class="source-code">} else {</p>
			<p class="source-code">  status = "Pass";</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Ternary</strong> operators are very useful for keeping your code succinct. Sometimes, utilizing a complete <strong class="source-inline">if...else</strong> statement detracts from the purpose of the code and makes it harder to understand. Feel free to use the <strong class="source-inline">ternary</strong> operator where you see fit.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor215"/>Working with Numbers</h1>
			<p>All numbers in JavaScript are 64-bit floating-point values. Unlike other languages, there is no internal differentiation between floating-point values and integers. JavaScript provides several objects containing functions that are orientated specifically around floating-point values and integers. However, these objects are semantic. Therefore, applying integer-specific functions to a number will still result in a floating-point value.</p>
			<p>Numbers are the simplest form of data represented by the JavaScript engine. Number values are immutable, which means their value cannot be modified in memory. If you assign a new number to a variable, you are simply overwriting the old value with the new. The existing value is not modified.</p>
			<p>Since <strong class="source-inline">numbers</strong> are passed to variables by value, it is not possible for two variables to point to the same <strong class="source-inline">number</strong> address space. Therefore, working with <strong class="source-inline">number</strong> values is considered pure, providing you do not reassign values to variables.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor216"/>Arithmetic Limitations</h2>
			<p>Floating-point values can pose something of a problem in JavaScript. Due to their <strong class="source-inline">binary</strong> encoding, which is how the <strong class="source-inline">number</strong> is represented in bits within the JavaScript engine, simply adding two floats together may not produce the result you are expecting. Consider the following:</p>
			<p class="source-code">0.1 + 0.2;  // outputs 0.30000000000000004</p>
			<p>Here, the response should be <strong class="source-inline">0.3</strong>, but it is not. The underlying runtime simply does not handle values in a way that allows them to be accurate, even with a single <strong class="source-inline">decimal</strong> place.</p>
			<p>If accuracy is necessary for your application, there are a number of tricks that provide the correct output. With regards to the preceding example, simply converting the values into decimals before the addition will yield better accuracy. You can then convert the resulting value back into a floating-point number afterward, like so:</p>
			<p class="source-code">((0.1 * 10) + (0.2 * 10)) / 10;  // outputs 0.3</p>
			<p>The same is also true for multiplication and division:</p>
			<p class="source-code">0.0032 * 13;  // outputs 0.041600000000000005</p>
			<p>However, if you convert into an <strong class="source-inline">integer</strong> first, then the result is more accurate:</p>
			<p class="source-code">0.0<a id="_idTextAnchor217"/>032 * 1000 * 13 / 1000; // outputs 0.0416</p>
			<p>This limitation is not restricted to JavaScript. In fact, any language that works with 64-bit IEEE 754 floating-point numbers will have the same limitations. There are numerous libraries available on the internet that help with these issues, if you would prefer not to tackle them yourself.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The largest integer values that JavaScript can represent as numbers are <strong class="source-inline">9,007,199,254,740,991</strong> and -<strong class="source-inline">9,007,199,254,740,991</strong>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor218"/>The Number Object</h2>
			<p>As we mentioned previously, numbers in JavaScript are primitives. As such, they have no properties or methods. Contrary to this, however, the JavaScript engine maintains an awareness of where numerical literals and variables are used within your application and provides syntactic support for methods via the <strong class="source-inline">number</strong> object. It is even possible to extend this object using prototypes, which will be explained in full in Part Four. Any extension imposed on the <strong class="source-inline">Number</strong> object will be usable against numeric values in your application:</p>
			<p class="source-code">5.123.toPrecision(3);</p>
			<p class="source-code">  // returns "5.12"</p>
			<p>Note that while it may seem as though numerical values are objects, this is not actually the case. In memory, numbers are very simple values. The <strong class="source-inline">Number</strong> object, and its implementation by the JavaScript runtime, merely provides many of the benefits afforded with objects against these values.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor219"/>Number Functions</h2>
			<p>The <strong class="source-inline">Number</strong> object contains an assortment of functions that work with numeric values. Like all objects, the <strong class="source-inline">Number</strong> object provides a constructor that, if invoked with the <strong class="source-inline">new</strong> keyword, creates a <strong class="source-inline">Number</strong> object instance. Numbers that are created with the <strong class="source-inline">Number</strong> constructor are actual objects, which is contrary to the previous statement, that is, that numbers are not objects, and is the cause of a lot of confusion. To make things even more interesting, the resulting object instance can be treated just like any other number.</p>
			<p>In addition to the constructor is the <strong class="source-inline">Number</strong> function. This is used in the same manner as the <strong class="source-inline">Number</strong> constructor but without the <strong class="source-inline">new</strong> keyword. Invoking this function returns a <strong class="source-inline">number</strong>, not an <strong class="source-inline">object</strong>:</p>
			<p class="source-code">var num1 = 99;</p>
			<p class="source-code">var num2 = Number(99);</p>
			<p class="source-code">var num3 = new Number(99);</p>
			<p class="source-code">console.log(num1 == num2); // outputs 'true'</p>
			<p class="source-code">console.log(num1 == num3); // outputs 'true'</p>
			<p class="source-code">console.log(num2 == num3); // outputs 'true'</p>
			<p class="source-code">console.log(num1, num2, num3); // outputs '99 99 Number {99}'</p>
			<p>In all the instances detailed in the preceding code, the resulting values can be worked with in the same manner and with the same rules, except when dealing with truthy conditionals. Typically, conditionals see the value <strong class="source-inline">0 </strong>(zero) as a falsey value, but the value returned from <strong class="source-inline">new Number(0)</strong> is truthy, even though it is also zero.</p>
			<p class="source-code">console.log( false==new Number(0) ); // =&gt; true, meaning that Number(0) equals to false, but:</p>
			<p class="source-code">if( new Number(0) ) { // =&gt; truthy</p>
			<p class="source-code">  console.log("truthy");</p>
			<p class="source-code">}</p>
			<p class="source-code">else {</p>
			<p class="source-code">  console.log("falsey");</p>
			<p class="source-code">}</p>
			<p>Likewise, when comparing by type, the value that's returned from <strong class="source-inline">new Number(0)</strong> is an object, not a number, so strict comparisons against numeric literals will fail.</p>
			<p>Both the <strong class="source-inline">Number</strong> function and constructor will accept any value type. If the value type cannot be converted into a number, then <strong class="source-inline">NaN</strong> (not a number) is returned:</p>
			<p class="source-code">console.log( Number(true) ); // 1</p>
			<p class="source-code">console.log( Number(false) ); // 0</p>
			<p class="source-code">console.log( Number("5") ); // 5</p>
			<p class="source-code">console.log( Number([]) ); // 0</p>
			<p class="source-code">console.log( Number([1, 2, 3]) ); // NaN</p>
			<p>When working with JavaScript, it is advised not to use the <strong class="source-inline">Number</strong> constructor at all so that your code is more readable.</p>
			<p>Aside from the <strong class="source-inline">Number</strong> function and constructor, the global <strong class="source-inline">Number</strong> object also provides a variety of functions to help us identify or parse numeric values:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer123">
					<img alt="Figure 5.11: Number functions and their descriptions&#13;&#10;" src="image/C14377_05_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Number functions and their descriptions</p>
			<p>Each of these functions is <strong class="source-inline">static</strong> and so must be preceded with the global <strong class="source-inline">Number</strong> object (which acts as a class in many languages), except when using <strong class="source-inline">parseFloat</strong> or <strong class="source-inline">parseInt</strong>. These functions are also global and therefore can be invoked without the preceding <strong class="source-inline">Number</strong>, like so:</p>
			<p class="source-code">console.log( Number.parseFloat("1.235e+2") ); // outputs 123.5</p>
			<p class="source-code">console.log( parseFloat("1.235e+2") ); // outputs 123.5 again</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor220"/>Number Methods</h2>
			<p><a id="_idTextAnchor221"/>Since the JavaScript parser semantically identifies numeric values, it is possible to invoke instance methods of the Number object against them, just like we can with actual objects. The majority of these methods are used to format <strong class="source-inline">numeric</strong> values as <strong class="source-inline">string</strong> representations, which is very useful for presentation in web pages:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer124">
					<img alt="Figure 5.12: Number methods and their descriptions&#13;&#10;" src="image/C14377_05_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Number methods and their descriptions</p>
			<p>Using a combination of the <strong class="source-inline">Number</strong> functions and methods, it is possible to convert to and from numeric values as necessary, though some precision may be lost:</p>
			<p class="source-code">console.log( 123.456.toLocaleString() ); // outputs "123.456"</p>
			<p class="source-code">console.log( 123.456.toFixed(1) ); // outputs "123.5"</p>
			<p class="source-code">console.log( 123.456.toExponential(3) ); // outputs "1.235e+2"</p>
			<p>However, calling those functions on integer literals (rather than floats) fails:</p>
			<p class="source-code">console.log( 123.toString() ); // =&gt; Uncaught SyntaxError: Invalid or unexpected token</p>
			<p>When JavaScript sees the first dot right after one or more digits, it assumes you want to write a float literal. There are some workarounds to this:</p>
			<p class="source-code">console.log( 123.0.toString() ); // Append .0. It will still be represented as an integer (as far as it fits in the integer range)</p>
			<p class="source-code">console.log( (123).toExponential(2) ); // Wrap within parentheses (..)</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor222"/>Number Properties</h2>
			<p>The global <strong class="source-inline">Number</strong> object provides a variety of constant properties, which is useful when comparing your numeric values. The most important of these is <strong class="source-inline">NaN</strong>. Being able to identify numeric discrepancies outside of the JavaScript runtime's ability to calculate provides you with a means to reduce bugs in your code. For instance, observe the following example:</p>
			<p class="source-code">var num = 999 / 0;</p>
			<p><a id="_idTextAnchor223"/>When executed, the result of <strong class="source-inline">num</strong> is the constant value known as Infinity. Since it is not possible to add, deduct, multiply, or divide other values from infinity, any further math against that value will also be Infinity.  Therefore, being able to deduce this restriction within your code will provide an early warning that something may be amiss in your logic.</p>
			<p>Other properties of Number include the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer125">
					<img alt="Figure 5.13: Number properties and their descriptions&#13;&#10;" src="image/C14377_05_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Number properties and their descriptions</p>
			<p>Both <strong class="source-inline">MAX_SAFE_INTEGER</strong> and <strong class="source-inline">MIN_SAFE_INTEGER</strong> are interesting values. Consider the following code:</p>
			<p class="source-code">Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2;</p>
			<p>Surprisingly, the result of the preceding expression is <strong class="source-inline">true</strong>. This is simply because the numbers exceed safety boundaries and are therefore no longer accurately represented. The precision that's used in both sides of the preceding expression results in the same value and thus are considered equal.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor224"/>Exercise 5.05: Currency Formatter</h2>
			<p>In this exercise, we will create a function that can take a numeric value parameter as a <strong class="source-inline">number</strong> or <strong class="source-inline">string</strong> and format it into a price value with two-decimal precision. In order to prepend a <strong class="source-inline">currency</strong> symbol, the function will accept it as a parameter. Let's get started:</p>
			<ol>
				<li value="1">Define your function signature. This function will accept two parameters. The first of these will be the decimal value and the second will be the currency symbol:<p class="source-code">function formatPrice(value, currency) {</p></li>
				<li>When executing, the first task that the function performs should be to validate the quality of the passed parameter values. The <strong class="source-inline">value</strong> parameter must be able to be converted into a numeric value, while the <strong class="source-inline">currency</strong> parameter should be a character <strong class="source-inline">string</strong>. If the <strong class="source-inline">currency</strong> is falsey, such as when no parameter has been passed, then we can default its value to the dollar symbol:<p class="source-code">  value = Number(value);</p><p class="source-code">  currency = currency || "$";</p></li>
				<li><a id="_idTextAnchor225"/>When responding to errors, there are many ways we can notify the caller that something went wrong. In this instance, we'll simply return <strong class="source-inline">null</strong>. This way, the caller will know that anything other than a <strong class="source-inline">string</strong> response means that something wasn't quite right:<p class="source-code">  if (Number.isNaN(value) || typeof currency != "string") {</p><p class="source-code">    return null;</p><p class="source-code">  }</p></li>
				<li>Now that we know the parameters are usable, combine them into the correct format and return the value:<p class="source-code">  return currency + value.toFixed(2);</p><p class="source-code">}</p></li>
				<li>If you go ahead and execute this function, you will see the appropriate responses:<p class="source-code">console.log( formatPrice(1.99, 32) ); // =&gt; null</p><p class="source-code">console.log( formatPrice(5, "£") ); // =&gt; £5.00</p><p class="source-code">console.log( formatPrice(9.9) ); // =&gt; $9.90</p><p class="source-code">console.log( formatPrice("Ted") ); // =&gt; null</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer126">
					<img alt="Figure 5.14: Exercise 5.05 output&#13;&#10;" src="image/C14377_05_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Exercise 5.05 output</p>
			<p>We can see the output once all four functions are run in the preceding figure. In this exercise, we created a function that took a numeric value parameter as a <strong class="source-inline">number</strong> or <strong class="source-inline">string</strong> and formatted it into a price value with two-decimal precision.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor226"/>Working with Strings</h1>
			<p>Like <strong class="source-inline">numbers</strong>, <strong class="source-inline">strings</strong> are simple immutable data types that are managed within the JavaScript runtime as a list of binary values, which are representable as characters. Since they are immutable, they cannot be altered. If you modify a <strong class="source-inline">string</strong>, using one of the various methods provided, you are actually creating a new string with the changes applied.</p>
			<p>The literal representation of strings is a list of characters surrounded by quotes. These quotes can be double quotes, single quotes (apostrophes), or backticks:</p>
			<p class="source-code">console.log( "I am a string" );</p>
			<p class="source-code">console.log( 'I am also a string' );</p>
			<p class="source-code">console.log( `I am a special string` );</p>
			<p>Strings can be thought of as a long list of single characters, much like arrays, which will be discussed later. As such, it is possible to query individual, or groups of, characters:</p>
			<p class="source-code">["H", "e", "l", "l", "o", ",", " ", "W", "o", "r", "l", "d", "!"]</p>
			<p>The preceding code is not a literal representation, but simply an analogy of how strings may be perceived. Since strings are lists, it is possible to retrieve characters from them using the character index. This is performed by enclosing the index with square bracket symbols. The index of a character string starts at <strong class="source-inline">0</strong> (zero):</p>
			<p class="source-code">"Hello, World!"[7];</p>
			<p class="source-code">// =&gt;   "W"</p>
			<p>Since strings are immutable, you cannot assign a replacement character to an index, like so:</p>
			<p class="source-code">var msg = "Hello, World!";</p>
			<p class="source-code">console.log( msg[7] = "Z" ); // =&gt; "Z"</p>
			<p class="source-code">msg; // =&gt;  "Hello, World!"</p>
			<p>It is not possible to modify a <strong class="source-inline">string</strong>. Instead, you can only create a new one based on the original. You can either reconstruct it using operators or use one of the many <strong class="source-inline">string</strong> functions provided by the <strong class="source-inline">String</strong> object, which will be described shortly.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor227"/>Special Characters</h2>
			<p>Since strings are contained in quotes, placing the same quotes within the string can be problematic. Simply typing the quote in the string is the same as terminating that string. This will then mean that any proceeding characters may be seen as malformed JavaScript code or, possibly worse, executable JavaScript code.</p>
			<p>One way to avoid terminating the <strong class="source-inline">string</strong> is to use a different quote to the type used to contain the <strong class="source-inline">string</strong>. For instance, if the string is contained in double quotes, then single quotes can be used freely. Likewise, containing the <strong class="source-inline">string</strong> in single quotes will allow double quotes to be used freely:</p>
			<p class="source-code">console.log( "I can contain 'single' quotes" );</p>
			<p class="source-code">console.log( 'I can contain "double" quotes' );</p>
			<p>This will work for simple text but is not as foolproof for strings that need to contain both quote types.</p>
			<p>The JavaScript language provides a means to <strong class="source-inline">escape</strong> characters included within strings so that they are treated differently. This is performed by preceding the character to escape with a backslash (<strong class="source-inline">\</strong>) character. In the case of quotes, escaping ensures that the quote character is not seen as the string termination character:</p>
			<p class="source-code">"It's useful to be able to \"escape\" quotes"</p>
			<p>The <strong class="source-inline">escape character</strong> can be used with several other characters for varying effects. It is even used to escape the escape character, for times when a backslash must exist within a <strong class="source-inline">string</strong>:</p>
			<p class="source-code">"This \\ will create a single backslash"</p>
			<p>Other supported escape characters include the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer127">
					<img alt="Figure 5.15: Escape Characters&#13;&#10;" src="image/C14377_05_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Escape Characters</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor228"/>Concatenation</h2>
			<p>Concatenating is a means of combining elements, end to end, to form a new element. With regards to strings, this is simply combining strings together to form a larger string.</p>
			<p>String concatenation is performed using the plus (<strong class="source-inline">+</strong>) symbol. This is known as method overloading:</p>
			<p class="source-code">"This string " + "and " + "this string " + "are concatenated";</p>
			<p class="source-code">// =&gt;  "This string and this string are concatenated"</p>
			<p>When concatenating strings, it is important to pay attention to the presence of space characters. No additional characters are added at the point of concatenation. Therefore, if you require spaces between combined strings, you must add these yourself.</p>
			<p>Since strings are immutable, concatenating strings creates a new string, which you can assign to a variable or pass as a parameter to a function. The original strings remain unaffected.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor229"/>Template Literals</h2>
			<p>Template literals are a more recent addition to the JavaScript language. Surrounding strings with backtick quotes (<strong class="source-inline">`</strong>) alter the translation of the literal by the JavaScript engine and afford some additional new features.</p>
			<p>The first interesting feature, and the one that's the most commonly used, is the ability to interpolate expressions within a <strong class="source-inline">string</strong>. This is performed by embedding blocks within the string preceded with the dollar (<strong class="source-inline">$</strong>) character. Combining strings in this fashion provides the benefit of making string literals easier to read, but can also greatly simplify more complex string concatenation requirements:</p>
			<p class="source-code">var str = `2 + 2 = ${2 + 2}`;</p>
			<p class="source-code">console.log( str ); // =&gt;  "2 + 2 = 4"</p>
			<p class="source-code">var name = "Jonny";</p>
			<p class="source-code">welcomeStr = `Hello, ${name}!`;</p>
			<p class="source-code">console.log( welcomeStr );  // =&gt; "Hello, Jonny!"</p>
			<p>Another useful feature of template literals is the ability to use physical line breaks. By applying line breaks to the JavaScript code, those same breaks appear within the resolved string:</p>
			<p class="source-code">var str = `This is line one</p>
			<p class="source-code">and this is line two`;</p>
			<p class="source-code">console.log( str );</p>
			<p class="source-code">// =&gt; "This is line one</p>
			<p class="source-code">// =&gt;  and this is line two"</p>
			<p>Finally, a template expression can contain inner template literals within it too, thereby providing a nested template literal implementation. You'll see them in the next example. This caters to more complex expressions within the <strong class="source-inline">string</strong> itself, such as conditionals or loops.</p>
			<p>The result of template literals is a feature within JavaScript that lends itself very nicely to processing pages, and other string data content, in a manner that is more manageable. Where JavaScript developers once looked toward third-party libraries to perform such feats, such libraries are no longer required.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor230"/>Exercise 5.06: Email Templates</h2>
			<p>In this exercise, you will create a function that accepts the components of an email sending service and combines them into an email body template. To make things more interesting, only adults are eligible to post comments on the website. Accordingly, the message text will change. Let's get started:</p>
			<ol>
				<li value="1">Start off by creating a function signature. The parameters of the function determine the values that can be entered into the email body. As stated in the description, we will require an <strong class="source-inline">age</strong> parameter:<p class="source-code">function sendEmail(name, age, comments) {</p></li>
				<li>With this in place, check the passed parameters now. If any are invalid, the function will simply return <strong class="source-inline">null</strong>:<p class="source-code">  var age = Number(age);</p><p class="source-code">  if (Number.isNaN(age)</p><p class="source-code">  || typeof name != "string"</p><p class="source-code">  || typeof comments != "string") {</p><p class="source-code">    return null;</p><p class="source-code">  }</p><p>Here, we're checking whether the number can be used as a valid numerical value and whether the <strong class="source-inline">name</strong> and <strong class="source-inline">comments</strong> are <strong class="source-inline">strings</strong>. We could also choose to check the length of the strings to ensure they have content, but that is not necessary for this exercise.</p></li>
				<li>Now that we have valid parameters, we'll need to create our <strong class="source-inline">body</strong> text with the alluded-to nested template expression:<p class="source-code">  var body = `A user has posted a comment from the website:</p><p class="source-code">  name: ${name}</p><p class="source-code">  age: ${age}</p><p class="source-code">  status: ${(age &lt; 18) ? `${name} is not a valid user` : `${name} is a valid  user`}</p><p class="source-code">  comments: ${comments}`;</p><p>As you can see, a <strong class="source-inline">ternary</strong> operator expression is used to populate the content of the interpolation in the <strong class="source-inline">status</strong> line. It would also be possible to invoke a function here, but it would not have been acceptable to use an actual <strong class="source-inline">if</strong> condition. The reason for this is that an <strong class="source-inline">if</strong> condition is composed of one or more blocks, which is not accepted in template interpolation syntax.</p></li>
				<li>Finally, we can close the function by returning the variable. If you now execute the function and pass in some arbitrary parameters, you should see the complete interpolated string:<p class="source-code">  return body;</p><p class="source-code">}</p><p class="source-code">sendEmail("Jane", 27, "Your website is fantastic!");</p><p class="source-code">// =&gt;  "A user has posted a comment from the website:</p><p class="source-code">// =&gt;  name: Jane</p><p class="source-code">// =&gt;  age: 27</p><p class="source-code">// =&gt;  status: Jane is a valid user</p><p class="source-code">// =&gt;  comments Your website is fantastic!"</p></li>
			</ol>
			<p>The expected output will be as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer128">
					<img alt="Figure 5.16 – Exercise 5.06 output&#13;&#10;" src="image/C14377_05_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: Exercise 5.06 output</p>
			<p>How and where you choose to concatenate or interpolate strings is up to you. When tackling a problem, consider whether the code is more readable using one form of quotation over another, especially if more than one developer will be working with the code.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor231"/>The String Object</h1>
			<p>Like number values, character strings also come with a useful object called the String object. Similarly, the String object provides numerous functions, methods, and properties oriented around strings.</p>
			<p>Also similar to the <strong class="source-inline">Number</strong> object is the <strong class="source-inline">String</strong> function, which converts any passed value into a <strong class="source-inline">string</strong>. The <strong class="source-inline">String</strong> function works by calling the value's <strong class="source-inline">toString</strong> function, which we'll discuss a little later.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor232"/>The length Property</h2>
			<p>The <strong class="source-inline">String</strong> object, and thus strings themselves, have only one property: the <strong class="source-inline">length</strong> property. As the name suggests, the <strong class="source-inline">length</strong> property returns the <strong class="source-inline">length</strong> of the <strong class="source-inline">string</strong> as an <strong class="source-inline">integer</strong>. As the indexing of a <strong class="source-inline">string</strong> starts at zero, the length is always one more than the last character index:</p>
			<p class="source-code">"Hello, World!".length;</p>
			<p class="source-code">// =&gt;  13</p>
			<p>The <strong class="source-inline">length</strong> property is particularly useful for iterating over the <strong class="source-inline">string</strong>, or when working with many of the <strong class="source-inline">string</strong> methods when its <strong class="source-inline">length</strong> is not already known.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor233"/>String Methods</h2>
			<p>The <strong class="source-inline">String</strong> object does not have any <strong class="source-inline">static</strong> functions, but it does support strings with numerous available methods – far more than those available in the <strong class="source-inline">Number</strong> object. This chapter will not attempt to cover them all but will look at the more useful methods.</p>
			<p>Working with and manipulating strings is a common requirement in JavaScript; not just for displaying text, but for working with data in general. It is often necessary to clip, sort, modify, add, and remove segments of strings using varying criteria. As such, JavaScript provides just about every method you could think of to make these tasks simple.</p>
			<p>T<a id="_idTextAnchor234"/>he following table lists the most commonly used methods that are provided by the String object:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer129">
					<img alt="Figure 5.17: String Methods&#13;&#10;" src="image/C14377_05_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17: String Methods</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor235"/>Exercise 5.07: Sentence Reversal</h2>
			<p>In this exercise, you will create a function that accepts a string of any size, trims any whitespace characters, reverses its content, and then capitalizes the first character of the string or of those following a period character. The result should look like a normal sentence from a reversed dimension. The purpose of the exercise is to understand data transformation. Transforming data is ubiquitous in software development. The JavaScript runtime transforms data when it reads your code and converts it into a running application. Being able to transform data in a simple manner will prove to be a valuable skill. Let's get started:</p>
			<ol>
				<li value="1">Start off with the function signature. We only want to accept a single parameter, which we'll call <strong class="source-inline">str</strong>; this is an abbreviation of "string":<p class="source-code">function reverse(str) {</p></li>
				<li>Next, perform the simplest task first, that is, removing any trailing whitespace characters from the beginning and end of the string. While doing this, you should also ensure that you are actually working with a string value:<p class="source-code">  str = String(str).trim();</p></li>
				<li>With the parameter prepared, you should now start a loop. The loop will build a new string by walking the parameter string in reverse. Therefore, you will also need to declare four additional variables, namely, a temporary variable to hold the resulting value, a variable to keep track of the current string index, a variable to store the current character, and a variable to keep track of whether the next non-whitespace character is at the start of a sentence:<p class="source-code">  var result = "", index = str.length - 1, chr, isStart = true;</p><p class="source-code">  while (index &gt;= 0) {</p><p>In the preceding code, we ensure that the counter starts at one less than the <strong class="source-inline">length</strong> of the string (the last index of the string) and that the loop iterates as long as the counter is greater than or equal to <strong class="source-inline">0</strong> (zero).</p></li>
				<li>With the loop in progress, store the character at the index into the <strong class="source-inline">chr</strong> variable:<p class="source-code">    chr = str[index];</p></li>
				<li>With the character stored, check whether the previous iteration is found at the end of a sentence. If it was, then you will need to uppercase the next non-whitespace character. Otherwise, you will need to <strong class="source-inline">lowercase</strong> it:<p class="source-code">    if (isStart &amp;&amp; chr != " ") {</p><p class="source-code">      chr = chr.toUpperCase();</p><p class="source-code">      isStart = false;</p><p class="source-code">    } else {</p><p class="source-code">      chr = chr.toLowerCase();</p><p class="source-code">    }</p><p>If the character is the start of a sentence, then the <strong class="source-inline">isStart</strong> flag needs to be set back to <strong class="source-inline">false</strong> so that the next iteration doesn't repeat the uppercasing.</p></li>
				<li>Since the uppercasing occurred for the previous iteration, check whether you should flag a new sentence in this iteration:<p class="source-code">    if (chr == ".") {</p><p class="source-code">      isStart = true;</p><p class="source-code">      if (index == str.length - 1) {</p><p class="source-code">        index--;</p><p class="source-code">        continue;</p><p>You detect the start of a new sentence by checking for the period character. If it is the start of a new sentence, then you set the <strong class="source-inline">isStart</strong> flag, but you also need to determine whether this is the very end of the original string. The reason for this is that you do not want to copy the last period of the original string to the start of the new string, or the result will start with a period, which will not make sense. If it is, you simply skip the character altogether by decrementing the <strong class="source-inline">index</strong> and continuing the loop.</p></li>
				<li>If the period was not at the end of the original string, make some adjustments. You will not want the new sentences to end with a space and then a period – you will require the reversal of that. Since the space will have already been applied to the result, you need to backtrack by one character and re-add the required output. As the result string has now been modified, you will need to continue to the next iteration once more:<p class="source-code">      } else {</p><p class="source-code">        result = result.substr(0, result.length-1) + ". ";</p><p class="source-code">        index--;</p><p class="source-code">        continue;</p><p class="source-code">      }</p><p class="source-code">    }</p></li>
				<li>If the loop does not continue, then the current iteration results in a regular character, which should simply be appended to the result. Decrement the index for the next iteration and close out the loop. End the function by returning the result to the caller:<p class="source-code">     result = result + chr;</p><p class="source-code">     index--;</p><p class="source-code">  }</p><p class="source-code">  return result + ".";</p><p class="source-code">}</p></li>
				<li>Now, go ahead and execute the function. Try passing multiple sentences to it inside a single string to see the full result:<p class="source-code">reverse("This is the first sentence. This is the second.");</p><p class="source-code">// =&gt;  "Dnoces eht si siht. Ecnetnes tsrif eht si siht."</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer130">
					<img alt="Figure 5.18 – Exercise 5.07 output&#13;&#10;" src="image/C14377_05_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18: Exercise 5.07 output</p>
			<p>There you have it. You have just created a string manipulation function using methods from the <strong class="source-inline">String</strong> global object. Certainly, the function will not win any awards and may not work well if provided with strings containing consecutive whitespace characters, but it does work.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor236"/>The toString Method</h2>
			<p>Every primitive type in JavaScript can be converted into a string using the <strong class="source-inline">String</strong> function. When working with more complex types, however, this is not always the case. For instance, with a typical object, converting it into a <strong class="source-inline">string</strong> will produce a set result, regardless of the object's content:</p>
			<p class="source-code">var obj = {name: "Bob"};</p>
			<p class="source-code">String(obj);</p>
			<p class="source-code">// =&gt;  "[object Object]"</p>
			<p>The reason for this is that the JavaScript engine doesn't understand how you wish the data to be parsed. It could simply be that you require the output to form a table of keys and values, or you may simply want a list of the values themselves and to discard the keys. The possibilities are endless.</p>
			<p>As such, JavaScript provides the concept of the <strong class="source-inline">toString</strong> value method.</p>
			<p><strong class="source-inline">toString</strong> is a method that exists on all data types but is required to be overridden on some of the complex types, providing that you have your own parsing logic. When calling the <strong class="source-inline">String</strong> function and passing it a value, you are in fact invoking the <strong class="source-inline">toString</strong> method on that value:</p>
			<p class="source-code">console.log( String(99) );</p>
			<p class="source-code">// =&gt;   "99"</p>
			<p class="source-code">console.log(  (99).toString() ); // See above about invoking methods on integer literals</p>
			<p class="source-code">// =&gt;  "99"</p>
			<p class="source-code">console.log( [1, 2, 3].toString() );</p>
			<p class="source-code">// =&gt;  "[1, 2, 3]"</p>
			<p>Overriding the <strong class="source-inline">toString</strong> method is simply a case of supplying an alternative function of the same name to the data value. For instance, to override the <strong class="source-inline">toString</strong> method in a custom object, you could simply do the following:</p>
			<p class="source-code">var obj = {ted: "bob", toString: function() { return "I am Bob!" }};</p>
			<p class="source-code">obj.toString();</p>
			<p class="source-code">// =&gt;  "I am Bob!"</p>
			<p class="source-code">String(obj);</p>
			<p class="source-code">   "I am Bob!"</p>
			<p>Working with complex objects and object functions will be described fully later in this chapter.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor237"/>Numbers with Strings</h2>
			<p><strong class="source-inline">Numbers</strong> and <strong class="source-inline">strings</strong> are both primitive data types and both overload the <strong class="source-inline">+</strong> (addition) operator. However, there is much more of a relationship between the two that can prove useful or catch you out if you are not careful.</p>
			<p>Interestingly, numbers and strings in JavaScript can often be interchangeable, thanks to an intelligent context-based system. Depending on the circumstances, JavaScript will attempt to deduce the resulting type of an expression based on the available parameters.</p>
			<p>You have already seen that strings can be concatenated using the <strong class="source-inline">+</strong> operator, but numbers can also be concatenated into strings:</p>
			<p class="source-code">"I am " + 21 + " years old";</p>
			<p class="source-code">// =&gt;  "I am 21 years old"</p>
			<p>When the JavaScript parser identifies a numeric value and a string value passed as expressions to the <strong class="source-inline">+</strong> operator, it will convert the number into a string so that the result is a simple string concatenation. This is otherwise known as context-based casting.</p>
			<p>When the string expression is also a representation of a numerical value and is used with other numerical associated operators, such as <strong class="source-inline">/</strong> or <strong class="source-inline">*</strong>, the reverse action will occur. At such times, JavaScript's context-based casting will instead convert the string number into an actual number. Here's an example:</p>
			<p class="source-code">"42.7" * 2;</p>
			<p class="source-code">// =&gt;  85.4</p>
			<p>JavaScript will always convert the non-string value into a string when we use the <strong class="source-inline">+</strong> operator in order to produce an expected result. It would be too confusing if the <strong class="source-inline">+</strong> operator worked differently based on the content of the string expression.</p>
			<p>Numbers can also be mathematically calculated when both expressions are a string, but again, this will only occur if you're not utilizing the <strong class="source-inline">+</strong> operator:</p>
			<p class="source-code">console.log( "10" * "10" );</p>
			<p class="source-code">// =&gt;  100</p>
			<p class="source-code">console.log( "10" + "10" );</p>
			<p class="source-code">// =&gt;  "1010"</p>
			<p>If it is expected that you will need to add together two numbers represented as strings, such as values read from text input fields, always convert them into numbers first:</p>
			<p class="source-code"> Number("10") + Number("10");</p>
			<p class="source-code">// =&gt;  20</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor238"/>Working with Functions</h1>
			<p>As you've already seen, JavaScript functions are blocks of code with signatures naming the variables that were passed to them when invoked. As with any block, functions have their own stacks that encapsulate and protect data declared within them.</p>
			<p>In JavaScript, functions are considered first-class types. This means that, much like any other type, they can be assigned to variables, passed as parameters to other functions, and returned from functions. They are also able to call themselves, which is known as recursive and is the quality that helps make JavaScript a functional language.</p>
			<p>There are many forms of function in JavaScript:</p>
			<ul>
				<li>Anonymous functions</li>
				<li>Named functions</li>
				<li>Arrow functions</li>
				<li>Generator functions</li>
			</ul>
			<p>The differences between them are mostly slight syntactical changes that affect how they are used. We will briefly cover each of the function types in this chapter.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor239"/>Anonymous Functions</h2>
			<p>Since functions in JavaScript are first class, they exist as a transferable resource, much like primitives and objects. Until now, functions have been declared and assigned, which means they have a callable name.  However, a function is also an expression with two states: its <strong class="source-inline">declared format</strong> and its <strong class="source-inline">invocation</strong>.  </p>
			<p>A function can exist without providing a name in the signature, whereby it has the following format:</p>
			<p class="source-code">function (...parameters) {</p>
			<p class="source-code">   ...body</p>
			<p class="source-code">}</p>
			<p>In JavaScript, it is possible to code a function without providing a name at declaration time. Creating functions in this way allows them to be created in place, such as in a call to another function:</p>
			<p class="source-code">otherFunction( function(a, b) { /* do something */ } );</p>
			<p>Functions can also be assigned to variables and, of course, be received as parameters in a function call. Once an anonymous function has been assigned to a variable, it becomes a named <strong class="source-inline">function</strong>, since the variable constitutes its name:</p>
			<p class="source-code">var echo = function(subject) { console.log(subject); };</p>
			<p class="source-code">echo("Hello, World!");</p>
			<p class="source-code">// =&gt;  "Hello, World!"</p>
			<p>In fact, up until now, you have been writing functions with a global scope. Declaring a named function simply means that a variable of the same name will be declared in the current scope and will point to that function.  For instance, the following two syntaxes are equivalent:</p>
			<p class="source-code">var myFunc = function(i) { return i + 1; };</p>
			<p class="source-code">function myFunc(i) { return i + 1; };</p>
			<p>Declaring a function without assigning a name can be considered a function literal. Since the function exists at the point of definition, it can also be executed in place. How could that be useful? It can encapsulate entire programs and avoid dirtying the global namespace:</p>
			<p class="source-code">( function(a, b) { console.log(a + b); }</p>
			<p class="source-code">)(2, 4);</p>
			<p class="source-code">// =&gt;  6</p>
			<p>Namespace dirtying is a term to describe functions and variables declared globally. While doing so is not disallowed, it can be problematic. If two libraries within the same web page create global variables of the same name, there can be unexpected results. Creating applications that honor a clean global environment will be discussed in a later chapter.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor240"/>Callbacks</h2>
			<p>An important use case for anonymous functions has often been asynchronous execution callbacks. When calling code that does not immediately return a value, but also does not stop the execution of code that immediately proceeds it, that code is considered <strong class="source-inline">asynchronous</strong>.</p>
			<p>Applications that contain asynchronous code need a means to alert the rest of the application once the asynchronous code has finished running and a value must be returned. In JavaScript, callbacks have long been used for this purpose:</p>
			<p class="source-code">function doSomethingAsync(data, callback) {</p>
			<p class="source-code">  async_task(data).then(    // do async request</p>
			<p class="source-code">    function(result) {    // then on return</p>
			<p class="source-code">      callback(result);    // execute callback, passing result data!</p>
			<p class="source-code">    }</p>
			<p class="source-code">   );</p>
			<p class="source-code">   //.. continue with other code ..</p>
			<p class="source-code">}</p>
			<p>The issue with callbacks is that should numerous asynchronous calls need to occur sequentially, the resulting code file has a tendency to indent catastrophically. This issue is sometimes fondly known as the pyramid of doom or callback hell:</p>
			<p class="source-code">asyncOne(data, function(res1) {</p>
			<p class="source-code">  asyncTwo(res1, function(res2) {</p>
			<p class="source-code">    asyncThree(res2, function(res3) {</p>
			<p class="source-code">      //... ad infinitum ..</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>As you can see, each new request indents a further two characters. It is not uncommon for an application to possess callback chains of several tens of requests, thereby reaching the far side of the screen while coding. Developers can choose not to indent, as indentation is not a requirement, but not doing so results in harder-to-read code. To resolve this, generator functions were introduced. You will learn more about generator functions later in this chapter.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor241"/>Exercise 5.08: Functional Parameters</h2>
			<p>In this exercise, you will create a function that accepts two parameters: a primitive data type and a function. This function will then combine those parameters and return a function as a result. The returned function will work identically to the function that was passed as a parameter, with the exception that it will always receive the original primitive parameter as its argument. Let's get started:</p>
			<ol>
				<li value="1">Start off by creating the function signature. You know that it will accept two parameters and, since it will act as a kind of currying process (a term used in functional programming), that's the name that will be used here:<p class="source-code">function curry(prim, fun) {</p><p>There is nothing special here. The <strong class="source-inline">curry</strong> function is just like any named function.</p><p>In this circumstance, it's not important what value the first parameter contains. Even if it contained <strong class="source-inline">null</strong>, that would still be valid in this instance, so you can accept whatever comes through. </p></li>
				<li>Now, check if the second parameter is a function. Otherwise, when it is invoked, an error may occur if it is some other value type:<p class="source-code">  if (typeof fun != "function") return;</p></li>
				<li>Now for the fun part. The intention is to always populate the parameter list of the passed-in function with the first parameter of this function, however many times it is called. To do this, use a local function definition:<p class="source-code">  var ret = function() {</p><p class="source-code">    return fun(prim);</p><p class="source-code">  };</p><p>As you can see, the result here is a function that, whenever it is called, will simply call the <strong class="source-inline">fun</strong> function. The <strong class="source-inline">prim</strong> parameter will always remain the same here, so the invocation will always produce the same result.</p></li>
				<li>Now, return the new function:<p class="source-code">  return ret;</p><p class="source-code">}</p></li>
				<li>Let's give this a spin. Try calling the function while trying different values as parameters:<p class="source-code">var fun = function(val) { return val + 50 };</p><p class="source-code">var curry1 = curry(99, fun);</p><p class="source-code">console.log( curry1() );</p><p class="source-code">// =&gt;  149</p><p class="source-code">console.log( curry1() );</p><p class="source-code">// =&gt;  149</p><p class="source-code">// calling curry1 will produce the same output however many times </p><p class="source-code">// it is called, because it is a fixed, pure function.</p><p class="source-code">var curry2 = curry("Bob", fun);</p><p class="source-code">console.log( curry2() );</p><p class="source-code">// =&gt;  "Bob50"</p><p>The expected output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer131">
					<img alt="Figure 5.19 – Exercise 5.08 output&#13;&#10;" src="image/C14377_05_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19: Exercise 5.08 output</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor242"/>Arrow Functions</h2>
			<p>Arrow functions, sometimes called <strong class="source-inline">fat arrow</strong> functions, are a simplified syntax for function declaration:</p>
			<p class="source-code">var myFun = (param) =&gt; param + 1;</p>
			<p>As shown in the preceding example, arrow functions don't need to provide a block of code and can instead be replaced with an expression. If an expression is used, then no <strong class="source-inline">return</strong> keyword is required since expressions already return a value. However, the <strong class="source-inline">return</strong> keyword is required if a block is used, since blocks are not expressions:</p>
			<p class="source-code">var myFun = (param) =&gt; {</p>
			<p class="source-code">  return param + 1;</p>
			<p class="source-code">};</p>
			<p>As well as functioning without a block, arrow functions can also be declared without the parentheses surrounding the parameter list:</p>
			<p class="source-code">var myFun = param =&gt; param + 1;</p>
			<p>However, the preceding code only works if the parameters are a list of one. This is because a list of two or more parameters forms a rather ambiguous statement. For instance, consider the following:</p>
			<p class="source-code">var myFun = a, b, c =&gt; a + b + c;</p>
			<p>When reading the preceding declaration, the compiler will not know which of the following declaration strings you are trying to achieve:</p>
			<p class="source-code">var myFun = a, b = undefined, (c) =&gt; { return a + b + c };</p>
			<p class="source-code">var myFun = a, (b, c) =&gt; { return a + b + c };</p>
			<p class="source-code">var myFun = (a, b, c) =&gt; { return a + b + c };</p>
			<p class="callout-heading">Note </p>
			<p>The first two examples will give an error since they attempt to define an arrow function in a <strong class="source-inline">var</strong> statement, but without being assigned to a variable.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor243"/>Arrow Function Caveats</h2>
			<p>While arrow functions appear much cleaner and more flexible than regular function declarations, there are disadvantages to their use. The first disadvantage is that arrow functions cannot be used as an object constructor and it's ill-advised to use them as object methods. The reason for this has to do with the second limitation; arrow functions have no access to their own this, arguments, or super objects (discussed later in this chapter).</p>
			<p>The purpose of arrow functions is simply to enable a cleaner syntax when working with anonymous functions. Arrow functions were the first syntactical weapon against callback hell, which we described previously. As such, arrow functions should be used wisely.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor244"/>Generator Functions</h2>
			<p>Generators are a recent and rather complex addition to the JavaScript language. They are incredibly useful functions once you begin to understand them, though that may take some effort. Generators do not facilitate any means that cannot be carried out in some other fashion within the JavaScript language. As such, this section will merely touch upon the subject of generator functions in order to alert you to their usefulness.</p>
			<p>Generators provide additional power to sequence iteration. Here's an example:</p>
			<p class="source-code">for (let i = 0; i &lt; 3; i++) {</p>
			<p class="source-code">  callback(i);</p>
			<p class="source-code">};</p>
			<p>The preceding code is an iterator. The loop iterates three times, from <strong class="source-inline">0</strong> to <strong class="source-inline">2</strong>. Each time the iteration occurs, the <strong class="source-inline">callback</strong> function is called, and the iteration result is passed to it.</p>
			<p>Now, the problem with loops is that they are a closed stack. For any custom code to execute within the loop, the loop needs to have knowledge of what to do with the iterated data. This is a restriction that generators aim to overcome.</p>
			<p>Generator functions are declared much like named and anonymous functions, but with a slight difference; an asterisk must be placed after the <strong class="source-inline">function</strong> keyword:</p>
			<p class="source-code">var myFun = function*(params) { /*body*/ };</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The arrow function format cannot be used for generator functions.</p>
			<p>When creating the function body, the same rules for named and anonymous functions apply. However, there are some differences. Take a look at the following example, based on the preceding loop:</p>
			<p class="source-code">var myFun = function*() {</p>
			<p class="source-code">  for (let i = 0; i &lt; 3; i++) {</p>
			<p class="source-code">    yield i;</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>In particular, note the <strong class="source-inline">yield</strong> keyword. <strong class="source-inline">yield</strong> is a keyword that's been borrowed from multithreaded languages such as C++. Its usage in those languages is similar to its usage here. Essentially, by calling <strong class="source-inline">yield</strong>, you are asking the runtime engine to pass control back to the caller. In JavaScript, "passing back of control" includes sending a value to the caller. In the preceding example, a value will be sent each time the function yields, which will be three times in total.</p>
			<p>To use the function, you must create an instance of the generator by invoking the function:</p>
			<p class="source-code">var myGen = myFun();</p>
			<p>Once you have a generator instance, you can acquire a value:</p>
			<p class="source-code">var firstValue = myGen.next().value;</p>
			<p class="source-code">console.log( firstValue );  // firstValue will equal 0;</p>
			<p>You can call the <strong class="source-inline">next</strong> function many times, until the stream is exhausted. Once exhausted, the returned value will be undefined:</p>
			<p class="source-code">console.log(myGen.next().value);</p>
			<p class="source-code">// =&gt;   1</p>
			<p class="source-code">console.log(myGen.next().value);</p>
			<p class="source-code">// =&gt;  2</p>
			<p class="source-code">console.log(myGen.next().value);</p>
			<p class="source-code">// =&gt;  undefined</p>
			<p>The return value of the <strong class="source-inline">next()</strong> function is an object with two fields:</p>
			<p class="source-code">{value: &lt;value&gt;, done: &lt;boolean&gt;}</p>
			<p>The <strong class="source-inline">object</strong> is hidden from the previous examples and we simply return the value in order to keep things simple. The done value will return true as long as there are more yields to return from the generator. Once the generator is exhausted, it will return the following for all successive calls to <strong class="source-inline">next()</strong>:</p>
			<p class="source-code">{value: undefined, done: true}</p>
			<p>One point to keep in mind is that the <strong class="source-inline">yield</strong> keyword may be called as many times as necessary in the <strong class="source-inline">generator</strong> function. In the previous example, the <strong class="source-inline">yield</strong> keyword was used in a loop, but it may just as easily be called elsewhere, too:</p>
			<p class="source-code">var myFun = function*() {</p>
			<p class="source-code">  var count = 0</p>
			<p class="source-code">  for (let i = 0; i &lt; 3; i++) {</p>
			<p class="source-code">    yield i;</p>
			<p class="source-code">    count += i;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  yield count;</p>
			<p class="source-code">};</p>
			<p>Generator functions may also use the <strong class="source-inline">return</strong> keyword. If <strong class="source-inline">return</strong> is used, then the returned value will be retrieved with a call to <strong class="source-inline">next()</strong>, just like yielded values. However, calling return will end the generator, meaning that no more values will be returned from calls to <strong class="source-inline">next()</strong>, even if further <strong class="source-inline">yield</strong> keywords exist in the function.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor245"/>The this Keyword </h2>
			<p>All functions, apart from arrow functions, have access to additional objects related to the functions' stack. As we mentioned previously, functions provide a stack that ring-fences the memory that's used by variables that are declared within it, while allowing access to variables declared in the functions or blocks surrounding the function being called. This is otherwise known as encapsulation and protects the outer stacks from being inadvertently corrupted by function body-related processes, while also protecting the data within the function from outside processes.</p>
			<p>The <strong class="source-inline">this</strong> keyword exists as a means to be able to directly target the context present within the execution of the function. While the variables that are declared within a function are direct members of the functions stack, the context of the function body may specifically be that of another block or object and may even be changed at invocation time to be a specific context other than the one the function is defined within:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer132">
					<img alt="Figure 5.20: Global, object, and function diagram&#13;&#10;" src="image/C14377_05_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: Global, object, and function diagram</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor246"/>The arguments Keyword </h2>
			<p>Another keyword that's available to functions is the <strong class="source-inline">arguments</strong> keyword. When defining a function signature, the parameters listed within the brackets of the signature are known as "named parameters" while the values that are passed to the function during invocation are considered the "functions arguments". Named parameters map to arguments, where possible, during the execution of the function.  </p>
			<p>When calling a function, you may pass in as many or as few arguments as you like, but they do not need to total the number of parameters listed in the function signature. If you specify fewer parameters than are named in the function signature, those parameters that are not provided for will simply have a value of undefined:</p>
			<p class="source-code">function myFun(param1, param2) {</p>
			<p class="source-code">  console.log(param1, param2);</p>
			<p class="source-code">};</p>
			<p class="source-code">myFun(99);</p>
			<p class="source-code">// =&gt;  99, undefined</p>
			<p>If,<a id="_idTextAnchor247"/> on the other hand, you specify more parameters than are listed for that function, those parameters are still made available to the function, despite not having enough named parameters; they are simply not named. In such circumstances, you can access the additional parameters using the arguments keyword.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">arguments</strong> keyword is very much like an array. You can access it like an array, and you can use it in functions that expect an array. It even has built-in array-like functions. However, the <strong class="source-inline">arguments</strong> keyword is not an array.</p>
			<p>To access additional function parameters, you can target them specifically by index against the <strong class="source-inline">arguments</strong> keyword. For instance, if four arguments were passed to the function, you could access the <strong class="source-inline">fourth</strong> argument with the following code:</p>
			<p class="source-code">var someValue = arguments[3];</p>
			<p>As you'll see later with arrays, you can find out just how many arguments were passed to the function invocation by calling the <strong class="source-inline">length</strong> property:</p>
			<p class="source-code">var numParams = arguments.length;</p>
			<p>The <strong class="source-inline">arguments</strong> object can be extremely useful when working with functions of a more dynamic nature.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor248"/>Call and Apply</h2>
			<p>As we mentioned previously, JavaScript is an exceptionally flexible language. Since functions are first-class citizens in JavaScript, facilities are provided by the language to manipulate functions.</p>
			<p>Two of the most commonly used tools for this endeavor are <strong class="source-inline">call</strong> and <strong class="source-inline">apply</strong>.</p>
			<p>Both <strong class="source-inline">call</strong> and apply function in very much the same way: by enabling the invocation of functions while changing the function stack's context. </p>
			<p>The differences between <strong class="source-inline">call</strong> and <strong class="source-inline">apply</strong> are simply that <strong class="source-inline">call</strong> is solely used to manipulate the invoked functions context and <strong class="source-inline">apply</strong> is used for the same thing and also to supply an arbitrary number of arguments:</p>
			<p class="source-code">var fun = function () { return arguments.length; };</p>
			<p class="source-code">fun.call(this, 1, 2, 3);</p>
			<p class="source-code">// =&gt;  3</p>
			<p class="source-code">fun.apply(this, [1, 2, 3]);</p>
			<p class="source-code">// =&gt;  3</p>
			<p>As you can see, to use <strong class="source-inline">call</strong>, you need to know the number of arguments at development time. The arguments that are used in <strong class="source-inline">apply</strong> can be of any <strong class="source-inline">length</strong> and do not have to be known.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor249"/>Exercise 5.09: Dynamic Currying</h2>
			<p>This exercise will be a continuation of the previous exercise. Since you now know much more about how functions work in JavaScript, we will take the <strong class="source-inline">curry</strong> concept to a much higher level by supporting arbitrary numbers of arguments. Let's get started:</p>
			<ol>
				<li value="1">Start off with your <strong class="source-inline">function</strong> signature. However, since you would like to support an arbitrary number of arguments, the function parameter will need to come first. Also, as the remaining parameters are <strong class="source-inline">arbitrary</strong>, there is no need to define them:<p class="source-code">var curry = function(fun) { </p><p>Check that the first parameter is a <strong class="source-inline">function</strong> before continuing with the rest of the logic:</p><p class="source-code">  if (typeof fun != "function") return;</p></li>
				<li>As you may have guessed, you will use the arguments object to acquire the parameters. However, you will need to manipulate the arguments list since you will not want to pass the function parameter to itself. As we mentioned previously, the <strong class="source-inline">arguments</strong> object is not an array, so you'll need to convert it into one first by manipulating it with an <strong class="source-inline">array</strong> function:<p class="source-code">  var args = Array.prototype.slice.call(arguments);</p><p class="source-code">  args.shift();</p><p>In order to convert <strong class="source-inline">arguments</strong> into an <strong class="source-inline">array</strong>, you need to call a native function of <strong class="source-inline">array</strong> instances that copies the array. The <strong class="source-inline">slice</strong> function creates a shallow copy of an array. In this case, it doesn't know that the <strong class="source-inline">arguments</strong> object is not an array, but still works fine, which is perfect for this use case. The <strong class="source-inline">args.shift()</strong> code removes the first item in the array using the newly created array's shift function. Since arrays are mutable, like objects, the <strong class="source-inline">args</strong> array value is permanently modified.</p></li>
				<li>Now that you have your parameters list, create your function wrapper, like you did previously. This time, however, the <strong class="source-inline">fun</strong> parameter will be invoked using <strong class="source-inline">apply</strong>:<p class="source-code">  var ret = function() {</p><p class="source-code">    var nested_args = Array.prototype.slice.call(arguments);</p><p class="source-code">    return fun.apply(this, args.concat(nested_args));</p><p class="source-code">  }</p><p>Since parameters will be supplied to the <strong class="source-inline">curry</strong> function and the returned function, the arguments of each must be joined into a single array. This is what <strong class="source-inline">concat</strong> does. The resulting array is then used as the arguments of the <strong class="source-inline">fun</strong> function.</p></li>
				<li>Finally, return the new function and close the <strong class="source-inline">curry</strong> function:<p class="source-code">  return ret;</p><p class="source-code">}</p></li>
				<li>Now, let's give this a spin:<p class="source-code">var<a id="_idTextAnchor250"/> fun = function() { return arguments.length; };</p><p class="source-code">var cur1 = curry(fun, 1, 2, 3);</p><p class="source-code">console.log( cur1(4, 5, 6) );</p><p class="source-code">// =&gt;  6</p><p class="source-code">var cur2 = curry(fun, 1, 2, 3, 4, 5, 6);</p><p class="source-code">console.log( cur2(9, 8, 7, 6, 5) );</p><p class="source-code">// =&gt;  11</p><p>The expected output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer133">
					<img alt="Figure 5.21: Exercise 5.09 output&#13;&#10;" src="image/C14377_05_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: Exercise 5.09 output</p>
			<p>What you have just achieved is no small feat. <strong class="source-inline">Currying</strong> is a powerful tool in functional programming, and you have achieved this task with very few lines of code.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor251"/>Activity 5.01: Simple Number Comparison</h2>
			<p>A lot has been covered so far, so it's time for an activity. In this activity, you have been tasked with writing a function that will receive the grades for a student's coursework for an entire year as percentages. The function must average the result of each grade in order to determine whether the student has passed the course for the entire year. The calculation will assume the following:</p>
			<ul>
				<li>An average below 35% is an F grade.</li>
				<li>An average of 35 – 44% is a D grade.</li>
				<li>An average of 45% – 59% is a C grade.</li>
				<li>An average of 60% – 74% is a B grade.</li>
				<li>An average of 75% and over is an A grade.</li>
			</ul>
			<p>Grades for each coursework assignment may be passed as a <strong class="source-inline">Number</strong> or a <strong class="source-inline">String</strong>. No other data type is expected, so error handling is not necessary.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create a function. Argument labels aren't necessary as we won't know how many arguments there will be.</li>
				<li>Extract the arguments for the function.</li>
				<li>Get the number of arguments that were passed and store it as a variable.</li>
				<li>Add all the arguments together and calculate the average. Store this in a variable.<p class="callout-heading">Note </p><p class="callout">The final condition will always be true if the others have failed, so the condition itself can be skipped. Each condition will not be evaluated if the previous condition has been returned from the function.</p></li>
				<li>Determine the <strong class="source-inline">grade</strong> from the student based on the <strong class="source-inline">average</strong> and return it.<p class="callout-heading">Note </p><p class="callout">The solution to this activity can be found on page 724. </p></li>
			</ol>
			<p>This activity should highlight the flexibility and simplicity of common problem-solving using JavaScript functions and data types. There are, in fact, many ways to solve this problem, but attempting this in a logical, easy-to-read manner is always preferable.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor252"/>Working with Objects</h1>
			<p>In <a id="_idTextAnchor253"/>JavaScript, objects are the primary configurable data structures from which all other complex data types extend, including <strong class="source-inline">Array</strong> and <strong class="source-inline">Date</strong>. Objects work like a <strong class="source-inline">hash map</strong>; they contain <strong class="source-inline">key</strong>/<strong class="source-inline">value</strong> properties that can contain any data type, including functions and other objects.</p>
			<p>An object is defined using curly braces, much like a block:</p>
			<p class="source-code">var myObject = {};</p>
			<p>The values that are added to an object are "members" of that object. Those members are accessible using dot notation:</p>
			<p class="source-code">var myObject = {foo: "bar"};</p>
			<p class="source-code">console.log(myObject.foo);</p>
			<p class="source-code">// =&gt;  "bar"</p>
			<p>The key of a property may be specified with or without quotes. However, the result is exactly the same:</p>
			<p class="source-code">var myObject = {param1: 1, "param2": 2};</p>
			<p>JavaScript is known as a prototype language, which means its object-oriented capabilities are provided by prototyping values to objects prior to instantiation. As such, JavaScript objects support the <strong class="source-inline">prototype</strong> keyword.  Prototypes are too advanced for this chapter and will be discussed at length in further chapters.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor254"/>Objects as Hashtables</h2>
			<p>Objects are very much like key/value <strong class="source-inline">hashtables</strong>: you assign a value to an object with a given <strong class="source-inline">name</strong> or <strong class="source-inline">key</strong>. These values are arbitrary, and they can be primitives, functions, objects, arrays, and so on. Once an object has been defined, you can further assign properties to them using dot notation:</p>
			<p class="source-code">var myObject = {};</p>
			<p class="source-code">myObject.age = 21;</p>
			<p class="source-code">console.log(myObject.age);</p>
			<p class="source-code">// =&gt;  21</p>
			<p>As well as assigning values via dot notation, they can also be assigned by named index, much like an <strong class="source-inline">array</strong>:</p>
			<p class="source-code">myObject["age"] = 32;</p>
			<p class="source-code">console.log(myObject.age);</p>
			<p class="source-code">// =&gt;  32</p>
			<p>The result is exactly the same, but there are some differences between these approaches.</p>
			<p>When using dot notation, the parameters of an object must use standard variable naming rules. These include the following:</p>
			<ul>
				<li>Only use letters, digits, underscores, and dollar symbols.</li>
				<li>Must start with a letter, dollar, or underscore symbol.</li>
				<li>Names are case-sensitive (a and A are different variables).</li>
				<li>Must not match a reserved word, such as "<strong class="source-inline">while</strong>" or "<strong class="source-inline">if</strong>".</li>
			</ul>
			<p>Objects keys, however, are not limited by this convention. By using square brackets and passing the name as a <strong class="source-inline">string</strong>, the scope for naming keys becomes much broader. In fact, you can seemingly use any <strong class="source-inline">ASCII</strong> character of your choice, including whitespace characters, with up to <strong class="source-inline">227</strong> characters in length. That's <strong class="source-inline">134,217,728</strong> characters!</p>
			<p class="source-code">var obj = {};</p>
			<p class="source-code">obj["   "] = 99;</p>
			<p class="source-code">console.log(obj["   "]);</p>
			<p class="source-code">// =&gt;   99</p>
			<p>Aside from strings, digits may also be used as keys. This results in objects appearing much like arrays. In fact, for the most part, arrays themselves are simply objects, albeit with some superpowers of their own.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Just as strings can be used with square brackets, values can be written and read from objects dynamically simply by using variables (or expressions) between square brackets instead.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor255"/>Object Keys and Memory</h2>
			<p>When working with objects as data stores, it can be tempting to add and retrieve all kinds of data. Objects are extremely versatile containers and their use is the foundation of many applications. However, as with any language platform, data consumes memory. Every time a new key is added to an object, more memory is used on the host computer.</p>
			<p>JavaScript uses a rather intelligent <strong class="source-inline">garbage collector</strong>; whose job is to clean up discarded data. The issue is, however, that data may not be considered discarded if a reference to it exists in an object. If it isn't handled properly, then memory will continue to be consumed as you add more data, eventually resulting in your browser crashing. This is known as a memory leak!</p>
			<p>One way to remove a reference to data from an object is to simply replace it with something else. For instance, it is common in JavaScript applications to see <strong class="source-inline">null</strong> assigned to object parameters when they are no longer needed. The problem with this approach, though, is that while the original value has been detached from the object, the new <strong class="source-inline">null</strong> value has now taken its place. null is a value, after all. This may not be overly problematic as all <strong class="source-inline">null</strong> values point to the same data space, but the contained value is not the only part of the property occupying memory; the <strong class="source-inline">key</strong> is also an overhead:</p>
			<p class="source-code">var obj = {key: 99};</p>
			<p class="source-code">obj.key = null;</p>
			<p class="source-code">console.log(obj);</p>
			<p class="source-code">// =&gt;  {key: null}</p>
			<p>In order to fully delete the reference from the object, which includes <strong class="source-inline">key</strong> and <strong class="source-inline">value</strong>, the <strong class="source-inline">delete</strong> keyword should be utilized:</p>
			<p class="source-code">var obj = {key: "data"};</p>
			<p class="source-code">delete obj.key;</p>
			<p class="source-code">console.log(obj);</p>
			<p class="source-code">// =&gt;   {}</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor256"/>Object and Pass-By Reference</h2>
			<p>As we mentioned at the beginning of this chapter, primitive values are immutable and exist by value. When passing them to functions or modifying them, a new copy is made of the data, which occupies a different location in memory.</p>
			<p>Objects differ from primitive values in this regard.</p>
			<p>Objects are <strong class="source-inline">mutable</strong> data. This means that instead of a copy of the object data being passed to functions or variable assignments within your applications, a reference to the original object data is always passed. When modifying an object, it is the actual original object being altered. No new object is created:</p>
			<p class="source-code">var myObj = {key: 99};</p>
			<p class="source-code">function update(obj) {</p>
			<p class="source-code">  obj.key = 22;</p>
			<p class="source-code">  console.log(obj === myObj);  // check they are the same object</p>
			<p class="source-code">}</p>
			<p class="source-code">update(myObj);</p>
			<p class="source-code">// =&gt;   true</p>
			<p class="source-code">console.log(myObj.key);</p>
			<p class="source-code">// =&gt;   22</p>
			<p>The reason objects work so differently is that copying object data is slow and CPU-intensive. Since objects can be nested, attempting to copy an object that has a tree of descendants linked to it can be agonizingly laborious for the host machine and is therefore completely impractical.</p>
			<p>Since objects are presented differently, care must be taken with their use. Modifying object data by passing the object to functions can be the cause of hard-to-find bugs.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor257"/>Object Iteration</h2>
			<p>Since objects work like <strong class="source-inline">hash arrays</strong>, it makes sense that functions exist to work with objects as <strong class="source-inline">iterables</strong>. The JavaScript language provides a number of functions for use when iterating over objects, but it also provides operators to this end, as seen with the in operator.</p>
			<p>The in operator converts an object into an <strong class="source-inline">iterable</strong> by iterating over its keys:</p>
			<p class="source-code">var myObj= {key: "value"};</p>
			<p class="source-code">for (const key in myObj) {</p>
			<p class="source-code">  console.log(myObj[key]);</p>
			<p class="source-code">}</p>
			<p>The same feat can also be accomplished with the <strong class="source-inline">Object.keys(myObj)</strong> function. The difference here is that it returns the object's keys as an array, so it also has other usefulness when working with objects:</p>
			<p class="source-code">var keys = Object.keys(myObj);</p>
			<p class="source-code">for (let i=0; i&lt;keys.length; i++) {</p>
			<p class="source-code">  var key = keys[i];</p>
			<p class="source-code">  console.log(myObj[key]);</p>
			<p class="source-code">}</p>
			<p>It can also be used like so:</p>
			<p class="source-code">var keys = Object.keys(myObj);</p>
			<p class="source-code">for (const key of keys) {</p>
			<p class="source-code">  console.log(myObj[key]);</p>
			<p class="source-code">}</p>
			<p>As well as a means to get the object keys as an array, there is a function to retrieve the object's values as an array, too:</p>
			<p class="source-code">var values = Object.values(myObj);</p>
			<p class="source-code">for (const value of values) {</p>
			<p class="source-code">  console.log(value);</p>
			<p class="source-code">}</p>
			<p>Finally, should you require both keys and values as associated pairs, JavaScript provides the entries function to do just that. The <strong class="source-inline">key</strong>/<strong class="source-inline">value</strong> pairs are provided as arrays, with the first item being the key and the second item being the value:</p>
			<p class="source-code">var keyValues = Object.entries(myObj);</p>
			<p class="source-code">for (const kv of keyValues) {</p>
			<p class="source-code">  console.log(kv[0], kv[1]);</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor258"/>Object Accessors</h2>
			<p>As you may have seen, writing to and reading from objects is allowed freely, but it may not be what you want. Let's suggest, for example, that you wish to create a <strong class="source-inline">gameState</strong> object that will keep track of the player's score and the remaining <strong class="source-inline">enemies</strong> in play. By allowing data to be read and written randomly, you provide an avenue for bugs to creep into your application.</p>
			<p>Let's look at an example:</p>
			<p class="source-code">var gameState = {</p>
			<p class="source-code">  score: 0,</p>
			<p class="source-code">  enemies: 99,</p>
			<p class="source-code">  lives: 3</p>
			<p class="source-code">}</p>
			<p>Now, one solution to restricting access to these properties would be to incorporate functions. Here's an example:</p>
			<p class="source-code">var gameState = {</p>
			<p class="source-code">  _score: 0,</p>
			<p class="source-code">  _enemies: 99,</p>
			<p class="source-code">  _lives: 3,</p>
			<p class="source-code">  addToScore: function(value) {</p>
			<p class="source-code">    this._score += value;</p>
			<p class="source-code">  },</p>
			<p class="source-code">  killEnemies: function(num) {</p>
			<p class="source-code">    this._enemies -= num;</p>
			<p class="source-code">  },</p>
			<p class="source-code">  killPlayer: function() {</p>
			<p class="source-code">    this._lives -= 1;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, the member variables have been renamed to start with an underscore. This is a common practice as it is deemed that any values starting with an underscore are values that should not be accessed directly. In <em class="italic">Chapter 4</em>, <em class="italic">JavaScript Libraries and Frameworks</em>, you will find out how to protect object variables absolutely, such that direct access becomes impossible.</p>
			<p>Now, while the preceding implementation is perfectly reasonable, the properties of the objects are no longer assignable but invoked. If you needed to read back the values of those properties, you would need yet another set of functions, and those would also need to be invoked. In short, it's not very clean.</p>
			<p>JavaScript provides a solution to this conundrum through the use of accessors, also known as getters and setters. Accessors are a way to add functions that can be used like variables, whereby a getter allows for the retrieval of data and a setter enables the setting of data.</p>
			<p>The syntax for accessors is as follows:</p>
			<p class="source-code">&lt;accessor_type&gt; &lt;accessor_name&gt;() {</p>
			<p class="source-code">  .. body..</p>
			<p class="source-code">}</p>
			<p>Let's rework the previous example to utilize getters and setters:</p>
			<p class="source-code"> var gameState = {</p>
			<p class="source-code">   _score: 0,</p>
			<p class="source-code">   _enemies: 99,</p>
			<p class="source-code">   _lives: 3,</p>
			<p class="source-code">   get score() {</p>
			<p class="source-code">     return this._score;</p>
			<p class="source-code">   },</p>
			<p class="source-code">   set score(value) {</p>
			<p class="source-code">     this._score += value;</p>
			<p class="source-code">   },</p>
			<p>Here, we can see that the <strong class="source-inline">get.score()</strong> allows getting the score and <strong class="source-inline">set.score(value)</strong> allows to set a value to the data.</p>
			<p class="source-code">   get enemies() {</p>
			<p class="source-code">     return this._enemies;</p>
			<p class="source-code">   },</p>
			<p class="source-code">   get killEnemies() {</p>
			<p class="source-code">     this._enemies--;</p>
			<p class="source-code">   },</p>
			<p class="source-code">   set killEnemies(num) {</p>
			<p class="source-code">     this._enemies -= num;</p>
			<p class="source-code">   },</p>
			<p class="source-code">   get lives() {</p>
			<p class="source-code">     return this._lives;</p>
			<p class="source-code">   },</p>
			<p class="source-code">   get killPlayer() {</p>
			<p class="source-code">     if (this.enemies &lt;= 0) {</p>
			<p class="source-code">       this._lives = 3;</p>
			<p class="source-code">     } else {</p>
			<p class="source-code">       this._lives--;</p>
			<p class="source-code">     }</p>
			<p class="source-code">   }</p>
			<p class="source-code"> }</p>
			<p>Here, a bit of creative license has been utilized. The <strong class="source-inline">score</strong> can be read and written to, just like any other value, except when writing, instead of replacing the value, the value is added to the original value, like so:</p>
			<p class="source-code">console.log(gameState.score);</p>
			<p class="source-code">// =&gt;   0</p>
			<p class="source-code">gameState.score = 100;</p>
			<p class="source-code">gameState.score = 99;</p>
			<p class="source-code">console.log(gameState.score);</p>
			<p class="source-code">// =&gt;   199</p>
			<p>The <strong class="source-inline">enemies</strong> value can be read as normal, but by calling <strong class="source-inline">killEnemies</strong>, passing a value will deduct it from the current value, but passing no total will deduct <strong class="source-inline">1</strong> from the value:</p>
			<p class="source-code">console.log(gameState.enemies);</p>
			<p class="source-code">// =&gt;   99</p>
			<p class="source-code">gameState.killEnemies = 3;</p>
			<p class="source-code">console.log(gameState.enemies);</p>
			<p class="source-code">// =&gt;   96</p>
			<p class="source-code">gameState.killEnemies;</p>
			<p class="source-code">console.log(gameState.enemies);</p>
			<p class="source-code">// =&gt;   95</p>
			<p>Finally, reading the player's lives property will return the current number of lives, but reading <strong class="source-inline">killPlayer</strong> will either deduct a life or it will reset it back to <strong class="source-inline">3</strong> lives should there be no enemies left. This may be useful, for instance, if you wanted to reset the player's lives after they've completed the game:</p>
			<p class="source-code">console.log(gameState.lives);</p>
			<p class="source-code">// =&gt;   3</p>
			<p class="source-code">gameState.killPlayer;</p>
			<p class="source-code">console.log(gameState.lives);</p>
			<p class="source-code">// =&gt;   2</p>
			<p class="source-code">gameState.killEnemies = 99;</p>
			<p class="source-code">gameState.killPlayer;</p>
			<p class="source-code">console.log(gameState.lives);</p>
			<p class="source-code">// =&gt;   3</p>
			<p>Note<a id="_idTextAnchor259"/> that if you assign the value of a setter to another variable, that other variable will contain whatever was passed to the setter, not the value that was determined within the setter logic. If no value is passed, then the accessor is not a getter, and so <strong class="source-inline">undefined</strong> is returned.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor260"/>Exercise 5.10: Converting Objects to toString</h2>
			<p>In this exercise, you will create a function within an object that provides a "pretty print" facility when using the object in circumstances that require a <strong class="source-inline">string</strong> value. The function will utilize the <strong class="source-inline">toString</strong> capability, which we detailed earlier in this chapter:</p>
			<ol>
				<li value="1">To begin, create an object with a bunch of different values. Add some nested objects to make things more interesting:<p class="source-code">var obj = {meaningOfLife: 42, foo: "bar", child: {me: "you", other: {him: "her"}}, toString: Object.prototype.toString};</p></li>
				<li>Now, if you output this with <strong class="source-inline">console.log</strong>, then it should show up just fine as the console is designed to parse complex objects for debugging purposes. However, if you concatenate the object data into a string, you'll get unwanted results:<p class="source-code">var str = obj + "";</p><p class="source-code">console.log(str);</p><p class="source-code">// =&gt;   [object Object]</p></li>
				<li>To rectify this, create a function that parses objects into a string representation:<p class="source-code">var objToString = function(obj, indent) {</p><p class="source-code">  obj = obj || this;</p><p class="source-code">  indent = indent || "";</p><p class="source-code">  var res = "";</p><p>The first thing you do here is accept both the passing of an object and utilize the current object context. This way, the function can be called against the object it exists in it, but also as a passed parameter. You'll need to do this so that you can recursively <strong class="source-inline">stringify</strong> any child objects that exist within the parent. The <strong class="source-inline">indent</strong> parameter is used to keep track of the child object indentation. For each level of child, you meet, you will want to indent it further still. This helps you visualize your object structure when printed. Finally, you also need the <strong class="source-inline">res</strong> variable to store the resulting string representation as it's being built.</p></li>
				<li>Iterate through all of the object's keys and build the string representation:<p class="source-code">  for (var k in obj) {</p></li>
				<li>Now, this is where things get a little tricky. If a value for the <strong class="source-inline">k</strong> key is also an object, you will want to pretty print that, too. Therefore, just pass it to the same function:<p class="source-code">    if (typeof obj[k] == "object") {</p><p class="source-code">      res += indent + k + " = {\n";</p><p class="source-code">      res += objToString(obj[k], indent + "- ");</p><p class="source-code">      res += indent + "}";</p><p>To nest the child, the key for that child is prefixed with the value of the current indent parameter. An open curly brace is used to denote an object in the returned string. The indent is then increased in length and passed to the recursive call to the <strong class="source-inline">objToString</strong> function for the nested iteration. The child print is then closed with a closing curly brace, which is also indented.</p></li>
				<li>If the value of the key is not an object, then it might be a function. You will want to skip those as you can't cleanly print them. Everything else can be appended like a string, but will also need to be indented in case it's the value of a field in a child object:<p class="source-code">    } else if (typeof obj[k] != "function") {</p><p class="source-code">      res += indent + k + " = " + obj[k];</p><p class="source-code">    } else {</p><p class="source-code">      continue;</p><p class="source-code">    }</p></li>
				<li>Next, apply a delimiter so that each of the keys is separated. A newline character should suffice:<p class="source-code">    res += "\n";</p></li>
				<li>Finally, close the loop and return the value:<p class="source-code">  }</p><p class="source-code">  return res;</p><p class="source-code">}</p></li>
				<li>To make this work, append the <strong class="source-inline">objToString</strong> function to the starting object as a <strong class="source-inline">toString</strong> function:<p class="source-code">obj.toString = objToString;</p></li>
				<li>Finally, to test this out, simply concatenate the object to a string, forcing the object to be cast to a string value:<p class="source-code">obj + "";</p><p>The output should be as follows:</p><p class="source-code">"meaningOfLife = 4</p><p class="source-code">foo = bar</p><p class="source-code">child = {</p><p class="source-code">  - me = you</p><p class="source-code">  - other = {</p><p class="source-code">  - - him = her</p><p class="source-code">  - }</p><p class="source-code">}"</p><p>The expected output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer134">
					<img alt="Figure 5.22: Exercise 5.10 output&#13;&#10;" src="image/C14377_05_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22: Exercise 5.10 output</p>
			<p>You have created a useable object <strong class="source-inline">stringifier</strong> function that works with complex objects of any depth.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor261"/>Working with Arrays</h1>
			<p>Arrays are another complex object type built on top of objects. Unlike objects, arrays are designed to work with lists of data. Arrays may be created in several ways. The first is known as an Array literal and, similarly to object literals, is simply a means of passing a defined Array value to a variable:</p>
			<p class="source-code">var myArray = [1, 2, 3];</p>
			<p class="source-code">var myEmptyArray = [];</p>
			<p>The values of an array have no keys, and are instead accessed using integer indexes with the square bracket form:</p>
			<p class="source-code">myValue = myArray[3];</p>
			<p>As with other types, the array type also has a constructor function that's used to create array instances. The array constructor can be passed values to prepopulate the <strong class="source-inline">Array</strong>. Therefore, the following examples are equivalent:</p>
			<p class="source-code">var arr1 = [1, 2, 3];</p>
			<p class="source-code">var arr2 = new Array(1, 2, 3);</p>
			<p>However, when using the constructor form, passing a single integer value will create an array with a set number of values set to undefined:</p>
			<p class="source-code">var arr = new Array(3);</p>
			<p class="source-code">console.log( arr );</p>
			<p class="source-code">// =&gt;   (3) [empty x3]</p>
			<p>Note that the <strong class="source-inline">Array</strong> constructor can lead to unintended results, should the developer intend to create an <strong class="source-inline">Array</strong> with one value as a single integer type. As such, it is considered a good practice to initialize all arrays using the literal form.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor262"/>Arrays and Mutability</h2>
			<p>Like objects, arrays are mutable objects. If you update an array that is passed into a function, the original <strong class="source-inline">Array</strong> is also modified.</p>
			<p>The <strong class="source-inline">Array</strong> object has a number of built-in functions that are useful in maintaining immutability when using arrays. They do not make the array immutable but provide a means to work with arrays while ensuring that they are copied rather than modified.</p>
			<p>The Array's immutability functions will be discussed at length in <em class="italic">Chapter 4</em>, <em class="italic">JavaScript Libraries and Frameworks</em>, when functional programming methodologies are discussed.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor263"/>Array Iteration</h2>
			<p>Arrays can be iterated in much the same way as objects. If you're using the <strong class="source-inline">for...in</strong> syntax, the element of the <strong class="source-inline">Array</strong> is the index, which is the same result when working with objects that have numerical keys:</p>
			<p class="source-code">for (var i in myArray) {</p>
			<p class="source-code">  console.log(myArray[i]);</p>
			<p class="source-code">}</p>
			<p>This format works well if you need to iterate an array from start to finish, but this isn't very flexible. To aid the traversal of an Array, JavaScript provides a number of additional features.</p>
			<p>Since an array is a linear list, it has a <strong class="source-inline">length</strong>. The array object provides the length property, which returns the number of elements in the array:</p>
			<p class="source-code">for (let i = 0; i &lt; myArray.length; i++) {</p>
			<p class="source-code">  console.log(myArray [i]);</p>
			<p class="source-code">}</p>
			<p>The starting index of an array is always <strong class="source-inline">0</strong>, while the <strong class="source-inline">length</strong> of an array is always one more than the last index of the <strong class="source-inline">Array</strong>.</p>
			<p>As well as retrieving a value from an array by index, it is also possible to search an array for a value and return its index using the <strong class="source-inline">indexOf</strong> function. <strong class="source-inline">indexOf</strong> takes a single parameter, that is, the value to find within the array:</p>
			<p class="source-code">var arr = [1, "b", true];</p>
			<p class="source-code">arr.indexOf("b");</p>
			<p class="source-code">// =&gt;   1</p>
			<p><strong class="source-inline">indexOf</strong> will return the index of the value if it is found but will return <strong class="source-inline">-1</strong> if it does not. A match can be at <strong class="source-inline">index 0</strong> or above, up to but exclusive of <strong class="source-inline">arr.length</strong>. To use a result of <strong class="source-inline">indexOf(...)</strong> in a conditional statement, compare it and check whether it's higher than <strong class="source-inline">-1</strong>:</p>
			<p class="source-code">var searchedValue= "b";</p>
			<p class="source-code"> if ( arr.indexOf(searchedValue)&gt;-1 ) {</p>
			<p class="source-code">   console.log( "match found" );</p>
			<p class="source-code">}</p>
			<p>Note that <strong class="source-inline">indexOf</strong> looks for the matching value of an element. Therefore, complex types will only be found within the Array if they exist within the Array by reference. Here's an example:</p>
			<p class="source-code">var obj = {name: "bob"};</p>
			<p class="source-code">var arr = ["a", 99, obj];</p>
			<p class="source-code">console.log( arr.indexOf(obj) );</p>
			<p class="source-code">// =&gt;   2</p>
			<p class="source-code">console.log( arr.indexOf({name: "bob"}) );</p>
			<p class="source-code">// =&gt;   -1</p>
			<p>Since complex types of identical structure are not considered the same by value, it is not possible to find occurrences of complex objects within an Array in this manner.</p>
			<p>If multiple occurrences of a value exist within an Array, <strong class="source-inline">indexOf</strong> will return the first discovered item index. All other instances of that value will be ignored.</p>
			<p>A companion of the <strong class="source-inline">indexOf</strong> function is the <strong class="source-inline">lastIndexOf</strong> function. This function works identically to <strong class="source-inline">indexOf</strong>, with the exception that the index search starts at the end of the Array.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor264"/>Built-In Array Functions</h2>
			<p>The array type provides many more functions that are useful in traversing, copying, concatenating, and presenting array structures. The following table lists some important and useful functions that are available as members of the array type:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer135">
					<img alt="Figure 5.23: Built-in array functions and their descriptions&#13;&#10;" src="image/C14377_05_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23: Built-in array functions and their descriptions</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor265"/>Working with Dates</h1>
			<p>The Date object is an important type in JavaScript but is a complicated type in any language. Like the <strong class="source-inline">Array</strong> type, the <strong class="source-inline">Date</strong> type is built on top of a JavaScript object.</p>
			<p>Dates have no literal format. As such, they must be created using the <strong class="source-inline">Date</strong> constructor. There are four ways to do this:</p>
			<ul>
				<li>An empty constructor creates a date with the current date and time.</li>
				<li>The constructor may be passed an integer representing the number of milliseconds to have passed since the beginning of <strong class="source-inline">January 1st, 1970</strong>.</li>
				<li>Supplying multiple integer parameters will specify date segments, for example:<p>(year, month, day, hour, minute, second, millisecond)</p><p>(year, month, day, hour, minute, second)</p><p>(year, month, day, hour, minute)</p><p>(year, month, day, hour)</p><p>(year, month, day)</p><p>(year, month)</p><p>Be aware that the month is specified by the numbers <strong class="source-inline">0</strong> - <strong class="source-inline">11</strong>.</p></li>
				<li>Supplying a string representation of a date:<p>ISO 8601 date format ("<strong class="source-inline">2019-04-25</strong>" or "<strong class="source-inline">2019-04-25T12:00:00Z</strong>", where months, days, and time are padded to two-digit lengths)</p><p>US short date format ("<strong class="source-inline">04/25/2019</strong>" with padded day and month)</p><p>US long date format ("<strong class="source-inline">Apr 25 2019</strong>" and so on)</p><p class="callout-heading">Note </p><p class="callout">You cannot create a <strong class="source-inline">Date</strong> instance by simply passing the year value as an integer since the JavaScript engine will not know whether you meant year or milliseconds. However, you can create a Date instance from simply passing a year string.</p></li>
			</ul>
			<p>Once a <strong class="source-inline">Date</strong> object has been constructed, it can be queried. The <strong class="source-inline">Date</strong> object provides numerous functions for extracting the elements of the <strong class="source-inline">date</strong>. The following table lists the functions that are available:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer136">
					<img alt="Figure 5.24: The Date object methods and their descriptions&#13;&#10;" src="image/C14377_05_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24: The Date object methods and their descriptions</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Each of the functions provided by Date returns a value starting from 0, with the exception of the <strong class="source-inline">getDate</strong> method. This often leads to confusion and bugs, so be sure to keep this in mind.</p>
			<p>Each of the functions detailed in the preceding table also has a set equivalent, with the exception of <strong class="source-inline">getDay</strong>. Therefore, to update the hour of the <strong class="source-inline">Date</strong> instance, you simply call <strong class="source-inline">setHour</strong> and pass it an integer:</p>
			<p class="source-code"> var d = new Date();</p>
			<p class="source-code"> d.setHours(12);</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor266"/>Parsing Date Strings</h2>
			<p>As we mentioned previously, the <strong class="source-inline">Date</strong> constructor can accept a date string and convert it into an instance of the <strong class="source-inline">Date</strong> object. Dates are represented internally within the Date type as integers. Thus, the <strong class="source-inline">getDate</strong> method returns the true interpretation of the date value.</p>
			<p>If you have a valid date string, as detailed previously, you can convert it into a date by calling the <strong class="source-inline">parse</strong> method:</p>
			<p class="source-code">var greatDate = Date.parse("November 3, 1976");</p>
			<p>However, the return value of the <strong class="source-inline">Date.parse</strong> method does not return a <strong class="source-inline">Date</strong> instance. Instead, it returns the number of milliseconds since <strong class="source-inline">January 1st, 1970</strong> until that date. In order to create a <strong class="source-inline">Date</strong> instance, you must, therefore, pass that resulting value to the <strong class="source-inline">Date</strong> constructor:</p>
			<p class="source-code">var millis = Date.parse("November 3, 1976");</p>
			<p class="source-code">var greatDate = new Date(millis);</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor267"/>Formatting Dates into Strings</h2>
			<p>The<strong class="source-inline"> Date </strong>object provides its own <strong class="source-inline">toString</strong> function. If you attempt to use a <strong class="source-inline">Date</strong> instance as a <strong class="source-inline">string</strong>, you will receive a formatted string instead:</p>
			<p class="source-code">var d = new Date();</p>
			<p class="source-code">console.log(d);</p>
			<p class="source-code">//  =&gt; current time in local timezone, for example:</p>
			<p class="source-code">// Thu Apr 25 2019 12:00:00 GMT+0100 (British Summer Time)</p>
			<p>However, this is often not the format you require. If you wish to provide your own date string format, you can override the <strong class="source-inline">toString</strong> function of the object, much like in the <em class="italic">Working with Object</em> section of this chapter. Here's an example:</p>
			<p class="source-code">var toString = function(date) {</p>
			<p class="source-code">  date = date || this;</p>
			<p class="source-code">  var months = [</p>
			<p class="source-code">   "Jan", "Feb", "Mar",</p>
			<p class="source-code">   "Apr", "May", "Jun",</p>
			<p class="source-code">   "Jul", "Aug", "Sep",</p>
			<p class="source-code">   "Oct", "Nov", "Dec"</p>
			<p class="source-code">  ];</p>
			<p class="source-code">  var day = date.getDate();</p>
			<p class="source-code">  var mnth = date.getMonth();</p>
			<p class="source-code">  var year = date.getFullYear();</p>
			<p class="source-code">  return day + ' ' + months[mnth] + ' ' + year;</p>
			<p class="source-code">}</p>
			<p class="source-code">var d = new Date();</p>
			<p class="source-code">d.toString = toString;</p>
			<p class="source-code">console.log(d);</p>
			<p>The output of this code will be as follows:</p>
			<p class="source-code">current date in format 25 Apr 2019</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor268"/>Date Math</h2>
			<p>JavaScript provides no functions for comparing, adding, or subtracting dates. However, working out date differences or combining dates is not hard in JavaScript.</p>
			<p>Typically, there are two tasks that need to be considered when comparing dates:</p>
			<ul>
				<li>What the difference is between two dates</li>
				<li>Adding or subtracting time to/from a date</li>
			</ul>
			<p>The first task is relatively simple. Since the date can be converted into a simple integer representing the number of milliseconds since <strong class="source-inline">January 1st, 1970</strong>, the dates you wish to difference can simply be represented as milliseconds and that value can be compared. Here's an example:</p>
			<p class="source-code">var date1 = new Date("Dec 25 2001").getTime();</p>
			<p class="source-code">var date2 = new Date("Dec 25 2019").getTime();</p>
			<p class="source-code">var diff = date2 - date1;</p>
			<p class="source-code">diff</p>
			<p class="source-code">// =&gt;   567993600000</p>
			<p>Now, with the number of milliseconds in each, you can convert that into a time unit. For example, if you wanted to find out the number of days that difference represents, you would simply do the following:</p>
			<p class="source-code">var day = 1000 * 60 * 60 * 24;</p>
			<p class="source-code">var numDays = diff / day;</p>
			<p class="source-code">numDays</p>
			<p class="source-code">// =&gt;   6574</p>
			<p>To get the unit, you simply start with milliseconds and work up. Therefore, a day is <strong class="source-inline">1,000 milliseconds * 60 seconds * 60 minutes * 24 hours</strong>.</p>
			<p>Adding or subtracting time from dates is also very simple. The set* methods provided by the <strong class="source-inline">Date</strong> object provide a means for us to roll over values that exceed the next largest unit. For instance, if the current date is <strong class="source-inline">April 25, 2019</strong>, adding <strong class="source-inline">10</strong> days will change the date to <strong class="source-inline">May 5, 2019</strong>. This feature is applicable to all of the <strong class="source-inline">set</strong> functions. Thus, to add time, simply get the unit of time you wish to add to and add to it:</p>
			<p class="source-code">var d = new Date("Apr 25 2019");</p>
			<p class="source-code">d.setMonth(d.getMonth() + 60);</p>
			<p class="source-code">d</p>
			<p class="source-code">// =&gt;   Thu Apr 25 2024 00:00:00 GMT+0100 (British Summer Time)</p>
			<p class="source-code">// The above result will use your local timezone.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor269"/>Activity 5.02: Creating a To-Do Model</h2>
			<p>Let's utilize all the information we have learned about in this chapter and see what we have retained. For this activity, imagine that you are working with a team of developers and your project is to create a stateful model that stores entries for a To-Do application. The model will be a primary function, though other functions can be created and used by it. The function will need to store one or more entries and will receive "actions" that tell the state to change.</p>
			<p>These actions will include the following:</p>
			<ul>
				<li>Create a new To-Do</li>
				<li>Remove a To-Do</li>
				<li>Modify a To-Do</li>
			</ul>
			<p>Actions will be passed to the state with a given action keyword of either <strong class="source-inline">CREATE</strong>, <strong class="source-inline">REMOVE</strong>, or <strong class="source-inline">MODIFY</strong>.</p>
			<p>Each To-Do item in the state will have the following fields:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer137">
					<img alt="Figure 5.25: Activity fields&#13;&#10;" src="image/C14377_05_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25: Activity fields</p>
			<p>The data will be passed to the state function with the action type. If the action is a <strong class="source-inline">CREATE</strong> action, then all of the preceding fields will be passed, with the exception of the <strong class="source-inline">id</strong> field. If it is a <strong class="source-inline">REMOVE</strong> action, then only the <strong class="source-inline">id</strong> is passed. It will be passed as a string value. Finally, if the <strong class="source-inline">MODIFY</strong> action is passed, then all of the data is passed, with the exception of the <strong class="source-inline">created_at</strong> value. This is because the <strong class="source-inline">created_at</strong> value shouldn't change.</p>
			<p>An important part of this task is to ensure that the state data is treated as immutable since the project manager is a fan of functional programming and wants to ensure that as few bugs as possible are added to the application. No objects, including <strong class="source-inline">Arrays</strong> and <strong class="source-inline">Dates</strong>, should be changed in this activity. Instead, new objects, <strong class="source-inline">Arrays</strong>, and <strong class="source-inline">Dates</strong> must be created, replacing the old values. This must also be true of the Array containing the <strong class="source-inline">TODO</strong> entries.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Array <strong class="source-inline">concat</strong> function returns a new Array, but any objects within it will still be references to the original values.</p>
			<p>Finally, when each action is received, the state function will need to pretty-print the data to the console. For <strong class="source-inline">CREATE</strong> actions, this will be the incoming data and for <strong class="source-inline">REMOVE</strong> actions, this will be the removed data. For <strong class="source-inline">MODIFY</strong> actions, both the removed and created data should be printed.</p>
			<p>If all goes to plan, you will be able to add, remove, and modify entries in your state function without worrying about corrupted data. You can prove this by modifying the values you send to the state function. If the entries in the state function are also modified, your model is not immutable.</p>
			<p>This activity highlights a common means to handle application data effectively and in a way that will not introduce bugs to your application. By managing data in a pure manner, you will ensure that your development practices produce reliable results in a short period of time.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create the function signature to accept the following:<ul><li>The current state, which is the current list of To-Do items</li><li>The action, which is simply a string value</li><li>The data to apply to the state change<p>The function signature will look as follows:</p><p class="source-code">function modelStateChange(state, action, data)</p><p>Here, <strong class="source-inline">state</strong> is the current Array of <strong class="source-inline">ToDo</strong> items in the model, <strong class="source-inline">action</strong> is either <strong class="source-inline">CREATE</strong>, <strong class="source-inline">MODIFY</strong>, or <strong class="source-inline">REMOVE</strong>, and <strong class="source-inline">data</strong> is either new <strong class="source-inline">ToDo</strong> data or simply the parameter to match a <strong class="source-inline">ToDo</strong> item to remove.</p></li></ul></li>
				<li>Create a conditional for each action type. Then, in the body of the condition, manipulate the state as needed. Remember to return the new state within the condition body. You may want to create a secondary function that does the lookup of a <strong class="source-inline">ToDo</strong> within the state as you'll need this functionality in the <strong class="source-inline">MODIFY</strong> and <strong class="source-inline">REMOVE</strong> actions.<p>Remember, this function should always return a new state value. That way, it is possible to cleanly test the function predictably and ensure that it works as intended.</p><p>An example of how this function may be called is as follows:</p><p class="source-code">todoState = modelStateChange(_todoState, "MODIFY", {id: curTodo.id, completed: true});</p><p class="callout-heading">Note </p><p class="callout">The solution to this activity can be found on page 726. </p></li>
			</ol>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor270"/>Summary</h1>
			<p>A lot has been covered in this chapter. You should now have a deeper understanding of the types provided by JavaScript, but also the subtle ways in which each type is related. Understanding how data is represented in a language provides a solid foundation for building applications more quickly and with fewer bugs.</p>
			<p>As well as understanding the data types, you also saw how to manipulate them, both with methods and with helper functions provided by the JavaScript engine. You also saw how to convert data into different types, in order to enable data interoperability.</p>
			<p>Finally, you saw how you can debug your data using the console and using string-based data formatting capabilities provided by the language.</p>
			<p>In the next chapter, you will start down the path of user interactivity and see how events can be triggered to force your code to do something. You will also be introduced to the relationship between the JavaScript language and the HTML DOM in the browser environment.</p>
		</div>
		<div>
			<div class="Content" id="_idContainer139">
			</div>
		</div>
	</body></html>