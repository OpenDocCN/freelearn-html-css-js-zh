<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>5. Beyond the Fundamentals</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to identify the difference between JavaScript's mutable and immutable types; manipulate each of the built-in data types confidently; convert data from one type to another; format data types for presentation; and differentiate between an expression and a statement.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor179"/>Introduction</h1>
			<p>In the previous chapter, you were given a tour of JavaScript, its runtimes, and its history. Using a high-level topography, that chapter will have given you an idea as to what JavaScript is, what it can do, and its ubiquity within the internet software development industry.</p>
			<p>Understanding code can be difficult for beginners. JavaScript is no exception. Its flexibility, extensive language syntax, and varying coding patterns can prove daunting to the uninitiated.</p>
			<p>This chapter will take you a step closer to writing your own software applications in JavaScript. By explaining the fundamentals, you will be empowered to not only understand what scripts do, but how to reason about problems using JavaScript syntax.</p>
			<p>In this chapter, you will take a close look at JavaScript's type system. All programming languages have a type system. Types literally dictate the type of data stored in a variable or function parameter. Types are typically separated into two categories: <strong class="bold">primitive</strong> and <strong class="bold">complex</strong> types.</p>
			<p>In JavaScript, all primitive data types are immutable. This means that the value cannot be changed in memory. New values can be assigned to a variable, but the underlying data stored in memory cannot be modified directly. This differs from the case in languages such as C++, where values can be directly altered in memory using pointers and helper functions. In JavaScript, when passing a primitive value from one variable to another, the data is copied in memory to the new variable. Therefore, updating one variable does not affect the other.</p>
			<p>Complex data types work differently. They are also known as reference types. Reference types include the <strong class="bold">Object</strong> type and all of its derivatives, such as <strong class="bold">Array</strong>, <strong class="bold">Date</strong>, and <strong class="bold">Function</strong>. All reference types are passed by reference, hence the name. Therefore, if an object is modified through one reference, all the other references that share the same object will see it as updated too, since all of the references point to the same data in memory.</p>
			<p>A complex type is simply a type that has more functionality than a primitive. For instance, a <code>Date</code> value provides additional means of representation, while objects can contain many nested values, such as primitives and other complex types.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Function types will not be explained in detail in this chapter and will instead be covered in a later chapter when prototypes are introduced.</p>
			<p>All primitives, and preexisting reference types are known as built-in data types. Each of these types has a corresponding object that provides functions for manipulating that type. These functions may be applied externally to data by passing the value as a parameter to a function, or they may be applied by calling the function as if it were a method of that type. The latter is also applicable to several primitives, despite them not existing as literal objects within the JavaScript type system. However, this is made possible through the syntactical context of the data. More will be explained about this feature throughout this chapter.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor180"/>Creating Variables</h1>
			<p>Variable creation is the means to assign a value to a symbol. In this circumstance, a symbol is a textual representation of the data, much like a container, which can be used to move data through your program. It also improves the legibility of your code. There are multiple ways to create variables, including assignment to the global scope or through the use of either the <code>var</code>, <code>let</code>, or <code>const</code> keywords.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor181"/>A Note on Referencing</h2>
			<p>Even at this early stage, it must be highlighted that JavaScript's referencing functionality can get rather confusing. The presence of <code>closures</code>, <code>prototypes</code>, <code>global</code> and <code>local memory stacks</code>, <code>variable assignment variations</code>, and <code>function invocation options</code> can leave even seasoned programmers scratching their heads.  Each of the aforementioned features supports JavaScript as a formidable and flexible programming language that's able to challenge most other platforms for almost any purpose. While it does deepen JavaScript's learning curve, mastering these concepts can be extremely rewarding.</p>
			<p>This chapter highlights the very basics of data referencing and attempts to not confuse matters any more than necessary. Only referencing with regard to data at the global level will be discussed.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor182"/>Global Assignment</h2>
			<p>Assigning a variable without the use of <code>var</code>, <code>let</code>, or <code>const</code> will place the variable into the global scope. This value will then be accessible anywhere in your application unless a variable of the same name exists within that scope. Redeclaring the same variable name without the use of a preceding keyword will overwrite the global reference, even if it's assigned within a different scope.</p>
			<p>Declaring globally in a browser environment is equivalent to declaring the value on the global window object as a field.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor183"/>Declaring with var</h2>
			<p>Preceding variable assignment with the <code>var</code> keyword places the variable into function scope. This means the variable only exists at the same function as the assignment, but not outside that function. Declaring with <code>var</code> in the global scope is equivalent to declaring without the <code>var</code> keyword.</p>
			<p>Redeclaring a variable with <code>var</code>, but in a nested scope, will not overwrite the variable of the same name in the outer scope.</p>
			<p>Using the <code>var</code> keyword, variables can be scoped (declared) even after they are used within the same scope.  This is due to variable hoisting. Hoisting was explained in <em class="italic">Chapter 4</em>, JavaScript Libraries and Framework<em class="italic">s</em>.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor184"/>Declaring with let</h2>
			<p>The <code>let</code> keyword has a narrower scope. While <code>var</code> is considered to be functionally scoped, the <code>let</code> keyword is block scoped. This means that variables that are created with <code>var</code> exist throughout a function's scope level, while let-declared variables are created and used at the block level, such as in <code>if</code> conditional blocks or <code>for</code> loops.</p>
			<p>For example, using <code>let</code>, a variable can be temporarily overwritten within a <code>for loop</code> while not changing a variable of the same name in the outer function. However, if <code>var</code> is used instead, the outer variable will be changed:</p>
			<pre>var a=0;
for(var a in [0, 1]);
console.log( a ); // ==&gt; a is now 1 (as modified by the loop)</pre>
			<p>In the preceding example, the variable declared in the <code>for loop</code> matches the symbol declared outside of it. As such, the same variable reference is modified. However, in the following example, the result is different, as the let-declared variable only exists within the context of the for loop, meaning the outside variable of the same name is left untouched:</p>
			<pre>var a=0;
for(let a in [0, 1]);
console.log( a ); // ==&gt; a is still 0 (not modified by the loop)</pre>
			<p>Contrary to <code>var</code>, let-declared variables are not hoisted. If a scope declares a variable with <code>let</code>, accessing that variable before that let declaration statement (within the same scope or in any inner scope) will raise an error (this is regardless of whether a variable with the same name has been created in an outer scope):</p>
			<pre>glob=1; {glob=2; let glob=3;}  // ==&gt; can't access lexical declaration `glob' before 
initialization
glob=1; {glob=2; var glob=3;} // ==&gt; accepted syntax</pre>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/>Declaring with const</h2>
			<p>The <code>const</code> keyword works with the same scoping and hoisting rules as the <code>let</code> keyword. The difference with <code>const</code> is that it is assumed the variable will not change throughout its lifetime. Using <code>const</code> allows the JavaScript engine to make certain optimizations at compile time since it expects the data to remain constant at runtime.</p>
			<p>It is possible to create a new variable assignment with the same name in a nested function scope, but it will not be possible to modify a variable of the same name using global scoping rules.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Declaring a variable with var or let, but without assigning a value, will result in the variable containing <code>undefined</code>. The undefined value will be covered a little later in this chapter.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Exercise 5.01: Variables and Scope</h2>
			<p>In this exercise, we will use the browser's JavaScript <strong class="bold">Read-Eval-Print Loop </strong>(<strong class="bold">REPL</strong>) to experiment with variable assignment and scope. Let's get started:</p>
			<ol>
				<li>Launch your browser and open the developer tools console. In Chrome, you can do this by pressing the <em class="italic">F12</em> key.</li>
				<li>Ensure the <code>Console</code> tab is selected:<div><img alt="Figure 5.1: The Console tab&#13;&#10;" src="img/C14377_05_01.jpg"/></div><p class="figure-caption">Figure 5.1<a id="_idTextAnchor187"/>: The Console tab</p></li>
				<li>At the <code>prompt</code>, enter the following commands, pressing <em class="italic">Enter</em> at the end of each line:<pre>const i = 10;
console.log(i);
// -&gt;    10</pre><p>The <code>console.log</code> command writes the value of <code>i</code> to the console.</p></li>
				<li>Next, create a function that also initializes a variable of the same name, as follows:<pre>const f = function() {
    var i = 20;
    console.log(i);
};</pre></li>
				<li>Invoke the function to print the variable that exists within the function scope. If you then print the global variable, you will see it has not been modified:<pre>f();
// -&gt;    20
console.log(i);
// -&gt;    10</pre></li>
				<li>N<a id="_idTextAnchor188"/>ext, try the <code>let</code> keyword:<pre>if (true) {
    let i = 15;
    console.log(i);
}
// -&gt;   15
 console.log(i);
// -&gt;   10</pre><p>As you can see, the <code>let</code> assignment only exists for the lifetime of the block that follows the if statement.</p></li>
				<li>Close the browser tab. Open a new tab and open the console again (otherwise, you won't be able to re-assign <code>i</code> as a variable). Now, try the same with <code>var</code>. You will see that the variable declaration raises an error because it conflicts with the <code>i</code> variable outside of the conditional block:<pre>i = 10;
if (true) {
    var i = 15;
    console.log(i);
}
// -&gt;    15
console.log(i);
// -&gt;    15</pre></li>
			</ol>
			<div><div><img alt="Figure 5.2: Exercise 5.01 output&#13;&#10;" src="img/C14377_05_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Exercise 5.01 output</p>
			<p>Understanding the scope surrounding a variable is important for the correct execution of your application, as well as for minimizing bugs. Try to keep a mental note of the positioning and use of each variable as you work. Utilizing functional paradigms, as discussed in <em class="italic">Chapter 13</em>, <em class="italic">JavaScript Programming Paradigms</em>, will also help alleviate any discrepancies in variable scoping.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor189"/>Identifying a Variable's Type</h2>
			<p>So far, you have created variables and output their value to the browser's console. In order to get the most out of the content of this chapter, however, it would be helpful to be able to identify the content of a variable.  JavaScript is known as a weakly typed language because a variable can hold a <code>string</code> one moment, but then an <code>integer</code> the </p>
			<p>next. By being able to identify the type of value stored in a variable, you prevent errors occurring where you attempt to process a value you expected to be of a different type.</p>
			<p>Th<a id="_idTextAnchor190"/>e <code>typeof</code> keyword exists to do just that. By preceding a variable with the <code>typeof</code> keyword, the returned value is the type of the variable represented as a <code>string</code>.</p>
			<p>The <code>typeof</code> keyword evaluates with the following type mapping:</p>
			<div><div><img alt="Figure 5.3: Types and responses&#13;&#10;" src="img/C14377_05_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Types and responses</p>
			<p>The <code>null</code> type evaluates as "<code>object</code>". This anomaly originates from the earliest incarnations of JavaScript where data types were tagged internally with an integer value. Object types were tagged with 0, while the <code>null</code> value existed as a <code>null pointer</code> (or <code>0x00</code> as a value). As the two expressions were identical, determining the type of <code>null</code> resulted in the same type as Object. This same anomaly still exists in JavaScript today. Therefore, when determining whether a type is an Object, we must also compare it with <code>null</code>:</p>
			<pre>var value = [1, 2, 3]; // an array - which is also an object
if (typeof value === "object" &amp;&amp; value != null) {
    console.log("value is an object");
}</pre>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor191"/>Exercise 5.02: Evaluating Types from Variables</h2>
			<p>In this exercise, we will create a function that outputs the type of whatever variable is passed to it. Let's get started:</p>
			<ol>
				<li value="1">At the command prompt, enter the following line to declare the function signature:<pre>var printType = function(val) {</pre><p>This function accepts a single variable, which will be the variable to analyze.</p></li>
				<li>Due to the Null value caveat, you must check for this, first. <a id="_idTextAnchor192"/>Here, compare <code>val</code> to <code>Null</code> and output the appropriate message. If the value is indeed <code>Null</code>, then the function must be returned so that no further comparisons can be made:<pre>  if (val === null) {
    console.log("Value is null");
    return;
  }</pre><p><a id="_idTextAnchor193"/><a id="_idTextAnchor194"/>Here, you are comparing <code>val</code> to <code>Null</code> and outputting the appropriate message. If the value is indeed <code>Null</code>, then the function must be returned so that no further comparisons can be made.</p></li>
				<li>If the value is <code>not Null</code>, then you can safely return the type of the value itself:<pre>  console.log("Value is", typeof val);
}</pre><p><code>console.log(...)</code> will output however many values are passed into it and concatenate them onto the same line. Here, you output the generic message but then concatenate it with the type of the variable. Since no value is required to be passed from this function, and as there is no more logic to perform, no return statement is required to close out the function.</p></li>
				<li>To test this function, execute it in the console with different values:<pre>printType(12);
printType("I am a string");
printType({});
printType(null);</pre><p>The preceding code will result in the following output:</p><pre>Value is number
Value is string
Value is object
Value is null</pre></li>
			</ol>
			<div><div><img alt="Figure 5.4: Exercise 5.02 output&#13;&#10;" src="img/C14377_05_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: Exercise 5.02 output</p>
			<p>The function you have just created is rather light in terms of introspection. It essentially enables you to determine the general type of a passed in value, but it isn't powerful enough to differentiate object types, including JavaScript's built-in objects. Whether you pass in a <code>Date</code> or an <code>Array</code>, you will get the same output.</p>
			<p>You will discover how to be more thorough in determining data types later in this module.</p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor195"/>Fixed Types</h1>
			<p>Fixed types are types that have no variation of value. Unlike numbers, which may have any combination of digits, an optional minus sign (for negative numbers), a decimal point, or a scientific notation, a fixed type is always one simple value or value group.</p>
			<p>In JavaScript, the available fixed types include <code>null</code>, <code>undefined</code>, and <code>Booleans</code> (<code>true</code> and <code>false</code>). These values are <code>static</code> and cannot change. If a variable contains one of these values, it is then strictly equal to the value itself. Fixed types are more of a representation of a situation than actual data. For instance, <code>true</code> is a fixed representation of truthfulness and <code>false</code> is a fixed representation of falsehood. The values are not quantifiable in the real world but are representative of logic that software directly deals with.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor196"/>The null Value</h2>
			<p><code>null</code>, in mathematical terms, denotes a value that is not present. In JavaScript, <code>null</code> is a static value that's used to mean no value. In other languages, this would be equivalent to nil or void.</p>
			<p><code>null</code> is a useful value for dereferencing variables or for returning a value from a function when no value can be returned. For instance, a function may return an object from an array if the item is present but may return <code>null</code> if it is not.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor197"/>The undefined Value</h2>
			<p><code>undefined</code> is similar to <code>null</code> in many ways and, due to this, the two values are often misused. <code>undefined</code> is the value contained in any variable that is declared first, but not assigned a value. It is also the value that's been returned from a function that does not explicitly return a value using the <code>return</code> keyword and it is the value that's returned from a statement (an action with no resulting value).</p>
			<p>When working with <code>undefined</code>, you should always anticipate it, but never assign it to a variable or return it explicitly from a function. In such circumstances, you should use <code>null</code>.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor198"/>Boolean Values</h2>
			<p><code>B<a id="_idTextAnchor199"/>oolean</code> is a term named after George Boole, a nineteenth-century English mathematician and philosopher. It is used to denote the values <code>true</code> and <code>false</code>. These values may be assigned to variables and are strictly equivalent to their value, like null.</p>
			<p>Booleans are unique among the types supported by JavaScript because they are indirectly comparable to other types and expressions. The logical operators described in <em class="italic">Chapter 3</em>, <em class="italic">Programming Fundamentals</em>, of this book, for instance, all result in a <code>Boolean</code> value.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor200"/>Boolean Operators</h1>
			<p>Boolean operators are operators that, when combined into an expression, return a <code>Boolean</code> value. Most Boolean operators are "<code>binary</code>" operators that accept two values, each of which sit either side of the operator. Like other operators, each value can be an expression and can be of any value type. As <code>Boolean</code> operators themselves form expressions, they can be used as input to other <code>Boolean</code> operators.</p>
			<p>Boolean operators fit into two categories; namely, comparison operators and logical operators.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor201"/>Comparison Operators</h2>
			<p>Comparison operators are used for comparing one value, or the result of an expression, with another. The operator in this circumstance may be considered a rule. If the rule succeeds, then the response of the combined expression returns <code>true</code>. Otherwise, it returns <code>false</code>.</p>
			<p>Comparison operators include the following symbols:</p>
			<div><div><img alt="Figure 5.5: Comparison operators and their descriptions&#13;&#10;" src="img/C14377_05_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: Comparison operators and their descriptions</p>
			<p>Comparison operators are often used as the condition parameters of if conditionals and while loop statements. If or while the condition expression returns true, the body block of the expression will execute.</p>
			<p>The following example expressions will all return the value true:</p>
			<pre>21 == 9+12;
false != true;
6 &gt; 1;
5 &gt;= 5;
"1" == 1;</pre>
			<p>If you look at the last example in the list, you may be a little surprised. The <code>==</code> operator is a "value comparison operator". In the example shown, the numeric value 1 and the string value "1" are considered the same value.  As such, the equality operator, which is a "value comparison" operator, will compare them as equal.</p>
			<p>In order to determine whether values are of the same type, as well as the same value, "strict comparison operators" should be used:</p>
			<div><div><img alt="Figure 5.6: Equality operators and their descriptions&#13;&#10;" src="img/C14377_05_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: Equality operators and their descriptions</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor202"/>Logical Operators</h2>
			<p>Logical operators are often used to concatenate <code>Boolean</code> expressions together. For instance, when comparing the qualities of a <code>string</code> value, you may wish to execute code if the <code>string</code> is longer than one value but shorter than another. In order to do this, you need to join two comparison expressions using the <code>&amp;&amp;</code> operator. In another condition, you may wish to execute the code if only one of the expressions is <code>true</code>, in which case, you would use the <code>||</code> operator.</p>
			<p>The following table lists each of the logical operators and what they do:</p>
			<div><div><img alt="Figure 5.7: Logical operators and their description&#13;&#10;" src="img/C14377_05_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: Logical operators and their description</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor203"/>Exercise 5.03: Odds and Evens</h2>
			<p>In this exercise, we will process a series of numbers and output messages describing whether a number is either odd or even.</p>
			<p>We'll fulfill this exercise using a function so that you can experiment with different starting values. Let's get started:</p>
			<ol>
				<li value="1">At the command prompt, create the <code>odd_or_even</code> function with a couple of parameters:<pre>function odd_or_even(counter, last) {</pre><p>The <code>last</code> parameter will be the ceiling value of the numerical series, while the <code>counter</code> parameter is both the starting value and the current index variable for each loop.</p></li>
				<li>Next, create your loop using the <code>while</code> keyword. while will process a block of code as long as the conditional expression is truthy. As the conditional in this exercise, you will simply compare <code>counter</code> with the <code>last</code> parameter:<pre>  while (counter &lt;= last) {</pre><p>If the <code>counter</code> variable is ever larger than the <code>last</code> parameter, then the <code>while</code> loop will exit, which will also exit the function.</p></li>
				<li>With the <code>while</code> conditional in place, you can now begin describing the counter value with each iteration. To do this, you simply examine the value of <code>counter</code> and respond with an appropriate message, depending on its content:<pre>    if (counter % 2 == 0) { // is true if the remainder of 'counter / 2' is 
equal to zero
      console.log(counter, "is an even number");
    } else {
      console.log(counter, "is an odd number");
    }</pre></li>
				<li>Now, increment the <code>counter</code> variable by <code>1</code> before you close the <code>while</code> loop block. <a id="_idTextAnchor204"/>If you fail to increment, the condition of the <code>while</code> loop would always be <code>true</code>, and the loop will never exit. Also, each iteration of the loop would process identically, which is not the result you require:<pre>  counter = counter + 1;<a id="_idTextAnchor205"/></pre></li>
				<li>Close out both the <code>while</code> block and the function. There is no need to return anything from this function as we are not interested in any final values:<pre>  }
}</pre></li>
				<li>Now, execute the function, passing a <code>counter</code> value and <code>last</code> value as required. The output should accurately describe all the numbers from <code>counter</code> to <code>last</code>, inclusively.<p>Here's the output:</p><pre>odd_or_even(1, 5);
//   1 "is an odd number"
//   2 "is an even number"
//   3 "is an odd number"
//   4 "is an even number"
//   5 "is an odd number"</pre></li>
			</ol>
			<div><div><img alt="Figure 5.8: Exercise 5.03 output&#13;&#10;" src="img/C14377_05_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: Exercise 5.03 output</p>
			<p>Have a go at changing the passed parameters when calling the function. However, be sure to keep <code>counter</code> to a value less than or equal to the <code>last</code> parameter or the <code>while</code> loop will not execute.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor206"/>Testing the Truth of Values</h2>
			<p>When writing programs with JavaScript, you will often need to compare values, typically when working with conditionals. Often, values will be compared with other values, but it is just as likely that you will need to check the truthiness of a value.</p>
			<p>Testing for truthiness can mean many things:</p>
			<ul>
				<li>Is there a value present?</li>
				<li>Are there any items in an array?</li>
				<li>Does the string have a length greater than 0?</li>
				<li>Does the passed expression return <code>true</code>?</li>
			</ul>
			<p>JavaScript provides a means to pass in a solitary value to conditional statements to test for truthiness.  However, this can sometimes be an area of confusion. For instance, examine the following example:</p>
			<pre>if (0) console.log("reached");  // doesn't succeed
console.log( 0 == false ); // prints true
console.log( 0 === false ); // prints false</pre>
			<p>The <code>if</code> statement body executes if the conditional is truthy. In the first example in the preceding code, the numeric value zero is seen as falsey. As the second and third examples show, <code>false</code> is equal to numeric zero, but only non-strictly. However, in the third example, the numeric value zero is not strictly equivalent to <code>false</code>.  The reason for this is that there is a difference between a <code>false</code> value and a falsey value. A <code>false</code> value is always false, but a falsey value may be one of several values, including the following:</p>
			<ul>
				<li>false</li>
				<li><code>undefined</code></li>
				<li><code>null</code></li>
				<li>-0, +0, or NaN</li>
				<li>An <code>empty</code> string</li>
			</ul>
			<p>If the value is not in the preceding list, then it is considered truthy.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor207"/>The NOT Operator</h2>
			<p>The <code>!</code> or <code>NOT</code> operator is rather unique. It is considered a "unary" operator because it only accepts one value to the right of it. By using the <code>NOT</code> operator, you essentially negate the value that precedes it. Here's an example:</p>
			<pre>var falseValue = !true;</pre>
			<p>In the preceding example, the <code>falseValue</code> variable will contain a value of <code>false</code>.</p>
			<p>A very useful feature of the <code>NOT</code> operator is the "<code>double NOT</code>." This is when two <code>NOT</code> operators are combined to double negate an expression; a true expression is negated to <code>false</code>, then back to <code>true</code>, while a <code>false</code> expression is negated to <code>true</code>, then back to <code>false</code>.</p>
			<p>When working with truthy or falsey expressions, using the <code>double NOT</code> operator alters the resulting value of these expressions to actual Boolean values. Here's an example:</p>
			<pre>if (!!1 === true) {
  console.log("this code will execute");
}</pre>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor208"/>Boolean Operator Precedence</h2>
			<p>All operators have an order of execution known as "<strong class="bold">precedence</strong>." This precedence is also apparent in mathematics and is a means to ensure that expressions are executed in a predictable manner.</p>
			<p>Consider the following code:</p>
			<pre>if (true || false &amp;&amp; false)</pre>
			<p>The preceding example could be read in two different ways. This is the first way:</p>
			<pre>if ((true || false) &amp;&amp; false)</pre>
			<p>This is the second way:</p>
			<pre>if (true || (false &amp;&amp; false))</pre>
			<p>If you follow the code from left to right, as in the first example of interpretation, it will return <code>false</code>, because the <code>&amp;&amp;</code> operator is executed last. There, the code will be reduced to the following:</p>
			<pre>   true || false &amp;&amp; false
= true &amp;&amp; false
= false</pre>
			<p>The second interpretation, however, will produce a different result:</p>
			<pre>   true || false &amp;&amp; false
= true || false
= true</pre>
			<p>To prevent such ambiguity, operator order precedence exists. Precedence is applicable to all the operators in the JavaScript language, but we'll list just those that are applicable to <code>Boolean</code> expressions here:</p>
			<div><div><img alt="Figure 5.9: Boolean operators and their associativity&#13;&#10;" src="img/C14377_05_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: Boolean operators and their associativity</p>
			<p>In the preceding table, the top row has the highest precedence and so is evaluated first, while the bottom row has the lowest precedence and is evaluated last.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor209"/>Boolean Operator Associativity</h2>
			<p>In the previous table, each operator is given an associativity description.  Associativity relates to the execution direction of an expression. Most operators have "left-to-right" associativity, which means the left-hand side expression is executed before the right-hand side expression. The <code>NOT</code> operator, however, executes its right-hand expression first.</p>
			<p>Associativity can be very important, especially when side effects occur within an expression. In the following example, the expressions present on either side of a <code>||</code> operator log the parameter and return it:</p>
			<pre>function logAndReturn( value ) {
  console.log( "logAndReturn: " +value );
  return value;
}
<a id="_idTextAnchor210"/>if ( logAndReturn (true) || logAndReturn (false)) {
  console.log("|| operator returned truthy.");
}</pre>
			<p>When executed, if the <code>log_and_return</code> function returns a truthy value, then only the first execution will occur and so only that call logs a message with <code>log_and_return</code>: concatenated with the value passed in. Since the <code>||</code> operator is left-to-right associative, the entire expression is considered truthy if the left-hand side returns <code>true</code>. As such, the right-hand side is never executed. For this particular operator, the right-hand side only ever executes if the left-hand side is false. This behavior is also called a short circuit.</p>
			<p>Since the side effect of <strong class="bold">logAndReturn</strong> is only logging the value, this provides a useful tool for debugging. However, consider a function that receives an object as a parameter, modifies it, and then returns a value:</p>
			<pre>// Following two variables are set to "anonymous" (simple) objects,
// each with two fields, 'name' and 'happy', set to initial values (both sad)
var john= {name: "John", happy: false};
var lucy= {name: "Lucy", happy: false};
function make_happy( person ) {
  console.log("Making " +person.name+ " happy.");
  person.happy= true;
  return true;
}
if (make_happy(john) || make_happy(lucy)) {
  console.log("John is happy: " +john.happy+ ", Lucy is happy: " +lucy.happy);
}</pre>
			<p>Both objects follow the same structure and the <code>make_happy</code> function could possibly work with either object. However, when the conditional is called, only <code>john</code> will be updated since the <code>||</code> condition in the conditional expression is satisfied on its left-hand side. </p>
			<p>The right-hand side is never executed. Therefore, if the code is dependent on both objects being modified at a later date, it will fail.</p>
			<p>This same caveat is true for the <code>&amp;&amp;</code> operator. Since an <code>&amp;&amp;</code> operator expression is considered <code>true</code> if both sides are truthy, then both sides will only execute if the left-hand side execution returns <code>true</code>.</p>
			<p>The associative execution rule for the <code>||</code> operator is particularly useful when working with variables. In some circumstances, it is preferable to assign a default value to a variable if, and only if, it does not already contain a value. In this instance, using the <code>||</code> operator can make light work of this task:</p>
			<pre>distanceLimit = distanceLimit || 5;</pre>
			<p>If the variable already contains a value, then it will keep that value. However, if its value is <code>null</code>, <code>undefined</code>, or some other falsey value, then it will be assigned the value 5.</p>
			<p>Similarly, using the <code>&amp;&amp;</code> operator is great if you wish to execute a function if a preceding variable is truthy:</p>
			<pre>items.length &amp;&amp; processItems(items);</pre>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor211"/>Exercise 5.04: Free Home Delivery Eligibility Validation</h2>
			<p>In this exercise, we will create a function that will determine whether the customers of a grocery store are eligible for free home delivery. The store only delivers to customers who are located within 5 miles of the store. To make this exercise more interesting, the store recently decided to provide free delivery for customers located within 10 miles of the store, but only if those customers have an active membership for their loyalty program. Moreover, if customers are within 1 mile of the store, they aren't eligible for free home delivery, regardless of their membership status. Let's get started:</p>
			<ol>
				<li value="1">Define your function signature. The function should accept the distance of the customer's house from the store and their membership status:<pre>function isEligible(distance, membershipstatus) {</pre><p>Based on the store's criteria, the function will return <code>true</code> if the customer is eligible for free delivery and <code>false</code> if they are not. Functions that describe something in a <code>Boolean</code> fashion are often labeled <code>is</code>, such as <code>isValid</code>, <code>isEnabled</code>, or <code>isGoingToReturnABoolean</code>.</p></li>
				<li>There are two ways to build the body of this function; either break the problem up into small chunks and test the parameters bit by bit or create a single conditional that detects all the appropriate outcomes. We'll work with the latter in order to appropriately demonstrate the content of this chapter thus far. The following if statement is a negative check – it checks whether a customer is not eligible for free home delivery:<pre>if (distance &lt; 1 || membershipstatus === "active" &amp;&amp; distance &gt; 10 || membershipstatus === "inactive" &amp;&amp; distance &gt; 5 ) {</pre><p>This is the crux of the exercise. The <code>Boolean</code> operators are executed in the following order, but only those that are necessary to determine the overall result. First and always is the relative check for houses within <code>1</code> mile of the store. If the house is within <code>1</code> mile of the store, the overall result is <code>true</code>, and the rest of the expression is not evaluated at all. Only if the distance is <code>1</code> mile or more is the overall result not determined yet and the following goes ahead. Only if the membership status is active does the check for a distance greater than <code>10</code> miles come. Otherwise, if the membership status is inactive, there comes the check for a <code>distance</code> of greater than <code>5</code> miles. Then, those results are with the less-than-1-mile check. Due to operator precedence, no grouping using parentheses was required.</p></li>
				<li>If the conditional evaluates as truthy, then we want to report that the person is not eligible for free delivery:<pre>    return false;</pre></li>
				<li>Since the function will simply halt here, if the conditional block is executed, simply return <code>true</code> for anything that slips past:<pre>  }
  return true;
}</pre></li>
				<li>With the function complete, try different parameter variations to test it:<pre>console.log( isEligible(.5, "active") );
// =&gt;   false
console.log( isEligible(7, "inactive") );
// =&gt;   false
console.log( isEligible(7, "active") );
// =&gt;    true</pre></li>
			</ol>
			<div><div><img alt="Figure 5.10: Exercise 5.04 output&#13;&#10;" src="img/C14377_05_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Exercise 5.04 output</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor212"/>Why You Shouldn't Compare Boolean and Non-Boolean Expressions</h2>
			<p>While many non-Boolean values and objects are considered truthy, they may not be equal to <code>Boolean</code> <code>true</code>:</p>
			<pre>console.log( 1 == true ); // =&gt; true, but:
console.log( 2 == true ); // =&gt; false, because true first converts to 1
console.log( 2 == false ); // =&gt; also false, because false converts to 0</pre>
			<p>A good rule of thumb is to convert the non-Boolean expression into a <code>Boolean</code> type with <code>!!</code> – the double negation:</p>
			<pre>console.log( !!2 == true ); // =&gt; true
console.log( !!2 == false ); // =&gt; false</pre>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor213"/>Why You Shouldn't Chain Comparison Expressions</h2>
			<p>Repeated applications of the same operator to more than two expressions are called chaining. Usually, this is practical and clear:</p>
			<pre>console.log( 1 + 2 + 3 ); // =&gt; 6
console.log( true &amp;&amp; true &amp;&amp; false ); // =&gt; false</pre>
			<p>It may also be tempting to use this process with comparison operators, but that would give a surprising, and incorrect, result. In such circumstances, the intermediary result of the first <code>Boolean</code> comparison would provide a <code>Boolean</code> outcome. Therefore, when it is compared with the next number in the chain, it will be converted by the JavaScript engine into a <code>1</code> (if it is <code>true</code>) or a <code>0</code> (if it is <code>false</code>):</p>
			<pre>console.log( 1 &lt; 3 &lt; 2 ); // 1&lt;3 =&gt; true, but then: true&lt;2 =&gt; 1&lt;2 =&gt; true!</pre>
			<p>Similar confusion arises when using comparison operators:</p>
			<pre>console.log( 2==2==2 ); // 2==2 =&gt; true, but then: true==2 =&gt; 1==2 =&gt; false!
// Similarly with 0:
console.log( 0==0==0 ); // 0==0 =&gt; true, but then: true==0 =&gt; 1==0 =&gt; false!
// However, not the same with 1:
console.log( 1==1==1 ); // 1==1 =&gt; true, then: true==1 =&gt; 1==1 =&gt; true</pre>
			<p>Therefore, avoid chaining any comparison operators unless you're explicitly working with <code>Boolean</code> values.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor214"/>The Ternary Operator</h2>
			<p>So far, we have looked at unary and binary operators, but another operator is also supported in JavaScript. Known simply as the ternary operator, it performs a similar role to <code>if...else</code>, but in a much more compact fashion. The <code>ternary</code> operator consists of a question mark (<code>?</code>) and a colon (<code>:</code>), which are used to denote a conditional expression <code>?</code>, a true expression with if <code>false</code> expression. For example:</p>
			<pre>var action = (score &lt; 40) ? "Fail" : "Pass";</pre>
			<p>This, of course, is the same as the following:</p>
			<pre>var action;
if (score &lt; 40) {
  action = "Fail";
} else {
  action = "Pass";
}</pre>
			<p>The primary difference here is that the <code>ternary</code> operator is an expression in itself. This differs from <code>if</code>, which is a statement (it does not return a value).</p>
			<p>The conditional segment of the <code>ternary</code> operator does not need to be enclosed in parentheses but is often seen as such so that it closely resembles an <code>if</code> expression. The rules for each of the three expressions are simply that they must be expressions; you cannot use <code>if</code>, <code>while</code>, or another such statement, otherwise an error will be thrown.</p>
			<p>As ternary operators are expressions, they can be nested. Each question mark segment of the operator expects a colon segment to follow, much like nesting groups of brackets. Therefore, it is possible, and acceptable, to do the following:</p>
			<pre>var status = (score &lt; 40) ? "Fail" : (score &gt; 90) ? "Outstanding Score" : "Pass";</pre>
			<p>This is equivalent to the following:</p>
			<pre>var status;
if (score &lt; 40) {
  status = "Fail";
} else if (score &gt; 90) {
  status = "Outstanding Score";
} else {
  status = "Pass";
}</pre>
			<p><code>Ternary</code> operators are very useful for keeping your code succinct. Sometimes, utilizing a complete <code>if...else</code> statement detracts from the purpose of the code and makes it harder to understand. Feel free to use the <code>ternary</code> operator where you see fit.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor215"/>Working with Numbers</h1>
			<p>All numbers in JavaScript are 64-bit floating-point values. Unlike other languages, there is no internal differentiation between floating-point values and integers. JavaScript provides several objects containing functions that are orientated specifically around floating-point values and integers. However, these objects are semantic. Therefore, applying integer-specific functions to a number will still result in a floating-point value.</p>
			<p>Numbers are the simplest form of data represented by the JavaScript engine. Number values are immutable, which means their value cannot be modified in memory. If you assign a new number to a variable, you are simply overwriting the old value with the new. The existing value is not modified.</p>
			<p>Since <code>numbers</code> are passed to variables by value, it is not possible for two variables to point to the same <code>number</code> address space. Therefore, working with <code>number</code> values is considered pure, providing you do not reassign values to variables.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor216"/>Arithmetic Limitations</h2>
			<p>Floating-point values can pose something of a problem in JavaScript. Due to their <code>binary</code> encoding, which is how the <code>number</code> is represented in bits within the JavaScript engine, simply adding two floats together may not produce the result you are expecting. Consider the following:</p>
			<pre>0.1 + 0.2;  // outputs 0.30000000000000004</pre>
			<p>Here, the response should be <code>0.3</code>, but it is not. The underlying runtime simply does not handle values in a way that allows them to be accurate, even with a single <code>decimal</code> place.</p>
			<p>If accuracy is necessary for your application, there are a number of tricks that provide the correct output. With regards to the preceding example, simply converting the values into decimals before the addition will yield better accuracy. You can then convert the resulting value back into a floating-point number afterward, like so:</p>
			<pre>((0.1 * 10) + (0.2 * 10)) / 10;  // outputs 0.3</pre>
			<p>The same is also true for multiplication and division:</p>
			<pre>0.0032 * 13;  // outputs 0.041600000000000005</pre>
			<p>However, if you convert into an <code>integer</code> first, then the result is more accurate:</p>
			<pre>0.0<a id="_idTextAnchor217"/>032 * 1000 * 13 / 1000; // outputs 0.0416</pre>
			<p>This limitation is not restricted to JavaScript. In fact, any language that works with 64-bit IEEE 754 floating-point numbers will have the same limitations. There are numerous libraries available on the internet that help with these issues, if you would prefer not to tackle them yourself.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The largest integer values that JavaScript can represent as numbers are <code>9,007,199,254,740,991</code> and -<code>9,007,199,254,740,991</code>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor218"/>The Number Object</h2>
			<p>As we mentioned previously, numbers in JavaScript are primitives. As such, they have no properties or methods. Contrary to this, however, the JavaScript engine maintains an awareness of where numerical literals and variables are used within your application and provides syntactic support for methods via the <code>number</code> object. It is even possible to extend this object using prototypes, which will be explained in full in Part Four. Any extension imposed on the <code>Number</code> object will be usable against numeric values in your application:</p>
			<pre>5.123.toPrecision(3);
  // returns "5.12"</pre>
			<p>Note that while it may seem as though numerical values are objects, this is not actually the case. In memory, numbers are very simple values. The <code>Number</code> object, and its implementation by the JavaScript runtime, merely provides many of the benefits afforded with objects against these values.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor219"/>Number Functions</h2>
			<p>The <code>Number</code> object contains an assortment of functions that work with numeric values. Like all objects, the <code>Number</code> object provides a constructor that, if invoked with the <code>new</code> keyword, creates a <code>Number</code> object instance. Numbers that are created with the <code>Number</code> constructor are actual objects, which is contrary to the previous statement, that is, that numbers are not objects, and is the cause of a lot of confusion. To make things even more interesting, the resulting object instance can be treated just like any other number.</p>
			<p>In addition to the constructor is the <code>Number</code> function. This is used in the same manner as the <code>Number</code> constructor but without the <code>new</code> keyword. Invoking this function returns a <code>number</code>, not an <code>object</code>:</p>
			<pre>var num1 = 99;
var num2 = Number(99);
var num3 = new Number(99);
console.log(num1 == num2); // outputs 'true'
console.log(num1 == num3); // outputs 'true'
console.log(num2 == num3); // outputs 'true'
console.log(num1, num2, num3); // outputs '99 99 Number {99}'</pre>
			<p>In all the instances detailed in the preceding code, the resulting values can be worked with in the same manner and with the same rules, except when dealing with truthy conditionals. Typically, conditionals see the value <code>0 </code>(zero) as a falsey value, but the value returned from <code>new Number(0)</code> is truthy, even though it is also zero.</p>
			<pre>console.log( false==new Number(0) ); // =&gt; true, meaning that Number(0) equals to false, but:
if( new Number(0) ) { // =&gt; truthy
  console.log("truthy");
}
else {
  console.log("falsey");
}</pre>
			<p>Likewise, when comparing by type, the value that's returned from <code>new Number(0)</code> is an object, not a number, so strict comparisons against numeric literals will fail.</p>
			<p>Both the <code>Number</code> function and constructor will accept any value type. If the value type cannot be converted into a number, then <code>NaN</code> (not a number) is returned:</p>
			<pre>console.log( Number(true) ); // 1
console.log( Number(false) ); // 0
console.log( Number("5") ); // 5
console.log( Number([]) ); // 0
console.log( Number([1, 2, 3]) ); // NaN</pre>
			<p>When working with JavaScript, it is advised not to use the <code>Number</code> constructor at all so that your code is more readable.</p>
			<p>Aside from the <code>Number</code> function and constructor, the global <code>Number</code> object also provides a variety of functions to help us identify or parse numeric values:</p>
			<div><div><img alt="Figure 5.11: Number functions and their descriptions&#13;&#10;" src="img/C14377_05_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Number functions and their descriptions</p>
			<p>Each of these functions is <code>static</code> and so must be preceded with the global <code>Number</code> object (which acts as a class in many languages), except when using <code>parseFloat</code> or <code>parseInt</code>. These functions are also global and therefore can be invoked without the preceding <code>Number</code>, like so:</p>
			<pre>console.log( Number.parseFloat("1.235e+2") ); // outputs 123.5
console.log( parseFloat("1.235e+2") ); // outputs 123.5 again</pre>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor220"/>Number Methods</h2>
			<p><a id="_idTextAnchor221"/>Since the JavaScript parser semantically identifies numeric values, it is possible to invoke instance methods of the Number object against them, just like we can with actual objects. The majority of these methods are used to format <code>numeric</code> values as <code>string</code> representations, which is very useful for presentation in web pages:</p>
			<div><div><img alt="Figure 5.12: Number methods and their descriptions&#13;&#10;" src="img/C14377_05_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Number methods and their descriptions</p>
			<p>Using a combination of the <code>Number</code> functions and methods, it is possible to convert to and from numeric values as necessary, though some precision may be lost:</p>
			<pre>console.log( 123.456.toLocaleString() ); // outputs "123.456"
console.log( 123.456.toFixed(1) ); // outputs "123.5"
console.log( 123.456.toExponential(3) ); // outputs "1.235e+2"</pre>
			<p>However, calling those functions on integer literals (rather than floats) fails:</p>
			<pre>console.log( 123.toString() ); // =&gt; Uncaught SyntaxError: Invalid or unexpected token</pre>
			<p>When JavaScript sees the first dot right after one or more digits, it assumes you want to write a float literal. There are some workarounds to this:</p>
			<pre>console.log( 123.0.toString() ); // Append .0. It will still be represented as an integer (as far as it fits in the integer range)
console.log( (123).toExponential(2) ); // Wrap within parentheses (..)</pre>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor222"/>Number Properties</h2>
			<p>The global <code>Number</code> object provides a variety of constant properties, which is useful when comparing your numeric values. The most important of these is <code>NaN</code>. Being able to identify numeric discrepancies outside of the JavaScript runtime's ability to calculate provides you with a means to reduce bugs in your code. For instance, observe the following example:</p>
			<pre>var num = 999 / 0;</pre>
			<p><a id="_idTextAnchor223"/>When executed, the result of <code>num</code> is the constant value known as Infinity. Since it is not possible to add, deduct, multiply, or divide other values from infinity, any further math against that value will also be Infinity.  Therefore, being able to deduce this restriction within your code will provide an early warning that something may be amiss in your logic.</p>
			<p>Other properties of Number include the following:</p>
			<div><div><img alt="Figure 5.13: Number properties and their descriptions&#13;&#10;" src="img/C14377_05_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Number properties and their descriptions</p>
			<p>Both <code>MAX_SAFE_INTEGER</code> and <code>MIN_SAFE_INTEGER</code> are interesting values. Consider the following code:</p>
			<pre>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2;</pre>
			<p>Surprisingly, the result of the preceding expression is <code>true</code>. This is simply because the numbers exceed safety boundaries and are therefore no longer accurately represented. The precision that's used in both sides of the preceding expression results in the same value and thus are considered equal.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor224"/>Exercise 5.05: Currency Formatter</h2>
			<p>In this exercise, we will create a function that can take a numeric value parameter as a <code>number</code> or <code>string</code> and format it into a price value with two-decimal precision. In order to prepend a <code>currency</code> symbol, the function will accept it as a parameter. Let's get started:</p>
			<ol>
				<li value="1">Define your function signature. This function will accept two parameters. The first of these will be the decimal value and the second will be the currency symbol:<pre>function formatPrice(value, currency) {</pre></li>
				<li>When executing, the first task that the function performs should be to validate the quality of the passed parameter values. The <code>value</code> parameter must be able to be converted into a numeric value, while the <code>currency</code> parameter should be a character <code>string</code>. If the <code>currency</code> is falsey, such as when no parameter has been passed, then we can default its value to the dollar symbol:<pre>  value = Number(value);
  currency = currency || "$";</pre></li>
				<li><a id="_idTextAnchor225"/>When responding to errors, there are many ways we can notify the caller that something went wrong. In this instance, we'll simply return <code>null</code>. This way, the caller will know that anything other than a <code>string</code> response means that something wasn't quite right:<pre>  if (Number.isNaN(value) || typeof currency != "string") {
    return null;
  }</pre></li>
				<li>Now that we know the parameters are usable, combine them into the correct format and return the value:<pre>  return currency + value.toFixed(2);
}</pre></li>
				<li>If you go ahead and execute this function, you will see the appropriate responses:<pre>console.log( formatPrice(1.99, 32) ); // =&gt; null
console.log( formatPrice(5, "£") ); // =&gt; £5.00
console.log( formatPrice(9.9) ); // =&gt; $9.90
console.log( formatPrice("Ted") ); // =&gt; null</pre></li>
			</ol>
			<div><div><img alt="Figure 5.14: Exercise 5.05 output&#13;&#10;" src="img/C14377_05_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Exercise 5.05 output</p>
			<p>We can see the output once all four functions are run in the preceding figure. In this exercise, we created a function that took a numeric value parameter as a <code>number</code> or <code>string</code> and formatted it into a price value with two-decimal precision.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor226"/>Working with Strings</h1>
			<p>Like <code>numbers</code>, <code>strings</code> are simple immutable data types that are managed within the JavaScript runtime as a list of binary values, which are representable as characters. Since they are immutable, they cannot be altered. If you modify a <code>string</code>, using one of the various methods provided, you are actually creating a new string with the changes applied.</p>
			<p>The literal representation of strings is a list of characters surrounded by quotes. These quotes can be double quotes, single quotes (apostrophes), or backticks:</p>
			<pre>console.log( "I am a string" );
console.log( 'I am also a string' );
console.log( `I am a special string` );</pre>
			<p>Strings can be thought of as a long list of single characters, much like arrays, which will be discussed later. As such, it is possible to query individual, or groups of, characters:</p>
			<pre>["H", "e", "l", "l", "o", ",", " ", "W", "o", "r", "l", "d", "!"]</pre>
			<p>The preceding code is not a literal representation, but simply an analogy of how strings may be perceived. Since strings are lists, it is possible to retrieve characters from them using the character index. This is performed by enclosing the index with square bracket symbols. The index of a character string starts at <code>0</code> (zero):</p>
			<pre>"Hello, World!"[7];
// =&gt;   "W"</pre>
			<p>Since strings are immutable, you cannot assign a replacement character to an index, like so:</p>
			<pre>var msg = "Hello, World!";
console.log( msg[7] = "Z" ); // =&gt; "Z"
msg; // =&gt;  "Hello, World!"</pre>
			<p>It is not possible to modify a <code>string</code>. Instead, you can only create a new one based on the original. You can either reconstruct it using operators or use one of the many <code>string</code> functions provided by the <code>String</code> object, which will be described shortly.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor227"/>Special Characters</h2>
			<p>Since strings are contained in quotes, placing the same quotes within the string can be problematic. Simply typing the quote in the string is the same as terminating that string. This will then mean that any proceeding characters may be seen as malformed JavaScript code or, possibly worse, executable JavaScript code.</p>
			<p>One way to avoid terminating the <code>string</code> is to use a different quote to the type used to contain the <code>string</code>. For instance, if the string is contained in double quotes, then single quotes can be used freely. Likewise, containing the <code>string</code> in single quotes will allow double quotes to be used freely:</p>
			<pre>console.log( "I can contain 'single' quotes" );
console.log( 'I can contain "double" quotes' );</pre>
			<p>This will work for simple text but is not as foolproof for strings that need to contain both quote types.</p>
			<p>The JavaScript language provides a means to <code>escape</code> characters included within strings so that they are treated differently. This is performed by preceding the character to escape with a backslash (<code>\</code>) character. In the case of quotes, escaping ensures that the quote character is not seen as the string termination character:</p>
			<pre>"It's useful to be able to \"escape\" quotes"</pre>
			<p>The <code>escape character</code> can be used with several other characters for varying effects. It is even used to escape the escape character, for times when a backslash must exist within a <code>string</code>:</p>
			<pre>"This \\ will create a single backslash"</pre>
			<p>Other supported escape characters include the following:</p>
			<div><div><img alt="Figure 5.15: Escape Characters&#13;&#10;" src="img/C14377_05_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Escape Characters</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor228"/>Concatenation</h2>
			<p>Concatenating is a means of combining elements, end to end, to form a new element. With regards to strings, this is simply combining strings together to form a larger string.</p>
			<p>String concatenation is performed using the plus (<code>+</code>) symbol. This is known as method overloading:</p>
			<pre>"This string " + "and " + "this string " + "are concatenated";
// =&gt;  "This string and this string are concatenated"</pre>
			<p>When concatenating strings, it is important to pay attention to the presence of space characters. No additional characters are added at the point of concatenation. Therefore, if you require spaces between combined strings, you must add these yourself.</p>
			<p>Since strings are immutable, concatenating strings creates a new string, which you can assign to a variable or pass as a parameter to a function. The original strings remain unaffected.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor229"/>Template Literals</h2>
			<p>Template literals are a more recent addition to the JavaScript language. Surrounding strings with backtick quotes (<code>`</code>) alter the translation of the literal by the JavaScript engine and afford some additional new features.</p>
			<p>The first interesting feature, and the one that's the most commonly used, is the ability to interpolate expressions within a <code>string</code>. This is performed by embedding blocks within the string preceded with the dollar (<code>$</code>) character. Combining strings in this fashion provides the benefit of making string literals easier to read, but can also greatly simplify more complex string concatenation requirements:</p>
			<pre>var str = `2 + 2 = ${2 + 2}`;
console.log( str ); // =&gt;  "2 + 2 = 4"
var name = "Jonny";
welcomeStr = `Hello, ${name}!`;
console.log( welcomeStr );  // =&gt; "Hello, Jonny!"</pre>
			<p>Another useful feature of template literals is the ability to use physical line breaks. By applying line breaks to the JavaScript code, those same breaks appear within the resolved string:</p>
			<pre>var str = `This is line one
and this is line two`;
console.log( str );
// =&gt; "This is line one
// =&gt;  and this is line two"</pre>
			<p>Finally, a template expression can contain inner template literals within it too, thereby providing a nested template literal implementation. You'll see them in the next example. This caters to more complex expressions within the <code>string</code> itself, such as conditionals or loops.</p>
			<p>The result of template literals is a feature within JavaScript that lends itself very nicely to processing pages, and other string data content, in a manner that is more manageable. Where JavaScript developers once looked toward third-party libraries to perform such feats, such libraries are no longer required.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor230"/>Exercise 5.06: Email Templates</h2>
			<p>In this exercise, you will create a function that accepts the components of an email sending service and combines them into an email body template. To make things more interesting, only adults are eligible to post comments on the website. Accordingly, the message text will change. Let's get started:</p>
			<ol>
				<li value="1">Start off by creating a function signature. The parameters of the function determine the values that can be entered into the email body. As stated in the description, we will require an <code>age</code> parameter:<pre>function sendEmail(name, age, comments) {</pre></li>
				<li>With this in place, check the passed parameters now. If any are invalid, the function will simply return <code>null</code>:<pre>  var age = Number(age);
  if (Number.isNaN(age)
  || typeof name != "string"
  || typeof comments != "string") {
    return null;
  }</pre><p>Here, we're checking whether the number can be used as a valid numerical value and whether the <code>name</code> and <code>comments</code> are <code>strings</code>. We could also choose to check the length of the strings to ensure they have content, but that is not necessary for this exercise.</p></li>
				<li>Now that we have valid parameters, we'll need to create our <code>body</code> text with the alluded-to nested template expression:<pre>  var body = `A user has posted a comment from the website:
  name: ${name}
  age: ${age}
  status: ${(age &lt; 18) ? `${name} is not a valid user` : `${name} is a valid  user`}
  comments: ${comments}`;</pre><p>As you can see, a <code>ternary</code> operator expression is used to populate the content of the interpolation in the <code>status</code> line. It would also be possible to invoke a function here, but it would not have been acceptable to use an actual <code>if</code> condition. The reason for this is that an <code>if</code> condition is composed of one or more blocks, which is not accepted in template interpolation syntax.</p></li>
				<li>Finally, we can close the function by returning the variable. If you now execute the function and pass in some arbitrary parameters, you should see the complete interpolated string:<pre>  return body;
}
sendEmail("Jane", 27, "Your website is fantastic!");
// =&gt;  "A user has posted a comment from the website:
// =&gt;  name: Jane
// =&gt;  age: 27
// =&gt;  status: Jane is a valid user
// =&gt;  comments Your website is fantastic!"</pre></li>
			</ol>
			<p>The expected output will be as follows:</p>
			<div><div><img alt="Figure 5.16 – Exercise 5.06 output&#13;&#10;" src="img/C14377_05_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: Exercise 5.06 output</p>
			<p>How and where you choose to concatenate or interpolate strings is up to you. When tackling a problem, consider whether the code is more readable using one form of quotation over another, especially if more than one developer will be working with the code.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor231"/>The String Object</h1>
			<p>Like number values, character strings also come with a useful object called the String object. Similarly, the String object provides numerous functions, methods, and properties oriented around strings.</p>
			<p>Also similar to the <code>Number</code> object is the <code>String</code> function, which converts any passed value into a <code>string</code>. The <code>String</code> function works by calling the value's <code>toString</code> function, which we'll discuss a little later.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor232"/>The length Property</h2>
			<p>The <code>String</code> object, and thus strings themselves, have only one property: the <code>length</code> property. As the name suggests, the <code>length</code> property returns the <code>length</code> of the <code>string</code> as an <code>integer</code>. As the indexing of a <code>string</code> starts at zero, the length is always one more than the last character index:</p>
			<pre>"Hello, World!".length;
// =&gt;  13</pre>
			<p>The <code>length</code> property is particularly useful for iterating over the <code>string</code>, or when working with many of the <code>string</code> methods when its <code>length</code> is not already known.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor233"/>String Methods</h2>
			<p>The <code>String</code> object does not have any <code>static</code> functions, but it does support strings with numerous available methods – far more than those available in the <code>Number</code> object. This chapter will not attempt to cover them all but will look at the more useful methods.</p>
			<p>Working with and manipulating strings is a common requirement in JavaScript; not just for displaying text, but for working with data in general. It is often necessary to clip, sort, modify, add, and remove segments of strings using varying criteria. As such, JavaScript provides just about every method you could think of to make these tasks simple.</p>
			<p>T<a id="_idTextAnchor234"/>he following table lists the most commonly used methods that are provided by the String object:</p>
			<div><div><img alt="Figure 5.17: String Methods&#13;&#10;" src="img/C14377_05_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17: String Methods</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor235"/>Exercise 5.07: Sentence Reversal</h2>
			<p>In this exercise, you will create a function that accepts a string of any size, trims any whitespace characters, reverses its content, and then capitalizes the first character of the string or of those following a period character. The result should look like a normal sentence from a reversed dimension. The purpose of the exercise is to understand data transformation. Transforming data is ubiquitous in software development. The JavaScript runtime transforms data when it reads your code and converts it into a running application. Being able to transform data in a simple manner will prove to be a valuable skill. Let's get started:</p>
			<ol>
				<li value="1">Start off with the function signature. We only want to accept a single parameter, which we'll call <code>str</code>; this is an abbreviation of "string":<pre>function reverse(str) {</pre></li>
				<li>Next, perform the simplest task first, that is, removing any trailing whitespace characters from the beginning and end of the string. While doing this, you should also ensure that you are actually working with a string value:<pre>  str = String(str).trim();</pre></li>
				<li>With the parameter prepared, you should now start a loop. The loop will build a new string by walking the parameter string in reverse. Therefore, you will also need to declare four additional variables, namely, a temporary variable to hold the resulting value, a variable to keep track of the current string index, a variable to store the current character, and a variable to keep track of whether the next non-whitespace character is at the start of a sentence:<pre>  var result = "", index = str.length - 1, chr, isStart = true;
  while (index &gt;= 0) {</pre><p>In the preceding code, we ensure that the counter starts at one less than the <code>length</code> of the string (the last index of the string) and that the loop iterates as long as the counter is greater than or equal to <code>0</code> (zero).</p></li>
				<li>With the loop in progress, store the character at the index into the <code>chr</code> variable:<pre>    chr = str[index];</pre></li>
				<li>With the character stored, check whether the previous iteration is found at the end of a sentence. If it was, then you will need to uppercase the next non-whitespace character. Otherwise, you will need to <code>lowercase</code> it:<pre>    if (isStart &amp;&amp; chr != " ") {
      chr = chr.toUpperCase();
      isStart = false;
    } else {
      chr = chr.toLowerCase();
    }</pre><p>If the character is the start of a sentence, then the <code>isStart</code> flag needs to be set back to <code>false</code> so that the next iteration doesn't repeat the uppercasing.</p></li>
				<li>Since the uppercasing occurred for the previous iteration, check whether you should flag a new sentence in this iteration:<pre>    if (chr == ".") {
      isStart = true;
      if (index == str.length - 1) {
        index--;
        continue;</pre><p>You detect the start of a new sentence by checking for the period character. If it is the start of a new sentence, then you set the <code>isStart</code> flag, but you also need to determine whether this is the very end of the original string. The reason for this is that you do not want to copy the last period of the original string to the start of the new string, or the result will start with a period, which will not make sense. If it is, you simply skip the character altogether by decrementing the <code>index</code> and continuing the loop.</p></li>
				<li>If the period was not at the end of the original string, make some adjustments. You will not want the new sentences to end with a space and then a period – you will require the reversal of that. Since the space will have already been applied to the result, you need to backtrack by one character and re-add the required output. As the result string has now been modified, you will need to continue to the next iteration once more:<pre>      } else {
        result = result.substr(0, result.length-1) + ". ";
        index--;
        continue;
      }
    }</pre></li>
				<li>If the loop does not continue, then the current iteration results in a regular character, which should simply be appended to the result. Decrement the index for the next iteration and close out the loop. End the function by returning the result to the caller:<pre>     result = result + chr;
     index--;
  }
  return result + ".";
}</pre></li>
				<li>Now, go ahead and execute the function. Try passing multiple sentences to it inside a single string to see the full result:<pre>reverse("This is the first sentence. This is the second.");
// =&gt;  "Dnoces eht si siht. Ecnetnes tsrif eht si siht."</pre></li>
			</ol>
			<div><div><img alt="Figure 5.18 – Exercise 5.07 output&#13;&#10;" src="img/C14377_05_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18: Exercise 5.07 output</p>
			<p>There you have it. You have just created a string manipulation function using methods from the <code>String</code> global object. Certainly, the function will not win any awards and may not work well if provided with strings containing consecutive whitespace characters, but it does work.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor236"/>The toString Method</h2>
			<p>Every primitive type in JavaScript can be converted into a string using the <code>String</code> function. When working with more complex types, however, this is not always the case. For instance, with a typical object, converting it into a <code>string</code> will produce a set result, regardless of the object's content:</p>
			<pre>var obj = {name: "Bob"};
String(obj);
// =&gt;  "[object Object]"</pre>
			<p>The reason for this is that the JavaScript engine doesn't understand how you wish the data to be parsed. It could simply be that you require the output to form a table of keys and values, or you may simply want a list of the values themselves and to discard the keys. The possibilities are endless.</p>
			<p>As such, JavaScript provides the concept of the <code>toString</code> value method.</p>
			<p><code>toString</code> is a method that exists on all data types but is required to be overridden on some of the complex types, providing that you have your own parsing logic. When calling the <code>String</code> function and passing it a value, you are in fact invoking the <code>toString</code> method on that value:</p>
			<pre>console.log( String(99) );
// =&gt;   "99"
console.log(  (99).toString() ); // See above about invoking methods on integer literals
// =&gt;  "99"
console.log( [1, 2, 3].toString() );
// =&gt;  "[1, 2, 3]"</pre>
			<p>Overriding the <code>toString</code> method is simply a case of supplying an alternative function of the same name to the data value. For instance, to override the <code>toString</code> method in a custom object, you could simply do the following:</p>
			<pre>var obj = {ted: "bob", toString: function() { return "I am Bob!" }};
obj.toString();
// =&gt;  "I am Bob!"
String(obj);
   "I am Bob!"</pre>
			<p>Working with complex objects and object functions will be described fully later in this chapter.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor237"/>Numbers with Strings</h2>
			<p><code>Numbers</code> and <code>strings</code> are both primitive data types and both overload the <code>+</code> (addition) operator. However, there is much more of a relationship between the two that can prove useful or catch you out if you are not careful.</p>
			<p>Interestingly, numbers and strings in JavaScript can often be interchangeable, thanks to an intelligent context-based system. Depending on the circumstances, JavaScript will attempt to deduce the resulting type of an expression based on the available parameters.</p>
			<p>You have already seen that strings can be concatenated using the <code>+</code> operator, but numbers can also be concatenated into strings:</p>
			<pre>"I am " + 21 + " years old";
// =&gt;  "I am 21 years old"</pre>
			<p>When the JavaScript parser identifies a numeric value and a string value passed as expressions to the <code>+</code> operator, it will convert the number into a string so that the result is a simple string concatenation. This is otherwise known as context-based casting.</p>
			<p>When the string expression is also a representation of a numerical value and is used with other numerical associated operators, such as <code>/</code> or <code>*</code>, the reverse action will occur. At such times, JavaScript's context-based casting will instead convert the string number into an actual number. Here's an example:</p>
			<pre>"42.7" * 2;
// =&gt;  85.4</pre>
			<p>JavaScript will always convert the non-string value into a string when we use the <code>+</code> operator in order to produce an expected result. It would be too confusing if the <code>+</code> operator worked differently based on the content of the string expression.</p>
			<p>Numbers can also be mathematically calculated when both expressions are a string, but again, this will only occur if you're not utilizing the <code>+</code> operator:</p>
			<pre>console.log( "10" * "10" );
// =&gt;  100
console.log( "10" + "10" );
// =&gt;  "1010"</pre>
			<p>If it is expected that you will need to add together two numbers represented as strings, such as values read from text input fields, always convert them into numbers first:</p>
			<pre> Number("10") + Number("10");
// =&gt;  20</pre>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor238"/>Working with Functions</h1>
			<p>As you've already seen, JavaScript functions are blocks of code with signatures naming the variables that were passed to them when invoked. As with any block, functions have their own stacks that encapsulate and protect data declared within them.</p>
			<p>In JavaScript, functions are considered first-class types. This means that, much like any other type, they can be assigned to variables, passed as parameters to other functions, and returned from functions. They are also able to call themselves, which is known as recursive and is the quality that helps make JavaScript a functional language.</p>
			<p>There are many forms of function in JavaScript:</p>
			<ul>
				<li>Anonymous functions</li>
				<li>Named functions</li>
				<li>Arrow functions</li>
				<li>Generator functions</li>
			</ul>
			<p>The differences between them are mostly slight syntactical changes that affect how they are used. We will briefly cover each of the function types in this chapter.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor239"/>Anonymous Functions</h2>
			<p>Since functions in JavaScript are first class, they exist as a transferable resource, much like primitives and objects. Until now, functions have been declared and assigned, which means they have a callable name.  However, a function is also an expression with two states: its <code>declared format</code> and its <code>invocation</code>.  </p>
			<p>A function can exist without providing a name in the signature, whereby it has the following format:</p>
			<pre>function (...parameters) {
   ...body
}</pre>
			<p>In JavaScript, it is possible to code a function without providing a name at declaration time. Creating functions in this way allows them to be created in place, such as in a call to another function:</p>
			<pre>otherFunction( function(a, b) { /* do something */ } );</pre>
			<p>Functions can also be assigned to variables and, of course, be received as parameters in a function call. Once an anonymous function has been assigned to a variable, it becomes a named <code>function</code>, since the variable constitutes its name:</p>
			<pre>var echo = function(subject) { console.log(subject); };
echo("Hello, World!");
// =&gt;  "Hello, World!"</pre>
			<p>In fact, up until now, you have been writing functions with a global scope. Declaring a named function simply means that a variable of the same name will be declared in the current scope and will point to that function.  For instance, the following two syntaxes are equivalent:</p>
			<pre>var myFunc = function(i) { return i + 1; };
function myFunc(i) { return i + 1; };</pre>
			<p>Declaring a function without assigning a name can be considered a function literal. Since the function exists at the point of definition, it can also be executed in place. How could that be useful? It can encapsulate entire programs and avoid dirtying the global namespace:</p>
			<pre>( function(a, b) { console.log(a + b); }
)(2, 4);
// =&gt;  6</pre>
			<p>Namespace dirtying is a term to describe functions and variables declared globally. While doing so is not disallowed, it can be problematic. If two libraries within the same web page create global variables of the same name, there can be unexpected results. Creating applications that honor a clean global environment will be discussed in a later chapter.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor240"/>Callbacks</h2>
			<p>An important use case for anonymous functions has often been asynchronous execution callbacks. When calling code that does not immediately return a value, but also does not stop the execution of code that immediately proceeds it, that code is considered <code>asynchronous</code>.</p>
			<p>Applications that contain asynchronous code need a means to alert the rest of the application once the asynchronous code has finished running and a value must be returned. In JavaScript, callbacks have long been used for this purpose:</p>
			<pre>function doSomethingAsync(data, callback) {
  async_task(data).then(    // do async request
    function(result) {    // then on return
      callback(result);    // execute callback, passing result data!
    }
   );
   //.. continue with other code ..
}</pre>
			<p>The issue with callbacks is that should numerous asynchronous calls need to occur sequentially, the resulting code file has a tendency to indent catastrophically. This issue is sometimes fondly known as the pyramid of doom or callback hell:</p>
			<pre>asyncOne(data, function(res1) {
  asyncTwo(res1, function(res2) {
    asyncThree(res2, function(res3) {
      //... ad infinitum ..
    });
  });
});</pre>
			<p>As you can see, each new request indents a further two characters. It is not uncommon for an application to possess callback chains of several tens of requests, thereby reaching the far side of the screen while coding. Developers can choose not to indent, as indentation is not a requirement, but not doing so results in harder-to-read code. To resolve this, generator functions were introduced. You will learn more about generator functions later in this chapter.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor241"/>Exercise 5.08: Functional Parameters</h2>
			<p>In this exercise, you will create a function that accepts two parameters: a primitive data type and a function. This function will then combine those parameters and return a function as a result. The returned function will work identically to the function that was passed as a parameter, with the exception that it will always receive the original primitive parameter as its argument. Let's get started:</p>
			<ol>
				<li value="1">Start off by creating the function signature. You know that it will accept two parameters and, since it will act as a kind of currying process (a term used in functional programming), that's the name that will be used here:<pre>function curry(prim, fun) {</pre><p>There is nothing special here. The <code>curry</code> function is just like any named function.</p><p>In this circumstance, it's not important what value the first parameter contains. Even if it contained <code>null</code>, that would still be valid in this instance, so you can accept whatever comes through. </p></li>
				<li>Now, check if the second parameter is a function. Otherwise, when it is invoked, an error may occur if it is some other value type:<pre>  if (typeof fun != "function") return;</pre></li>
				<li>Now for the fun part. The intention is to always populate the parameter list of the passed-in function with the first parameter of this function, however many times it is called. To do this, use a local function definition:<pre>  var ret = function() {
    return fun(prim);
  };</pre><p>As you can see, the result here is a function that, whenever it is called, will simply call the <code>fun</code> function. The <code>prim</code> parameter will always remain the same here, so the invocation will always produce the same result.</p></li>
				<li>Now, return the new function:<pre>  return ret;
}</pre></li>
				<li>Let's give this a spin. Try calling the function while trying different values as parameters:<pre>var fun = function(val) { return val + 50 };
var curry1 = curry(99, fun);
console.log( curry1() );
// =&gt;  149
console.log( curry1() );
// =&gt;  149
// calling curry1 will produce the same output however many times 
// it is called, because it is a fixed, pure function.
var curry2 = curry("Bob", fun);
console.log( curry2() );
// =&gt;  "Bob50"</pre><p>The expected output will be as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 5.19 – Exercise 5.08 output&#13;&#10;" src="img/C14377_05_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19: Exercise 5.08 output</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor242"/>Arrow Functions</h2>
			<p>Arrow functions, sometimes called <code>fat arrow</code> functions, are a simplified syntax for function declaration:</p>
			<pre>var myFun = (param) =&gt; param + 1;</pre>
			<p>As shown in the preceding example, arrow functions don't need to provide a block of code and can instead be replaced with an expression. If an expression is used, then no <code>return</code> keyword is required since expressions already return a value. However, the <code>return</code> keyword is required if a block is used, since blocks are not expressions:</p>
			<pre>var myFun = (param) =&gt; {
  return param + 1;
};</pre>
			<p>As well as functioning without a block, arrow functions can also be declared without the parentheses surrounding the parameter list:</p>
			<pre>var myFun = param =&gt; param + 1;</pre>
			<p>However, the preceding code only works if the parameters are a list of one. This is because a list of two or more parameters forms a rather ambiguous statement. For instance, consider the following:</p>
			<pre>var myFun = a, b, c =&gt; a + b + c;</pre>
			<p>When reading the preceding declaration, the compiler will not know which of the following declaration strings you are trying to achieve:</p>
			<pre>var myFun = a, b = undefined, (c) =&gt; { return a + b + c };
var myFun = a, (b, c) =&gt; { return a + b + c };
var myFun = (a, b, c) =&gt; { return a + b + c };</pre>
			<p class="callout-heading">Note </p>
			<p>The first two examples will give an error since they attempt to define an arrow function in a <code>var</code> statement, but without being assigned to a variable.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor243"/>Arrow Function Caveats</h2>
			<p>While arrow functions appear much cleaner and more flexible than regular function declarations, there are disadvantages to their use. The first disadvantage is that arrow functions cannot be used as an object constructor and it's ill-advised to use them as object methods. The reason for this has to do with the second limitation; arrow functions have no access to their own this, arguments, or super objects (discussed later in this chapter).</p>
			<p>The purpose of arrow functions is simply to enable a cleaner syntax when working with anonymous functions. Arrow functions were the first syntactical weapon against callback hell, which we described previously. As such, arrow functions should be used wisely.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor244"/>Generator Functions</h2>
			<p>Generators are a recent and rather complex addition to the JavaScript language. They are incredibly useful functions once you begin to understand them, though that may take some effort. Generators do not facilitate any means that cannot be carried out in some other fashion within the JavaScript language. As such, this section will merely touch upon the subject of generator functions in order to alert you to their usefulness.</p>
			<p>Generators provide additional power to sequence iteration. Here's an example:</p>
			<pre>for (let i = 0; i &lt; 3; i++) {
  callback(i);
};</pre>
			<p>The preceding code is an iterator. The loop iterates three times, from <code>0</code> to <code>2</code>. Each time the iteration occurs, the <code>callback</code> function is called, and the iteration result is passed to it.</p>
			<p>Now, the problem with loops is that they are a closed stack. For any custom code to execute within the loop, the loop needs to have knowledge of what to do with the iterated data. This is a restriction that generators aim to overcome.</p>
			<p>Generator functions are declared much like named and anonymous functions, but with a slight difference; an asterisk must be placed after the <code>function</code> keyword:</p>
			<pre>var myFun = function*(params) { /*body*/ };</pre>
			<p class="callout-heading">Note </p>
			<p class="callout">The arrow function format cannot be used for generator functions.</p>
			<p>When creating the function body, the same rules for named and anonymous functions apply. However, there are some differences. Take a look at the following example, based on the preceding loop:</p>
			<pre>var myFun = function*() {
  for (let i = 0; i &lt; 3; i++) {
    yield i;
  }
};</pre>
			<p>In particular, note the <code>yield</code> keyword. <code>yield</code> is a keyword that's been borrowed from multithreaded languages such as C++. Its usage in those languages is similar to its usage here. Essentially, by calling <code>yield</code>, you are asking the runtime engine to pass control back to the caller. In JavaScript, "passing back of control" includes sending a value to the caller. In the preceding example, a value will be sent each time the function yields, which will be three times in total.</p>
			<p>To use the function, you must create an instance of the generator by invoking the function:</p>
			<pre>var myGen = myFun();</pre>
			<p>Once you have a generator instance, you can acquire a value:</p>
			<pre>var firstValue = myGen.next().value;
console.log( firstValue );  // firstValue will equal 0;</pre>
			<p>You can call the <code>next</code> function many times, until the stream is exhausted. Once exhausted, the returned value will be undefined:</p>
			<pre>console.log(myGen.next().value);
// =&gt;   1
console.log(myGen.next().value);
// =&gt;  2
console.log(myGen.next().value);
// =&gt;  undefined</pre>
			<p>The return value of the <code>next()</code> function is an object with two fields:</p>
			<pre>{value: &lt;value&gt;, done: &lt;boolean&gt;}</pre>
			<p>The <code>object</code> is hidden from the previous examples and we simply return the value in order to keep things simple. The done value will return true as long as there are more yields to return from the generator. Once the generator is exhausted, it will return the following for all successive calls to <code>next()</code>:</p>
			<pre>{value: undefined, done: true}</pre>
			<p>One point to keep in mind is that the <code>yield</code> keyword may be called as many times as necessary in the <code>generator</code> function. In the previous example, the <code>yield</code> keyword was used in a loop, but it may just as easily be called elsewhere, too:</p>
			<pre>var myFun = function*() {
  var count = 0
  for (let i = 0; i &lt; 3; i++) {
    yield i;
    count += i;
  }
  yield count;
};</pre>
			<p>Generator functions may also use the <code>return</code> keyword. If <code>return</code> is used, then the returned value will be retrieved with a call to <code>next()</code>, just like yielded values. However, calling return will end the generator, meaning that no more values will be returned from calls to <code>next()</code>, even if further <code>yield</code> keywords exist in the function.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor245"/>The this Keyword </h2>
			<p>All functions, apart from arrow functions, have access to additional objects related to the functions' stack. As we mentioned previously, functions provide a stack that ring-fences the memory that's used by variables that are declared within it, while allowing access to variables declared in the functions or blocks surrounding the function being called. This is otherwise known as encapsulation and protects the outer stacks from being inadvertently corrupted by function body-related processes, while also protecting the data within the function from outside processes.</p>
			<p>The <code>this</code> keyword exists as a means to be able to directly target the context present within the execution of the function. While the variables that are declared within a function are direct members of the functions stack, the context of the function body may specifically be that of another block or object and may even be changed at invocation time to be a specific context other than the one the function is defined within:</p>
			<div><div><img alt="Figure 5.20: Global, object, and function diagram&#13;&#10;" src="img/C14377_05_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: Global, object, and function diagram</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor246"/>The arguments Keyword </h2>
			<p>Another keyword that's available to functions is the <code>arguments</code> keyword. When defining a function signature, the parameters listed within the brackets of the signature are known as "named parameters" while the values that are passed to the function during invocation are considered the "functions arguments". Named parameters map to arguments, where possible, during the execution of the function.  </p>
			<p>When calling a function, you may pass in as many or as few arguments as you like, but they do not need to total the number of parameters listed in the function signature. If you specify fewer parameters than are named in the function signature, those parameters that are not provided for will simply have a value of undefined:</p>
			<pre>function myFun(param1, param2) {
  console.log(param1, param2);
};
myFun(99);
// =&gt;  99, undefined</pre>
			<p>If,<a id="_idTextAnchor247"/> on the other hand, you specify more parameters than are listed for that function, those parameters are still made available to the function, despite not having enough named parameters; they are simply not named. In such circumstances, you can access the additional parameters using the arguments keyword.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>arguments</code> keyword is very much like an array. You can access it like an array, and you can use it in functions that expect an array. It even has built-in array-like functions. However, the <code>arguments</code> keyword is not an array.</p>
			<p>To access additional function parameters, you can target them specifically by index against the <code>arguments</code> keyword. For instance, if four arguments were passed to the function, you could access the <code>fourth</code> argument with the following code:</p>
			<pre>var someValue = arguments[3];</pre>
			<p>As you'll see later with arrays, you can find out just how many arguments were passed to the function invocation by calling the <code>length</code> property:</p>
			<pre>var numParams = arguments.length;</pre>
			<p>The <code>arguments</code> object can be extremely useful when working with functions of a more dynamic nature.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor248"/>Call and Apply</h2>
			<p>As we mentioned previously, JavaScript is an exceptionally flexible language. Since functions are first-class citizens in JavaScript, facilities are provided by the language to manipulate functions.</p>
			<p>Two of the most commonly used tools for this endeavor are <code>call</code> and <code>apply</code>.</p>
			<p>Both <code>call</code> and apply function in very much the same way: by enabling the invocation of functions while changing the function stack's context. </p>
			<p>The differences between <code>call</code> and <code>apply</code> are simply that <code>call</code> is solely used to manipulate the invoked functions context and <code>apply</code> is used for the same thing and also to supply an arbitrary number of arguments:</p>
			<pre>var fun = function () { return arguments.length; };
fun.call(this, 1, 2, 3);
// =&gt;  3
fun.apply(this, [1, 2, 3]);
// =&gt;  3</pre>
			<p>As you can see, to use <code>call</code>, you need to know the number of arguments at development time. The arguments that are used in <code>apply</code> can be of any <code>length</code> and do not have to be known.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor249"/>Exercise 5.09: Dynamic Currying</h2>
			<p>This exercise will be a continuation of the previous exercise. Since you now know much more about how functions work in JavaScript, we will take the <code>curry</code> concept to a much higher level by supporting arbitrary numbers of arguments. Let's get started:</p>
			<ol>
				<li value="1">Start off with your <code>function</code> signature. However, since you would like to support an arbitrary number of arguments, the function parameter will need to come first. Also, as the remaining parameters are <code>arbitrary</code>, there is no need to define them:<pre>var curry = function(fun) { </pre><p>Check that the first parameter is a <code>function</code> before continuing with the rest of the logic:</p><pre>  if (typeof fun != "function") return;</pre></li>
				<li>As you may have guessed, you will use the arguments object to acquire the parameters. However, you will need to manipulate the arguments list since you will not want to pass the function parameter to itself. As we mentioned previously, the <code>arguments</code> object is not an array, so you'll need to convert it into one first by manipulating it with an <code>array</code> function:<pre>  var args = Array.prototype.slice.call(arguments);
  args.shift();</pre><p>In order to convert <code>arguments</code> into an <code>array</code>, you need to call a native function of <code>array</code> instances that copies the array. The <code>slice</code> function creates a shallow copy of an array. In this case, it doesn't know that the <code>arguments</code> object is not an array, but still works fine, which is perfect for this use case. The <code>args.shift()</code> code removes the first item in the array using the newly created array's shift function. Since arrays are mutable, like objects, the <code>args</code> array value is permanently modified.</p></li>
				<li>Now that you have your parameters list, create your function wrapper, like you did previously. This time, however, the <code>fun</code> parameter will be invoked using <code>apply</code>:<pre>  var ret = function() {
    var nested_args = Array.prototype.slice.call(arguments);
    return fun.apply(this, args.concat(nested_args));
  }</pre><p>Since parameters will be supplied to the <code>curry</code> function and the returned function, the arguments of each must be joined into a single array. This is what <code>concat</code> does. The resulting array is then used as the arguments of the <code>fun</code> function.</p></li>
				<li>Finally, return the new function and close the <code>curry</code> function:<pre>  return ret;
}</pre></li>
				<li>Now, let's give this a spin:<pre>var<a id="_idTextAnchor250"/> fun = function() { return arguments.length; };
var cur1 = curry(fun, 1, 2, 3);
console.log( cur1(4, 5, 6) );
// =&gt;  6
var cur2 = curry(fun, 1, 2, 3, 4, 5, 6);
console.log( cur2(9, 8, 7, 6, 5) );
// =&gt;  11</pre><p>The expected output will be as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 5.21: Exercise 5.09 output&#13;&#10;" src="img/C14377_05_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: Exercise 5.09 output</p>
			<p>What you have just achieved is no small feat. <code>Currying</code> is a powerful tool in functional programming, and you have achieved this task with very few lines of code.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor251"/>Activity 5.01: Simple Number Comparison</h2>
			<p>A lot has been covered so far, so it's time for an activity. In this activity, you have been tasked with writing a function that will receive the grades for a student's coursework for an entire year as percentages. The function must average the result of each grade in order to determine whether the student has passed the course for the entire year. The calculation will assume the following:</p>
			<ul>
				<li>An average below 35% is an F grade.</li>
				<li>An average of 35 – 44% is a D grade.</li>
				<li>An average of 45% – 59% is a C grade.</li>
				<li>An average of 60% – 74% is a B grade.</li>
				<li>An average of 75% and over is an A grade.</li>
			</ul>
			<p>Grades for each coursework assignment may be passed as a <code>Number</code> or a <code>String</code>. No other data type is expected, so error handling is not necessary.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create a function. Argument labels aren't necessary as we won't know how many arguments there will be.</li>
				<li>Extract the arguments for the function.</li>
				<li>Get the number of arguments that were passed and store it as a variable.</li>
				<li>Add all the arguments together and calculate the average. Store this in a variable.<p class="callout-heading">Note </p><p class="callout">The final condition will always be true if the others have failed, so the condition itself can be skipped. Each condition will not be evaluated if the previous condition has been returned from the function.</p></li>
				<li>Determine the <code>grade</code> from the student based on the <code>average</code> and return it.<p class="callout-heading">Note </p><p class="callout">The solution to this activity can be found on page 724. </p></li>
			</ol>
			<p>This activity should highlight the flexibility and simplicity of common problem-solving using JavaScript functions and data types. There are, in fact, many ways to solve this problem, but attempting this in a logical, easy-to-read manner is always preferable.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor252"/>Working with Objects</h1>
			<p>In <a id="_idTextAnchor253"/>JavaScript, objects are the primary configurable data structures from which all other complex data types extend, including <code>Array</code> and <code>Date</code>. Objects work like a <code>hash map</code>; they contain <code>key</code>/<code>value</code> properties that can contain any data type, including functions and other objects.</p>
			<p>An object is defined using curly braces, much like a block:</p>
			<pre>var myObject = {};</pre>
			<p>The values that are added to an object are "members" of that object. Those members are accessible using dot notation:</p>
			<pre>var myObject = {foo: "bar"};
console.log(myObject.foo);
// =&gt;  "bar"</pre>
			<p>The key of a property may be specified with or without quotes. However, the result is exactly the same:</p>
			<pre>var myObject = {param1: 1, "param2": 2};</pre>
			<p>JavaScript is known as a prototype language, which means its object-oriented capabilities are provided by prototyping values to objects prior to instantiation. As such, JavaScript objects support the <code>prototype</code> keyword.  Prototypes are too advanced for this chapter and will be discussed at length in further chapters.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor254"/>Objects as Hashtables</h2>
			<p>Objects are very much like key/value <code>hashtables</code>: you assign a value to an object with a given <code>name</code> or <code>key</code>. These values are arbitrary, and they can be primitives, functions, objects, arrays, and so on. Once an object has been defined, you can further assign properties to them using dot notation:</p>
			<pre>var myObject = {};
myObject.age = 21;
console.log(myObject.age);
// =&gt;  21</pre>
			<p>As well as assigning values via dot notation, they can also be assigned by named index, much like an <code>array</code>:</p>
			<pre>myObject["age"] = 32;
console.log(myObject.age);
// =&gt;  32</pre>
			<p>The result is exactly the same, but there are some differences between these approaches.</p>
			<p>When using dot notation, the parameters of an object must use standard variable naming rules. These include the following:</p>
			<ul>
				<li>Only use letters, digits, underscores, and dollar symbols.</li>
				<li>Must start with a letter, dollar, or underscore symbol.</li>
				<li>Names are case-sensitive (a and A are different variables).</li>
				<li>Must not match a reserved word, such as "<code>while</code>" or "<code>if</code>".</li>
			</ul>
			<p>Objects keys, however, are not limited by this convention. By using square brackets and passing the name as a <code>string</code>, the scope for naming keys becomes much broader. In fact, you can seemingly use any <code>ASCII</code> character of your choice, including whitespace characters, with up to <code>227</code> characters in length. That's <code>134,217,728</code> characters!</p>
			<pre>var obj = {};
obj["   "] = 99;
console.log(obj["   "]);
// =&gt;   99</pre>
			<p>Aside from strings, digits may also be used as keys. This results in objects appearing much like arrays. In fact, for the most part, arrays themselves are simply objects, albeit with some superpowers of their own.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Just as strings can be used with square brackets, values can be written and read from objects dynamically simply by using variables (or expressions) between square brackets instead.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor255"/>Object Keys and Memory</h2>
			<p>When working with objects as data stores, it can be tempting to add and retrieve all kinds of data. Objects are extremely versatile containers and their use is the foundation of many applications. However, as with any language platform, data consumes memory. Every time a new key is added to an object, more memory is used on the host computer.</p>
			<p>JavaScript uses a rather intelligent <code>garbage collector</code>; whose job is to clean up discarded data. The issue is, however, that data may not be considered discarded if a reference to it exists in an object. If it isn't handled properly, then memory will continue to be consumed as you add more data, eventually resulting in your browser crashing. This is known as a memory leak!</p>
			<p>One way to remove a reference to data from an object is to simply replace it with something else. For instance, it is common in JavaScript applications to see <code>null</code> assigned to object parameters when they are no longer needed. The problem with this approach, though, is that while the original value has been detached from the object, the new <code>null</code> value has now taken its place. null is a value, after all. This may not be overly problematic as all <code>null</code> values point to the same data space, but the contained value is not the only part of the property occupying memory; the <code>key</code> is also an overhead:</p>
			<pre>var obj = {key: 99};
obj.key = null;
console.log(obj);
// =&gt;  {key: null}</pre>
			<p>In order to fully delete the reference from the object, which includes <code>key</code> and <code>value</code>, the <code>delete</code> keyword should be utilized:</p>
			<pre>var obj = {key: "data"};
delete obj.key;
console.log(obj);
// =&gt;   {}</pre>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor256"/>Object and Pass-By Reference</h2>
			<p>As we mentioned at the beginning of this chapter, primitive values are immutable and exist by value. When passing them to functions or modifying them, a new copy is made of the data, which occupies a different location in memory.</p>
			<p>Objects differ from primitive values in this regard.</p>
			<p>Objects are <code>mutable</code> data. This means that instead of a copy of the object data being passed to functions or variable assignments within your applications, a reference to the original object data is always passed. When modifying an object, it is the actual original object being altered. No new object is created:</p>
			<pre>var myObj = {key: 99};
function update(obj) {
  obj.key = 22;
  console.log(obj === myObj);  // check they are the same object
}
update(myObj);
// =&gt;   true
console.log(myObj.key);
// =&gt;   22</pre>
			<p>The reason objects work so differently is that copying object data is slow and CPU-intensive. Since objects can be nested, attempting to copy an object that has a tree of descendants linked to it can be agonizingly laborious for the host machine and is therefore completely impractical.</p>
			<p>Since objects are presented differently, care must be taken with their use. Modifying object data by passing the object to functions can be the cause of hard-to-find bugs.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor257"/>Object Iteration</h2>
			<p>Since objects work like <code>hash arrays</code>, it makes sense that functions exist to work with objects as <code>iterables</code>. The JavaScript language provides a number of functions for use when iterating over objects, but it also provides operators to this end, as seen with the in operator.</p>
			<p>The in operator converts an object into an <code>iterable</code> by iterating over its keys:</p>
			<pre>var myObj= {key: "value"};
for (const key in myObj) {
  console.log(myObj[key]);
}</pre>
			<p>The same feat can also be accomplished with the <code>Object.keys(myObj)</code> function. The difference here is that it returns the object's keys as an array, so it also has other usefulness when working with objects:</p>
			<pre>var keys = Object.keys(myObj);
for (let i=0; i&lt;keys.length; i++) {
  var key = keys[i];
  console.log(myObj[key]);
}</pre>
			<p>It can also be used like so:</p>
			<pre>var keys = Object.keys(myObj);
for (const key of keys) {
  console.log(myObj[key]);
}</pre>
			<p>As well as a means to get the object keys as an array, there is a function to retrieve the object's values as an array, too:</p>
			<pre>var values = Object.values(myObj);
for (const value of values) {
  console.log(value);
}</pre>
			<p>Finally, should you require both keys and values as associated pairs, JavaScript provides the entries function to do just that. The <code>key</code>/<code>value</code> pairs are provided as arrays, with the first item being the key and the second item being the value:</p>
			<pre>var keyValues = Object.entries(myObj);
for (const kv of keyValues) {
  console.log(kv[0], kv[1]);
}</pre>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor258"/>Object Accessors</h2>
			<p>As you may have seen, writing to and reading from objects is allowed freely, but it may not be what you want. Let's suggest, for example, that you wish to create a <code>gameState</code> object that will keep track of the player's score and the remaining <code>enemies</code> in play. By allowing data to be read and written randomly, you provide an avenue for bugs to creep into your application.</p>
			<p>Let's look at an example:</p>
			<pre>var gameState = {
  score: 0,
  enemies: 99,
  lives: 3
}</pre>
			<p>Now, one solution to restricting access to these properties would be to incorporate functions. Here's an example:</p>
			<pre>var gameState = {
  _score: 0,
  _enemies: 99,
  _lives: 3,
  addToScore: function(value) {
    this._score += value;
  },
  killEnemies: function(num) {
    this._enemies -= num;
  },
  killPlayer: function() {
    this._lives -= 1;
  }
}</pre>
			<p>Here, the member variables have been renamed to start with an underscore. This is a common practice as it is deemed that any values starting with an underscore are values that should not be accessed directly. In <em class="italic">Chapter 4</em>, <em class="italic">JavaScript Libraries and Frameworks</em>, you will find out how to protect object variables absolutely, such that direct access becomes impossible.</p>
			<p>Now, while the preceding implementation is perfectly reasonable, the properties of the objects are no longer assignable but invoked. If you needed to read back the values of those properties, you would need yet another set of functions, and those would also need to be invoked. In short, it's not very clean.</p>
			<p>JavaScript provides a solution to this conundrum through the use of accessors, also known as getters and setters. Accessors are a way to add functions that can be used like variables, whereby a getter allows for the retrieval of data and a setter enables the setting of data.</p>
			<p>The syntax for accessors is as follows:</p>
			<pre>&lt;accessor_type&gt; &lt;accessor_name&gt;() {
  .. body..
}</pre>
			<p>Let's rework the previous example to utilize getters and setters:</p>
			<pre> var gameState = {
   _score: 0,
   _enemies: 99,
   _lives: 3,
   get score() {
     return this._score;
   },
   set score(value) {
     this._score += value;
   },</pre>
			<p>Here, we can see that the <code>get.score()</code> allows getting the score and <code>set.score(value)</code> allows to set a value to the data.</p>
			<pre>   get enemies() {
     return this._enemies;
   },
   get killEnemies() {
     this._enemies--;
   },
   set killEnemies(num) {
     this._enemies -= num;
   },
   get lives() {
     return this._lives;
   },
   get killPlayer() {
     if (this.enemies &lt;= 0) {
       this._lives = 3;
     } else {
       this._lives--;
     }
   }
 }</pre>
			<p>Here, a bit of creative license has been utilized. The <code>score</code> can be read and written to, just like any other value, except when writing, instead of replacing the value, the value is added to the original value, like so:</p>
			<pre>console.log(gameState.score);
// =&gt;   0
gameState.score = 100;
gameState.score = 99;
console.log(gameState.score);
// =&gt;   199</pre>
			<p>The <code>enemies</code> value can be read as normal, but by calling <code>killEnemies</code>, passing a value will deduct it from the current value, but passing no total will deduct <code>1</code> from the value:</p>
			<pre>console.log(gameState.enemies);
// =&gt;   99
gameState.killEnemies = 3;
console.log(gameState.enemies);
// =&gt;   96
gameState.killEnemies;
console.log(gameState.enemies);
// =&gt;   95</pre>
			<p>Finally, reading the player's lives property will return the current number of lives, but reading <code>killPlayer</code> will either deduct a life or it will reset it back to <code>3</code> lives should there be no enemies left. This may be useful, for instance, if you wanted to reset the player's lives after they've completed the game:</p>
			<pre>console.log(gameState.lives);
// =&gt;   3
gameState.killPlayer;
console.log(gameState.lives);
// =&gt;   2
gameState.killEnemies = 99;
gameState.killPlayer;
console.log(gameState.lives);
// =&gt;   3</pre>
			<p>Note<a id="_idTextAnchor259"/> that if you assign the value of a setter to another variable, that other variable will contain whatever was passed to the setter, not the value that was determined within the setter logic. If no value is passed, then the accessor is not a getter, and so <code>undefined</code> is returned.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor260"/>Exercise 5.10: Converting Objects to toString</h2>
			<p>In this exercise, you will create a function within an object that provides a "pretty print" facility when using the object in circumstances that require a <code>string</code> value. The function will utilize the <code>toString</code> capability, which we detailed earlier in this chapter:</p>
			<ol>
				<li value="1">To begin, create an object with a bunch of different values. Add some nested objects to make things more interesting:<pre>var obj = {meaningOfLife: 42, foo: "bar", child: {me: "you", other: {him: "her"}}, toString: Object.prototype.toString};</pre></li>
				<li>Now, if you output this with <code>console.log</code>, then it should show up just fine as the console is designed to parse complex objects for debugging purposes. However, if you concatenate the object data into a string, you'll get unwanted results:<pre>var str = obj + "";
console.log(str);
// =&gt;   [object Object]</pre></li>
				<li>To rectify this, create a function that parses objects into a string representation:<pre>var objToString = function(obj, indent) {
  obj = obj || this;
  indent = indent || "";
  var res = "";</pre><p>The first thing you do here is accept both the passing of an object and utilize the current object context. This way, the function can be called against the object it exists in it, but also as a passed parameter. You'll need to do this so that you can recursively <code>stringify</code> any child objects that exist within the parent. The <code>indent</code> parameter is used to keep track of the child object indentation. For each level of child, you meet, you will want to indent it further still. This helps you visualize your object structure when printed. Finally, you also need the <code>res</code> variable to store the resulting string representation as it's being built.</p></li>
				<li>Iterate through all of the object's keys and build the string representation:<pre>  for (var k in obj) {</pre></li>
				<li>Now, this is where things get a little tricky. If a value for the <code>k</code> key is also an object, you will want to pretty print that, too. Therefore, just pass it to the same function:<pre>    if (typeof obj[k] == "object") {
      res += indent + k + " = {\n";
      res += objToString(obj[k], indent + "- ");
      res += indent + "}";</pre><p>To nest the child, the key for that child is prefixed with the value of the current indent parameter. An open curly brace is used to denote an object in the returned string. The indent is then increased in length and passed to the recursive call to the <code>objToString</code> function for the nested iteration. The child print is then closed with a closing curly brace, which is also indented.</p></li>
				<li>If the value of the key is not an object, then it might be a function. You will want to skip those as you can't cleanly print them. Everything else can be appended like a string, but will also need to be indented in case it's the value of a field in a child object:<pre>    } else if (typeof obj[k] != "function") {
      res += indent + k + " = " + obj[k];
    } else {
      continue;
    }</pre></li>
				<li>Next, apply a delimiter so that each of the keys is separated. A newline character should suffice:<pre>    res += "\n";</pre></li>
				<li>Finally, close the loop and return the value:<pre>  }
  return res;
}</pre></li>
				<li>To make this work, append the <code>objToString</code> function to the starting object as a <code>toString</code> function:<pre>obj.toString = objToString;</pre></li>
				<li>Finally, to test this out, simply concatenate the object to a string, forcing the object to be cast to a string value:<pre>obj + "";</pre><p>The output should be as follows:</p><pre>"meaningOfLife = 4
foo = bar
child = {
  - me = you
  - other = {
  - - him = her
  - }
}"</pre><p>The expected output will be as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 5.22: Exercise 5.10 output&#13;&#10;" src="img/C14377_05_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22: Exercise 5.10 output</p>
			<p>You have created a useable object <code>stringifier</code> function that works with complex objects of any depth.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor261"/>Working with Arrays</h1>
			<p>Arrays are another complex object type built on top of objects. Unlike objects, arrays are designed to work with lists of data. Arrays may be created in several ways. The first is known as an Array literal and, similarly to object literals, is simply a means of passing a defined Array value to a variable:</p>
			<pre>var myArray = [1, 2, 3];
var myEmptyArray = [];</pre>
			<p>The values of an array have no keys, and are instead accessed using integer indexes with the square bracket form:</p>
			<pre>myValue = myArray[3];</pre>
			<p>As with other types, the array type also has a constructor function that's used to create array instances. The array constructor can be passed values to prepopulate the <code>Array</code>. Therefore, the following examples are equivalent:</p>
			<pre>var arr1 = [1, 2, 3];
var arr2 = new Array(1, 2, 3);</pre>
			<p>However, when using the constructor form, passing a single integer value will create an array with a set number of values set to undefined:</p>
			<pre>var arr = new Array(3);
console.log( arr );
// =&gt;   (3) [empty x3]</pre>
			<p>Note that the <code>Array</code> constructor can lead to unintended results, should the developer intend to create an <code>Array</code> with one value as a single integer type. As such, it is considered a good practice to initialize all arrays using the literal form.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor262"/>Arrays and Mutability</h2>
			<p>Like objects, arrays are mutable objects. If you update an array that is passed into a function, the original <code>Array</code> is also modified.</p>
			<p>The <code>Array</code> object has a number of built-in functions that are useful in maintaining immutability when using arrays. They do not make the array immutable but provide a means to work with arrays while ensuring that they are copied rather than modified.</p>
			<p>The Array's immutability functions will be discussed at length in <em class="italic">Chapter 4</em>, <em class="italic">JavaScript Libraries and Frameworks</em>, when functional programming methodologies are discussed.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor263"/>Array Iteration</h2>
			<p>Arrays can be iterated in much the same way as objects. If you're using the <code>for...in</code> syntax, the element of the <code>Array</code> is the index, which is the same result when working with objects that have numerical keys:</p>
			<pre>for (var i in myArray) {
  console.log(myArray[i]);
}</pre>
			<p>This format works well if you need to iterate an array from start to finish, but this isn't very flexible. To aid the traversal of an Array, JavaScript provides a number of additional features.</p>
			<p>Since an array is a linear list, it has a <code>length</code>. The array object provides the length property, which returns the number of elements in the array:</p>
			<pre>for (let i = 0; i &lt; myArray.length; i++) {
  console.log(myArray [i]);
}</pre>
			<p>The starting index of an array is always <code>0</code>, while the <code>length</code> of an array is always one more than the last index of the <code>Array</code>.</p>
			<p>As well as retrieving a value from an array by index, it is also possible to search an array for a value and return its index using the <code>indexOf</code> function. <code>indexOf</code> takes a single parameter, that is, the value to find within the array:</p>
			<pre>var arr = [1, "b", true];
arr.indexOf("b");
// =&gt;   1</pre>
			<p><code>indexOf</code> will return the index of the value if it is found but will return <code>-1</code> if it does not. A match can be at <code>index 0</code> or above, up to but exclusive of <code>arr.length</code>. To use a result of <code>indexOf(...)</code> in a conditional statement, compare it and check whether it's higher than <code>-1</code>:</p>
			<pre>var searchedValue= "b";
 if ( arr.indexOf(searchedValue)&gt;-1 ) {
   console.log( "match found" );
}</pre>
			<p>Note that <code>indexOf</code> looks for the matching value of an element. Therefore, complex types will only be found within the Array if they exist within the Array by reference. Here's an example:</p>
			<pre>var obj = {name: "bob"};
var arr = ["a", 99, obj];
console.log( arr.indexOf(obj) );
// =&gt;   2
console.log( arr.indexOf({name: "bob"}) );
// =&gt;   -1</pre>
			<p>Since complex types of identical structure are not considered the same by value, it is not possible to find occurrences of complex objects within an Array in this manner.</p>
			<p>If multiple occurrences of a value exist within an Array, <code>indexOf</code> will return the first discovered item index. All other instances of that value will be ignored.</p>
			<p>A companion of the <code>indexOf</code> function is the <code>lastIndexOf</code> function. This function works identically to <code>indexOf</code>, with the exception that the index search starts at the end of the Array.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor264"/>Built-In Array Functions</h2>
			<p>The array type provides many more functions that are useful in traversing, copying, concatenating, and presenting array structures. The following table lists some important and useful functions that are available as members of the array type:</p>
			<div><div><img alt="Figure 5.23: Built-in array functions and their descriptions&#13;&#10;" src="img/C14377_05_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23: Built-in array functions and their descriptions</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor265"/>Working with Dates</h1>
			<p>The Date object is an important type in JavaScript but is a complicated type in any language. Like the <code>Array</code> type, the <code>Date</code> type is built on top of a JavaScript object.</p>
			<p>Dates have no literal format. As such, they must be created using the <code>Date</code> constructor. There are four ways to do this:</p>
			<ul>
				<li>An empty constructor creates a date with the current date and time.</li>
				<li>The constructor may be passed an integer representing the number of milliseconds to have passed since the beginning of <code>January 1st, 1970</code>.</li>
				<li>Supplying multiple integer parameters will specify date segments, for example:<p>(year, month, day, hour, minute, second, millisecond)</p><p>(year, month, day, hour, minute, second)</p><p>(year, month, day, hour, minute)</p><p>(year, month, day, hour)</p><p>(year, month, day)</p><p>(year, month)</p><p>Be aware that the month is specified by the numbers <code>0</code> - <code>11</code>.</p></li>
				<li>Supplying a string representation of a date:<p>ISO 8601 date format ("<code>2019-04-25</code>" or "<code>2019-04-25T12:00:00Z</code>", where months, days, and time are padded to two-digit lengths)</p><p>US short date format ("<code>04/25/2019</code>" with padded day and month)</p><p>US long date format ("<code>Apr 25 2019</code>" and so on)</p><p class="callout-heading">Note </p><p class="callout">You cannot create a <code>Date</code> instance by simply passing the year value as an integer since the JavaScript engine will not know whether you meant year or milliseconds. However, you can create a Date instance from simply passing a year string.</p></li>
			</ul>
			<p>Once a <code>Date</code> object has been constructed, it can be queried. The <code>Date</code> object provides numerous functions for extracting the elements of the <code>date</code>. The following table lists the functions that are available:</p>
			<div><div><img alt="Figure 5.24: The Date object methods and their descriptions&#13;&#10;" src="img/C14377_05_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24: The Date object methods and their descriptions</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Each of the functions provided by Date returns a value starting from 0, with the exception of the <code>getDate</code> method. This often leads to confusion and bugs, so be sure to keep this in mind.</p>
			<p>Each of the functions detailed in the preceding table also has a set equivalent, with the exception of <code>getDay</code>. Therefore, to update the hour of the <code>Date</code> instance, you simply call <code>setHour</code> and pass it an integer:</p>
			<pre> var d = new Date();
 d.setHours(12);</pre>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor266"/>Parsing Date Strings</h2>
			<p>As we mentioned previously, the <code>Date</code> constructor can accept a date string and convert it into an instance of the <code>Date</code> object. Dates are represented internally within the Date type as integers. Thus, the <code>getDate</code> method returns the true interpretation of the date value.</p>
			<p>If you have a valid date string, as detailed previously, you can convert it into a date by calling the <code>parse</code> method:</p>
			<pre>var greatDate = Date.parse("November 3, 1976");</pre>
			<p>However, the return value of the <code>Date.parse</code> method does not return a <code>Date</code> instance. Instead, it returns the number of milliseconds since <code>January 1st, 1970</code> until that date. In order to create a <code>Date</code> instance, you must, therefore, pass that resulting value to the <code>Date</code> constructor:</p>
			<pre>var millis = Date.parse("November 3, 1976");
var greatDate = new Date(millis);</pre>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor267"/>Formatting Dates into Strings</h2>
			<p>The<code> Date </code>object provides its own <code>toString</code> function. If you attempt to use a <code>Date</code> instance as a <code>string</code>, you will receive a formatted string instead:</p>
			<pre>var d = new Date();
console.log(d);
//  =&gt; current time in local timezone, for example:
// Thu Apr 25 2019 12:00:00 GMT+0100 (British Summer Time)</pre>
			<p>However, this is often not the format you require. If you wish to provide your own date string format, you can override the <code>toString</code> function of the object, much like in the <em class="italic">Working with Object</em> section of this chapter. Here's an example:</p>
			<pre>var toString = function(date) {
  date = date || this;
  var months = [
   "Jan", "Feb", "Mar",
   "Apr", "May", "Jun",
   "Jul", "Aug", "Sep",
   "Oct", "Nov", "Dec"
  ];
  var day = date.getDate();
  var mnth = date.getMonth();
  var year = date.getFullYear();
  return day + ' ' + months[mnth] + ' ' + year;
}
var d = new Date();
d.toString = toString;
console.log(d);</pre>
			<p>The output of this code will be as follows:</p>
			<pre>current date in format 25 Apr 2019</pre>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor268"/>Date Math</h2>
			<p>JavaScript provides no functions for comparing, adding, or subtracting dates. However, working out date differences or combining dates is not hard in JavaScript.</p>
			<p>Typically, there are two tasks that need to be considered when comparing dates:</p>
			<ul>
				<li>What the difference is between two dates</li>
				<li>Adding or subtracting time to/from a date</li>
			</ul>
			<p>The first task is relatively simple. Since the date can be converted into a simple integer representing the number of milliseconds since <code>January 1st, 1970</code>, the dates you wish to difference can simply be represented as milliseconds and that value can be compared. Here's an example:</p>
			<pre>var date1 = new Date("Dec 25 2001").getTime();
var date2 = new Date("Dec 25 2019").getTime();
var diff = date2 - date1;
diff
// =&gt;   567993600000</pre>
			<p>Now, with the number of milliseconds in each, you can convert that into a time unit. For example, if you wanted to find out the number of days that difference represents, you would simply do the following:</p>
			<pre>var day = 1000 * 60 * 60 * 24;
var numDays = diff / day;
numDays
// =&gt;   6574</pre>
			<p>To get the unit, you simply start with milliseconds and work up. Therefore, a day is <code>1,000 milliseconds * 60 seconds * 60 minutes * 24 hours</code>.</p>
			<p>Adding or subtracting time from dates is also very simple. The set* methods provided by the <code>Date</code> object provide a means for us to roll over values that exceed the next largest unit. For instance, if the current date is <code>April 25, 2019</code>, adding <code>10</code> days will change the date to <code>May 5, 2019</code>. This feature is applicable to all of the <code>set</code> functions. Thus, to add time, simply get the unit of time you wish to add to and add to it:</p>
			<pre>var d = new Date("Apr 25 2019");
d.setMonth(d.getMonth() + 60);
d
// =&gt;   Thu Apr 25 2024 00:00:00 GMT+0100 (British Summer Time)
// The above result will use your local timezone.</pre>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor269"/>Activity 5.02: Creating a To-Do Model</h2>
			<p>Let's utilize all the information we have learned about in this chapter and see what we have retained. For this activity, imagine that you are working with a team of developers and your project is to create a stateful model that stores entries for a To-Do application. The model will be a primary function, though other functions can be created and used by it. The function will need to store one or more entries and will receive "actions" that tell the state to change.</p>
			<p>These actions will include the following:</p>
			<ul>
				<li>Create a new To-Do</li>
				<li>Remove a To-Do</li>
				<li>Modify a To-Do</li>
			</ul>
			<p>Actions will be passed to the state with a given action keyword of either <code>CREATE</code>, <code>REMOVE</code>, or <code>MODIFY</code>.</p>
			<p>Each To-Do item in the state will have the following fields:</p>
			<div><div><img alt="Figure 5.25: Activity fields&#13;&#10;" src="img/C14377_05_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25: Activity fields</p>
			<p>The data will be passed to the state function with the action type. If the action is a <code>CREATE</code> action, then all of the preceding fields will be passed, with the exception of the <code>id</code> field. If it is a <code>REMOVE</code> action, then only the <code>id</code> is passed. It will be passed as a string value. Finally, if the <code>MODIFY</code> action is passed, then all of the data is passed, with the exception of the <code>created_at</code> value. This is because the <code>created_at</code> value shouldn't change.</p>
			<p>An important part of this task is to ensure that the state data is treated as immutable since the project manager is a fan of functional programming and wants to ensure that as few bugs as possible are added to the application. No objects, including <code>Arrays</code> and <code>Dates</code>, should be changed in this activity. Instead, new objects, <code>Arrays</code>, and <code>Dates</code> must be created, replacing the old values. This must also be true of the Array containing the <code>TODO</code> entries.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Array <code>concat</code> function returns a new Array, but any objects within it will still be references to the original values.</p>
			<p>Finally, when each action is received, the state function will need to pretty-print the data to the console. For <code>CREATE</code> actions, this will be the incoming data and for <code>REMOVE</code> actions, this will be the removed data. For <code>MODIFY</code> actions, both the removed and created data should be printed.</p>
			<p>If all goes to plan, you will be able to add, remove, and modify entries in your state function without worrying about corrupted data. You can prove this by modifying the values you send to the state function. If the entries in the state function are also modified, your model is not immutable.</p>
			<p>This activity highlights a common means to handle application data effectively and in a way that will not introduce bugs to your application. By managing data in a pure manner, you will ensure that your development practices produce reliable results in a short period of time.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Create the function signature to accept the following:<ul><li>The current state, which is the current list of To-Do items</li><li>The action, which is simply a string value</li><li>The data to apply to the state change<p>The function signature will look as follows:</p><pre>function modelStateChange(state, action, data)</pre><p>Here, <code>state</code> is the current Array of <code>ToDo</code> items in the model, <code>action</code> is either <code>CREATE</code>, <code>MODIFY</code>, or <code>REMOVE</code>, and <code>data</code> is either new <code>ToDo</code> data or simply the parameter to match a <code>ToDo</code> item to remove.</p></li></ul></li>
				<li>Create a conditional for each action type. Then, in the body of the condition, manipulate the state as needed. Remember to return the new state within the condition body. You may want to create a secondary function that does the lookup of a <code>ToDo</code> within the state as you'll need this functionality in the <code>MODIFY</code> and <code>REMOVE</code> actions.<p>Remember, this function should always return a new state value. That way, it is possible to cleanly test the function predictably and ensure that it works as intended.</p><p>An example of how this function may be called is as follows:</p><pre>todoState = modelStateChange(_todoState, "MODIFY", {id: curTodo.id, completed: true});</pre><p class="callout-heading">Note </p><p class="callout">The solution to this activity can be found on page 726. </p></li>
			</ol>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor270"/>Summary</h1>
			<p>A lot has been covered in this chapter. You should now have a deeper understanding of the types provided by JavaScript, but also the subtle ways in which each type is related. Understanding how data is represented in a language provides a solid foundation for building applications more quickly and with fewer bugs.</p>
			<p>As well as understanding the data types, you also saw how to manipulate them, both with methods and with helper functions provided by the JavaScript engine. You also saw how to convert data into different types, in order to enable data interoperability.</p>
			<p>Finally, you saw how you can debug your data using the console and using string-based data formatting capabilities provided by the language.</p>
			<p>In the next chapter, you will start down the path of user interactivity and see how events can be triggered to force your code to do something. You will also be introduced to the relationship between the JavaScript language and the HTML DOM in the browser environment.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>