<html><head></head><body>
		<div><h1 id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor037"/>2</h1>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Thinking Functionally – A First Example</h1>
			<p>In <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>, we went over what FP is, mentioned some advantages of applying it, and listed some tools we’d need in JavaScript. For now, let’s leave the theory behind and start by considering a simple problem and how to solve it in a functional way.</p>
			<p>In this chapter, we will do the following:</p>
			<ul>
				<li>Look at a simple, e-commerce-related problem</li>
				<li>Consider several usual ways to solve it (with their associated defects)</li>
				<li>Find a way to solve the problem by looking at it functionally</li>
				<li>Devise a higher-order solution that can be applied to other problems</li>
				<li>Work out how to carry out unit testing for functional solutions</li>
			</ul>
			<p>In future chapters, we’ll be returning to some of the topics listed here, so we won’t be going into too much detail. We’ll just show how FP can give a different outlook on our problem and leave further details for later.</p>
			<p>After working through this chapter, you will have had a first look at a common problem and at a way of solving it by thinking functionally, as a prelude for the rest of this book.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Our problem – doing something only once</h1>
			<p>Let’s <a id="_idIndexMarker086"/>consider a simple but common situation. You have developed an e-commerce site; the user can fill their shopping cart, and in the end, they must click on a <strong class="bold">Bill me</strong> button so that their credit card will be charged. However, the user shouldn’t click twice (or more), or they will be billed several times.</p>
			<p>The HTML part of your application might have something like this somewhere:</p>
			<pre class="source-code">
&lt;button id="billButton"
    onclick="billTheUser(some, sales, data)"&gt;Bill me
      &lt;/button&gt;</pre>
			<p>And, among the scripts, you’d have something similar to the following code:</p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p class="callout-heading">A bad example</p>
			<p class="callout">Assigning the events handler directly in HTML, the way I did it, isn’t recommended. Instead, unobtrusively, you should set the handler through code. So, <em class="italic">do as I say, not as </em><em class="italic">I do!</em></p>
			<p>This is a bare-bones explanation of the web page problem, but it’s enough for our purposes. Now, let’s get to thinking about ways of avoiding repeated clicks on that button. How can we manage to prevent the user from clicking more than once? That’s an interesting<a id="_idIndexMarker087"/> problem, with several possible solutions – let’s start by looking at bad ones!</p>
			<p>How many ways can you think of to solve our problem? Let’s go over several solutions and analyze their quality.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Solution 1 – hoping for the best!</h2>
			<p>How can we solve the <a id="_idIndexMarker088"/>problem? The first solution may seem like a joke: do nothing, tell the user not to click twice, and hope for the best! Your page might look like <em class="italic">Figure 2</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_2.1_B19301.jpg" alt="Figure 2.1 – An actual screenshot of a page, just warning you against clicking more than once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – An actual screenshot of a page, just warning you against clicking more than once</p>
			<p>This is a way to weasel out of the problem; I’ve seen several websites that just warn the user about the risks of clicking more than once and do nothing to prevent the situation. So, the user got billed twice? We warned them... it’s their fault!</p>
			<p>Your solution might simply look like the following code:</p>
			<pre class="source-code">
&lt;button
  id="billButton"
  onclick="billTheUser(some, sales, data)"&gt;Bill me
&lt;/button&gt;
&lt;b&gt;WARNING: PRESS ONLY ONCE, DO NOT PRESS AGAIN!!&lt;/b&gt;</pre>
			<p>Okay, this isn’t an <a id="_idIndexMarker089"/>actual solution; let’s move on to more serious proposals.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Solution 2 – using a global flag</h2>
			<p>The solution <a id="_idIndexMarker090"/>most people would probably think of first is using some global variable to record whether the user has already clicked on the button. You define a flag named something like <code>clicked</code>, initialized with <code>false</code>. When the user clicks on the button, if <code>clicked</code> is <code>false</code>, you change it to <code>true</code> and execute the function; otherwise, you do nothing at all. This can be seen in the following code:</p>
			<pre class="source-code">
let clicked = false;
.
.
.
function billTheUser(some, sales, data) {
  if (!clicked) {
    clicked = true;
    window.alert("Billing the user...");
    // actually bill the user
  }
}</pre>
			<p>This works, but it has several problems that must be addressed:</p>
			<ul>
				<li>You are using a global variable, and you could change its value by accident. Global variables aren’t a good idea, in JavaScript or other languages. You must also remember to re-initialize it to <code>false</code> when the user starts buying again. If you don’t, the user won’t be able to make a second purchase because paying will become impossible.</li>
				<li>You will have difficulties testing this code because it depends on external things (that is, the clicked variable).</li>
			</ul>
			<p>So, this isn’t a very good solution. Let’s keep thinking!</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Solution 3 – removing the handler</h2>
			<p>We may <a id="_idIndexMarker091"/>go for a lateral kind of solution, and instead of having the function avoid repeated clicks, we might just remove the possibility of clicking altogether. The following code does just that; the first thing that <code>billTheUser()</code> does is remove the <code>onclick</code> handler from the button, so no further calls will be possible:</p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .onclick = null;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This solution also has some problems:</p>
			<ul>
				<li>The code is tightly coupled to the button, so you won’t be able to reuse it elsewhere</li>
				<li>You must remember to reset the handler; otherwise, the user won’t be able to make a second purchase</li>
				<li>Testing will also be more complex because you’ll have to provide some DOM elements</li>
			</ul>
			<p>We can enhance this solution a bit and avoid coupling the function to the button by providing the latter’s ID as an extra argument in the call. (This idea can also be applied to some of the further solutions that we’ll see.) The HTML part would be as follows; note the extra argument to <code>billTheUser()</code>:</p>
			<pre class="source-code">
&lt;button
  id="billButton"
  onclick="billTheUser('billButton', some, sales, data)"
&gt;Bill me
&lt;/button&gt;</pre>
			<p>We also have to change the called function so that it will use the received <code>buttonId</code> value to access the corresponding button:</p>
			<pre class="source-code">
function billTheUser(buttonId, some, sales, data) {
  document.getElementById(buttonId).onclick = null;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This solution<a id="_idIndexMarker092"/> is somewhat better. But, in essence, we are still using a global element – not a variable, but the <code>onclick</code> value. So, despite the enhancement, this isn’t a very good solution either. Let’s move on.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Solution 4 – changing the handler</h2>
			<p>A variant to the<a id="_idIndexMarker093"/> previous solution would be not to remove the click function, but to assign a new one instead. We are using functions as first-class objects here when we assign the <code>alreadyBilled()</code> function to the click event. The function warning the user that they have already clicked could look something like this:</p>
			<pre class="source-code">
function alreadyBilled() {
  window.alert("Your billing process is running; don't
    click, please.");
}</pre>
			<p>Our <code>billTheUser()</code> function would then be like the following code – note how instead of assigning <code>null</code> to the <code>onclick</code> handler as in the previous section, now, the <code>alreadyBilled()</code> function is assigned:</p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .onclick = alreadyBilled;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>There’s a good point to this solution; if the user clicks a second time, they’ll get a warning not to do that, but they won’t be billed again. (From the point of view of user experience, it’s better.) However, this solution still has the very same objections as the previous one (code coupled to the button, needing to reset the handler, and harder testing), so we don’t <a id="_idIndexMarker094"/>consider it quite good anyway.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Solution 5 – disabling the button</h2>
			<p>A similar idea here <a id="_idIndexMarker095"/>is instead of removing the event handler, we can disable the button so the user won’t be able to click. You might have a function such as the one shown in the following code, which does exactly that by setting the <code>disabled</code> attribute of the button:</p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .setAttribute("disabled", "true");
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This also works, but we still have objections as with the previous solutions (coupling the code to the button, needing to re-enable the button, and harder testing), so we don’t like this solution either.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Solution 6 – redefining the handler</h2>
			<p>Another idea: instead of <a id="_idIndexMarker096"/>changing anything in the button, let’s have the event handler change itself. The trick is in the second line of the following code; by assigning a new value to the <code>billTheUser</code> variable, we are dynamically changing what the function does! The first time you call the function, it will do its thing, but it will also change itself out of existence by giving its name to a new function:</p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  billTheUser = function() {};
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>There’s a <a id="_idIndexMarker097"/>special trick in the solution. Functions are global, so the <code>billTheUser=...</code> line changes the function’s inner workings. From that point on, <code>billTheUser</code> will be the new (null) function. This solution is still hard to test. Even worse, how would you restore the functionality of <code>billTheUser</code>, setting it back to its original objective?</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Solution 7 – using a local flag</h2>
			<p>We can go <a id="_idIndexMarker098"/>back to the idea of using a flag, but instead of making it global (which was our main objection to the second solution), we can <a id="_idIndexMarker099"/>use an <code>clicked</code> will be local to the function and not visible anywhere else:</p>
			<pre class="source-code">
var billTheUser = (clicked =&gt; {
  return (some, sales, data) =&gt; {
    if (!clicked) {
      clicked = true;
      window.alert("Billing the user...");
      // actually bill the user
    }
  };
})(false);</pre>
			<p>This solution is along the lines of the global variable solution, but using a private, local variable is an enhancement. (Note how <code>clicked</code> gets its initial value from the call at the end.) The only drawback we could find is that we'll have to rework every function that needs to be called only once to work in this fashion (and, as we’ll see in the following section, our FP solution is similar to it in some ways). Okay, it’s not too hard to do, but don’t forget<a id="_idIndexMarker100"/> the <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>), usual <a id="_idIndexMarker101"/>advice!</p>
			<p>We have now gone through multiple ways of solving our “do something only once” problem – but as we’ve seen, they were not very good! Let’s think about the problem functionally so that we get a more general solution.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>A functional solution to our problem</h1>
			<p>Let’s try to be more <a id="_idIndexMarker102"/>general; after all, requiring that some function or other be executed only once isn’t that outlandish, and may be required elsewhere! Let’s lay down some principles:</p>
			<ul>
				<li>The original function (the one that may be called only once) should do whatever it is expected to do and nothing else</li>
				<li>We don’t want to modify the original function in any way</li>
				<li>We need a new function that will call the original one only once</li>
				<li>We want a general solution that we can apply to any number of original functions</li>
			</ul>
			<p class="callout-heading">A SOLID base</p>
			<p class="callout">The first principle listed previously is the single responsibility principle (the S in the <strong class="bold">SOLID</strong> acronym), which states that every function should be responsible for a single functionality. For more on<a id="_idIndexMarker103"/> SOLID, check the article by Uncle Bob (Robert C. Martin, who wrote the five principles) at <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>.</p>
			<p>Can we do it? Yes, and we’ll write a higher-order function, which we’ll be able to apply to any function, to produce a new function that will work only once. Let’s see how! We will introduce higher-order functions in <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>. There, we’ll go about testing our functional solution, as well as making some enhancements to it.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>A higher-order solution</h2>
			<p>If we don’t want to modify <a id="_idIndexMarker104"/>the original function, we can create a higher-order function, which we’ll (inspiredly!) name <code>once()</code>. This function will receive a function as a parameter and return a new function, which will work only once. (As we mentioned previously, we’ll be seeing more of higher-order functions later; in particular, see the <em class="italic">Doing things once, revisited</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a><em class="italic">, </em><em class="italic">Producing Functions</em>).</p>
			<p class="callout-heading">Many solutions</p>
			<p class="callout">Underscore and Lodash already have a similar function, invoked as <code>_.once()</code>. Ramda also provides <code>R.once()</code>, and most FP libraries include similar functionality, so you wouldn’t have to program it on your own.</p>
			<p>Our <code>once()</code> function<a id="_idIndexMarker105"/> may seem imposing at first, but as you get accustomed to working in an FP fashion, you’ll get used to this sort of code and find it to be quite understable:</p>
			<pre class="source-code">
// once.ts
const once = &lt;FNType extends (...args: any[]) =&gt; any&gt;(
  fn: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
      return fn(...args);
    }
  }) as FNType;
};</pre>
			<p>Let’s go over some of the finer points of this function:</p>
			<ul>
				<li>Our <code>once()</code> function receives a function (<code>fn</code>) as its parameter and returns a new function, of the same type. (We’ll discuss this typing in more detail shortly.)</li>
				<li>We define an internal, private <code>done</code> variable, by taking advantage of <em class="italic">closure</em>, as in <em class="italic">Solution 7</em>. We opted not to call it <code>clicked</code> (as we did previously) because you don’t necessarily need to click on a button to call the function; we went for a more general term. Each time you apply <code>once()</code> to some function, a new, distinct <code>done</code> variable will be created and will be accessible only from the returned function.</li>
				<li>The <code>return</code> statement shows that <code>once()</code> will return a function, with the same type of parameters as the original <code>fn()</code> one. We are using the spread syntax we saw in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>. With older versions of JavaScript, you’d have to work with the arguments object; see <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments</a> for more on that. The modern way is simpler and shorter!</li>
				<li>We assign <code>done = true</code> before calling <code>fn()</code>, just in case that function throws an exception. Of course, if you don’t want to disable the function unless it has successfully ended, you could move the assignment below the <code>fn()</code> call. (See <em class="italic">Question 2.4</em> in the <em class="italic">Questions</em> section for another take on this.)</li>
				<li>After the setting is<a id="_idIndexMarker106"/> done, we finally call the original function. Note the use of the spread operator to pass along whatever parameters the original <code>fn()</code> had.</li>
			</ul>
			<p>Typing for <code>once()</code> may be obscure. We have to specify that the type of the input function and the type of <code>once()</code> are the same, and that’s the reason for defining <code>FNType</code>. <em class="italic">Figure 2</em><em class="italic">.2</em> shows that TypeScript correctly understands this (Check the answer to <em class="italic">Question 1.7</em> at the end of this book for another example of this):</p>
			<div><div><img src="img/Figure_2.2_B19301.jpg" alt="Figure 2.2 – Hovering shows that the type of once()’s output matches the type of its input"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Hovering shows that the type of once()’s output matches the type of its input</p>
			<p>If you’re not still used to TypeScript, let’s see the pure JavaScript equivalent, which is the same code but for typing:</p>
			<pre class="source-code">
// once_JS.js
const once = (fn) =&gt; {
  let done = false;
  return (...args) =&gt; {
    if (!done) {
      done = true;
      return fn(...args);
    }
  };
};</pre>
			<p>So, how would we use it? We first create a new version of the billing function.</p>
			<pre class="source-code">
const billOnce = once(billTheUser);</pre>
			<p>Then, we rewrite the <code>onclick</code> method as follows:</p>
			<pre class="source-code">
&lt;button id="billButton"
  onclick="<strong class="bold">billOnce(some, sales, data)</strong>"&gt;Bill me
&lt;/button&gt;;</pre>
			<p>When the user <a id="_idIndexMarker107"/>clicks on the button, the function that gets called with the <code>(some, sales, data)</code> argument isn’t the original <code>billTheUser()</code> but rather the result of having applied <code>once()</code> to it. The result of that is a function that can be called only a single time.</p>
			<p class="callout-heading">You can’t always get what you want!</p>
			<p class="callout">Note that our <code>once()</code> function uses functions such as first-class objects, arrow functions, closures, and the spread operator. Back in <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Becoming Functional</em>, we said we’d be needing those, so we’re keeping our word! All we are missing from that chapter is recursion, but as the Rolling Stones sang, <em class="italic">You Can’t Always Get What </em><em class="italic">You Want!</em></p>
			<p>We now have a functional way of getting a function to do its thing only once, but how would we test it? Let’s get into that topic now.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Testing the solution manually</h2>
			<p>We can run a <a id="_idIndexMarker108"/>simple test. Let’s write a <code>squeak()</code> function that will, appropriately, <em class="italic">squeak</em> when called! The code is simple:</p>
			<pre class="source-code">
// once.manual.ts
const squeak = a =&gt; console.log(a, " squeak!!");
squeak("original"); // "original squeak!!"
squeak("original"); // "original squeak!!"
squeak("original"); // "original squeak!!"</pre>
			<p>If we apply <code>once()</code> to it, we get a new function that will squeak only once. See the highlighted line in the following code:</p>
			<pre class="source-code">
// continued...
const squeakOnce = once(squeak);
<strong class="bold">squeakOnce("only once"); // "only once squeak!!"</strong> squeakOnce("only once"); // no output
squeakOnce("only once"); // no output</pre>
			<p>The previous steps showed us how we could test our <code>once()</code> function by hand, but our method is not exactly ideal. In the next section, we’ll see why and how to do better.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Testing the solution automatically</h2>
			<p>Running tests by <a id="_idIndexMarker109"/>hand isn’t suitable: it gets tiresome and boring, and it leads, after a while, to not running the tests any longer. Let’s do better and write some automatic tests <a id="_idIndexMarker110"/>with <strong class="bold">Jest</strong>:</p>
			<pre class="source-code">
// once.test.ts
import once } from "./once";
describe("once", () =&gt; {
  it("without 'once', a function always runs", () =&gt; {
    const myFn = jest.fn();
    myFn();
    myFn();
    myFn();
    expect(myFn).toHaveBeenCalledTimes(3);
  });
  it("with 'once', a function runs one time", () =&gt; {
    const myFn = jest.fn();
    const onceFn = jest.fn(once(myFn));
    onceFn();
    onceFn();
    onceFn();
    expect(onceFn).toHaveBeenCalledTimes(3);
    expect(myFn).toHaveBeenCalledTimes(1);
  });
});</pre>
			<p>There are <a id="_idIndexMarker111"/>several points to note here:</p>
			<ul>
				<li>To spy on a function (for instance, to count how many times it was called), we need to pass it as an argument to <code>jest.fn()</code>; we can apply tests to the result, which works exactly like the original function, but can be spied on.</li>
				<li>When you spy on a function, Jest intercepts your calls and registers that the function was called, with which arguments, and how many times it was called.</li>
				<li>The first test only checks that if we call the function several times, it gets called that number of times. This is trivial, but we’d be doing something wrong if that didn’t happen!</li>
				<li>In the second test, we apply <code>once()</code> to a (dummy) <code>myFn()</code> function, and we call the result (<code>onceFn()</code>) several times. We then check that <code>myFn()</code> was called only once, though <code>onceFn()</code> was called three times.</li>
			</ul>
			<p>We can see the results in <em class="italic">Figure 2</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_2.3_B19301.jpg" alt="Figure 2.3 – Running automatic tests on our function with Jest"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Running automatic tests on our function with Jest</p>
			<p>With that, we <a id="_idIndexMarker112"/>have seen not only how to test our functional solution by hand but also in an automatic way, so we are done with testing. Let’s just finish by considering an even better solution, also achieved in a functional way.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Producing an even better solution</h2>
			<p>In one of the<a id="_idIndexMarker113"/> previous solutions, we mentioned that it would be a good idea to do something every time after the first click, and not silently ignore the user’s clicks. We’ll write a new higher-order function that takes a second parameter – a function to be called every time from the second call onward. Our new function will be called <code>onceAndAfter()</code> and can be written as follows:</p>
			<pre class="source-code">
// onceAndAfter.ts
const onceAndAfter = &lt;
  FNType extends (...args: any[]) =&gt; any
&gt;(
  f: FNType,
  g: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
      return f(...args);
    } else {
      return g(...args);
    }
  }) as FNType;
};</pre>
			<p>We have<a id="_idIndexMarker114"/> ventured further into higher-order functions; <code>onceAndAfter()</code> takes two functions as parameters and produces a third one, which includes the other two within.</p>
			<p class="callout-heading">Function as default</p>
			<p class="callout">You could make <code>onceAndAfter()</code> more powerful by giving a default value for <code>g</code>, such as <code>() =&gt; {}</code>, so if you didn’t specify the second function, it would still work fine because the default do-nothing function would be called instead of causing an error.</p>
			<p>We can do a quick-and-dirty test along the same lines as we did earlier. Let’s add a <code>creak()</code> creaking function to our previous <code>squeak()</code> one and check out what happens if we apply <code>onceAndAfter()</code> to them. We can then get a <code>makeSound()</code> function that should squeak once and creak afterward:</p>
			<pre class="source-code">
// onceAndAfter.manual.ts
import { onceAndAfter } from "./onceAndAfter";
const squeak = (x: string) =&gt; console.log(x, "squeak!!");
const creak = (x: string) =&gt; console.log(x, "creak!!");
const makeSound = onceAndAfter(squeak, creak);
makeSound("door"); // "door squeak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"</pre>
			<p>Writing a test for this new function isn’t hard, only a bit longer. We have to check which function <a id="_idIndexMarker115"/>was called and how many times:</p>
			<pre class="source-code">
// onceAndAfter.test.ts
import { onceAndAfter } from "./onceAndAfter";
describe("onceAndAfter", () =&gt; {
  it("calls the 1st function once &amp; the 2nd after", () =&gt; {
    const func1 = jest.fn();
    const func2 = jest.fn();
    const testFn = jest.fn(onceAndAfter(func1, func2));
    testFn();
    testFn();
    testFn();
    testFn();
    expect(testFn).toHaveBeenCalledTimes(4);
    expect(func1).toHaveBeenCalledTimes(1);
    expect(func2).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>Notice that we <a id="_idIndexMarker116"/>always check that <code>func1()</code> is called only once. Similarly, we check <code>func2()</code>; the count of calls starts at zero (the time that <code>func1()</code> is called), and from then on, it goes up by one on each call.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Summary</h1>
			<p>In this chapter, we’ve seen a common, simple problem based on a real-life situation. After analyzing several typical ways of solving that, we went for a functional thinking solution. We saw how to apply FP to our problem and found a more general higher-order solution that we could apply to similar problems with no further code changes. We saw how to write unit tests for our code to round out the development job.</p>
			<p>Finally, we produced an even better solution (from the point of view of the user experience) and saw how to code it and how to unit-test it. Now, you’ve started to get a grip on how to solve a problem functionally; next, in <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, we’ll delve more deeply into functions, which are at the core of all FP.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Questions</h1>
			<p>2.1 <code>done</code>, to mark whether the function had already been called. Not that it matters, but could you make do without using any extra variables? Note that we aren’t telling you not to use any variables, it’s just a matter of not adding any new ones, such as <code>done</code>, and only as an exercise!</p>
			<p>2.2 <code>onceAndAfter()</code> function, can you write an <code>alternator()</code> higher-order function that gets two functions as arguments and, on each call, alternatively calls one and another? The expected behavior should be as in the following example:</p>
			<pre class="source-code">
const sayA = () =&gt; console.log("A");
const sayB = () =&gt; console.log("B");
const alt = alternator(sayA, sayB);
alt(); // A
alt(); // B
alt(); // A
alt(); // B
alt(); // A
alt(); // B</pre>
			<p>2.3 <code>once()</code>, could you write a higher-order function, <code>thisManyTimes(fn,n)</code>, that would let you call the <code>fn()</code> function up to <em class="italic">n</em> times, but would do nothing afterward? To give an example, <code>once(fn)</code> and <code>thisManyTimes(fn,1)</code> would produce functions that behave the same way. Do also write tests for it.</p>
			<p>2.4 <code>once()</code> to a function, and the first time that function gets called, it crashes. Here, we may want to allow a second call to the function, hoping it wouldn’t crash again. We want an <code>onceIfSuccess()</code> function, that will get a function as a parameter and produce a new function that will run successfully only once, but will be allowed to fail (throwing exceptions) many times if need be. Implement <code>onceIfSuccess()</code>, and don’t forget to write unit tests for it.</p>
			<p>2.5 <code>once()</code> using classic functions, instead of arrow functions. This is just meant to help you explore the slightly different needed data typing syntax.</p>
		</div>
	</body></html>