<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor037"/>2</h1>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Thinking Functionally – A First Example</h1>
			<p>In <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, we went over what FP is, mentioned some advantages of applying it, and listed some tools we’d need in JavaScript. For now, let’s leave the theory behind and start by considering a simple problem and how to solve it in a <span class="No-Break">functional way.</span></p>
			<p>In this chapter, we will do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Look at a simple, <span class="No-Break">e-commerce-related problem</span></li>
				<li>Consider several usual ways to solve it (with their <span class="No-Break">associated defects)</span></li>
				<li>Find a way to solve the problem by looking at <span class="No-Break">it functionally</span></li>
				<li>Devise a higher-order solution that can be applied to <span class="No-Break">other problems</span></li>
				<li>Work out how to carry out unit testing for <span class="No-Break">functional solutions</span></li>
			</ul>
			<p>In future chapters, we’ll be returning to some of the topics listed here, so we won’t be going into too much detail. We’ll just show how FP can give a different outlook on our problem and leave further details <span class="No-Break">for later.</span></p>
			<p>After working through this chapter, you will have had a first look at a common problem and at a way of solving it by thinking functionally, as a prelude for the rest of <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Our problem – doing something only once</h1>
			<p>Let’s <a id="_idIndexMarker086"/>consider a simple but common situation. You have developed an e-commerce site; the user can fill their shopping cart, and in the end, they must click on a <strong class="bold">Bill me</strong> button so that their credit card will be charged. However, the user shouldn’t click twice (or more), or they will be billed <span class="No-Break">several times.</span></p>
			<p>The HTML part of your application might have something like <span class="No-Break">this somewhere:</span></p>
			<pre class="source-code">
&lt;button id="billButton"
    onclick="billTheUser(some, sales, data)"&gt;Bill me
      &lt;/button&gt;</pre>
			<p>And, among the scripts, you’d have something similar to the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p class="callout-heading">A bad example</p>
			<p class="callout">Assigning the events handler directly in HTML, the way I did it, isn’t recommended. Instead, unobtrusively, you should set the handler through code. So, <em class="italic">do as I say, not as </em><span class="No-Break"><em class="italic">I do!</em></span></p>
			<p>This is a bare-bones explanation of the web page problem, but it’s enough for our purposes. Now, let’s get to thinking about ways of avoiding repeated clicks on that button. How can we manage to prevent the user from clicking more than once? That’s an interesting<a id="_idIndexMarker087"/> problem, with several possible solutions – let’s start by looking at <span class="No-Break">bad ones!</span></p>
			<p>How many ways can you think of to solve our problem? Let’s go over several solutions and analyze <span class="No-Break">their quality.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Solution 1 – hoping for the best!</h2>
			<p>How can we solve the <a id="_idIndexMarker088"/>problem? The first solution may seem like a joke: do nothing, tell the user not to click twice, and hope for the best! Your page might look like <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_2.1_B19301.jpg" alt="Figure 2.1 – An actual screenshot of a page, just warning you against clicking more than once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – An actual screenshot of a page, just warning you against clicking more than once</p>
			<p>This is a way to weasel out of the problem; I’ve seen several websites that just warn the user about the risks of clicking more than once and do nothing to prevent the situation. So, the user got billed twice? We warned them... it’s <span class="No-Break">their fault!</span></p>
			<p>Your solution might simply look like the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&lt;button
  id="billButton"
  onclick="billTheUser(some, sales, data)"&gt;Bill me
&lt;/button&gt;
&lt;b&gt;WARNING: PRESS ONLY ONCE, DO NOT PRESS AGAIN!!&lt;/b&gt;</pre>
			<p>Okay, this isn’t an <a id="_idIndexMarker089"/>actual solution; let’s move on to more <span class="No-Break">serious proposals.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Solution 2 – using a global flag</h2>
			<p>The solution <a id="_idIndexMarker090"/>most people would probably think of first is using some global variable to record whether the user has already clicked on the button. You define a flag named something like <strong class="source-inline">clicked</strong>, initialized with <strong class="source-inline">false</strong>. When the user clicks on the button, if <strong class="source-inline">clicked</strong> is <strong class="source-inline">false</strong>, you change it to <strong class="source-inline">true</strong> and execute the function; otherwise, you do nothing at all. This can be seen in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let clicked = false;
.
.
.
function billTheUser(some, sales, data) {
  if (!clicked) {
    clicked = true;
    window.alert("Billing the user...");
    // actually bill the user
  }
}</pre>
			<p>This works, but it has several problems that must <span class="No-Break">be addressed:</span></p>
			<ul>
				<li>You are using a global variable, and you could change its value by accident. Global variables aren’t a good idea, in JavaScript or other languages. You must also remember to re-initialize it to <strong class="source-inline">false</strong> when the user starts buying again. If you don’t, the user won’t be able to make a second purchase because paying will <span class="No-Break">become impossible.</span></li>
				<li>You will have difficulties testing this code because it depends on external things (that is, the <span class="No-Break">clicked variable).</span></li>
			</ul>
			<p>So, this isn’t a very good solution. Let’s <span class="No-Break">keep thinking!</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Solution 3 – removing the handler</h2>
			<p>We may <a id="_idIndexMarker091"/>go for a lateral kind of solution, and instead of having the function avoid repeated clicks, we might just remove the possibility of clicking altogether. The following code does just that; the first thing that <strong class="source-inline">billTheUser()</strong> does is remove the <strong class="source-inline">onclick</strong> handler from the button, so no further calls will <span class="No-Break">be possible:</span></p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .onclick = null;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This solution also has <span class="No-Break">some problems:</span></p>
			<ul>
				<li>The code is tightly coupled to the button, so you won’t be able to reuse <span class="No-Break">it elsewhere</span></li>
				<li>You must remember to reset the handler; otherwise, the user won’t be able to make a <span class="No-Break">second purchase</span></li>
				<li>Testing will also be more complex because you’ll have to provide some <span class="No-Break">DOM elements</span></li>
			</ul>
			<p>We can enhance this solution a bit and avoid coupling the function to the button by providing the latter’s ID as an extra argument in the call. (This idea can also be applied to some of the further solutions that we’ll see.) The HTML part would be as follows; note the extra argument <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">billTheUser()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;button
  id="billButton"
  onclick="billTheUser('billButton', some, sales, data)"
&gt;Bill me
&lt;/button&gt;</pre>
			<p>We also have to change the called function so that it will use the received <strong class="source-inline">buttonId</strong> value to access the <span class="No-Break">corresponding button:</span></p>
			<pre class="source-code">
function billTheUser(buttonId, some, sales, data) {
  document.getElementById(buttonId).onclick = null;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This solution<a id="_idIndexMarker092"/> is somewhat better. But, in essence, we are still using a global element – not a variable, but the <strong class="source-inline">onclick</strong> value. So, despite the enhancement, this isn’t a very good solution either. Let’s <span class="No-Break">move on.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Solution 4 – changing the handler</h2>
			<p>A variant to the<a id="_idIndexMarker093"/> previous solution would be not to remove the click function, but to assign a new one instead. We are using functions as first-class objects here when we assign the <strong class="source-inline">alreadyBilled()</strong> function to the click event. The function warning the user that they have already clicked could look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
function alreadyBilled() {
  window.alert("Your billing process is running; don't
    click, please.");
}</pre>
			<p>Our <strong class="source-inline">billTheUser()</strong> function would then be like the following code – note how instead of assigning <strong class="source-inline">null</strong> to the <strong class="source-inline">onclick</strong> handler as in the previous section, now, the <strong class="source-inline">alreadyBilled()</strong> function <span class="No-Break">is assigned:</span></p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .onclick = alreadyBilled;
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>There’s a good point to this solution; if the user clicks a second time, they’ll get a warning not to do that, but they won’t be billed again. (From the point of view of user experience, it’s better.) However, this solution still has the very same objections as the previous one (code coupled to the button, needing to reset the handler, and harder testing), so we don’t <a id="_idIndexMarker094"/>consider it quite <span class="No-Break">good anyway.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Solution 5 – disabling the button</h2>
			<p>A similar idea here <a id="_idIndexMarker095"/>is instead of removing the event handler, we can disable the button so the user won’t be able to click. You might have a function such as the one shown in the following code, which does exactly that by setting the <strong class="source-inline">disabled</strong> attribute of <span class="No-Break">the button:</span></p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  document
    .getElementById("billButton")
    .setAttribute("disabled", "true");
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>This also works, but we still have objections as with the previous solutions (coupling the code to the button, needing to re-enable the button, and harder testing), so we don’t like this <span class="No-Break">solution either.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Solution 6 – redefining the handler</h2>
			<p>Another idea: instead of <a id="_idIndexMarker096"/>changing anything in the button, let’s have the event handler change itself. The trick is in the second line of the following code; by assigning a new value to the <strong class="source-inline">billTheUser</strong> variable, we are dynamically changing what the function does! The first time you call the function, it will do its thing, but it will also change itself out of existence by giving its name to a <span class="No-Break">new function:</span></p>
			<pre class="source-code">
function billTheUser(some, sales, data) {
  billTheUser = function() {};
  window.alert("Billing the user...");
  // actually bill the user
}</pre>
			<p>There’s a <a id="_idIndexMarker097"/>special trick in the solution. Functions are global, so the <strong class="source-inline">billTheUser=...</strong> line changes the function’s inner workings. From that point on, <strong class="source-inline">billTheUser</strong> will be the new (null) function. This solution is still hard to test. Even worse, how would you restore the functionality of <strong class="source-inline">billTheUser</strong>, setting it back to its <span class="No-Break">original objective?</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Solution 7 – using a local flag</h2>
			<p>We can go <a id="_idIndexMarker098"/>back to the idea of using a flag, but instead of making it global (which was our main objection to the second solution), we can <a id="_idIndexMarker099"/>use an <strong class="bold">Immediately Invoked Function Expression</strong> (<strong class="bold">IIFE</strong>), which we’ll see more about in <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, and <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing Design Patterns</em>. With this, we can use a closure, so <strong class="source-inline">clicked</strong> will be local to the function and not visible <span class="No-Break">anywhere else:</span></p>
			<pre class="source-code">
var billTheUser = (clicked =&gt; {
  return (some, sales, data) =&gt; {
    if (!clicked) {
      clicked = true;
      window.alert("Billing the user...");
      // actually bill the user
    }
  };
})(false);</pre>
			<p>This solution is along the lines of the global variable solution, but using a private, local variable is an enhancement. (Note how <strong class="source-inline">clicked</strong> gets its initial value from the call at the end.) The only drawback we could find is that we'll have to rework every function that needs to be called only once to work in this fashion (and, as we’ll see in the following section, our FP solution is similar to it in some ways). Okay, it’s not too hard to do, but don’t forget<a id="_idIndexMarker100"/> the <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>), <span class="No-Break">usual </span><span class="No-Break"><a id="_idIndexMarker101"/></span><span class="No-Break">advice!</span></p>
			<p>We have now gone through multiple ways of solving our “do something only once” problem – but as we’ve seen, they were not very good! Let’s think about the problem functionally so that we get a more <span class="No-Break">general solution.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>A functional solution to our problem</h1>
			<p>Let’s try to be more <a id="_idIndexMarker102"/>general; after all, requiring that some function or other be executed only once isn’t that outlandish, and may be required elsewhere! Let’s lay down <span class="No-Break">some principles:</span></p>
			<ul>
				<li>The original function (the one that may be called only once) should do whatever it is expected to do and <span class="No-Break">nothing else</span></li>
				<li>We don’t want to modify the original function in <span class="No-Break">any way</span></li>
				<li>We need a new function that will call the original one <span class="No-Break">only once</span></li>
				<li>We want a general solution that we can apply to any number of <span class="No-Break">original functions</span></li>
			</ul>
			<p class="callout-heading">A SOLID base</p>
			<p class="callout">The first principle listed previously is the single responsibility principle (the S in the <strong class="bold">SOLID</strong> acronym), which states that every function should be responsible for a single functionality. For more on<a id="_idIndexMarker103"/> SOLID, check the article by Uncle Bob (Robert C. Martin, who wrote the five principles) <span class="No-Break">at </span><a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod"><span class="No-Break">butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</span></a><span class="No-Break">.</span></p>
			<p>Can we do it? Yes, and we’ll write a higher-order function, which we’ll be able to apply to any function, to produce a new function that will work only once. Let’s see how! We will introduce higher-order functions in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>. There, we’ll go about testing our functional solution, as well as making some enhancements <span class="No-Break">to it.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>A higher-order solution</h2>
			<p>If we don’t want to modify <a id="_idIndexMarker104"/>the original function, we can create a higher-order function, which we’ll (inspiredly!) name <strong class="source-inline">once()</strong>. This function will receive a function as a parameter and return a new function, which will work only once. (As we mentioned previously, we’ll be seeing more of higher-order functions later; in particular, see the <em class="italic">Doing things once, revisited</em> section of <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Producing Functions</em></span><span class="No-Break">).</span></p>
			<p class="callout-heading">Many solutions</p>
			<p class="callout">Underscore and Lodash already have a similar function, invoked as <strong class="source-inline">_.once()</strong>. Ramda also provides <strong class="source-inline">R.once()</strong>, and most FP libraries include similar functionality, so you wouldn’t have to program it on <span class="No-Break">your own.</span></p>
			<p>Our <strong class="source-inline">once()</strong> function<a id="_idIndexMarker105"/> may seem imposing at first, but as you get accustomed to working in an FP fashion, you’ll get used to this sort of code and find it to be <span class="No-Break">quite understable:</span></p>
			<pre class="source-code">
// once.ts
const once = &lt;FNType extends (...args: any[]) =&gt; any&gt;(
  fn: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
      return fn(...args);
    }
  }) as FNType;
};</pre>
			<p>Let’s go over some of the finer points of <span class="No-Break">this function:</span></p>
			<ul>
				<li>Our <strong class="source-inline">once()</strong> function receives a function (<strong class="source-inline">fn</strong>) as its parameter and returns a new function, of the same type. (We’ll discuss this typing in more <span class="No-Break">detail shortly.)</span></li>
				<li>We define an internal, private <strong class="source-inline">done</strong> variable, by taking advantage of <em class="italic">closure</em>, as in <em class="italic">Solution 7</em>. We opted not to call it <strong class="source-inline">clicked</strong> (as we did previously) because you don’t necessarily need to click on a button to call the function; we went for a more general term. Each time you apply <strong class="source-inline">once()</strong> to some function, a new, distinct <strong class="source-inline">done</strong> variable will be created and will be accessible only from the <span class="No-Break">returned function.</span></li>
				<li>The <strong class="source-inline">return</strong> statement shows that <strong class="source-inline">once()</strong> will return a function, with the same type of parameters as the original <strong class="source-inline">fn()</strong> one. We are using the spread syntax we saw in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>. With older versions of JavaScript, you’d have to work with the arguments object; see <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments</a> for more on that. The modern way is simpler <span class="No-Break">and shorter!</span></li>
				<li>We assign <strong class="source-inline">done = true</strong> before calling <strong class="source-inline">fn()</strong>, just in case that function throws an exception. Of course, if you don’t want to disable the function unless it has successfully ended, you could move the assignment below the <strong class="source-inline">fn()</strong> call. (See <em class="italic">Question 2.4</em> in the <em class="italic">Questions</em> section for another take <span class="No-Break">on this.)</span></li>
				<li>After the setting is<a id="_idIndexMarker106"/> done, we finally call the original function. Note the use of the spread operator to pass along whatever parameters the original <span class="No-Break"><strong class="source-inline">fn()</strong></span><span class="No-Break"> had.</span></li>
			</ul>
			<p>Typing for <strong class="source-inline">once()</strong> may be obscure. We have to specify that the type of the input function and the type of <strong class="source-inline">once()</strong> are the same, and that’s the reason for defining <strong class="source-inline">FNType</strong>. <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em> shows that TypeScript correctly understands this (Check the answer to <em class="italic">Question 1.7</em> at the end of this book for another example <span class="No-Break">of this):</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.2_B19301.jpg" alt="Figure 2.2 – Hovering shows that the type of once()’s output matches the type of its input"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Hovering shows that the type of once()’s output matches the type of its input</p>
			<p>If you’re not still used to TypeScript, let’s see the pure JavaScript equivalent, which is the same code but <span class="No-Break">for typing:</span></p>
			<pre class="source-code">
// once_JS.js
const once = (fn) =&gt; {
  let done = false;
  return (...args) =&gt; {
    if (!done) {
      done = true;
      return fn(...args);
    }
  };
};</pre>
			<p>So, how would we use it? We first create a new version of the <span class="No-Break">billing function.</span></p>
			<pre class="source-code">
const billOnce = once(billTheUser);</pre>
			<p>Then, we rewrite the <strong class="source-inline">onclick</strong> method <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;button id="billButton"
  onclick="<strong class="bold">billOnce(some, sales, data)</strong>"&gt;Bill me
&lt;/button&gt;;</pre>
			<p>When the user <a id="_idIndexMarker107"/>clicks on the button, the function that gets called with the <strong class="source-inline">(some, sales, data)</strong> argument isn’t the original <strong class="source-inline">billTheUser()</strong> but rather the result of having applied <strong class="source-inline">once()</strong> to it. The result of that is a function that can be called only a <span class="No-Break">single time.</span></p>
			<p class="callout-heading">You can’t always get what you want!</p>
			<p class="callout">Note that our <strong class="source-inline">once()</strong> function uses functions such as first-class objects, arrow functions, closures, and the spread operator. Back in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, we said we’d be needing those, so we’re keeping our word! All we are missing from that chapter is recursion, but as the Rolling Stones sang, <em class="italic">You Can’t Always Get What </em><span class="No-Break"><em class="italic">You Want!</em></span></p>
			<p>We now have a functional way of getting a function to do its thing only once, but how would we test it? Let’s get into that <span class="No-Break">topic now.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Testing the solution manually</h2>
			<p>We can run a <a id="_idIndexMarker108"/>simple test. Let’s write a <strong class="source-inline">squeak()</strong> function that will, appropriately, <em class="italic">squeak</em> when called! The code <span class="No-Break">is simple:</span></p>
			<pre class="source-code">
// once.manual.ts
const squeak = a =&gt; console.log(a, " squeak!!");
squeak("original"); // "original squeak!!"
squeak("original"); // "original squeak!!"
squeak("original"); // "original squeak!!"</pre>
			<p>If we apply <strong class="source-inline">once()</strong> to it, we get a new function that will squeak only once. See the highlighted line in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// continued...
const squeakOnce = once(squeak);
<strong class="bold">squeakOnce("only once"); // "only once squeak!!"</strong> squeakOnce("only once"); // no output
squeakOnce("only once"); // no output</pre>
			<p>The previous steps showed us how we could test our <strong class="source-inline">once()</strong> function by hand, but our method is not exactly ideal. In the next section, we’ll see why and how to <span class="No-Break">do better.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Testing the solution automatically</h2>
			<p>Running tests by <a id="_idIndexMarker109"/>hand isn’t suitable: it gets tiresome and boring, and it leads, after a while, to not running the tests any longer. Let’s do better and write some automatic tests <a id="_idIndexMarker110"/><span class="No-Break">with </span><span class="No-Break"><strong class="bold">Jest</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// once.test.ts
import once } from "./once";
describe("once", () =&gt; {
  it("without 'once', a function always runs", () =&gt; {
    const myFn = jest.fn();
    myFn();
    myFn();
    myFn();
    expect(myFn).toHaveBeenCalledTimes(3);
  });
  it("with 'once', a function runs one time", () =&gt; {
    const myFn = jest.fn();
    const onceFn = jest.fn(once(myFn));
    onceFn();
    onceFn();
    onceFn();
    expect(onceFn).toHaveBeenCalledTimes(3);
    expect(myFn).toHaveBeenCalledTimes(1);
  });
});</pre>
			<p>There are <a id="_idIndexMarker111"/>several points to <span class="No-Break">note here:</span></p>
			<ul>
				<li>To spy on a function (for instance, to count how many times it was called), we need to pass it as an argument to <strong class="source-inline">jest.fn()</strong>; we can apply tests to the result, which works exactly like the original function, but can be <span class="No-Break">spied on.</span></li>
				<li>When you spy on a function, Jest intercepts your calls and registers that the function was called, with which arguments, and how many times it <span class="No-Break">was called.</span></li>
				<li>The first test only checks that if we call the function several times, it gets called that number of times. This is trivial, but we’d be doing something wrong if that <span class="No-Break">didn’t happen!</span></li>
				<li>In the second test, we apply <strong class="source-inline">once()</strong> to a (dummy) <strong class="source-inline">myFn()</strong> function, and we call the result (<strong class="source-inline">onceFn()</strong>) several times. We then check that <strong class="source-inline">myFn()</strong> was called only once, though <strong class="source-inline">onceFn()</strong> was called <span class="No-Break">three times.</span></li>
			</ul>
			<p>We can see the results in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.3_B19301.jpg" alt="Figure 2.3 – Running automatic tests on our function with Jest"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Running automatic tests on our function with Jest</p>
			<p>With that, we <a id="_idIndexMarker112"/>have seen not only how to test our functional solution by hand but also in an automatic way, so we are done with testing. Let’s just finish by considering an even better solution, also achieved in a <span class="No-Break">functional way.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Producing an even better solution</h2>
			<p>In one of the<a id="_idIndexMarker113"/> previous solutions, we mentioned that it would be a good idea to do something every time after the first click, and not silently ignore the user’s clicks. We’ll write a new higher-order function that takes a second parameter – a function to be called every time from the second call onward. Our new function will be called <strong class="source-inline">onceAndAfter()</strong> and can be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// onceAndAfter.ts
const onceAndAfter = &lt;
  FNType extends (...args: any[]) =&gt; any
&gt;(
  f: FNType,
  g: FNType
) =&gt; {
  let done = false;
  return ((...args: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
      return f(...args);
    } else {
      return g(...args);
    }
  }) as FNType;
};</pre>
			<p>We have<a id="_idIndexMarker114"/> ventured further into higher-order functions; <strong class="source-inline">onceAndAfter()</strong> takes two functions as parameters and produces a third one, which includes the other <span class="No-Break">two within.</span></p>
			<p class="callout-heading">Function as default</p>
			<p class="callout">You could make <strong class="source-inline">onceAndAfter()</strong> more powerful by giving a default value for <strong class="source-inline">g</strong>, such as <strong class="source-inline">() =&gt; {}</strong>, so if you didn’t specify the second function, it would still work fine because the default do-nothing function would be called instead of causing <span class="No-Break">an error.</span></p>
			<p>We can do a quick-and-dirty test along the same lines as we did earlier. Let’s add a <strong class="source-inline">creak()</strong> creaking function to our previous <strong class="source-inline">squeak()</strong> one and check out what happens if we apply <strong class="source-inline">onceAndAfter()</strong> to them. We can then get a <strong class="source-inline">makeSound()</strong> function that should squeak once and <span class="No-Break">creak afterward:</span></p>
			<pre class="source-code">
// onceAndAfter.manual.ts
import { onceAndAfter } from "./onceAndAfter";
const squeak = (x: string) =&gt; console.log(x, "squeak!!");
const creak = (x: string) =&gt; console.log(x, "creak!!");
const makeSound = onceAndAfter(squeak, creak);
makeSound("door"); // "door squeak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"
makeSound("door"); // "door creak!!"</pre>
			<p>Writing a test for this new function isn’t hard, only a bit longer. We have to check which function <a id="_idIndexMarker115"/>was called and how <span class="No-Break">many times:</span></p>
			<pre class="source-code">
// onceAndAfter.test.ts
import { onceAndAfter } from "./onceAndAfter";
describe("onceAndAfter", () =&gt; {
  it("calls the 1st function once &amp; the 2nd after", () =&gt; {
    const func1 = jest.fn();
    const func2 = jest.fn();
    const testFn = jest.fn(onceAndAfter(func1, func2));
    testFn();
    testFn();
    testFn();
    testFn();
    expect(testFn).toHaveBeenCalledTimes(4);
    expect(func1).toHaveBeenCalledTimes(1);
    expect(func2).toHaveBeenCalledTimes(3);
  });
});</pre>
			<p>Notice that we <a id="_idIndexMarker116"/>always check that <strong class="source-inline">func1()</strong> is called only once. Similarly, we check <strong class="source-inline">func2()</strong>; the count of calls starts at zero (the time that <strong class="source-inline">func1()</strong> is called), and from then on, it goes up by one on <span class="No-Break">each call.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Summary</h1>
			<p>In this chapter, we’ve seen a common, simple problem based on a real-life situation. After analyzing several typical ways of solving that, we went for a functional thinking solution. We saw how to apply FP to our problem and found a more general higher-order solution that we could apply to similar problems with no further code changes. We saw how to write unit tests for our code to round out the <span class="No-Break">development job.</span></p>
			<p>Finally, we produced an even better solution (from the point of view of the user experience) and saw how to code it and how to unit-test it. Now, you’ve started to get a grip on how to solve a problem functionally; next, in <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, we’ll delve more deeply into functions, which are at the core of <span class="No-Break">all FP.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Questions</h1>
			<p>2.1 <strong class="bold">No extra variables</strong>: Our functional implementation required using an extra variable, <strong class="source-inline">done</strong>, to mark whether the function had already been called. Not that it matters, but could you make do without using any extra variables? Note that we aren’t telling you not to use any variables, it’s just a matter of not adding any new ones, such as <strong class="source-inline">done</strong>, and only as <span class="No-Break">an exercise!</span></p>
			<p>2.2 <strong class="bold">Alternating functions</strong>: In the spirit of our <strong class="source-inline">onceAndAfter()</strong> function, can you write an <strong class="source-inline">alternator()</strong> higher-order function that gets two functions as arguments and, on each call, alternatively calls one and another? The expected behavior should be as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
const sayA = () =&gt; console.log("A");
const sayB = () =&gt; console.log("B");
const alt = alternator(sayA, sayB);
alt(); // A
alt(); // B
alt(); // A
alt(); // B
alt(); // A
alt(); // B</pre>
			<p>2.3 <strong class="bold">Everything has a limit!</strong> As an extension of <strong class="source-inline">once()</strong>, could you write a higher-order function, <strong class="source-inline">thisManyTimes(fn,n)</strong>, that would let you call the <strong class="source-inline">fn()</strong> function up to <em class="italic">n</em> times, but would do nothing afterward? To give an example, <strong class="source-inline">once(fn)</strong> and <strong class="source-inline">thisManyTimes(fn,1)</strong> would produce functions that behave the same way. Do also write tests <span class="No-Break">for it.</span></p>
			<p>2.4 <strong class="bold">Allow for crashing</strong>: Suppose we apply <strong class="source-inline">once()</strong> to a function, and the first time that function gets called, it crashes. Here, we may want to allow a second call to the function, hoping it wouldn’t crash again. We want an <strong class="source-inline">onceIfSuccess()</strong> function, that will get a function as a parameter and produce a new function that will run successfully only once, but will be allowed to fail (throwing exceptions) many times if need be. Implement <strong class="source-inline">onceIfSuccess()</strong>, and don’t forget to write unit tests <span class="No-Break">for it.</span></p>
			<p>2.5 <strong class="bold">Say no to arrows</strong>: Implement <strong class="source-inline">once()</strong> using classic functions, instead of arrow functions. This is just meant to help you explore the slightly different needed data <span class="No-Break">typing syntax.</span></p>
		</div>
	</body></html>