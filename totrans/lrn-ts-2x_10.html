<html><head></head><body><div><h1 class="header-title">Node.js Development with TypeScript</h1>
                
            
            
                
<p>Over the preceding chapters of this book, we have been using Node.js and some of the tools of its ecosystem, but we haven't developed a Node.js application. In this chapter, we are going to learn how to develop applications with Node.js. We are going to cover the following topics:</p>
<ul>
<li>The main characteristics of Node.js</li>
<li>The main characteristics of the Node.js core API</li>
<li>Server-side development with Node.js</li>
<li>Developing REST APIs with Node.js</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding Node.js</h1>
                
            
            
                
<p>Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js is single-threaded and uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding non-blocking I/O</h1>
                
            
            
                
<p>An input or output operation (I/O) is an operation that requires writing or reading from a physical source. This includes things such as saving a file into your hard disk or sending a file through the network.</p>
<p>In the past, operating systems only allowed us to perform I/O operations in what is known as a blocking model. In a <strong>blocking model</strong>, we can run an application in a thread, but when an I/O request takes place, the thread is blocked until the request is completed.</p>
<p>Web servers implemented using blocking I/O are not be able to handle multiple simultaneous connections using the same thread. For example, when an HTTP request arrives at the web server, it might need to perform some I/O operation (for example, reading from a database or talking to another server through the network) to provide the creator of the request with a response. If the web server uses one unique thread, it will be blocked until the I/O operation has been completed. As a result, if a second HTTP request hits the server, the server will not be able to handle it. The solution to this problem was to create a new thread for each HTTP request but this solution was not scalable because a single CPU cannot handle a very large number of threads and CPUs are one of the most expensive components of a server.</p>
<p>The following diagram represents the blocking I/O model:</p>
<div><img class="alignnone size-full wp-image-252 image-border" src="img/41461bc3-57bc-4b33-bd33-c7c16ae88d28.png" style="width:83.92em;height:33.33em;" width="1007" height="400"/></div>
<p>The non-blocking I/O model is the solution to the limitations of the blocking I/O model. In the non-blocking model, an I/O request doesn't block the main thread. Instead of that, the I/O events are collected and queued by a component known as the event demultiplexer. Node.js implements a pattern known as the reactor pattern, which combines the JavaScript event loop with the event demultiplexer.</p>
<p>The following diagram represents the interactions between the event loop and the event demultiplexer:</p>
<div><img class="alignnone size-full wp-image-332 image-border" src="img/70e4e029-a9dc-4f4e-88f5-2e6357fb9147.jpg" style="width:39.08em;height:36.83em;" width="561" height="529"/></div>
<p>The main idea behind it is to have a handler (which in Node.js is represented by a callback function) associated with each I/O operation. When the I/O operation is completed, an event is produced and consumed by the JavaScript event loop, which invokes the handler.</p>
<p>Please refer to <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime</em>, to learn more about the JavaScript event loop and the way event handlers work.</p>
<p>If the web server uses one unique thread, it will not be blocked until the I/O operation has been completed. As a result, if a second HTTP request hits the server, the server will be able to handle it without the need for more threads. Each HTTP request creates I/O events and event handlers that are stored in memory, and if the server is hit by thousands of HTTP requests, it can still reach a limit. However, the level of concurrent HTTP requests is much higher than the previous limit imposed by the blocking I/O model:</p>
<div><img class="alignnone size-full wp-image-253 image-border" src="img/52a49ffb-02f9-464c-b4ca-4b4f0e61b7ae.png" style="width:40.17em;height:12.33em;" width="1131" height="347"/></div>
<p>Node.js takes full advantage of the non-blocking I/O model and is fundamentally built on top of it, as we will see in the following section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The main components of Node.js</h1>
                
            
            
                
<p>Now that we understand how the non-blocking I/O model works, we are in a much better position to be able to understand each of the internal components of Node.js:</p>
<div><img class="alignnone size-full wp-image-254 image-border" src="img/108197ec-d968-4cb1-8ce1-a90a34d6cf63.png" style="width:20.67em;height:18.67em;" width="810" height="730"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">V8</h1>
                
            
            
                
<p>V8 is the JavaScript engine originally developed for Google's Chrome. It is responsible for the parsing, interpretation, and execution of JavaScript.</p>
<p>Please refer to the V8 documentation at <a href="https://github.com/v8/v8/wiki">https://github.com/v8/v8/wiki</a> if you wish to learn more about it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Libuv</h1>
                
            
            
                
<p>Each operating system has its interface for the event demultiplexer and each I/O operation can behave quite differently depending on the type of the resource, even within the same OS. Libuv is a C library that makes Node.js compatible with all the major platforms and normalizes the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p>
<p>Please refer to the official libuv documentation at <a href="https://libuv.org/">https://libuv.org/</a> and <a href="http://docs.libuv.org/en/v1.x/">http://docs.libuv.org/en/v1.x/</a> if you wish to learn more.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Bindings</h1>
                
            
            
                
<p>The bindings are a set of libraries that wrap the V8 and libuv public APIs in a way that allows us to consume them using JavaScript instead of C or C++ code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Node.js core API (node-core)</h1>
                
            
            
                
<p>Node.js includes a set of core APIs to perform common operations, such as reading files, sending an HTTP request, or encrypting a text file. These APIs use V8 and libuv under the hood, but they don't talk to them directly, they do it through the bindings.</p>
<p>Please note that we will learn more about the Node.js core APIs later in this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js environment versus browser environment</h1>
                
            
            
                
<p>The Node.js environment and the browser environment are not identical. For example, the environment in web browsers includes an API known as the <strong>Document Object Model</strong> (<strong>DOM</strong>) and an API known as the <strong>Browser Object Model</strong> (<strong>BOM</strong>). These APIs define APIs, such as the window object or the history API. However, these APIs are not available in the Node.js environment. The following table highlights some of the most significant differences between the environment Node.js and web browsers:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p class="TableColumnHeadingPACKT"><strong>Feature</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Node.js</strong></p>
</td>
<td>
<p class="TableColumnHeadingPACKT"><strong>Web browsers</strong></p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">DOM</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">BOM</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">Global variable is named window</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">Global variable is named global</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">The require function</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">Common JS modules</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
</tr>
<tr>
<td>
<p class="TableColumnContentPACKT">Access to sensitive resources (for example, the filesystem)</p>
</td>
<td>
<p class="TableColumnContentPACKT">Yes</p>
</td>
<td>
<p class="TableColumnContentPACKT">No</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    </div>



  
<div><h1 class="header-title">The Node.js ecosystem</h1>
                
            
            
                
<p>In this section, we are going to explore the Node.js ecosystem. We are going to learn what Node.js has to offer us, and some significant code conventions are followed by its entire ecosystem.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Node.js core API</h1>
                
            
            
                
<p>The Node.js core API, also known as node-core, is a set of libraries that are part of Node.js and, as a result, are installed in our OS when we install Node.js. The Node.js core API includes the following modules:</p>
<ul>
<li><kbd>assert</kbd></li>
<li><kbd>async_hooks</kbd></li>
<li><kbd>buffer</kbd></li>
<li><kbd>child_process</kbd></li>
<li><kbd>cluster</kbd></li>
<li><kbd>crypto</kbd></li>
<li><kbd>dgram</kbd></li>
<li><kbd>dns</kbd></li>
<li><kbd>domain</kbd></li>
<li><kbd>events</kbd></li>
<li><kbd>fs</kbd></li>
<li><kbd>http</kbd></li>
<li><kbd>http2</kbd></li>
<li><kbd>https</kbd></li>
<li><kbd>net</kbd></li>
<li><kbd>os</kbd></li>
<li><kbd>path</kbd></li>
<li><kbd>perf_hooks</kbd></li>
<li><kbd>punycode</kbd></li>
<li><kbd>querystring</kbd></li>
<li><kbd>readline</kbd></li>
<li><kbd>repl</kbd></li>
<li><kbd>stream</kbd></li>
<li><kbd>string_decoder</kbd></li>
<li><kbd>tls</kbd></li>
<li><kbd>tty</kbd></li>
<li><kbd>url</kbd></li>
<li><kbd>util</kbd></li>
<li><kbd>v8</kbd></li>
<li><kbd>vm</kbd></li>
<li><kbd>zlib</kbd></li>
</ul>
<p>As we can see in the preceding list, there are modules to work with <strong>Domain Name Servers</strong> (<strong>DNS</strong>), working with HTTP requests (<kbd>http</kbd>), or reading and writing files to the hard disk (<kbd>fs</kbd>). Covering all these modules is out of the scope of this book. However, we are going to use some of them later in this chapter.</p>
<p>Please note that you can visit the official Node.js documentation at <a href="https://nodejs.org/docs/">https://nodejs.org/docs/</a> to learn all the details about each of the features available in each of the modules.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The style of the Node.js core API</h1>
                
            
            
                
<p>Earlier in this chapter, we learned how the reactor pattern and the non-blocking I/O model are two of the most fundamental characteristics of Node.js. This should help us to understand why callbacks are used so extensively in the entire Node.js core API. As we can imagine, the core API has a direct impact on all the other modules. As a result, the entire Node.js ecosystem uses callbacks extensively.</p>
<p>Node.js not only uses callbacks extensively, but it also uses them in a very consistent way:</p>
<ul>
<li>Callbacks in Node.js are always the last argument of a function</li>
<li>Callbacks in Node.js always take an error as the first argument</li>
</ul>
<p>The following code snippet uses the filesystem API to read a text file. The <kbd>readFile</kbd> function showcases the two preceding rules in action:</p>
<pre>import { readFile } from "fs"; 

readFile("./hello.txt", (err, buffer) =&gt; { 

    console.log(buffer.toString()); 

}); </pre>
<p>There are a few new rules about Node.js callbacks:</p>
<ul>
<li>Errors are never thrown by a function that takes a callback. The errors should be passed to the callback instead.</li>
<li>When we have nested callbacks, if an error takes place, it should be passed to the callback in the top level.</li>
</ul>
<p>The following code snippet showcases both the preceding rules in action:</p>
<pre>function readJson( 
    fileName: string, 
    callback: (err: Error|null, json?: any) =&gt; void 
) { 
    readFile(fileName, "utf-8", (err, buffer) =&gt; { 
        if (err) { 
            callback(err); 
        } 

        try { 
            const parsed = JSON.parse(buffer); 
            callback(null, parsed); 
        } catch (innerErr) { 
            callback(err); 
        } 
    }); 
} </pre>
<p>Node.js uses callbacks because when it was originally implemented, promises, generators, and <kbd>async</kbd>/<kbd>await</kbd> were not available in V8. This seems unfortunate because, as TypeScript users, we know how much nicer is to use <kbd>async</kbd>/<kbd>await</kbd> instead of callbacks and promises.</p>
<p>Thanks to the consistency of the Node.js APIs, we can write a helper that takes a function implemented with a callback-based API and returns the same function implemented with a promise-based API. In fact, this function is part of the <kbd>util</kbd> core module and can be imported as follows:</p>
<pre>import * as util from "util";<br/>const promisify = util.promisify;</pre>
<p>We can use the preceding helper function to transform the <kbd>readFile</kbd> function that we used during the previous example into a function that returns a promise. The new function is named <kbd>readFileAsync</kbd>. Now that the function returns a promise, we can use <kbd>async</kbd>/<kbd>await</kbd>:</p>
<pre>import { readFile } from "fs"; 

const readFileAsync = promisify(readFile); 

(async () =&gt; { 
    const buffer = await readFileAsync("./hello.txt", "utf-8"); 
    console.log(buffer.toString()); 
})(); </pre>
<p>The following code snippet showcases how to transform the second example into the <kbd>async</kbd>/<kbd>await</kbd> style:</p>
<pre>import { readFile } from "fs"; 

const { promisify } = require("util"); 
const readFileAsync = promisify(readFile); 
 
async function readJson(fileName: string) { 
    try { 
        const buffer = await readFileAsync(fileName, "utf-8"); 
        const parsed = JSON.parse(buffer.toString()); 
        return parsed; 
    } catch (err) { 
        return err; 
    } 
} </pre>
<p>In the future, Node.js will support promises in its core API natively but, for now, using the <kbd>promisify</kbd> helper is a good option.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The npm ecosystem</h1>
                
            
            
                
<p>We have used npm previously in this book, and by now we should know how to use it well. The npm ecosystem is composed of thousands of external modules. We can use the official npm website at <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> to search for a package that might help us to complete a given task. Unlike the modules that are part of the core Node.js API, external <kbd>npm</kbd> modules need to be installed using <kbd>npm</kbd>:</p>
<pre><strong>npm install react</strong> </pre>
<p>If the module is not recognized by TypeScript, we will also need to install its type definitions (if available):</p>
<pre><strong>npm install @types/react</strong> </pre>
<p>Please refer to <a href="2ead318d-0bef-4d4c-9aac-ba0dc42f656f.xhtml">Chapter 13</a>, <em>Application Performance</em>, and <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, to learn more about other tools in the Node.js ecosystem, for example, the Node.js inspector, a tool that allows us to debug and analyze the performance of our Node.js applications.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting up Node.js</h1>
                
            
            
                
<p>To set up Node.js on your machine, you will need to visit the official download page at <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download</a> and follow the instructions for your operating system.</p>
<p>If you are an OS X or Linux user, you can additionally install the <strong>node version manager</strong> (<strong>nvm</strong>) following the instructions at <a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a>. This tool allows us to install multiple versions of Node.js on the same machine and to switch between them in a matter of seconds. If you are a Windows user, you will need to install <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows</a> instead.</p>
<p>If we want to use one of the Node.js core API modules, all we need to do is to import it. We don't need to install an additional <kbd>npm</kbd> module. For example, the filesystem module can be used to read and write files and manage directories. If we want to use the filesystem API, all we need to do is to import the module as follows:</p>
<pre>import * as fs from "fs"; </pre>
<p>However, TypeScript will not recognize the module by default because it is not part of the JavaScript specification. We can solve this problem by installing the Node.js type definitions:</p>
<pre><strong>npm install @types/node</strong> </pre>
<p>Finally, you may want to install <kbd>ts-node</kbd> to be able to execute Node.js applications implemented with TypeScript without the need to compile them first. We can run a Node.js application or a TypeScript application using the following commands respectively:</p>
<pre><strong>node app.js</strong> 

<strong>ts-node app.ts</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js development</h1>
                
            
            
                
<p>In this section, we are going to look at a few small real-world examples of the usage of Node.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with the filesystem</h1>
                
            
            
                
<p>We are going to implement a very small Node.js application. This application can be used as a search and replace tool. The result can be used as a command-line application and can be executed using the following command:</p>
<pre><strong>ts-node app.ts --files ./**/*.txt --find SOMETHING --replace SOMETHING_ELSE</strong> </pre>
<p>The application will replace one word for another in all the matching files. We are going to use the core filesystem API (<kbd>fs</kbd>) and two external <kbd>npm</kbd> modules:</p>
<ul>
<li><kbd>glob</kbd> is used to find files that match a given pattern</li>
<li><kbd>yargs</kbd> is used to parse command-line arguments</li>
</ul>
<p>We need to install both packages and the corresponding type definition files:</p>
<pre><strong>npm install glob yargs --save</strong> 

<strong>npm install @types/glob @types/yargs @types/node -save-dev</strong> </pre>
<p>Let's look at the source code:</p>
<pre>import * as fs from "fs"; 

import * as yargs from "yargs"; 

import glob from "glob"; 

const { promisify } = require("util"); </pre>
<p class="mce-root">We are going to use the <kbd>promisify</kbd> function to transform some callback-based APIs into promise-based APIs:</p>
<pre>const globAsync = promisify(glob); 

const readFileAsync = promisify(fs.readFile); 

const writeFileAsync = promisify(fs.writeFile); </pre>
<p>The following function reads the arguments from the command line:</p>
<pre>function getCommandLineArguments() { 
    const files = yargs.argv.files; 

    if (!files) { 
        throw new Error("Missing argument --files"); 
    } 

    const find = yargs.argv.find; 
 
    if (!find) { 
        throw new Error("Missing argument --find"); 
    } 

    const replace = yargs.argv.replace; 
 
    if (!replace) { 
        throw new Error("Missing argument --replace"); 
    } 

    return { 
        pattern: files, 
        find: find, 
        replace: replace 
    }; 
};</pre>
<p>The following function validates the command-line arguments:</p>
<pre>function validateCommandLineArguments(args: any) { 

    if (args.pattern === undefined) { 

        throw new Error(`Invalid pattern ${args.pattern}`); 

    } 

    if (args.find === undefined) { 

        throw new Error(`Invalid find ${args.find}`); 

    } 

    if (args.replace === undefined) { 

        throw new Error(`Invalid replace ${args.replace}`); 

    } 

} </pre>
<p>The following function finds the path of files that match the <kbd>glob</kbd> pattern provided:</p>
<pre>async function findMatchingFilesAsync(pattern: string) { 

    const files = await globAsync(pattern); 

    // We need to let TypeScript that files are an array 

    return files as string[]; 

} </pre>
<p>The following function is used to find a word in a file and replace it with a second word:</p>
<pre>async function findAndReplaceAsync( 

    file: string, 

    find: string, 

    replace: string 

) { 

    const buffer = await readFileAsync(file); 

    const originalText = buffer.toString(); 

    // This is a quick way to replace a word in JavaScript 

    const newText = originalText.split(find).join(replace); 

    await writeFileAsync(file, newText, "utf8"); 

} </pre>
<p>This function is the main function in the application and the application's entry point. It delegates work to all the previous functions:</p>
<pre>async function runAsync() { 

    // Read arguments 
    const args = getCommandLineArguments(); 

    // Validate arguments 
    validateCommandLineArguments(args); 

    // Find matching files 
    const files = await findMatchingFilesAsync(args.pattern);  

    // Find and replace 
    files.forEach(async (file) =&gt; { 
        await findAndReplaceAsync(file, args.find, args.replace); 
    }); 
} </pre>
<p>At this point, we can invoke the application's entry point:</p>
<pre>(async () =&gt; { 
    await runAsync(); 
})(); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with databases</h1>
                
            
            
                
<p>In this section, we are going to learn how to interact with a database from a Node.js application using a TypeScript library known as TypeORM. TypeORM is an <strong>object-relational mapping</strong> (<strong>ORM</strong>) library. An ORM is a tool that allows us to use objects and methods to interact with a database instead of using one of the flavors of the SQL programming language.</p>
<p>We are going to need a Postgres database server running in our development environment before we can implement an example. There are multiple ways to get a server up and running, but we are going to use Docker. Docker is a virtualization service that allows us to run software in standalone virtual machines known as containers. A Docker container is an instance of a Docker image. We are going to start by installing the Docker community edition by following the instructions at the official Docker installation guide, which can be found at <a href="https://docs.docker.com/install">https://docs.docker.com/install</a>, and we will then run the following command to download the Docker Postgres image:</p>
<pre><strong>docker pull postgres:9.5</strong> </pre>
<p>We can use the following command to see all the installed images:</p>
<pre><strong>docker images</strong> </pre>
<p>We also need to set some environment variables. The following should work if you are using Bash as your command line:</p>
<pre><strong>export DATABASE_USER=postgres </strong> 

<strong>export DATABASE_PASSWORD=secret </strong> 

<strong>export DATABASE_HOST=localhost </strong> 

<strong>export DATABASE_PORT=5432 </strong> 

<strong>export DATABASE_DB=demo</strong> </pre>
<p>Please note that if you are using Windows, you will need to use the <kbd>setx</kbd> command instead of the <kbd>export</kbd> command to declare an environment variable. You can learn more about the <kbd>setx</kbd> command at <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx">https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/setx</a>.</p>
<p>At this point, we can run a container using the Postgres image. The following command runs the container using the environment variables that we declared in the preceding step:</p>
<pre><strong>docker run --name POSTGRES_USER -p "$DATABASE_PORT":"$DATABASE_PORT"  </strong> 

<strong>-e POSTGRES_PASSWORD="$DATABASE_PASSWORD"  </strong> 

<strong>-e POSTGRES_USER="$DATABASE_USER"  </strong> 

<strong>-e POSTGRES_DB="$DATABASE_DB" </strong> 

<strong>-d postgres</strong> </pre>
<p>We can run the following command to see all the Docker containers on our machine:</p>
<pre><strong>docker ps -a</strong> </pre>
<p>If everything went well, you should see something like the following in your console:</p>
<div><img class="alignnone size-full wp-image-255 image-border" src="img/bc5438b8-2cc2-4d48-a02e-ac5508f12b1f.png" style="width:150.00em;height:4.58em;" width="1800" height="55"/></div>
<p>If you need to start again, you can stop and remove the Docker container using the following commands respectively:</p>
<pre><strong>docker stop $containerId</strong> 

<strong>docker rm $containerId</strong> </pre>
<p>Please note that we are not going to go into more details about Docker because it is out of the scope of this book. Please refer to the official Docker documentation at <a href="https://docs.docker.com">https://docs.docker.com</a> if you need additional help.</p>
<p>At this point, we should have a Postgres server running as a Docker container. We also need to install some <kbd>npm</kbd> modules:</p>
<pre><strong>npm install reflect-metadata pg typeorm</strong> </pre>
<p>The <kbd>pg</kbd> module is used by TypeORM to connect to the Postgres database. The <kbd>reflect-metadata</kbd> is used by TypeORM to read and write metadata. It is very important to import the <kbd>reflect-metadata</kbd> module only once in our entire application.</p>
<p>The following code snippet uses TypeORM to declare an entity named <kbd>Movie</kbd>. The <kbd>Movie</kbd> entity will be mapped into a database table by TypeORM. The example also creates a database connection and a <kbd>Movie</kbd> repository. We finally use the repository instance to insert a new movie into the movie table and to read the movies in the table that match the year 1977:</p>
<pre>import "reflect-metadata"; 

import { 
    Entity, 
    getConnection, 
    createConnection, 
    PrimaryGeneratedColumn, 
    Column 
} from "typeorm"; 

@Entity() 
class Movie { 
    @PrimaryGeneratedColumn() 
    public id!: number; 
    @Column() 
    public title!: string; 
    @Column() 
    public year!: number; 
} 

const entities = [ 
    Movie 
]; 

const DATABASE_HOST = process.env.DATABASE_HOST || "localhost"; 
const DATABASE_USER = process.env.DATABASE_USER || ""; 
const DATABASE_PORT = 5432; 
const DATABASE_PASSWORD = process.env.DATABASE_PASSWORD || ""; 
const DATABASE_DB = "demo"; 
 
(async () =&gt; {     
    const conn = await createConnection({ 
        type: "postgres", 
        host: DATABASE_HOST, 
        port: DATABASE_PORT, 
        username: DATABASE_USER, 
        password: DATABASE_PASSWORD, 
        database: DATABASE_DB, 
        entities: entities, 
        synchronize: true 
    }); 

    const getRepository = (entity: Function) =&gt; conn.getRepository(entity); 
    const movieRepository = conn.getRepository(Movie); 

    // INSERT INTO movies 
    // VALUES ('Star Wars: Episode IV - A New Hope', 1977) 
    await movieRepository.save({ 
        title: "Star Wars: Episode IV - A New Hope", 
        year: 1977 
    }); 

    // SELECT * FROM movies WHERE year=1977 
    const aMovieFrom1977 = await movieRepository.findOne({ 
        year: 1977 
    }); 

    if (aMovieFrom1977) { 
        console.log(aMovieFrom1977.title); 
    } 
})(); </pre>
<p>The repository design pattern uses classes to encapsulate the data access logic and the mapping between the database and the domain entities. You can learn more about the repository pattern at <a href="https://msdn.microsoft.com/en-us/library/ff649690.aspx">https://msdn.microsoft.com/en-us/library/ff649690.aspx</a>.</p>
<p>Finally, we can run the example using <kbd>ts-node</kbd>:</p>
<pre><strong>ts-node app.ts</strong> </pre>
<p>Please note that the environment variables and the Postgres server must be configured correctly for this example to work.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with REST APIs</h1>
                
            
            
                
<p>In this section, we are going to learn how to implement some REST APIs using Node.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hello world (http)</h1>
                
            
            
                
<p>The <kbd>http</kbd> module allows us to perform tasks in relation to the HTTP protocol. The following code snippet showcases how we can use the <kbd>http</kbd> module to implement very minimal implantation of a web server:</p>
<pre>import * as http from "http"; 
const hostname = "127.0.0.1"; 
const port = 3000; 

const server = http.createServer((req, res) =&gt; { 
    res.statusCode = 200; 
    res.setHeader("Content-Types", "text/plain"); 
    res.end("Hello world!"); 
}); 

server.listen(port, hostname, () =&gt; { 
    console.log(`Server running at http://${hostname}:${port}/`); 
}); </pre>
<p>We have created a web server that will listen to all the HTTP requests. The <kbd>http</kbd> module allows us to implement our web HTTP server, but its level of abstraction is very low. In a real-world application, we would prefer something with a higher level of abstraction, something that, for example, doesn't require us to set the response status code by hand. There are multiple frameworks for Node.js that can provide us with a higher level of abstraction over the HTTP protocol. In the following section, we are going to learn how to use one of them: Express.js.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Hello world (Express.js)</h1>
                
            
            
                
<p>Express.js is a framework designed for the implementation of server-side web applications. To use Express with TypeScript, we are going to need the following <kbd>npm</kbd> modules:</p>
<pre><strong>npm install @types/node @types/express -save-dev</strong> 

<strong>npm install express --save</strong> </pre>
<p>The following example implements an application with a behavior almost identical to the application that we implemented in the preceding section, but this time we use Express.js instead of the <kbd>http core</kbd> module:</p>
<pre>import express from "express"; 

const port = 3000; 
const app = express(); 

app.get("/", (req, res) =&gt; { 
    res.send("Hello World!"); 
}); 

app.listen(port, () =&gt; { 
    console.log(`Server running at http://127.0.0.1:${port}/`); 
}); </pre>
<p>As we can see, even in an example as simple as the preceding one, with Express, sometimes we don't need to take care of some low-level details, such as setting up the response status code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Routing with Express</h1>
                
            
            
                
<p>In the preceding section, we learned how to declare a route; however, as our application grows, we are going to need to implement some route organization strategy. Express allows us to create multiple router instances and nest them as a tree-like data structure. The following code snippet demonstrates how to create two routers that deal with two different kinds of entities (<kbd>movies</kbd> and <kbd>directors</kbd>); the two routers are then used by the Express application:</p>
<pre>import express from "express"; 

const moviesRouter = express.Router(); 
 
// URL "/api/v1/movies" + "/" 
moviesRouter.get("/", (req, res) =&gt; { 
    res.send("Hello from movies!"); 
}); 

const directorsRouter = express.Router(); 
 
// URL "/api/v1/directors" + "/" 
directorsRouter.get("/", (req, res) =&gt; { 
    res.send("Hello from directors!"); 
}); 

const port = 3000; 
const app = express(); 

app.use("/api/v1/movies", moviesRouter); 
app.use("/api/v1/directors", directorsRouter); 

app.listen(port, () =&gt; { 
    console.log(`Server running at http://127.0.0.1:${port}/`); 
}); </pre>
<p>When we run the preceding example, two routes are available:</p>
<ul>
<li><kbd>http://localhost:3000/api/v1/directors</kbd></li>
<li><kbd>http://localhost:3000/api/v1/directors</kbd></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Express middleware</h1>
                
            
            
                
<p>Express also allows us to declare a middleware function. A middleware function allows us to implement cross-cutting concerns. A cross-cutting concern is a requirement that affects the entire application or a subset of it. Common examples of cross-cutting concerns are logging and authorization.</p>
<p>A middleware function takes the current request and response as arguments together with a function known as <kbd>next</kbd>:</p>
<pre>const middlewareFunction = ( 
    req: express.Request, 
    res: express.Response, 
    next: express.NextFunction 
) =&gt; { 
    next(); 
}; </pre>
<p>We can chain middleware functions, and the <kbd>next</kbd> function is what communicates to Express that the middleware has finished its task and the next middleware can be invoked. When no more middleware functions are available, the route handler is invoked.</p>
<p>The following code snippet declares two middleware functions. The first middleware function (<kbd>timerMiddleware</kbd>) is invoked once for each HTTP request that hits the server. The second middleware function (<kbd>loggerMiddleware</kbd>) is invoked once for each HTTP request that hits the <kbd>http://localhost:3000</kbd> endpoint:</p>
<pre>import express from "express"; 

const port = 3000; 
const app = express();  

const timerMiddleware = ( 
    req: express.Request, 
    res: express.Response, 
    next: express.NextFunction 
) =&gt; { 
    console.log(`Time: ${Date.now()}`); 
    next(); 
}; 

const loggerMiddleware = ( 
    req: express.Request, 
    res: express.Response, 
    next: express.NextFunction 
) =&gt; { 

    console.log(`URL: ${req.url}`); 
    next(); 
}; 

// Application level middleware 
app.use(timerMiddleware); 

// Route level middleware 
app.get("/", loggerMiddleware, (req, res) =&gt; { 
    res.send("Hello World!"); 
}); 

app.listen(port, () =&gt; { 
    console.log(`Server running at http://127.0.0.1:${port}/`); 
}); </pre>
<p>When we execute the preceding example, the following route becomes available: <kbd>http://localhost:3000</kbd>. When an HTTP request hits the preceding URL, the response is <kbd>Hello world!</kbd> and the console displays the output generated by both middleware functions previously declared:</p>
<pre>URL: / 
Time: 1520354128960 </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Architecting Node.js application – the MVC design pattern</h1>
                
            
            
                
<p>Architecting Node.js applications is a very extensive topic that could take an entire book on its own. However, we are going to cover one of the most commonly used design patterns, the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) design pattern, defined as follows by MSDN:</p>
<p class="mce-root">The MVC framework includes the following components:</p>
<ul>
<li><kbd>Models</kbd>: Model objects are the parts of the application that implement the logic for the application's data domain. Often, model objects retrieve and store model state in a database. For example, a <kbd>Product</kbd> object might retrieve information from a database, operate on it, and then write updated information back to a Products table in a database. In small applications, the model is often a conceptual separation instead of a physical one. For example, if the application only reads a dataset and sends it to the view, the application does not have a physical model layer and associated classes. In that case, the dataset takes on the role of a model object.</li>
<li><kbd>Views</kbd>: Views are the components that display the application's <strong>user interface</strong> (<strong>UI</strong>). Typically, this UI is created from the model data. An example would be an edit view of a Products table that displays text boxes, drop-down lists and checks boxes based on the current state of a <kbd>Product</kbd> object.</li>
<li><kbd>Controllers</kbd>: Controllers are the components that handle user interaction, work with the model, and ultimately select a view to render that displays UI. In an MVC application, the view only displays information; the controller handles and responds to user input and interaction. For example, the controller handles query-string values and passes these values to the model, which in turn might use these values to query the database.</li>
</ul>
<p>The MVC design pattern can be implemented in both the backend and the frontend. However, in this section, we are going to implement it in the backend.</p>
<p>Please note that to be able to run this example without problems, you must first install all dependencies using <kbd>npm install</kbd> from the <kbd>chapter_10</kbd> folder in the companion source code. Then you can open <kbd>09_mvc</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Model</h1>
                
            
            
                
<p>Our model is going to be composed of two layers. We are going to implement an entity and a repository. The entity is implemented using TypeORM:</p>
<pre>import { 
    Entity, 
    PrimaryGeneratedColumn, 
    Column 
} from "typeorm"; 

@Entity() 
export class Movie { 
    @PrimaryGeneratedColumn() 
    public id!: number; 
    @Column() 
    public title!: string; 
    @Column() 
    public year!: number; 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Repository</h1>
                
            
            
                
<p>The repository is also implemented with TypeORM:</p>
<pre>import { getConnection } from "typeorm"; 

import { Movie } from "../entities/movie"; 

export function getRepository() { 
    const conn = getConnection(); 
    const movieRepository = conn.getRepository(Movie); 
    return movieRepository; 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Controller</h1>
                
            
            
                
<p>The controller uses the model (entity + repository) and it is implemented using the Express routing techniques that we explored earlier in this chapter.</p>
<p>We are going to declare routes to get all movies, filter movies by year, and create a new movie. The example also uses <kbd>req.params</kbd> to access the request parameter year.</p>
<p>It is important to note that we can use the <kbd>get</kbd> method to declare a route handler for an HTTP GET request, while we can use the <kbd>post</kbd> method to declare a route handler for an HTTP POST request:</p>
<pre>import { Router } from "express"; 

import { getRepository } from "../repositories/movie_repository"; 
<br/>const movieRouter = Router(); 
movieRouter.get("/", function (req, res) { 
    const movieRepository = getRepository(); 
    movieRepository.find().then((movies) =&gt; { 
        res.json(movies); 
    }).catch((e: Error) =&gt; { 
        res.status(500); 
        res.send(e.message); 
    }); 
}); 

movieRouter.get("/:year", function (req, res) { 
    const movieRepository = getRepository(); 
    movieRepository.find({ 
        year: req.params.year 
    }).then((movies) =&gt; { 
        res.json(movies); 
    }).catch((e: Error) =&gt; { 
        res.status(500); 
        res.send(e.message); 
    }); 
}); 

movieRouter.post("/", function (req, res) { 
    const movieRepository = getRepository(); 
    const newMovie = req.body; 
    if ( 
        typeof newMovie.title !== "string" || 
        typeof newMovie.year !=== "number" 
    ) { 
        res.status(400); 
        res.send(`Invalid Movie!`); 
    } 

    movieRepository.find(newMovie).then((movie) =&gt; { 
        res.json(movie); 
    }).catch((e: Error) =&gt; { 
        res.status(500); 
        res.send(e.message); 
    }); 
}); 

export { movieRouter }; </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Database</h1>
                
            
            
                
<p>In our repository, we have used the <kbd>getConnection</kbd> function from TypeORM. Before we can invoke this function, we need to ensure that a connection has been created. The following function is used later to create a database connection:</p>
<pre>import { createConnection } from "typeorm"; 

import { Movie } from "./entities/movie"; 

export async function getDbConnection() { 
    const DATABASE_HOST = process.env.DATABASE_HOST || "localhost"; 
    const DATABASE_USER = process.env.DATABASE_USER || ""; 
    const DATABASE_PORT = 5432; 
    const DATABASE_PASSWORD = process.env.DATABASE_PASSWORD || ""; 
    const DATABASE_DB = "demo"; 
 
    const entities = [ 
        Movie 
    ]; 

    const conn = await createConnection({ 
        type: "postgres", 
        host: DATABASE_HOST, 
        port: DATABASE_PORT, 
        username: DATABASE_USER, 
        password: DATABASE_PASSWORD, 
        database: DATABASE_DB, 
        entities: entities, 
        synchronize: true 
    }); 

    return conn; 

} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">View</h1>
                
            
            
                
<p>Because we are implementing REST services, we don't have a data presentation layer. The REST API can be completely decoupled from the web user interface. We will not learn how to implement the presentation layer in this chapter because this topic is going to be covered in the upcoming chapters.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Index</h1>
                
            
            
                
<p>The index file is the application's entry point. The entry point creates a new Express app and a database connection. It then connects the controller routes to the Express app and launches the web server:</p>
<pre>import "reflect-metadata"; 

import express from "express"; 

import { getDbConnection } from "./db"; 

import { movieRouter } from "./controllers/movie_controller"; 

(async () =&gt; { 
    await getDbConnection();
    const port = 3000; 
    const app = express(); 
    app.use("/api/v1/movies", movieRouter); 
    app.listen(port, () =&gt; { 
        console.log(`Server running at http://127.0.0.1:${port}/`) 
    }); 
})(); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Controllers and routing with inversify-express-utils</h1>
                
            
            
                
<p>Earlier in this book, we learned about dependency injection and dependency inversion with InversifyJS. In this section, we are going to learn how to use InversifyJS together with Express, using a helper <kbd>npm</kbd> module known as <kbd>inversify-express-utils</kbd>. We are going to need to install <kbd>inversify</kbd> and <kbd>inversify-express-utils</kbd>:</p>
<pre><strong>npm install inversify inversify-express-utils</strong> </pre>
<p>Please note that to be able to run this example without problems, you must first install all dependencies using <kbd>npm install</kbd> from the <kbd>chapter_10</kbd> folder in the companion source code. Then you can open the <kbd>10_inversify_express_utils</kbd> folder.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Model, repository, database, and view</h1>
                
            
            
                
<p>We can reuse 100% of the code used for the model, repository, database, and view in the preceding example.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Types</h1>
                
            
            
                
<p>We need to declare some identifiers required for the InversifyJS type bindings. If you don't know what a type binding is, you should go back to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>, to learn the basics about InversifyJS. We are going to declare a binding for the <kbd>MovieRepository</kbd> class:</p>
<pre>export const TYPE = { 
    MovieRepository: Symbol("MovieRepository") 
}; </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Controller</h1>
                
            
            
                
<p>The InversifyJS Express utils allow us to declare controllers using what is known as declarative routing. Instead of declaring <kbd>Router</kbd> instances, we can annotate a controller class using some decorators. The metadata generated by the decorators is later used by the InversifyJS express utils to generate the <kbd>Router</kbd> instances for us.</p>
<p>The following example uses the following decorators:</p>
<ul>
<li><kbd>@controller(path)</kbd>: It is used to declare the path of a router</li>
<li><kbd>@inject(type)</kbd>: It is used to inject dependencies into a class</li>
<li><kbd>@httpGet(subpath)</kbd>: It is used to declare a route handler for HTTP GET requests</li>
<li><kbd>@httpPost(subpath)</kbd>: It is used to declare a route handler for HTTP POST requests</li>
<li><kbd>@response()</kbd>: It is used to pass the response object to a route handler as an argument</li>
<li><kbd>@requestParam(paramName)</kbd>: It is used to pass a request parameter to a route handler as an argument</li>
<li><kbd>@requestBody()</kbd>: It is used to pass the request body to a route handler as an argument</li>
</ul>
<p>Another interesting feature of the InversifyJS Express utils is that we can use <kbd>async</kbd> methods. InversifyJS will automatically detect whether our methods are <kbd>async</kbd> and use <kbd>await</kbd> when necessary:</p>
<pre>import express from "express"; 

import { inject } from "inversify"; 

import { 
    controller, 
    httpGet, 
    httpPost, 
    response, 
    requestParam, 
    requestBody 
} from "inversify-express-utils"; 

import { Repository } from "typeorm"; 

import { Movie } from "../entities/movie"; 

import { TYPE } from "../constants/types"; 

@controller("/api/v1/movies") 
export class MovieController { 
    private readonly _movieRepository: Repository&lt;Movie&gt;; 
    public constructor( 
        @inject(TYPE.MovieRepository)movieRepository: Repository&lt;Movie&gt; 
    ) { 
        this._movieRepository = movieRepository; 
    } 
    @httpGet("/") 
    public async get( 
        @response() res: express.Response 
    ) { 

        try { 
            return await this._movieRepository.find(); 
        } catch(e) { 
            res.status(500); 
            res.send(e.message); 
        } 
    } 

    @httpGet("/:year") 
    public async getByYear( 
        @response() res: express.Response, 
        @requestParam("year") yearParam: string 
    ) { 

        try { 
            const year = parseInt(yearParam); 
            return await this._movieRepository.find({ 
                year 
            }); 
        } catch(e) { 
            res.status(500); 
            res.send(e.message); 
        } 
    } 

    @httpPost("/") 
    public async post( 
        @response() res: express.Response, 
        @requestBody() newMovie: Movie 
    ) { 

        if ( 
            typeof newMovie.title !== "string" | 
            typeof newMovie.year !== "number" 
        ) { 
            res.status(400); 
            res.send(`Invalid Movie!`); 
        } 

        try { 
            return await this._movieRepository.save(newMovie); 
        } catch(e) { 
            res.status(500); 
            res.send(e.message); 
        } 
    } 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">InversifyJS configuration</h1>
                
            
            
                
<p>We are going to declare some type bindings. We are going to declare the type bindings using <kbd>AsyncContainerModule</kbd> because we need to wait for the database connection to be ready. We are going to declare a binding for <kbd>MovieRepository</kbd>. We don't need to declare a binding for the <kbd>MovieController</kbd> because the <kbd>@controller(path)</kbd> annotation will create it for us. However, we need to import the controller to ensure that the decorator is executed and, as a result, the binding is declared:</p>
<pre>import { AsyncContainerModule } from "inversify"; 

import { Repository, Connection } from "typeorm"; 

import { Movie } from "./entities/movie"; 

import { getDbConnection } from "./db"; 

import { getRepository } from "./repositories/movie_repository"; 

import { TYPE } from "./constants/types"; 

export const bindings = new AsyncContainerModule(async (bind) =&gt; { 
    await getDbConnection(); 
    await require("./controllers/movie_controller"); 
    bind&lt;Repository&lt;Movie&gt;&gt;(TYPE.MovieRepository).toDynamicValue(() =&gt; { 
        return getRepository(); 
    }).inRequestScope(); 
}); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Index</h1>
                
            
            
                
<p>The index file is also different. Instead of creating a new <em>Express</em> app, we need to create a new <em>InversifyExpressServer</em> app. The <kbd>InversifyExpressServer</kbd> constructor requires an instance of <kbd>Container</kbd>. The type bindings for the container are declared in the bindings object, which is an instance of the <kbd>AsyncContainerModule</kbd>:</p>
<pre>import "reflect-metadata"; 

import { Container } from "inversify"; 

import { InversifyExpressServer } from "inversify-express-utils"; 

import { bindings } from "./inversify.config"; 

(async () =&gt; { 
    const port = 3000; 
    const container = new Container(); 
    await container.loadAsync(bindings); 
    const app = new InversifyExpressServer(container); 
    const server = app.build(); 
    server.listen(port, () =&gt; { 
        console.log(`Server running at http://127.0.0.1:${port}/`) 
    }); 
})(); </pre>
<p>Please refer to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>, to learn more dependency injection and dependency inversion with InversifyJS.<br/>
Please refer to the official InversifyJS express utils at <a href="https://github.com/inversify/inversify-express-utils">https://github.com/inversify/inversify-express-utils</a> to learn more about it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Other applications of Node.js</h1>
                
            
            
                
<p>Developing command-line applications or REST APIs is not the only real-world application of Node.js. For example, we can develop desktop applications using Electron. Node.js is also commonly used as a reverse proxy and powers many web development tools.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned the main characteristics of Node.js as a platform and its main components. We have also learned a little bit about the Node.js ecosystem and the kind of applications that we can create using it.</p>
<p>Toward the end of the chapter, we implemented a very small REST API. In the next two chapters, we are going to learn how we can use TypeScript to create web-based user interfaces that consume these APIs.</p>


            

            
        
    </div>



  </body></html>