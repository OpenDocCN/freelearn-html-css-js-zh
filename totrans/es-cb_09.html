<html><head></head><body>
        

                            
                    <h1 class="header-title">Larger Structures with Design Patterns</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Defining steps with template functions</li>
<li>Assembling customized instances with builders</li>
<li>Replicating instances with factories</li>
<li>Processing a structure with the visitor pattern</li>
<li>Using a singleton to manage instances</li>
<li>Modifying an existing design pattern to fit different use cases</li>
<li>Combining existing design patterns to fit different use cases</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Classes, like objects and functions, are the fundamental building blocks from which we create programs. As programs grow, it becomes more difficult to efficiently and systematically define relationships between entities. When the relationships between data and functionality grow complicated, we can use classes and other objects to organize them. But what do we do when classes and objects proliferate?</p>
<p>Design patterns can be a helpful guide. Useful design patterns are refined from practical implementation. These patterns are intended to solve patterns of a given shape in predictable ways. When properly implemented, they form a contract of expected behaviors. This predictability and regularity (with other implementations of the pattern) assist in reasoning about code and a higher level of abstraction.</p>
<p>In this chapter, we'll see how common design patterns can be used as blueprints for organizing larger structures.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining steps with template functions</h1>
                
            
            
                
<p>A template is a design pattern that details the order a given set of operations are to be executed in; however, a template does not outline the steps themselves. This pattern is useful when behavior is divided in to phases that have some conceptual or side effect dependency that requires them to be executed in a specific order.</p>
<p>In this recipe, we'll see how to use the template function design pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-01-defining-steps-with-template-functions</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> file that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new abstract <kbd>class</kbd> named <kbd>Mission</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  constructor () { 
    if (this.constructor === Mission) { 
      throw new Error('Mission is an abstract class, must <br/>      extend'); 
    } 
  } 
}  </pre>
<ol start="5">
<li>Add a function named <kbd>execute</kbd> that calls three instance methods—<kbd>determineDestination</kbd>, <kbd>determinPayload</kbd>, and <kbd>launch</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  execute () { 
    this.determinDestination(); 
    this.determinePayload(); 
    this.launch(); 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>LunarRover</kbd> class that extends the <kbd>Mission</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class LunarRover extends Mission {} </pre>
<ol start="7">
<li>Add a constructor that assigns <kbd>name</kbd> to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class LunarRover extends Mission 
  constructor (name) { 
    super(); 
    this.name = name; 
  } 
}  </pre>
<ol start="8">
<li>Implement the three methods called by <kbd>Mission.execute</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class LunarRover extends Mission {} 
  determinDestination() { 
    this.destination = 'Oceanus Procellarum'; 
  } 
 
  determinePayload() { 
    this.payload = 'Rover with camera and mass spectrometer.'; 
  } 
 
  launch() { 
    console.log(` 
Destination: ${this.destination} 
Playload: ${this.payload} 
Lauched! 
Rover Will arrive in a week. 
    `); 
  } 
}  </pre>
<ol start="9">
<li>Create a <kbd>JovianOrbiter</kbd> class that also extends the <kbd>Mission</kbd> class:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class LunarRover extends Mission {} 
constructor (name) { 
    super(); 
    this.name = name; 
  } 
 
  determinDestination() { 
    this.destination = 'Jovian Orbit'; 
  } 
 
  determinePayload() { 
    this.payload = 'Orbiter with decent module.'; 
  } 
 
  launch() { 
    console.log(` 
Destination: ${this.destination} 
Playload: ${this.payload} 
Lauched! 
Orbiter Will arrive in 7 years. 
    `); 
  } 
} </pre>
<ol start="10">
<li>Create a <kbd>main</kbd> function that creates both concrete mission types and executes them:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const jadeRabbit = new LunarRover('Jade Rabbit'); 
  jadeRabbit.execute(); 
  const galileo = new JovianOrbiter('Galileo'); 
  galileo.execute(); 
} </pre>
<ol start="11">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="12">
<li>The output should appear as follows:</li>
</ol>
<div><img src="img/17f7e161-ba42-4534-b30f-2c7fab39c4bb.png" style="width:41.67em;height:37.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Mission</kbd> abstract class defines the <kbd>execute</kbd> method, which calls the other instance methods in a particular order. You'll notice that the methods called are not defined by the <kbd>Mission</kbd> class. This implementation detail is the responsibility of the extending classes. This use of abstract classes allows child classes to be used by code that takes advantage of the interface defined by the abstract class.</p>
<p>In the template function pattern, it is the responsibility of the child classes to define the steps. When they are instantiated, and the <kbd>execute</kbd> method is called, those steps are then performed in the specified order.</p>
<p>Ideally, we'd be able to ensure that <kbd>Mission.execute</kbd> was not overridden by any inheriting classes. Overriding this method works against the pattern and breaks the contract associated with it.</p>
<p>This pattern is useful for organizing data-processing pipelines. The guarantee that these steps will occur in a given order means that, if side effects are eliminated, the instances can be organized more flexibly. The implementing class can then organize these steps in the best possible way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Assembling customized instances with builders</h1>
                
            
            
                
<p>The previous recipe shows how to organize the operations of a class. Sometimes, object initialization can also be complicated. In these situations, it can be useful to take advantage of another design pattern: builders.</p>
<p>In this recipe, we'll see how to use builders to organize the initialization of more complicated objects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-02-assembling-instances-with-builders</kbd>.</li>
</ol>
<ol start="3">
<li>Create a <kbd>main.js</kbd> file that defines a new <kbd>class</kbd> named <kbd>Mission</kbd>, which that takes a <kbd>name</kbd> constructor argument and assigns it to an instance property. Also, create a <kbd>describe</kbd> method that prints out some details:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  constructor (name) { 
    this.name = name; 
  } 
 
  describe () { 
    console.log(`<br/>      The ${this.name} mission will be launched by a<br/>       ${this.rocket.name}<br/>      rocket, and deliver a ${this.payload.name} to<br/>      ${this.destination.name}. 
    `); 
  } 
   } </pre>
<ol start="4">
<li>Create classes named <kbd>Destination</kbd>, <kbd>Payload</kbd>, and <kbd>Rocket</kbd>, which receive a <kbd>name</kbd> property as a constructor parameter and assign it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
class Destination { 
  constructor (name) { 
    this.name = name; 
  } 
} 
 
class Payload { 
  constructor (name) { 
    this.name = name; 
  } 
} 
 
class Rocket { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="5">
<li>Create a <kbd>MissionBuilder</kbd> class that defines the <kbd>setMissionName</kbd>, <kbd>setDestination</kbd>, <kbd>setPayload</kbd>, and <kbd>setRocket</kbd> methods:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionBuilder { 
 
  setMissionName (name) { 
    this.missionName = name; 
    return this; 
  } 
 
  setDestination (destination) { 
    this.destination = destination; 
    return this; 
  } 
 
  setPayload (payload) { 
    this.payload = payload; 
    return this; 
  } 
 
  setRocket (rocket) { 
    this.rocket = rocket; 
    return this; 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>build</kbd> method that creates a new <kbd>Mission</kbd> instance with the appropriate properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionBuilder { 
  build () { 
    const mission = new Mission(this.missionName); 
    mission.rocket = this.rocket; 
    mission.destination = this.destination; 
    mission.payload = this.payload; 
    return mission; 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that uses <kbd>MissionBuilder</kbd> to create a new mission instance:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  // build an describe a mission 
  new MissionBuilder() 
    .setMissionName('Jade Rabbit') 
    .setDestination(new Destination('Oceanus Procellarum')) 
    .setPayload(new Payload('Lunar Rover')) 
    .setRocket(new Rocket('Long March 3B Y-23')) 
    .build() 
    .describe(); 
}  </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
<li>Your output should appear as follows:</li>
</ol>
<div><img src="img/6cf25134-2e1e-4673-9212-3606668ae3e2.png" style="width:41.33em;height:34.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The builder defines methods for assigning all the relevant properties and defines a build method that ensures that each is called and assigned appropriately. Builders are like template functions, but instead of ensuring that a set of operations are executed in the correct order, they ensure that an instance is properly configured before returning.</p>
<p>Because each instance method of <kbd>MissionBuilder</kbd> returns the <kbd>this</kbd> reference, the methods can be chained. The last line of the <kbd>main</kbd> function calls <kbd>describe</kbd> on the new <kbd>Mission</kbd> instance that is returned from the <kbd>build</kbd> method.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Replicating instances with factories</h1>
                
            
            
                
<p>Like builders, factories are a way of organizing object construction. They differ from builders in how they are organized. Often, the interface of factories is a single function call. This makes factories easier to use, if less customizable, than builders.</p>
<p>In this recipe, we'll see how to use factories to easily replicate instances.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-03-replicating-instances-with-factories</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that defines a new <kbd>class</kbd> named <kbd>Mission</kbd>. Add a constructor that takes a <kbd>name</kbd> constructor argument and assigns it to an instance property. Also, define a simple <kbd>describe</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  constructor (name) { 
    this.name = name; 
  } 
 
  describe () { 
    console.log(` 
The ${this.name} mission will be launched by a ${this.rocket.name} rocket, and 
deliver a ${this.payload.name} to ${this.destination.name}. 
    `); 
  } 
} </pre>
<ol start="5">
<li>Create three classes named<strong> </strong><kbd>Destination</kbd>, <kbd>Payload</kbd>, and <kbd>Rocket</kbd>, that take <kbd>name</kbd> as a constructor argument and assign it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Destination { 
  constructor (name) { 
    this.name = name; 
  } 
} 
 
class Payload { 
  constructor (name) { 
    this.name = name; 
  } 
} 
 
class Rocket { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>MarsMissionFactory</kbd> object with a single <kbd>create</kbd> method that takes two arguments: <kbd>name</kbd> and <kbd>rocket</kbd>. This method should create a new <kbd>Mission</kbd> using those arguments:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
const MarsMissionFactory = { 
  create (name, rocket) { 
    const mission = new Mission(name); 
    mission.destination = new Destination('Martian surface'); 
    mission.payload = new Payload('Mars rover'); 
    mission.rocket = rocket; 
    return mission; 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> method that creates and describes two similar missions:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
export function main() { 
  // build an describe a mission 
  MarsMissionFactory 
    .create('Curiosity', new Rocket('Atlas V')) 
    .describe(); 
  MarsMissionFactory 
    .create('Spirit', new Rocket('Delta II')) 
    .describe(); 
} </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="9">
<li>Your output should appear as follows:</li>
</ol>
<div><img src="img/8128d8d6-c25a-45fc-993a-296ce42bda19.png" style="width:43.00em;height:35.83em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>create</kbd> method takes a subset of the properties needed to create a new mission. The remaining values are provided by the method itself. This allows factories to simplify the process of creating similar instances. In the <kbd>main</kbd> function, you can see that two Mars missions have been created, only differing in name and <kbd>Rocket</kbd> instance. We've halved the number of values needed to create an instance.</p>
<p>This pattern can help reduce instantiation logic. In this recipe, we simplified the creation of different kinds of missions by identifying the common attributes, encapsulating those in the body of the factory function, and using arguments to supply the remaining properties. In this way, commonly used instance shapes can be created without additional boilerplate code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Processing a structure with the visitor pattern</h1>
                
            
            
                
<p>The patterns we've seen thus far organize the construction of objects and the execution of operations. The next pattern we'll look at is specially made to traverse and perform operations on hierarchical structures.</p>
<p>In this recipe, we'll be looking at the visitor pattern.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>
<p>Additionally, this recipe assumes that you've completed the previous recipe, <em>Assembling customized instances with builders</em>. If not, complete that recipe first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Copy the <kbd>09-02-assembling-instances-with-builders</kbd> folder to a new <kbd>09-04-processing-a-structure-with-the-visitor-pattern </kbd>directory.</li>
</ol>
<ol start="3">
<li>Add a class named <kbd>MissionInspector</kbd> to <kbd>main.js</kbd>. Create a <kbd>visitor</kbd> method that calls a corresponding method for each of the following types: <kbd>Mission</kbd>, <kbd>Destination</kbd>, <kbd>Rocket</kbd>, and <kbd>Payload</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
/* visitor that inspects mission */ 
class MissionInspector { 
  visit (element) { 
    if (element instanceof Mission) { 
      this.visitMission(element); 
    } 
    else if (element instanceof Destination) { 
      this.visitDestination(element); 
    } 
    else if (element instanceof Rocket) { 
      this.visitRocket(element); 
    } 
    else if (element instanceof Payload) { 
      this.visitPayload(element); 
    } 
  } 
} </pre>
<ol start="4">
<li>Create a <kbd>visitMission</kbd> method that logs out an <kbd>ok</kbd> message:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionInspector { 
  visitMission (mission) { 
    console.log('Mission ok'); 
    mission.describe(); 
     } 
} </pre>
<ol start="5">
<li>Create a <kbd>visitDestination</kbd> method that throws an error if the destination is not in an approved list:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionInspector { 
  visitDestination (destination) { 
    const name = destination.name.toLowerCase(); 
 
    if ( 
      name === 'mercury' || 
      name === 'venus' || 
      name === 'earth' || 
      name === 'moon' || 
      name === 'mars' 
    ) { 
      console.log('Destination: ', name, ' approved'); 
    } else { 
      throw new Error('Destination: '' + name + '' not approved      <br/>      at this time'); 
    } 
     } 
} </pre>
<ol start="6">
<li>Create a <kbd>visitPayload</kbd> method that throws an error if the <kbd>payload</kbd> isn't valid:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionInspector { 
  visitPayload (payload) { 
    const name = payload.name.toLowerCase(); 
    const payloadExpr = /(orbiter)|(rover)/; 
 
    if ( payloadExpr.test(name) ) { 
      console.log('Payload: ', name, ' approved'); 
    } 
    else { 
      throw new Error('Payload: '' + name + '' not approved at <br/>      this time'); 
    } 
  } 
} </pre>
<ol start="7">
<li>Create a <kbd>visitRocket</kbd> method that logs out an <kbd>ok</kbd> message:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionInspector { 
 
  visitRocket (rocket) { 
    console.log('Rocket: ', rocket.name, ' approved'); 
  } 
} </pre>
<ol start="8">
<li>Add an <kbd>accept</kbd> method to the <kbd>Mission</kbd> class that calls <kbd>accept</kbd> on its constituents, then tells <kbd>visitor</kbd> to visit the current instance:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
 
  // other mission code ... 
 
  accept (visitor) { 
    this.rocket.accept(visitor); 
    this.payload.accept(visitor); 
    this.destination.accept(visitor); 
    visitor.visit(this); 
  } 
  } </pre>
<ol start="9">
<li>Add an <kbd>accept</kbd> method to the <kbd>Destination</kbd> class that tells <kbd>visitor</kbd> to visit the current instance:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Destination { 
 
  // other mission code ... 
 
 
  accept (visitor) { 
    visitor.visit(this); 
    } 
  } </pre>
<ol start="10">
<li>Add an <kbd>accept</kbd> method to the <kbd>Payload</kbd> class that tells <kbd>visitor</kbd> to visit the current instance:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Payload { 
 
  // other mission code ... 
 
  accept (visitor) { 
    visitor.visit(this); 
    } 
  } </pre>
<ol start="11">
<li>
<p>Add an <kbd>accept</kbd> method to the <kbd>Rocket</kbd> class that tells <kbd>visitor</kbd> to visit the current instance:</p>
</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
 
  // other mission code ... 
 
  accept (visitor) { 
    visitor.visit(this); 
    } 
  } </pre>
<ol start="12">
<li>Create a <kbd>main</kbd> function that creates different instances with the builder, visits them with the <kbd>MissionInspector</kbd> instance, and logs out any thrown errors:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  // build an describe a mission 
  const jadeRabbit = new MissionBuilder() 
    .setMissionName('Jade Rabbit') 
    .setDestination(new Destination('Moon')) 
    .setPayload(new Payload('Lunar Rover')) 
    .setRocket(new Rocket('Long March 3B Y-23')) 
    .build(); 
 
  const curiosity = new MissionBuilder() 
    .setMissionName('Curiosity') 
    .setDestination(new Destination('Mars')) 
    .setPayload(new Payload('Mars Rover')) 
    .setRocket(new Rocket('Delta II')) 
    .build(); 
 
  // expect error from Destination 
  const buzz = new MissionBuilder() 
    .setMissionName('Buzz Lightyear') 
    .setDestination(new Destination('Too Infinity And Beyond')) 
    .setPayload(new Payload('Interstellar Orbiter')) 
    .setRocket(new Rocket('Self Propelled')) 
    .build(); 
 
  // expect error from payload 
  const terraformer = new MissionBuilder() 
    .setMissionName('Mars Terraformer') 
    .setDestination(new Destination('Mars')) 
    .setPayload(new Payload('Terraformer')) 
    .setRocket(new Rocket('Light Sail')) 
    .build(); 
 
  const inspector = new MissionInspector(); 
 
  [jadeRabbit, curiosity, buzz, terraformer].forEach((mission) =&gt; <br/>   { 
    try { 
      mission.accept(inspector); 
    } catch (e) { console.error(e); } 
  }); 
} </pre>
<ol start="13">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>Your output should appear as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/53fd4e1c-d6ce-416c-a89c-d64a7c6dd8db.png" style="width:33.50em;height:52.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The visitor pattern has two components. The visitor processes the subject objects and the subjects tell other related subjects about the visitor, and when the current subject should be visited.</p>
<p>The <kbd>accept</kbd> method is required for each subject to receive a notification that there is a visitor. That method then makes two types of method call. The first is the <kbd>accept</kbd> method on its related subjects. The second is the <kbd>visitor</kbd> method on the visitor. In this way, the visitor traverses a structure by being passed around by the subjects.</p>
<p>The <kbd>visitor</kbd> methods are used to process different types of node. In some languages, this is handled by language-level <strong>polymorphism</strong>. In JavaScript, we can use run-time type checks to do this.</p>
<p>The visitor pattern is a good option for processing hierarchical structures of objects, where the structure is not known ahead of time, but the types of subjects are known.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a singleton to manage instances</h1>
                
            
            
                
<p>Sometimes, there are objects that are resource intensive. They may require time, memory, battery power, or network usage that are unavailable or inconvenient. It is often useful to manage the creation and sharing of instances.</p>
<p>In this recipe, we'll see how to use singletons to manage instances.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-05-singleton-to-manage-instances</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> file that defines a new <kbd>class</kbd> named <kbd>Rocket</kbd><strong>.</strong> Add a constructor takes a <kbd>name</kbd> constructor argument and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor (name) { 
    this.name = name; 
  } 
}  </pre>
<ol start="5">
<li>Create a <kbd>RocketManager</kbd> object that has a <kbd>rockets</kbd> property. Add a <kbd>findOrCreate</kbd> method that indexes <kbd>Rocket</kbd> instances by the <kbd>name</kbd> property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
const RocketManager = { 
  rockets: {}, 
  findOrCreate (name) { 
    const rocket = this.rockets[name] || new Rocket(name); 
    this.rockets[name] = rocket; 
    return rocket; 
  } 
} </pre>
<ol start="6">
<li>Create a <kbd>main</kbd> function that creates instances with and without the manager. Compare the instances and see whether they are identical:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const atlas = RocketManager.findOrCreate('Atlas V'); 
  const atlasCopy = RocketManager.findOrCreate('Atlas V'); 
  const atlasClone = new Rocket('Atlas V'); 
 
  console.log('Copy is the same: ', atlas === atlasCopy); 
  console.log('Clone is the same: ', atlas === atlasClone); 
} </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="8">
<li>Your output should appear as follows:</li>
</ol>
<div><img src="img/03775438-0d01-404c-86c0-7af5f2b0731c.png" style="width:47.42em;height:25.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The object stores references to the instances, indexed by the string value given with <kbd>name</kbd>. This map is created when the module loads, so it is persisted through the life of the program. The singleton is then able to look up the object and returns instances created by <kbd>findOrCreate</kbd> with the same name.</p>
<p>Conserving resources and simplifying communication are primary motivations for using singletons. Creating a single object for multiple uses is more efficient in terms of space and time needed than creating several. Plus, having single instances for messages to be communicated through makes communication between different parts of a program easier.</p>
<p>Singletons may require more sophisticated indexing if they are relying on more complicated data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying an existing design pattern to fit different use cases</h1>
                
            
            
                
<p>Patterns are not commandments received from a higher plane. They have their origins in, and have been refined from, real-world engineering projects. Patterns can be modified to fit new situations better.</p>
<p>In this recipe, we'll see how to modify the factory pattern to make creating missions easier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-06-modifying-existing-design-pattern-to-fit-differet-use-cases</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new <kbd>class</kbd> named <kbd>Mission</kbd>. Add a constructor that takes a <kbd>name</kbd> constructor argument and assigns it to an instance property. Also, define a simple <kbd>print</kbd> method:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  constructor (name) { 
    this.name = name; 
  } 
 
  describe () { 
    console.log(` The ${this.name} mission will be launched by a  <br/>    ${this.rocket.name}, and deliver a ${this.payload.name} to <br/>    ${this.destination.name}. 
    `); 
  } 
}  </pre>
<ol start="5">
<li>Create a class named <kbd>Destination</kbd>. Add a constructor takes a name constructor takes a <kbd>name</kbd> constructor argument and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Destination { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="6">
<li>Create a class named <kbd>Payload</kbd>. Add a constructor that takes a <kbd>name</kbd> constructor argument and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Payload { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="7">
<li>Create a class named <kbd>Rocket</kbd>. Add a constructor that takes a <kbd>name</kbd> constructor argument and assigns it to an instance property:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="8">
<li>Create a function named <kbd>MissionProgramFactoryFn</kbd> that takes <kbd>rocketName</kbd>, <kbd>destinationName</kbd>, and <kbd>payloadName</kbd> arguments. This function should return a function that receives a <kbd>name</kbd> argument and returns a new <kbd>mission</kbd> with all of the properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
function MissionProgramFactoryFn(rocketName, destinationName, payloadName) { 
  return (name) =&gt; { 
    const mission = new Mission(name); 
    mission.rocket = new Rocket(rocketName); 
    mission.destination = new Destination(destinationName); 
    mission.payload = new Payload(payloadName); 
    return mission; 
  } 
} </pre>
<ol start="9">
<li>Create a <kbd>main</kbd> function that creates two program factories. Create and describe multiple missions with the instances:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  const marsRoverProgram = MissionProgramFactoryFn('AtlasV',<br/>  'MartianSurface', 'Mars Rover'); 
  marsRoverProgram('Curiosity').describe(); 
  marsRoverProgram('Spirit').describe(); 
 
  const interstellarProgram = MissionProgramFactoryFn('Warp <br/>  Drive',<br/>  'Vulcan', 'Dimplomatic Vessal'); 
  interstellarProgram('Enterprise E').describe(); 
  interstellarProgram('Defiant').describe(); 
} </pre>
<ol start="10">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="11">
<li>Your output should appear as follows:
<div><img src="img/db6a42fd-fa3c-4b08-b667-b72a942fd2b9.png" style="width:44.17em;height:37.42em;"/></div>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the preceding example, we modified the factory pattern to be a bit more flexible. Rather than calling the factory function directly, we created new ones with the <kbd>MissionProgramFactoryFn</kbd> function. In effect, we created a factory of factories!<br/></p>
<p>Variables within a JavaScript function are available to any blocks contained by that function. Thus, the <kbd>rocketName</kbd>, <kbd>destinationName</kbd>, and <kbd>payloadName</kbd> values are available to the body of the factory functions returned from <kbd>MissionProgramFactoryFn</kbd>.  This way, we reuse common values for new instances without repeating them.</p>
<p>Returning a function from a function is called a second-order function; this pattern is common in JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining existing design patterns to fit different use cases</h1>
                
            
            
                
<p>Modifying and extending patterns doesn't mean that we must forge ahead into <em>terra incognita</em>. It is still advisable to use well-known patterns when tackling new problems.</p>
<p>In this recipe, we'll see how to combine two patterns to better fit a given use case.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>09-07-combine-design-patters-to-fit-new-use-case</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> file that defines a new <kbd>class</kbd> named <kbd>Mission</kbd>. Create a constructor that assigns a <kbd>name</kbd> argument to an instance variable. Add a simple <kbd>print</kbd> function:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Mission { 
  constructor (name) { 
    this.name = name; 
  } 
 
  describe () { 
    console.log(` 
The ${this.name} mission will be launched by a ${this.rocket.name} rocket, and 
deliver a ${this.payload.name} to ${this.destination.name}. 
    `); 
  } 
}  </pre>
<ol start="5">
<li>Create a class named <kbd>Destination</kbd>. Create a constructor that assigns a <kbd>name</kbd> argument to an instance variable:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Destination { 
  constructor (name) { 
    this.name = name; 
  } 
}  </pre>
<ol start="6">
<li>Create a class named <kbd>Payload</kbd>. Create a constructor that assigns a <kbd>name</kbd> argument to an instance variable:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Payload { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="7">
<li>Create a class named <kbd>Rocket</kbd>. Create a constructor that assigns a <kbd>name</kbd> argument to an instance variable:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class Rocket { 
  constructor (name) { 
    this.name = name; 
  } 
} </pre>
<ol start="8">
<li>Create a <kbd>MissionBuilder</kbd> class that defines setters for the mission's <kbd>name</kbd>, <kbd>payload</kbd>, and <kbd>rocket</kbd><strong> </strong>properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionBuilder { 
  setMissionName (name) { 
    this.missionName = name; 
    return this; 
  } 
 
  setDestination (destination) { 
    this.destination = destination; 
    return this; 
  } 
 
  setPayload (payload) { 
    this.payload = payload; 
    return this; 
  } 
 
  setRocket (rocket) { 
    this.rocket = rocket; 
    return this; 
  } 
}  </pre>
<ol start="9">
<li>Add a <kbd>build</kbd> function that assembles all of these properties:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
class MissionBuilder { 
  build () { 
    const mission = new Mission(this.missionName); 
    mission.rocket = this.rocket; 
    mission.destination = this.destination; 
    mission.payload = this.payload; 
    return mission; 
  } 
} </pre>
<ol start="10">
<li>Create a <kbd>MarsMissionFactory</kbd> object that takes <kbd>name</kbd> and <kbd>rocket</kbd> arguments, and uses <kbd>MissionBuilder</kbd> to assemble a new mission:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
 
const MarsMissionFactory = { 
  create (name, rocket) { 
    return new MissionBuilder() 
      .setMissionName(name) 
      .setDestination(new Destination('Martian Surface')) 
      .setPayload(new Payload('Mars Rover')) 
      .setRocket(rocket) 
      .build() 
  } 
} </pre>
<ol start="11">
<li>Create a <kbd>main</kbd> function that creates and describes a few instances of Mars missions:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
export function main() { 
  // build an describe a mission 
  MarsMissionFactory 
    .create('Curiosity', new Rocket('Atlas V')) 
    .describe(); 
  MarsMissionFactory 
    .create('Spirit', new Rocket('Delta II')) 
    .describe(); 
} </pre>
<ol start="12">
<li>Start your Python web server and open the following link in your browser: <br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>Your output should appear as follows:
<div><img src="img/f672f48e-2e12-4880-a393-09b6c0b82330.png"/></div>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p><kbd>MarsMissionFactory</kbd> receives the values for the <kbd>name</kbd> and <kbd>rocket</kbd> properties of <kbd>mission</kbd>, then supplies the remaining values to a builder instance. This narrows the properties required to make a new <kbd>mission</kbd>, while still using the builder interface.</p>
<p>This method of combining rather than modifying patterns is preferable in many use cases. Like more established library code, better-known patterns have better-defined contracts and more predictable behavior than custom ones. Their familiarity makes them easier for a newcomer to understand.</p>


            

            
        
    </body></html>