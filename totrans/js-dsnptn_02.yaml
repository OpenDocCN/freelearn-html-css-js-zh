- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Creational Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript design patterns are techniques that allow us to write more robust,
    scalable, and extensible applications in JavaScript. JavaScript is a very popular
    programming language, in part due to its place as a way to deliver interactive
    functionality on web pages. The other reason for its popularity is JavaScript’s
    lightweight, dynamic, multi-paradigm nature, which means that design patterns
    from other ecosystems can be adapted to take advantage of JavaScript’s strengths.
    JavaScript’s specific strengths and weaknesses can also inform new patterns specific
    to the language and the contexts in which it’s used.
  prefs: []
  type: TYPE_NORMAL
- en: Creational design patterns give structure to object creation, which enables
    the development of systems and applications where different modules, classes,
    and objects don’t need to know how to create instances of each other. The design
    patterns most relevant to JavaScript – the prototype, singleton, and factory patterns
    – will be explored, as well as situations where they’re helpful and how to implement
    them in an idiomatic fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive definition of creational design patterns and definitions for
    the prototype, singleton, and factory patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple implementations of the prototype pattern and its use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An implementation of the singleton design pattern, eager and lazy initialization,
    use cases for singleton, and what a singleton pattern in modern JavaScript looks
    like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement the factory pattern using classes, a modern JavaScript alternative,
    and use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to identify when a creational design
    pattern is useful and make an informed decision on which of its multiple implementations
    to use, ranging from a more idiomatic JavaScript form to a classical form.
  prefs: []
  type: TYPE_NORMAL
- en: What are creational design patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creational design patterns handle object creation. They allow a consumer to
    create object instances without knowing the details of how to instantiate the
    object. Since, in object-oriented languages, instantiation of objects is limited
    to a class’s constructor, allowing object instances to be created without calling
    the constructor is useful to reduce noise and tight coupling between the consumer
    and the class being instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, there’s ambiguity when we discuss “object creation,” since JavaScript’s
    multi-paradigm nature means we can create objects without a class or a constructor.
    For example, in JavaScript this is an object creation using an object literal
    – `const config = { forceUpdate: true` `}`. In fact, modern idiomatic JavaScript
    tends to lean more toward procedural and function paradigms than object orientation.
    This means that creational design patterns may have to be adapted to be fully
    useful in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, creational design patterns are useful in object-oriented JavaScript,
    since they hide instantiation details from consumers, which keeps coupling low,
    thereby allowing better module separation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll encounter our first creational design pattern – the
    prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the prototype pattern in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with a definition of the prototype pattern first.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype design pattern allows us to create an instance based on another
    existing instance (our prototype).
  prefs: []
  type: TYPE_NORMAL
- en: In more formal terms, a `prototype` class exposes a `clone()` method. Consuming
    code, instead of calling `new SomeClass`, will call `new` `SomeClassPrototype(someClassInstance).clone()`.
    This method call will return a `new SomeClass` instance with all the values copied
    from `someClassInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s imagine a scenario where we’re building a chessboard. There are two key
    types of squares – white and black. In addition to this information, each square
    contains information such as its row, file, and which piece sits atop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `BoardSquare` class constructor might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A set of useful methods on `BoardSquare` might be `occupySquare` and `clearSquare`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiating `BoardSquare` is quite cumbersome, due to all its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the repetition of arguments being passed to `new BoardSquare`, which will
    cause issues if we want to change all board squares to black. We would need to
    change the parameter passed to each call of `BoardSquare` is one by one for each
    `new BoardSquare` call. This can be quite error-prone; all it takes is one hard-to-find
    mistake in the `color` value to cause a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing our instantiation logic using a classical prototype looks as follows.
    We need a `BoardSquarePrototype` class; its constructor takes a `prototype` property,
    which it stores on the instance. `BoardSquarePrototype` exposes a `clone()` method
    that takes no arguments and returns a `BoardSquare` instance, with all the properties
    of `prototype` copied onto it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `BoardSquarePrototype` requires the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want an instance of **BoardSquare** to initialize – in this case,
    with **''white''**. It will then be passed as the **prototype** property during
    the **BoardSquarePrototype** constructor call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can then use **whiteSquarePrototype** with **.clone()** to create our copies
    of **whiteSquare**. Note that **color** is copied over but each call to **clone()**
    returns a new instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Per the assertions in the code, the cloned instances contain the same value
    for `color` but are different instances of the `Square` object.
  prefs: []
  type: TYPE_NORMAL
- en: A use case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate what it would take to change from a white square to a black square,
    let’s look at some sample code where `''white''` is not referenced in the variable
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we would only have to change the `color` value passed to
    `BoardSquare` to change the color of all the instances cloned from the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The prototype pattern is useful in situations where a “template” for the object
    instances is useful. It’s a good pattern to create a “default object” but with
    custom values. It allows faster and easier changes, since they are implemented
    once on the template object but are applied to all `clone()`-ed instances.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing robustness to change in the prototype’s instance variables with modern
    JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are improvements we can make to our prototype implementation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The first is in the `clone()` method. To make our prototype class robust to
    changes in the prototype’s constructor/instance variables, we should avoid copying
    the properties one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we add a new `startingPiece` parameter that the `BoardSquare`
    constructor takes and sets the `piece` instance variable to, our current implementation
    of `BoardSquarePrototype` will fail to copy it, since it only copies `color`,
    `row`, and `file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference for **Object.assign**: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we amend our `BoardSquarePrototype` class to use `Object.assign(new BoardSquare(),
    this.prototype)`, it will copy all the enumerable properties of `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The prototype pattern without classes in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, JavaScript has a prototype concept deeply embedded into
    the language. In fact, classes were introduced much later into the ECMAScript
    standard, with ECMAScript 6, which was released in 2015 (for reference, ECMAScript
    1 was published in 1997).
  prefs: []
  type: TYPE_NORMAL
- en: This is why a lot of JavaScript completely forgoes the use of classes. The JavaScript
    “object prototype” can be used to make objects inherit methods and variables from
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to clone objects is by using the `Object.create` to clone objects with
    their methods. This relies on the JavaScript prototype system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One subtlety here is that `Object.create` does not actually copy anything;
    it simply creates a new object and sets its prototype to `square`. This means
    that if properties are not found on `otherSquare`, they’re accessed on `square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A further note on the JavaScript prototype, and its existence before classes
    were part of JavaScript, is that subclassing in JavaScript is another syntax for
    setting an object’s prototype. Have a look at the following `extends` example.
    `BlackSquare extends Square` sets the `prototype.__proto__` property of `BlackSquare`
    to `Square.prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to implement the prototype pattern with a prototype
    class that exposes a `clone()` method, which code situations the prototype patterns
    can help with, and how to further improve our prototype implementation with modern
    JavaScript features. We also covered the JavaScript “prototype,” why it exists,
    and its relationship with the prototype design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the chapter, we’ll look at another creational design pattern,
    the singleton design pattern, with some implementation approaches in JavaScript
    and its use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern with eager and lazy initialization in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let’s define the singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern allows an object to be instantiated only once, exposes
    this single instance to consumers, and controls the instantiation of the single
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton is another way of getting access to an object instance without
    using a constructor, although it’s necessary for the object to be designed as
    a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A classic example of a singleton is a logger. It’s rarely necessary (and often,
    it’s a problem) to instantiate multiple loggers in an application. Having a singleton
    means the initialization site is controlled, and the logger configuration will
    be consistent across the application – for example, the log level won’t change
    depending on where in the application we call the logger from.
  prefs: []
  type: TYPE_NORMAL
- en: A simple logger looks something as follows, with a constructor taking `logLevel`
    and `transport`, and an `isLevelEnabled` private method, which allows us to drop
    logs that the logger is not configured to keep (for example, when the level is
    `warn` we drop `info` messages). The logger finally implements the `info`, `warn`,
    and `error` methods, which behave as previously described; they only call the
    relevant `transport` method if the level is “enabled” (i.e., “above” what the
    configured log level is).
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible `logLevel` values that power `isLevelEnabled` are stored as a
    static field on `Logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make `Logger` a singleton, we need to implement a `getInstance`
    static method that returns a cached instance. In order to do, this we’ll use a
    static `loggerInstance` on `Logger`. `getInstance` will check whether `Logger.loggerInstance`
    exists and return it if it does; otherwise, it will create a new `Logger` instance,
    set that as `loggerInstance`, and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this in another module is as simple as calling `Logger.getInstance()`.
    All `getInstance` calls will return the same instance of `Logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We’ve implemented a singleton with “lazy” initialization. The initialization
    occurs when the first `getInstance` call is made. In the next section, we’ll see
    how we might extend our code to have an “eager” initialization of `loggerInstance`,
    where `loggerInstance` will be initialized when the `Logger` code is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring only one singleton instance is constructed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A characteristic of a singleton is the “single instance” concept. We want to
    “force” consumers to use the `getInstance` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we can check for the existence of `loggerInstance` when
    the contructor is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where we call `getInstance` (and, therefore, `Logger.loggerInstance`
    is populated), the constructor will now throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is useful to ensure that consumers don’t instantiate their own
    Logger and they use `getInstance` instead. All consumers using `getInstance` means
    the configuration to set up the logger is encapsulated by the `Logger` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s still a gap in the implementation, as constructing `new Logger()` before
    any `getInstance()` calls will succeed, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In multithreaded languages, our implementation would also have a potential race
    condition – multiple consumers calling `Logger.getInstance()` concurrently could
    cause multiple instances to exist. However, since popular JavaScript runtimes
    are single-threaded, we won’t have to worry about such a race condition – `getInstance`
    is a “synchronous” method, so multiple calls to it would be interpreted one after
    the other. For reference, Node.js, Deno, and the mainstream browsers Chrome, Safari,
    Edge, and Firefox provide a single-threaded JavaScript runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton with eager initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eager initialization can be useful to ensure that the singleton is ready for
    use and features, such as disabling the constructor when an instance exists, work
    for all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can eager-initialize by setting `Logger.loggerInstance` in the `Logger`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This approach has the downside of the constructor performing a global state
    mutation, which isn’t ideal from a “single responsibility principle” standpoint;
    the constructor now has a side-effect of sorts (mutating global state) beyond
    its responsibility to set up an object instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to eager-initialize is by running `Logger.getInstance()`
    in the logger’s module; it’s useful to pair it with an `export` `default` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding exports added, there are now two ways to access a logger
    instance. The first is to import `Logger` by name and call `Logger.getInstance()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to use the logger is by importing the default export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Any code now importing `Logger` will get a pre-determined singleton instance
    of the logger.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A singleton shines when there should only be one instance of an object in an
    application – for example, a logger that shouldn’t be set up/torn down on every
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Since the singleton class controls how it gets instantiated, it’s also a good
    fit for objects that are tricky to configure (again, a logger, a metrics exporter,
    and an API client are good examples). The instantiation is completely encapsulated
    if, like in our example, we “disable” the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a performance benefit to constraining the application to a single instance
    of an object in terms of memory footprint.
  prefs: []
  type: TYPE_NORMAL
- en: The major drawbacks of singletons are an effect of their reliance on global
    state (in our example, the static `loggerInstance`). It’s hard to test a singleton,
    especially in a case where the constructor is “disabled” (like in our example),
    since our tests will want to always have a single instance of the singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons can also be considered “global state” to some extent, which comes
    with all its drawbacks. Global state can sometimes be a sign of poor design, and
    updating/consuming global state is error-prone (e.g., if a consumer is reading
    state but it is then updated and not read again).
  prefs: []
  type: TYPE_NORMAL
- en: Improvements with the “class singleton” pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our singleton logger implementation, it’s possible to modify the internal
    state of the singleton from outside of it. This is nothing specific to our singleton;
    it’s the nature of JavaScript. By default, its fields and methods are public.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is a bigger issue in our singleton scenario, since a consumer
    could reset `loggerInstance` using a statement such as `Logger.loggerInstance
    = null` or `delete` `Logger.loggerInstance`. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to stop consumers from modifying the `loggerInstance` static field,
    we can make it a private field. Private fields in JavaScript are part of the ECMAScript
    2023 specification (the 13th ECMAScript edition).
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a private field, we use the `#` prefix for the field name – in this
    case, `loggerInstance` becomes `#loggerInstance`. The `isLevelEnabled` method
    becomes `#isLevelEnabled`, and we also declare `logLevel` and `transport` as `#logLevel`
    and `#``transport`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not possible to delete `loggerInstace` or set it to `null`, since attempting
    to access `Logger.#loggerInstance` is a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Another useful technique is to disallow modification of fields on an object.
    In order to disallow modification, we can use `Object.freeze` to freeze the instance
    once it’s created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when someone attempts to change a field on the `Logger` instance, they’ll
    get `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now refactored our singleton implementation to disallow external modifications
    to it by using private fields and `Object.freeze`. Next, we’ll see how to use
    **EcmaScript** (**ES**) modules to deliver singleton functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A singleton without class fields using ES module behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript module system has the following caching behavior – if a module
    is loaded, any further imports of the module’s exports will be cached instances
    of exports.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it’s possible to create a singleton as follows in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Multiple imports of the default export will result in only one existing instance
    of the `MySingleton` object. Furthermore, if we don’t export the class, then the
    constructor doesn’t need to be “protected.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For our logger, this means we could implement an eager-initialized singleton
    in JavaScript without any of the heavy-handed guarding of the constructor or even
    a `getInstance` method. Note the use of `logLevel` and `isLevelEnabled` as a public
    instance property and a public method, respectively (since it might be useful
    to have access to them from a consumer). In the meantime, `#transport` remains
    private, and we’ve dropped `loggerInstance` and `getInstance`. We’ve kept `Object.freeze()`,
    which means that even though `logLevel` is readable from a consumer, it’s not
    available to modify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the chapter, we learned how to implement the singleton pattern
    with a class that exposes a `getInstance()` method, as well as the difference
    between the eager and lazy initialization of a singleton. We’ve covered some JavaScript
    features, such as private class fields and `Object.freeze`, which can be useful
    when implementing the singleton pattern. Finally, we explored how JavaScript/ECMAScript
    modules have singleton-like behavior and can be relied upon to provide this behavior
    for a class instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore the final creational design pattern covered
    in this chapter – the factory design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar fashion to the discussion about the JavaScript “prototype” versus
    the prototype creational design pattern, “factory” refers to related but different
    concepts when it comes to general program design discussions and design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'A “factory,” in the general programming sense, is an object that’s built with
    the goal of creating other objects. This is hinted at by the name that refers
    to a facility that processes items from one shape into another (or from one type
    of item to another). This factory denomination means that the output of a function
    or method is a new object. In JavaScript, this means that something as simple
    as a function that returns an object literal is a factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This definition of a factory is useful, but this section of the chapter is about
    the factory design pattern, which does fit into this overall “factory” definition.
  prefs: []
  type: TYPE_NORMAL
- en: The factory or factory method design pattern solves a class inheritance problem.
    A base or superclass is extended (the extended class is a subclass). The base
    class’s role is to provide orchestration for the methods implemented in the subclasses,
    as we want the subclasses to control which other objects to populate an instance
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A factory example is as follows. We have a `Building` base class that implements
    a `generateBuilding()` method. For now, it’s going to create a top floor using
    the `makeTopFloor` instance method. In the base class (`Building`), `makeTopFloor`
    is implemented, mainly because JavaScript doesn’t provide a way to define abstract
    methods. The `makeTopFloor` implementation throws an error because subclasses
    should override it; `makeTopFloor` is the “factory method” in this case. It’s
    how the base class defers the instantiation of objects to the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to implement a single-story house, we would extend `Building`
    and override `makeTopFloor`; in this instance, `topFloor` will have `level: 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When we instantiate `House`, which is a subclass of `Building`, we have access
    to the `generateBuilding` method; when called, it sets `topFloor` correctly (to
    `{ level:` `1 }`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to create a different type of building that has a very different
    top floor, we can still extend `Building`; we simply override `makeTopFloor` to
    return a different floor. In the case of a skyscraper, we want the top floor to
    be very high, so we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined our `SkyScraper`, which is a subclass of `Building`, we can
    instantiate it and call `generateBuilding`. As in the preceding `House` case,
    the `generateBuilding` method will use `SkyScraper`’s `makeTopFloor` method to
    populate the `topFloor` instance property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The “factory method” in this case is `makeTopFloor`. The `makeTopFloor` method
    is “not implemented” in the base class, in the sense that it’s implemented in
    a manner that forces subclasses that wish to use `generateBuilding` to define
    a `makeTopFloor` override.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `makeTopFloor` in our examples returned object literals, as mentioned
    earlier in the chapter; this is a feature of JavaScript not available in all object-oriented
    languages (JavaScript is multi-paradigm). We’ll see different ways to implement
    the factory pattern later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The benefit of using a factory method is that we can create a wide variety of
    subclasses without modifying the base class. This is the “open/closed principle”
    at play – the `Building` class in our example is “open” to extension (i.e., can
    be subclassed to infinity for different types of buildings) but “closed” to modification
    (i.e., we don’t need to make changes in `Building` for every subclass, only when
    we want to add new behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: Improvements with modern JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key improvement we can make with JavaScript is enabled by its first-class
    support for functions and the ability to define objects using literals (instead
    of classes being instantiated).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript having “first-class functions” means functions are like any other
    type – they can be passed as parameters, set as variable values, and returned
    from other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more idiomatic implementation of this pattern would probably involve a `generateBuilding`
    standalone function instead of a `Building` class. `generateBuilding` would take
    `makeTopFloor` either as a parameter or take an object parameter with a `makeTopFloor`
    key. The output of `generateBuilding` would be an object created using an object
    literal, which takes the output of `makeTopFloor()` and sets it as the value to
    a `topFloor` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In order to create our house and skyscraper, we would call `generateBuilding`
    with the relevant `makeTopFloor` functions. In the case of the house, we want
    a top floor that is on level 1; in the case of the skyscraper, we want a top floor
    on level 125.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: One reason why using functions directly works better in JavaScript is that we
    didn’t have to implement a “throw an error to remind consumers to override me”
    `makeFloor` method that we had with the `Building` class.
  prefs: []
  type: TYPE_NORMAL
- en: In languages other than JavaScript that have support for abstract methods, this
    pattern is more useful and natural to implement than in JavaScript, where we have
    first-class functions.
  prefs: []
  type: TYPE_NORMAL
- en: You also have to bear in mind that the original versions of JavaScript/ECMAScript
    didn’t include a `class` construct.
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of the chapter, we learned what the factory method pattern
    is and how it contrasts with the factory programming concept. We then implemented
    a class-based factory pattern scenario as well as a more idiomatic JavaScript
    version. Interspersed through this section, we covered the use cases, benefits,
    and drawbacks of the factory method pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we discussed how creational design patterns allow us
    to build more extensible and maintainable systems in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype design pattern shines when creating many instances of objects
    that contain the same values. This design pattern allows us to change the initial
    values of the prototype and affect all the cloned instances.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton design pattern is useful to completely hide initialization details
    of a class that should really only be instantiated once. We saw how JavaScript’s
    module system generates singletons and how that can be leveraged to simplify a
    singleton implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method design pattern allows a base class to defer the implementation
    of some object creations to subclasses. We saw which features would make this
    pattern more useful in JavaScript, as well as an alternative idiomatic JavaScript
    approach with factory functions.
  prefs: []
  type: TYPE_NORMAL
- en: We can now leverage creational design patterns to build classes that are composable
    and can be evolved as necessary to cover different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create objects efficiently with creational design patterns,
    in the next chapter, we’ll cover how to use structural design patterns to organize
    relationships between different objects and classes.
  prefs: []
  type: TYPE_NORMAL
