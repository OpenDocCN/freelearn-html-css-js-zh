- en: 'Chapter 7. The App: Showing Ratings via Canvas'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have seen ways to lay out and draw elements in our enterprise
    application using CSS and images. If we need to create complex visualizations
    and/or animations based on dynamic data, the use of `DOM` objects becomes intricate
    and its manipulation slow. For that reason, the `canvas` tag was introduced in
    the HTML5 specification. The `canvas` tag defines a rectangular area where we
    can draw anything using its JavaScript API. This chapter introduces the `canvas`
    tag for data visualizations and simple animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Charting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything depends on the context (2D and 3D contexts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Charting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current implementation of MovieNow uses a subset of the data provided by
    the `movielistings.php` web service. Some of the data not used includes ratings
    from MetaCritic, EditorBoost, and general user ratings (`avgMetaCriticRating`,
    `editorBoost`, and `avgUserRating` respectively). MovieNow users would love to
    see that information in the form of bar charts. For that, we will use `canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is possible to render this information using `DOM` objects it can
    be slower and more restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add a new interaction to show the ratings chart with a click. Let
    us remove our current on-click interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The new interaction will include two buttons: one to show the movie description
    and the other to show the ratings chart. Inside the `img` folder, you will find
    an `options.png` image sprite. It has icons for both information and charts.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing our code](img/5689_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `details-button` and `charting-button` classes, let us add some styles
    to `styles.css`. Each button will be 45 px x 45 px, using absolute positioning
    to place it in the bottom-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the details button to the left-hand side of the charting button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the correct image for the charting button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `displayShowtimes` function of `movienow.geolocation.js`, we will need
    to change the HTML structure to add our new buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also place our chart container with its canvas. At this point, we are
    going to use the HTML5 custom data attribute – `data-feed`, to store information
    about ratings in each canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML5 custom data attributes allow the embedding of metadata on HTML elements.
    Your attribute name must have a prefix, `data-`, followed at least by one character
    string; in our case we use the word `feed` so our attribute name is `data-feed`.
    It does not allow uppercase and the value is a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it together, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some spacing before the charting elements in `styles.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To hide and show the `charting` and `description` areas, we are going to use
    the `desc` class. If the `desc` class is applied to the `li` tag, we will hide
    `charting` and show `description`. Otherwise, we hide `description` and show `charting`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to `movienow.geolocation.js`, we define methods to show chart (`showCharts`)
    and show details (`showDetails`). For `showCharts`, we will use jQuery''s chaining
    capability. `$(event.target)` if the button is clicked, so we go two levels up
    using `parent()`; remove the `desc` class from the current object (`li`), add
    the `open` class, and find the first `canvas` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jQuery allows for the concatenation of method calls applying each method to
    the result of the previous one. This improves performance but sometimes goes against
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a function called `charts` to draw each canvas, this
    function will take the `canvas` object as a parameter. Our final method should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the same train of thought to show details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add event handlers for a click to open and close:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create `movienow.charts.js` and add the `charts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `charts` method calls the `drawBarChart` method. We use this
    construct to change the drawing method later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to include `movienow.charts.js` in `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Everything depends on the context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Canvas provides APIs to draw in two or three dimensions, where supported. Canvas
    2D has wider support than Canvas 3D; the latter is generally not supported on
    any mobile browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define what API to use by getting the canvas context. Let us suppose
    that `chart` is our `canvas` object. If you want to draw in two dimensions, you
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the 2D API to draw, for example, a red square defining its
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw the shape as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the 3D API, the use is far more complicated. First, it is still not fully
    supported as some browsers recognize `webgl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While others use `experimental-webgl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `webgl` specification is still in development. Use of WebGL
    requires knowledge of computer graphics and concepts like cameras, lights, textures,
    materials, mapping, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 2D context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to create a horizontal bar chart to show MetaCritic, EditorBoost,
    and user ratings. The idea is to use green, yellow, and red to indicate how high
    or low the rating is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, we can see our chart design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![2D context](img/5689_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on the `movienow.charts.js` structure we have established, let us write
    the `drawBarChart` method. As we do not want to redraw our canvas every time we
    call this method, we are going to use the `painted` class as a flag to determine
    if the canvas is already drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then save `canvas` as a jQuery object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can verify if it has the `painted` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our conditional, we split `data-feed` that contains rating information
    in order to iterate over it, building a bar for each rating category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then get the 2D context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: An overview of the Canvas 2D Drawing API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us go over the most useful methods of Canvas in a 2D context:'
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The methods used for setting styles in Canvas 2D API are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.strokeStyle(value)`: This receives a string containing a CSS color
    of the stroke; if no parameter is passed, it returns the current style for stroking
    shapes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.fillStyle(value)`: It receives a string with the CSS color for filling
    shapes; if no parameter is passed, it returns the current fill style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`strokeStyle` and `fillStyle` can receive `CanvasGradient` or `CanvasPattern`
    as a parameter, allowing you to draw gradients and patterns. For more information
    about how to create gradients and patterns, you can check out the canvas 2D API
    specification: [http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`context.lineWidth(value)`: It defines the width of the lines using pixels.
    It only accepts positive values; if no value is passed, it acts like a getter
    and returns the current line width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.lineCap(value)`: It sets the style of the end (or cap) of lines. Possible
    values are `butt`, `round`, and `square`. If no value is passed, it returns the
    current line cap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.lineJoin(value)`: It sets the style of the connection of lines. Possible
    values are `bevel`, `round`, and `miter`. If no value is passed, it returns the
    current line joint style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font styles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The methods used for setting font styles in canvas 2D API are explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.font(value)`: It defines the style of the fonts using a string with
    CSS syntax. If no value is passed, it returns the current font style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.fillText``(text,x,y[, maxWidth])`: It draws text. It receives a `text`
    string with the information to draw `x` and `y` coordinates in pixels and `maxWidth`
    that defines the maximum size in pixels for the container''s width, which is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.strokeText(text,x,y[, maxWidth])`: It behaves like `fillText` but
    draws only the stroke of the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing simple shapes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The methods used for drawing simple shapes in the Canvas 2D API are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.clearRect(x, y, w, h)`: It defines a rectangle with coordinates `x`
    and `y`, width `w`, and height `h`, and clears all pixels inside the area defined.
    Values are in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.fillRect(x, y, w, h)`: It draws a rectangle with coordinates `x` and
    `y`, width `w` and height `h` using the predefined `fillStyle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.strokeRect``(x, y, w, h)`: It draws the stroke of a rectangle with
    coordinates `x` and `y`, width `w`, and height `h` using the predefined `strokeStyle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing complex shapes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create more complex shapes, Canvas 2D API allows you to define paths and
    subpaths. A path is a collection of subpaths while a subpath is a list of points
    connected by lines or curves.
  prefs: []
  type: TYPE_NORMAL
- en: The current project does not require complex shapes, but it is good to know
    the methods that allow you to draw curves and lines making it possible to draw
    any figure.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be aware that our context always contains a current path, and it
    is not possible to have more than one.
  prefs: []
  type: TYPE_NORMAL
- en: '`co``ntext.beginPath()`: It resets the current path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.closePath()`: It closes the current path and creates a new one with
    a first point that uses the same coordinates as the last subpath point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.moveTo(x, y)`: It creates a new subpath with coordinates `x` and `y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.lineTo(x, y)`: It creates a line between the current point and a new
    point with coordinates `x` and `y` adding the latest to the current subpath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.quadraticCurveTo(cpx, cpy, x, y)`: It creates a quadratic curve between
    the current point and a new point with coordinates `x` and `y` using a control
    point, defined with coordinates `cpx` on the x axis, and `cpy` on the y axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)`: It creates a Bezier
    curve between the current point and a new point with coordinates `x` and `y` using
    two control points cp1(`cp1x`, `cp1y`) and cp2 (`cp2x`, `cp2y`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.arcTo(x1, y2, x2, y2, radius)`: It connects the current point with
    a new point with coordinates `x1` and `y1`, then creates a new point with coordinates
    `x2` and `y2` joined with the previous one by an arc with radius defined by the
    parameter `radius`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.rect(x, y, w, h)`: It adds a rectangle with coordinates `x` and `y`,
    width `w`, and height `h` to the list of subpaths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.fill()`: It applies the current fill style to fill the subpaths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.stroke()`: It applies the current stroke style to create stroke lines
    for the subpaths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.isPointInPath(x, y)`: It returns `true` if the point defined by coordinates
    `x` and `y` is in the current path and `false` otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are other methods that can be useful for more complicated drawings and
    animations; you can look at the canvas specification here: [http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let us define the text style for that context and a variable to count
    the current bar index (in case not all movies have the same number of rating categories):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over rating categories and get the current value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We draw (only if the value is bigger than `0`) first a gray bar (`#292929`)
    that defines a width of `290` px and a height of `26` px. Using the syntax `fillRect(x,y,width,height)`,
    notice that we use `36` to give 10 pixels of separation between bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The canvas origin is positioned in the upper-left corner of the canvas DOM object.
    Positive values go below origin and to the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then draw our color bar. For that, we define a `getChartColor` method
    that returns different colors depending on the rating value using green for higher
    ones, yellow for mediums, and red for lowest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using our `getChartColor` method and current rating value `val`, we can set
    the shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the rating category title, we change fill style to a transparent white,
    and then we use `fillText` with syntax `fillText(text, x,y)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we can use hexadecimal, RGB, or RGBA colors to define `fillStyle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we write a validation such that if there is no data we show a message
    that says **No Data Available**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrap it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do not need to clear our canvas area because we are not
    animating or changing information after our first draw. However, if we do require
    redrawing, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canvas 2D context provides a procedural approach to drawing—creating bitmap
    images. If we need to use vectorial graphics instead of bitmaps it's possible
    to use Scalable Vector Graphics (SVG), which provides a declarative approach using
    XML. To know more about SVG you can research here [http://www.w3.org/Graphics/SVG/](http://www.w3.org/Graphics/SVG/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Canvas 2D API is supported in all modern browsers including Internet Explorer
    since Version 9.0\. As we have shown in [Chapter 2](ch02.html "Chapter 2. HTML5
    Starter Kit: Useful Tools"), *HTML Starter Kit: Useful Tools*, it is still possible
    to support previous versions of Internet Explorer using ExplorerCanvas [http://code.google.com/p/explorercanvas/downloads/list](http://code.google.com/p/explorercanvas/downloads/list).'
  prefs: []
  type: TYPE_NORMAL
- en: 3D context – WebGL and experimental WebGL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we saw a two-dimensional implementation of our chart solution, let
    us try to create a three-dimensional version and add some animations to make things
    more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we think of user experience, a general rule is that less is more. That
    means that keeping things simple should make our application more usable. In this
    case, we are going to add animations that are not needed for the sake of learning
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: In our case we are going to draw bar charts using WebGL and rating categories
    titles using DOM objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final implementation should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D context – WebGL and experimental WebGL](img/5689_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entering a tridimensional world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebGL specification is based on the OpenGL for Embedded Systems 2.0 (or
    OpenGL ES) specification. Unless you are familiar with OpenGL and you need to
    work with low level manipulations, it is suggested that you use a library that
    abstracts the use of it. Among the advantages are more readable code, less development
    time, and better extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we selected `Three.js`, a JavaScript library that simplifies the
    use of WebGL using common metaphors used in other tridimensional libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider project objectives when you have to decide which library to use, and
    think in terms of future improvements and limitations of that library.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Three.js` is a JavaScript library that abstracts 3D manipulation allowing
    us to use simple metaphors like scenes, cameras, objects, and so on. You can download
    `Three.js` from [https://github.com/mrdoob/three.js/ a](https://github.com/mrdoob/three.js/
    a)nd read its documentation at [http://mrdoob.github.com/three.js/docs/50/](http://mrdoob.github.com/three.js/docs/50/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go over some basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Scene
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The scene is the virtual environment where we can insert objects. Every object
    must be in a `scene` in order to visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: You can create scenes using `scene = new THREE.Scene()` and add an object to
    it using `scene.add(object)`.
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A camera indicates which section of our scene to visualize. Think of it as a
    movie; if we want to record a specific place, we need to point our camera at it.
    `Three.js` provides an abstract `Camera` class for cameras, two basic cameras,
    and two extra implementations of cameras.
  prefs: []
  type: TYPE_NORMAL
- en: '`OrthographicCamera` defines an orthographic projection defined by a cube formed
    for the constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`left` – defines left plane using a float that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right` – defines right plane using a float that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top` – defines top plane using a float that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom` – defines bottom plane using a float that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`near` – defines the plane nearest to the camera or near plane using a float
    that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`far` – defines the plane farthest to the camera or far plane using a float
    that indicates position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PerspectiveCamera` defines a perspective projection using field of view, aspect
    ratio, near and far values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`fov` – defines the angle that indicates the field of view represented by a
    float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aspect` – defines the camera aspect ratio defined by a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`near` – as in `OrtographicCamera` defines near plane using a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`far` – as in `OrtographicCamera` defines far plane using a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A visual representation of a perspective camera is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Camera](img/5689EN_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Material
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Materials define a set of properties that describe the appearance of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Texture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Textures define appearance of objects using images (or procedural patterns).
  prefs: []
  type: TYPE_NORMAL
- en: Mesh
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Meshes are part of the list of objects than can be added to the scene. You can
    assign geometries and materials to a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Geometry is a representation of an object that can be assigned to a mesh. In
    our case, we are going to use `CubeGeometry` to define our bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will download and include `three.js` in our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add a new parameter to our `charts` class to specify which rendering
    we would like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We define as default **3DChart** in the `showCharts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us write our 3D drawing method `draw3DChart`. As our previous two-dimensional
    drawing method, this one takes our `canvas` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we verify if Canvas has the `painted` class to avoid initializing
    it again. We can then verify WebGL support and, if it is not supported, we render
    our 2D charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `webGLSupport`, we get our ratings data, `canvas` dimensions, and a
    variable to store time for animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a `three.js` renderer using WebGL, which contains our new canvas,
    and set its dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We assign the `data` attribute and the `painted` class to the renderer DOM element
    (`canvas`) and replace our old `canvas` with this one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We implement our camera using field of vision (FOV) 45 degree, aspect ratio
    based on canvas dimensions, near of 1 and far of 1000, and we position our camera
    to 700 on the z axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define our scene, a `bars` array to store meshes to be rendered later,
    an `index` as in our 2D example and a `labels` string to store the DOM object
    that will show the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over rating categories as our previous example. We get a color for
    our current value using `getChartColor` and replace `#` with `0x` because of the
    color notation used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As we will have six faces for each bar, we will have six different materials.
    Each one will have its own color, so we define arrays for `colors` and `materials`.
    We fill our title information in the `labels` string too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we can have more than one material assigned. In this case, we use
    the following to define a transparent fill for our solids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following draws the edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `bar` is defined as a mesh with geometry. Use the following `CubeGeometry`
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new `CubeGeometry` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Animating our geometries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are going to animate the growing of the bars, so we will scale them on the
    x axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Meshes have their reference points at their centers, so positioning the mesh
    and setting the overdraw to manage transparent geometries, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the bar to our scene and to our array with the final width that we should
    have at the end of our animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So our iteration should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have not rendered anything. We can remedy that by setting
    the `labels` string and appending it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We set a `three` structure that we will use for our rendering, and then we
    call our render method – `animate3DChart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `draw3DChart` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finishing up
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We create a `window.requestAnimFrame` method to abstract the definition of
    our `timeout` for animation. Notice that we use `1000/60`. This indicates 60 frames
    per second (`FPS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `animate3DChart` method, we simply define a variable to stop our animation
    (`isReady`), and scale and position each `bar` stopping when we reach 100 percent
    scale (in this case `1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to rotate each bar with no stop, we can define some values to control
    the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can then substitute `isReady=(three.bars[i].object.scale.x>=1)` with `three.bars[i].object.rotation.x
    += angleChange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify rotation on the x axis, we can add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The canvas WebGL API is not fully supported by all browsers. You can use the
    3D API for Firefox 4.0+, Chrome, Opera, and Safari since Version 5.1 (on OSX or
    higher, but not Safari for iOS devices or Safari for Windows).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebGL is disabled by default on Safari. To enable WebGL on Safari, click on
    the **Safari** menu and select **Preferences**, then click on the **Advanced**
    tab. At the bottom, check the **Show Develop menu in menu bar** checkbox. Open
    the **Develop** menu and then select **Enable WebGL**.
  prefs: []
  type: TYPE_NORMAL
- en: For Internet Explorer, you can enable WebGL support by installing the Chrome
    Frame plugin [http://www.google.com/chromeframe](http://www.google.com/chromeframe).
    Google Chrome Frame replaces the rendering mechanism of Internet Explorer with
    Google Chrome's versions of the WebKit layout engine and V8 JavaScript engine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the canvas specification is still in development, we can apply its
    APIs for innumerable use cases in our enterprise applications. Charts, scientific
    visualization, diagrams, and animated wizards are merely the tip of the iceberg.
    As developers, we should always give ample consideration to fallbacks or alternative
    solutions in the event something is not supported to ensure proper cross-platform
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover drag-and-drop capabilities and event delegation
    using HTML5.
  prefs: []
  type: TYPE_NORMAL
