- en: 'Chapter 7. The App: Showing Ratings via Canvas'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 应用程序：通过Canvas显示评分
- en: Until now, we have seen ways to lay out and draw elements in our enterprise
    application using CSS and images. If we need to create complex visualizations
    and/or animations based on dynamic data, the use of `DOM` objects becomes intricate
    and its manipulation slow. For that reason, the `canvas` tag was introduced in
    the HTML5 specification. The `canvas` tag defines a rectangular area where we
    can draw anything using its JavaScript API. This chapter introduces the `canvas`
    tag for data visualizations and simple animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了使用CSS和图像在我们的企业应用程序中布局和绘制元素的方法。如果我们需要根据动态数据创建复杂可视化或动画，使用`DOM`对象会变得复杂，其操作也会变慢。因此，HTML5规范中引入了`canvas`标签。`canvas`标签定义了一个矩形区域，我们可以使用其JavaScript
    API在其中绘制任何内容。本章介绍了`canvas`标签用于数据可视化和简单动画。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Charting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制图表
- en: Preparing our code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备我们的代码
- en: Everything depends on the context (2D and 3D contexts)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都取决于上下文（2D和3D上下文）
- en: Charting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制图表
- en: Our current implementation of MovieNow uses a subset of the data provided by
    the `movielistings.php` web service. Some of the data not used includes ratings
    from MetaCritic, EditorBoost, and general user ratings (`avgMetaCriticRating`,
    `editorBoost`, and `avgUserRating` respectively). MovieNow users would love to
    see that information in the form of bar charts. For that, we will use `canvas`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的MovieNow实现使用了`movielistings.php`网络服务提供的数据子集。一些未使用的数据包括来自MetaCritic、EditorBoost和一般用户评分（分别对应`avgMetaCriticRating`、`editorBoost`和`avgUserRating`）。MovieNow用户会喜欢以条形图的形式看到这些信息。为此，我们将使用`canvas`。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Although it is possible to render this information using `DOM` objects it can
    be slower and more restrictive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`DOM`对象渲染此信息，但这可能较慢且更具限制性。
- en: Preparing our code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的代码
- en: 'We need to add a new interaction to show the ratings chart with a click. Let
    us remove our current on-click interaction:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个新的交互来通过点击显示评分图表。让我们移除我们当前的点击交互：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new interaction will include two buttons: one to show the movie description
    and the other to show the ratings chart. Inside the `img` folder, you will find
    an `options.png` image sprite. It has icons for both information and charts.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 新交互将包括两个按钮：一个用于显示电影描述，另一个用于显示评分图表。在`img`文件夹中，您将找到一个`options.png`图像精灵。它包含信息和图表的图标。
- en: '![Preparing our code](img/5689_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![准备我们的代码](img/5689_07_01.jpg)'
- en: 'Using the `details-button` and `charting-button` classes, let us add some styles
    to `styles.css`. Each button will be 45 px x 45 px, using absolute positioning
    to place it in the bottom-right corner:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`details-button`和`charting-button`类，让我们在`styles.css`中添加一些样式。每个按钮将是45 px x
    45 px，使用绝对定位将其放置在右下角：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Place the details button to the left-hand side of the charting button:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将详细信息按钮放置在图表按钮的左侧：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the correct image for the charting button:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设置图表按钮的正确图像：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `displayShowtimes` function of `movienow.geolocation.js`, we will need
    to change the HTML structure to add our new buttons:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`movienow.geolocation.js`的`displayShowtimes`函数中，我们需要更改HTML结构以添加我们的新按钮：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also place our chart container with its canvas. At this point, we are
    going to use the HTML5 custom data attribute – `data-feed`, to store information
    about ratings in each canvas:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将放置我们的图表容器及其canvas。在此阶段，我们将使用HTML5自定义数据属性`data-feed`来存储每个canvas中的评分信息：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: HTML5 custom data attributes allow the embedding of metadata on HTML elements.
    Your attribute name must have a prefix, `data-`, followed at least by one character
    string; in our case we use the word `feed` so our attribute name is `data-feed`.
    It does not allow uppercase and the value is a string.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5自定义数据属性允许在HTML元素上嵌入元数据。您的属性名必须以`data-`前缀开头，后跟至少一个字符字符串；在我们的情况下，我们使用单词`feed`，因此我们的属性名是`data-feed`。它不允许使用大写字母，并且值是一个字符串。
- en: 'Putting it together, we get:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们组合起来，我们得到：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add some spacing before the charting elements in `styles.css`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`styles.css`中图表元素之前添加一些间距：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To hide and show the `charting` and `description` areas, we are going to use
    the `desc` class. If the `desc` class is applied to the `li` tag, we will hide
    `charting` and show `description`. Otherwise, we hide `description` and show `charting`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏和显示`charting`和`description`区域，我们将使用`desc`类。如果`desc`类应用于`li`标签，我们将隐藏`charting`并显示`description`。否则，我们将隐藏`description`并显示`charting`：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Back to `movienow.geolocation.js`, we define methods to show chart (`showCharts`)
    and show details (`showDetails`). For `showCharts`, we will use jQuery''s chaining
    capability. `$(event.target)` if the button is clicked, so we go two levels up
    using `parent()`; remove the `desc` class from the current object (`li`), add
    the `open` class, and find the first `canvas` element:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `movienow.geolocation.js`，我们定义显示图表（`showCharts`）和显示细节（`showDetails`）的方法。对于
    `showCharts`，我们将使用 jQuery 的链式调用功能。`$(event.target)` 如果按钮被点击，那么我们使用 `parent()`
    向上移动两级；从当前对象（`li`）中移除 `desc` 类，添加 `open` 类，并找到第一个 `canvas` 元素：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: jQuery allows for the concatenation of method calls applying each method to
    the result of the previous one. This improves performance but sometimes goes against
    readability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 允许方法调用的连接，将每个方法应用于前一个方法的结果。这提高了性能，但有时会牺牲可读性。
- en: 'We are going to create a function called `charts` to draw each canvas, this
    function will take the `canvas` object as a parameter. Our final method should
    look like the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `charts` 的函数来绘制每个画布，这个函数将 `canvas` 对象作为参数。我们的最终方法应该如下所示：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Apply the same train of thought to show details:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用相同的思路来展示细节：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add event handlers for a click to open and close:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加点击事件处理程序以打开和关闭：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we create `movienow.charts.js` and add the `charts` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建 `movienow.charts.js` 并添加 `charts` 方法：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the `charts` method calls the `drawBarChart` method. We use this
    construct to change the drawing method later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`charts` 方法调用了 `drawBarChart` 方法。我们使用这个结构来更改后续的绘图方法。
- en: 'Remember to include `movienow.charts.js` in `index.html`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在 `index.html` 中包含 `movienow.charts.js`：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Everything depends on the context
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都取决于上下文
- en: Canvas provides APIs to draw in two or three dimensions, where supported. Canvas
    2D has wider support than Canvas 3D; the latter is generally not supported on
    any mobile browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 提供了在二维或三维空间中绘图的 API，在支持的情况下。Canvas 2D 的支持范围比 Canvas 3D 更广；后者通常在任何移动浏览器上都不被支持。
- en: 'You can define what API to use by getting the canvas context. Let us suppose
    that `chart` is our `canvas` object. If you want to draw in two dimensions, you
    can use:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过获取画布上下文来定义要使用的 API。假设 `chart` 是我们的 `canvas` 对象。如果你想绘制二维图形，你可以使用：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you can use the 2D API to draw, for example, a red square defining its
    color:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 2D API 来绘制，例如，一个红色的正方形，定义其颜色：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Draw the shape as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式绘制形状：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the 3D API, the use is far more complicated. First, it is still not fully
    supported as some browsers recognize `webgl`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 3D API，使用要复杂得多。首先，它仍然没有得到完全支持，因为一些浏览器识别 `webgl`：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While others use `experimental-webgl`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他人使用 `experimental-webgl`：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is because the `webgl` specification is still in development. Use of WebGL
    requires knowledge of computer graphics and concepts like cameras, lights, textures,
    materials, mapping, and so on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `webgl` 规范仍在开发中。使用 WebGL 需要了解计算机图形和诸如相机、灯光、纹理、材质、映射等概念。
- en: 2D context
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D 上下文
- en: We are going to create a horizontal bar chart to show MetaCritic, EditorBoost,
    and user ratings. The idea is to use green, yellow, and red to indicate how high
    or low the rating is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个水平条形图来显示 MetaCritic、EditorBoost 和用户评分。想法是使用绿色、黄色和红色来表示评分的高低。
- en: 'In the following image, we can see our chart design:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以看到我们的图表设计：
- en: '![2D context](img/5689_07_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![2D 上下文](img/5689_07_02.jpg)'
- en: Based on the `movienow.charts.js` structure we have established, let us write
    the `drawBarChart` method. As we do not want to redraw our canvas every time we
    call this method, we are going to use the `painted` class as a flag to determine
    if the canvas is already drawn.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们已建立的 `movienow.charts.js` 结构，让我们编写 `drawBarChart` 方法。由于我们不希望在每次调用此方法时都重新绘制我们的画布，我们将使用
    `painted` 类作为标志来决定画布是否已经绘制。
- en: 'We can then save `canvas` as a jQuery object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将 `canvas` 保存为 jQuery 对象：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we can verify if it has the `painted` class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以验证它是否有 `painted` 类：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside our conditional, we split `data-feed` that contains rating information
    in order to iterate over it, building a bar for each rating category:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的条件语句中，我们将包含评分信息的 `data-feed` 分割，以便遍历它，为每个评分类别构建一个条形图：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then get the 2D context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取 2D 上下文：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An overview of the Canvas 2D Drawing API
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Canvas 2D 绘图 API 概览
- en: 'Let us go over the most useful methods of Canvas in a 2D context:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 Canvas 在二维上下文中最有用的方法：
- en: Styles
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 样式
- en: 'The methods used for setting styles in Canvas 2D API are explained as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 2D API 中设置样式的使用方法如下所述：
- en: '`context.strokeStyle(value)`: This receives a string containing a CSS color
    of the stroke; if no parameter is passed, it returns the current style for stroking
    shapes.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.strokeStyle(value)`: 这接收一个包含 CSS 颜色的字符串，用于描边；如果没有传递参数，则返回当前描边样式。'
- en: '`context.fillStyle(value)`: It receives a string with the CSS color for filling
    shapes; if no parameter is passed, it returns the current fill style.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.fillStyle(value)`: 它接收一个包含用于填充形状的 CSS 颜色的字符串；如果没有传递参数，则返回当前填充样式。'
- en: Tip
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`strokeStyle` and `fillStyle` can receive `CanvasGradient` or `CanvasPattern`
    as a parameter, allowing you to draw gradients and patterns. For more information
    about how to create gradients and patterns, you can check out the canvas 2D API
    specification: [http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html).'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`strokeStyle` 和 `fillStyle` 可以接收 `CanvasGradient` 或 `CanvasPattern` 作为参数，允许您绘制渐变和图案。有关如何创建渐变和图案的更多信息，您可以查看
    canvas 2D API 规范：[http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html)。'
- en: '`context.lineWidth(value)`: It defines the width of the lines using pixels.
    It only accepts positive values; if no value is passed, it acts like a getter
    and returns the current line width.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.lineWidth(value)`: 它使用像素定义线的宽度。它只接受正值；如果没有传递值，则充当获取器并返回当前线宽。'
- en: '`context.lineCap(value)`: It sets the style of the end (or cap) of lines. Possible
    values are `butt`, `round`, and `square`. If no value is passed, it returns the
    current line cap.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.lineCap(value)`: 它设置线的端点（或帽）的样式。可能的值是 `butt`、`round` 和 `square`。如果没有传递值，则返回当前的线帽样式。'
- en: '`context.lineJoin(value)`: It sets the style of the connection of lines. Possible
    values are `bevel`, `round`, and `miter`. If no value is passed, it returns the
    current line joint style.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.lineJoin(value)`: 它设置线的连接样式。可能的值是 `bevel`、`round` 和 `miter`。如果没有传递值，则返回当前的线连接样式。'
- en: Font styles
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字体样式
- en: 'The methods used for setting font styles in canvas 2D API are explained as
    follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 canvas 2D API 中设置字体样式的使用方法如下：
- en: '`context.font(value)`: It defines the style of the fonts using a string with
    CSS syntax. If no value is passed, it returns the current font style.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.font(value)`: 它使用 CSS 语法字符串定义字体样式。如果没有传递值，则返回当前的字体样式。'
- en: '`context.fillText``(text,x,y[, maxWidth])`: It draws text. It receives a `text`
    string with the information to draw `x` and `y` coordinates in pixels and `maxWidth`
    that defines the maximum size in pixels for the container''s width, which is optional.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.fillText``(text,x,y[, maxWidth])`: 绘制文本。它接收一个包含要绘制信息的 `text` 字符串，以像素为单位指定
    `x` 和 `y` 坐标，以及定义容器宽度最大像素值的 `maxWidth`，后者是可选的。'
- en: '`context.strokeText(text,x,y[, maxWidth])`: It behaves like `fillText` but
    draws only the stroke of the text.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.strokeText(text,x,y[, maxWidth])`: 它的行为类似于 `fillText`，但只绘制文本的描边。'
- en: Drawing simple shapes
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制简单形状
- en: 'The methods used for drawing simple shapes in the Canvas 2D API are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Canvas 2D API 中绘制简单形状使用的方法如下：
- en: '`context.clearRect(x, y, w, h)`: It defines a rectangle with coordinates `x`
    and `y`, width `w`, and height `h`, and clears all pixels inside the area defined.
    Values are in pixels.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.clearRect(x, y, w, h)`: 它定义一个坐标为 `x` 和 `y`、宽度为 `w` 和高度为 `h` 的矩形，并清除该区域内定义的所有像素。值以像素为单位。'
- en: '`context.fillRect(x, y, w, h)`: It draws a rectangle with coordinates `x` and
    `y`, width `w` and height `h` using the predefined `fillStyle`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.fillRect(x, y, w, h)`: 使用预定义的 `fillStyle` 绘制坐标为 `x` 和 `y`、宽度为 `w`
    和高度为 `h` 的矩形。'
- en: '`context.strokeRect``(x, y, w, h)`: It draws the stroke of a rectangle with
    coordinates `x` and `y`, width `w`, and height `h` using the predefined `strokeStyle`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.strokeRect``(x, y, w, h)`: 使用预定义的 `strokeStyle` 绘制坐标为 `x` 和 `y`、宽度为
    `w` 和高度为 `h` 的矩形描边。'
- en: Drawing complex shapes
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制复杂形状
- en: To create more complex shapes, Canvas 2D API allows you to define paths and
    subpaths. A path is a collection of subpaths while a subpath is a list of points
    connected by lines or curves.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更复杂的形状，Canvas 2D API 允许您定义路径和子路径。路径是一系列子路径的集合，而子路径是由线条或曲线连接的点列表。
- en: The current project does not require complex shapes, but it is good to know
    the methods that allow you to draw curves and lines making it possible to draw
    any figure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当前项目不需要复杂的形状，但了解允许您绘制曲线和线条的方法，使其能够绘制任何图形是很好的。
- en: We need to be aware that our context always contains a current path, and it
    is not possible to have more than one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到我们的上下文始终包含一个当前路径，并且不可能有多个。
- en: '`co``ntext.beginPath()`: It resets the current path'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co``ntext.beginPath()`: 它重置当前路径'
- en: '`context.closePath()`: It closes the current path and creates a new one with
    a first point that uses the same coordinates as the last subpath point'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.closePath()`: 它关闭当前路径并创建一个新的路径，其第一个点使用与最后一个子路径点相同的坐标'
- en: '`context.moveTo(x, y)`: It creates a new subpath with coordinates `x` and `y`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.moveTo(x, y)`: 它使用坐标 `x` 和 `y` 创建一个新的子路径'
- en: '`context.lineTo(x, y)`: It creates a line between the current point and a new
    point with coordinates `x` and `y` adding the latest to the current subpath'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.lineTo(x, y)`: 它在当前点和坐标为 `x` 和 `y` 的新点之间创建一条线，并将最新点添加到当前子路径中'
- en: '`context.quadraticCurveTo(cpx, cpy, x, y)`: It creates a quadratic curve between
    the current point and a new point with coordinates `x` and `y` using a control
    point, defined with coordinates `cpx` on the x axis, and `cpy` on the y axis'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.quadraticCurveTo(cpx, cpy, x, y)`: 它使用一个控制点创建一个二次曲线，该控制点在 x 轴上的坐标为
    `cpx`，在 y 轴上的坐标为 `cpy`，在当前点和坐标为 `x` 和 `y` 的新点之间'
- en: '`context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)`: It creates a Bezier
    curve between the current point and a new point with coordinates `x` and `y` using
    two control points cp1(`cp1x`, `cp1y`) and cp2 (`cp2x`, `cp2y`)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)`: 它使用两个控制点 cp1(`cp1x`,
    `cp1y`) 和 cp2 (`cp2x`, `cp2y`) 在当前点和坐标为 `x` 和 `y` 的新点之间创建一个贝塞尔曲线'
- en: '`context.arcTo(x1, y2, x2, y2, radius)`: It connects the current point with
    a new point with coordinates `x1` and `y1`, then creates a new point with coordinates
    `x2` and `y2` joined with the previous one by an arc with radius defined by the
    parameter `radius`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.arcTo(x1, y2, x2, y2, radius)`: 它通过一个半径由参数 `radius` 定义的弧将当前点与坐标为 `x1`
    和 `y1` 的新点连接起来，然后通过一个弧与之前的一个点连接，坐标为 `x2` 和 `y2`'
- en: '`context.rect(x, y, w, h)`: It adds a rectangle with coordinates `x` and `y`,
    width `w`, and height `h` to the list of subpaths'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.rect(x, y, w, h)`: 它将一个坐标为 `x` 和 `y`、宽度为 `w` 和高度为 `h` 的矩形添加到子路径列表中'
- en: '`context.fill()`: It applies the current fill style to fill the subpaths'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.fill()`: 它将当前填充样式应用于填充子路径'
- en: '`context.stroke()`: It applies the current stroke style to create stroke lines
    for the subpaths'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.stroke()`: 它将当前描边样式应用于创建子路径的描边线'
- en: '`context.isPointInPath(x, y)`: It returns `true` if the point defined by coordinates
    `x` and `y` is in the current path and `false` otherwise'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.isPointInPath(x, y)`: 如果由坐标 `x` 和 `y` 定义的点在当前路径中，则返回 `true`，否则返回 `false`'
- en: 'There are other methods that can be useful for more complicated drawings and
    animations; you can look at the canvas specification here: [http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法对于更复杂的绘制和动画可能很有用；您可以在以下位置查看画布规范：[http://dev.w3.org/2006/canvas-api/canvas-2d-api.html](http://dev.w3.org/2006/canvas-api/canvas-2d-api.html)。
- en: Drawing charts
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制图表
- en: 'First, let us define the text style for that context and a variable to count
    the current bar index (in case not all movies have the same number of rating categories):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为该上下文定义文本样式以及一个用于计算当前条索引的变量（以防不是所有电影都有相同数量的评分类别）：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Iterate over rating categories and get the current value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历评分类别并获取当前值：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We draw (only if the value is bigger than `0`) first a gray bar (`#292929`)
    that defines a width of `290` px and a height of `26` px. Using the syntax `fillRect(x,y,width,height)`,
    notice that we use `36` to give 10 pixels of separation between bars:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先绘制一个灰色条（`#292929`），它定义了宽度为 `290` 像素和高度为 `26` 像素的宽度。使用 `fillRect(x,y,width,height)`
    语法，注意我们使用 `36` 来在条之间提供 10 像素的间隔：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The canvas origin is positioned in the upper-left corner of the canvas DOM object.
    Positive values go below origin and to the right-hand side.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 画布原点位于画布 DOM 对象的左上角。正值位于原点下方并向右。
- en: 'We can then draw our color bar. For that, we define a `getChartColor` method
    that returns different colors depending on the rating value using green for higher
    ones, yellow for mediums, and red for lowest:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以绘制我们的颜色条。为此，我们定义一个 `getChartColor` 方法，该方法根据评分值返回不同的颜色，对于较高的评分使用绿色，对于中等评分使用黄色，对于最低评分使用红色：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using our `getChartColor` method and current rating value `val`, we can set
    the shape:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `getChartColor` 方法以及当前的评分值 `val`，我们可以设置形状：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To draw the rating category title, we change fill style to a transparent white,
    and then we use `fillText` with syntax `fillText(text, x,y)`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制评分类别标题，我们更改填充样式为半透明的白色，然后使用 `fillText` 语法 `fillText(text, x,y)`：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that we can use hexadecimal, RGB, or RGBA colors to define `fillStyle`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用十六进制、RGB 或 RGBA 颜色来定义 `fillStyle`。
- en: 'Finally, we write a validation such that if there is no data we show a message
    that says **No Data Available**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编写一个验证，如果没有数据，则显示一条消息，说明**无可用数据**：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Wrap it all together:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we do not need to clear our canvas area because we are not
    animating or changing information after our first draw. However, if we do require
    redrawing, we can use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要清除我们的画布区域，因为我们第一次绘制后没有进行动画或更改信息。然而，如果我们确实需要重新绘制，我们可以使用：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Canvas 2D context provides a procedural approach to drawing—creating bitmap
    images. If we need to use vectorial graphics instead of bitmaps it's possible
    to use Scalable Vector Graphics (SVG), which provides a declarative approach using
    XML. To know more about SVG you can research here [http://www.w3.org/Graphics/SVG/](http://www.w3.org/Graphics/SVG/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 2D上下文提供了一种过程式绘图方法——创建位图图像。如果我们需要使用矢量图形而不是位图，可以使用可缩放矢量图形（SVG），它使用XML提供了一种声明式方法。要了解更多关于SVG的信息，你可以在这里研究
    [http://www.w3.org/Graphics/SVG/](http://www.w3.org/Graphics/SVG/)。
- en: 'The Canvas 2D API is supported in all modern browsers including Internet Explorer
    since Version 9.0\. As we have shown in [Chapter 2](ch02.html "Chapter 2. HTML5
    Starter Kit: Useful Tools"), *HTML Starter Kit: Useful Tools*, it is still possible
    to support previous versions of Internet Explorer using ExplorerCanvas [http://code.google.com/p/explorercanvas/downloads/list](http://code.google.com/p/explorercanvas/downloads/list).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 2D API自9.0版本以来被所有现代浏览器支持，包括Internet Explorer。正如我们在[第2章](ch02.html "第2章。HTML5入门套件：实用工具")中所示，*HTML入门套件：实用工具*，仍然可以使用ExplorerCanvas
    [http://code.google.com/p/explorercanvas/downloads/list](http://code.google.com/p/explorercanvas/downloads/list)来支持之前的Internet
    Explorer版本。
- en: 3D context – WebGL and experimental WebGL
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3D上下文 – WebGL和实验性WebGL
- en: Now that we saw a two-dimensional implementation of our chart solution, let
    us try to create a three-dimensional version and add some animations to make things
    more interesting.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们图表解决方案的二维实现，让我们尝试创建一个三维版本，并添加一些动画使事物更加有趣。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we think of user experience, a general rule is that less is more. That
    means that keeping things simple should make our application more usable. In this
    case, we are going to add animations that are not needed for the sake of learning
    how to do it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑用户体验时，一个普遍的规则是“少即是多”。这意味着保持简单可以使我们的应用程序更易于使用。在这种情况下，我们将添加不必要的动画，以便学习如何进行操作。
- en: In our case we are going to draw bar charts using WebGL and rating categories
    titles using DOM objects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将使用WebGL绘制条形图，并使用DOM对象绘制评分类别标题。
- en: 'The final implementation should look like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终实现应该看起来像以下这样：
- en: '![3D context – WebGL and experimental WebGL](img/5689_07_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![3D上下文 – WebGL和实验性WebGL](img/5689_07_03.jpg)'
- en: Entering a tridimensional world
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进入三维世界
- en: The WebGL specification is based on the OpenGL for Embedded Systems 2.0 (or
    OpenGL ES) specification. Unless you are familiar with OpenGL and you need to
    work with low level manipulations, it is suggested that you use a library that
    abstracts the use of it. Among the advantages are more readable code, less development
    time, and better extensibility.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL规范基于嵌入式系统OpenGL 2.0（或OpenGL ES）规范。除非你熟悉OpenGL并且需要执行低级操作，否则建议你使用抽象其使用的库。其优点包括代码可读性更高、开发时间更短、更好的可扩展性。
- en: In our case, we selected `Three.js`, a JavaScript library that simplifies the
    use of WebGL using common metaphors used in other tridimensional libraries.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们选择了`Three.js`，这是一个JavaScript库，它通过使用其他三维库中常用的隐喻简化了WebGL的使用。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Consider project objectives when you have to decide which library to use, and
    think in terms of future improvements and limitations of that library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须决定使用哪个库时，请考虑项目目标，并考虑该库未来的改进和限制。
- en: Three.js
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Three.js
- en: '`Three.js` is a JavaScript library that abstracts 3D manipulation allowing
    us to use simple metaphors like scenes, cameras, objects, and so on. You can download
    `Three.js` from [https://github.com/mrdoob/three.js/ a](https://github.com/mrdoob/three.js/
    a)nd read its documentation at [http://mrdoob.github.com/three.js/docs/50/](http://mrdoob.github.com/three.js/docs/50/).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Three.js`是一个JavaScript库，它抽象了3D操作，允许我们使用场景、相机、对象等简单的隐喻。您可以从[https://github.com/mrdoob/three.js/](https://github.com/mrdoob/three.js/)下载`Three.js`，并在[http://mrdoob.github.com/three.js/docs/50/](http://mrdoob.github.com/three.js/docs/50/)阅读其文档。'
- en: 'Let us go over some basic concepts:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些基本概念：
- en: Scene
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 场景
- en: The scene is the virtual environment where we can insert objects. Every object
    must be in a `scene` in order to visualize it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是我们可以插入对象的虚拟环境。每个对象都必须在一个`scene`中才能可视化。
- en: You can create scenes using `scene = new THREE.Scene()` and add an object to
    it using `scene.add(object)`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`scene = new THREE.Scene()`创建场景，并使用`scene.add(object)`向其中添加对象。
- en: Camera
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相机
- en: A camera indicates which section of our scene to visualize. Think of it as a
    movie; if we want to record a specific place, we need to point our camera at it.
    `Three.js` provides an abstract `Camera` class for cameras, two basic cameras,
    and two extra implementations of cameras.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相机指示要可视化的场景部分。将其视为一部电影；如果我们想记录特定的地方，我们需要将相机指向它。`Three.js`提供了一个抽象的`Camera`类用于相机，两个基本相机和两个额外的相机实现。
- en: '`OrthographicCamera` defines an orthographic projection defined by a cube formed
    for the constructor parameters:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrthographicCamera` 使用构造函数参数定义的立方体定义正交投影'
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`left` – defines left plane using a float that indicates position'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left` – 使用表示位置的浮点数定义左平面'
- en: '`right` – defines right plane using a float that indicates position'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right` – 使用表示位置的浮点数定义右平面'
- en: '`top` – defines top plane using a float that indicates position'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top` – 使用表示位置的浮点数定义顶平面'
- en: '`bottom` – defines bottom plane using a float that indicates position'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom` – 使用表示位置的浮点数定义底平面'
- en: '`near` – defines the plane nearest to the camera or near plane using a float
    that indicates position'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near` – 使用表示位置的浮点数定义最近的平面或近平面'
- en: '`far` – defines the plane farthest to the camera or far plane using a float
    that indicates position'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`far` – 使用表示位置的浮点数定义最远的平面或远平面'
- en: '`PerspectiveCamera` defines a perspective projection using field of view, aspect
    ratio, near and far values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`PerspectiveCamera` 使用视场、宽高比、近点和远点值定义透视投影：'
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`fov` – defines the angle that indicates the field of view represented by a
    float'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fov` – 使用浮点数定义表示视场的角度'
- en: '`aspect` – defines the camera aspect ratio defined by a float'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect` – 定义由浮点数指定的相机宽高比'
- en: '`near` – as in `OrtographicCamera` defines near plane using a float'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near` – 在`OrthographicCamera`中，使用浮点数定义近平面'
- en: '`far` – as in `OrtographicCamera` defines far plane using a float'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`far` – 在`OrthographicCamera`中，使用浮点数定义远平面'
- en: 'A visual representation of a perspective camera is shown in the following figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图中展示了透视相机的视觉表示：
- en: '![Camera](img/5689EN_07_04.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![相机](img/5689EN_07_04.jpg)'
- en: Material
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 材质
- en: Materials define a set of properties that describe the appearance of objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 材质定义了一组描述对象外观的属性。
- en: Texture
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 纹理
- en: Textures define appearance of objects using images (or procedural patterns).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理使用图像（或程序性图案）定义对象的外观。
- en: Mesh
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网格
- en: Meshes are part of the list of objects than can be added to the scene. You can
    assign geometries and materials to a mesh.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 网格是可添加到场景的对象列表的一部分。您可以将几何体和材质分配给网格。
- en: Geometry
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 几何体
- en: Geometry is a representation of an object that can be assigned to a mesh. In
    our case, we are going to use `CubeGeometry` to define our bars.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 几何体是可分配给网格的对象的表示。在我们的例子中，我们将使用`CubeGeometry`来定义我们的条形。
- en: 'To start, we will download and include `three.js` in our `index.html` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将下载并将`three.js`包含在我们的`index.html`文件中：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then add a new parameter to our `charts` class to specify which rendering
    we would like to use:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后向我们的`charts`类添加一个新参数来指定我们想要使用的渲染：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We define as default **3DChart** in the `showCharts` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`showCharts`方法中将默认定义为**3DChart**：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let us write our 3D drawing method `draw3DChart`. As our previous two-dimensional
    drawing method, this one takes our `canvas` as a parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写我们的3D绘图方法`draw3DChart`。像我们之前的二维绘图方法一样，这个方法将我们的`canvas`作为参数：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As before, we verify if Canvas has the `painted` class to avoid initializing
    it again. We can then verify WebGL support and, if it is not supported, we render
    our 2D charts:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们验证Canvas是否有`painted`类以避免再次初始化它。然后我们可以验证WebGL支持，如果不支持，我们渲染2D图表：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside `webGLSupport`, we get our ratings data, `canvas` dimensions, and a
    variable to store time for animation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`webGLSupport`内部，我们获取我们的评分数据、`canvas`尺寸和存储动画时间的变量：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we define a `three.js` renderer using WebGL, which contains our new canvas,
    and set its dimensions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用WebGL定义一个`three.js`渲染器，它包含我们的新画布，并设置其尺寸：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We assign the `data` attribute and the `painted` class to the renderer DOM element
    (`canvas`) and replace our old `canvas` with this one.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`data`属性和`painted`类分配给渲染器DOM元素（`canvas`），并用这个替换我们旧的`canvas`。
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We implement our camera using field of vision (FOV) 45 degree, aspect ratio
    based on canvas dimensions, near of 1 and far of 1000, and we position our camera
    to 700 on the z axis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用视场（FOV）45度、基于画布尺寸的宽高比、近点为1和远点为1000来实现我们的相机，并将相机定位在z轴上的700处。
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we define our scene, a `bars` array to store meshes to be rendered later,
    an `index` as in our 2D example and a `labels` string to store the DOM object
    that will show the titles:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义我们的场景，一个用于存储稍后要渲染的网格的`bars`数组，一个类似于我们2D示例中的`index`，以及一个用于存储将显示标题的DOM对象的`labels`字符串：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Iterate over rating categories as our previous example. We get a color for
    our current value using `getChartColor` and replace `#` with `0x` because of the
    color notation used:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们之前的示例迭代评分类别。我们使用`getChartColor`为我们当前的值获取一个颜色，并将`#`替换为`0x`，因为使用了颜色表示法：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we will have six faces for each bar, we will have six different materials.
    Each one will have its own color, so we define arrays for `colors` and `materials`.
    We fill our title information in the `labels` string too:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个条形将有六个面，我们将有六种不同的材质。每一种都将有自己的颜色，因此我们为`colors`和`materials`定义数组。我们还在`labels`字符串中填充我们的标题信息：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that we can have more than one material assigned. In this case, we use
    the following to define a transparent fill for our solids:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以分配多个材质。在这种情况下，我们使用以下方式为我们的实体定义透明填充：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following draws the edges:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下绘制了边缘：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Each `bar` is defined as a mesh with geometry. Use the following `CubeGeometry`
    syntax:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`bar`被定义为具有几何形状的网格。使用以下`CubeGeometry`语法：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This creates a new `CubeGeometry` object:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`CubeGeometry`对象：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Animating our geometries
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动画我们的几何形状
- en: We are going to animate the growing of the bars, so we will scale them on the
    x axis.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将动画条形的增长，所以我们将它们在x轴上缩放。
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Meshes have their reference points at their centers, so positioning the mesh
    and setting the overdraw to manage transparent geometries, we have:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的参考点位于其中心，因此定位网格并设置重绘以管理透明几何形状，我们有：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We add the bar to our scene and to our array with the final width that we should
    have at the end of our animation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将条形添加到我们的场景和我们的数组中，并设置最终宽度，这是动画结束时的宽度：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So our iteration should look as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的迭代应该看起来如下：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, we have not rendered anything. We can remedy that by setting
    the `labels` string and appending it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有渲染任何东西。我们可以通过设置`labels`字符串并附加它来纠正这一点：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We set a `three` structure that we will use for our rendering, and then we
    call our render method – `animate3DChart`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置一个`three`结构，我们将用它来进行渲染，然后调用我们的渲染方法`animate3DChart`：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Our `draw3DChart` method looks as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`draw3DChart`方法如下所示：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finishing up
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结束
- en: 'We create a `window.requestAnimFrame` method to abstract the definition of
    our `timeout` for animation. Notice that we use `1000/60`. This indicates 60 frames
    per second (`FPS`):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`window.requestAnimFrame`方法来抽象我们的动画`timeout`定义。注意，我们使用`1000/60`。这表示每秒60帧（`FPS`）：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the `animate3DChart` method, we simply define a variable to stop our animation
    (`isReady`), and scale and position each `bar` stopping when we reach 100 percent
    scale (in this case `1`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`animate3DChart`方法，我们简单地定义一个变量来停止我们的动画（`isReady`），并缩放和定位每个`bar`，直到我们达到100%的缩放（在这种情况下为`1`）：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we want to rotate each bar with no stop, we can define some values to control
    the animation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让每个条形无限旋转，我们可以定义一些值来控制动画：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can then substitute `isReady=(three.bars[i].object.scale.x>=1)` with `three.bars[i].object.rotation.x
    += angleChange`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`isReady=(three.bars[i].object.scale.x>=1)`替换为`three.bars[i].object.rotation.x
    += angleChange`。
- en: 'To modify rotation on the x axis, we can add the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改x轴上的旋转，我们可以添加以下内容：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The canvas WebGL API is not fully supported by all browsers. You can use the
    3D API for Firefox 4.0+, Chrome, Opera, and Safari since Version 5.1 (on OSX or
    higher, but not Safari for iOS devices or Safari for Windows).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL画布API并非所有浏览器都完全支持。您可以使用Firefox 4.0+、Chrome、Opera和从版本5.1开始（在OSX或更高版本上，但不是iOS设备上的Safari或Windows上的Safari）的3D
    API。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: WebGL is disabled by default on Safari. To enable WebGL on Safari, click on
    the **Safari** menu and select **Preferences**, then click on the **Advanced**
    tab. At the bottom, check the **Show Develop menu in menu bar** checkbox. Open
    the **Develop** menu and then select **Enable WebGL**.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL在Safari中默认禁用。要在Safari中启用WebGL，请点击**Safari**菜单并选择**偏好设置**，然后点击**高级**选项卡。在底部，勾选**在菜单栏中显示开发菜单**复选框。打开**开发**菜单，然后选择**启用WebGL**。
- en: For Internet Explorer, you can enable WebGL support by installing the Chrome
    Frame plugin [http://www.google.com/chromeframe](http://www.google.com/chromeframe).
    Google Chrome Frame replaces the rendering mechanism of Internet Explorer with
    Google Chrome's versions of the WebKit layout engine and V8 JavaScript engine.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Internet Explorer，您可以通过安装Chrome Frame插件[http://www.google.com/chromeframe](http://www.google.com/chromeframe)来启用WebGL支持。Google
    Chrome Frame用Google Chrome的WebKit布局引擎和V8 JavaScript引擎的版本替换了Internet Explorer的渲染机制。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Although the canvas specification is still in development, we can apply its
    APIs for innumerable use cases in our enterprise applications. Charts, scientific
    visualization, diagrams, and animated wizards are merely the tip of the iceberg.
    As developers, we should always give ample consideration to fallbacks or alternative
    solutions in the event something is not supported to ensure proper cross-platform
    compatibility.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管画布规范仍在开发中，我们仍然可以在我们的企业应用中应用其API，以应对无数的使用场景。图表、科学可视化、图表和动画向导只是冰山一角。作为开发者，我们应该始终充分考虑回退或替代方案，以防某些功能不受支持，以确保适当的跨平台兼容性。
- en: The next chapter will cover drag-and-drop capabilities and event delegation
    using HTML5.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍使用HTML5的拖放功能和事件委托。
