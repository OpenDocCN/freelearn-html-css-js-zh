- en: Running E2E Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You are just one step away from becoming a full stack application
    developer! For now, we will stop talking about Aurelia; you know the framework
    and have a high level of knowledge of how JavaScript works as a programming language.
    Now, it's time to expand our knowledge about full-stack application development.
    We have our FIFA WC 2018 application running on our localhost and have some unit
    testing implemented. Is it enough to ensure that it will work in a QA or production
    environment? Of course, no.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is very important, but it only ensures the correct functionality
    of one single service. How can we ensure that all our applications (database,
    backend, frontend, and any other external services) are working correctly as one
    single application? This is what we will learn in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Testing is one of the highly demanded skills for all developers nowadays. Why?
    It's because programming is no longer just writing code and to ensure that it
    works on your own PC, you need to create code that ensures this functionality
    and also be able to automate the testing process to create a continuous delivery
    pipeline.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide the testing phase into four different levels, and we will cover
    each one through this chapter. Look at the following image:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e592f9b9-20ca-4f76-aa30-cf8321f608a5.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: 'We can refer to these layers as basic tests. Once we have covered all three
    layers, we can commit and push our code. Is that all? No. We have more advanced
    testing layers that should be performed using tools completely external to our
    application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**System testing** ensures that all our business use cases are resolved and
    satisfied. It''s like black box testing where we don''t know how each method or
    operation is performed; we just care about the input and output. This kind of
    testing starts in the frontend layer, emulating common user operations and expecting
    some data already processed through the backend APIs and external services. You
    must know that system testing can be automated in your CI cycle.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance testing** is performed by real end users. They ensure that your
    system will support all user interactions, evaluating time, performance, and one
    very important aspect—your app''s user experience. Commonly, this test is performed
    by the product owner first in an external environment called **user acceptance
    testing** (**UAT**).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we can resume the testing phase in the following illustration:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67ec1984-69c6-49fd-88a1-0925b0185df7.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: 'We will cover each testing phase through this chapter. We''ve already reviewed
    the unit testing in the last section of Chapter 4, *Creating Components and Templates*,
    which is useful to ensure the functionality of a single component, but how can
    we evaluate the complete interaction between our components and other external
    services? It''s time to go one step ahead and learn about integration testing.
    But even one step ahead is not enough for us, so let''s go deeper and evaluate
    one very important but often ignored aspect of every web application: we can ensure
    our application functionality, but is it simple to use by our final users? UI
    testing will give us the answer. Finally, let''s add some cool documentation to
    each endpoint we are exposing to be consumed by some client, even if it''s web
    or mobile. We will show you how Swagger works and how it can generate a nice readable
    documentation about your API. The topics covered in this chapter are these:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API testing – Swagger
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not pass through this chapter; testing is a very important part of the application
    development life cycle. Ready? Go!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing – Multiple services, one application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have all our functionalities already tested. We know that our services work
    correctly but what about our database connection? What about our SSO? Can you
    confirm these services/dependencies work correctly?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration testing plays an important role in the application development
    cycle by verifying the correct behavior of the system. Let''s explore our current
    application architecture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/183fbeb4-5cc3-4ee3-a149-6b11ef57fec5.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Integration tests ensure the correct interaction across our different application
    layers, in this case, database connection, SSO service, and frontend application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should you do integration tests? Well, if it''s not clear yet, there are
    a few reasons to consider:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Easy integration with daily builds in your **Continuous Integration** (**CI**)
    cycle. Your progress will be testable at any time.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to test in dev/QA/UAT/Production environment. It's easy, just like running
    your application.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests run faster as compared to end-to-end tests.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to detect system-level issues. Communication between services, database
    connection, and so on.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's add some integration tests to our existing express application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Configuring applications for integration testing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only prerequisite you need is the Node runtime environment running correctly.
    In JavaScript, we have some tools to make integration tests, such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**SuperTest**: The best feature is its strong documentation; easy to understand
    and implement, you just need to write a few lines of code to start testing your
    application.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha**: A simple JavaScript test framework. It can be executed in the web
    browser or in your Node environment. Since Mocha is based on JavaScript, it can
    execute asynchronous tests and generate very useful reports.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use both tools together for our testing purposes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'With SuperTest, you gain advantages such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: You can simulate a multiple user interaction, storing different credentials
    (tokens) to switch between users.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't need to worry about delete or add mock data. SuperTest will perform
    the operations to clean or add data to your store.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most useful feature—all these tests can be automated and integrated in your
    CI pipeline.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SuperTest is a big help for productivity; also, it offers a natural way to write
    and test your code at the same time; it is very intuitive and human readable.
    Let’s go over how to quickly set it up for something like user retrieving data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Where can you run SuperTest tests? Basically, you can run them in any server
    you want. No matter whether you are deploying on local `dev` servers or cloud
    providers, SuperTests can be executed from any of them, but you must know something—SuperTest
    includes its own express server. This server should not be running all the time,
    but using some external tools like nodemon, you can automatically restart your
    server each time we have a change and need to test it. If you don't want to run
    all the tests, Mocha's only specifier is a nice solution too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download our dependencies:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Chai allows us to choose any of the following prefixes: `should`, `expect`,
    or `assert`. Just like other test tools, they are all available here too.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We already have our `server.js` file, so you won't need to add any code there.
    Yes, you don't need to run any server, and this is the most beautiful advantage
    of SuperTest!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that our test files should be separated from the application files. Next,
    create your `tests` file with the `touch tests.spec.js` command, and let''s add
    some code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's explain what the code is doing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We are importing our server, Chai and SuperTest. SuperTest includes its own `.expect()`,
    but we are using Chai’s syntax. The code sets a group of `API Tests` and creates
    one test to check whether the `/teams` endpoint returns 200 (OK) as status code.
    Note that the `done()` function is important to declare our asynchronous tests
    are complete. Of course, this is a very high-level test, and we can add more assertions
    such as evaluating the response's content and more. For example purposes, this
    is very simple to understand and know how SuperTest works.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see if it works. Run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should get this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure you have correctly configured the `test` command in the script section
    on `package.json` file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Mocking external dependencies
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, you can write some integration tests. Is it enough? Not yet. Let's think.
    We really need to connect to external services? What if they're down? Of course,
    our test will fail but not for some application error. To avoid this, we will
    use Mocks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Mocking is the technique used to simulate some object/service/component and
    return a predefined response when its called. We''ll not connect with real services,
    so we''ll be using `sinon.mock` to create a mock model for our Teams schema, and
    we''ll test the expected result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All okay at this point. Now, let's evaluate another very important aspect of
    testing, code coverage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that `sinon` is downloaded in your project and imported in your current
    test file to make the example work, same as any external model you may need. You
    can find more info about `sinon` at [http://sinonjs.org](http://sinonjs.org).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Calculating code coverage
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our integration test already written and running, we have one thing pending
    to do. It would be an awesome thing if we could see how our tests are doing with
    respect to our app in terms of test coverage.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add code coverage to the app!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Istanbul** is a very famous JavaScript code coverage tool that computes different
    metrics such as statement quality, lines of code, function use, and branch coverage
    with module loader hooks to analyze all our code and add coverage when running
    tests, giving us real-time information about our application. It supports all
    kinds of JavaScript coverage use cases, from unit tests to functional and browser
    tests. The best part about this is that it is scalable.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we just need to install Istanbul and `nyc` (this last one in the
    command line client for `istanbul`). We just do this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we modify our `package.json` file. This is to add test with coverage
    to our `script` object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, run the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should be able to see the coverage summary of your application in the console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Does our app meet our business requirements? UI testing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't be confused, we won't test frontend application functionality. This is
    already tested with our unit test, so what is really UI testing? Well, it is a
    very long discussion. We can have many test suites configured to be executed at
    any time, and this will ensure that our E2E meets the business requirements already
    programmed. What do we mean by this? Unit and integration testing cannot evaluate
    all areas of a complete application, specifically the areas related to workflow
    and usability. Basically, all our automated tests can only verify code that exists.
    They cannot evaluate functionality that is maybe missing or issues related to
    visual elements of our application and how easy our product is to use. This is
    the real value of GUI testing, which is performed from the perspective of a user
    instead of the practical point of view of the developer. By analyzing an application
    from a user’s perspective, GUI testing can provide enough information to the project
    team to decide whether the application is ready to deploy or we need to reorganize
    some features to accomplish the user needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: So, that being said, will I always will need a person who should be verifying
    a functionality manually? Yes and no. This theme is really hard to explain, because
    different points of view can be referenced and in some cases, contradicted. For
    these cases, we will focus on some very useful testing techniques in the next
    section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Scripted testing
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like its name, scripted testing based on prescripts elaborated by software
    testers to detect whether there are some functionalities not covered for the application
    at that moment. For example, a script doing a login, saving some data, and then
    retrieving it from another screen. The script defines the predefined data that
    the tester will use to evaluate each screen and the expected output. Then, the
    tester analyzes the results and reports any found defects to the application development
    team. Scripted testing can be performed manually by humans or can be supported
    by test automation through CI tools.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The advantage is that you can divide the work between your most experienced
    developers to write the scripts and the entry-level developers to run the script
    and analyze the data, giving maintenance and learning the business requirements.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage is that it's hard to maintain if your UI changes frequently.
    This kind of testing is highly coupled with your business code so if it changes,
    the entire test should change too.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Exploratory testing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this kind of testing, we won't use any automated script. It enforces the
    tester to use the application as a common user and evaluate aspects such as design,
    how easy our product is for the final users, how is the user experience, alternative
    workflows, and more. The tester may identify any failure regarding these aspects
    and provide valuable feedback to developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Since explanatory tests do not use scripts, there is still pre-planning. In
    real-life situations, commonly in session-based exploratory testing, the testers
    team sets goals for the planned tests and defines a time frame to perform exploratory
    testing in focused areas. All this information is introduced in a document called
    test-charter. Sessions and results of exploratory testing are documented in a
    report and reviewed in the daily meeting with the entire team.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The advantage is that testers have more time to focus on the actual testing,
    because the time to prepare test cases and look at boring documentation is reduced,
    becoming a constant challenge to find more issues and increase their business
    knowledge.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage is that this kind of test is not auto-executable and of course,
    cannot be repeated to be used as a regression test. Also, you will need testers
    with a deep understanding of your business requirements that most of the time
    are hard to find. In addition, in real-time scenarios, it may be impractical to
    try to cover an entire application with exploratory testing since we won't find
    enough testers with the required knowledge about the product.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: UX testing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In user experience testing, actual end users (or user representatives) evaluate
    an application for its ease of use, visual appearance, and ability to meet their
    needs. The users will explore all the applications in an isolated environment
    called UAT, which can be configured in a local server or some cloud provider.
    You must keep in mind that it does not matter where the product is deployed, it
    should represent the same conditions as your production environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Don’t confuse user experience testing (UX) with user acceptance testing (UAT).
    UAT is a testing level that verifies that a given application meets demanded requirements
    focusing only on business use cases. For example, in UAT, you can ensure that
    your Retrieve Teams button works correctly and returns the correct data well formatted.
    So, it's not enough? Of course no, because you don't know yet whether your button
    is well placed or whether it's difficult to find from the end user's perspective.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we understand how this kind of testing works, which one should
    we apply? All taken decisions regarding testing should target to maximize the
    value of the product for its final users, even by detecting bugs or unexpected
    features, and by ensuring functionality and usability. To achieve this goal, in
    real-time situations, we will need a combination of all different test techniques
    reviewed at this time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Planning our tests – Time for the truth
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning is a very important phase of any project, and this won't be an exception. It
    is important to have a test plan that identifies the resources available for testing
    and that prioritizes areas of the application to be tested before we start writing
    our cases. With this information, the testing team will be able to create test
    scenarios, test cases, and test scripts for scripted testing, documented in the
    test charter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the structure that our test plan should contain:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Defined dates for each test
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required testers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required resources such as servers, environments, tools, and cloud providers
    correctly configured to start testing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target application environments, such as different screen resolutions, mobile
    devices, and supported browsers
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User workflows/navigation to test
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing techniques to be used, including scripted testing, exploratory testing,
    and user experience testing
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goals for testing, including the acceptance criteria to determine if a test
    passes or fails
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, we can add some more sections according to our own needs:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/534f2510-9baf-4cf3-80e3-0cd8e5ab2b6d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Test plans can be text documents, excel tables, or a test management tool to
    develop the test plan to support analysis and reporting. There are many tools
    available, some of them to download into your private server and others to be
    used on a cloud provider.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Our GUI test plan should not be considered as a full system test plan. You can
    also consider other aspects such as load testing, security, backup, fault tolerance,
    and recovery.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Done, we have our plan! What''s next? Identify our testing priorities. For
    example, first of all, we need to ensure the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Visual design
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compliance
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functionality
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it''s time to represent it in a mental map to be understood by the entire
    team and perform the required tests. Check out this example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cff9be57-89ea-454f-af08-f9870377c79e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'The most common areas to test when we are navigating on a web application are
    these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with different versions of most used browsers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior when the user clicks on the back or refresh button (in browser)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior after a user returns to the page using a bookmark or their browser
    history
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior when the user has multiple browser windows open on the UAT at the same
    time
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining common scenarios
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define a test scenario as a brief statement describing how an application
    will be used in specific real-life situations, for example, “the user will be
    able to log in with a valid username and password.” Commonly, test scenarios are
    written from development documents such as requirements or user stories, each
    one with the required acceptance criteria to accomplish that. If these documents
    are not created yet, product owners should write them and define the different
    scenarios and acceptance criteria to mark the product as complete.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios are useful because they can guide exploratory testing, giving a good
    understanding of a GUI event, without restricting the testing team to a specific
    procedure. Since it is much faster to create a test scenario instead of writing
    a full test case, scenarios are most used in agile environments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If scenarios are used in scripted testing, they can be used as the base from
    which test cases can be written.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the *login scenario* mentioned earlier can have test cases for
    GUI events such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: User enters a valid username and password
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User enters invalid username
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User enters valid username but invalid password
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User tries to reset the password
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User presses the Submit button repeatedly
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/11e36bd5-80ad-4c47-9c89-858d95450e3f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Writing test cases
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commonly, this document starts with a brief description of a GUI event to be
    tested, we will still use the example about the login attempt. We should specify
    conditions and steps for executing the test. Finally, we need to evaluate the
    expected result of the test and define the acceptance criteria for determining
    whether the test succeeds or fails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'You must keep in mind some considerations such as the ones listed here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: How often the user interface changes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much freedom end users will have when navigating through the application
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have testers with less experience, they may need more detailed procedures
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What to include? Good question. Similar to our planning template, we need to
    put our acceptance criteria organized in a document where we can check and save
    the evolution of each test case. Here''s a very basic example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73de0547-f09d-4247-b359-afd1fd2c9826.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: It's important that you have separated your test data for test cases. Most of
    the time, issues are products of validation errors in the project, so the development
    teams must know which parameters caused this error. Always remember that application
    development is a team work, so you must give all the facilities to your colleagues
    to get the best product.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our test – Creating scripts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most detailed part of our test. Here, we will define the steps and
    procedures to execute our test. Create sufficient test scripts to verify paths
    that users will take through the UAT.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to document the input data and the expected output; it will
    be very important when we have to deal with unexpected events.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: API test with Swagger
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we were centered in the E2E testing of our entire application
    starting from the frontend, but what about our API itself? Remember that one API
    can be used to serve many client types such as web or mobile. So, don't you think
    it would be awesome to ensure this functionality independently from the entire
    application life cycle? Sure, we know you agree, and we have in mind a very nice
    solution to accomplish this objective—Swagger.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger is a specification and a nice group of tools to write RESTful APIs.
    Based on their own web page definition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '"Swagger is the world’s largest framework of API developer tools for the OpenAPI
    Specification (OAS), enabling development across the entire API life cycle, from
    design and documentation, to test and deployment."'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In the group of tools we have in Swagger, we can find these:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger Editor: This tool will allow us to view the updated document in real
    time.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger Codegen: A template-driven engine to generate interactive documents.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swagger UI: Allows to visualize the RESTful API, and check input and responses. So,
    *Swagger UI* takes an existing JSON or YAML document and creates interactive documentation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Swagger
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start getting our most important dependency, Swagger. Remember that we
    will use NPM to download Swagger, because we will use it on a ExpressJS API. Swagger
    has its own implementation depending on the platform you need to document.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two very famous swagger implementations to integrate with an ExpressJS
    application:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`swagger-node-express`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swagger-ui-express`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `swagger-node-express` is the official *Swagger* module for *Node*. Some
    of the most interesting (and not so) characteristics of this library are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Official distribution of the Swagger API. We are fully supported by an organization
    working actively on the development of the product.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is open source.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comes with *Swagger Editor* and Swagger Codegen.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Swagger UI* needs to be inserted inside the code where we are adding documentation.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since documentation is quite poor, you need to read the source code of some
    different libraries to learn and understand each argument used to configure Swagger.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `swagger-ui-express` is supported by the community, another great open source
    option. How does it work? This library adds a middleware to your Express.jsapplication
    that serves the Swagger UI bound to your Swagger document. It's really easy to
    configure; the only thing you will need to perform is add one route to host Swagger
    UI, without need to copy anything manually. Documentation is really good, and
    we think everything you need should be there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Given the functionality and simplicity of this tool, we've decided to use this
    library instead of any other option to achieve our main goal of documenting our
    application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to add the library to our current project:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the library is added to our project, we need to configure a route to host Swagger
    UI. Also, we need to load the Swagger API definition of our application. In our
    application, the Swagger API definition is a single file containing information
    about our application represented in a JSON object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Swagger API definition, we have used Swagger Editor. Remember
    that you are free to use JSON or YAML notation. Let''s look at an example of the
    same definition in different formats:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSON it is done as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In YAML:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Both are very human readable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Even if our specification file is a text that can be edited with any text editor, nowadays
    we have many specialized tools to achieve this, giving us some useful features
    such as syntax validation, format, autocomplete parameters, and more. The best
    option to write specification file is Swagger Editor (yes, its own tool), a powerful
    set of static files that allows you to write and validate Swagger specification
    in YAML syntax and see how your file will look rendered.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The created Swagger API definition will be stored in our application as a JSON
    object inside the `swagger.json` file. At this moment, our setup script should
    look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, first middleware is setting up our Swagger server. This middleware
    will return static files that are needed for hosting Swagger UI. Second middleware
    is our setup function that will set up Swagger UI to use our predefined users
    parameters in the `json/yml` file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Also, of course, our documentation URL is `http://localhost:3000/api-docs`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now just one step away from getting the maximum knowledge about full-stack
    applications and all the stuff it concerns. As we said earlier, one of the most
    important parts, and the one that makes the difference between just a programmer
    and a full-stack application developer, is testing. This chapter was meant to
    be easily understandable and highly applicable in your day-to-day work, giving
    you the most modern concepts and tools used in application testing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: You need to remember that integration tests are the assurance process of all
    components working well together, such third-party systems, external databases,
    and asynchronous processes. Depending on which platform you use, you will have
    a complete ecosystem to accomplish this and get the best value from your application.
    The best part is that you can automate all the tests at this layer and make your
    deployment process safer. One thing you cannot test using script is the usability
    of the application. You will need real humans to interact with your product and in
    this layer different UI testing techniques come to the rescue. Remember that user
    experience is one differential when you need to offer your products to the market.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住，集成测试是确保所有组件协同工作良好的保证过程，例如第三方系统、外部数据库和异步进程。根据你使用的平台，你将拥有一个完整的生态系统来完成这项任务，并从你的应用程序中获得最佳价值。最好的部分是你可以在这个层面自动化所有测试，使你的部署过程更安全。有一件事你不能使用脚本进行测试，那就是应用程序的可用性。你需要真实的人类来与你的产品互动，在这个层面，不同的UI测试技术会提供帮助。记住，当你需要将产品推向市场时，用户体验是一个重要的差异化因素。
- en: Finally, all the different tests need to be documented to be used by other developers
    to improve more features of your application. Swagger is a very nice and simple
    tool to generate a detailed documentation and share with your team.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有不同的测试都需要被记录下来，以便其他开发者可以使用它们来改进你应用程序的更多功能。Swagger是一个非常棒且简单的工具，可以生成详细的文档并与你的团队共享。
- en: Now we have completely covered the testing phase! You know what time it is...
    Let's deploy! See you in the next chapter!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全覆盖了测试阶段！你知道现在是时候了... 让我们部署吧！下一章见！
