<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Giving Forms the Knockout Touch</h1></div></div></div><p>Two of the oldest uses of the web are sharing and gathering information. This exchange includes the use of form and non-form elements. In this chapter, we will learn how to streamline coding and user interaction using the following focus areas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Event binding</li><li class="listitem" style="list-style-type: disc">Text binding</li><li class="listitem" style="list-style-type: disc">The textInput binding</li><li class="listitem" style="list-style-type: disc">Web 3.0</li><li class="listitem" style="list-style-type: disc">Radio and checkbox binding</li><li class="listitem" style="list-style-type: disc">Select binding</li><li class="listitem" style="list-style-type: disc">Grid forms</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Event binding</h1></div></div></div><p>Let me start off by saying that I have not tested every type of event that can be bound to Knockout, but <a id="id98" class="indexterm"/>there are tons of events in HTML, or rather DOM, that can be tested. It seems with HTML5-friendly browsers the number of the browsers available to us has increased. I would suggest that you make sure that you test to validate if any newer events are actually available on the platform you are targeting.</p><p>When we bind an event it requires a handler. These handlers are either functions or methods on objects. The functions can be part of the ViewModel or external to the scope of the ViewModel. As a reminder, when functions are part of the ViewModel we can assign the function method without <code class="literal">( )</code>. If we are passing arguments then we would, of course, use them, even if they were part of the ViewModel.</p><p>Common events we would look for in the View would include <code class="literal">click</code>, <code class="literal">keypress</code>, <code class="literal">mouseover</code>, and <code class="literal">mouseout</code>. There are many other events, but that is enough of a list to give you an <a id="id99" class="indexterm"/>idea of what events are, if this is a new concept to you.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>The binding markup</h2></div></div></div><p>We will <a id="id100" class="indexterm"/>start by <a id="id101" class="indexterm"/>creating the HTML for our page. Create a file named <code class="literal">enable.html</code> for this example:</p><div><pre class="programlisting">&lt;div&gt;
  &lt;div data-bind="event: { mouseover: oneLeft }"&gt;
    Move One Left
  &lt;/div&gt;
  &lt;div data-bind="event: { mouseover: oneRight }"&gt;
    Move One Right
  &lt;/div&gt;
  &lt;div style="border:solid 1px black;"&gt;
    &lt;div data-bind="css: oneClass"&gt;
      ( One )
    &lt;/div&gt;
    &lt;div data-bind="css: twoClass"&gt;
      ( Two )
    &lt;/div&gt;
    &lt;div style="clear:both;"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;button data-bind="event: {mousedown: twoLeft }"&gt;Move Two Left&lt;/button&gt;
  &lt;button data-bind="event: {mouseup: twoRight }"&gt;Move Two Right&lt;/button&gt;
&lt;/div&gt;</pre></div><p>We see the <code class="literal">data-bind</code> attribute has an event declaration in this code. We are going to bind the two first elements to the <code class="literal">mouseover</code> event. <code class="literal">oneLeft</code> is a function that the binding calls when the mouse is over the element. We see again that <code class="literal">( )</code> is not needed because we will be creating the function as part of the ViewModel.</p><p>The middle two <code class="literal">div</code> tags here have the element's class, the CSS attribute, set by the Knockout <code class="literal">data-bind</code> attribute. This would be a good time for us to create our extra classes before we do the code side of the work. Here is the CSS code:</p><div><pre class="programlisting">&lt;style type="text/css"&gt;
.putLeft { float:left; }
.putRight { float:right; }
&lt;/style&gt;</pre></div><p>These are two very simple float classes. The first two declarations in our ViewModel will be observables holding the value of our classes assigned to these elements. Note that we are declaring these as classes, so do not start the class name with a period. The CSS assumes this is the case.</p><div><pre class="programlisting">&lt;script&gt;
    var vm = {
        oneClass: ko.observable('putLeft'),
        twoClass: ko.observable('putLeft'),
        /* mode code coming */
    };
    &lt;/script&gt;</pre></div><p>If we look back <a id="id102" class="indexterm"/>at our HTML markup code, we see the events are not mouseover but rather mousedown <a id="id103" class="indexterm"/>and mouseup. These ViewModel event handlers, also known as functions, will call the methods to manage the <strong>(Two)</strong> item in the box on the browser page. Let's add the code for both sets of handlers:</p><div><pre class="programlisting">oneLeft: function() {
     this.oneClass('putLeft');
},
oneRight: function() {
    this.oneClass('putRight');
},
twoLeft: function() {
    this.twoClass('putLeft');
},
twoRight: function() {
    this.twoClass('putRight');
}</pre></div><p>All we are doing is changing the text of the ViewModel elements as this will change the bound CSS to match. This will, of course, shift the assigned element to float left or right on the page. Here is the complete code for this example:</p><div><pre class="programlisting">&lt; script &gt;
var vm = {
    oneClass: ko.observable('putLeft'),
    twoClass: ko.observable('putLeft'),
    oneLeft: function () {
        this.oneClass('putLeft');
    },
    oneRight: function () {
        this.oneClass('putRight');
    },
    twoLeft: function () {
        this.twoClass('putLeft');
    },
    twoRight: function () {
        this.twoClass('putRight');
    }
};
ko.applyBindings(vm); &lt; /script&gt;</pre></div><p>Now run the <a id="id104" class="indexterm"/>code in <a id="id105" class="indexterm"/>the browser and you should see the <strong>(One)</strong> element shifting left and right when hovering over the items above the box. You will have to actually click the items below the box to get them to take action.</p><div><img src="img/1028OS_03_01.jpg" alt="The binding markup"/></div><p>It would be great if we could get the book to show you the results. Perhaps in e-books in the future that will be possible, but for now we will stay old school and actually enter the code and test it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>The binding checkbox with visibility</h2></div></div></div><p>In this example we will create a file named <code class="literal">event.html</code> and copy the <code class="literal">_base.html</code> to save time. We <a id="id106" class="indexterm"/>will be looking at parameters and doing something in a very elegant way that was<a id="id107" class="indexterm"/> too much work for a simple task in JavaScript. jQuery made JavaScript coding better but Knockout brings binding simplicity that we all needed from the start.</p><p>Next, we will create the markup for our example. We see the <code class="literal">data-bind</code> this time is connected to the checked value changing. The second input box is tied to the same ViewModel item, <code class="literal">bringingSpouse</code>. The second input stores the value entered into the ViewModel item, <code class="literal">spouseName</code>. When first loading the page it will not store anything because the input box will be disabled.</p><div><pre class="programlisting">&lt;p&gt;
  Will you be bringing your spouse?
  &lt;input type="checkbox" name="bringspouse" data-bind="checked: bringingSpouse" /&gt;
&lt;/p&gt;
&lt;p&gt;
  Your Spouse's Name:
  &lt;input type="text" data-bind="value: spouseName, enable: bringingSpouse" /&gt;
&lt;/p&gt;</pre></div><div><img src="img/1028OS_03_02.jpg" alt="The binding checkbox with visibility"/></div><p>This is the <a id="id108" class="indexterm"/>code to <a id="id109" class="indexterm"/>drive the automated logic. It just takes two observables; one to hold the value for the spouse's name and the other to handle true or false, to toggle the input box when the user has a spouse.</p><div><pre class="programlisting">&lt;script&gt;
var vm = {
  bringingSpouse: ko.observable(false),
  spouseName: ko.observable("")
};
ko.applyBindings(vm);
&lt;/script&gt;</pre></div><p>Now, we can test our code to see how this works. It is as simple as clicking on the checkbox, following which the input box should become usable and ready for you to enter your spouse's name, if that applies to you, of course:</p><div><img src="img/1028OS_03_03.jpg" alt="The binding checkbox with visibility"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Modifier keys</h2></div></div></div><p>We are <a id="id110" class="indexterm"/>going to revisit our <code class="literal">enable.html</code> file and learn a little how to deal with some modified events. In our case, we will be looking at spotting the event when the <em>Shift</em> key is pressed. If <em>Shift</em> is pressed we will handle the event one way and if not, we will handle it another way. First, let's add a reset button to the screen with this HTML code:</p><div><pre class="programlisting">&lt;br/&gt;
&lt;button data-bind="event: {mouseover: reset }"&gt;RESET&lt;/button&gt;</pre></div><p>Now, we will add the highlighted code in the <code class="literal">script</code> section of the page:</p><div><pre class="programlisting">var vm = {
    oneClass: ko.observable('putLeft'),
    twoClass: ko.observable('putLeft'),
    oneLeft: function() {
        this.oneClass('putLeft');
    },
    oneRight: function() {
        this.oneClass('putRight');
    },
    twoLeft: function() {
        this.twoClass('putLeft');
    },
    twoRight: function() {
        this.twoClass('putRight');
    }<strong>,</strong>
<strong>    reset: function(data, event){</strong>
<strong>        if(event.shiftKey){</strong>
<strong>            alert("Don't hold the shift key!");</strong>
<strong>        } else {</strong>
<strong>            this.oneClass('putLeft');</strong>
<strong>            this.twoClass('putLeft');</strong>
<strong>        }</strong>
<strong>    }</strong>
};</pre></div><p>When we <a id="id111" class="indexterm"/>hover the mouse over the new button with the <em>Shift</em> key pressed, it will pull up an alert box similar to this:</p><div><img src="img/1028OS_03_04.jpg" alt="Modifier keys"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Default actions</h2></div></div></div><p>By default, Knockout <a id="id112" class="indexterm"/>prevents the built-in standard browser events from taking place. If you want to let these events run, just bind a handler to the event that returns true.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Preventing bubbling</h2></div></div></div><p>Another thing you may want to do is to prevent event bubbling. <strong>Bubbling</strong> means that an element <a id="id113" class="indexterm"/>on the web page, also called the DOM element, has a chain relationship with what we will <a id="id114" class="indexterm"/>call higher-level elements. After an item has had an opportunity to handle an event, the events are then passed up the chain to allow a higher element an opportunity<a id="id115" class="indexterm"/> to respond to the event.</p><p>In our mouseover example, there could have been an area of the page wrapping the button that also had a mouseover handler. If there was, after the button handled the event, the event would have been passed to the higher element to allow it to respond to the event as well.</p><p>Control is actually very simple. We only need to prevent the event by telling our button handler to return false. Of course, in a different scenario, for the event action which you don't want to go beyond, you would have set its handler return false value just like the button in our use case example we are discussing here.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>The textInput binding</h1></div></div></div><p>We have obviously done a number of bindings to textboxes already. Now, we are going to do <a id="id116" class="indexterm"/>something new with them. We are going to put a text input and a text area on the page together. Here is our HTML markup, where we will put in a new file called <code class="literal">text.html</code>:</p><div><pre class="programlisting">&lt;p&gt;Title: &lt;input data-bind="textInput: title" /&gt;&lt;/p&gt;
&lt;p&gt;Post: &lt;textarea data-bind="textInput: post" /&gt;&lt;/textarea&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2 data-bind="text: title"&gt;&lt;/h2&gt;
&lt;div data-bind="text: post"&gt;&lt;/div&gt;
&lt;/p&gt;</pre></div><p>If we were using the value binding we would only get an update when the input element lost focus. Using the <code class="literal">textInput</code> binding let us have character by character feedback. Let's add our code so we can try it out:</p><div><pre class="programlisting">&lt;script&gt;
function Blog() {
  this.title = ko.observable();
  this.post = ko.observable();
};
blog = new Blog();
ko.applyBindings( blog );
&lt;/script&gt;</pre></div><div><img src="img/1028OS_03_05.jpg" alt="The textInput binding"/></div><p>We see the page content updating character by character as we type but there is an issue. The <a id="id117" class="indexterm"/>text in the <strong>Post</strong> is coming into the page as text. There is a simple way to fix that. We just change the content target from <code class="literal">text</code> to <code class="literal">html</code>. Oh, and make sure you use small letters or you will have an issue. Now, run it again and it should look like this:</p><div><img src="img/1028OS_03_06.jpg" alt="The textInput binding"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Dynamic focus</h2></div></div></div><p>There are many opportunities to enhance user experience when doing dynamic AJAX style sites. Years ago, a website was a dead experience compared to the power you could add <a id="id118" class="indexterm"/>to a desktop application. Today, the more dynamic application is left up to the creative ability of the designers and developers on each platform. Changing the user interface to be more responsive creates a virtual relationship between the user and your page. Make use of the following steps to make your page dynamic:</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing we will do is change the <code class="literal">data-bind</code> attribute on the title of the text input. By adding a comma we can have more than one data binding on an element. We will add the <code class="literal">hasFocus</code> binder to the input, and target the event to call the handler that we will name <code class="literal">lookAtTitleBox</code>. Our input box should now look like this in the code:<div><pre class="programlisting">&lt;input data-bind="textInput: title, hasFocus: lookAtTitleBox" /&gt;</pre></div></li><li class="listitem">Next, we <a id="id119" class="indexterm"/>will add a button after this input box to show the ability to dynamically control the focus from code. This means we need to tie an event handler, our function, to the click event of the button. Then, we will let the code take care of passing control back to the title input box. Add this markup right after our title input box:<div><pre class="programlisting">&lt;button data-bind="click: focusTitle"&gt;Focus On Title&lt;/button&gt;</pre></div></li><li class="listitem">Now, we will need to add our output text for the View to be displayed when the title input has the focus:<div><pre class="programlisting">&lt;span data-bind="visible:lookAtTitleBox"&gt;( Enter A Good Title )&lt;/span&gt;</pre></div></li><li class="listitem">The last thing we need to do is modify our ViewModel to make our form more interactive. We will add two items: an observable attribute on our ViewModel and a method to be called by our View element:<div><pre class="programlisting">this.lookAtTitleBox = ko.observable(false);
this.focusTitle = function(){
  this.lookAtTitleBox(true);
};</pre></div></li></ol></div><p>When the page is reloaded, our title field has the focus, by default. Click inside <strong>Post</strong> to remove the focus from the title element. You should see the focus text after the button is visible and when the title element has focus. Now, when the title element does not have focus, click on the <strong>Focus On Title</strong> button. You will see through Knockout that we are able to designate the focus of an element by toggling a variable in the ViewModel. This is another example of what makes ViewModels in MVVM oriented applications powerful. Here is the output we get when the page is reloaded:</p><div><img src="img/1028OS_03_07.jpg" alt="Dynamic focus"/></div><p>Our complete code for this logic should look like the following:</p><div><pre class="programlisting">&lt;!-- Here is the markup code--&gt;
&lt;br/&gt;
&lt;p&gt;Title: &lt;input data-bind="textInput: title, hasFocus: lookAtTitleBox" /&gt;
&lt;button data-bind="click: focusTitle"&gt;Focus On Title&lt;/button&gt;
&lt;span data-bind="visible:lookAtTitleBox"&gt;
( Enter A Good Title )
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;Post: &lt;textarea data-bind="textInput: post" /&gt;&lt;/textarea&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2 data-bind="text: title"&gt;&lt;/h2&gt;
&lt;div data-bind="html: post"&gt;&lt;/div&gt;
&lt;/p&gt;</pre></div><div><pre class="programlisting">// Here is the script code
&lt;script&gt;
function Blog() {
  this.title = ko.observable();
  this.post = ko.observable();
  this.lookAtTitleBox = ko.observable(false);
  this.focusTitle = function(){
    this.lookAtTitleBox(true);
  };
};
blog = new Blog();
ko.applyBindings( blog );
&lt;/script&gt;</pre></div><p>Take a <a id="id120" class="indexterm"/>moment and look at the elegant simplicity of this code. This is why many Knockout coders feel like what jQuery did for JavaScript, Knockout does as much to enhance the design and development experience.</p><p>Well, that is not good enough. If the goal is improved user experience why don't we copy this file, <code class="literal">text.html</code>, as <code class="literal">text3.html</code> and create a Web 3.0 level experience? We will just show all the code at once and talk through it. We will be creating the click-to-edit experience here:</p><div><pre class="programlisting">&lt;p&gt;
  &lt;span data-bind="click:editTitle"&gt;Title&lt;/span&gt;:
  &lt;input data-bind="visible: showTitleEditor, textInput: title, hasFocus:showTitleEditor" /&gt;
  &lt;span data-bind="visible: !showTitleEditor(), html:title, click: editTitle"&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;span data-bind="click:editPost"&gt;Post&lt;/span&gt;:
  &lt;textarea data-bind="visible: showPostEditor, textInput: post, hasFocus:showPostEditor" /&gt;&lt;/textarea&gt;
  &lt;span data-bind="visible: !showPostEditor(), html:post, click: editPost"&gt;&lt;/span&gt;
&lt;/p&gt;</pre></div><p>What we<a id="id121" class="indexterm"/> have done is put the input element for the title with a span that displays the contents of the title value. You will notice they both have the same item starting the <code class="literal">data-bind</code> attribute. The order is not important as far as the code is stable; this is just the order we happen to code in. The visible item in the text has parentheses because the <code class="literal">!</code> (not) symbol means we have entered JavaScript code into the attribute value. Whenever we do that we need to enter parentheses for it to function correctly.</p><p>We also have added a click event handler to the label and the title content. The reason we have added the label is that there will be times when you may have a page load without the title prepopulated. This was just an example to show that you still have access to calling the edit box by clicking on the title. When the page loads it will look like this at first (remember to complete the ViewModel before so that it will work correctly):</p><div><img src="img/1028OS_03_08.jpg" alt="Dynamic focus"/></div><p>We want the same functionality for the <strong>Post</strong> box so you can see our code in the markup is identical, except it is a <code class="literal">textArea</code> field for the post versus the title. Now, let's look at our ViewModel code:</p><div><pre class="programlisting">&lt;script&gt;
function Blog() {
  this.title = ko.observable('Web 3.0');
  this.showTitleEditor = ko.observable(false);
  this.editTitle = function(){
    this.showTitleEditor(true);
  };
  
  this.post = ko.observable('Here is my &lt;strong&gt;Web 3.0&lt;/strong&gt; content!');
  this.showPostEditor = ko.observable(false);
  this.editPost = function(){
    this.showPostEditor(true);
  };
};
blog = new Blog();
ko.applyBindings( blog );
&lt;/script&gt;</pre></div><p>We see that <a id="id122" class="indexterm"/>our values for the title and the visibility of the title editor are simple observable attributes on our ViewModel. The only thing we need the <code class="literal">editTitle</code> event handler to do is toggle the visible state of the title input box to true. Knockout will set the visibility of our View and edit elements correctly for us with hardly any code. We did the same thing for the post element. Now, when we click either on the title content or the title label, we will see the edit box for the title display as follows:</p><div><img src="img/1028OS_03_09.jpg" alt="Dynamic focus"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Radio and checkbox binding</h1></div></div></div><p>Radio and <a id="id123" class="indexterm"/>checkbox handling in forms can be a pain. This is another area where Knockout just makes<a id="id124" class="indexterm"/> things simple. Our example will start by creating a file named <code class="literal">radio.html</code> this time. Let's start with the markup for our checkbox:</p><div><pre class="programlisting">&lt;h2&gt;Checkbox&lt;/h2&gt;
&lt;p&gt;
  Colors (&lt;span data-bind="text: colors"&gt;&lt;/span&gt;)&lt;br/&gt;
  &lt;input type="checkbox" value="red" data-bind="checked: colors" /&gt; Red&lt;br/&gt;
  &lt;input type="checkbox" value="green" data-bind="checked: colors" /&gt; Green&lt;br/&gt;
  &lt;input type="checkbox" value="blue" data-bind="checked: colors" /&gt; Blue&lt;br/&gt;
  &lt;input type="checkbox" value="yellow" data-bind="checked: colors" /&gt; Yellow&lt;br/&gt;
  &lt;input type="checkbox" value="purple" data-bind="checked: colors" /&gt; Purple&lt;br/&gt;
&lt;/p&gt;</pre></div><div><img src="img/1028OS_03_10.jpg" alt="Radio and checkbox binding"/></div><p>Now, add this code in a <code class="literal">script</code> tag on the bottom of the page, as we have done for the other <a id="id125" class="indexterm"/>pages. We <a id="id126" class="indexterm"/>will need an array to hold the contents of the selected items and that is basically all we need in our ViewModel for this functionality:</p><div><pre class="programlisting">function VM() {
  this.colors = ko.observableArray([]);
};
vm = new VM();
ko.applyBindings( vm );</pre></div><p>By binding the checked handler in the <code class="literal">data-bind</code> attributes, we will see that the <code class="literal">colors</code> attribute is automatically populated. The <code class="literal">colors</code> attribute in the <code class="literal">span</code> tag will show all of the currently selected checkbox elements. You might even try clicking earlier items on and off and you will see it always puts the last selected item at the end of the list:</p><div><img src="img/1028OS_03_11.jpg" alt="Radio and checkbox binding"/></div><p>The markup for a radio button is very similar. We are going to create our code the same way to show the difference in function between a radio button collection and a checkbox collection of elements, as follows:</p><div><pre class="programlisting">&lt;h2&gt;Radio&lt;/h2&gt;
&lt;p&gt;
  Shapes (&lt;span data-bind="text: shapes"&gt;&lt;/span&gt;)&lt;br/&gt;
  &lt;input type="radio" value="square" data-bind="checked: shapes" /&gt;Square&lt;br/&gt;
  &lt;input type="radio" value="round" data-bind="checked: shapes" /&gt;Round&lt;br/&gt;
  &lt;input type="radio" value="triangle" data-bind="checked: shapes" /&gt;Triangle&lt;br/&gt;
  &lt;input type="radio" value="rectangle" data-bind="checked: shapes" /&gt;Rectangle&lt;br/&gt;
  &lt;input type="radio" value="oval" data-bind="checked: shapes" /&gt;Oval&lt;br/&gt;
&lt;/p&gt;</pre></div><div><img src="img/1028OS_03_12.jpg" alt="Radio and checkbox binding"/></div><p>All we <a id="id127" class="indexterm"/>need to<a id="id128" class="indexterm"/> is just add this single line of code in <code class="literal">function VM()</code>:</p><div><pre class="programlisting">this.shapes = ko.observableArray([]);</pre></div><div><img src="img/1028OS_03_13.jpg" alt="Radio and checkbox binding"/></div><p>With the radio button it does not matter how many items are clicked, as radio buttons always limit themselves to a single item being selected. In common HTML, we would <a id="id129" class="indexterm"/>have <a id="id130" class="indexterm"/>needed to put a name on each of the radio buttons to make sure the DOM knew how to achieve this functionality. In this example, we can plainly see again that Knockout is taking care of business for us.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Enhanced event integration</h2></div></div></div><p>The radio and checkbox binding, which we explained earlier, is useful and many seasoned developers <a id="id131" class="indexterm"/>likely think that HTML coding is far too heavy with the manual entering of all the details of colors or shapes right in the markup or the View part of the document. This type of thing is the best practice to place in a data collection of some sort. And this is exactly what we will do with the another set of checkboxes that we will label as <strong>Foods</strong>.</p><p>In this example, we will add an attribute to our ViewModel called <code class="literal">foodItems</code>. We will also go another step forward and set some preselected values in a variable called <code class="literal">foods</code>. You will notice that our <code class="literal">foodItems</code> attribute has a structured collection with two nested items: <code class="literal">item</code> and <code class="literal">itemDisplay</code>. Make sure your preselected items are using the <code class="literal">item</code> value. If you put in <code class="literal">Milk</code> instead of <code class="literal">milk</code> you will be confused about why it did not appear to work correctly. Items have to have a 100 percent match so lower case and upper case make all the difference here. Add the following code in <code class="literal">function VM()</code>:</p><div><pre class="programlisting">  this.foodItems = ko.observableArray([
    { item: 'bread', itemDisplay: 'Bread' },
    { item: 'milk', itemDisplay: 'Milk' },
    { item: 'eggs', itemDisplay: 'Eggs' }
  ]);
  this.foods = ko.observableArray(['bread', 'eggs'"]);</pre></div><p>Now, we can add in another set of checkboxes for the foods in the View section of our code. We will also be using the foreach binding in this set. Here, we can pass a JSON style structure to allow us to create an alias of "food" for our internal <code class="literal">$data</code> item. Each item inside <code class="literal">foreach</code> is designated as <code class="literal">$data</code>. Adding the <code class="literal">as</code> key allows us to set an alias for the <code class="literal">$data</code> as food. We show both approaches in use here by using <code class="literal">$data.item</code> and by using <code class="literal">food.itemDisplay</code> for the more dynamic example. Here is the code to add in the markup:</p><div><pre class="programlisting">&lt;h2&gt;Checkbox&lt;/h2&gt;
&lt;p&gt;
  Foods (&lt;span data-bind="text: foods"&gt;&lt;/span&gt;)&lt;br/&gt;
&lt;div data-bind="foreach: {data:foodItems, as: 'food'}"&gt;
  &lt;input type="checkbox" data-bind="checkedValue: $data.item, checked: $root.foods" /&gt;
  &lt;span data-bind="text: food.itemDisplay"&gt;&lt;/span&gt;&lt;br/&gt;
&lt;/div&gt;
&lt;/p&gt;</pre></div><div><img src="img/1028OS_03_14.jpg" alt="Enhanced event integration"/></div><p>This is our<a id="id132" class="indexterm"/> complete <a id="id133" class="indexterm"/>code, in case it would help you to see all in one place. Knockout again has shown a simpler and powerful advantage to the way it works.</p><div><pre class="programlisting">function VM() {
  this.colors = ko.observableArray([]);
  this.shapes = ko.observableArray([]);
  this.foodItems = ko.observableArray([
    { item: 'bread', itemDisplay: 'Bread' },
    { item: 'milk', itemDisplay: 'Milk' },
    { item: 'eggs', itemDisplay: 'Eggs' }
  ]);
  this.foods = ko.observableArray(["bread","eggs"]);
};
vm = new VM();
ko.applyBindings( vm );</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Select binding</h1></div></div></div><p>Our first example of <a id="id134" class="indexterm"/>using Knockout with a <code class="literal">select</code> element will be for single item selection. This is the markup where we will put <code class="literal">colors</code> into the options:</p><div><pre class="programlisting">&lt;p&gt;
  Colors: ( &lt;span data-bind="text: colors"&gt;&lt;/span&gt; )
  &lt;br/&gt;
  &lt;select data-bind="options: colorOptions, 
              value: colors,
              optionsCaption: 'Choose a color'"&gt;&lt;/select&gt;
&lt;/p&gt;</pre></div><p>In our code we will be doing one more special thing at this time. After we create the ViewModel we will modify one of its attributes and add another color to the <code class="literal">colorOptions</code> array <a id="id135" class="indexterm"/>using the <code class="literal">push</code> function, common to JavaScript. This means that some parts of JavaScript are great already and we should continue to use them. Here is the <code class="literal">script</code> code:</p><div><pre class="programlisting">&lt;script&gt;
function MyModel(){
  this.colorOptions = ko.observableArray(['Red','Green','Blue','Yellow','Green']);
  this.colors = ko.observableArray();
};
myModel = new MyModel();
ko.applyBindings( myModel );
myModel.colorOptions.push('Orange');
&lt;/script&gt;</pre></div><div><img src="img/1028OS_03_15.jpg" alt="Select binding"/></div><p>If we select the last added item, <strong>Orange</strong>, we will see the selector and the display span both showing the value as in the preceding screenshot. Using the code you can set the value of the ViewModel <code class="literal">color</code> attribute and it will automatically set the select box to the matching value. You should try it from the browser developer tools console. Don't forget to match the case of the value.</p><p>Now, we will use a multi-select element. We don't need the options caption in this case. What we do need is to change the values of the <code class="literal">data-bind</code> handler to the <code class="literal">selectedOptions</code> handler. This allows us to capture multiple items. Just remember that a value is singular and selected options are plural. I am not saying that we always have to think of singular and plural, but we do in this case. Add the following code to the markup:</p><div><pre class="programlisting">&lt;p&gt;
  Shapes: ( &lt;span data-bind="text: shapes"&gt;&lt;/span&gt; )
  &lt;br/&gt;
  &lt;select size="3" multiple="true"
    data-bind="options: shapeOptions, 
      selectedOptions: shapes"&gt;&lt;/select&gt;
&lt;/p&gt;</pre></div><p>Now, it's time to add in a little bit of code to work with the new select element. There is no pragmatic <a id="id136" class="indexterm"/>difference between the data coding of a single select and the multi-select element in the ViewModel.</p><div><pre class="programlisting">this.shapeOptions = ko.observableArray(['Square','Circle','Triangle','Rectange', 'Oval']);
this.shapes = ko.observableArray();</pre></div><p>As you can see in the following screenshot, this works really well by allowing us to select multiple elements:</p><div><img src="img/1028OS_03_16.jpg" alt="Select binding"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Selecting elements with the object collections</h2></div></div></div><p>Sometimes <a id="id137" class="indexterm"/>our data comes with the value and the displayed item representing the value as two different items. Here is an example of how to code when this is the case:</p><div><pre class="programlisting">&lt;p&gt;
  Budget:
  &lt;br/&gt;
  &lt;select data-bind="options: budgets,
        optionsText: 'budgetName',
        value: budget,
        optionsCaption: 'Pick...'"&gt;&lt;/select&gt;
&lt;/p&gt;
&lt;div&gt;
  You have chosen a 
  '&lt;span data-bind="text: budget() ? budget().budgetType : 'undeclared'"&gt;&lt;/span&gt;'
  budget type.
&lt;/div&gt;</pre></div><p>And in the <code class="literal">script</code> tag, inside <code class="literal">MyModel()</code>, add the following line of code:</p><div><pre class="programlisting">this.budget = ko.observable();</pre></div><p>Notice <code class="literal">optionsText</code> is not a variable but is the value of the structure element inside the collection item. We are using an individual result here so we use the value handler to hold the results. If it were multiple selections, we would use the <code class="literal">selectedOptions</code> binding. Here is what the initial display will look like after our code is <a id="id138" class="indexterm"/>added. Notice that the type is set to <code class="literal">undeclared</code>:</p><div><img src="img/1028OS_03_17.jpg" alt="Selecting elements with the object collections"/></div><p>Also take note of the logic inside our text binding. If there is no item selected, the budget item will be a null item. This works in JavaScript as a false result. It will then display the contents of the item after the colon. Otherwise it returns the results of the item before the colon. In that case we will return the structure element from the budget item for the type, which you will see in our script; we coded it as <code class="literal">budgetType</code>. Let's take a look at the <code class="literal">script</code> code now:</p><div><pre class="programlisting">var Budget = function(name, type){
  this.budgetName = name;
  this.budgetType = type;
};</pre></div><p>The code segment above will come before we declare the structure of our ViewModel. We will use it to declare the items within our budget collection as follows. We use a simple observable versus an observableArray because we are only returning a single item. It is a structured item with nested attributes but it is a single item at that level and thus, this is the correct logic:</p><div><pre class="programlisting">this.budgets = ko.observableArray([
  new Budget('Electric','expense'),
  new Budget('Bob Pay','income'),
  new Budget('Betty Pay','income'),
  new Budget('Taxes','expense'),
  new Budget('Gas','expense'),
  new Budget('Rental House','income'),
  new Budget('House Payment','expense')
]);
this.budget = ko.observable();</pre></div><p>Now, let's look at the results once we select an item. If we select the <strong>Rental House</strong> item we see that the budget type changes to <strong>income</strong>. This makes for nice dynamic interaction with far less manual coding of our automated systems.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Listing the management Knockout style</h2></div></div></div><p>Now we can take our budget system just a little further. We will make a list editor that will let <a id="id139" class="indexterm"/>us add, delete, and sort our list. While most of what we have done so far has been very <a id="id140" class="indexterm"/>simple, this one is going to be different. This example is going to be simplified. It does a lot more so it will take a little more. Yet, through the power of Knockout, we will see that simplicity is still intact:</p><div><pre class="programlisting">&lt;p&gt;
  &lt;form data-bind="submit:addBudget"&gt;
  Budget Editor:
  &lt;hr/&gt;
  Budget:
  &lt;input data-bind="value: newName, valueUpdate: 'afterkeydown'" /&gt;&lt;br/&gt;
  Type:
  &lt;select data-bind="options: budgetTypes,
              value: budgetType"&gt;&lt;/select&gt;&lt;br/&gt;
  &lt;button type="submit" data-bind="enable: newName().length"&gt;Add Budget&lt;/button&gt;
  &lt;/form&gt;
&lt;/p&gt;</pre></div><p>In our first section of code we use something that we have not used so far. We use a <code class="literal">form</code> tag. Normally forms are not used when coding with Knockout. So why the change in this example? The change is because we are going to use the <code class="literal">submit</code> function of the form to act as our trigger to add the new budget items to our budget. This is done with the <code class="literal">addBudget</code> handler in our code. Here is our <code class="literal">script</code> code:</p><div><pre class="programlisting">this.newName = ko.observable("");
this.budgetTypes = ko.observableArray(['income','expense']);
this.budgetType = ko.observable();
this.selectedBudgets = ko.observableArray([]);
this.addBudget = function(){
  var myBudget = new Budget(this.newName(),this.budgetType());
  if((this.newName() != "") 
      &amp;&amp; (this.budgets.indexOf(myBudget) &lt; 0) ) {
    this.budgets.push(myBudget);
  }
  this.newName("");
};
this.dropBudget = function(){
  this.budgets.removeAll(this.selectedBudgets());
};
this.sortBudgets = function(){
  this.budgets.sort(bCompare);
};</pre></div><p>Most of the <a id="id141" class="indexterm"/>rest of the code looks familiar. The only part that might be new for some is the sorting of budgets. We do this using the standard JavaScript style sorting and a custom function <a id="id142" class="indexterm"/>we created outside the ViewModel. The custom function is the <code class="literal">bCompare</code> function. Here is the code for that:</p><div><pre class="programlisting">var bCompare = function(left,right){
  if(left.budgetName &lt; right.budgetName) {
    return -1;
}
  if(left.budgetName &gt; right.budgetName) {
    return 1;
}
  return 0;
};</pre></div><p>This is a simple compare function used by JavaScript to interact with the natural flow to make sure that all the items are in order. Again, we see that the code behind this edit form is simple enough. Let's take a look at the list editor we are building. We did not make it fancy but we are certainly building some sweet functionality into it:</p><div><img src="img/1028OS_03_18.jpg" alt="Listing the management Knockout style"/></div><p>There is a little more special markup in the View side of the code to make sure things are bound correctly, shown as follows:</p><div><pre class="programlisting">&lt;p&gt;	
  &lt;select size="5" multiple="true"
      data-bind="options: budgets,
              optionsText: 'budgetName',
              selectedOptions: selectedBudgets"&gt;&lt;/select&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;button data-bind="click: dropBudget"&gt;Drop Budget&lt;/button&gt;
  &lt;button data-bind="click: sortBudgets"&gt;Sort Budgets&lt;/button&gt;
&lt;/p&gt;</pre></div><p>Now, if you are looking at the code you may be wondering what is special about the code. It's just Knockout making things simple and powerful. This is all it takes to get the job <a id="id143" class="indexterm"/>done. Oh, did you figure out that I am pretty impressed with Knockout? I am. Knockout is<a id="id144" class="indexterm"/> what makes it special because it is doing so much for us so that we can concentrate on the programming goals instead of how to achieve them. Here is a screenshot after we add <strong>Entertainment</strong> as an expense, sort the list, and delete <strong>Gas</strong> from it:</p><div><img src="img/1028OS_03_19.jpg" alt="Listing the management Knockout style"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>The uniqueName binding</h1></div></div></div><p>IE6 does not allow radio buttons to be checked if they don't have a <code class="literal">name</code> attribute. Most of the <a id="id145" class="indexterm"/>time this is irrelevant because your radio button elements will have the <code class="literal">name</code> attributes to put them into mutually-exclusive groups. However, if you didn't add a <code class="literal">name</code> attribute because it's unnecessary in your case, Knockout will internally use <code class="literal">uniqueName</code> on those elements to ensure they can be checked. Hopefully, none of us will have to use IE6 but just in case, add the <code class="literal">uniqueName</code> handler to the <code class="literal">data-bind</code> attribute, something like this if needed:</p><div><pre class="programlisting">&lt;input data-bind="value: newName, uniqueName: true" /&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Grid forms</h1></div></div></div><p>Now we will take our budget form just one step further. We will combine a number of the features we <a id="id146" class="indexterm"/>have been learning to this point into an editable grid. We will wrap the grid in a form this time also, but you will see in the code a dual option for how you use the form. Create a file called <code class="literal">grid.html</code> for this example. Enter the following in the markup:</p><div><pre class="programlisting">&lt;form action='/serverTargetHandlerHere'&gt;
  &lt;p&gt;You have asked for &lt;span data-bind='text: budget().length'&gt;&amp;nbsp;&lt;/span&gt; budget item(s)&lt;/p&gt;
  &lt;table data-bind='visible: budget().length &gt; 0'&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;Budget&lt;/th&gt;
        &lt;th&gt;Amount&lt;/th&gt;
        &lt;th/&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody data-bind='foreach: budget'&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;input data-bind='value: name, uniqueName: true' /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;input data-bind='value: amount, uniqueName: true' /&gt;&lt;/td&gt;
        &lt;td&gt;&lt;a href='#' data-bind='click: $root.removeBudget'&gt;Delete&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
  &lt;button data-bind='click: addBudget'&gt;Add Budget&lt;/button&gt;
  &lt;button data-bind='enable: budget().length &gt; 0,click: save' type''='submit'&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre></div><p>If you want to <a id="id147" class="indexterm"/>use Knockout just as an automated editor and still submit the form, you could fill in the details on the <code class="literal">action</code> attribute of the form and still submit it in the old-school approach. This might be useful if you are working with an older system and your business logic is still form-submission based. This will also allow you to enter the realm of Knockout more gradually. It could also allow you to test out the functionality without having to totally rewrite your systems during testing this way.</p><p>Notice we are using the <code class="literal">foreach</code> markup binding to manage a row in our grid for every data row on the model of our data. The ViewModel smartly keeps all of this tied together and up to date. We have also added in the <code class="literal">uniqueName</code> logic that one would add into an application that needs to support IE6. Now let's look at the script code:</p><div><pre class="programlisting">var BudgetModel = function(budget) {
    var self = this;
    self.budget = ko.observableArray(budget);
    self.addBudget = function() {
        self.budget.push({
            name: "",
            amount: ""
        });
    };
    self.removeBudget = function(budget) {
        self.budget.remove(budget);
    };
    self.save = function(form) {
        alert("Could now transmit to server: " + ko.utils.stringifyJson(self.budget));
        // To actually transmit to server as a regular form post, write this: ko.utils.postJson($("form")[0], self.budget);
    };
};
var budget = new BudgetModel([
    { name: "Food", amount: "560.00"},
    { name: "Utilities", amount: "180.00"},
    { name: "Rent", amount: "620.00"},
    { name: "Insurance", amount: "80.00"}
]);
ko.applyBindings( budget );</pre></div><p>We created a standard ViewModel named BudgetModel in this example. Once again, we are using<a id="id148" class="indexterm"/> the JavaScript array <code class="literal">push</code> method to stack another budget item in our array collection. We also have handlers for removing a budget item. If we look back at our markup you will see it uses the scope-based variable <code class="literal">$root.removeBudget</code>. The rows are added using the foreach functionality so Knockout once again does the heavy lifting for us and it will know which row you are trying to delete. Don't get stressed out trying to figure it out. Think of it like a smartphone. You don't need to know how it works. What you need to know is how to use it.</p><p>The save method handler is set to show the results in an alert box. You could have easily used jQuery AJAX to send these results back to a server for persistent data storage. You will also see there is, as stated previously, the ability to just send it as a form. The choice is there for you to pick the one that best suits your needs. Here is the screenshot for the previous code:</p><div><img src="img/1028OS_03_20.jpg" alt="Grid forms"/></div><p>Now play around with this example. Add some rows. Delete some rows. Click <strong>Submit</strong> with data and you will see the results in an alert box. Click it without any rows and you will see it is <a id="id149" class="indexterm"/>smart enough to just ignore the user trying to submit nothing.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>When working with forms and grids, and keeping the data up to date, anytime you touch it, anywhere, is what Knockout has been about from the start. I hope you are enjoying coding web forms with the simple but powerful advances this technology offers. It makes focusing on business logic much easier with less code.</p><p>In the next chapter, we will learn to integrate data management in Knockout using JSON and mapping.</p></div></body></html>