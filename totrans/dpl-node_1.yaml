- en: Chapter 1. Appreciating Node
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章  欣赏Node
- en: At the time of writing this book, Node is approaching its fifth year of existence,
    and its usage has grown in each of those five years. The opportunity for Node
    to fail has come, and passed. Node is a serious technology built by a highly skilled
    core team and very active community focused on constantly improving its speed,
    security, and usefulness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Node正接近其存在的第五个年头，其使用量在这五年中逐年增长。Node失败的机会已经到来，并且已经过去。Node是由一支技术精湛的核心团队和非常活跃的社区构建的严肃技术，他们专注于不断改进其速度、安全性和实用性。
- en: 'Every day, developers face some of the problems that NodeJS aims to solve.
    Some of them are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每天开发者都会面临NodeJS旨在解决的问题。以下是一些例子：
- en: Scaling networked applications beyond a single server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个服务器之外扩展网络应用程序
- en: Preventing I/O bottlenecks (database, file, and network access)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止I/O瓶颈（数据库、文件和网络访问）
- en: Monitoring system usage and performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控系统使用情况和性能
- en: Testing the integrity of system components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试系统组件的完整性
- en: Managing concurrency safely and reliably
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全可靠地管理并发
- en: Pushing code changes and bug fixes into live environments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码更改和错误修复推送到生产环境
- en: In this book, we will look at techniques of deploying, scaling, monitoring,
    testing, and maintaining your Node applications. The focus will be on how Node's
    event-driven, nonblocking model can be applied in practice to these aspects of
    software design and deployment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将探讨部署、扩展、监控、测试和维护您的Node应用程序的技术。重点将放在如何将Node的事件驱动、非阻塞模型应用于软件设计和部署的这些方面。
- en: 'On February 28, 2014, Eran Hammer delivered the keynote address to attendees
    of NodeDay, a large developer conference organized and sponsored by PayPal. He
    began his address by reciting some numbers relevant to his employer, Walmart:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年2月28日，Eran Hammer向由PayPal组织和赞助的大型开发者会议NodeDay的与会者发表了主题演讲。他开始演讲时，列举了一些与他雇主沃尔玛相关的数字：
- en: 11,000 stores
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 11,000家门店
- en: Half a trillion dollars of net sales per year
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每年半兆美元的净销售额
- en: 2.2 million employees
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.2百万名员工
- en: The largest private employer in the world
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界上最大的私营雇主
- en: 'He continued:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 他继续说道：
- en: '|   | *"55 percent of our Black Friday traffic, which is our Superbowl of the
    year…we do about 40 percent of annual revenues on Black Friday. 55 percent came
    on mobile…that 55 percent of traffic went 100 percent through Node. […] We were
    able to deliver…this massive traffic with the equivalent of two CPUs and 30 Gigs
    of RAM. That''s it. That''s what Node needed to handle 100 percent of mobile Node
    traffic on Black Friday. […] Walmart global e-commerce is a 10-billion-dollar
    business, and by the end of this year, all 10 billion will go through Node."*
    |   |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|    | *"55%的黑色星期五流量，这是我们一年中的超级碗……我们在黑色星期五实现了大约40%的年度收入。55%的流量来自移动端……这55%的流量100%通过Node完成。[...]
    我们能够处理...如此巨大的流量，只需要相当于两个CPU和30吉字节RAM。就是这样。这就是Node在黑色星期五处理100%移动端Node流量的需求。[...]
    沃尔玛全球电子商务业务价值100亿美元，到今年年底，所有这100亿美元都将通过Node完成。"[...] |    |'
- en: '|   | --*Eran Hammer, Senior Architect, Walmart Labs* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|    | --*Eran Hammer，沃尔玛实验室高级架构师* |'
- en: Modern network software, for various reasons, is growing in complexity and,
    in many ways, changing how we think about application development. Most new platforms
    and languages are attempting to address these changes. Node is no exception—and
    JavaScript is no exception.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，现代网络软件的复杂性正在增长，并且在许多方面改变了我们思考应用程序开发的方式。大多数新的平台和语言都在试图应对这些变化。Node也不例外——JavaScript也不例外。
- en: Learning about Node means learning about event-driven programming, composing
    software out of modules, creating and linking data streams, and producing and
    consuming events and their related data. Node-based architectures are often composed
    of many small processes and/or services communicating with events—internally,
    by extending the `EventEmitter` interface and using callbacks and externally,
    over one of several common transport layers (for example, HTTP, TCP) or through
    a thin messaging layer covering one of these transport layers (for example, 0MQ,
    Redis PUBSUB, and Kafka). It is likely that these processes are composed of several
    free, open source, and high-quality **npm** modules, each distributed with unit
    tests and/or examples and/or documentation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Node意味着了解事件驱动编程、将软件模块化、创建和链接数据流，以及产生和消费事件及其相关数据。基于Node的架构通常由许多小型进程和/或服务组成，它们通过事件进行通信——内部通过扩展`EventEmitter`接口和使用回调，外部通过几个常见的传输层之一（例如，HTTP、TCP）或通过覆盖这些传输层之一的薄消息层（例如，0MQ、Redis
    PUBSUB和Kafka）。这些进程可能由几个免费、开源且高质量的**npm**模块组成，每个模块都附带单元测试和/或示例和/或文档。
- en: In this chapter, we will take a quick tour of Node, highlighting the problems
    it aims to solve, the solutions implied by its design, and what this means to
    you. We will also briefly discuss some of the core topics we will explore more
    comprehensively in later chapters, such as how to structure efficient and stable
    Node servers, how to make the best use of JavaScript for your application and
    your team, and how to think about and use Node for best results.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速浏览Node，突出其旨在解决的问题、其设计所暗示的解决方案以及这对你的意义。我们还将简要讨论一些我们将在后续章节中更全面探讨的核心主题，例如如何构建高效稳定的Node服务器、如何最好地利用JavaScript为你的应用程序和团队服务，以及如何思考和利用Node以获得最佳效果。
- en: Let's start with understanding the how and why of Node's design.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解Node设计的方式和原因开始。
- en: Understanding Node's unique design
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Node的独特设计
- en: 'I/O operations (disk and network) are clearly more expensive. The following
    table shows clock cycles consumed by typical system tasks (from Ryan Dahl''s original
    presentation of Node—[https://www.youtube.com/watch?v=ztspvPYybIY](https://www.youtube.com/watch?v=ztspvPYybIY)):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: I/O操作（磁盘和网络）显然更昂贵。以下表格显示了典型系统任务消耗的时钟周期（来自Ryan Dahl的原始演示——[https://www.youtube.com/watch?v=ztspvPYybIY](https://www.youtube.com/watch?v=ztspvPYybIY)）：
- en: '| **L1-cache** | 3 cycles |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **L1-cache** | 3周期 |'
- en: '| **L2-cache** | 14 cycles |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **L2-cache** | 14周期 |'
- en: '| **RAM** | 250 cycles |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **RAM** | 250周期 |'
- en: '| **Disk** | 41,000,000 cycles |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **Disk** | 41,000,000周期 |'
- en: '| **Network** | 240,000,000 cycles |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **Network** | 240,000,000周期 |'
- en: 'The reasons are clear enough: a disk is a physical device, a spinning metal
    platter—storing and retrieving that data is much slower than moving data between
    solid-state devices (such as microprocessors and memory chips) or indeed optimized
    on-chip L1/L2 caches. Similarly, data does not move from point to point on a network
    instantaneously. Light itself needs 0.1344 seconds to circle the globe! In a network
    used by many billions of people regularly interacting across great distances at
    speeds much slower than the speed of light, with many detours and few straight
    lines, this sort of latency builds up.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很清楚：磁盘是一个物理设备，一个旋转的金属盘片——存储和检索数据比在固态设备（如微处理器和内存芯片）之间移动数据或确实在片上优化的L1/L2缓存中操作要慢得多。同样，数据在网络上的点对点传输不会瞬间完成。光本身需要0.1344秒才能绕地球一周！在一个由数十亿人使用、在远距离以远低于光速的速度进行大量交互、有许多迂回和很少直线的网络中，这种延迟会累积起来。
- en: When our software ran on personal computers on our desks, little or no communication
    was happening over the network. Delays or hiccups in our interactions with a word
    processor or spreadsheet had to do with disk access time. Much work was done to
    improve disk access speeds. Data storage and retrieval became faster, software
    became more responsive, and users now expect this responsiveness in their tools.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的软件在我们的办公桌上运行在个人电脑上时，网络上几乎没有通信发生。与文字处理器或电子表格交互中的延迟或中断与磁盘访问时间有关。我们做了大量工作来提高磁盘访问速度。数据存储和检索变得更快，软件变得更加响应，现在用户期望他们的工具具有这种响应性。
- en: With the advent of cloud computing and browser-based software, your data has
    left the local disk and exists on a remote disk, and you access this data via
    a network—the Internet. Data access times have slowed down again, dramatically.
    Network I/O is slow. Nevertheless, more companies are migrating sections of their
    applications into the *cloud*, with some software being entirely network-based.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算和基于浏览器的软件的出现，你的数据已经离开了本地磁盘，存在于远程磁盘上，而你通过网络——互联网来访问这些数据。数据访问时间再次变慢，大幅下降。网络I/O速度缓慢。尽管如此，越来越多的公司将他们的应用程序的部分迁移到*云*中，有些软件完全是基于网络的。
- en: Node is designed to make I/O fast. It is designed for this new world of networked
    software, where data is in many places and must be assembled quickly. Many of
    the traditional frameworks to build web applications were designed at a time when
    a single user working on a desktop computer used a browser to periodically make
    HTTP requests to a single server running a relational database. Modern software
    must anticipate tens of thousands of simultaneously connected clients concurrently
    altering enormous, shared data pools via a variety of network protocols on any
    number of unique devices. Node is designed specifically to help those building
    that kind of network software.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node被设计成使I/O快速。它被设计用于这个新的网络软件世界，其中数据存在于许多地方，并且必须快速组装。许多用于构建Web应用程序的传统框架是在这样一个时代设计的，当时单个用户在台式计算机上使用浏览器定期向运行关系型数据库的单个服务器发出HTTP请求。现代软件必须预测成千上万的客户端同时通过各种网络协议在任何数量的独特设备上并发地更改巨大的共享数据池。Node被特别设计来帮助那些构建这种网络软件的人。
- en: What do concurrency, parallelism, asynchronous execution, callbacks, and events
    mean to the Node developer?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并发、并行性、异步执行、回调和事件对Node开发者意味着什么？
- en: Concurrency
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发
- en: 'Running code procedurally, or in order, is a reasonable idea. We tend to do
    that when we execute tasks and, for a long time, programming languages were naturally
    procedural. Clearly, at some point, the instructions you send to a processor must
    be executed in a predictable order. If I want to multiply 8 by 6, divide that
    result by 144 divided by 12, and then add the total result to 10, the order of
    those operations must proceed sequentially:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序或程序性地运行代码是一个合理的想法。当我们执行任务时，我们往往会这样做，而且长期以来，编程语言都是自然程序性的。显然，在某个时刻，你发送给处理器的指令必须以可预测的顺序执行。如果我想将8乘以6，然后将结果除以144除以12，最后将总和加到10上，这些操作的顺序必须按顺序进行：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The order of operations must not be as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的顺序不应该是以下这样：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is logical and easy to understand. Early computers typically had one processor,
    and processing one instruction blocked the processing of subsequent instructions.
    But things did not stay that way, and we have moved far beyond single-core computers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有逻辑的，也容易理解。早期的计算机通常只有一个处理器，处理一个指令会阻止后续指令的处理。但事情并没有保持这种状态，我们已经远远超越了单核计算机。
- en: If you think about the previous example, it should be obvious that calculating
    `144/12` and `8x6` can be done independently—one need not wait for the other.
    A problem can be divided into smaller problems and distributed across a pool of
    available people or workers to work on in parallel, and the results can be combined
    into a correctly ordered final calculation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑之前的例子，应该很明显，计算`144/12`和`8x6`可以独立完成——一个不需要等待另一个。一个问题可以被分解成更小的问题，并分布到一组可用的人或工人中并行处理，然后将结果组合成一个正确排序的最终计算。
- en: Multiple processes, each solving one part of a single mathematical problem simultaneously,
    are an example of **parallelism**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同时解决单个数学问题的一个部分，多个进程的例子是**并行性**。
- en: 'Rob Pike, co-inventor of Google''s Go programming language, defines **concurrency**
    in this way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Google的Go编程语言的共同发明者Rob Pike这样定义**并发**：
- en: '*"Concurrency is a way to structure a thing so that you can, maybe, use parallelism
    to do a better job. But parallelism is not the goal of concurrency; concurrency''s
    goal is a good structure."*'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"并发是一种构建事物的方式，这样你就可以，也许，利用并行性做得更好。但并行性不是并发的目标；并发的目标是良好的结构。"*'
- en: Concurrency is not parallelism. A system demonstrating concurrency allows developers
    to compose applications *as if* multiple independent processes are simultaneously
    executing many possibly related things. Successful high-concurrency application
    development frameworks provide an easy-to-reason-about vocabulary to describe
    and build such a system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并发不是并行。一个表现出并发的系统允许开发者构建应用程序，*好像*多个独立的过程同时执行许多可能相关的事情。成功的高并发应用程序开发框架提供了一个易于理解的词汇表来描述和构建这样的系统。
- en: Node's design suggests that achieving its primary goal—to provide an easy way
    to build scalable network programs—includes simplifying how the execution order
    of coexisting processes is structured and composed. Node helps a developer reasoning
    about a program, within which many things are happening at once (such as serving
    many concurrent clients), to better organize his or her code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Node的设计表明，实现其主要目标——提供一种简单的方式来构建可扩展的网络程序——包括简化共存进程的执行顺序的结构和组成。Node帮助开发者更好地组织代码，在程序中许多事情同时发生（例如，服务多个并发客户端）时，更好地思考程序。
- en: Let's take a look at the differences between parallelism and concurrency, threads
    and processes, and the special way that Node absorbs the best parts of each into
    its own unique design.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看并行性和并发性、线程和进程之间的区别，以及Node如何以独特的方式吸收每个部分的优点。
- en: Parallelism and threads
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行和线程
- en: 'The following diagram describes how a traditional microprocessor might execute
    the simple program discussed previously:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了传统的微处理器可能如何执行之前讨论的简单程序：
- en: '![Parallelism and threads](img/1403OS_01_01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![并行和线程](img/1403OS_01_01.jpg)'
- en: The program is broken up into individual instructions that are executed in order.
    This works but does require that instructions be processed in a serial fashion,
    and, while any one instruction is being processed, subsequent instructions must
    wait. This is a blocking process—executing any one segment of this chain blocks
    the execution of subsequent segments. There is a **single thread** of execution
    in play.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被分解成单个指令，按顺序执行。这可行，但需要指令以串行方式处理，并且，在处理任何一条指令时，后续的指令必须等待。这是一个阻塞过程——执行链中的任何一段都会阻塞后续段的处理。这里有一个**单线程**的执行流。
- en: However, there is some good news. The processor has (literally) total control
    of the board, and there is no danger of another processor nulling memory or overriding
    any other state that this primary processor might manipulate. Speed is sacrificed
    for stability and safety.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些好消息。处理器（实际上）完全控制着主板，没有其他处理器会清除内存或覆盖这个主要处理器可能操作的其他任何状态。速度是为了稳定性和安全性而牺牲的。
- en: We do like speed; however, the model discussed earlier rapidly became obsolete
    as chip designers and systems programmers worked to introduce parallel computing.
    Rather than having one blocking thread, the goal was to have multiple cooperating
    threads.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实喜欢速度；然而，随着芯片设计师和系统程序员努力引入并行计算，之前讨论的模型迅速变得过时。目标不是只有一个阻塞线程，而是要有多条协作线程。
- en: 'This improvement definitely increased the speed of calculation but introduced
    some problems, as described in the following schematic:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进无疑提高了计算的效率，但也引入了一些问题，如下面的示意图所示：
- en: '![Parallelism and threads](img/1403OS_01_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![并行和线程](img/1403OS_01_02.jpg)'
- en: This diagram illustrates cooperating threads executing in parallel within a
    single process, which reduces the time necessary to perform the given calculation.
    Distinct threads are employed to break apart, solve, and compose a solution. As
    many subtasks can be completed independently, the overall completion time can
    be reduced dramatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此图说明了在单个进程中并行执行的协作线程，这减少了执行给定计算所需的时间。使用不同的线程来分解、解决和组合解决方案。由于许多子任务可以独立完成，整体完成时间可以显著减少。
- en: Threads provide parallelism within a single process. A single thread represents
    a single sequence of (serially executed) instructions. A process can contain any
    number of threads.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在单个进程中提供并行性。一个线程代表一个单一的指令序列（顺序执行）。一个进程可以包含任意数量的线程。
- en: 'Difficulties arise out of the complexity of thread synchronization. It is very
    difficult to model highly concurrent scenarios using threads, especially models
    in which the state is shared. It is difficult to anticipate all the ways in which
    an action taken in one thread will affect all the others if it is never clear
    when an asynchronously executing thread will complete:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 线程同步的复杂性导致了困难。使用线程来模拟高度并发场景非常困难，尤其是在共享状态的模式中。如果异步执行的线程何时完成并不明确，那么很难预测一个线程采取的行动将如何影响所有其他线程：
- en: The shared memory and the locking behavior this requires lead to systems that
    are very difficult to reason about as they grow in complexity.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存及其所需的锁定行为导致系统在复杂性增加时变得非常难以推理。
- en: Communication between tasks requires the implementation of a wide range of synchronization
    primitives, such as mutexes and semaphores, condition variables, and so on. An
    already challenging environment requires highly complex tools, expanding the level
    of expertise necessary to complete even relatively simple systems.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务之间的通信需要实现各种同步原语，如互斥锁和信号量、条件变量等。一个已经具有挑战性的环境需要高度复杂的工具，这增加了完成甚至相对简单系统所需的技能水平。
- en: Race conditions and deadlocks are a common pitfall in these sorts of systems.
    Contemporaneous read/write operations within a shared program space lead to problems
    of sequencing, where two threads may be in an unpredictable *race* for the right
    to influence a state, event, or other key system characteristic.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件和死锁是这类系统中的常见陷阱。在共享程序空间内同时进行的读写操作会导致序列化问题，其中两个线程可能在进行不可预测的*竞争*以获得影响状态、事件或其他关键系统特性的权利。
- en: 'Because maintaining dependable boundaries between threads and their states
    is so difficult, ensuring that a library (for Node, it would be a *package* or
    *module*) is thread safe occupies a great deal of the developer''s time. Can I
    know that this library will not destroy some part of my application? Guaranteeing
    thread safety requires great diligence on the part of a library''s developer,
    and these guarantees may be conditional: for example, a library may be thread
    safe when reading—but not when writing.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为在线程及其状态之间保持可靠的边界如此困难，确保一个库（对于Node来说，它可能是一个*包*或*模块*）是线程安全的占据了开发者大量时间。我能知道这个库不会破坏我应用程序的某些部分吗？保证线程安全需要库开发者的极大勤奋，并且这些保证可能是条件性的：例如，一个库在读取时可能是线程安全的，但在写入时则不是。
- en: 'We want the power of parallelization provided by threads but could do without
    the mind-bending world of semaphores and mutexes. In the Unix world, there is
    a concept that is sometimes referred to as the **Rule of Simplicity**: *Developers
    should design for simplicity by looking for ways to break up program systems into
    small, straightforward cooperating pieces. This rule aims to discourage developers''
    affection for writing ''intricate and beautiful complexities'' that are, in reality,
    bug-prone programs*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望利用线程提供的并行化能力，但可以不需要那些令人头疼的信号量和互斥锁的世界。在Unix世界中，有一个概念有时被称为**简单规则**：*开发者应该通过寻找将程序系统分解成小而直接的合作部分的方法来设计简单性。这个规则旨在阻止开发者对编写'复杂而美丽'的程序的喜爱，而这些程序实际上是有缺陷的程序*。
- en: Concurrency and processes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与进程
- en: Parallelism within a single process is a complicated illusion that is achieved
    deep within mind-bendingly complex chipsets and other hardware. The question is
    really about appearances—about how the activity of the system appears to, and
    can be programmed by, a developer. Threads offer hyper-efficient parallelism,
    but make concurrency difficult to reason about.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单个进程内的并行化是一个复杂的错觉，它是在令人费解的复杂芯片组和其它硬件深处实现的。真正的问题在于外观——关于系统的活动如何向开发者显示，以及如何被开发者编程。线程提供了超高效的并行化，但使得并发难以推理。
- en: 'Rather than have the developer struggle with this complexity, Node itself manages
    I/O threads, simplifying this complexity by demanding only that control flow be
    managed between events. There is a need to *micromanage* I/O threading; one simply
    designs an application to establish data availability points (callbacks) and the
    instructions to be executed once the said data is available. A single stream of
    instructions that explicitly takes and relinquishes control in a clear, collision-free,
    and predictable way aids development:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让开发者与这种复杂性作斗争，Node 本身管理 I/O 线程，通过只要求在事件之间管理控制流来简化这种复杂性。需要**微观管理**I/O 线程；开发者只需设计一个应用程序来建立数据可用点（回调）以及当数据可用时要执行的指令。一条明确的指令流，以清晰、无冲突和可预测的方式明确地获取和释放控制，有助于开发：
- en: Instead of concerning themselves with arbitrary locking and other collisions,
    developers can focus on constructing execution chains, the ordering of which is
    predictable.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此同时，开发者不必担心任意的锁定和其他冲突，可以专注于构建执行链，其顺序是可预测的。
- en: Parallelization is accomplished through the use of multiple processes, each
    with an individual and distinct memory space, due to which communication between
    processes remains uncomplicated—via the *Rule of Simplicity*, we achieve not only
    simple and bug-free components, but also easier interoperability.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化是通过使用多个进程来实现的，每个进程都有自己的独立和独特的内存空间，因此进程间的通信保持简单——通过**简单法则**，我们不仅实现了简单且无错误的组件，还实现了更易于互操作。
- en: The state is not (arbitrarily) shared between individual Node processes. A single
    process is automatically protected from surprise visits from other processes bent
    on memory reallocation or resource monopolization. Communication is through clear
    channels using basic protocols, all of which make it very hard to write programs
    that make unpredictable changes across processes.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态不是（任意地）在单个 Node 进程之间共享的。单个进程自动受到来自其他进程的意外访问的保护，这些进程热衷于内存重新分配或资源垄断。通信是通过使用基本协议的清晰通道进行的，所有这些都使得编写在进程之间产生不可预测变化的程序变得非常困难。
- en: Thread safety is one less concern for developers to waste time worrying about.
    Because single-threaded concurrency obviates the collisions present in multithreaded
    concurrency, development can proceed more quickly and on surer ground.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全是开发者无需浪费时间担忧的另一个问题。因为单线程并发消除了多线程并发中的冲突，开发可以更快地进行，并建立在更坚实的基础之上。
- en: A single thread describing asynchronous control flow efficiently managed by
    an event loop brings stability, maintainability, readability, and resilience to
    Node programs. The big news is that Node continues to deliver the speed and power
    of multithreading to its developers—the brilliance of Node's design makes such
    power transparent, reflecting one part of Node's stated aim of bringing the most
    power to the most people with the least difficulty.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程描述了由事件循环高效管理的异步控制流，为 Node 程序带来了稳定性、可维护性、可读性和弹性。最大的新闻是 Node 继续向开发者提供多线程的速度和力量——Node
    设计的卓越之处使得这种力量变得透明，反映了 Node 声明的目标之一：以最少的困难将最多的力量带给最多的人。
- en: Events
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: Many JavaScript extensions in Node emit events. These are instances of `events.EventEmitter`.
    Any object can extend `EventEmitter`, which gives the developer an elegant toolkit
    to build tight, asynchronous interfaces to their object methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Node 中许多 JavaScript 扩展都会发出事件。这些是 `events.EventEmitter` 的实例。任何对象都可以扩展 `EventEmitter`，这为开发者提供了一个优雅的工具包，用于构建紧密的、异步的对象方法接口。
- en: 'Work through this example demonstrating how to set an `EventEmitter` object
    as the prototype of a function constructor. As each constructed instance now has
    the `EventEmitter` object exposed to its prototype chain, `this` provides a natural
    reference to the event''s **Application Programming Interface** (**API**). The
    `counter` instance methods can, therefore, emit events, and these can be listened
    for. Here, we emit the latest count whenever the `counter.increment` method is
    called and bind a callback to the "incremented" event, which simply prints the
    current counter value to the command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例演示如何将 `EventEmitter` 对象设置为函数构造函数的原型。由于每个构造实例现在都将 `EventEmitter` 对象暴露给其原型链，`this`
    提供了对事件**应用程序编程接口**（**API**）的自然引用。因此，`counter` 实例方法可以发出事件，并且可以监听这些事件。在这里，每当调用 `counter.increment`
    方法时，我们都会发出最新的计数，并将回调绑定到“incremented”事件，该事件简单地打印当前计数器的值到命令行：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: To remove the event listeners bound to `counter`, use `counter.removeListener('incremented',
    callback)`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除绑定到`counter`的事件监听器，请使用`counter.removeListener('incremented', callback)`。
- en: '`EventEmitter`, as an extensible object, adds to the expressiveness of JavaScript.
    For example, it allows I/O data streams to be handled in an event-oriented manner
    in keeping with Node''s principle of asynchronous, nonblocking programming:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`作为一个可扩展的对象，增加了JavaScript的表达能力。例如，它允许以事件驱动的方式处理I/O数据流，符合Node的异步、非阻塞编程原则：'
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this program, we have a `Readable` stream pushing out a set of numbers—with
    listeners on that stream's data event catching numbers as they are emitted and
    logging them—and finishing with a message when the stream has ended. It is plain
    that the listener is called once per number, which means that running this set
    did not block the event loop. Because Node's event loop need only commit resources
    to handling callbacks, many other instructions can be processed in the downtime
    of each event.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们有一个`Readable`流推送一系列数字——在该流的data事件上设置监听器，捕获发出的数字并记录它们——并在流结束时发送一条消息。很明显，监听器对每个数字只调用一次，这意味着运行这个集合并没有阻塞事件循环。因为Node的事件循环只需要承诺资源来处理回调，所以在每个事件的下一次空闲时间可以处理许多其他指令。
- en: The event loop
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: 'The code seen in non-networked software is often synchronous or blocking. I/O
    operations in the following pseudo-code are also blocking:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在非网络软件中看到的代码通常是同步的或阻塞的。以下伪代码中的I/O操作也是阻塞的：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following iterator will read one file at a time, dump its contents, and
    then read the next until it is done:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下迭代器将一次读取一个文件，输出其内容，然后读取下一个文件，直到完成：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a fine model for many cases. However, what if these files are very
    large? If each takes 1 second to fetch, all will take 3 seconds to fetch. The
    retrieval on one file is always waiting on another retrieval to finish, which
    is inefficient and slow. Using Node, we can initiate file reads on all files simultaneously:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个适用于许多情况的优秀模型。然而，如果这些文件非常大呢？如果每个文件都需要1秒钟来获取，那么所有文件都需要3秒钟来获取。对一个文件的检索总是等待另一个检索完成，这既低效又慢。使用Node，我们可以同时启动所有文件的读取操作：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Node version will read all three files at once, each call to `fs.readFile`
    returning its result at some unknowable point in the future. This is why we can't
    always expect the files to be returned in the order they were arrayed. We can
    expect that all three will be returned in roughly the time it took for one to
    be retrieved—something less than 3 seconds. We have traded a predictable execution
    order for speed, and, as with threads, achieving synchronization in concurrent
    environments requires extra work. How do we manage and describe unpredictable
    data events so that our code is both easy to understand *and* efficient?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Node版本将一次性读取所有三个文件，每次调用`fs.readFile`都会在未来的某个未知时刻返回其结果。这就是为什么我们无法总是期望文件按它们被数组化的顺序返回。我们可以期望所有三个文件在大约一个文件被检索所需的时间内返回——这比3秒要少。我们为了速度而牺牲了可预测的执行顺序，并且，就像线程一样，在并发环境中实现同步需要额外的工作。我们如何管理和描述不可预测的数据事件，以便我们的代码既易于理解*又*高效？
- en: 'The key design choice made by Node''s designers was the implementation of an
    event loop as a concurrency manager. The following description of event-driven
    programming (taken from [http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html](http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html))
    clearly not only describes the event-driven paradigm, but also introduces us to
    how events are handled in Node and how JavaScript is an ideal language for such
    a paradigm:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Node的设计者做出的关键设计选择是实现事件循环作为并发管理器。以下关于事件驱动编程的描述（摘自[http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html](http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Event-driven_programming.html)）不仅清楚地描述了事件驱动范式，而且还介绍了Node中事件的处理方式以及JavaScript为何是这种范式的理想语言：
- en: '*"In computer programming, event-driven programming or event-based programming
    is a programming paradigm in which the flow of the program is determined by events—that
    is, sensor outputs or user actions (mouse clicks, key presses) or messages from
    other programs or threads.*'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在计算机编程中，事件驱动编程或基于事件的编程是一种编程范式，其中程序的流程由事件决定——即传感器输出或用户操作（鼠标点击、按键）或其他程序或线程的消息。"*'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Event-driven programming can also be defined as an application architecture
    technique in which the application has a main loop that is clearly divided down
    to two sections: the first is event selection (or event detection), and the second
    is event handling […]*'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*事件驱动编程也可以被定义为一种应用程序架构技术，其中应用程序有一个主循环，该循环被明确地分为两个部分：第一部分是事件选择（或事件检测），第二部分是事件处理
    [...]*'
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Event-driven programs can be written in any language although the task is
    easier in languages that provide high-level abstractions, such as closures."*'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*事件驱动程序可以用任何语言编写，尽管在提供高级抽象的语言中这项任务更容易完成，例如闭包。"*'
- en: As we've seen in the preceding quote, single-threaded execution environments
    block and can, therefore, run slowly. V8 provides a single thread of execution
    for JavaScript programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前述引用中看到的，单线程执行环境会阻塞，因此可能会运行缓慢。V8为JavaScript程序提供单个执行线程。
- en: How can this single thread be made more efficient?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使这个单线程更高效？
- en: 'Node makes a single thread more efficient by delegating many blocking operations
    to OS subsystems to process, bothering the main V8 thread only when there is data
    available for use. The main thread (your executing Node program) expresses interest
    in some data (such as via `fs.readFile`) by passing a callback and is notified
    when that data is available. Until that data arrives, no further burden is placed
    on V8''s main JavaScript thread. How? Node delegates I/O work to **libuv**, as
    quoted at [http://nikhilm.github.io/uvbook/basics.html#event-loops](http://nikhilm.github.io/uvbook/basics.html#event-loops):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过将许多阻塞操作委托给操作系统子系统来处理，仅在可用数据时才打扰主V8线程，从而使单个线程更高效。主线程（你正在执行的Node程序）通过传递回调来对某些数据（例如通过`fs.readFile`）表示关注，并在数据可用时得到通知。在此数据到达之前，不会对V8的主JavaScript线程造成进一步负担。如何做到？Node将I/O工作委托给**libuv**，如[http://nikhilm.github.io/uvbook/basics.html#event-loops](http://nikhilm.github.io/uvbook/basics.html#event-loops)中引用的那样：
- en: '*"In event-driven programming, an application expresses interest in certain
    events and responds to them when they occur. The responsibility of gathering events
    from the operating system or monitoring other sources of events is handled by
    libuv, and the user can register callbacks to be invoked when an event occurs."*'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在事件驱动编程中，应用程序对某些事件表示关注，并在它们发生时做出响应。从操作系统或监控其他事件源收集事件的责任由libuv处理，用户可以注册回调，以便在事件发生时调用。"*'
- en: '*The user* in the preceding quote is the Node process executing a JavaScript
    program. *Callbacks* are JavaScript functions, and managing callback invocation
    for the user is accomplished by Node''s event loop. Node manages a queue of I/O
    requests populated by libuv, which is responsible for polling the OS for I/O data
    events and handing off the results to JavaScript callbacks.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前述引用中的*用户*是执行JavaScript程序的Node进程。*回调*是JavaScript函数，Node通过事件循环管理回调的调用，以管理用户的回调调用。Node管理由libuv填充的I/O请求队列，libuv负责轮询操作系统以获取I/O数据事件，并将结果传递给JavaScript回调。
- en: 'Consider the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This program will result in the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序将产生以下输出：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s what Node does when executing this program:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node执行此程序时，它会做以下操作：
- en: Node loads the `fs` module. This provides access to `fs.binding`, which is *a
    static type map defined in src/node.cc that provides glue between C++ and JS code*.
    ([https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ](https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ)).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node加载`fs`模块。这提供了对`fs.binding`的访问，它是在`src/node.cc`中定义的静态类型映射，它提供了C++和JS代码之间的粘合剂。([https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ](https://groups.google.com/forum/#!msg/nodejs/R5fDzBr0eEk/lrCKaJX_6vIJ))。
- en: The `fs.readFile` method is passed instructions and a JavaScript callback. Through
    `fs.binding`, libuv is notified of the file read request and is passed a specially
    prepared version of the callback sent by the original program.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.readFile`方法接收指令和JavaScript回调。通过`fs.binding`，libuv被通知文件读取请求，并传递由原始程序发送的特别准备好的回调版本。'
- en: libuv invokes the OS-level functions necessary to read a file within its own
    thread pool.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libuv在其自己的线程池中调用必要的操作系统级函数来读取文件。
- en: The JavaScript program continues, printing `This happens first`. Because there
    is a callback outstanding, the event loop continues to spin, waiting for that
    callback to resolve.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript程序继续，打印`This happens first`。因为有一个未解决的回调，事件循环继续旋转，等待该回调解决。
- en: When the file descriptor has been fully read by the OS, libuv (via internal
    mechanisms) is informed and the callback passed to libuv is invoked, which essentially
    prepares the original JavaScript callback for re-entrance into the main (V8) thread.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文件描述符被操作系统完全读取后，libuv（通过内部机制）会得到通知，并将回调传递给libuv，这实际上是为原始JavaScript回调准备重新进入主（V8）线程。
- en: The original JavaScript callback is pushed onto the event loop queue and is
    invoked on the next tick of the loop.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始JavaScript回调被推送到事件循环队列，并在循环的下一个tick上调用。
- en: The file contents are printed to the console.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件内容被打印到控制台。
- en: As there are no further callbacks in flight, the process exits.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于飞行过程中没有进一步的回调，进程退出。
- en: Here, we see the key ideas that Node implements to achieve fast, manageable,
    and scalable I/O. If, for example, there were 10 read calls made for `'foo.js'`
    in the preceding program, the execution time would, nevertheless, remain roughly
    the same. Each call would have been made *in parallel* in its *own thread* within
    the libuv thread pool. Even though we wrote our code "in JavaScript", we are actually
    deploying a very efficient multithreaded execution engine *while avoiding the
    difficulties of thread management*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到Node实现快速、可管理和可扩展I/O的关键思想。例如，如果在前面的程序中对`'foo.js'`进行了10次读取调用，执行时间仍然大致相同。每次调用都会在libuv线程池中的自己的线程中**并行**执行。尽管我们用“JavaScript”编写了代码，但实际上我们部署了一个非常高效的**多线程执行引擎**，同时避免了线程管理的困难。
- en: Let's close with more details on how exactly libuv results are returned into
    the main thread's event loop.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以更多细节结束，具体说明libuv结果是如何返回到主线程的事件循环中的。
- en: When data becomes available on a socket or other stream interface, we cannot
    simply execute our callback immediately. JavaScript is single threaded, so results
    must be synchronized. We can't suddenly change the state in the middle of an event
    loop tick—this would create some of the classic multithreaded application problems
    of race conditions, memory access conflicts, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字或其他流接口上有数据可用时，我们不能立即执行我们的回调。JavaScript是单线程的，所以结果必须同步。我们无法在事件循环的tick过程中突然改变状态——这会创建一些经典的多线程应用程序问题，如竞态条件、内存访问冲突等。
- en: Upon entering an event loop, Node (in effect) makes a copy of the current instruction
    queue (also known as **stack**), empties the original queue, and executes its
    copy. The processing of this instruction queue is referred to as a *tick*. If
    libuv, asynchronously, receives results while the chain of instructions copied
    at the start of this tick are being processed on the single main thread (V8),
    these results (wrapped as callbacks) are queued. Once the current queue is emptied
    and its last instruction has completed, the queue is again checked for instructions
    to execute *on the next tick*. This pattern of checking and executing the queue
    will repeat (loop) until the queue is emptied, and no further data events are
    expected, at which point the Node process exits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入事件循环时，Node（实际上）复制了当前的指令队列（也称为**栈**），清空了原始队列，并执行其副本。处理这个指令队列的过程被称为**tick**。如果在开始这个tick时复制的指令链在单个主线程（V8）上异步接收结果（作为回调包装），这些结果（包装为回调）将被排队。一旦当前队列被清空，其最后一条指令完成，队列再次检查是否有指令要在下一个tick上执行。这种检查和执行队列的模式将重复（循环）直到队列为空，并且不再期望有进一步的数据事件，此时Node进程退出。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion at [https://github.com/joyent/node/issues/5798](https://github.com/joyent/node/issues/5798)
    among some core Node developers about the `process.nextTick` and `setImmediate`
    implementations offers very precise information on how the event loop operates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/joyent/node/issues/5798](https://github.com/joyent/node/issues/5798)上，一些核心Node开发者关于`process.nextTick`和`setImmediate`实现的讨论提供了关于事件循环如何操作的非常精确的信息。
- en: 'The following are the sorts of I/O events fed into the queue:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些被喂入队列的I/O事件：
- en: '**Execution blocks**: These are blocks of JavaScript code comprising the Node
    program; they could be expressions, loops, functions, and so on. This includes
    `EventEmitter` events emitted within the current execution context.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行块**：这些是Node程序的JavaScript代码块；它们可以是表达式、循环、函数等。这包括在当前执行上下文中发出的`EventEmitter`事件。'
- en: '**Timers**: These are callbacks deferred to a time in the future specified
    in milliseconds, such as `setTimeout` and `setInterval`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器**: 这些是在未来某个时间点（以毫秒为单位）延迟执行的回调函数，例如`setTimeout`和`setInterval`。'
- en: '**I/O**: These are prepared callbacks returned to the main thread after being
    delegated to Node''s managed thread pool, such as filesystem calls and network
    listeners.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O**: 这些是在委托给Node的管理线程池（如文件系统调用和网络监听器）后返回主线程的准备好的回调函数。'
- en: '**Deferred execution blocks**: These are mainly the functions slotted on the
    stack according to the rules of `setImmediate` and `process.nextTick`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟执行块**: 这些主要是根据`setImmediate`和`process.nextTick`的规则在堆栈上定位的函数。'
- en: 'There are two important things to remember:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件重要的事情需要记住：
- en: You don't start and/or stop the event loop. The event loop starts as soon as
    a process starts and ends when no further callbacks remain to be performed. The
    event loop may, therefore, run forever.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能启动和/或停止事件循环。事件循环在进程启动时开始，在没有任何进一步回调需要执行时结束。因此，事件循环可能永远运行。
- en: The event loop executes on a single thread but delegates I/O operations to libuv,
    which manages a thread pool that parallelizes these operations, notifying the
    event loop when results are available. An easy-to-reason-about single-threaded
    programming model is reinforced with the efficiency of multithreading.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环在单个线程上执行，但将I/O操作委托给libuv，它管理一个线程池，并行化这些操作，并在结果可用时通知事件循环。通过多线程的效率强化了一个易于理解的单一线程编程模型。
- en: To learn more about how Node is bound to libuv and other core libraries, parse
    through the `fs` module code at [https://github.com/joyent/node/blob/master/lib/fs.js](https://github.com/joyent/node/blob/master/lib/fs.js).
    Compare the `fs.read` and the `fs.readSync` methods to observe the difference
    between how synchronous and asynchronous actions are implemented—note the `wrapper`
    callback that is passed to the native `binding.read` method in `fs.read`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Node如何绑定到libuv和其他核心库的信息，请解析`fs`模块代码[https://github.com/joyent/node/blob/master/lib/fs.js](https://github.com/joyent/node/blob/master/lib/fs.js)。比较`fs.read`和`fs.readSync`方法，以观察同步和异步操作实现的差异——注意传递给`fs.read`中本地`binding.read`方法的`wrapper`回调。
- en: To take an even deeper dive into the very heart of Node's design, including
    the queue implementation, read through the Node source at [https://github.com/joyent/node/tree/master/src](https://github.com/joyent/node/tree/master/src).
    Follow `MakeCallback` within `fs_event_wrap.cc` and `node.cc`. Investigate the
    `req_wrap` class, a wrapper for the V8 engine, deployed in `node_file.cc` and
    elsewhere and defined in `req_wrap.h`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解Node的设计核心，包括队列实现，请阅读Node源代码[https://github.com/joyent/node/tree/master/src](https://github.com/joyent/node/tree/master/src)。在`fs_event_wrap.cc`和`node.cc`中的`MakeCallback`跟踪，调查`req_wrap`类，它是V8引擎的包装器，在`node_file.cc`和其他地方部署，并在`req_wrap.h`中定义。
- en: The implications of Node's design on system architects
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node的设计对系统架构师的影响
- en: Node is a new technology. At the time of writing this, it has yet to reach its
    1.0 version. Security flaws have been found and fixed. Memory leaks have been
    found and fixed. Eran Hammer, mentioned at the beginning of this chapter, and
    his entire team at Walmart Labs actively contribute to the Node codebase—in particular
    when they find flaws! This is true of many other large companies committed to
    Node, such as PayPal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Node是一种新技术。在撰写本文时，它尚未达到1.0版本。已经发现并修复了安全漏洞。已经发现并修复了内存泄漏。在本章开头提到的Eran Hammer以及他在沃尔玛实验室的整个团队积极地为Node代码库做出贡献——特别是在他们发现漏洞时！许多其他致力于Node的大型公司也是如此，例如PayPal。
- en: If you have chosen Node, and your application has grown to such a size that
    you feel you need to read a book on how to deploy Node, you have the opportunity
    to not only benefit from the community, but have a part, perhaps, in literally
    designing aspects of the environment based on your particular needs. Node is open
    source, and you can submit pull requests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了Node，并且你的应用程序已经增长到这样一个规模，以至于你觉得你需要阅读一本关于如何部署Node的书，那么你不仅有从社区中受益的机会，也许还能在实际上基于你的特定需求设计环境的一些方面。Node是开源的，你可以提交pull请求。
- en: 'In addition to events, there are two key design aspects that are important
    to understand if you are going to do advanced Node work: build your systems out
    of small parts and use evented streams when piping data between them.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件之外，还有两个关键的设计方面，如果你打算进行高级Node工作，那么理解它们是很重要的：用小部分构建你的系统，并在它们之间传输数据时使用事件流。
- en: Building large systems out of small systems
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从小系统构建大型系统
- en: 'In his book, *The Art of Unix Programming*, Eric Raymond proposed the **Rule
    of Modularity**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《Unix编程艺术》中，埃里克·雷蒙德提出了**模块化法则**：
- en: '*"Developers should build a program out of simple parts connected by well-defined
    interfaces, so problems are local, and parts of the program can be replaced in
    future versions to support new features. This rule aims to save time on debugging
    complex code that is complex, long, and unreadable."*'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"开发者应该用简单部分构建程序，这些部分通过定义良好的接口连接，这样问题就是局部的，程序的某些部分可以在未来的版本中替换，以支持新功能。这个规则旨在节省调试复杂代码的时间，这些代码复杂、长且难以阅读。"*'
- en: This idea of building complex systems out of "small pieces, loosely joined"
    is seen in management theory, theories of government, manufacturing, and many
    other contexts. In terms of software development, it advises developers to contribute
    only the simplest, most useful component necessary within a larger system. Large
    systems are hard to reason about, especially if the boundaries of their components
    are fuzzy.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从“小部件，松散连接”构建复杂系统的想法在管理理论、政府理论、制造业和其他许多环境中都可以看到。在软件开发方面，它建议开发者在更大的系统中只贡献最简单、最有用的组件。大型系统难以推理，特别是如果它们的组件边界模糊的话。
- en: 'One of the primary difficulties when constructing scalable JavaScript programs
    is the lack of a standard interface to assemble a coherent program out of many
    smaller ones. For example, a typical web application might load dependencies using
    a sequence of `<script>` tags in the `<head>` section of a **HyperText Markup
    Language** (**HTML**) document:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可扩展的JavaScript程序时，主要困难之一是缺乏一个标准接口来将许多较小的程序组合成一个连贯的程序。例如，一个典型的Web应用程序可能会使用一系列的`<script>`标签在**超文本标记语言**（**HTML**）文档的`<head>`部分加载依赖项：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are many problems with this sort of system:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的系统存在许多问题：
- en: All potential dependencies must be declared prior to their being needed—dynamic
    inclusion requires complicated *hacks*.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有潜在的依赖项必须在需要之前声明——动态包含需要复杂的*技巧*。
- en: The introduced scripts are not forcibly encapsulated—nothing stops both files
    from writing to the same global object. Namespaces can easily collide, which makes
    arbitrary injection dangerous.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入的脚本没有被强制封装——没有任何东西阻止两个文件写入同一个全局对象。命名空间可以轻易冲突，这使得任意注入变得危险。
- en: '`fileA` cannot address `fileB` as a collection—an addressable context, such
    as `fileB.method`, isn''t available.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileA`不能将`fileB`作为一个集合来引用——没有可寻址的上下文，例如`fileB.method`是不可用的。'
- en: The `<script>` method itself isn't systematic, precluding the design of useful
    module services, such as dependency awareness and version control.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>`方法本身并不系统，这阻碍了设计有用的模块服务，如依赖项意识和版本控制。'
- en: Scripts cannot be easily removed or overridden.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本不能轻易地移除或覆盖。
- en: Because of these dangers and difficulties, sharing is not effortless, thus diminishing
    opportunities for collaboration in an open ecosystem.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些危险和困难，共享并非易事，从而减少了在开放生态系统中协作的机会。
- en: Ambivalently inserting unpredictable code fragments into an application frustrates
    attempts to predictably shape functionality. What is needed is a standard way
    to load and share discreet program modules.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中随意插入不可预测的代码片段会挫败预测性地塑造功能性的尝试。需要的是一种标准的方式来加载和共享离散的程序模块。
- en: 'Accordingly, Node introduced the concept of the **package**, following the
    CommonJS specification. A package is a collection of program files bundled with
    a manifest file describing the collection. Dependencies, authorship, purpose,
    structure, and other important metadata is exposed in a standard way. This encourages
    the construction of large systems from many small, interdependent systems. Perhaps,
    even more importantly, it encourages sharing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Node引入了**包**的概念，遵循CommonJS规范。包是一组程序文件，与描述集合的清单文件捆绑在一起。依赖项、作者、目的、结构和其他重要元数据以标准方式公开。这鼓励从许多小型、相互依赖的系统构建大型系统。也许更重要的是，它鼓励共享：
- en: '|   | *"What I''m describing here is not a technical problem. It''s a matter
    of people getting together and making a decision to step forward and start building
    up something bigger and cooler together."* |   |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   | *"我在这里描述的不是技术问题。这是人们聚在一起，做出决定，向前迈出一步，一起开始构建更大、更酷的东西的问题。" |   |'
- en: '|   | --*Kevin Dangoor, creator of CommonJS* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|   | --*CommonJS的创造者凯文·丹古尔* |'
- en: In many ways, the success of Node is due to the growth in the number and quality
    of packages available to the developer community that are distributed via Node's
    package management system, **npm**. This system has done much to help make JavaScript
    a viable, professional option for systems programming.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，Node的成功归功于开发者社区中通过Node的包管理系统**npm**分发的包的数量和质量的增长。这个系统在很大程度上帮助JavaScript成为系统编程的一个可行且专业的选择。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A good introduction to npm for anyone new to Node can be found at: [https://www.npmjs.org/doc/developers.html](https://www.npmjs.org/doc/developers.html).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node新用户来说，可以在以下链接找到对npm的良好介绍：[https://www.npmjs.org/doc/developers.html](https://www.npmjs.org/doc/developers.html)。
- en: Streams
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流
- en: 'In his book, *The C++ Programming Language, Third Edition*, Bjarne Stoustrup
    states:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的著作《C++编程语言，第三版》中，Bjarne Stroustrup表示：
- en: '*"Designing and implementing a general input/output facility for a programming
    language is notoriously difficult. […] An I/O facility should be easy, convenient,
    and safe to use; efficient and flexible; and, above all, complete."*'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"为编程语言设计并实现一个通用的输入/输出设施是出了名的困难。[...] 输入/输出设施应该易于使用、方便且安全；高效且灵活；最重要的是，完整。"*'
- en: It shouldn't surprise anyone that a design team focused on providing efficient
    and easy I/O has delivered such a facility through Node. Through a symmetrical
    and simple interface, which handles data buffers and stream events so that the
    implementer does not have to, Node's `Stream` module is the preferred way to manage
    asynchronous data streams for both internal modules and, hopefully, for the modules
    that developers will create.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专注于提供高效和简单I/O的设计团队通过Node提供这样的功能，这并不会让任何人感到惊讶。通过一个对称且简单的接口，该接口处理数据缓冲区和流事件，使得实现者无需自己处理，Node的`Stream`模块是管理异步数据流的优选方式，对于内部模块，以及开发者可能创建的模块来说，也是如此。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An excellent tutorial on the `Stream` module can be found at [https://github.com/substack/stream-handbook](https://github.com/substack/stream-handbook).
    Also, the Node documentation is comprehensive at [http://nodejs.org/api/stream.html](http://nodejs.org/api/stream.html).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/substack/stream-handbook](https://github.com/substack/stream-handbook)找到关于`Stream`模块的优秀教程。此外，Node文档在[http://nodejs.org/api/stream.html](http://nodejs.org/api/stream.html)上非常全面。
- en: A stream in Node is simply a sequence of bytes or, if you like, a sequence of
    characters. At any time, a stream contains a buffer of bytes, and this buffer
    has a length of zero or more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中，流简单地说是一系列字节，或者如果你愿意，是一系列字符。在任何时候，流都包含一个字节缓冲区，这个缓冲区的长度为零或更多。
- en: Because each character in a stream is well defined, and because every type of
    digital data can be expressed in bytes, any part of a stream can be redirected,
    or *piped*, to any other stream, different chunks of the stream can be sent to
    different handlers. In this way, stream input and output interfaces are both flexible
    and predictable and can be easily coupled.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流中的每个字符都有明确的定义，并且每种数字数据都可以用字节表示，因此流的任何部分都可以重定向，或*管道化*到任何其他流，流的不同部分可以发送到不同的处理器。这样，流输入和输出接口既灵活又可预测，并且可以轻松耦合。
- en: In addition to events, Node is distinctive for its comprehensive use of streams.
    Continuing the idea of composing applications out of many small processes emitting
    events or reacting to events, several Node I/O modules and features are implemented
    as streams. Network sockets, file readers and writers, stdin and stdout, Zlib,
    and so on, are all data producers and/or consumers that are easily connected through
    the abstract `Stream` interface. Those familiar with Unix pipes will see some
    similarities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件之外，Node以其对流的全面使用而独特。继续将应用程序组合成许多小进程，这些进程发出事件或对事件做出反应的想法，Node的几个I/O模块和功能都作为流实现。网络套接字、文件读取器和写入器、stdin和stdout、Zlib等，都是可以通过抽象的`Stream`接口轻松连接的数据生产者和/或消费者。熟悉Unix管道的人会看到一些相似之处。
- en: 'Five distinct base classes are exposed via the abstract `Stream` interface:
    `Readable`, `Writable`, `Duplex`, `Transform`, and `PassThrough`. Each base class
    inherits from `EventEmitter`, which we know to be an interface to which event
    listeners and emitters can be bound. Streams in Node are evented streams, and
    sending data between processes is commonly done using streams. Because streams
    can be easily chained and otherwise combined, they are fundamental tools for the
    Node developer.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象的`Stream`接口暴露了五个不同的基类：`Readable`、`Writable`、`Duplex`、`Transform`和`PassThrough`。每个基类都继承自`EventEmitter`，这是我们已知的事件监听器和发射器可以绑定到的接口。Node中的流是事件流，进程间数据传输通常使用流来完成。因为流可以轻松地链式连接和组合，它们是Node开发者的重要工具。
- en: It is recommended that you develop a clear understanding of what streams are
    and how they are implemented in Node before going further as we will use streams
    extensively throughout this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在进一步学习之前，对什么是流以及它们在Node中的实现有一个清晰的理解，因为我们将在这本书的整个过程中广泛使用流。
- en: Using full-stack JavaScript to maximum effect
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用全栈JavaScript发挥最大效用
- en: JavaScript has become a full-stack language. A native JavaScript runtime exists
    in all browsers. V8, the JavaScript interpreter used by Node, is the same engine
    powering Google's Chrome browser. And the language has gone even further than
    covering both the client and server layers of the software stack. JavaScript is
    used to query the CouchDB database, do map/reduce with MongoDB, and find data
    in ElasticSearch collections. The wildly popular **JavaScript Object Notation**
    (**JSON**) data format simply represents data as a JavaScript object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经成为一种全栈语言。所有浏览器都存在本地的JavaScript运行时。Node使用的JavaScript解释器V8，是谷歌Chrome浏览器背后的同一引擎。而且，该语言已经超越了覆盖软件栈的客户端和服务器层。JavaScript用于查询CouchDB数据库，使用MongoDB进行map/reduce，以及在ElasticSearch集合中查找数据。广受欢迎的**JavaScript对象表示法**（**JSON**）数据格式只是将数据表示为JavaScript对象。
- en: When different languages are used within the same application, the cost of *context
    switching* goes up. If a system is composed of parts described in different languages,
    the system architecture becomes more difficult to describe, understand, and extend.
    If different parts of a system *speak* differently, every cross-dialect conversation
    will require expensive translation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一应用程序中使用不同的语言时，上下文切换的成本会增加。如果一个系统由用不同语言描述的部分组成，那么系统架构就变得更加难以描述、理解和扩展。如果系统的不同部分“说”不同的语言，每次跨方言的对话都需要昂贵的翻译。
- en: Inefficiencies in comprehension lead to larger costs and more brittle systems.
    The members of the engineering team for this system must each be fluent in these
    many languages or be grouped by different skill sets; engineers are expensive
    to find and/or train. When the inner workings of significant parts of a system
    become opaque to all but a few engineers, it is likely that cross-team collaboration
    will decrease, making product upgrades and additions more difficult and likely
    leading to more errors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 理解上的低效会导致更高的成本和更脆弱的系统。这个系统的工程团队每个成员都必须精通这些多种语言，或者根据不同的技能组合成小组；工程师的寻找和/或培训成本高昂。当系统的关键部分对除了少数工程师之外的人都变得不透明时，跨团队协作很可能会减少，这使得产品升级和新增功能变得更加困难，并可能导致更多错误。
- en: What new opportunities open up when these difficulties are reduced or eliminated?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些困难减少或消除时，会打开哪些新的机会？
- en: Hot code
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热代码
- en: Because your clients and servers will speak the same language, each can pass
    code to be natively executed on the other. If you are building a web application,
    this opens up very interesting (and unique) opportunities.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的客户端和服务器将使用相同的语言，每个都可以将代码传递给对方以原生方式执行。如果你正在构建一个Web应用程序，这会打开非常有趣（且独特）的机会。
- en: For example, consider an application that allows one client to make changes
    to another's environment. This tool allows a software developer to make changes
    to the JavaScript powering a website and allows their clients to see those changes
    in real time in their browsers. What this application must do is transform live
    code in many browsers so that it reflects changes. One way to do this would be
    to capture a change set into a transform function, pass that function across to
    all connected clients, and have that function executed in their local environment,
    updating it to reflect the *canonical* view. One application evolves, it emits
    a *genetic* update in the code of JavaScript, and the rest of its species similarly
    evolves. We will use one such technology in [Chapter 7](ch07.html "Chapter 7. Deploying
    and Maintaining"), *Deploying and Maintaining*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个允许一个客户端对另一个环境进行更改的应用程序。这个工具允许软件开发者更改网站的 JavaScript，并允许他们的客户在浏览器中实时看到这些更改。这个应用程序必须做的事情是将实时代码在许多浏览器中转换，以便它反映更改。完成这一目标的一种方法是将更改集捕获到一个转换函数中，将该函数传递给所有连接的客户端，并在他们的本地环境中执行该函数，以更新它以反映
    *规范* 视图。一个应用程序在演变时，会在 JavaScript 代码中发出一个 *遗传* 更新，其余的物种也会类似地演变。我们将在 [第 7 章](ch07.html
    "第 7 章。部署和维护") *部署和维护* 中使用这种技术。
- en: Since Node shares the same JavaScript code base, a Node server, on its own initiative,
    can take this action. The network itself can broadcast code for its clients to
    execute. Similarly, clients can send code to the server for execution. It is easy
    to see how this allows hot code pushes, where a Node process sends a unique packet
    of raw JavaScript to specific clients for execution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node 共享相同的 JavaScript 代码库，Node 服务器可以主动采取此行动。网络本身可以向其客户端广播要执行的代码。同样，客户端也可以向服务器发送代码以执行。很容易看出这如何允许热代码推送，其中
    Node 进程向特定客户端发送一个唯一的原始 JavaScript 数据包以执行。
- en: When **Remote Procedure Calls** (**RPC**) no longer require a broker layer to
    translate between communicating contexts, code can exist anywhere in the network
    for as long or as brief a period as necessary and can execute in multiple contexts,
    which are chosen for reasons of load balancing, data awareness, computational
    power, geographic precision, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **远程过程调用** (**RPC**) 不再需要中介层来在通信上下文之间进行翻译时，代码可以在网络中的任何地方存在，所需的时间或短或长，并且可以在多个上下文中执行，这些上下文的选择基于负载均衡、数据意识、计算能力、地理精度等因素。
- en: Browserify
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Browserify
- en: JavaScript is the language common to Node and the browser. However, Node significantly
    extends the JavaScript language, adding many commands and other constructs that
    are not available to the client-side developer. For example, there is no equivalent
    of the core Node `Stream` module in JavaScript.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是 Node 和浏览器共有的语言。然而，Node 显著扩展了 JavaScript 语言，添加了许多客户端开发者不可用的命令和其他结构。例如，JavaScript
    中没有与核心 Node `Stream` 模块等效的模块。
- en: Additionally, the npm repository is rapidly growing, and, at the time of writing,
    contains more than 80,000 Node packages. Many of these packages are equally useful
    on the client as well as within Node. The spread of JavaScript to the server has,
    in effect, created two cooperating threads producing enterprise-grade JavaScript
    libraries and modules.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，npm 仓库正在迅速增长，在撰写本文时，包含超过 80,000 个 Node 包。其中许多包在客户端以及 Node 环境中同样有用。JavaScript
    传播到服务器实际上创建了两个协作线程，产生了企业级的 JavaScript 库和模块。
- en: '**Browserify** was developed to make it easy to share **npm** modules and core
    Node modules seamlessly with the client. Once a package has been *browserified*,
    it is easily imported into a browser environment using the standard `<script>`
    tag. Installing Browserify is simple:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Browserify** 的开发是为了使共享 **npm** 模块和核心 Node 模块变得容易，并且可以无缝地与客户端一起使用。一旦一个包被 *browserified*，它就可以使用标准的
    `<script>` 标签轻松地导入到浏览器环境中。安装 Browserify 非常简单：'
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s build an example. Create a file, `math.js`, written as you would write
    an npm module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个示例。创建一个文件，`math.js`，就像编写 npm 模块一样：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, create a program file, `add.js`, that uses this module:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个程序文件，`add.js`，它使用此模块：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing this program using Node on the command line (`> node add.js` ) will
    result in `4` being printed to your terminal. What if we wanted to use our math
    module in the browser? Client-side JavaScript doesn''t have a `require` statement,
    so we browserify it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 在命令行上执行此程序（`> node add.js`）将在您的终端上打印出 `4`。如果我们想在浏览器中使用我们的数学模块呢？客户端 JavaScript
    没有使用 `require` 语句，所以我们将其 browserify：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Browserify walks through your code, finding `require` statements and automatically
    bundling those dependencies (and the dependencies of those dependencies) into
    one file that you load into your client application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify会遍历您的代码，找到`require`语句，并将这些依赖（以及这些依赖的依赖）自动打包成一个文件，您可以将这个文件加载到您的客户端应用中：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As an added bonus, this bundle automatically introduces some useful Node globals
    to your browser environment: `__filename`, `__dirname`, `process`, `Buffer`, and
    `global`. This means you have, for example, `process.nextTick` available in the
    browser.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的奖励，这个包会自动将一些有用的Node全局变量引入到您的浏览器环境中：`__filename`、`__dirname`、`process`、`Buffer`和`global`。这意味着您在浏览器中可以使用例如`process.nextTick`。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The creator of Browserify, James Halliday, is a prolific contributor to the
    Node community. Visit him at [https://github.com/substack](https://github.com/substack).
    Also, there exists an online service for testing out browserified npm modules
    at http://requirebin.com. The full documentation can be found at [https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Browserify的创建者James Halliday是Node社区的活跃贡献者。您可以在[https://github.com/substack](https://github.com/substack)访问他。此外，还有一个在线服务可以测试browserified
    npm模块，网址为http://requirebin.com。完整文档可以在[https://github.com/substack/node-browserify#usage](https://github.com/substack/node-browserify#usage)找到。
- en: 'Another exciting project that, like Browserify, leverages Node to enhance the
    JavaScript available to browser-based JavaScript is **Component**. The authors
    describe it this way: *Component is currently a stopgap for ES6 modules and Web
    Components. When all modern browsers start supporting these features, Component
    will begin focusing more on semantic versioning and server-side bundling as browsers
    would be able to handle the rest*. The project is still in flux but worth a look.
    Here''s the link: [https://github.com/componentjs/guide](https://github.com/componentjs/guide).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人兴奋的项目，就像Browserify一样，利用Node来增强基于浏览器的JavaScript的功能，是**Component**。作者这样描述它：*Component目前是ES6模块和Web
    Components的临时解决方案。当所有现代浏览器开始支持这些功能时，Component将开始更多地关注语义版本控制和服务器端打包，因为浏览器将能够处理其余部分*。该项目仍在不断发展，但值得一观。以下是链接：[https://github.com/componentjs/guide](https://github.com/componentjs/guide)。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went on a whirlwind tour of Node. You learned something
    about why it is designed the way it is and why this event-driven environment is
    a good solution to modern problems in networked software. Having explained the
    event loop and the related ideas around concurrency and parallelism, we talked
    a bit about the Node philosophy of composing software from *small pieces loosely
    joined*. You learned about the special advantages that full-stack JavaScript provides
    and explored new possibilities of applications made possible because of them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了Node。您了解了一些关于它为什么被设计成这样的原因，以及为什么这种事件驱动环境是解决网络软件现代问题的良好解决方案。在解释了事件循环以及相关的并发和并行性概念之后，我们简要地讨论了Node的软件组合哲学，即从*小而松散连接的组件*构建软件。您了解了全栈JavaScript提供的特殊优势，并探索了由此带来的应用新可能性。
- en: You now have a good understanding of the kind of applications we will be deploying,
    and this understanding will help you see the unique concerns and considerations
    faced when building and maintaining Node applications. In the next chapter, we'll
    dive right in with building servers with Node, options for hosting these applications,
    and ideas around building, packaging, and distributing them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在对我们将要部署的应用类型有了很好的理解，这种理解将帮助您在构建和维护Node应用时看到独特的关注点和考虑因素。在下一章中，我们将直接进入使用Node构建服务器、托管这些应用的选项以及构建、打包和分发它们的想法。
