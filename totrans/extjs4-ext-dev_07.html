<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Input Field with Clear Button</h1></div></div></div><p>In this chapter we will go <a id="id275" class="indexterm"/>through Stephen Friedrich's <code class="literal">ClearButton</code> plugin. This plugin is targeted for text components that show a "clear" button over the text field. When the clear button is clicked on, the text field is emptied. Also, the icon image and its positioning can be controlled using CSS.</p><p>The topics covered are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional requirements</li><li class="listitem" style="list-style-type: disc">Planning and coding of the clear button</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Functional requirements</h1></div></div></div><p>We want a plugin that will help users to clear the text within the text components, such as <code class="literal">Ext.form.field.Text</code>, <code class="literal">Ext.form.field.TextArea</code>, <code class="literal">Ext.form.field.ComboBox</code>, and <code class="literal">Ext.form.field.Date</code>. The plugin should provide a button to click on in order to clear the text within a text component. This plugin should have several useful<a id="id276" class="indexterm"/> configuration options and CSS styles, where <a id="id277" class="indexterm"/>we can set our requirements, such as the clear button should always/only show up when the mouse enters within the input field, or it should be shown when the input field is empty or is cleared when the user presses <em>Esc</em>. The clear button can be customized for button image/position via CSS, and so on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Planning and coding of the clear button</h1></div></div></div><p>To develop this plugin we will first create the clear button that will be rendered over the text component, and <a id="id278" class="indexterm"/>will apply the CSS styles according to the configuration <a id="id279" class="indexterm"/>options. After that, we need to add several event handlers for the clear button, such as <code class="literal">click</code>, <code class="literal">mouseover</code>, <code class="literal">mouseout</code>, <code class="literal">mouseup</code>, and <code class="literal">mousedown</code>, and also, several event handlers for the text component, such as <code class="literal">destroy</code>, <code class="literal">resize</code>, <code class="literal">change</code>, <code class="literal">mouseover</code>, and <code class="literal">mouseout</code>. Let us now start coding:</p><div><pre class="programlisting">Ext.define('Examples.plugin.ClearButton', {
  alias : 'plugin.clearbutton',

  hideClearButtonWhenEmpty : true,
  hideClearButtonWhenMouseOut : true,
  animateClearButton : true,
  clearOnEscape : true,
  clearButtonCls : 'ext-ux-clearbutton',
  textField : null,
  animateWithCss3 : false,

  constructor : function(cfg) {
    Ext.apply(this, cfg);

    this.callParent(arguments);
  },

  init : function(textField) {
    this.textField = textField;
    if (!textField.rendered) {
      textField.on('afterrender', this.handleAfterRender, this);
    }
    else {
      this.handleAfterRender();
    }
  }</pre></div><p>In the preceding <a id="id280" class="indexterm"/>code snippet, you can see that we have defined <a id="id281" class="indexterm"/>several <a id="id282" class="indexterm"/>configuration options, and the required <a id="id283" class="indexterm"/>
<code class="literal">init</code> function.</p><p>Now let us<a id="id284" class="indexterm"/> define the <code class="literal">handleAfterRender</code> function:</p><div><pre class="programlisting">handleAfterRender : function(textField) {
  this.isTextArea = (this.textField.inputEl.dom.type.toLowerCase() == 'textarea');
  this.createClearButtonEl();
  this.addListeners();
  this.repositionClearButton();
  this.updateClearButtonVisibility();
  this.addEscListener();
}</pre></div><p>Within this <code class="literal">handleAfterRender</code> function, at first, we are checking whether the textfield is a <code class="literal">textarea</code> or not, as we need to handle <code class="literal">textarea</code> with custom functionality since this field may have a scrollbar. And then we call the <code class="literal">createClearButtonEl</code> function to create the element and the DOM for the clear button.</p><p>Now let us define <a id="id285" class="indexterm"/>the <code class="literal">createClearButtonEl</code> function:</p><div><pre class="programlisting">createClearButtonEl : function() {
  var animateWithClass = this.animateClearButton &amp;&amp;this.animateWithCss3;
  this.clearButtonEl = this.textField.bodyEl.createChild({
    tag : 'div',
    cls : this.clearButtonCls
  });
  if (this.animateClearButton) {
    this.animateWithCss3 = this.supportsCssTransition(this.clearButtonEl);
  }
  if (this.animateWithCss3) {
    this.clearButtonEl.addCls(this.clearButtonCls + '-off');
  }
  else {
    this.clearButtonEl.setStyle('visibility', 'hidden');
  }
}</pre></div><p>In the preceding<a id="id286" class="indexterm"/> function the clear button has been created and<a id="id287" class="indexterm"/> assigned an animation, based on the configuration <a id="id288" class="indexterm"/>options. In this function we also checked whether the browser supports CSS3 transitions or not, by calling the <code class="literal">supportsCssTransition</code> function.</p><p>Now, let us define<a id="id289" class="indexterm"/> the <code class="literal">supportsCssTransition</code> function:</p><div><pre class="programlisting">supportsCssTransition: function(el) {
  var styles = ['transitionProperty', 'WebkitTransitionProperty','MozTransitionProperty', 'OTransitionProperty','msTransitionProperty', 'KhtmlTransitionProperty'];

  var style = el.dom.style;
  for(var i = 0, length = styles.length; i &lt; length; ++i) {
    if(style[styles[i]] !== 'undefined') { 
      return true;
    }
  }
  return false;
}</pre></div><p>The next function we are calling within<a id="id290" class="indexterm"/> the <code class="literal">handleAfterRender</code> function is the <code class="literal">addListeners</code> function to add listeners to the field, its input element, and <a id="id291" class="indexterm"/>the clear button to handle resizing events such as <code class="literal">mouseover</code>, <code class="literal">mouseout</code>, and <code class="literal">click</code>.</p><p>Now, let us define <a id="id292" class="indexterm"/>the <code class="literal">addListeners</code> function:</p><div><pre class="programlisting">addListeners: function() { 
  var textField = this.textField;
  var bodyEl = textField.bodyEl;
  bodyEl.on('mouseover', this.handleMouseOverInputField, this);
  bodyEl.on('mouseout', this.handleMouseOutOfInputField, this);

  textField.on('destroy', this.handleDestroy, this);
  textField.on('resize', this.repositionClearButton, this);
  textField.on('change', function() {
    this.repositionClearButton();
    this.updateClearButtonVisibility();
  }, this);

  var clearButtonEl = this.clearButtonEl;
  clearButtonEl.on('mouseover', this.handleMouseOverClearButton,this);
  clearButtonEl.on('mouseout', this.handleMouseOutOfClearButton,this);
  clearButtonEl.on('mousedown', this.handleMouseDownOnClearButton,this);
    clearButtonEl.on('mouseup', this.handleMouseUpOnClearButton,this);
  clearButtonEl.on('click', this.handleMouseClickOnClearButton,this);
}</pre></div><p>Next <a id="id293" class="indexterm"/>we <a id="id294" class="indexterm"/>define<a id="id295" class="indexterm"/> the <code class="literal">mouseover</code> event handler – <code class="literal">handleMouseOverInputField</code>, and<a id="id296" class="indexterm"/> the <a id="id297" class="indexterm"/>
<code class="literal">mouseout</code> event handler – <code class="literal">handleMouseOutOfInputField</code>, for <code class="literal">bodyEl</code> of <code class="literal">textField</code>:</p><div><pre class="programlisting">handleMouseOverInputField: function(event, htmlElement, object) {
  this.clearButtonEl.addCls(this.clearButtonCls +'-mouse-over-input');
  if (event.getRelatedTarget() == this.clearButtonEl.dom) {
    this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-over-button');
    this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-down');
  }
  this.updateClearButtonVisibility();
},
handleMouseOutOfInputField: function(event, htmlElement, object) {
  this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-over-input');
  if (event.getRelatedTarget() == this.clearButtonEl.dom) { 
    this.clearButtonEl.addCls(this.clearButtonCls +'-mouse-over-button');
  }
  this.updateClearButtonVisibility();
}</pre></div><p>Now let us define the "destroy" event handler of <code class="literal">textField</code> since when the field is destroyed, we also need to destroy the clear button element to prevent memory leaks:</p><div><pre class="programlisting">handleDestroy: function() {
  this.clearButtonEl.destroy();
}</pre></div><p>Now let us start <a id="id298" class="indexterm"/>defining the<a id="id299" class="indexterm"/> handlers<a id="id300" class="indexterm"/> for the clear button's <code class="literal">mouseover</code>, <code class="literal">mouseout</code>, <code class="literal">mousedown</code>, <code class="literal">mouseup</code>, and <code class="literal">click</code> events:</p><div><pre class="programlisting">handleMouseOverClearButton: function(event, htmlElement, object) {
  event.stopEvent();
  if (this.textField.bodyEl.contains(event.getRelatedTarget())) {
    return;
  }
  this.clearButtonEl.addCls(this.clearButtonCls +'-mouse-over-button');
  this.updateClearButtonVisibility();
},

handleMouseOutOfClearButton: function(event, htmlElement, object){
  event.stopEvent();
  if (this.textField.bodyEl.contains(event.getRelatedTarget())) { 
    return;
  }
  this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-over-button');
    this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-down');
  this.updateClearButtonVisibility();
},

handleMouseDownOnClearButton: function(event, htmlElement,object){
  if (!this.isLeftButton(event)) {
    return;
  }
  this.clearButtonEl.addCls(this.clearButtonCls +'-mouse-down');
},

handleMouseUpOnClearButton: function(event, htmlElement, object) {
  if (!this.isLeftButton(event)) {
    return;
  }
  this.clearButtonEl.removeCls(this.clearButtonCls +'-mouse-down');
},

handleMouseClickOnClearButton: function(event, htmlElement, object) {
  if (!this.isLeftButton(event)) {
    return;
  }
  this.textField.setValue('');
  this.textField.focus();
}</pre></div><p>The next function we will <a id="id301" class="indexterm"/>call within the <code class="literal">handleAfterRender</code> function<a id="id302" class="indexterm"/> is the <code class="literal">repositionClearButton</code> function,<a id="id303" class="indexterm"/> to reposition the clear button element based on the <code class="literal">inputEl</code> element<a id="id304" class="indexterm"/> of <code class="literal">textField</code>. Now, let <a id="id305" class="indexterm"/>us define this function:</p><div><pre class="programlisting">repositionClearButton: function() {
  var clearButtonEl = this.clearButtonEl;
  if (!clearButtonEl) {
    return;
  }
  var clearButtonPosition = this.calculateClearButtonPosition(this.textField);
  clearButtonEl.dom.style.right = clearButtonPosition.right +'px';
  clearButtonEl.dom.style.top = clearButtonPosition.top + 'px';
}</pre></div><p>You can see that we get the clear button's position value by calling the <code class="literal">calculateClearButtonPosition</code> function<a id="id306" class="indexterm"/>. This function calculates the position of the clear button, based on the <code class="literal">inputEl</code> element of <code class="literal">textField</code>. Now, let us define this function:</p><div><pre class="programlisting">calculateClearButtonPosition: function(textField) {
  var positions = textField.inputEl.getBox(true, true);
  var top = positions.y;
  var right = positions.x;
  if (this.fieldHasScrollBar()) {
    right += Ext.getScrollBarWidth();
  }
  if (this.textField.triggerWrap) {
    right += this.textField.getTriggerWidth();
  }
  return {
    right: right,
    top: top
  };
}</pre></div><p>You can see that we checked whether the field has a scrollbar or not, and if the field has a scrollbar, we add the value of the <code class="literal">Ext.getScrollBarWidth </code>function to the <code class="literal">right</code> position. Now, let us define<a id="id307" class="indexterm"/> the <code class="literal">fieldHasScrollBar</code> function:</p><div><pre class="programlisting">fieldHasScrollBar: function() {
  if (!this.isTextArea) {
    return false;
  }

  var inputEl = this.textField.inputEl;
  var overflowY = inputEl.getStyle('overflow-y');
  if (overflowY == 'hidden' || overflowY == 'visible') {
    return false;
  }
  if (overflowY == 'scroll') {
    return true;
  }
  if (inputEl.dom.scrollHeight &lt;= inputEl.dom.clientHeight) {
    return false;
  }
  return true;
}</pre></div><p>And then <a id="id308" class="indexterm"/>we called the <code class="literal">updateClearButtonVisibility</code> function<a id="id309" class="indexterm"/> within the <code class="literal">handleAfterRender</code> function <a id="id310" class="indexterm"/>for fixing<a id="id311" class="indexterm"/> the clear button's visibility:</p><div><pre class="programlisting">updateClearButtonVisibility: function() {
  var oldVisible = this.isButtonCurrentlyVisible();
  var newVisible = this.shouldButtonBeVisible();

  var clearButtonEl = this.clearButtonEl;
  if (oldVisible != newVisible) {
    if(this.animateClearButton &amp;&amp; this.animateWithCss3) {
      this.clearButtonEl.removeCls(this.clearButtonCls +(oldVisible ? '-on' : '-off'));
      clearButtonEl.addCls(this.clearButtonCls + (newVisible ? '-on' : '-off'));
    }
    else {
      clearButtonEl.stopAnimation();
      clearButtonEl.setVisible(newVisible,this.animateClearButton);
    }

    clearButtonEl.setStyle('background-color',this.textField.inputEl.getStyle('background-color'));

    if (!(this.isTextArea &amp;&amp; Ext.isGecko) &amp;&amp; !Ext.isIE) {
      var deltaPaddingRight = clearButtonEl.getWidth() - this.clearButtonEl.getMargin('l');
      var currentPaddingRight = this.textField.inputEl.getPadding('r');
      var factor = (newVisible ? +1 : -1);
      this.textField.inputEl.dom.style.paddingRight = (currentPaddingRight + factor * deltaPaddingRight) + 'px';
    }
  }
}</pre></div><p>You can see that we took the value of the current visible state, and what will be the new visible state, by calling the <a id="id312" class="indexterm"/>
<code class="literal">isButtonCurrentlyVisible</code> and <code class="literal">shouldButtonBeVisible</code> functions<a id="id313" class="indexterm"/>. The<code class="literal"> isButtonCurrentlyVisible</code> function is a wrapper around <code class="literal">clearButtonEl.isVisible()</code> to handle the <code class="literal">setVisible</code> animation that may still <a id="id314" class="indexterm"/>be in progress, and the<code class="literal"> shouldButtonBeVisible</code> function<a id="id315" class="indexterm"/> checks the configuration options and the current mouse status to <a id="id316" class="indexterm"/>determine whether the clear button should be visible or not. Now, let <a id="id317" class="indexterm"/>us define these functions:</p><div><pre class="programlisting">isButtonCurrentlyVisible: function() {
  if (this.animateClearButton &amp;&amp; this.animateWithCss3) {
    return this.clearButtonEl.hasCls(this.clearButtonCls + '-on');
  } 
  var cachedVisible = Ext.core.Element.data(this.clearButtonEl.dom, 'isVisible');
  if (typeof(cachedVisible) == 'boolean') {
    return cachedVisible;
  }
  return this.clearButtonEl.isVisible();
},

shouldButtonBeVisible: function() {
  if (this.hideClearButtonWhenEmpty &amp;&amp; Ext.isEmpty(this.textField.getValue())) {

    return false;
  }

  var clearButtonEl = this.clearButtonEl;

  if (this.hideClearButtonWhenMouseOut &amp;&amp; !clearButtonEl.hasCls(this.clearButtonCls + '-mouse-over-button') &amp;&amp; !clearButtonEl.hasCls(this.clearButtonCls + '-mouse-over-input')) {

    return false;
  }

  return true;
}</pre></div><p>And the last function<a id="id318" class="indexterm"/> that we called within the <code class="literal">handleAfterRender</code> function is the <a id="id319" class="indexterm"/>
<code class="literal">addEscListener</code> function. What<a id="id320" class="indexterm"/> we need to do is, if the configuration option <code class="literal">clearOnEscape</code> is set to <code class="literal">true</code>, add<a id="id321" class="indexterm"/> a key listener that will clear this field. Now, let us define this <a id="id322" class="indexterm"/>function:</p><div><pre class="programlisting">addEscListener: function() {
  if (!this.clearOnEscape) {
    return;
  }

  this.textField.inputEl.on('keydown', function(e) {
    if (e.getKey() == Ext.EventObject.ESC) {
      if (this.textField.isExpanded) {
        return;
      }
      Ext.Function.defer(this.textField.setValue, 1,this.textField, ['']);
      e.stopEvent();
    }
  },
  this);
}</pre></div><p>The following screenshot is the output where we've used this plugin for <strong>textfield</strong>, <strong>textareafield</strong>, <strong>combobox</strong>, and the date field:</p><div><img src="img/3725OS_7_1.jpg" alt="Planning and coding of the clear button"/></div><p>You can see that on hovering over the <a id="id323" class="indexterm"/>
<strong>textfield</strong> component, the clear button is visible and clicking on <a id="id324" class="indexterm"/>this <a id="id325" class="indexterm"/>button will clear the<a id="id326" class="indexterm"/> respective field.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Summary</h1></div></div></div><p>In this chapter we've gone through an Ext JS plugin, which provides a clear button for text components to clear the content within it. We can see that developing a single plugin can be used in several types of components, and how easily we can inject the functionality of the plugin.</p><p>In the next chapter we will develop an Ext JS extension for a fancy animated message bar. The message bar will provide a facility to have a configurable duration timer for showing a message. It will have a close button, and it will also be able to show an "error" and a "successful" icon, beside the message.</p></div></body></html>