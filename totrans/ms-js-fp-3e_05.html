<html><head></head><body>
		<div><h1 id="_idParaDest-85" class="chapter-number"><a id="_idTextAnchor084"/>5</h1>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Programming Declaratively – A Better Style</h1>
			<p>Up to now, we haven’t really been able to appreciate the possibilities of <strong class="bold">functional programming</strong> (<strong class="bold">FP</strong>) as it pertains to working in a higher-level, declarative fashion. In this chapter, we will correct this and start producing shorter, more concise, and easier-to-understand code, by using some <strong class="bold">higher-order functions</strong> (<strong class="bold">HOFs</strong>) —that is, functions that take functions as parameters, such as the following:</p>
			<ul>
				<li><code>reduce()</code> and <code>reduceRight()</code> to apply an operation to a whole array, reducing it to a single result</li>
				<li><code>map()</code> to transform one array into another by applying a function to each of its elements</li>
				<li><code>flat()</code> to make a single array out of an array of arrays</li>
				<li><code>flatMap()</code> to mix together mapping and flattening</li>
				<li><code>forEach()</code> to simplify writing loops by abstracting the necessary looping code</li>
			</ul>
			<p>We’ll also be able to perform searches and selections with the following:</p>
			<ul>
				<li><code>filter()</code> to pick some elements from an array</li>
				<li><code>find()</code> and <code>findIndex()</code> to search for elements that satisfy a condition</li>
				<li>A pair of predicates, <code>every()</code> and <code>some()</code>, to check an array for a Boolean test</li>
			</ul>
			<p>Using these functions will let you work more declaratively, and you’ll see that your focus will shift to what you need to do and not so much to how it’s going to be done; the dirty details are hidden inside our functions. Instead of writing a series of possibly nested loops, we’ll focus on using functions as building blocks to specify our desired result.</p>
			<p>We will use these functions to work with events in a declarative style, as we’ll see in <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Design Patterns</em>, when we use the <strong class="bold">observer</strong> pattern. We will also be able to work in a <em class="italic">fluent</em> fashion, in which the output of a function becomes the input of the next one, a style we will look at later.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Transformations</h1>
			<p>The first set of operations that we<a id="_idIndexMarker268"/> are going to consider works on an array and processes it in the base of a function to produce certain results. There are several possible results: a single value with the <code>reduce()</code> operation, a new array with <code>map()</code>, or just about any kind of result with <code>forEach()</code>.</p>
			<p class="callout-heading">Caring about inefficiency</p>
			<p class="callout">If you google around, you will find some articles declaring that these functions are inefficient because a loop done by hand can be faster. This, while possibly true, is practically irrelevant. Unless your code really suffers from speed problems and you can determine that the slowness derives from using these HOFs, trying to avoid them using longer code, with a higher probability of bugs, simply doesn’t make much sense.</p>
			<p>Let’s start by considering the preceding list of functions in order, beginning with the most general of all, which, as we’ll see, can even be used to emulate the rest of the transformations in this chapter!</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Reducing an array to a value</h2>
			<p>Answer this question: how many<a id="_idIndexMarker269"/> times have you had to loop through an array, performing an operation (say, summing) to produce a single value (maybe the sum of all the array values) as a result? Probably many, many, many times. This kind of operation can usually be implemented functionally by applying <code>reduce()</code> and <code>reduceRight()</code>. Let’s start with the former!</p>
			<p class="callout-heading">To fold or not to fold</p>
			<p class="callout">Time for some terminology! In usual FP<a id="_idIndexMarker270"/> parlance, we speak of <code>reduce()</code> is <code>reduceRight()</code> is correspondingly <a id="_idIndexMarker271"/>known as <strong class="bold">foldr</strong>. In category theory terms, both <a id="_idIndexMarker272"/>operations are <strong class="bold">catamorphisms</strong>: the reduction of all the values in a container down to a single result.</p>
			<p>The inner <a id="_idIndexMarker273"/>workings of the <code>reduce()</code> function are illustrated in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_5.1_B19301.jpg" alt="Figure 5.1 – The workings of the reduce() operation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The workings of the reduce() operation</p>
			<p>See how <code>reduce()</code> traverses the array, applying a reducing function to each element and the accumulated value.</p>
			<p>Why should you always try to use <code>reduce()</code> or <code>reduceRight()</code> instead of hand-coded loops? The following<a id="_idIndexMarker274"/> points might answer this question:</p>
			<ul>
				<li>All the aspects of loop control are <a id="_idIndexMarker275"/>automatically taken care of, so you don’t even have the possibility of an off-by-one mistake</li>
				<li>The initialization and handling of the result values are also done implicitly</li>
				<li>Unless you work really hard at being impure and modifying the original array, your code will be free of side-effects</li>
			</ul>
			<p>Now that we can <code>reduce()</code> an array, let’s <a id="_idIndexMarker276"/>see some of its practical use cases.</p>
			<h3>Summing an array</h3>
			<p>The most <a id="_idIndexMarker277"/>common example of the application of <code>reduce()</code>, usually seen in all textbooks and on all web pages, is the summing of all of the elements of an array. So, to keep with tradition, let’s start with precisely this example!</p>
			<p>To reduce an<a id="_idIndexMarker278"/> array, you must<a id="_idIndexMarker279"/> provide a <strong class="bold">dyadic</strong> function (a function with two parameters; <strong class="bold">binary</strong> would be another name for that) and an initial value. In our case, the <a id="_idIndexMarker280"/>function will sum up its two arguments. Initially, the function will be applied to the provided initial value and the first element of the array. For us, the initial value to provide is a zero, and the first result will be the first element itself. Then, the function will be applied again, this time, to the result of the previous operation and the second element of the array, and so the second result will be the sum of the first two elements of the array. Progressing in this fashion along the whole array, the final result will be the sum of all its elements:</p>
			<pre class="source-code">
// sum.ts
const myArray = [22, 9, 60, 12, 4, 56];
const sum = (x: number, y: number): number =&gt; x + y;
const mySum = myArray.reduce(<strong class="bold">sum</strong>, <strong class="bold">0</strong>); // 163</pre>
			<p>You don’t actually need the sum definition—you could have just written <code>myArray.reduce((x,y) =&gt; x+y, 0)</code>—however, when written in this fashion, the meaning of the code is clearer: you want to reduce the array to a single value by <code>sum</code>-ming all its elements. (Would we be forgetting data types with this? No; TypeScript can deduce all the implied types on its own.)</p>
			<p>Instead of writing out the loop, initializing a variable to hold the result of the calculations, and going through the array doing the sums, you just declare which operation should be performed. This is what I meant when I said that programming with functions such as those we’ll see in this chapter allows you to work more declaratively, focusing on what rather than how.</p>
			<p>You can also even use <code>reduce()</code> without providing the initial value: if you skip it, the first value of the array will be used, and the internal loop will start with the second element of the <a id="_idIndexMarker281"/>array; however, be careful if the array is empty and you skipped providing an initial value, as you’ll get a runtime error! See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a> for more details.</p>
			<p>We can change the reducing function to see how it progresses through its calculations by just including a little bit of impurity!</p>
			<pre class="source-code">
// continued...
const sumAndLog = (x: number, y: number): number =&gt; {
<strong class="bold">  console.log(`${x}+${y}=${x + y}`);</strong>
  return x + y;
};
myArray.reduce(sumAndLog, 0);</pre>
			<p>The output would be as follows:</p>
			<pre class="console">
0+22=22
22+9=31
31+60=91
91+12=103
103+4=107
107+56=163</pre>
			<p>You can see how the first sum was done by adding the initial value (<code>0</code>) and the first element of the array, how that result was used in the second addition, and so on.</p>
			<p class="callout-heading">What’s in a name?</p>
			<p class="callout">Part of the reason for the <em class="italic">foldl</em> name seen previously (at least, its ending, <em class="italic">l</em>) should now be clear: the reducing operation proceeds from left to right, from the first element to the last. You may wonder, however, how it would have been named if it had been defined by a right-to-left language (such as Arabic, Hebrew, Farsi, or Urdu) speaker!</p>
			<p>This example is common<a id="_idIndexMarker282"/> and well known; let’s do something more complicated. As we’ll find out, <code>reduce()</code> will be quite useful for many different<a id="_idIndexMarker283"/> objectives!</p>
			<h3>Calculating an average</h3>
			<p>Let’s do a bit more work. How do <a id="_idIndexMarker284"/>you calculate the average of a list of numbers? If you were explaining this to someone, your answer would surely be something such as <em class="italic">sum all the elements in the list and divide that by the number of elements</em>. In programming terms, this is not a procedural description (you don’t explain how to sum elements or traverse the array) but rather a declarative one since you say what to do, not how.</p>
			<p>We can transform that description of the calculation into an almost self-explanatory function (In the <em class="italic">Averaging arrays</em> section of the next chapter, we’ll extend arrays to include an averaging method, based on this code.):</p>
			<pre class="source-code">
// average.ts
const myArray = [22, 9, 60, 12, 4, 56];
const sum = (x: number, y: number): number =&gt; x + y;
const average = (arr: number[]): number =&gt;
<strong class="bold">  arr.reduce(sum, 0) / arr.length;</strong>
console.log(average(myArray)); // 27.166667</pre>
			<p>The definition of <code>average()</code> follows what a verbal explanation would be: sum the elements of the array, starting from 0, and divide by the array’s length—simpler: impossible!</p>
			<p class="callout-heading">Not-so-safe reducing</p>
			<p class="callout">As we mentioned in the previous section, you could also have written <code>arr.reduce(sum)</code> without specifying the initial value (<code>0</code>) for the reduction; it’s even shorter and closer to the verbal description of the required calculation. This, however, is less safe, because it would fail (producing a runtime error) should the array be empty. So, it’s better to always provide the starting value.</p>
			<p>This isn’t, however, the<a id="_idIndexMarker285"/> only way of calculating the average. The reducing function also gets passed the index of the current position of the array as well as the array itself, so you could do something different from last time:</p>
			<pre class="source-code">
// continued...
const sumOrDivide = (
  sum: number,
  val: number,
  ind: number,
  arr: number[]
) =&gt; {
  sum += val;
  return <strong class="bold">ind == arr.length - 1 ? sum / arr.length : sum</strong>;
};
const average2 = (arr: number[]): number =&gt;
  arr.reduce(sumOrDivide, 0);
console.log(myArray.reduce(average2, 0)); // 27.166667</pre>
			<p>Given the current index (and, obviously, having access to the array’s length), we can do some trickery: in this case, our reducing <code>sumOrDivide()</code> function always sums values, but at the end of the array, it throws in a division so that the average value of the array will be returned. This is slick, but from the point of view of legibility, we can agree that the first version we saw was more declarative and closer to the mathematical definition than this second version.</p>
			<p class="callout-heading">Impurity warning!</p>
			<p class="callout">Getting the array and the index means you could also turn the function into an impure one. Avoid this! Anybody who sees a <code>reduce()</code> call will automatically assume it’s a pure function and will surely introduce bugs when using it.</p>
			<p>This example and the previous one required calculating a single result, but it’s possible to go beyond this and calculate<a id="_idIndexMarker286"/> several values in a single pass. Let’s see how.</p>
			<h3>Calculating several values at once</h3>
			<p>What would you do if<a id="_idIndexMarker287"/> you needed to calculate two or more results instead of a single value? This would seem to be a case for providing a clear advantage for standard loops, but there’s a trick that you can use. Let’s yet again revisit the average calculation. We could do it the old-fashioned way by looping and simultaneously summing and counting all the numbers. Well, <code>reduce()</code> only lets you produce a single result, but there’s no reason you can’t return an object with as many fields as desired, as we did in the <em class="italic">Impure functions</em> section in <a href="B19301_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a><em class="italic">, </em><em class="italic">Behaving Properly</em>:</p>
			<pre class="source-code">
// continued...
const average3 = (arr: number[]): number =&gt; {
  const sc = arr.reduce(
    <strong class="bold">(ac, val) =&gt; ({</strong>
<strong class="bold">      sum: val + ac.sum,</strong>
<strong class="bold">      count: ac.count + 1,</strong>
<strong class="bold">    })</strong>,
    <strong class="bold">{ sum: 0, count: 0 }</strong>
  );
  return <strong class="bold">sc.sum / sc.count</strong>;
};
console.log(average3(myArray)); // 27.166667</pre>
			<p>Scrutinize the code carefully. We need two variables: one for the sum and one for the count of all numbers. We provide an object as the initial value for the accumulator, with two properties set to <code>0</code>, and our reducing function updates those two properties. After getting the final result with both <code>sum</code> and <code>count</code>, we divide to get the desired average.</p>
			<p>By the way, there are options other than using an object. You could also produce any other data structure; let’s see an example with a tuple. The resemblance is pretty obvious:</p>
			<pre class="source-code">
// continued...
const average4 = (arr: number[]) =&gt; {
  const sc = arr.reduce(
    <strong class="bold">(ac, val) =&gt; [ac[0] + val, ac[1] + 1]</strong>,
    <strong class="bold">[0, 0]</strong>
  );
  return <strong class="bold">sc[0] / sc[1]</strong>;
};
console.log(average4(myArray)); // 27.166667</pre>
			<p>To be frank, I think it’s way more obscure than the solution with the object. Consider this an alternative (and <a id="_idIndexMarker288"/>not well-recommended) way of calculating many values simultaneously!</p>
			<p>We have now seen several examples of the use of <code>reduce()</code>, so it’s high time to meet a variant of it, <code>reduceRight()</code>, which works similarly.</p>
			<h3>Folding left and right</h3>
			<p>The complementary <code>reduceRight()</code> method works just as <code>reduce()</code> does, only starting at the end and <a id="_idIndexMarker289"/>looping until the beginning <a id="_idIndexMarker290"/>of the array. (Read more about <code>reduceRight()</code> at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight</a>.) For many operations (such as the calculation of averages that we saw previously), this makes no difference, but there are some cases in which it will. See <em class="italic">Figure 5</em><em class="italic">.2</em>.</p>
			<p>We shall be seeing a clear case of this in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>; let’s go with a simpler example here:</p>
			<div><div><img src="img/Figure_5.2_B19301.jpg" alt="Figure 5.2 – The reduceRight() operation works the same way as reduce(), but in reverse order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The reduceRight() operation works the same way as reduce(), but in reverse order</p>
			<p>Suppose that we want to implement a function to reverse a string. (And, obviously, also that we don’t know that<a id="_idIndexMarker291"/> JavaScript already provides a <code>reverse()</code> method!) A <a id="_idIndexMarker292"/>solution could be to transform the string into an array by using <code>split()</code>, then reversing that array, and finally using <code>join()</code> to make it whole again:</p>
			<pre class="source-code">
// reverse.ts
const reverseString = (str: string): string =&gt; {
  const arr = str.split("");
  arr.reverse();
  return arr.join("");
};
console.log(reverseString("MONTEVIDEO"));  // OEDIVETNOM</pre>
			<p>This solution works (and yes, it can be shortened, but that’s not the point here), but let’s do it in another way, just to experiment with <code>reduceRight()</code>:</p>
			<pre class="source-code">
// continued...
const reverseString2 = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight((x, y) =&gt; x + y, "")</strong>;
console.log(reverseString2("OEDIVETNOM")); // MONTEVIDEO</pre>
			<p>Note that we didn’t need to specify data types for the reducing function; just like earlier in this chapter, TypeScript was able to figure them out. Also, if you like to re-use code, look at <em class="italic">Question 5.2</em>!</p>
			<p>From the previous examples, you can <a id="_idIndexMarker293"/>also get an idea: if you first apply <code>reverse()</code> to an array and then use <code>reduce()</code>, the effect will be the same as if you had just applied <code>reduceRight()</code> to the original array. There is only one point to take into account: <code>reverse()</code> alters the given array, so you would be causing an unintended side-effect by reversing the original array! The only way out would be to first generate a copy of the array and only then do<a id="_idIndexMarker294"/> the rest. Too much work, so it’s best to use <code>reduceRight()</code>!</p>
			<p>However, we can draw another conclusion, showing a result we had foretold: it is possible, albeit more cumbersome, to use <code>reduce()</code> to simulate the same result as <code>reduceRight()</code>—and in later sections, we’ll also use it to emulate the other functions in the chapter. Let’s now<a id="_idIndexMarker295"/> move on to another common and powerful operation: <strong class="bold">mapping</strong>.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Applying an operation – map()</h2>
			<p>Processing lists of elements <a id="_idIndexMarker296"/>and applying some kind of operation to each of them is a quite common pattern in computer programming. Writing loops that <a id="_idIndexMarker297"/>systematically go through all the elements in an array or collection, starting at the first and looping until finishing with the last, and performing some kind of process on each of them is a basic coding exercise, usually learned in the first days of all programming courses. We already saw one such kind of operation in the previous section with <code>reduce()</code> and <code>reduceRight()</code>; let’s now turn to a new one, called <code>map()</code>.</p>
			<p>In mathematics, a <code>map()</code> function transforms an array of inputs into an array of outputs.</p>
			<p class="callout-heading">Names, names, names…</p>
			<p class="callout">Some more terminology: we would say that an <a id="_idIndexMarker300"/>array is a <strong class="bold">functor</strong> because it provides a mapping operation with some prespecified properties, which we shall see later. And, in category theory, which we’ll talk about a little in <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, the mapping operation itself would be <a id="_idIndexMarker301"/>called a <strong class="bold">morphism</strong>.</p>
			<p>The inner workings of the <code>map()</code> operation can be seen in <em class="italic">Figure 5</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_5.3_B19301.jpg" alt="Figure 5.3 – The map() operation transforms each element of the input array by applying a mapping function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The map() operation transforms each element of the input array by applying a mapping function</p>
			<p class="callout-heading">More maps available</p>
			<p class="callout">The jQuery library provides<a id="_idIndexMarker302"/> a function, <code>$.map(array, callback)</code>, that is <a id="_idIndexMarker303"/>similar to the <code>map()</code> method. Be careful, though, because there are important differences. The jQuery function processes the undefined values of the array, while <code>map()</code> skips them. Also, if the applied function produces an array as its result, jQuery flattens it and adds each of its individual elements separately, while <code>map()</code> just includes those arrays in the result. Underscore, and Ramda also provide similar functions. Finally, JavaScript itself provides an alternative way of doing <code>map()</code>: check out the <code>Array.from()</code> method at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a> and pay special attention to its second argument!</p>
			<p>What are the advantages<a id="_idIndexMarker304"/> of using <code>map()</code> over using a straightforward<a id="_idIndexMarker305"/> loop?</p>
			<ul>
				<li>First, you don’t have to write any loops, so that’s one less possible source of bugs</li>
				<li>Second, you don’t even have to access the original array or the index position, even though they are there for you to use if you really need them</li>
				<li>Lastly, a new array is produced, so your code is pure (although, of course, if you really want to produce side effects, you can!)</li>
			</ul>
			<p>There are only two caveats when doing this:</p>
			<ul>
				<li>Always return<a id="_idIndexMarker306"/> something from your mapping function. If you forget this, then you’ll just produce an array filled with <code>undefined</code> values, because JavaScript always provides a default <code>return undefined</code> for all functions.</li>
				<li>If the input array elements are objects or arrays, and you include them in the output array, then JavaScript will still allow the original elements to be accessed.</li>
			</ul>
			<p>Also, there’s a restriction. In JavaScript, <code>map()</code> is basically available only for arrays (you can read more about this at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a>); however, in the <em class="italic">Extending current data types</em> section in <a href="B19301_12.xhtml#_idTextAnchor221"><em class="italic">Chapter 12</em></a>, <em class="italic">Building Better Containers</em>, we will learn how to make it available for other basic types, such as numbers, Booleans, strings, and even functions. Also, libraries such as Lodash, Underscore, and Ramda, provide similar functionalities.</p>
			<p>As we did earlier with <code>reduce()</code>, let’s now look at some examples of the use of <code>map()</code> for common processes so that you’ll better appreciate its power and convenience.</p>
			<h3>Extracting data from objects</h3>
			<p>Let’s start with a simple example. Suppose that we have some geographic data (as shown in the following snippet) related to<a id="_idIndexMarker307"/> some South American countries and the coordinates (latitude and longitude) of their capitals. Let’s say that we want to calculate the average position of those cities. (No, I don’t have a clue why we’d want to do that.) How would we go about it?</p>
			<pre class="source-code">
// average.ts
const markers = [
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BO", lat: -16.5, lon: -68.1 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  { name: "CL", lat: -33.4, lon: -70.7 },
  { name: "CO", lat:   4.6, lon: -74.0 },
  { name: "EC", lat:  -0.3, lon: -78.6 },
  { name: "PE", lat: -12.0, lon: -77.0 },
  { name: "PY", lat: -25.2, lon: -57.5 },
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "VE", lat:  10.5, lon: -66.9 },
];</pre>
			<p class="callout-heading">A lot of negativity?</p>
			<p class="callout">In case you are wondering whether all the data is negative and if so, why, it’s because the countries shown here are all south of the Equator and west of the Greenwich Meridian. However, some South American countries, such as Colombia and Venezuela, have positive latitudes. We’ll return to these data a little later when we study the <code>some()</code> and <code>every()</code> methods.</p>
			<p>We would want to use our <code>average()</code> function (which we developed earlier in this chapter), but there is a problem: that function can only be applied to an array of <em class="italic">numbers</em>, and what we have here is an array of <em class="italic">objects</em>. We can, however, do a trick: we can focus on calculating the average latitude (we can deal with the longitude later, in a similar fashion). We can map each element of the array to its latitude, and we would then have an appropriate input for <code>average()</code>. The solution would be something like the following:</p>
			<pre class="source-code">
// continued...
const averageLat = average(<strong class="bold">markers.map((x) =&gt; x.lat)</strong>);
const averageLon = average(<strong class="bold">markers.map((x) =&gt; x.lon)</strong>);
console.log(averageLat, averageLon); // -15.76, -65.53</pre>
			<p>Mapping an array to<a id="_idIndexMarker308"/> extract data is powerful, but you must be careful. Let’s now look at a case that seems right but produces incorrect results!</p>
			<h3>Parsing numbers tacitly</h3>
			<p>Working with <code>map()</code> is usually far safer <a id="_idIndexMarker309"/>and simpler than looping by hand, but some edge cases may trip you up. Say you received an array of strings representing numeric values and wanted to parse them into actual numbers. Can you explain the following results?</p>
			<pre class="source-code">
["123.45", "67.8", "90"].map(parseFloat);
// [123.45, 67.8, 90]
["123.45", "-67.8", "90"].map(parseInt);
// [123, <strong class="bold">NaN</strong>, <strong class="bold">NaN</strong>]</pre>
			<p>Let’s analyze the results. When we used <code>parseFloat()</code> to get floating-point results, everything was OK; however, when we wanted to truncate the results to integer values with <code>parseInt()</code>, the output was really awry, and weird <code>NaN</code> values appeared. What happened?</p>
			<p>The answer lies in a problem with tacit programming. (We have already seen some uses of tacit programming in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>, and we’ll see more in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>.) When you don’t explicitly show the parameters to a function, it’s easy for there to be oversights. Look at the following code, which will lead us to the solution:</p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(<strong class="bold">(x) =&gt; parseFloat(x)</strong>);
// [123.45, -67.8, 90]
["123.45", "-67.8", "90"].map(<strong class="bold">(x) =&gt; parseInt(x)</strong>);
// [123, -67, 90]</pre>
			<p>The reason for the unexpected behavior with <code>parseInt()</code> is that this function can also receive a second parameter—namely, the radix to use when converting the string into a number. For instance, a call such as <code>parseInt("100010100001", 2)</code> will convert a binary number of <code>100010100001</code> into a decimal.</p>
			<p class="callout-heading">Note:</p>
			<p class="callout">You can read more about <code>parseInt()</code> at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a>, where the radix parameter is explained in detail. You should always provide it because some browsers might interpret strings with a leading zero to be octal, which would once again produce unwanted results.</p>
			<p>So, what happens<a id="_idIndexMarker310"/> when we provide <code>parseInt()</code> to <code>map()</code>? Remember that <code>map()</code> calls your mapping function with three parameters: the array element value, its index, and the array itself. When <code>parseInt</code> receives these values, it ignores the array but assumes that the provided index is actually a radix, and <code>NaN</code> values are produced since the original strings are not valid numbers in the given radix.</p>
			<p>OK, some functions can lead you astray when mapping, and you now know what to look for. Let’s keep enhancing the way we work by using ranges to write code that would usually require a hand-written loop.</p>
			<h3>Working with ranges</h3>
			<p>Let’s now turn to a helper function, which <a id="_idIndexMarker311"/>will come in handy for many uses. We want a <code>range(start,stop)</code> function that generates an array of numbers, with values ranging from <code>start</code> (inclusive) to <code>stop</code> (exclusive):</p>
			<pre class="source-code">
// range.ts
const range = (start: number, stop: number): number[] =&gt;
  new Array(stop - start).fill(0).map((v, i) =&gt; start + i);
range(2, 7); // [2, 3, 4, 5, 6]</pre>
			<p>Why <code>fill(0)</code>? Undefined array elements are skipped by <code>map()</code>, so we need to fill them with something or our code will have no effect.</p>
			<p class="callout-heading">Expanding your range</p>
			<p class="callout">Libraries such as Underscore and Lodash provide a more powerful version of our <code>range()</code> function, letting us go in ascending or descending order and also specifying the step to use—as in <code>_.range(0, -8, -2)</code>, which produces <code>[0, -2, -4, -6]</code>—but for our needs, the version we wrote is enough. Refer to the <em class="italic">Questions</em> section at the end of this chapter.</p>
			<p>How can we use it? In the following section, we’ll see some uses for controlled looping with <code>forEach()</code>, but we can redo our factorial function by applying <code>range()</code> and then <code>reduce()</code>. The idea of this is to generate all the numbers from 1 to <code>n</code> and then multiply them together:</p>
			<pre class="source-code">
// continued...
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce((x, y) =&gt; x * y, 1);</pre>
			<p>It’s important to check the<a id="_idIndexMarker312"/> border cases, but the function also works for zero; can you see why? The reason for this is that the produced range is empty: the call is <code>range(1,1)</code>, which returns an empty array. Then, <code>reduce()</code> doesn’t do any calculations and returns the initial value (<code>1</code>), which is correct.</p>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><em class="italic">Chapter 7</em></a>, <em class="italic">Transforming Functions</em>, we’ll have the opportunity to use <code>range()</code> to generate source code; check out the <em class="italic">Currying with eval()</em> and <em class="italic">Partial application with </em><em class="italic">eval()</em> sections.</p>
			<p>You could use these numeric ranges to produce other kinds of ranges. For example, should you need an array with the alphabet, you could certainly (and tediously) write <code>["A", "B", "C"</code>... up to ...<code>"X", "Y", "Z"]</code>. A simpler solution would be to generate a range with the ASCII codes for the alphabet and map those to letters:</p>
			<pre class="source-code">
// continued...
const ALPHABET = range(
  "A".charCodeAt(0),
  "Z".charCodeAt(0) + 1
).map(<strong class="bold">(x) =&gt; String.fromCharCode(x)</strong>);
// ["A", "B", "C", ... "X", "Y", "Z"]</pre>
			<p>Note the use of <code>charCodeAt()</code> to get the ASCII codes for the letters and <code>String.fromCharCode(x)</code> to transform the ASCII code into a character.</p>
			<p>Mapping is very important and often <a id="_idIndexMarker313"/>used, so let’s now analyze how you could implement it on your own, which could help you develop code for more complex cases.</p>
			<h3>Emulating map() with reduce()</h3>
			<p>Earlier in this chapter, we saw how <code>reduce()</code> could be used to implement <code>reduceRight()</code>. Now, let’s see how <code>reduce()</code> can also be used to provide a polyfill for <code>map()</code> (not that you will<a id="_idIndexMarker314"/> need it because nowadays, browsers offer both methods, but it will give you more of an idea of what you can achieve with these tools).</p>
			<p>Our own <code>myMap()</code> is a one-liner but can be hard to understand. We apply the function to each element of the array and use <code>concat()</code> to append the result to a result array (which is initially empty). When the loop finishes working with the input array, the result array will have the desired output values. Let’s first see a plain JavaScript version before getting to data typing:</p>
			<pre class="source-code">
// map.js
const myMap = (arr, fn) =&gt;
  arr.reduce((x, y) =&gt; x.concat(fn(y)), []);</pre>
			<p>We apply the mapping function to each array element, one by one, and we concatenate the result to the accumulated output array.</p>
			<p>Let’s test this with an array and a simple function. We will use both the original <code>map()</code> method and <code>myMap()</code>, and the results should match! Our mapping function will return double its input:</p>
			<pre class="source-code">
// continued...
const dup = (x: number): number =&gt; 2 * x;
console.log(<strong class="bold">myMap(myArray, dup)</strong>);
console.log(<strong class="bold">myArray.map(dup)</strong>);
// [44, 18, 120, 24, 8, 112] both times</pre>
			<p>The first log shows the expected result, produced by <code>map()</code>. The second output gives the same result, so it seems that <code>myMap()</code> works! And the final output is just to check that the original input array wasn’t modified in any way; mapping operations should always produce a new array. See <em class="italic">Question 5.3</em> for testing our <code>myMap()</code> function more thoroughly.</p>
			<p>Let’s review our <code>myMap()</code> function <a id="_idIndexMarker315"/>and add typing. The needed data types are more complex, and we’ll have a generic function:</p>
			<pre class="source-code">
// map.ts
const myMap = <strong class="bold">&lt;T, R&gt;</strong>(arr: <strong class="bold">T[]</strong>, fn: <strong class="bold">(x: T) =&gt; R</strong>): <strong class="bold">R[]</strong> =&gt;
  arr.reduce(
    (x: R[], y: T): R[] =&gt; x.concat(fn(y)),
    [] as R[]
  );</pre>
			<p>Our <code>myMap()</code> function receives an array of elements of type <code>T</code> and an <code>fn()</code> mapping function that transforms its <code>T</code> argument into an <code>R</code>-type result. The result of this mapping is an array of <code>R</code>-type elements. Examine the accumulator function by yourself; is its typing understandable?</p>
			<p>Let’s try a different mapping function to verify that our typing is correct.  We’ll use one that returns strings instead of numbers – it just adds dashes before and after its input, to produce a string.</p>
			<pre class="source-code">
// continued...
const addDashes = (x: number): string =&gt; `-${x}-`;
const myDashes = myArray.map(<strong class="bold">addDashes</strong>);
// [ '-22-', '-9-', '-60-', '-12-', '-4-', '-56-' ]</pre>
			<p>OK, it seems that our complex type definitions were correct!</p>
			<p>All the previous examples in the chapter focused on simple arrays. But what happens if things get more complicated, say if you had to deal with an array whose elements were arrays themselves? Fortunately, there’s a way out of that. Let’s move on.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Dealing with arrays of arrays</h2>
			<p>So far, we have worked with an array of (single) values as an input, but what would happen if your input was an array of arrays? If you consider this to be a far-fetched case, there are many possible <a id="_idIndexMarker316"/>scenarios where this could apply:</p>
			<ul>
				<li>For some applications, you could have a table of distances, which in JavaScript requires an array of arrays: <code>distance[i][j]</code> would be the distance between <code>i</code> and <code>j</code>. How could you find the maximum distance between any two points? Finding the maximum is simple with a common array, but how do you deal with an array of arrays?</li>
				<li>A more complex example, also in a geographic vein, is that you could query a geographic API for cities matching a string, and the response could be an array of countries, each with an array of states, each itself with an array of matching cities: an array of arrays of arrays!</li>
			</ul>
			<p>In the first case, you could want a single array with all distances, and in the second, an array with all cities; how would you manage this? A new operation, <strong class="bold">flattening</strong>, is required; let’s take a look.</p>
			<h3>Flattening an array</h3>
			<p>In ES2019, two operations were<a id="_idIndexMarker317"/> added to JavaScript: <code>flat()</code>, which we’ll look at now, and <code>flatMap()</code>, which we’ll look at later. It’s easier to show what they do than to explain—bear with me!</p>
			<p class="callout-heading">No flat() allowed?</p>
			<p class="callout">As often happens, not all browsers have been updated to include these new methods, and Microsoft’s Internet Explorer and others were deficient in this regard, so for web programming, a polyfill will be required. As usual, for updated compatibility data, check out the <em class="italic">Can I use?</em> site, in this case, at <a href="http://caniuse.com/#feat=array-flat">caniuse.com/#feat=array-flat</a>. A piece of good news: since September 2018, all major browsers provide this feature natively!</p>
			<p>The <code>flat()</code> method creates a new array, concatenating all elements of its subarrays to the desired level, which is, by default, <code>1</code>:</p>
			<pre class="source-code">
const a = [[1, 2], [3, 4, [5, 6, 7]], 8, [[[9]]]];
console.log(a.flat()); // or a.flat(1)
[ 1, 2, 3, 4, [ 5, 6, 7 ], 8, [ [ 9 ] ] ]
console.log(a.flat(2));
[ 1, 2, 3, 4, 5, 6, 7, 8, [ 9 ]]
console.log(a.flat(Infinity));
[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</pre>
			<p>So, how could we use this<a id="_idIndexMarker318"/> function to solve our problems? Using <code>flat()</code>, spreading, and <code>Math.max()</code> answers the first question (as we saw back in the <em class="italic">Spread</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Becoming Functional</em>; we could have used the <code>maxArray()</code> function we wrote back then), and we can also use <code>reduce()</code> for variety. Suppose we have the following table of distances:</p>
			<pre class="source-code">
const distances = [
  [0, 20, 35, 40],
  [20, 0, 10, 50],
  [35, 10, 0, 30],
  [40, 50, 30, 0],
];</pre>
			<p>Then, we can find our maximum distance in a couple of ways: we either flatten the array, spread it, and use <code>Math.max()</code>, or flatten the array and use reducing to explicitly find the maximum:</p>
			<pre class="source-code">
// flat.js
const maxDist1 = Math.max(...distances.flat()); // 50
const maxDist2 = distances
  .flat()
  .reduce((p, d) =&gt; Math.max(p, d), 0); // also 50</pre>
			<p>Let’s go back to the second question. Suppose we queried a geographic API for cities that have <code>"LINCOLN"</code>  (upper or<a id="_idIndexMarker319"/> lower case) in their names and got the following answer:</p>
			<pre class="source-code">
// continued...
const apiAnswer = [
  {
    country: "AR",
    name: "Argentine",
    states: [
      {
        state: "1",
        name: "Buenos Aires",
        cities: [{city: 3846864, name: "Lincoln"}],
      },
    ],
  },
  {
    country: "GB",
    name: "Great Britain",
    states: [
      {
        state: "ENG",
        name: "England",
        cities: [{city: 2644487, name: "Lincoln"}],
      },
    ],
  },
  {
    country: "US",
    name: "United States of America",
    states: [
      {
        state: "CA",
        name: "California",
        cities: [{city: 5072006, name: "Lincoln"}],
      },
      .
      .
      .
      {
        state: "IL",
        name: "Illinois",
        cities: [
          {city: 4899911, name: "Lincoln Park"},
          {city: 4899966, name: "Lincoln Square"},
        ],
      },
    ],
  },
];</pre>
			<p>Extracting the list of cities can <a id="_idIndexMarker320"/>be done by applying <code>map()</code> and <code>flat()</code> twice:</p>
			<pre class="source-code">
// continued...
console.log(
  apiAnswer
<strong class="bold">    .map(x =&gt; x.states)</strong>
<strong class="bold">    .flat()</strong>
<strong class="bold">    .map(y =&gt; y.cities)</strong>
<strong class="bold">    .flat()</strong>
);
/* Results:
[ { city: 3846864, name: 'Lincoln' },
  { city: 2644487, name: 'Lincoln' },
  { city: 5072006, name: 'Lincoln' },
  { city: 8531960, name: 'Lincoln' },
  { city: 4769608, name: 'Lincolnia' },
  { city: 4999311, name: 'Lincoln Park' },
  { city: 5072006, name: 'Lincoln' },
  { city: 4899911, name: 'Lincoln Park' },
  { city: 4899966, name: 'Lincoln Square' }
]
*/</pre>
			<p>We have seen how to use <code>flat()</code> to flatten an array; let’s now see how to use <code>flatMap()</code>, an interesting mixture of <code>flat()</code> and <code>map()</code>, to further streamline our coding and even further shorten our preceding second solution! (And if you think this exercise wasn’t hard enough <a id="_idIndexMarker321"/>and its output was sort of lame, try out <em class="italic">Question 5.10</em> for a more challenging version!)</p>
			<h3>Mapping and flattening – flatMap()</h3>
			<p>Basically, what <code>flatMap()</code> does is first apply a <code>map()</code> function and then apply <code>flat()</code> to the result of the mapping operation. This is an interesting combination because it lets you produce a new array with a different number of elements. (With the normal <code>map()</code> operation, the <a id="_idIndexMarker322"/>output array would be precisely the same length as the input array). If your mapping operation produces an array with two or more elements, then the output array will include many output values, and if you produce an empty array, the output array will include fewer values.</p>
			<p>Let’s look at a (somehow nonsensical) example. Assume that we have a list of names, such as <code>"Winston Spencer Churchill"</code>, <code>"Abraham Lincoln"</code>, and <code>"Socrates"</code>. Our rule is that if a name has several words, exclude the initial one (the first name, we assume) and separate the rest (last names), but if a name is a single word, drop it (assuming the person has no last name):</p>
			<pre class="source-code">
// continued...
const names = [
  "Winston Spencer Churchill",
  "Plato",
  "Abraham Lincoln",
  "Socrates",
  "Charles Darwin",
];
const lastNames = names.<strong class="bold">flatMap</strong>((x) =&gt; {
  const s = x.split(" ");
  return s.length === 1 ? [] : s.splice(1);
});
// [ 'Spencer', 'Churchill', 'Lincoln', 'Darwin' ]</pre>
			<p>As we can see, the output array has a different number of elements than the input array: just because of this, we could consider <code>flatMap()</code> to be an upgraded version of <code>map()</code>, even including some aspects of <code>filter()</code>, like when we excluded single names.</p>
			<p>Let’s now move on to a simple example. Keeping with the Lincolnian theme from the last section, let’s count how many words are in Lincoln’s Gettysburg address, given as an array of sentences. By the way, this address is usually considered to be 272 words long, but the version I found doesn’t produce that number! This may be because there are five manuscript copies of the address written by Lincoln himself, plus another version transcribed from shorthand notes taken at the event. In any case, I will leave the discrepancy to historians and stick to coding!</p>
			<p>We can use <code>flatMap()</code> to split <a id="_idIndexMarker323"/>each sentence into an array of words and then see the length of the flattened array:</p>
			<pre class="source-code">
const gettysburg = [
  "Four score and seven years ago our fathers",
  "brought forth, on this continent, a new nation,",
  "conceived in liberty, and dedicated to the",
  "proposition that all men are created equal.",
  "Now we are engaged in a great civil war,",
  "testing whether that nation, or any nation",
  "so conceived and so dedicated, can long endure.",
  "We are met on a great battle field of that",
  "war. We have come to dedicate a portion of",
  "that field, as a final resting place for",
  "those who here gave their lives, that that",
  "nation might live. It is altogether",
  "fitting and proper that we should do this.",
  "But, in a larger sense, we cannot dedicate,",
  "we cannot consecrate, we cannot hallow,",
  "this ground.",
  "The brave men, living and dead, who",
  "struggled here, have consecrated it far",
  "above our poor power to add or detract.",
  "The world will little note nor long",
  "remember what we say here, but it can",
  "never forget what they did here.",
  "It is for us the living, rather, to be",
  "dedicated here to the unfinished work",
  "which they who fought here have thus far",
  "so nobly advanced.",
  "It is rather for us to be here dedicated",
  "to the great task remaining before us—",
  "that from these honored dead we take",
  "increased devotion to that cause for",
  "which they here gave the last full",
  "measure of devotion— that we here highly",
  "resolve that these dead shall not have",
  "died in vain— that this nation, under",
  "God, shall have a new birth of freedom-",
  "and that government of the people, by",
  "the people, for the people, shall not",
  "perish from the earth.",
];
console.log(
  gettysburg<strong class="bold">.flatMap((s: string) =&gt; s.split(" "))</strong>.length
);
// 270 ...not 272?</pre>
			<p>Let’s go back to the problem with the <a id="_idIndexMarker324"/>cities. If we notice that each <code>map()</code> was followed by <code>flat()</code>, an alternative solution is immediately apparent. Compare this solution with the one we wrote in the <em class="italic">Flattening an array</em> section; it’s essentially the same but conflates each <code>map()</code> with its following <code>flat()</code>:</p>
			<pre class="source-code">
// continued...
console.log(
  apiAnswer
<strong class="bold">    .flatMap((x) =&gt; x.states)</strong>
<strong class="bold">    .flatMap((y) =&gt; y.cities)</strong>
);
// same result as with separate map() and flat() calls</pre>
			<p>We have now seen the new operations. (And, yes, it’s perfectly possible to solve the problems in this section without mapping, but that wouldn’t be a good example for this section! See <em class="italic">Question 5.11</em> for an alternative to the word counting problem.) Let’s now learn how to emulate these operations should you not have them readily available.</p>
			<h3>Emulating flat() and flatMap()</h3>
			<p>We have already seen <a id="_idIndexMarker325"/>how <code>reduce()</code> could be used to emulate <code>map()</code>. Let’s now see how to work out equivalents for <code>flat()</code> and <code>flatMap()</code> to get more practice. We’ll also throw in a recursive version, a topic we’ll return to in <a href="B19301_09.xhtml#_idTextAnchor172"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Functions</em>. As was mentioned earlier, we are not aiming for the fastest or smallest or any particular version of the code; instead, we want to focus on using the concepts we’ve been looking at in this book.</p>
			<p>Totally flattening an <a id="_idIndexMarker326"/>array can be done with a recursive call. We use <code>reduce()</code> to process the array element by element, and if an element happens to be an array, we recursively flatten it:</p>
			<pre class="source-code">
// continued...
const flatAll = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr.reduce(
    (f: T[], v: T) =&gt;
      f.concat(Array.isArray(v) ? flatAll(v) : v),
    [] as T[]
  );</pre>
			<p>Flattening an array to a given <a id="_idIndexMarker327"/>level (not infinity; let’s leave that for later) is easy if you can first flatten an array one level. We can do this either by using spreading or with <code>reduce()</code>. Let’s write a <code>flatOne()</code> function that flattens just a single level of an array. There are two versions of this; pick whichever you prefer:</p>
			<pre class="source-code">
// continued...
const flatOne1 = &lt;T&gt;(arr: T[]): T[] =&gt;
  ([] as T[]).concat(...arr);
const flatOne2 = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr.reduce((f, v) =&gt; f.concat(v), [] as T[]);</pre>
			<p>Using either of these two functions, we can flatten an array of several levels, and we can do this in two different ways. Our two versions of a <code>flat()</code> function use our previous <code>flatOne()</code> and <code>flatAll()</code> functions, but the first one only uses standard looping, while the second one works in a fully recursive way. Which one do you prefer?</p>
			<pre class="source-code">
// continued...
const flat1 = &lt;T&gt;(arr: T[], n = 1): T[] =&gt; {
  if (n === Infinity) {
    return flatAll(arr);
  } else {
    let result = arr;
    range(0, n).forEach(() =&gt; {
      result = flatOne(result);
    });
    return result;
  }
};
const flat2 =  &lt;T&gt;(arr: T[], n = 1): T[] =&gt; {
  n === Infinity
    ? flatAll(arr)
    : n === 1
    ? flatOne(arr)
    : flat2(flatOne(arr), n - 1);</pre>
			<p>I think the recursive one is nicer <a id="_idIndexMarker328"/>and more aligned with the theme of this book. Still, it’s up to you, really—although if you don’t feel comfortable with the ternary operator, then the recursive version is definitely not for you!</p>
			<p>If you wish to polyfill these<a id="_idIndexMarker329"/> functions (despite our suggestions not to), it’s not complex, and is similar to what we did with the <code>average()</code> method previously. I took care not to create any extra methods:</p>
			<pre class="source-code">
// continued...
if (!Array.prototype.flat) {
  Array.prototype.flat = function (this, n): any[] {
    if (n === undefined || n === 1) {
      return flatOne(this as any[]);
    } else if (n === Infinity) {
      return flatAll(this as any[]);
    } else {
      return flatOne(this as any[]).flat(n - 1);
    }
  };
}</pre>
			<p>Our <code>flatOneX()</code> and <code>flatAllX()</code> methods are just copies of what we developed before, and you’ll recognize the code of our previous <code>flat2()</code> function at the end of our implementation.</p>
			<p>Finally, emulating <code>flatMap()</code> is simple in itself, and we can skip it because it’s just a matter of applying <code>map()</code> first, and then <code>flat()</code>; no big deal!</p>
			<p>We have seen how to work with <a id="_idIndexMarker330"/>arrays in several ways, but sometimes what you need isn’t really well served by <a id="_idIndexMarker331"/>any of the functions we have seen. Let’s move on to more general ways of looping, for greater power.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>More general looping</h2>
			<p>The preceding examples that we’ve <a id="_idIndexMarker332"/>seen all loop through arrays, doing some work. However, sometimes, you need to loop, but the required process doesn’t really fit <code>map()</code> or <code>reduce()</code>. So, what can be done in such cases? There is a <code>forEach()</code> method that can help. (Read more about it at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</a>.)</p>
			<p>You must provide a callback that will receive the value, the index, and the array on which you are operating. (The last two arguments are optional.) JavaScript will take care of the loop control, and you can do whatever you want at each step. For instance, we can program an object copying method by using <code>Object</code> methods to copy the source object attributes one at a time and generate a new object:</p>
			<pre class="source-code">
// copy.ts
const objCopy = &lt;T&gt;(obj: T): T =&gt; {
  const copy = Object.create(Object.getPrototypeOf(obj));
  Object.getOwnPropertyNames(obj).forEach((prop: string) =&gt;
    Object.defineProperty(
      copy,
      prop,
      Object.getOwnPropertyDescriptor(obj, prop) as string
    )
  );
  return copy;
};
const myObj = { fk: 22, st: 12, desc: "couple" };
const myCopy = objCopy(myObj);
console.log(myObj, myCopy);
// {fk: 22, st: 12, desc: "couple"}, twice</pre>
			<p>The idea is: we create a <code>copy</code> object with the same prototype as the original <code>obj</code>, and then for each property in the original, we define an equivalent property in the copy. The function’s signature makes clear that the input and output types are the same. One particular detail: given the loop we are writing, we know for sure that <code>Object.getOwnPropertyDescriptor(obj, prop)</code> will be a string (and not <code>undefined</code>), but TypeScript cannot tell; adding <code>as string</code> solves this.</p>
			<p class="callout-heading">Shallow or deep?</p>
			<p class="callout">Yes, of course, we could have written <code>myCopy={...myObj}</code>, but where’s the fun in that? It would be better, but I needed a nice example to use <code>forEach()</code> with. Sorry about that! Also, there are some hidden inconveniences in that code, which we’ll explain in <a href="B19301_10.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Ensuring Purity</em>, when we try to get frozen, unmodifiable objects. Just a hint: the new object may share values with the old one because we have a shallow copy, not a deep one. We’ll learn more about this later in the book.</p>
			<p>If we use the <code>range()</code> function<a id="_idIndexMarker333"/> that we defined previously, we can also perform common loops of the <code>for(let i=0; i&lt;10; i++)</code> variety. We might write yet another version of factorial (!) using that:</p>
			<pre class="source-code">
// loops.ts
import { range } from "./range";
const fact4 = (n: number): number =&gt; {
  let result = 1;
  range(1, n + 1).forEach((v) =&gt; (result *= v));
  return result;
};
console.log(fact4(5)); // 120</pre>
			<p>This definition of factorial really matches the usual description: it generates all the numbers from 1 to <em class="italic">n</em> inclusive and multiplies them—simple!</p>
			<p>For greater generality, consider expanding <code>range()</code> so it can generate ascending and descending ranges of values, possibly stepping by a number other than 1. This would allow you to replace all the loops in your code with <code>forEach()</code> loops.</p>
			<p>At this point, we have seen many<a id="_idIndexMarker334"/> ways of processing arrays to generate results, but other objectives may be of interest, so let’s now move on to logical functions, which will also simplify our coding needs.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Logical HOFs</h1>
			<p>Up to now, we have been <a id="_idIndexMarker335"/>using HOFs to produce new results. However, some other functions produce logical results by applying a predicate to all the elements of an array. (By the way, we’ll see much more about HOFs in the next chapter.)</p>
			<p class="callout-heading">Many meanings</p>
			<p class="callout">A bit of terminology: the word <strong class="bold">predicate</strong> can be <a id="_idIndexMarker336"/>used in several senses (as in predicate logic), but for us, in computer science, it has the meaning of <em class="italic">a function that returns true or false</em>. OK, this isn’t a very formal definition, but it’s enough for our needs. For example, saying that we will filter an array depending on a predicate means that we get to decide which elements are included or excluded depending on the predicate’s result.</p>
			<p>Using these functions<a id="_idIndexMarker337"/> implies that your code will become shorter: you can get results corresponding to a whole set of values with a single line of code.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Filtering an array</h2>
			<p>We will encounter a common <a id="_idIndexMarker338"/>need to filter the elements of an array according to a specific condition. The <code>filter()</code> method lets you inspect each element of an array in the same fashion as <code>map()</code>. The difference is that instead of producing a new element, the result of your function determines whether the input value will be kept in the output (if the function returned <code>true</code>) or if it will be skipped (if the function returned <code>false</code>). Also, similar to <code>map()</code>, <code>filter()</code> doesn’t alter the original array but produces a new array with the chosen items. You can read more on the <code>filter()</code> function at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</a>.</p>
			<p>See <em class="italic">Figure 5</em><em class="italic">.4</em> for a diagram showing the input and output:</p>
			<div><div><img src="img/Figure_5.4_B19301.jpg" alt="Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy a given predicate"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy a given predicate</p>
			<p>There are a couple<a id="_idIndexMarker339"/> of things to remember when filtering an array:</p>
			<ul>
				<li><code>undefined</code>, and since that’s a falsy value, the output will be an empty array</li>
				<li><strong class="bold">The copy that is made is shallow</strong>: If the input array elements are objects or arrays, then the original elements will still be accessible</li>
			</ul>
			<p>Let’s get into more detail by <a id="_idIndexMarker340"/>seeing a practical example of <code>filter()</code> and then looking at how we could implement that functionality by using <code>reduce()</code>.</p>
			<h3>A filter() example</h3>
			<p>Let’s look at a practical example. Suppose a <a id="_idIndexMarker341"/>service has returned a JSON object, which has an array of objects containing an account’s <code>id</code> value and <code>balance</code>. How can we get the list of IDs <em class="italic">“in the red”</em>, with a negative balance? The input data could be as follows:</p>
			<pre class="source-code">
// filter.ts
const serviceResult = {
  accountsData: [
    { id: "F220960K", balance: 1024 },
    { id: "S120456T", balance: 2260 },
    { id: "J140793A", balance: -38 },
    { id: "M120396V", balance: -114 },
    { id: "A120289L", balance: 55000 },
  ],
};</pre>
			<p>We could get the delinquent accounts with something like the following. You can check that the value of the <code>delinquent</code> variable correctly includes the two IDs of accounts with a negative balance:</p>
			<pre class="source-code">
// continued...
const delinquent = serviceResult.accountsData.filter(
  <strong class="bold">(v) =&gt; v.balance &lt; 0</strong>
);
console.log(delinquent);
// two objects, with id's <strong class="bold">J140793A</strong> and <strong class="bold">M120396V</strong></pre>
			<p>By the way, given that the filtering operation produced yet another array, if you just wanted the accounts IDs, you could get them by mapping the output to only get the <code>id</code> field:</p>
			<pre class="source-code">
// continued...
const delinquentIds = delinquent.<strong class="bold">map((v) =&gt; v.id)</strong>;</pre>
			<p>And if you didn’t care for the intermediate result, a one-liner would have worked as well:</p>
			<pre class="source-code">
// continued...
const delinquentIds2 = serviceResult.accountsData
  .filter((v) =&gt; v.balance &lt; 0)
  .map((v) =&gt; v.id);</pre>
			<p>Filtering is a very useful <a id="_idIndexMarker342"/>function, so now, to get a better handle on it, let’s see how you can emulate it, which you could use as a basis for more sophisticated, powerful functions of your own.</p>
			<h3>Emulating filter() with reduce()</h3>
			<p>As we did before with <code>map()</code>, we can also <a id="_idIndexMarker343"/>create our own version of <code>filter()</code> by using <code>reduce()</code>. The idea is similar: loop through all the elements of the input array, apply the predicate to it, and if the result is <code>true</code>, add the original element to the output array. When the loop is done, the output array will only have those elements for which the predicate was <code>true</code>:</p>
			<pre class="source-code">
// continued...
const myFilter = &lt;T&gt;(arr: T[], fn: (x: T) =&gt; boolean) =&gt;
  arr.reduce(
    (x: T[], y: T) =&gt; (fn(y) ? x.concat(y) : x),
    []
  );</pre>
			<p>Our function is generic; it takes an array of elements of type <code>T</code> and a predicate that accepts a <code>T</code>-type parameter and generates a new array of elements of type <code>T</code>. We can quickly see that our function works as expected:</p>
			<pre class="source-code">
myFilter(serviceResult.accountsData, (v) =&gt; v.balance &lt; 0);</pre>
			<p>The output is the same pair of accounts that we saw earlier in this section.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Searching an array</h2>
			<p>Sometimes, instead <a id="_idIndexMarker344"/>of filtering all the elements of an array, you <a id="_idIndexMarker345"/>want to find an element that satisfies a given predicate. There are a couple of functions that can be used for this, depending on your specific needs:</p>
			<ul>
				<li><code>find()</code> searches through the array and returns the value of the first element that satisfies a given condition, or <code>undefined</code> if no such element is found</li>
				<li><code>findIndex()</code> performs a similar task, but instead of returning an element, it returns the index of the first element in the array that satisfies the condition, or <code>-1</code> if none were found</li>
			</ul>
			<p>The similarity to <code>includes()</code> and <code>indexOf()</code> is clear; these functions search for a specific value instead of an element that satisfies a more general condition. We can easily write equivalent one-liners:</p>
			<pre class="source-code">
arr.includes(value);  // arr.find(v =&gt; v === value) arr.indexOf(value);  // arr.findIndex(v =&gt; v === value)</pre>
			<p>Going back to the geographic data we used earlier, we could easily find a given country by using the <code>find()</code> method. For instance, let’s get data for Brazil ( <code>"BR"</code>); it just takes a single line of code:</p>
			<pre class="source-code">
// search.ts
import { markers } from "./average";
const brazilData = markers.<strong class="bold">find((v) =&gt; v.name === "BR")</strong>;
// {name:"BR", lat:-15.8, lon:-47.9}</pre>
			<p>We can’t use the simpler <code>includes()</code> method because we have to delve into the object to get the field we want. If we wanted the position of the country in the array, we would have used <code>findIndex()</code>:</p>
			<pre class="source-code">
// continued...
const brazilIndex = markers<strong class="bold">.findIndex(</strong>
<strong class="bold">  (v) =&gt; v.name === "BR"</strong>
<strong class="bold">)</strong>;
// 2</pre>
			<p>OK, this was easy! What about a special case, which could even be a trick interview question? Read<a id="_idIndexMarker346"/> on!</p>
			<h3>A special search case</h3>
			<p>Suppose you had an array of numbers and wanted to run a sanity check, studying whether any of them were <code>NaN</code>. How<a id="_idIndexMarker347"/> would you do this? A tip: don’t try checking the types of the array elements—even though <code>NaN</code> stands for not a number, <code>typeof NaN</code> <em class="italic">is</em> <code>"number"</code>. You’ll get a surprising result if you try to search in an obvious way:</p>
			<pre class="source-code">
[1, 2, NaN, 4].findIndex((x) =&gt; x === NaN); // -1</pre>
			<p>What’s going on here? It’s a bit of interesting JavaScript trivia: <code>NaN</code> is the only value that isn’t equal to itself. Should you need to look for <code>NaN</code>, you’ll have to use the new <code>isNaN()</code> function as follows:</p>
			<pre class="source-code">
[1, 2, NaN, 4].findIndex(x =&gt; isNaN(x)); // 2</pre>
			<p>ESLint would help with the <code>use-isnan</code> rule: see eslint.org/docs/latest/rules/use-isnan for more on this. <em class="italic">Figure 5</em><em class="italic">.5</em> shows the result.</p>
			<div><div><img src="img/Figure_5.5_B19301.jpg" alt="Figure 5.5 – ESLint prevents you from a NaN-related mistake"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – ESLint prevents you from a NaN-related mistake</p>
			<p>This was a particular case worth knowing about; I had to deal with it once! Now, let’s continue as we have done previously, by emulating the searching methods with <code>reduce()</code> so that we can see more examples of the power of that function.</p>
			<h3>Emulating find() and findIndex() with reduce()</h3>
			<p>As with the other methods, let’s finish this section by studying how to implement the methods we showed by using the omnipotent <code>reduce()</code>. This is a good exercise to get accustomed to working <a id="_idIndexMarker348"/>with HOFs, even if you will never actually<a id="_idIndexMarker349"/> use these polyfills!</p>
			<p>The <code>find()</code> method requires <a id="_idIndexMarker350"/>a bit of work. We start the search with an <code>undefined</code> value, and if we find an array element so that the predicate is <code>true</code>, we change<a id="_idIndexMarker351"/> the accumulated value to that of the array:</p>
			<pre class="source-code">
arr.find(fn); // or arr.find((x) =&gt; fn(x));
arr.reduce(
  (x, y) =&gt; <strong class="bold">(x === undefined &amp;&amp; fn(y) ? y : x)</strong>,
  undefined
);</pre>
			<p>In terms of performance, there’s a slight difference with the standard <code>find()</code> method. The language specification (at <a href="http://tc39.es/ecma262/#sec-array.prototype.find">tc39.es/ecma262/#sec-array.prototype.find</a>) shows that the search stops as soon as an element satisfies the search. Our code, however, keeps processing the rest of the array (because that’s how <code>reduce()</code> works), although it doesn’t evaluate the predicate again; can you see why?</p>
			<p>For <code>findIndex()</code>, we must remember that the callback function receives the accumulated value, the array’s current element, and the index of the current element, but other than that, the equivalent expression is quite similar to the one for <code>find()</code>; comparing them is worth the time:</p>
			<pre class="source-code">
arr.findIndex(fn);
arr.reduce((x, y, i) =&gt; (x == -1 &amp;&amp; fn(y) ? i : x), -1);</pre>
			<p>The initial accumulated value is <code>-1</code> here, which will be the returned value if no element fulfills the predicate. Whenever the accumulated value is still <code>-1</code>, but we find an element that satisfies the predicate, we change the accumulated value to the array index.</p>
			<p>OK, we are now done with searches: let’s move on to considering higher-level predicates that will simplify testing arrays for a condition, but always in the declarative style we’ve been using so far.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Higher-level predicates – every() and some()</h2>
			<p>The last functions we will consider greatly simplify going through arrays to test for conditions. These functions are as follows:</p>
			<ul>
				<li><code>every()</code>, which is <code>true</code> if and only <a id="_idIndexMarker352"/>if every element in the array satisfies a given predicate</li>
				<li><code>some()</code>, which is <code>true</code> if at least one element in the array satisfies the predicate</li>
			</ul>
			<p>For example, we could <a id="_idIndexMarker353"/>quickly check our hypothesis about all the countries having negative coordinates:</p>
			<pre class="source-code">
// continued...
markers.every((v) =&gt; v.lat &lt; 0 &amp;&amp; v.lon &lt; 0); // false
markers.some((v) =&gt; v.lat &lt; 0 &amp;&amp; v.lon &lt; 0);  // true</pre>
			<p>If we want to find equivalents to these two functions in terms of <code>reduce()</code>, the two alternatives show nice symmetry:</p>
			<pre class="source-code">
arr.every(fn);
arr.reduce((x, y) =&gt; x &amp;&amp; fn(y), true);
arr.some(fn);
arr.reduce((x, y) =&gt; x || fn(y), false);</pre>
			<p>The first folding operation evaluates <code>fn(y)</code> and ANDs the result with the previous tests; the only way the final result will be <code>true</code> is if every test succeeds. The second folding operation is similar, but ORs the result with the previous results and will produce <code>true</code> unless every test fails.</p>
			<p class="callout-heading">Boolean duality</p>
			<p class="callout">In terms of Boolean algebra, the alternative formulations for <code>every()</code> and <code>some()</code> exhibit duality. This duality is the same kind that appears in the <code>x === x &amp;&amp; true</code> and <code>x === x || false</code> expressions; if <code>x</code> is a Boolean value, and we exchange <code>&amp;&amp;</code> and <code>||</code>, and also <code>true</code> and <code>false</code>, then we transform one expression into the other, and both are valid.</p>
			<p>In this section, we saw how to check for a given Boolean condition. Let’s finish by seeing how to check a negative condition by inventing a method of our own.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Checking negatives – none()</h2>
			<p>If you wanted, you<a id="_idIndexMarker354"/> could also define <code>none()</code> as the complement of <code>every()</code>. This new function would be <code>true</code> only if none of the elements of the array satisfied the given predicate. The simplest way of coding this would be by noting that if no elements satisfy the condition, then all elements satisfy the negation of the condition:</p>
			<pre class="source-code">
// continued...
const none = &lt;T&gt;(arr: T[], fn: (x: T) =&gt; boolean) =&gt;
  arr.<strong class="bold">every((v) =&gt; !fn(v))</strong>;</pre>
			<p>You can turn it into a method by modifying the array prototype, as we saw earlier. It’s still a bad practice, but it’s what we have until we start looking into better methods for composing and<a id="_idIndexMarker355"/> chaining functions, which we will do in <a href="B19301_08.xhtml#_idTextAnchor148"><em class="italic">Chapter 8</em></a>, <em class="italic">Connecting Functions</em>:</p>
			<pre class="source-code">
// continued...
declare global {
  interface Array&lt;T&gt; {
    <strong class="bold">none(f: (x: T) =&gt; boolean): boolean;</strong>
  }
}
Array.prototype.none = function (fn) {
  return this.every((v) =&gt; !fn(v));
};</pre>
			<p>We had to use <code>function()</code> instead of an arrow function for the same reasons we saw on earlier occasions: we need <code>this</code> to be correctly assigned. We also had to add a global definition like when we used averages so that TypeScript wouldn’t object to the newly added <code>none()</code> method. Other than that, it’s simple coding, and we now have a <code>none()</code> method available for all arrays. In <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we will see yet other ways of negating a function by writing an appropriate HOF of our own.</p>
			<p>In this and the preceding section, we worked with everyday problems and saw how to solve them declaratively. However, things change a bit when you start working with <code>async</code> functions. We will see in the following section that new solutions will be needed.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Working with async functions</h1>
			<p>All the examples <a id="_idIndexMarker356"/>and code we studied in the previous sections were meant to be used with common functions, specifically meaning <em class="italic">not</em> <code>async</code> ones. When you want to do mapping, filtering, reducing, and so on, but the function you are using is an <code>async</code> one, the results may surprise you. To simplify our work and not deal with actual API calls, let’s create a <code>fakeAPI(delay, value)</code> function that will delay a while before returning the given value:</p>
			<pre class="source-code">
// async.ts
const fakeAPI = &lt;T&gt;(delay: number, value: T): Promise&lt;T&gt; =&gt;
  <strong class="bold">new Promise((resolve) =&gt;</strong>
<strong class="bold">    setTimeout(() =&gt; resolve(value), delay)</strong>
<strong class="bold">  )</strong>;</pre>
			<p>Let’s also have a function to display what <code>fakeAPI()</code> returns so that we can see that things are working as expected:</p>
			<pre class="source-code">
// continued...
const useResult = (x: any): void =&gt;
  console.log(new Date(), x);</pre>
			<p>We are using the modern <code>async</code> and <code>await</code> features from ES2017 to simplify our code, and we are avoiding the top-level <code>await</code>:</p>
			<pre class="source-code">
// async.ts
(async () =&gt; {
  console.log("START");
  console.log(new Date());
  const result = await fakeAPI(1000, 229);
  useResult(result);
  console.log("END");
})();
/*
<strong class="bold">START</strong>
<strong class="bold">2022-10-29T01:28:12.986Z</strong>
<strong class="bold">2022-10-29T01:28:13.989Z 229</strong>
<strong class="bold">END</strong>
*/</pre>
			<p>The results are previsible: we get the <code>START</code> text, then about 1 second (1,000 milliseconds) later, the <a id="_idIndexMarker357"/>result of the fake API call (<code>229</code>), and finally the <code>END</code> text. What could go wrong?</p>
			<p class="callout-heading">Top-level await</p>
			<p class="callout">Why are we using the immediate invocation pattern we saw in <a href="B19301_03.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Starting Out with Functions</em>? The reason is that the use of <code>await</code> at the top level has been available for Node.js since version 14.8 (August 2020) and browsers since 2021, so it’s not yet widespread. So, as you can only use <code>await</code> within an <code>async</code> function, I opted to go with an IIFE here for major compatibility.</p>
			<p>The critical problem is that all the functions we saw earlier in this chapter are not <code>async</code>-<em class="italic">aware</em>, so they won’t work as you’d expect. Let’s start looking at this.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Some strange behaviors</h2>
			<p>Let’s start with a simple <a id="_idIndexMarker358"/>quiz: are results what you expected? Let’s look at a couple of examples of code involving <code>async</code> calls, and we’ll see some unexpected results. First, let’s look at a typical straightforward sequence of <code>async</code> calls:</p>
			<pre class="source-code">
// continued...
(async () =&gt; {
  console.log("START SEQUENCE");
  const x1 = await fakeAPI(1000, 1);
  useResult(x1);
  const x2 = await fakeAPI(2000, 2);
  useResult(x2);
  const x3 = await fakeAPI(3000, 3);
  useResult(x3);
  const x4 = await fakeAPI(4000, 4);
  useResult(x4);
  console.log("END SEQUENCE");
})();</pre>
			<p>If you run this code, you’ll get the following results, which are indeed what you would expect—a <code>START SEQUENCE</code> text, four individual lines with the results of the fake API calls, and a final <code>END SEQUENCE</code> text. Nothing special here—everything is fine!</p>
			<pre class="console">
<strong class="bold">START SEQUENCE</strong>
2022-10-29T01:32:11.671Z 1
2022-10-29T01:32:13.677Z 2
2022-10-29T01:32:16.680Z 3
2022-10-29T01:32:20.683Z 4
<strong class="bold">END SEQUENCE</strong></pre>
			<p>Let’s go for an alternative second version, which you’d expect to be equivalent to the first one. The only difference<a id="_idIndexMarker359"/> here is that we are using looping to do the four API calls; it should be the same, shouldn’t it? (We could also have used a <code>forEach()</code> loop with the <code>range()</code> function that we saw earlier, but that makes no difference.) I kept using an IIFE, though in this particular case, it wasn’t needed; can you see why?</p>
			<pre class="source-code">
// continued...
(() =&gt; {
  console.log("START FOREACH");
  [1, 2, 3, 4].forEach(async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    useResult(x);
  });
  console.log("END FOREACH");
})();</pre>
			<p>This code certainly looks equivalent to the first one, but it produces something entirely different!</p>
			<pre class="console">
<strong class="bold">START FOREACH</strong>
<strong class="bold">END FOREACH</strong>
2022-10-29T01:34:06.287Z 1
2022-10-29T01:34:07.287Z 2
2022-10-29T01:34:08.286Z 3
2022-10-29T01:34:09.286Z 4</pre>
			<p>The <code>END FOREACH</code> text appears before the results of the API calls. What’s happening? The answer is what we mentioned before: methods similar to <code>forEach()</code> and the like are meant to be used with<a id="_idIndexMarker360"/> standard, sync function calls and behave strangely with <code>async</code> function calls.</p>
			<p>The key concept is that <code>async</code> functions always return promises, so after getting the <code>START FOREACH</code> text, the loop actually creates four promises (which will eventually be resolved at some point), <em class="italic">but without waiting for them</em>, and our code goes on to print the <code>END</code> <code>FOREACH</code> text.</p>
			<p>The problem is not only with <code>forEach()</code> but also affects all other similar methods. Let’s see how we can work around this situation and write <code>async</code>-aware functions to let us keep working in a declarative fashion, as we did earlier in the chapter.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Async-ready looping</h2>
			<p>If we cannot directly use <a id="_idIndexMarker361"/>methods such as <code>forEach()</code>, <code>map()</code>, and<a id="_idIndexMarker362"/> the like, we’ll have to develop new versions of our own. Let’s see how to achieve this.</p>
			<h3>Looping over async calls</h3>
			<p>Since <code>async</code> calls return promises, we can emulate <code>forEach()</code> with <code>reduce()</code> by starting with a resolved<a id="_idIndexMarker363"/> promise and chaining to it the promises for each value in the array. The <code>then()</code> methods will be called in the proper order, so the results will be correct. The following piece of code manages to get the right, expected results:</p>
			<pre class="source-code">
// continued...
<strong class="bold">const forEachAsync = &lt;T&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; any</strong>
<strong class="bold">): Promise&lt;any&gt; =&gt;</strong>
<strong class="bold">  arr.reduce(</strong>
<strong class="bold">    (promise: Promise&lt;void&gt;, value: T) =&gt;</strong>
<strong class="bold">      promise.then(() =&gt; fn(value)),</strong>
<strong class="bold">    Promise.resolve()</strong>
<strong class="bold">  );</strong>
(async () =&gt; {
  console.log("START FOREACH VIA REDUCE");
  await forEachAsync([1, 2, 3, 4], async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    useResult(x);
  });
  console.log("END FOREACH VIA REDUCE");
})();</pre>
			<p>The result is as<a id="_idIndexMarker364"/> follows:</p>
			<pre class="console">
<strong class="bold">START FOREACH VIA REDUCE</strong>
2022-10-29T01:42:09.385Z 1
2022-10-29T01:42:11.388Z 2
2022-10-29T01:42:14.391Z 3
2022-10-29T01:42:18.392Z 4
<strong class="bold">END FOREACH VIA REDUCE</strong></pre>
			<p>As <code>forEachAsync()</code> returns a promise, we must remember to await it before showing the final text message. Other than not forgetting all the <code>await</code> statements, the code is similar to what we build using <code>forEach()</code> with the crucial difference being that this does work as expected!</p>
			<h3>Mapping async calls</h3>
			<p>Can we use the other functions? Writing <code>mapAsync()</code>, a version of <code>map()</code> that can work with an <code>async</code> mapping<a id="_idIndexMarker365"/> function, is simple because you can take advantage of <code>Promise.all()</code> to create a promise out of an array of promises:</p>
			<pre class="source-code">
// continued...
<strong class="bold">const mapAsync = &lt;T, R&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; Promise&lt;R&gt;</strong>
<strong class="bold">) =&gt; Promise.all(arr.map(fn));</strong>
(async () =&gt; {
  console.log("START MAP");
  const mapped = await mapAsync([1, 2, 3, 4], async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    return x * 10;
  });
  useResult(mapped);
  console.log("END MAP");
})();</pre>
			<p>We get the following:</p>
			<pre class="console">
START MAP
2022-10-29T01:47:06.726Z [ 10, 20, 30, 40 ]
END MAP</pre>
			<p>The structure of the solution is similar to the <code>forEachAsync()</code> code. As before, we must remember to <code>await</code> the result of <code>mapAsync()</code> before continuing the process. Other than that, the<a id="_idIndexMarker366"/> logic is straightforward, and the results are as expected; the mapping function delays for a while and returns 10 times its input argument, and we see the correct output is produced.</p>
			<h3>Filtering with async calls</h3>
			<p>Filtering with an <code>async</code> function is <a id="_idIndexMarker367"/>a tad more complicated. We will have to use <code>mapAsync()</code> to produce an array of <code>true</code> or <code>false</code> results and then use the standard <code>filter()</code> method to pick values out of the original array depending on what the <code>async</code> filtering function returned. Let’s try out a simple example, calling the API and accepting only even results utilizing a <code>fakeFilter()</code> function, which, for our example, accepts even numbers and rejects odd ones:</p>
			<pre class="source-code">
// continued...
const fakeFilter = (value: number): Promise&lt;boolean&gt; =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; resolve(value % 2 === 0), 1000)
  );</pre>
			<p>The needed <code>async</code> filtering<a id="_idIndexMarker368"/> code is as follows:</p>
			<pre class="source-code">
// continued...
<strong class="bold">const filterAsync = &lt;T&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; Promise&lt;boolean&gt;</strong>
<strong class="bold">) =&gt;</strong>
<strong class="bold">  mapAsync(arr, fn).then((arr2) =&gt;</strong>
<strong class="bold">    arr.filter((v, i) =&gt; Boolean(arr2[i]))</strong>
<strong class="bold">  );</strong>
(async () =&gt; {
  console.log("START FILTER");
  const filtered = await filterAsync(
    [1, 2, 3, 4],
    async (n) =&gt; {
      const x = await fakeFilter(n);
      return x;
    }
  );
  useResult(filtered);
  console.log("END FILTER");
})();</pre>
			<p>The result is as follows:</p>
			<pre class="console">
START FILTER
2022-10-29T01:56:19.798Z [ 2, 4 ]
END FILTER</pre>
			<p>Note that the result of the mapping of <code>async</code> calls is a Boolean array (<code>arr2</code>), which we then use with <code>filter()</code> to select <a id="_idIndexMarker369"/>elements from the original array of values (<code>arr</code>); this can be tricky to understand!</p>
			<h3>Reducing async calls</h3>
			<p>Finally, finding an <a id="_idIndexMarker370"/>equivalent for <code>reduce()</code> is a bit more complex, but not so much after the other functions that we’ve seen. The key idea is the same as for <code>forEachAsync()</code>: each function call will return a promise, which must be awaited in order to update the accumulator in an upcoming <code>then()</code>. We set up this iteration with an initial promise that immediately resolves to the initial value for the accumulator:</p>
			<pre class="source-code">
// continued...
const reduceAsync = &lt;T, R&gt;(
  arr: T[],
  fn: (acc: R, val: T) =&gt; Promise&lt;R&gt;,
  init: R
) =&gt;
<strong class="bold">  Promise.resolve(init).then((accum) =&gt;</strong>
<strong class="bold">    forEachAsync(arr, async (v: T) =&gt; {</strong>
<strong class="bold">      accum = await fn(accum, v);</strong>
<strong class="bold">    }).then(() =&gt; accum)</strong>
<strong class="bold">  );</strong></pre>
			<p>To do the reducing, let’s use an <code>async</code> <code>fakeSum()</code> function that will sum the API-returned values:</p>
			<pre class="source-code">
// continued...
const fakeSum = (
  value1: number,
  value2: number
): Promise&lt;number&gt; =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; resolve(value1 + value2), 1000)
  );
(async () =&gt; {
  console.log("START REDUCE");
  const summed = await reduceAsync(
    [1, 2, 3, 4],
    async (_accum, n) =&gt; {
      const accum = <strong class="bold">await _accum</strong>;
      const x = <strong class="bold">await fakeSum(accum, n)</strong>;
      useResult(`accum=${accum} value=${x} `);
      return x;
    },
    0
  );
  useResult(summed);
  console.log("END REDUCE");
})();</pre>
			<p>Note the critical detail: in <a id="_idIndexMarker371"/>our reducing function, we must first <code>await</code> the value of the accumulator and only afterward <code>await</code> the result of our <code>async</code> function. This is an important point you must not miss: since we are reducing in an <code>async</code> fashion, getting the accumulator is also an <code>async</code> matter, so we need to <code>await</code> both the accumulator and the new API call.</p>
			<p>The result shows four intermediate values and the final result:</p>
			<pre class="console">
<strong class="bold">START REDUCE</strong>
2022-10-29T02:04:20.862Z accum=0 value=1
2022-10-29T02:04:21.864Z accum=1 value=3
2022-10-29T02:04:22.865Z accum=3 value=6
2022-10-29T02:04:23.866Z accum=6 value=10
2022-10-29T02:04:23.866Z 10
<strong class="bold">END REDUCE</strong></pre>
			<p>By looking at these equivalents, we have seen that <code>async</code> functions, despite producing problems with the usual declarative methods that we studied at the beginning of the chapter, may also be handled by similar new functions of our own, so we can keep the new style even for these cases. Even if we have to use a somewhat different set of functions, your code will still be declarative, tighter, and clearer; an all-around win!</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Working with parallel functions</h1>
			<p>JavaScript provides concurrency through <code>async</code> functions, meaning that several tasks can go on at the same time, even if a single CPU is <a id="_idIndexMarker372"/>doing all the jobs. <strong class="bold">Web workers</strong> (for the frontend) and <strong class="bold">worker threads</strong> (for the <a id="_idIndexMarker373"/>backend) allow processing in parallel in a different core, for better <a id="_idIndexMarker374"/>performance. This can offload work from the main thread and solve potential problems, in line with our FP approach.</p>
			<p>In this section, we’ll see how to avoid bottlenecks in frontend and backend programming by using workers in functional ways, along the lines of the previous sections in this chapter.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Unresponsive pages</h2>
			<p>Let’s return to our Fibonacci slow-performing code <a id="_idIndexMarker375"/>from the <em class="italic">Memoization</em> section in the previous chapter. Suppose we want to create a web page that will allow users to enter a number and calculate the corresponding Fibonacci number, as in <em class="italic">Figure 5</em><em class="italic">.6</em>.</p>
			<div><div><img src="img/Figure_5.6_B19301.jpg" alt="Figure 5.6 – A Fibonacci calculator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A Fibonacci calculator</p>
			<p>The code for this page is very basic—and no, I’m not even trying to do any styling; that’s not the problem here!</p>
			<pre class="source-code">
// workers/test_worker_1.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Fibonacci&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Fibonacci:
    &lt;input id="num" type="number" min="0" value="0" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    <strong class="bold">&lt;button onclick="locally()"&gt;Locally&lt;/button&gt;</strong>
    &lt;br /&gt;
    &lt;br /&gt;
    Result: &lt;span id="res"&gt;&lt;/span&gt;
    &lt;script src="img/test_worker_1.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>The script code is as<a id="_idIndexMarker376"/> follows:</p>
			<pre class="source-code">
// workers/test_worker_1.ts
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
function getNumber(): number {
  return Number(
    (document.getElementById("num") as HTMLInputElement)
      .value
  );
}
function showResult(result: number): void {
  document.getElementById("res")!.innerText =
    String(result);
}
<strong class="bold">function locally(): void {</strong>
<strong class="bold">  showResult(fib(getNumber()));</strong>
<strong class="bold">}</strong></pre>
			<p>The corresponding <a id="_idIndexMarker377"/>Fibonacci number is calculated and shown when the user enters a number and clicks on the <strong class="bold">Locally</strong> button, but what happens if a fairly large number (say, around 50) is entered? <em class="italic">Figure 5</em><em class="italic">.7</em> illustrates the problem.</p>
			<div><div><img src="img/Figure_5.7_B19301.jpg" alt="Figure 5.7 – A long-running process eventually blocks the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – A long-running process eventually blocks the browser</p>
			<p>As the code runs, the page becomes totally unresponsive, and you cannot click anywhere or enter a new number. Furthermore, if a process requires too much processing time, the browser will think there’s a problem and offer the user to kill the page… not what we want!</p>
			<p>What’s the solution? We want to offload the calculation to a worker, which will run in parallel, freeing the browser. Let’s see how we’d set this up in not a particularly functional way!</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>A frontend worker</h2>
			<p>Workers (see developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API for web <a id="_idIndexMarker378"/>workers and nodejs.org/api/worker_threads.html for Node.js worker threads) work in similar ways. They are plain <a id="_idIndexMarker379"/>JavaScript code that can listen to messages, and after doing their work, they respond to their caller by sending another message.</p>
			<p>For our Fibonacci calculation, the following would do:</p>
			<pre class="source-code">
// workers/web_fib_worker.ts
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
<strong class="bold">onmessage = (e: MessageEvent&lt;number&gt;) =&gt;</strong>
<strong class="bold">  postMessage(fib(e.data));</strong>;</pre>
			<p>The last line of the code provides all the interaction between the caller and the worker. On getting a message, <code>e</code>, its <code>e.data</code> value is passed to the <code>fib()</code> function, and the result is posted back to the caller.</p>
			<p>How would this be used? <em class="italic">Figure 5</em><em class="italic">.8</em> shows the result we try to achieve. We now want to allow two ways of calculating Fibonacci numbers: locally, as before, subject to lengthy processing time problems, or in <a id="_idIndexMarker380"/>parallel, by offloading the job to a worker.</p>
			<div><div><img src="img/Figure_5.8_B19301.jpg" alt="Figure 5.8 – Calculating Fibonacci numbers by using workers as an option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Calculating Fibonacci numbers by using workers as an option</p>
			<p>The new code is as<a id="_idIndexMarker381"/> follows; we’ll highlight the additions:</p>
			<pre class="source-code">
// workers/test_worker_2.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Fibonacci&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Fibonacci:
    &lt;input id="num" type="number" min="0" value="0" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;button onclick="locally()"&gt;Locally&lt;/button&gt;
<strong class="bold">    &lt;button onclick="parallelly()"&gt;Parallelly&lt;/button&gt;</strong>
    &lt;br /&gt;
    &lt;br /&gt;
    Result: &lt;span id="res"&gt;&lt;/span&gt;
    &lt;script src="img/test_worker_2.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>The new script file is just like the<a id="_idIndexMarker382"/> previous one, with some additions at the end:</p>
			<pre class="source-code">
// workers/test_worker_2.ts
.
.
.
const worker = <strong class="bold">new Worker(</strong>
<strong class="bold">  "http://localhost:8887/test_fib_worker.js"</strong>
<strong class="bold">)</strong>;
worker.onmessage = <strong class="bold">(e: MessageEvent&lt;number&gt;) =&gt;</strong>
<strong class="bold">  showResult(e.data)</strong>;
/* eslint-disable-next-line */
function parallelly(): void {
  <strong class="bold">worker.postMessage(getNumber())</strong>;
}</pre>
			<p>The new <code>Parallelly</code> button calls the corresponding <code>parallelly()</code> function. This function gets the number that the user entered and posts it via a message to the worker that had been created <a id="_idIndexMarker383"/>earlier. The <code>onmessage</code> method of that worker receives the calculated result and shows it onscreen.</p>
			<p>Using this method, the user can ask for any Fibonacci number, and the window will remain responsive, and no warning will pop up for the user to close the page; see <em class="italic">Figure 5</em><em class="italic">.9</em>.</p>
			<div><div><img src="img/Figure_5.9_B19301.jpg" alt="Figure 5.9 – The page remains responsive even as calculations take a long time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The page remains responsive even as calculations take a long time</p>
			<p>OK, using workers<a id="_idIndexMarker384"/> clearly helps if you have lots of calculations to perform at the<a id="_idIndexMarker385"/> frontend; let’s see a similar implementation for the backend.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>A backend worker</h2>
			<p>Let’s see a quick example of a backend worker, as we could use with Node.js or similar. The example will be<a id="_idIndexMarker386"/> very bare-bones; in real life, we’d include route definitions<a id="_idIndexMarker387"/> and much more, but we want to focus on worker creation and usage here.</p>
			<p>Our worker is similar to the web worker; the differences are easy to understand:</p>
			<pre class="source-code">
// workers/fib_worker.ts
import { parentPort } from "worker_threads";
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
<strong class="bold">parentPort!.on("message", (m: number) =&gt;</strong>
<strong class="bold">  parentPort!.postMessage(fib(m))</strong>
<strong class="bold">);</strong></pre>
			<p>The idea is precisely the same; when the <code>message</code> event occurs, we call <code>fib()</code> to calculate the corresponding <a id="_idIndexMarker388"/>Fibonacci number, and we use <code>postMessage()</code> to send it to the caller.</p>
			<p>The caller code would be simple too:</p>
			<pre class="source-code">
// workers/fib_worker_test.ts
import { Worker } from "worker_threads";
const worker = <strong class="bold">new Worker("./fib_worker.js");</strong>
console.log("START");
<strong class="bold">worker.postMessage(40);</strong>
console.log("END");
<strong class="bold">worker.on("message", (msg) =&gt; {</strong>
<strong class="bold">  console.log("MESSAGE", msg);</strong>
<strong class="bold">  worker.terminate();</strong>
<strong class="bold">});</strong></pre>
			<p>The code is totally<a id="_idIndexMarker389"/> analogous to the frontend code. We create a worker (with the <code>new Worker()</code> call), we post a message to it with <code>postMessage()</code>, and we listen to the worker’s <code>message</code> event. When we receive the computed result, we display it, and <code>terminate()</code> the worker. Running this code produces the following simple result—the last line takes a while to appear!</p>
			<pre class="console">
START
END
MESSAGE 102334155</pre>
			<p>We have seen how to use workers in event-oriented programming, but this isn’t particularly suited to our desired FP way of working; let’s fix that.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Workers, FP style</h2>
			<p>Workers are appropriate <a id="_idIndexMarker390"/>for FP programming for the following reasons:</p>
			<p>Workers run in separate contexts, so they cannot interact with the DOM or global variables.</p>
			<p>All communication is done through messages; otherwise, workers are separated from their caller.</p>
			<ul>
				<li>Data passed to and from workers is a copy; it is serialized before it is passed and deserialized when received. Even if the worker were to modify the arguments it received, that wouldn’t cause any problem for the caller.</li>
			</ul>
			<p>We can work with events, but it would be better to wrap workers in promises so we can apply the <code>async</code> functions <a id="_idIndexMarker391"/>we developed in the previous section.</p>
			<p class="callout-heading">Events or promises?</p>
			<p class="callout">Workers can send multiple messages to their caller. If this is the case, a promise won’t be a good idea because it will be resolved after the first result, disregarding future messages. In most cases, a single result is expected, so promises are OK, but keep in mind there are other possibilities.</p>
			<p>A direct way to wrap a worker would be the following:</p>
			<pre class="source-code">
// workers/fib_worker_test_with_promise.ts
import { Worker } from "worker_threads";
const callWorker = (filename: string, value: unknown) =&gt;
<strong class="bold">  new Promise((resolve) =&gt; {</strong>
<strong class="bold">    const worker = new Worker(filename);</strong>
<strong class="bold">    worker.on("message", resolve);</strong>
<strong class="bold">    worker.postMessage(value);</strong>
  });
console.log("START");
const result = await callWorker("./fib_worker.js", 40);
console.log("AWAITED", result);
console.log("END");
/* Result:
<strong class="bold">START</strong>
<strong class="bold">AWAITED 102334155</strong>
<strong class="bold">END</strong>
*/</pre>
			<p>The <code>callWorker</code> object we create is a promise that will resolve when the worker sends back a result. Results are as expected: the <code>START</code> text, the <code>AWAITED</code> result from the worker, and the <code>END</code> text. Note that we are using a point-free style for processing the <code>message</code> event.</p>
			<p>These code examples work well, but they have a performance issue: every time you call them, a worker is created (meaning that its JavaScript code must be read, parsed, and processed), so there<a id="_idIndexMarker392"/> will be delays. Let’s think about ways to avoid that.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Long-living pooled workers</h2>
			<p>Workers can stay unterminated <a id="_idIndexMarker393"/>and will be able to receive new messages and reply to them. Messages get queued, so if you need to use the same worker more than once at the same time, there will be a logical delay; calls will go out sequentially. If you need a worker and it’s free, you can call it directly, but if you need it and it’s occupied, it makes sense to create a new worker. We’ll keep a pool of threads, and whenever a call comes in, we’ll check whether there’s an available worker to deal with it or whether we need to create a new worker first.</p>
			<p>Let’s see how to do this. First, we’ll need a pool:</p>
			<pre class="source-code">
// workers/pool.ts
import { Worker } from "worker_threads";
<strong class="bold">type PoolEntry = {</strong>
<strong class="bold">  worker: Worker;</strong>
<strong class="bold">  filename: string;</strong>
<strong class="bold">  value: any;</strong>
<strong class="bold">  inUse: boolean;</strong>
<strong class="bold">};</strong>
const <strong class="bold">pool: PoolEntry[] = []</strong>;</pre>
			<p>The <code>PoolEntry</code> objects will have the following:</p>
			<ul>
				<li>The <code>worker</code> object.</li>
				<li>The filename corresponding to the path with which the worker was created.</li>
				<li>The value with which it was called the last time we used this worker (just for logging; we can do without it).</li>
				<li>the <code>inUse</code> flag to show whether it’s available or not. <code>pool</code> is just an array of <code>PoolEntry</code> objects.</li>
			</ul>
			<p>We need a function that will allow us to call a worker; let’s name it <code>workerCall()</code>. We’ll have to specify the filename of the function to call, and the value to pass to it. The function will first see whether there’s an appropriate available free worker (with the same filename and not in use) in a very declarative fashion; if no worker of this kind is found, it will create a new one. Then, the worker will be called by using a promise, as in the previous section, and <a id="_idIndexMarker394"/>when a result comes, the worker will be marked as not in use, ready for a new call:</p>
			<pre class="source-code">
// continued...
export const workerCall = (
  filename: string,
  value: any
): Promise&lt;any&gt; =&gt; {
<strong class="bold">  let available = pool</strong>
<strong class="bold">    .filter((v) =&gt; !v.inUse)</strong>
<strong class="bold">    .find((x) =&gt; x.filename === filename);</strong>
  if (available === undefined) {
    // console.log("CREATING", filename, value);
    available = {
      worker: new Worker(filename),
      filename,
      value,
      inUse: true,
    } as PoolEntry;
    pool.push(available);
  } else {
    // console.log("REUSING", filename, available.value);
  }
  return new Promise((resolve) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
      // console.log("RESOLVING", filename, value, x);
    });
    available!.worker.postMessage(value);
  });
};</pre>
			<p>We can see how this works with our previous Fibonacci worker, plus a new random one that delays a while before <a id="_idIndexMarker395"/>returning a random number:</p>
			<pre class="source-code">
// workers/random_worker.ts
import { parentPort } from "worker_threads";
<strong class="bold">async function random(n: number): Promise&lt;number&gt; {</strong>
<strong class="bold">  await new Promise((resolve) =&gt; setTimeout(resolve, n));</strong>
<strong class="bold">  return Math.floor(n * Math.random());</strong>
<strong class="bold">}</strong>
parentPort!.on("message", async (m) =&gt;
  parentPort!.postMessage(await random(m))
);</pre>
			<p>We can verify this works:</p>
			<pre class="source-code">
// workers/pool_test.ts
import { workerCall } from "./pool";
const FIB_WORKER = "./fib_worker.js";
const RANDOM_WORKER = "./random_worker.js";
const showResult = (s: string) =&gt; (x: any) =&gt;
  console.log(s, x);
workerCall(FIB_WORKER, 35).then(showResult("fib(35)"));
workerCall(RANDOM_WORKER, 3000).then(showResult("random"));
workerCall(FIB_WORKER, 20).then(showResult("fib(20)"));
workerCall(FIB_WORKER, 44).then(showResult("fib(44)"));
workerCall(FIB_WORKER, 10).then((x) =&gt; {
  console.log("fib(10)", x);
  workerCall(FIB_WORKER, 11).then((y) =&gt;
    console.log("fib(11)", y)
  );
});
workerCall(RANDOM_WORKER, 2000).then(showResult("random"));
workerCall(RANDOM_WORKER, 1000).then(showResult("random"));</pre>
			<p>The results of running<a id="_idIndexMarker396"/> this code are as follows—but I disabled the <code>"Resolving"</code> logging line since I was also logging output in another way:</p>
			<pre class="console">
CREATING ./fib_worker.js 35
CREATING ./random_worker.js 3000
CREATING ./fib_worker.js 20
CREATING ./fib_worker.js 44
CREATING ./fib_worker.js 10
CREATING ./random_worker.js 2000
CREATING ./random_worker.js 1000
<strong class="bold">fib(10) 55</strong>
REUSING ./test_fib_worker.js 10
<strong class="bold">fib(11) 89</strong>
<strong class="bold">fib(20) 6765</strong>
<strong class="bold">fib(35) 9227465</strong>
<strong class="bold">random 602</strong>
<strong class="bold">random 135</strong>
<strong class="bold">random 17</strong>
<strong class="bold">fib(44) 701408733</strong></pre>
			<p>The results of Fibonacci calls come in order; this is logical since we know their calculation time grows. The 3 calls to the random worker take a bit longer, but less than the calculation of the 44th Fibonacci number.</p>
			<p>Notice that we didn’t ask<a id="_idIndexMarker397"/> for the 11th Fibonacci number until the result for the 10th had come in. Our pool correctly detected it had an available worker to use, and it didn’t create a new one.</p>
			<p>You could explore several extra ideas (see the <em class="italic">Questions</em> section at the end of this chapter), but we achieved an efficient solution that let us run functional code in parallel with good performance; a nice win!</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Summary</h1>
			<p>In this chapter, we started working with HOFs to show a more declarative way of working with shorter, more expressive code. We went over several operations: we used <code>reduce()</code> and <code>reduceRight()</code> to get a single result from an array, <code>map()</code> to apply a function to each element of an array, <code>forEach()</code> to simplify looping, <code>flat()</code> and <code>flatMap()</code> to work with arrays of arrays, <code>filter()</code> to pick elements from an array, <code>find()</code> and <code>findIndex()</code> to search in the arrays, and <code>every()</code> and <code>some()</code> (plus a made-up <code>none()</code>) to verify general logic conditions. We then considered some unexpected situations when you deal with <code>async</code> functions, and we wrote special functions for those cases. Finally, we showed how to do parallel work functionally for extra performance.</p>
			<p>In <a href="B19301_06.xhtml#_idTextAnchor107"><em class="italic">Chapter 6</em></a>, <em class="italic">Producing Functions</em>, we will continue working with HOFs, but we will write our own ones to gain more expressive power for our coding.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Questions</h1>
			<p>5.1 <code>filter()</code> → <code>map()</code> →<code> reduce()</code> sequence is quite common (even though sometimes you won’t use all three), and we’ll come back to this in the <em class="italic">Functional design patterns</em> section of <a href="B19301_11.xhtml#_idTextAnchor204"><em class="italic">Chapter 11</em></a><em class="italic">, Implementing Design Patterns</em>. The problem here is how to use those functions (and no others!) to produce an unordered list of elements (<code>&lt;ul&gt;...&lt;/ul&gt;</code>) that can later be used onscreen. Your input is an array of characters such as the following (does the list date me?), and you must produce a list of each name that corresponds to chess or checkers players:</p>
			<pre class="source-code">
const characters = [
  { name: "Fred", plays: "bowling" },
  { name: "Barney", plays: "chess" },
  { name: "Wilma", plays: "bridge" },
  { name: "Betty", plays: "checkers" },
  .
  .
  .
  { name: "Pebbles", plays: "chess" },
];</pre>
			<p>The output would be something like the following (although it doesn’t matter if you don’t generate spaces and indentation). It would be easier if you could use, say, <code>join()</code>, but in this case, it won’t be allowed; only the three functions mentioned can be used:</p>
			<pre class="source-code">
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;Barney&lt;/li&gt;
    &lt;li&gt;Betty&lt;/li&gt;
    .
    .
    .
    &lt;li&gt;Pebbles&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;;</pre>
			<p>5.2 <strong class="bold">More formal testing</strong>: In some preceding examples, such as those in the <em class="italic">Emulating map() with reduce()</em> section, we didn’t write actual unit tests but were satisfied with doing some console logging. Can you write appropriate unit tests instead?</p>
			<p>5.3 <code>reverseString2()</code> function, we used a summing function for the reduction, but we already had written a <code>sum()</code> function in the <em class="italic">Summing an array</em> section; couldn’t we use it here? Why not? How can we solve that?</p>
			<pre class="source-code">
const reverseString2 = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight(sum, "")</strong>;</pre>
			<p>5.4 <code>reverseString2()</code> function (see the previous question) if we summed <code>x</code> and <code>y</code> the reverse way, writing this instead?</p>
			<pre class="source-code">
const reversedReverse = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight((x, y) =&gt; y + x, "")</strong>;</pre>
			<p>5.5 <code>range()</code> function we saw here has many uses but lacks a bit of generality. Can you expand it to allow for descending ranges, as in, <code>range(10,1)</code>? (What should the last number in the range be?) Could you also include a step size to specify the difference between consecutive numbers in the range? With this, <code>range(1,10,2)</code> would produce <code>[1, 3, 5, </code><code>7, 9]</code>.</p>
			<p>5.6 <code>range()</code> function. Instead of first generating a whole array of numbers and then processing them, a generator-based solution generates the range numbers one at a time. Can you provide such an implementation?</p>
			<p>5.7 <code>map(x =&gt; String.fromCharCode(x))</code>, you had written <code>map(String.fromCharCode)</code>? Can you explain the different behavior? Hint: we have seen a similar problem elsewhere in this chapter.</p>
			<p>5.8 <code>\n</code> stands for the newline character:</p>
			<pre class="source-code">
let myData = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]];
let myCSV = dataToCsv(myData);
// "1,2,3,4\n5,6,7,8\n9,10,11,12\n"</pre>
			<p>5.9 <code>flat1()</code> and <code>flat2()</code> work properly if applied to arrays with empty places, such as <code>[22, , 9, , , 60, , ]</code>. Why do they work?</p>
			<p>5.10 <strong class="bold">Producing better output</strong>: Modify the cities query to produce a list of strings that includes not only the name of the city but the state and country as well.</p>
			<p>5.11 <strong class="bold">Old-style code only!</strong>: Can you rewrite the word-counting solution without using any mapping or reducing? This is more of a JavaScript problem than an FP one, but why not?</p>
			<p>5.12 <code>someArray</code>, and apply the following <code>filter()</code> to it, which at first sight doesn’t even look like valid JavaScript code. What will be in the new array, and why?</p>
			<pre class="source-code">
let newArray = someArray.filter(<strong class="bold">Boolean</strong>);</pre>
			<p>5.13 <code>fact4(0)</code> produce the correct result, i.e., 1? Why, or why not?</p>
			<p>5.14 <code>...Async()</code> functions are not methods; can you modify them and add them to <code>Array.prototype</code> so that we can write, for example, <code>[1,2,3,4].mapAsync(…)</code>? And by the way, will chaining work with your solution?</p>
			<p>5.15 <code>forEach()</code>, <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> equivalents for <code>async</code>, but we didn’t do the same for <code>find()</code>, <code>findIndex()</code>, <code>some()</code>, and <code>every()</code>; can you?</p>
			<p>5.16 <strong class="bold">Emptying the pool</strong>: As coded, the pool of workers can only grow in size. What can you do to prevent it from growing indefinitely? Try this idea: whenever there are more than, say, 10 workers not in use, remove some from the pool.</p>
			<p>5.17 <strong class="bold">Queueing for the pool</strong>: You cannot have an unlimited number of parallel workers running simultaneously. Implement a queueing procedure so that all calls will be accepted, but they will only call a worker when the number of workers in use is below a certain threshold.</p>
			<p>5.18 <code>showResult()</code> function in the last section is interesting; how does it work? It’s a function that returns a function; an optimal example of FP!</p>
			<p>5.19 <code>workerCall()</code> in the <em class="italic">Long-living pooled workers</em> section, we wrote the following—is this the best way to find the available workers?</p>
			<pre class="source-code">
  let available = pool
    .filter((v) =&gt; !v.inUse)
    .find((x) =&gt; x.filename === filename);</pre>
			<p>5.20 <code>workerCall()</code> more suited to real-world problems?</p>
		</div>
	</body></html>