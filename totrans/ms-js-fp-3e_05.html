<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-85" class="chapter-number"><a id="_idTextAnchor084"/>5</h1>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Programming Declaratively – A Better Style</h1>
			<p>Up to now, we haven’t really been able to appreciate the possibilities of <strong class="bold">functional programming</strong> (<strong class="bold">FP</strong>) as it pertains to working in a higher-level, declarative fashion. In this chapter, we will correct this and start producing shorter, more concise, and easier-to-understand code, by using some <strong class="bold">higher-order functions</strong> (<strong class="bold">HOFs</strong>) —that is, functions that take functions as parameters, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">reduce()</strong> and <strong class="source-inline">reduceRight()</strong> to apply an operation to a whole array, reducing it to a <span class="No-Break">single result</span></li>
				<li><strong class="source-inline">map()</strong> to transform one array into another by applying a function to each of <span class="No-Break">its elements</span></li>
				<li><strong class="source-inline">flat()</strong> to make a single array out of an array <span class="No-Break">of arrays</span></li>
				<li><strong class="source-inline">flatMap()</strong> to mix together mapping <span class="No-Break">and flattening</span></li>
				<li><strong class="source-inline">forEach()</strong> to simplify writing loops by abstracting the necessary <span class="No-Break">looping code</span></li>
			</ul>
			<p>We’ll also be able to perform searches and selections with <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">filter()</strong> to pick some elements from <span class="No-Break">an array</span></li>
				<li><strong class="source-inline">find()</strong> and <strong class="source-inline">findIndex()</strong> to search for elements that satisfy <span class="No-Break">a condition</span></li>
				<li>A pair of predicates, <strong class="source-inline">every()</strong> and <strong class="source-inline">some()</strong>, to check an array for a <span class="No-Break">Boolean test</span></li>
			</ul>
			<p>Using these functions will let you work more declaratively, and you’ll see that your focus will shift to what you need to do and not so much to how it’s going to be done; the dirty details are hidden inside our functions. Instead of writing a series of possibly nested loops, we’ll focus on using functions as building blocks to specify our <span class="No-Break">desired result.</span></p>
			<p>We will use these functions to work with events in a declarative style, as we’ll see in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing Design Patterns</em>, when we use the <strong class="bold">observer</strong> pattern. We will also be able to work in a <em class="italic">fluent</em> fashion, in which the output of a function becomes the input of the next one, a style we will look <span class="No-Break">at later.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Transformations</h1>
			<p>The first set of operations that we<a id="_idIndexMarker268"/> are going to consider works on an array and processes it in the base of a function to produce certain results. There are several possible results: a single value with the <strong class="source-inline">reduce()</strong> operation, a new array with <strong class="source-inline">map()</strong>, or just about any kind of result <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">forEach()</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Caring about inefficiency</p>
			<p class="callout">If you google around, you will find some articles declaring that these functions are inefficient because a loop done by hand can be faster. This, while possibly true, is practically irrelevant. Unless your code really suffers from speed problems and you can determine that the slowness derives from using these HOFs, trying to avoid them using longer code, with a higher probability of bugs, simply doesn’t make <span class="No-Break">much sense.</span></p>
			<p>Let’s start by considering the preceding list of functions in order, beginning with the most general of all, which, as we’ll see, can even be used to emulate the rest of the transformations in <span class="No-Break">this chapter!</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Reducing an array to a value</h2>
			<p>Answer this question: how many<a id="_idIndexMarker269"/> times have you had to loop through an array, performing an operation (say, summing) to produce a single value (maybe the sum of all the array values) as a result? Probably many, many, many times. This kind of operation can usually be implemented functionally by applying <strong class="source-inline">reduce()</strong> and <strong class="source-inline">reduceRight()</strong>. Let’s start with <span class="No-Break">the former!</span></p>
			<p class="callout-heading">To fold or not to fold</p>
			<p class="callout">Time for some terminology! In usual FP<a id="_idIndexMarker270"/> parlance, we speak of <strong class="bold">folding operations</strong>: <strong class="source-inline">reduce()</strong> is <strong class="bold">foldl</strong> (for <em class="italic">fold left</em>) or just plain <strong class="bold">fold</strong>, and <strong class="source-inline">reduceRight()</strong> is correspondingly <a id="_idIndexMarker271"/>known as <strong class="bold">foldr</strong>. In category theory terms, both <a id="_idIndexMarker272"/>operations are <strong class="bold">catamorphisms</strong>: the reduction of all the values in a container down to a <span class="No-Break">single result.</span></p>
			<p>The inner <a id="_idIndexMarker273"/>workings of the <strong class="source-inline">reduce()</strong> function are illustrated in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_5.1_B19301.jpg" alt="Figure 5.1 – The workings of the reduce() operation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The workings of the reduce() operation</p>
			<p>See how <strong class="source-inline">reduce()</strong> traverses the array, applying a reducing function to each element and the <span class="No-Break">accumulated value.</span></p>
			<p>Why should you always try to use <strong class="source-inline">reduce()</strong> or <strong class="source-inline">reduceRight()</strong> instead of hand-coded loops? The following<a id="_idIndexMarker274"/> points might answer <span class="No-Break">this question:</span></p>
			<ul>
				<li>All the aspects of loop control are <a id="_idIndexMarker275"/>automatically taken care of, so you don’t even have the possibility of an <span class="No-Break">off-by-one mistake</span></li>
				<li>The initialization and handling of the result values are also <span class="No-Break">done implicitly</span></li>
				<li>Unless you work really hard at being impure and modifying the original array, your code will be free <span class="No-Break">of side-effects</span></li>
			</ul>
			<p>Now that we can <strong class="source-inline">reduce()</strong> an array, let’s <a id="_idIndexMarker276"/>see some of its practical <span class="No-Break">use cases.</span></p>
			<h3>Summing an array</h3>
			<p>The most <a id="_idIndexMarker277"/>common example of the application of <strong class="source-inline">reduce()</strong>, usually seen in all textbooks and on all web pages, is the summing of all of the elements of an array. So, to keep with tradition, let’s start with precisely <span class="No-Break">this example!</span></p>
			<p>To reduce an<a id="_idIndexMarker278"/> array, you must<a id="_idIndexMarker279"/> provide a <strong class="bold">dyadic</strong> function (a function with two parameters; <strong class="bold">binary</strong> would be another name for that) and an initial value. In our case, the <a id="_idIndexMarker280"/>function will sum up its two arguments. Initially, the function will be applied to the provided initial value and the first element of the array. For us, the initial value to provide is a zero, and the first result will be the first element itself. Then, the function will be applied again, this time, to the result of the previous operation and the second element of the array, and so the second result will be the sum of the first two elements of the array. Progressing in this fashion along the whole array, the final result will be the sum of all <span class="No-Break">its elements:</span></p>
			<pre class="source-code">
// sum.ts
const myArray = [22, 9, 60, 12, 4, 56];
const sum = (x: number, y: number): number =&gt; x + y;
const mySum = myArray.reduce(<strong class="bold">sum</strong>, <strong class="bold">0</strong>); // 163</pre>
			<p>You don’t actually need the sum definition—you could have just written <strong class="source-inline">myArray.reduce((x,y) =&gt; x+y, 0)</strong>—however, when written in this fashion, the meaning of the code is clearer: you want to reduce the array to a single value by <strong class="source-inline">sum</strong>-ming all its elements. (Would we be forgetting data types with this? No; TypeScript can deduce all the implied types on <span class="No-Break">its own.)</span></p>
			<p>Instead of writing out the loop, initializing a variable to hold the result of the calculations, and going through the array doing the sums, you just declare which operation should be performed. This is what I meant when I said that programming with functions such as those we’ll see in this chapter allows you to work more declaratively, focusing on what rather <span class="No-Break">than how.</span></p>
			<p>You can also even use <strong class="source-inline">reduce()</strong> without providing the initial value: if you skip it, the first value of the array will be used, and the internal loop will start with the second element of the <a id="_idIndexMarker281"/>array; however, be careful if the array is empty and you skipped providing an initial value, as you’ll get a runtime error! See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce</a> for <span class="No-Break">more details.</span></p>
			<p>We can change the reducing function to see how it progresses through its calculations by just including a little bit <span class="No-Break">of impurity!</span></p>
			<pre class="source-code">
// continued...
const sumAndLog = (x: number, y: number): number =&gt; {
<strong class="bold">  console.log(`${x}+${y}=${x + y}`);</strong>
  return x + y;
};
myArray.reduce(sumAndLog, 0);</pre>
			<p>The output would be <span class="No-Break">as follows:</span></p>
			<pre class="console">
0+22=22
22+9=31
31+60=91
91+12=103
103+4=107
107+56=163</pre>
			<p>You can see how the first sum was done by adding the initial value (<strong class="source-inline">0</strong>) and the first element of the array, how that result was used in the second addition, and <span class="No-Break">so on.</span></p>
			<p class="callout-heading">What’s in a name?</p>
			<p class="callout">Part of the reason for the <em class="italic">foldl</em> name seen previously (at least, its ending, <em class="italic">l</em>) should now be clear: the reducing operation proceeds from left to right, from the first element to the last. You may wonder, however, how it would have been named if it had been defined by a right-to-left language (such as Arabic, Hebrew, Farsi, or <span class="No-Break">Urdu) speaker!</span></p>
			<p>This example is common<a id="_idIndexMarker282"/> and well known; let’s do something more complicated. As we’ll find out, <strong class="source-inline">reduce()</strong> will be quite useful for many <span class="No-Break">different</span><span class="No-Break"><a id="_idIndexMarker283"/></span><span class="No-Break"> objectives!</span></p>
			<h3>Calculating an average</h3>
			<p>Let’s do a bit more work. How do <a id="_idIndexMarker284"/>you calculate the average of a list of numbers? If you were explaining this to someone, your answer would surely be something such as <em class="italic">sum all the elements in the list and divide that by the number of elements</em>. In programming terms, this is not a procedural description (you don’t explain how to sum elements or traverse the array) but rather a declarative one since you say what to do, <span class="No-Break">not how.</span></p>
			<p>We can transform that description of the calculation into an almost self-explanatory function (In the <em class="italic">Averaging arrays</em> section of the next chapter, we’ll extend arrays to include an averaging method, based on <span class="No-Break">this code.):</span></p>
			<pre class="source-code">
// average.ts
const myArray = [22, 9, 60, 12, 4, 56];
const sum = (x: number, y: number): number =&gt; x + y;
const average = (arr: number[]): number =&gt;
<strong class="bold">  arr.reduce(sum, 0) / arr.length;</strong>
console.log(average(myArray)); // 27.166667</pre>
			<p>The definition of <strong class="source-inline">average()</strong> follows what a verbal explanation would be: sum the elements of the array, starting from 0, and divide by the array’s <span class="No-Break">length—simpler: impossible!</span></p>
			<p class="callout-heading">Not-so-safe reducing</p>
			<p class="callout">As we mentioned in the previous section, you could also have written <strong class="source-inline">arr.reduce(sum)</strong> without specifying the initial value (<strong class="source-inline">0</strong>) for the reduction; it’s even shorter and closer to the verbal description of the required calculation. This, however, is less safe, because it would fail (producing a runtime error) should the array be empty. So, it’s better to always provide the <span class="No-Break">starting value.</span></p>
			<p>This isn’t, however, the<a id="_idIndexMarker285"/> only way of calculating the average. The reducing function also gets passed the index of the current position of the array as well as the array itself, so you could do something different from <span class="No-Break">last time:</span></p>
			<pre class="source-code">
// continued...
const sumOrDivide = (
  sum: number,
  val: number,
  ind: number,
  arr: number[]
) =&gt; {
  sum += val;
  return <strong class="bold">ind == arr.length - 1 ? sum / arr.length : sum</strong>;
};
const average2 = (arr: number[]): number =&gt;
  arr.reduce(sumOrDivide, 0);
console.log(myArray.reduce(average2, 0)); // 27.166667</pre>
			<p>Given the current index (and, obviously, having access to the array’s length), we can do some trickery: in this case, our reducing <strong class="source-inline">sumOrDivide()</strong> function always sums values, but at the end of the array, it throws in a division so that the average value of the array will be returned. This is slick, but from the point of view of legibility, we can agree that the first version we saw was more declarative and closer to the mathematical definition than this <span class="No-Break">second version.</span></p>
			<p class="callout-heading">Impurity warning!</p>
			<p class="callout">Getting the array and the index means you could also turn the function into an impure one. Avoid this! Anybody who sees a <strong class="source-inline">reduce()</strong> call will automatically assume it’s a pure function and will surely introduce bugs when <span class="No-Break">using it.</span></p>
			<p>This example and the previous one required calculating a single result, but it’s possible to go beyond this and calculate<a id="_idIndexMarker286"/> several values in a single pass. Let’s <span class="No-Break">see how.</span></p>
			<h3>Calculating several values at once</h3>
			<p>What would you do if<a id="_idIndexMarker287"/> you needed to calculate two or more results instead of a single value? This would seem to be a case for providing a clear advantage for standard loops, but there’s a trick that you can use. Let’s yet again revisit the average calculation. We could do it the old-fashioned way by looping and simultaneously summing and counting all the numbers. Well, <strong class="source-inline">reduce()</strong> only lets you produce a single result, but there’s no reason you can’t return an object with as many fields as desired, as we did in the <em class="italic">Impure functions</em> section in <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Behaving Properly</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const average3 = (arr: number[]): number =&gt; {
  const sc = arr.reduce(
    <strong class="bold">(ac, val) =&gt; ({</strong>
<strong class="bold">      sum: val + ac.sum,</strong>
<strong class="bold">      count: ac.count + 1,</strong>
<strong class="bold">    })</strong>,
    <strong class="bold">{ sum: 0, count: 0 }</strong>
  );
  return <strong class="bold">sc.sum / sc.count</strong>;
};
console.log(average3(myArray)); // 27.166667</pre>
			<p>Scrutinize the code carefully. We need two variables: one for the sum and one for the count of all numbers. We provide an object as the initial value for the accumulator, with two properties set to <strong class="source-inline">0</strong>, and our reducing function updates those two properties. After getting the final result with both <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong>, we divide to get the <span class="No-Break">desired average.</span></p>
			<p>By the way, there are options other than using an object. You could also produce any other data structure; let’s see an example with a tuple. The resemblance is <span class="No-Break">pretty obvious:</span></p>
			<pre class="source-code">
// continued...
const average4 = (arr: number[]) =&gt; {
  const sc = arr.reduce(
    <strong class="bold">(ac, val) =&gt; [ac[0] + val, ac[1] + 1]</strong>,
    <strong class="bold">[0, 0]</strong>
  );
  return <strong class="bold">sc[0] / sc[1]</strong>;
};
console.log(average4(myArray)); // 27.166667</pre>
			<p>To be frank, I think it’s way more obscure than the solution with the object. Consider this an alternative (and <a id="_idIndexMarker288"/>not well-recommended) way of calculating many <span class="No-Break">values simultaneously!</span></p>
			<p>We have now seen several examples of the use of <strong class="source-inline">reduce()</strong>, so it’s high time to meet a variant of it, <strong class="source-inline">reduceRight()</strong>, which <span class="No-Break">works similarly.</span></p>
			<h3>Folding left and right</h3>
			<p>The complementary <strong class="source-inline">reduceRight()</strong> method works just as <strong class="source-inline">reduce()</strong> does, only starting at the end and <a id="_idIndexMarker289"/>looping until the beginning <a id="_idIndexMarker290"/>of the array. (Read more about <strong class="source-inline">reduceRight()</strong> at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight</a>.) For many operations (such as the calculation of averages that we saw previously), this makes no difference, but there are some cases in which it will. See <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<p>We shall be seeing a clear case of this in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>; let’s go with a simpler <span class="No-Break">example here:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_5.2_B19301.jpg" alt="Figure 5.2 – The reduceRight() operation works the same way as reduce(), but in reverse order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The reduceRight() operation works the same way as reduce(), but in reverse order</p>
			<p>Suppose that we want to implement a function to reverse a string. (And, obviously, also that we don’t know that<a id="_idIndexMarker291"/> JavaScript already provides a <strong class="source-inline">reverse()</strong> method!) A <a id="_idIndexMarker292"/>solution could be to transform the string into an array by using <strong class="source-inline">split()</strong>, then reversing that array, and finally using <strong class="source-inline">join()</strong> to make it <span class="No-Break">whole again:</span></p>
			<pre class="source-code">
// reverse.ts
const reverseString = (str: string): string =&gt; {
  const arr = str.split("");
  arr.reverse();
  return arr.join("");
};
console.log(reverseString("MONTEVIDEO"));  // OEDIVETNOM</pre>
			<p>This solution works (and yes, it can be shortened, but that’s not the point here), but let’s do it in another way, just to experiment <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">reduceRight()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const reverseString2 = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight((x, y) =&gt; x + y, "")</strong>;
console.log(reverseString2("OEDIVETNOM")); // MONTEVIDEO</pre>
			<p>Note that we didn’t need to specify data types for the reducing function; just like earlier in this chapter, TypeScript was able to figure them out. Also, if you like to re-use code, look at <span class="No-Break"><em class="italic">Question 5.2</em></span><span class="No-Break">!</span></p>
			<p>From the previous examples, you can <a id="_idIndexMarker293"/>also get an idea: if you first apply <strong class="source-inline">reverse()</strong> to an array and then use <strong class="source-inline">reduce()</strong>, the effect will be the same as if you had just applied <strong class="source-inline">reduceRight()</strong> to the original array. There is only one point to take into account: <strong class="source-inline">reverse()</strong> alters the given array, so you would be causing an unintended side-effect by reversing the original array! The only way out would be to first generate a copy of the array and only then do<a id="_idIndexMarker294"/> the rest. Too much work, so it’s best to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">reduceRight()</strong></span><span class="No-Break">!</span></p>
			<p>However, we can draw another conclusion, showing a result we had foretold: it is possible, albeit more cumbersome, to use <strong class="source-inline">reduce()</strong> to simulate the same result as <strong class="source-inline">reduceRight()</strong>—and in later sections, we’ll also use it to emulate the other functions in the chapter. Let’s now<a id="_idIndexMarker295"/> move on to another common and powerful <span class="No-Break">operation: </span><span class="No-Break"><strong class="bold">mapping</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Applying an operation – map()</h2>
			<p>Processing lists of elements <a id="_idIndexMarker296"/>and applying some kind of operation to each of them is a quite common pattern in computer programming. Writing loops that <a id="_idIndexMarker297"/>systematically go through all the elements in an array or collection, starting at the first and looping until finishing with the last, and performing some kind of process on each of them is a basic coding exercise, usually learned in the first days of all programming courses. We already saw one such kind of operation in the previous section with <strong class="source-inline">reduce()</strong> and <strong class="source-inline">reduceRight()</strong>; let’s now turn to a new one, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">map()</strong></span><span class="No-Break">.</span></p>
			<p>In mathematics, a <strong class="bold">map</strong> is a transformation<a id="_idIndexMarker298"/> of elements from a domain into elements of a codomain. For example, you might transform numbers into strings or strings into numbers, but also numbers into numbers, or strings into strings: the important point is that you have a way to transform an element of the first <strong class="bold">kind</strong> or <strong class="bold">domain</strong> (think <strong class="bold">type</strong>, if it helps) into an element of the second kind, or <strong class="bold">codomain</strong>. In our case, this will mean taking the elements of an array<a id="_idIndexMarker299"/> and applying a function to each of them to produce a new array. In more computer-like terms, the <strong class="source-inline">map()</strong> function transforms an array of inputs into an array <span class="No-Break">of outputs.</span></p>
			<p class="callout-heading">Names, names, names…</p>
			<p class="callout">Some more terminology: we would say that an <a id="_idIndexMarker300"/>array is a <strong class="bold">functor</strong> because it provides a mapping operation with some prespecified properties, which we shall see later. And, in category theory, which we’ll talk about a little in <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, the mapping operation itself would be <a id="_idIndexMarker301"/>called <span class="No-Break">a </span><span class="No-Break"><strong class="bold">morphism</strong></span><span class="No-Break">.</span></p>
			<p>The inner workings of the <strong class="source-inline">map()</strong> operation can be seen in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_5.3_B19301.jpg" alt="Figure 5.3 – The map() operation transforms each element of the input array by applying a mapping function"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The map() operation transforms each element of the input array by applying a mapping function</p>
			<p class="callout-heading">More maps available</p>
			<p class="callout">The jQuery library provides<a id="_idIndexMarker302"/> a function, <strong class="source-inline">$.map(array, callback)</strong>, that is <a id="_idIndexMarker303"/>similar to the <strong class="source-inline">map()</strong> method. Be careful, though, because there are important differences. The jQuery function processes the undefined values of the array, while <strong class="source-inline">map()</strong> skips them. Also, if the applied function produces an array as its result, jQuery flattens it and adds each of its individual elements separately, while <strong class="source-inline">map()</strong> just includes those arrays in the result. Underscore, and Ramda also provide similar functions. Finally, JavaScript itself provides an alternative way of doing <strong class="source-inline">map()</strong>: check out the <strong class="source-inline">Array.from()</strong> method at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from</a> and pay special attention to its <span class="No-Break">second argument!</span></p>
			<p>What are the advantages<a id="_idIndexMarker304"/> of using <strong class="source-inline">map()</strong> over using a <span class="No-Break">straightforward</span><span class="No-Break"><a id="_idIndexMarker305"/></span><span class="No-Break"> loop?</span></p>
			<ul>
				<li>First, you don’t have to write any loops, so that’s one less possible source <span class="No-Break">of bugs</span></li>
				<li>Second, you don’t even have to access the original array or the index position, even though they are there for you to use if you really <span class="No-Break">need them</span></li>
				<li>Lastly, a new array is produced, so your code is pure (although, of course, if you really want to produce side effects, <span class="No-Break">you can!)</span></li>
			</ul>
			<p>There are only two caveats when <span class="No-Break">doing this:</span></p>
			<ul>
				<li>Always return<a id="_idIndexMarker306"/> something from your mapping function. If you forget this, then you’ll just produce an array filled with <strong class="source-inline">undefined</strong> values, because JavaScript always provides a default <strong class="source-inline">return undefined</strong> for <span class="No-Break">all functions.</span></li>
				<li>If the input array elements are objects or arrays, and you include them in the output array, then JavaScript will still allow the original elements to <span class="No-Break">be accessed.</span></li>
			</ul>
			<p>Also, there’s a restriction. In JavaScript, <strong class="source-inline">map()</strong> is basically available only for arrays (you can read more about this at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a>); however, in the <em class="italic">Extending current data types</em> section in <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, we will learn how to make it available for other basic types, such as numbers, Booleans, strings, and even functions. Also, libraries such as Lodash, Underscore, and Ramda, provide <span class="No-Break">similar functionalities.</span></p>
			<p>As we did earlier with <strong class="source-inline">reduce()</strong>, let’s now look at some examples of the use of <strong class="source-inline">map()</strong> for common processes so that you’ll better appreciate its power <span class="No-Break">and convenience.</span></p>
			<h3>Extracting data from objects</h3>
			<p>Let’s start with a simple example. Suppose that we have some geographic data (as shown in the following snippet) related to<a id="_idIndexMarker307"/> some South American countries and the coordinates (latitude and longitude) of their capitals. Let’s say that we want to calculate the average position of those cities. (No, I don’t have a clue why we’d want to do that.) How would we go <span class="No-Break">about it?</span></p>
			<pre class="source-code">
// average.ts
const markers = [
  { name: "AR", lat: -34.6, lon: -58.4 },
  { name: "BO", lat: -16.5, lon: -68.1 },
  { name: "BR", lat: -15.8, lon: -47.9 },
  { name: "CL", lat: -33.4, lon: -70.7 },
  { name: "CO", lat:   4.6, lon: -74.0 },
  { name: "EC", lat:  -0.3, lon: -78.6 },
  { name: "PE", lat: -12.0, lon: -77.0 },
  { name: "PY", lat: -25.2, lon: -57.5 },
  { name: "UY", lat: -34.9, lon: -56.2 },
  { name: "VE", lat:  10.5, lon: -66.9 },
];</pre>
			<p class="callout-heading">A lot of negativity?</p>
			<p class="callout">In case you are wondering whether all the data is negative and if so, why, it’s because the countries shown here are all south of the Equator and west of the Greenwich Meridian. However, some South American countries, such as Colombia and Venezuela, have positive latitudes. We’ll return to these data a little later when we study the <strong class="source-inline">some()</strong> and <span class="No-Break"><strong class="source-inline">every()</strong></span><span class="No-Break"> methods.</span></p>
			<p>We would want to use our <strong class="source-inline">average()</strong> function (which we developed earlier in this chapter), but there is a problem: that function can only be applied to an array of <em class="italic">numbers</em>, and what we have here is an array of <em class="italic">objects</em>. We can, however, do a trick: we can focus on calculating the average latitude (we can deal with the longitude later, in a similar fashion). We can map each element of the array to its latitude, and we would then have an appropriate input for <strong class="source-inline">average()</strong>. The solution would be something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// continued...
const averageLat = average(<strong class="bold">markers.map((x) =&gt; x.lat)</strong>);
const averageLon = average(<strong class="bold">markers.map((x) =&gt; x.lon)</strong>);
console.log(averageLat, averageLon); // -15.76, -65.53</pre>
			<p>Mapping an array to<a id="_idIndexMarker308"/> extract data is powerful, but you must be careful. Let’s now look at a case that seems right but produces <span class="No-Break">incorrect results!</span></p>
			<h3>Parsing numbers tacitly</h3>
			<p>Working with <strong class="source-inline">map()</strong> is usually far safer <a id="_idIndexMarker309"/>and simpler than looping by hand, but some edge cases may trip you up. Say you received an array of strings representing numeric values and wanted to parse them into actual numbers. Can you explain the <span class="No-Break">following results?</span></p>
			<pre class="source-code">
["123.45", "67.8", "90"].map(parseFloat);
// [123.45, 67.8, 90]
["123.45", "-67.8", "90"].map(parseInt);
// [123, <strong class="bold">NaN</strong>, <strong class="bold">NaN</strong>]</pre>
			<p>Let’s analyze the results. When we used <strong class="source-inline">parseFloat()</strong> to get floating-point results, everything was OK; however, when we wanted to truncate the results to integer values with <strong class="source-inline">parseInt()</strong>, the output was really awry, and weird <strong class="source-inline">NaN</strong> values appeared. <span class="No-Break">What happened?</span></p>
			<p>The answer lies in a problem with tacit programming. (We have already seen some uses of tacit programming in the <em class="italic">An unnecessary mistake</em> section of <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>, and we’ll see more in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>.) When you don’t explicitly show the parameters to a function, it’s easy for there to be oversights. Look at the following code, which will lead us to <span class="No-Break">the solution:</span></p>
			<pre class="source-code">
["123.45", "-67.8", "90"].map(<strong class="bold">(x) =&gt; parseFloat(x)</strong>);
// [123.45, -67.8, 90]
["123.45", "-67.8", "90"].map(<strong class="bold">(x) =&gt; parseInt(x)</strong>);
// [123, -67, 90]</pre>
			<p>The reason for the unexpected behavior with <strong class="source-inline">parseInt()</strong> is that this function can also receive a second parameter—namely, the radix to use when converting the string into a number. For instance, a call such as <strong class="source-inline">parseInt("100010100001", 2)</strong> will convert a binary number of <strong class="source-inline">100010100001</strong> into <span class="No-Break">a decimal.</span></p>
			<p class="callout-heading">Note:</p>
			<p class="callout">You can read more about <strong class="source-inline">parseInt()</strong> at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a>, where the radix parameter is explained in detail. You should always provide it because some browsers might interpret strings with a leading zero to be octal, which would once again produce <span class="No-Break">unwanted results.</span></p>
			<p>So, what happens<a id="_idIndexMarker310"/> when we provide <strong class="source-inline">parseInt()</strong> to <strong class="source-inline">map()</strong>? Remember that <strong class="source-inline">map()</strong> calls your mapping function with three parameters: the array element value, its index, and the array itself. When <strong class="source-inline">parseInt</strong> receives these values, it ignores the array but assumes that the provided index is actually a radix, and <strong class="source-inline">NaN</strong> values are produced since the original strings are not valid numbers in the <span class="No-Break">given radix.</span></p>
			<p>OK, some functions can lead you astray when mapping, and you now know what to look for. Let’s keep enhancing the way we work by using ranges to write code that would usually require a <span class="No-Break">hand-written loop.</span></p>
			<h3>Working with ranges</h3>
			<p>Let’s now turn to a helper function, which <a id="_idIndexMarker311"/>will come in handy for many uses. We want a <strong class="source-inline">range(start,stop)</strong> function that generates an array of numbers, with values ranging from <strong class="source-inline">start</strong> (inclusive) to <span class="No-Break"><strong class="source-inline">stop</strong></span><span class="No-Break"> (exclusive):</span></p>
			<pre class="source-code">
// range.ts
const range = (start: number, stop: number): number[] =&gt;
  new Array(stop - start).fill(0).map((v, i) =&gt; start + i);
range(2, 7); // [2, 3, 4, 5, 6]</pre>
			<p>Why <strong class="source-inline">fill(0)</strong>? Undefined array elements are skipped by <strong class="source-inline">map()</strong>, so we need to fill them with something or our code will have <span class="No-Break">no effect.</span></p>
			<p class="callout-heading">Expanding your range</p>
			<p class="callout">Libraries such as Underscore and Lodash provide a more powerful version of our <strong class="source-inline">range()</strong> function, letting us go in ascending or descending order and also specifying the step to use—as in <strong class="source-inline">_.range(0, -8, -2)</strong>, which produces <strong class="source-inline">[0, -2, -4, -6]</strong>—but for our needs, the version we wrote is enough. Refer to the <em class="italic">Questions</em> section at the end of <span class="No-Break">this chapter.</span></p>
			<p>How can we use it? In the following section, we’ll see some uses for controlled looping with <strong class="source-inline">forEach()</strong>, but we can redo our factorial function by applying <strong class="source-inline">range()</strong> and then <strong class="source-inline">reduce()</strong>. The idea of this is to generate all the numbers from 1 to <strong class="source-inline">n</strong> and then multiply <span class="No-Break">them together:</span></p>
			<pre class="source-code">
// continued...
const factorialByRange = (n: number): number =&gt;
  range(1, n + 1).reduce((x, y) =&gt; x * y, 1);</pre>
			<p>It’s important to check the<a id="_idIndexMarker312"/> border cases, but the function also works for zero; can you see why? The reason for this is that the produced range is empty: the call is <strong class="source-inline">range(1,1)</strong>, which returns an empty array. Then, <strong class="source-inline">reduce()</strong> doesn’t do any calculations and returns the initial value (<strong class="source-inline">1</strong>), which <span class="No-Break">is correct.</span></p>
			<p>In <a href="B19301_07.xhtml#_idTextAnchor128"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Transforming Functions</em>, we’ll have the opportunity to use <strong class="source-inline">range()</strong> to generate source code; check out the <em class="italic">Currying with eval()</em> and <em class="italic">Partial application with </em><span class="No-Break"><em class="italic">eval()</em></span><span class="No-Break"> sections.</span></p>
			<p>You could use these numeric ranges to produce other kinds of ranges. For example, should you need an array with the alphabet, you could certainly (and tediously) write <strong class="source-inline">["A", "B", "C"</strong>... up to ...<strong class="source-inline">"X", "Y", "Z"]</strong>. A simpler solution would be to generate a range with the ASCII codes for the alphabet and map those <span class="No-Break">to letters:</span></p>
			<pre class="source-code">
// continued...
const ALPHABET = range(
  "A".charCodeAt(0),
  "Z".charCodeAt(0) + 1
).map(<strong class="bold">(x) =&gt; String.fromCharCode(x)</strong>);
// ["A", "B", "C", ... "X", "Y", "Z"]</pre>
			<p>Note the use of <strong class="source-inline">charCodeAt()</strong> to get the ASCII codes for the letters and <strong class="source-inline">String.fromCharCode(x)</strong> to transform the ASCII code into <span class="No-Break">a character.</span></p>
			<p>Mapping is very important and often <a id="_idIndexMarker313"/>used, so let’s now analyze how you could implement it on your own, which could help you develop code for more <span class="No-Break">complex cases.</span></p>
			<h3>Emulating map() with reduce()</h3>
			<p>Earlier in this chapter, we saw how <strong class="source-inline">reduce()</strong> could be used to implement <strong class="source-inline">reduceRight()</strong>. Now, let’s see how <strong class="source-inline">reduce()</strong> can also be used to provide a polyfill for <strong class="source-inline">map()</strong> (not that you will<a id="_idIndexMarker314"/> need it because nowadays, browsers offer both methods, but it will give you more of an idea of what you can achieve with <span class="No-Break">these tools).</span></p>
			<p>Our own <strong class="source-inline">myMap()</strong> is a one-liner but can be hard to understand. We apply the function to each element of the array and use <strong class="source-inline">concat()</strong> to append the result to a result array (which is initially empty). When the loop finishes working with the input array, the result array will have the desired output values. Let’s first see a plain JavaScript version before getting to <span class="No-Break">data typing:</span></p>
			<pre class="source-code">
// map.js
const myMap = (arr, fn) =&gt;
  arr.reduce((x, y) =&gt; x.concat(fn(y)), []);</pre>
			<p>We apply the mapping function to each array element, one by one, and we concatenate the result to the accumulated <span class="No-Break">output array.</span></p>
			<p>Let’s test this with an array and a simple function. We will use both the original <strong class="source-inline">map()</strong> method and <strong class="source-inline">myMap()</strong>, and the results should match! Our mapping function will return double <span class="No-Break">its input:</span></p>
			<pre class="source-code">
// continued...
const dup = (x: number): number =&gt; 2 * x;
console.log(<strong class="bold">myMap(myArray, dup)</strong>);
console.log(<strong class="bold">myArray.map(dup)</strong>);
// [44, 18, 120, 24, 8, 112] both times</pre>
			<p>The first log shows the expected result, produced by <strong class="source-inline">map()</strong>. The second output gives the same result, so it seems that <strong class="source-inline">myMap()</strong> works! And the final output is just to check that the original input array wasn’t modified in any way; mapping operations should always produce a new array. See <em class="italic">Question 5.3</em> for testing our <strong class="source-inline">myMap()</strong> function <span class="No-Break">more thoroughly.</span></p>
			<p>Let’s review our <strong class="source-inline">myMap()</strong> function <a id="_idIndexMarker315"/>and add typing. The needed data types are more complex, and we’ll have a <span class="No-Break">generic function:</span></p>
			<pre class="source-code">
// map.ts
const myMap = <strong class="bold">&lt;T, R&gt;</strong>(arr: <strong class="bold">T[]</strong>, fn: <strong class="bold">(x: T) =&gt; R</strong>): <strong class="bold">R[]</strong> =&gt;
  arr.reduce(
    (x: R[], y: T): R[] =&gt; x.concat(fn(y)),
    [] as R[]
  );</pre>
			<p>Our <strong class="source-inline">myMap()</strong> function receives an array of elements of type <strong class="source-inline">T</strong> and an <strong class="source-inline">fn()</strong> mapping function that transforms its <strong class="source-inline">T</strong> argument into an <strong class="source-inline">R</strong>-type result. The result of this mapping is an array of <strong class="source-inline">R</strong>-type elements. Examine the accumulator function by yourself; is its <span class="No-Break">typing understandable?</span></p>
			<p>Let’s try a different mapping function to verify that our typing is correct.  We’ll use one that returns strings instead of numbers – it just adds dashes before and after its input, to produce <span class="No-Break">a string.</span></p>
			<pre class="source-code">
// continued...
const addDashes = (x: number): string =&gt; `-${x}-`;
const myDashes = myArray.map(<strong class="bold">addDashes</strong>);
// [ '-22-', '-9-', '-60-', '-12-', '-4-', '-56-' ]</pre>
			<p>OK, it seems that our complex type definitions <span class="No-Break">were correct!</span></p>
			<p>All the previous examples in the chapter focused on simple arrays. But what happens if things get more complicated, say if you had to deal with an array whose elements were arrays themselves? Fortunately, there’s a way out of that. Let’s <span class="No-Break">move on.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Dealing with arrays of arrays</h2>
			<p>So far, we have worked with an array of (single) values as an input, but what would happen if your input was an array of arrays? If you consider this to be a far-fetched case, there are many possible <a id="_idIndexMarker316"/>scenarios where this <span class="No-Break">could apply:</span></p>
			<ul>
				<li>For some applications, you could have a table of distances, which in JavaScript requires an array of arrays: <strong class="source-inline">distance[i][j]</strong> would be the distance between <strong class="source-inline">i</strong> and <strong class="source-inline">j</strong>. How could you find the maximum distance between any two points? Finding the maximum is simple with a common array, but how do you deal with an array <span class="No-Break">of arrays?</span></li>
				<li>A more complex example, also in a geographic vein, is that you could query a geographic API for cities matching a string, and the response could be an array of countries, each with an array of states, each itself with an array of matching cities: an array of arrays <span class="No-Break">of arrays!</span></li>
			</ul>
			<p>In the first case, you could want a single array with all distances, and in the second, an array with all cities; how would you manage this? A new operation, <strong class="bold">flattening</strong>, is required; let’s take <span class="No-Break">a look.</span></p>
			<h3>Flattening an array</h3>
			<p>In ES2019, two operations were<a id="_idIndexMarker317"/> added to JavaScript: <strong class="source-inline">flat()</strong>, which we’ll look at now, and <strong class="source-inline">flatMap()</strong>, which we’ll look at later. It’s easier to show what they do than to explain—bear <span class="No-Break">with me!</span></p>
			<p class="callout-heading">No flat() allowed?</p>
			<p class="callout">As often happens, not all browsers have been updated to include these new methods, and Microsoft’s Internet Explorer and others were deficient in this regard, so for web programming, a polyfill will be required. As usual, for updated compatibility data, check out the <em class="italic">Can I use?</em> site, in this case, at <a href="http://caniuse.com/#feat=array-flat">caniuse.com/#feat=array-flat</a>. A piece of good news: since September 2018, all major browsers provide this <span class="No-Break">feature natively!</span></p>
			<p>The <strong class="source-inline">flat()</strong> method creates a new array, concatenating all elements of its subarrays to the desired level, which is, by <span class="No-Break">default, </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const a = [[1, 2], [3, 4, [5, 6, 7]], 8, [[[9]]]];
console.log(a.flat()); // or a.flat(1)
[ 1, 2, 3, 4, [ 5, 6, 7 ], 8, [ [ 9 ] ] ]
console.log(a.flat(2));
[ 1, 2, 3, 4, 5, 6, 7, 8, [ 9 ]]
console.log(a.flat(Infinity));
[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</pre>
			<p>So, how could we use this<a id="_idIndexMarker318"/> function to solve our problems? Using <strong class="source-inline">flat()</strong>, spreading, and <strong class="source-inline">Math.max()</strong> answers the first question (as we saw back in the <em class="italic">Spread</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional</em>; we could have used the <strong class="source-inline">maxArray()</strong> function we wrote back then), and we can also use <strong class="source-inline">reduce()</strong> for variety. Suppose we have the following table <span class="No-Break">of distances:</span></p>
			<pre class="source-code">
const distances = [
  [0, 20, 35, 40],
  [20, 0, 10, 50],
  [35, 10, 0, 30],
  [40, 50, 30, 0],
];</pre>
			<p>Then, we can find our maximum distance in a couple of ways: we either flatten the array, spread it, and use <strong class="source-inline">Math.max()</strong>, or flatten the array and use reducing to explicitly find <span class="No-Break">the maximum:</span></p>
			<pre class="source-code">
// flat.js
const maxDist1 = Math.max(...distances.flat()); // 50
const maxDist2 = distances
  .flat()
  .reduce((p, d) =&gt; Math.max(p, d), 0); // also 50</pre>
			<p>Let’s go back to the second question. Suppose we queried a geographic API for cities that have <strong class="source-inline">"LINCOLN"</strong>  (upper or<a id="_idIndexMarker319"/> lower case) in their names and got the <span class="No-Break">following answer:</span></p>
			<pre class="source-code">
// continued...
const apiAnswer = [
  {
    country: "AR",
    name: "Argentine",
    states: [
      {
        state: "1",
        name: "Buenos Aires",
        cities: [{city: 3846864, name: "Lincoln"}],
      },
    ],
  },
  {
    country: "GB",
    name: "Great Britain",
    states: [
      {
        state: "ENG",
        name: "England",
        cities: [{city: 2644487, name: "Lincoln"}],
      },
    ],
  },
  {
    country: "US",
    name: "United States of America",
    states: [
      {
        state: "CA",
        name: "California",
        cities: [{city: 5072006, name: "Lincoln"}],
      },
      .
      .
      .
      {
        state: "IL",
        name: "Illinois",
        cities: [
          {city: 4899911, name: "Lincoln Park"},
          {city: 4899966, name: "Lincoln Square"},
        ],
      },
    ],
  },
];</pre>
			<p>Extracting the list of cities can <a id="_idIndexMarker320"/>be done by applying <strong class="source-inline">map()</strong> and <span class="No-Break"><strong class="source-inline">flat()</strong></span><span class="No-Break"> twice:</span></p>
			<pre class="source-code">
// continued...
console.log(
  apiAnswer
<strong class="bold">    .map(x =&gt; x.states)</strong>
<strong class="bold">    .flat()</strong>
<strong class="bold">    .map(y =&gt; y.cities)</strong>
<strong class="bold">    .flat()</strong>
);
/* Results:
[ { city: 3846864, name: 'Lincoln' },
  { city: 2644487, name: 'Lincoln' },
  { city: 5072006, name: 'Lincoln' },
  { city: 8531960, name: 'Lincoln' },
  { city: 4769608, name: 'Lincolnia' },
  { city: 4999311, name: 'Lincoln Park' },
  { city: 5072006, name: 'Lincoln' },
  { city: 4899911, name: 'Lincoln Park' },
  { city: 4899966, name: 'Lincoln Square' }
]
*/</pre>
			<p>We have seen how to use <strong class="source-inline">flat()</strong> to flatten an array; let’s now see how to use <strong class="source-inline">flatMap()</strong>, an interesting mixture of <strong class="source-inline">flat()</strong> and <strong class="source-inline">map()</strong>, to further streamline our coding and even further shorten our preceding second solution! (And if you think this exercise wasn’t hard enough <a id="_idIndexMarker321"/>and its output was sort of lame, try out <em class="italic">Question 5.10</em> for a more <span class="No-Break">challenging version!)</span></p>
			<h3>Mapping and flattening – flatMap()</h3>
			<p>Basically, what <strong class="source-inline">flatMap()</strong> does is first apply a <strong class="source-inline">map()</strong> function and then apply <strong class="source-inline">flat()</strong> to the result of the mapping operation. This is an interesting combination because it lets you produce a new array with a different number of elements. (With the normal <strong class="source-inline">map()</strong> operation, the <a id="_idIndexMarker322"/>output array would be precisely the same length as the input array). If your mapping operation produces an array with two or more elements, then the output array will include many output values, and if you produce an empty array, the output array will include <span class="No-Break">fewer values.</span></p>
			<p>Let’s look at a (somehow nonsensical) example. Assume that we have a list of names, such as <strong class="source-inline">"Winston Spencer Churchill"</strong>, <strong class="source-inline">"Abraham Lincoln"</strong>, and <strong class="source-inline">"Socrates"</strong>. Our rule is that if a name has several words, exclude the initial one (the first name, we assume) and separate the rest (last names), but if a name is a single word, drop it (assuming the person has no <span class="No-Break">last name):</span></p>
			<pre class="source-code">
// continued...
const names = [
  "Winston Spencer Churchill",
  "Plato",
  "Abraham Lincoln",
  "Socrates",
  "Charles Darwin",
];
const lastNames = names.<strong class="bold">flatMap</strong>((x) =&gt; {
  const s = x.split(" ");
  return s.length === 1 ? [] : s.splice(1);
});
// [ 'Spencer', 'Churchill', 'Lincoln', 'Darwin' ]</pre>
			<p>As we can see, the output array has a different number of elements than the input array: just because of this, we could consider <strong class="source-inline">flatMap()</strong> to be an upgraded version of <strong class="source-inline">map()</strong>, even including some aspects of <strong class="source-inline">filter()</strong>, like when we excluded <span class="No-Break">single names.</span></p>
			<p>Let’s now move on to a simple example. Keeping with the Lincolnian theme from the last section, let’s count how many words are in Lincoln’s Gettysburg address, given as an array of sentences. By the way, this address is usually considered to be 272 words long, but the version I found doesn’t produce that number! This may be because there are five manuscript copies of the address written by Lincoln himself, plus another version transcribed from shorthand notes taken at the event. In any case, I will leave the discrepancy to historians and stick <span class="No-Break">to coding!</span></p>
			<p>We can use <strong class="source-inline">flatMap()</strong> to split <a id="_idIndexMarker323"/>each sentence into an array of words and then see the length of the <span class="No-Break">flattened array:</span></p>
			<pre class="source-code">
const gettysburg = [
  "Four score and seven years ago our fathers",
  "brought forth, on this continent, a new nation,",
  "conceived in liberty, and dedicated to the",
  "proposition that all men are created equal.",
  "Now we are engaged in a great civil war,",
  "testing whether that nation, or any nation",
  "so conceived and so dedicated, can long endure.",
  "We are met on a great battle field of that",
  "war. We have come to dedicate a portion of",
  "that field, as a final resting place for",
  "those who here gave their lives, that that",
  "nation might live. It is altogether",
  "fitting and proper that we should do this.",
  "But, in a larger sense, we cannot dedicate,",
  "we cannot consecrate, we cannot hallow,",
  "this ground.",
  "The brave men, living and dead, who",
  "struggled here, have consecrated it far",
  "above our poor power to add or detract.",
  "The world will little note nor long",
  "remember what we say here, but it can",
  "never forget what they did here.",
  "It is for us the living, rather, to be",
  "dedicated here to the unfinished work",
  "which they who fought here have thus far",
  "so nobly advanced.",
  "It is rather for us to be here dedicated",
  "to the great task remaining before us—",
  "that from these honored dead we take",
  "increased devotion to that cause for",
  "which they here gave the last full",
  "measure of devotion— that we here highly",
  "resolve that these dead shall not have",
  "died in vain— that this nation, under",
  "God, shall have a new birth of freedom-",
  "and that government of the people, by",
  "the people, for the people, shall not",
  "perish from the earth.",
];
console.log(
  gettysburg<strong class="bold">.flatMap((s: string) =&gt; s.split(" "))</strong>.length
);
// 270 ...not 272?</pre>
			<p>Let’s go back to the problem with the <a id="_idIndexMarker324"/>cities. If we notice that each <strong class="source-inline">map()</strong> was followed by <strong class="source-inline">flat()</strong>, an alternative solution is immediately apparent. Compare this solution with the one we wrote in the <em class="italic">Flattening an array</em> section; it’s essentially the same but conflates each <strong class="source-inline">map()</strong> with its <span class="No-Break">following </span><span class="No-Break"><strong class="source-inline">flat()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
console.log(
  apiAnswer
<strong class="bold">    .flatMap((x) =&gt; x.states)</strong>
<strong class="bold">    .flatMap((y) =&gt; y.cities)</strong>
);
// same result as with separate map() and flat() calls</pre>
			<p>We have now seen the new operations. (And, yes, it’s perfectly possible to solve the problems in this section without mapping, but that wouldn’t be a good example for this section! See <em class="italic">Question 5.11</em> for an alternative to the word counting problem.) Let’s now learn how to emulate these operations should you not have them <span class="No-Break">readily available.</span></p>
			<h3>Emulating flat() and flatMap()</h3>
			<p>We have already seen <a id="_idIndexMarker325"/>how <strong class="source-inline">reduce()</strong> could be used to emulate <strong class="source-inline">map()</strong>. Let’s now see how to work out equivalents for <strong class="source-inline">flat()</strong> and <strong class="source-inline">flatMap()</strong> to get more practice. We’ll also throw in a recursive version, a topic we’ll return to in <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>. As was mentioned earlier, we are not aiming for the fastest or smallest or any particular version of the code; instead, we want to focus on using the concepts we’ve been looking at in <span class="No-Break">this book.</span></p>
			<p>Totally flattening an <a id="_idIndexMarker326"/>array can be done with a recursive call. We use <strong class="source-inline">reduce()</strong> to process the array element by element, and if an element happens to be an array, we recursively <span class="No-Break">flatten it:</span></p>
			<pre class="source-code">
// continued...
const flatAll = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr.reduce(
    (f: T[], v: T) =&gt;
      f.concat(Array.isArray(v) ? flatAll(v) : v),
    [] as T[]
  );</pre>
			<p>Flattening an array to a given <a id="_idIndexMarker327"/>level (not infinity; let’s leave that for later) is easy if you can first flatten an array one level. We can do this either by using spreading or with <strong class="source-inline">reduce()</strong>. Let’s write a <strong class="source-inline">flatOne()</strong> function that flattens just a single level of an array. There are two versions of this; pick whichever <span class="No-Break">you prefer:</span></p>
			<pre class="source-code">
// continued...
const flatOne1 = &lt;T&gt;(arr: T[]): T[] =&gt;
  ([] as T[]).concat(...arr);
const flatOne2 = &lt;T&gt;(arr: T[]): T[] =&gt;
  arr.reduce((f, v) =&gt; f.concat(v), [] as T[]);</pre>
			<p>Using either of these two functions, we can flatten an array of several levels, and we can do this in two different ways. Our two versions of a <strong class="source-inline">flat()</strong> function use our previous <strong class="source-inline">flatOne()</strong> and <strong class="source-inline">flatAll()</strong> functions, but the first one only uses standard looping, while the second one works in a fully recursive way. Which one do <span class="No-Break">you prefer?</span></p>
			<pre class="source-code">
// continued...
const flat1 = &lt;T&gt;(arr: T[], n = 1): T[] =&gt; {
  if (n === Infinity) {
    return flatAll(arr);
  } else {
    let result = arr;
    range(0, n).forEach(() =&gt; {
      result = flatOne(result);
    });
    return result;
  }
};
const flat2 =  &lt;T&gt;(arr: T[], n = 1): T[] =&gt; {
  n === Infinity
    ? flatAll(arr)
    : n === 1
    ? flatOne(arr)
    : flat2(flatOne(arr), n - 1);</pre>
			<p>I think the recursive one is nicer <a id="_idIndexMarker328"/>and more aligned with the theme of this book. Still, it’s up to you, really—although if you don’t feel comfortable with the ternary operator, then the recursive version is definitely not <span class="No-Break">for you!</span></p>
			<p>If you wish to polyfill these<a id="_idIndexMarker329"/> functions (despite our suggestions not to), it’s not complex, and is similar to what we did with the <strong class="source-inline">average()</strong> method previously. I took care not to create any <span class="No-Break">extra methods:</span></p>
			<pre class="source-code">
// continued...
if (!Array.prototype.flat) {
  Array.prototype.flat = function (this, n): any[] {
    if (n === undefined || n === 1) {
      return flatOne(this as any[]);
    } else if (n === Infinity) {
      return flatAll(this as any[]);
    } else {
      return flatOne(this as any[]).flat(n - 1);
    }
  };
}</pre>
			<p>Our <strong class="source-inline">flatOneX()</strong> and <strong class="source-inline">flatAllX()</strong> methods are just copies of what we developed before, and you’ll recognize the code of our previous <strong class="source-inline">flat2()</strong> function at the end of <span class="No-Break">our implementation.</span></p>
			<p>Finally, emulating <strong class="source-inline">flatMap()</strong> is simple in itself, and we can skip it because it’s just a matter of applying <strong class="source-inline">map()</strong> first, and then <strong class="source-inline">flat()</strong>; no <span class="No-Break">big deal!</span></p>
			<p>We have seen how to work with <a id="_idIndexMarker330"/>arrays in several ways, but sometimes what you need isn’t really well served by <a id="_idIndexMarker331"/>any of the functions we have seen. Let’s move on to more general ways of looping, for <span class="No-Break">greater power.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>More general looping</h2>
			<p>The preceding examples that we’ve <a id="_idIndexMarker332"/>seen all loop through arrays, doing some work. However, sometimes, you need to loop, but the required process doesn’t really fit <strong class="source-inline">map()</strong> or <strong class="source-inline">reduce()</strong>. So, what can be done in such cases? There is a <strong class="source-inline">forEach()</strong> method that can help. (Read more about it <span class="No-Break">at </span><a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach</span></a><span class="No-Break">.)</span></p>
			<p>You must provide a callback that will receive the value, the index, and the array on which you are operating. (The last two arguments are optional.) JavaScript will take care of the loop control, and you can do whatever you want at each step. For instance, we can program an object copying method by using <strong class="source-inline">Object</strong> methods to copy the source object attributes one at a time and generate a <span class="No-Break">new object:</span></p>
			<pre class="source-code">
// copy.ts
const objCopy = &lt;T&gt;(obj: T): T =&gt; {
  const copy = Object.create(Object.getPrototypeOf(obj));
  Object.getOwnPropertyNames(obj).forEach((prop: string) =&gt;
    Object.defineProperty(
      copy,
      prop,
      Object.getOwnPropertyDescriptor(obj, prop) as string
    )
  );
  return copy;
};
const myObj = { fk: 22, st: 12, desc: "couple" };
const myCopy = objCopy(myObj);
console.log(myObj, myCopy);
// {fk: 22, st: 12, desc: "couple"}, twice</pre>
			<p>The idea is: we create a <strong class="source-inline">copy</strong> object with the same prototype as the original <strong class="source-inline">obj</strong>, and then for each property in the original, we define an equivalent property in the copy. The function’s signature makes clear that the input and output types are the same. One particular detail: given the loop we are writing, we know for sure that <strong class="source-inline">Object.getOwnPropertyDescriptor(obj, prop)</strong> will be a string (and not <strong class="source-inline">undefined</strong>), but TypeScript cannot tell; adding <strong class="source-inline">as string</strong> <span class="No-Break">solves this.</span></p>
			<p class="callout-heading">Shallow or deep?</p>
			<p class="callout">Yes, of course, we could have written <strong class="source-inline">myCopy={...myObj}</strong>, but where’s the fun in that? It would be better, but I needed a nice example to use <strong class="source-inline">forEach()</strong> with. Sorry about that! Also, there are some hidden inconveniences in that code, which we’ll explain in <a href="B19301_10.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Ensuring Purity</em>, when we try to get frozen, unmodifiable objects. Just a hint: the new object may share values with the old one because we have a shallow copy, not a deep one. We’ll learn more about this later in <span class="No-Break">the book.</span></p>
			<p>If we use the <strong class="source-inline">range()</strong> function<a id="_idIndexMarker333"/> that we defined previously, we can also perform common loops of the <strong class="source-inline">for(let i=0; i&lt;10; i++)</strong> variety. We might write yet another version of factorial (!) <span class="No-Break">using that:</span></p>
			<pre class="source-code">
// loops.ts
import { range } from "./range";
const fact4 = (n: number): number =&gt; {
  let result = 1;
  range(1, n + 1).forEach((v) =&gt; (result *= v));
  return result;
};
console.log(fact4(5)); // 120</pre>
			<p>This definition of factorial really matches the usual description: it generates all the numbers from 1 to <em class="italic">n</em> inclusive and <span class="No-Break">multiplies them—simple!</span></p>
			<p>For greater generality, consider expanding <strong class="source-inline">range()</strong> so it can generate ascending and descending ranges of values, possibly stepping by a number other than 1. This would allow you to replace all the loops in your code with <span class="No-Break"><strong class="source-inline">forEach()</strong></span><span class="No-Break"> loops.</span></p>
			<p>At this point, we have seen many<a id="_idIndexMarker334"/> ways of processing arrays to generate results, but other objectives may be of interest, so let’s now move on to logical functions, which will also simplify our <span class="No-Break">coding needs.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Logical HOFs</h1>
			<p>Up to now, we have been <a id="_idIndexMarker335"/>using HOFs to produce new results. However, some other functions produce logical results by applying a predicate to all the elements of an array. (By the way, we’ll see much more about HOFs in the <span class="No-Break">next chapter.)</span></p>
			<p class="callout-heading">Many meanings</p>
			<p class="callout">A bit of terminology: the word <strong class="bold">predicate</strong> can be <a id="_idIndexMarker336"/>used in several senses (as in predicate logic), but for us, in computer science, it has the meaning of <em class="italic">a function that returns true or false</em>. OK, this isn’t a very formal definition, but it’s enough for our needs. For example, saying that we will filter an array depending on a predicate means that we get to decide which elements are included or excluded depending on the <span class="No-Break">predicate’s result.</span></p>
			<p>Using these functions<a id="_idIndexMarker337"/> implies that your code will become shorter: you can get results corresponding to a whole set of values with a single line <span class="No-Break">of code.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Filtering an array</h2>
			<p>We will encounter a common <a id="_idIndexMarker338"/>need to filter the elements of an array according to a specific condition. The <strong class="source-inline">filter()</strong> method lets you inspect each element of an array in the same fashion as <strong class="source-inline">map()</strong>. The difference is that instead of producing a new element, the result of your function determines whether the input value will be kept in the output (if the function returned <strong class="source-inline">true</strong>) or if it will be skipped (if the function returned <strong class="source-inline">false</strong>). Also, similar to <strong class="source-inline">map()</strong>, <strong class="source-inline">filter()</strong> doesn’t alter the original array but produces a new array with the chosen items. You can read more on the <strong class="source-inline">filter()</strong> function <span class="No-Break">at </span><a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter"><span class="No-Break">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter</span></a><span class="No-Break">.</span></p>
			<p>See <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em> for a diagram showing the input <span class="No-Break">and output:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_5.4_B19301.jpg" alt="Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy a given predicate"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The ﬁlter() method picks the elements of an array that satisfy a given predicate</p>
			<p>There are a couple<a id="_idIndexMarker339"/> of things to remember when filtering <span class="No-Break">an array:</span></p>
			<ul>
				<li><strong class="bold">Always return something from your predicate</strong>: If you forget to include a return, the function will implicitly return <strong class="source-inline">undefined</strong>, and since that’s a falsy value, the output will be an <span class="No-Break">empty array</span></li>
				<li><strong class="bold">The copy that is made is shallow</strong>: If the input array elements are objects or arrays, then the original elements will still <span class="No-Break">be accessible</span></li>
			</ul>
			<p>Let’s get into more detail by <a id="_idIndexMarker340"/>seeing a practical example of <strong class="source-inline">filter()</strong> and then looking at how we could implement that functionality by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">reduce()</strong></span><span class="No-Break">.</span></p>
			<h3>A filter() example</h3>
			<p>Let’s look at a practical example. Suppose a <a id="_idIndexMarker341"/>service has returned a JSON object, which has an array of objects containing an account’s <strong class="source-inline">id</strong> value and <strong class="source-inline">balance</strong>. How can we get the list of IDs <em class="italic">“in the red”</em>, with a negative balance? The input data could be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// filter.ts
const serviceResult = {
  accountsData: [
    { id: "F220960K", balance: 1024 },
    { id: "S120456T", balance: 2260 },
    { id: "J140793A", balance: -38 },
    { id: "M120396V", balance: -114 },
    { id: "A120289L", balance: 55000 },
  ],
};</pre>
			<p>We could get the delinquent accounts with something like the following. You can check that the value of the <strong class="source-inline">delinquent</strong> variable correctly includes the two IDs of accounts with a <span class="No-Break">negative balance:</span></p>
			<pre class="source-code">
// continued...
const delinquent = serviceResult.accountsData.filter(
  <strong class="bold">(v) =&gt; v.balance &lt; 0</strong>
);
console.log(delinquent);
// two objects, with id's <strong class="bold">J140793A</strong> and <strong class="bold">M120396V</strong></pre>
			<p>By the way, given that the filtering operation produced yet another array, if you just wanted the accounts IDs, you could get them by mapping the output to only get the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
// continued...
const delinquentIds = delinquent.<strong class="bold">map((v) =&gt; v.id)</strong>;</pre>
			<p>And if you didn’t care for the intermediate result, a one-liner would have worked <span class="No-Break">as well:</span></p>
			<pre class="source-code">
// continued...
const delinquentIds2 = serviceResult.accountsData
  .filter((v) =&gt; v.balance &lt; 0)
  .map((v) =&gt; v.id);</pre>
			<p>Filtering is a very useful <a id="_idIndexMarker342"/>function, so now, to get a better handle on it, let’s see how you can emulate it, which you could use as a basis for more sophisticated, powerful functions of <span class="No-Break">your own.</span></p>
			<h3>Emulating filter() with reduce()</h3>
			<p>As we did before with <strong class="source-inline">map()</strong>, we can also <a id="_idIndexMarker343"/>create our own version of <strong class="source-inline">filter()</strong> by using <strong class="source-inline">reduce()</strong>. The idea is similar: loop through all the elements of the input array, apply the predicate to it, and if the result is <strong class="source-inline">true</strong>, add the original element to the output array. When the loop is done, the output array will only have those elements for which the predicate <span class="No-Break">was </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const myFilter = &lt;T&gt;(arr: T[], fn: (x: T) =&gt; boolean) =&gt;
  arr.reduce(
    (x: T[], y: T) =&gt; (fn(y) ? x.concat(y) : x),
    []
  );</pre>
			<p>Our function is generic; it takes an array of elements of type <strong class="source-inline">T</strong> and a predicate that accepts a <strong class="source-inline">T</strong>-type parameter and generates a new array of elements of type <strong class="source-inline">T</strong>. We can quickly see that our function works <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
myFilter(serviceResult.accountsData, (v) =&gt; v.balance &lt; 0);</pre>
			<p>The output is the same pair of accounts that we saw earlier in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Searching an array</h2>
			<p>Sometimes, instead <a id="_idIndexMarker344"/>of filtering all the elements of an array, you <a id="_idIndexMarker345"/>want to find an element that satisfies a given predicate. There are a couple of functions that can be used for this, depending on your <span class="No-Break">specific needs:</span></p>
			<ul>
				<li><strong class="source-inline">find()</strong> searches through the array and returns the value of the first element that satisfies a given condition, or <strong class="source-inline">undefined</strong> if no such element <span class="No-Break">is found</span></li>
				<li><strong class="source-inline">findIndex()</strong> performs a similar task, but instead of returning an element, it returns the index of the first element in the array that satisfies the condition, or <strong class="source-inline">-1</strong> if none <span class="No-Break">were found</span></li>
			</ul>
			<p>The similarity to <strong class="source-inline">includes()</strong> and <strong class="source-inline">indexOf()</strong> is clear; these functions search for a specific value instead of an element that satisfies a more general condition. We can easily write <span class="No-Break">equivalent one-liners:</span></p>
			<pre class="source-code">
arr.includes(value);  // arr.find(v =&gt; v === value) arr.indexOf(value);  // arr.findIndex(v =&gt; v === value)</pre>
			<p>Going back to the geographic data we used earlier, we could easily find a given country by using the <strong class="source-inline">find()</strong> method. For instance, let’s get data for Brazil ( <strong class="source-inline">"BR"</strong>); it just takes a single line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
// search.ts
import { markers } from "./average";
const brazilData = markers.<strong class="bold">find((v) =&gt; v.name === "BR")</strong>;
// {name:"BR", lat:-15.8, lon:-47.9}</pre>
			<p>We can’t use the simpler <strong class="source-inline">includes()</strong> method because we have to delve into the object to get the field we want. If we wanted the position of the country in the array, we would have <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">findIndex()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
const brazilIndex = markers<strong class="bold">.findIndex(</strong>
<strong class="bold">  (v) =&gt; v.name === "BR"</strong>
<strong class="bold">)</strong>;
// 2</pre>
			<p>OK, this was easy! What about a special case, which could even be a trick interview question? <span class="No-Break">Read</span><span class="No-Break"><a id="_idIndexMarker346"/></span><span class="No-Break"> on!</span></p>
			<h3>A special search case</h3>
			<p>Suppose you had an array of numbers and wanted to run a sanity check, studying whether any of them were <strong class="source-inline">NaN</strong>. How<a id="_idIndexMarker347"/> would you do this? A tip: don’t try checking the types of the array elements—even though <strong class="source-inline">NaN</strong> stands for not a number, <strong class="source-inline">typeof NaN</strong> <em class="italic">is</em> <strong class="source-inline">"number"</strong>. You’ll get a surprising result if you try to search in an <span class="No-Break">obvious way:</span></p>
			<pre class="source-code">
[1, 2, NaN, 4].findIndex((x) =&gt; x === NaN); // -1</pre>
			<p>What’s going on here? It’s a bit of interesting JavaScript trivia: <strong class="source-inline">NaN</strong> is the only value that isn’t equal to itself. Should you need to look for <strong class="source-inline">NaN</strong>, you’ll have to use the new <strong class="source-inline">isNaN()</strong> function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[1, 2, NaN, 4].findIndex(x =&gt; isNaN(x)); // 2</pre>
			<p>ESLint would help with the <strong class="source-inline">use-isnan</strong> rule: see eslint.org/docs/latest/rules/use-isnan for more on this. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.5</em> shows <span class="No-Break">the result.</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_5.5_B19301.jpg" alt="Figure 5.5 – ESLint prevents you from a NaN-related mistake"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – ESLint prevents you from a NaN-related mistake</p>
			<p>This was a particular case worth knowing about; I had to deal with it once! Now, let’s continue as we have done previously, by emulating the searching methods with <strong class="source-inline">reduce()</strong> so that we can see more examples of the power of <span class="No-Break">that function.</span></p>
			<h3>Emulating find() and findIndex() with reduce()</h3>
			<p>As with the other methods, let’s finish this section by studying how to implement the methods we showed by using the omnipotent <strong class="source-inline">reduce()</strong>. This is a good exercise to get accustomed to working <a id="_idIndexMarker348"/>with HOFs, even if you will never actually<a id="_idIndexMarker349"/> use <span class="No-Break">these polyfills!</span></p>
			<p>The <strong class="source-inline">find()</strong> method requires <a id="_idIndexMarker350"/>a bit of work. We start the search with an <strong class="source-inline">undefined</strong> value, and if we find an array element so that the predicate is <strong class="source-inline">true</strong>, we change<a id="_idIndexMarker351"/> the accumulated value to that of <span class="No-Break">the array:</span></p>
			<pre class="source-code">
arr.find(fn); // or arr.find((x) =&gt; fn(x));
arr.reduce(
  (x, y) =&gt; <strong class="bold">(x === undefined &amp;&amp; fn(y) ? y : x)</strong>,
  undefined
);</pre>
			<p>In terms of performance, there’s a slight difference with the standard <strong class="source-inline">find()</strong> method. The language specification (at <a href="http://tc39.es/ecma262/#sec-array.prototype.find">tc39.es/ecma262/#sec-array.prototype.find</a>) shows that the search stops as soon as an element satisfies the search. Our code, however, keeps processing the rest of the array (because that’s how <strong class="source-inline">reduce()</strong> works), although it doesn’t evaluate the predicate again; can you <span class="No-Break">see why?</span></p>
			<p>For <strong class="source-inline">findIndex()</strong>, we must remember that the callback function receives the accumulated value, the array’s current element, and the index of the current element, but other than that, the equivalent expression is quite similar to the one for <strong class="source-inline">find()</strong>; comparing them is worth <span class="No-Break">the time:</span></p>
			<pre class="source-code">
arr.findIndex(fn);
arr.reduce((x, y, i) =&gt; (x == -1 &amp;&amp; fn(y) ? i : x), -1);</pre>
			<p>The initial accumulated value is <strong class="source-inline">-1</strong> here, which will be the returned value if no element fulfills the predicate. Whenever the accumulated value is still <strong class="source-inline">-1</strong>, but we find an element that satisfies the predicate, we change the accumulated value to the <span class="No-Break">array index.</span></p>
			<p>OK, we are now done with searches: let’s move on to considering higher-level predicates that will simplify testing arrays for a condition, but always in the declarative style we’ve been using <span class="No-Break">so far.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Higher-level predicates – every() and some()</h2>
			<p>The last functions we will consider greatly simplify going through arrays to test for conditions. These functions are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">every()</strong>, which is <strong class="source-inline">true</strong> if and only <a id="_idIndexMarker352"/>if every element in the array satisfies a <span class="No-Break">given predicate</span></li>
				<li><strong class="source-inline">some()</strong>, which is <strong class="source-inline">true</strong> if at least one element in the array satisfies <span class="No-Break">the predicate</span></li>
			</ul>
			<p>For example, we could <a id="_idIndexMarker353"/>quickly check our hypothesis about all the countries having <span class="No-Break">negative coordinates:</span></p>
			<pre class="source-code">
// continued...
markers.every((v) =&gt; v.lat &lt; 0 &amp;&amp; v.lon &lt; 0); // false
markers.some((v) =&gt; v.lat &lt; 0 &amp;&amp; v.lon &lt; 0);  // true</pre>
			<p>If we want to find equivalents to these two functions in terms of <strong class="source-inline">reduce()</strong>, the two alternatives show <span class="No-Break">nice symmetry:</span></p>
			<pre class="source-code">
arr.every(fn);
arr.reduce((x, y) =&gt; x &amp;&amp; fn(y), true);
arr.some(fn);
arr.reduce((x, y) =&gt; x || fn(y), false);</pre>
			<p>The first folding operation evaluates <strong class="source-inline">fn(y)</strong> and ANDs the result with the previous tests; the only way the final result will be <strong class="source-inline">true</strong> is if every test succeeds. The second folding operation is similar, but ORs the result with the previous results and will produce <strong class="source-inline">true</strong> unless every <span class="No-Break">test fails.</span></p>
			<p class="callout-heading">Boolean duality</p>
			<p class="callout">In terms of Boolean algebra, the alternative formulations for <strong class="source-inline">every()</strong> and <strong class="source-inline">some()</strong> exhibit duality. This duality is the same kind that appears in the <strong class="source-inline">x === x &amp;&amp; true</strong> and <strong class="source-inline">x === x || false</strong> expressions; if <strong class="source-inline">x</strong> is a Boolean value, and we exchange <strong class="source-inline">&amp;&amp;</strong> and <strong class="source-inline">||</strong>, and also <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong>, then we transform one expression into the other, and both <span class="No-Break">are valid.</span></p>
			<p>In this section, we saw how to check for a given Boolean condition. Let’s finish by seeing how to check a negative condition by inventing a method of <span class="No-Break">our own.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Checking negatives – none()</h2>
			<p>If you wanted, you<a id="_idIndexMarker354"/> could also define <strong class="source-inline">none()</strong> as the complement of <strong class="source-inline">every()</strong>. This new function would be <strong class="source-inline">true</strong> only if none of the elements of the array satisfied the given predicate. The simplest way of coding this would be by noting that if no elements satisfy the condition, then all elements satisfy the negation of <span class="No-Break">the condition:</span></p>
			<pre class="source-code">
// continued...
const none = &lt;T&gt;(arr: T[], fn: (x: T) =&gt; boolean) =&gt;
  arr.<strong class="bold">every((v) =&gt; !fn(v))</strong>;</pre>
			<p>You can turn it into a method by modifying the array prototype, as we saw earlier. It’s still a bad practice, but it’s what we have until we start looking into better methods for composing and<a id="_idIndexMarker355"/> chaining functions, which we will do in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <span class="No-Break"><em class="italic">Connecting Functions</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// continued...
declare global {
  interface Array&lt;T&gt; {
    <strong class="bold">none(f: (x: T) =&gt; boolean): boolean;</strong>
  }
}
Array.prototype.none = function (fn) {
  return this.every((v) =&gt; !fn(v));
};</pre>
			<p>We had to use <strong class="source-inline">function()</strong> instead of an arrow function for the same reasons we saw on earlier occasions: we need <strong class="source-inline">this</strong> to be correctly assigned. We also had to add a global definition like when we used averages so that TypeScript wouldn’t object to the newly added <strong class="source-inline">none()</strong> method. Other than that, it’s simple coding, and we now have a <strong class="source-inline">none()</strong> method available for all arrays. In <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we will see yet other ways of negating a function by writing an appropriate HOF of <span class="No-Break">our own.</span></p>
			<p>In this and the preceding section, we worked with everyday problems and saw how to solve them declaratively. However, things change a bit when you start working with <strong class="source-inline">async</strong> functions. We will see in the following section that new solutions will <span class="No-Break">be needed.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Working with async functions</h1>
			<p>All the examples <a id="_idIndexMarker356"/>and code we studied in the previous sections were meant to be used with common functions, specifically meaning <em class="italic">not</em> <strong class="source-inline">async</strong> ones. When you want to do mapping, filtering, reducing, and so on, but the function you are using is an <strong class="source-inline">async</strong> one, the results may surprise you. To simplify our work and not deal with actual API calls, let’s create a <strong class="source-inline">fakeAPI(delay, value)</strong> function that will delay a while before returning the <span class="No-Break">given value:</span></p>
			<pre class="source-code">
// async.ts
const fakeAPI = &lt;T&gt;(delay: number, value: T): Promise&lt;T&gt; =&gt;
  <strong class="bold">new Promise((resolve) =&gt;</strong>
<strong class="bold">    setTimeout(() =&gt; resolve(value), delay)</strong>
<strong class="bold">  )</strong>;</pre>
			<p>Let’s also have a function to display what <strong class="source-inline">fakeAPI()</strong> returns so that we can see that things are working <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
// continued...
const useResult = (x: any): void =&gt;
  console.log(new Date(), x);</pre>
			<p>We are using the modern <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> features from ES2017 to simplify our code, and we are avoiding the <span class="No-Break">top-level </span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// async.ts
(async () =&gt; {
  console.log("START");
  console.log(new Date());
  const result = await fakeAPI(1000, 229);
  useResult(result);
  console.log("END");
})();
/*
<strong class="bold">START</strong>
<strong class="bold">2022-10-29T01:28:12.986Z</strong>
<strong class="bold">2022-10-29T01:28:13.989Z 229</strong>
<strong class="bold">END</strong>
*/</pre>
			<p>The results are previsible: we get the <strong class="source-inline">START</strong> text, then about 1 second (1,000 milliseconds) later, the <a id="_idIndexMarker357"/>result of the fake API call (<strong class="source-inline">229</strong>), and finally the <strong class="source-inline">END</strong> text. What could <span class="No-Break">go wrong?</span></p>
			<p class="callout-heading">Top-level await</p>
			<p class="callout">Why are we using the immediate invocation pattern we saw in <a href="B19301_03.xhtml#_idTextAnchor054"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Starting Out with Functions</em>? The reason is that the use of <strong class="source-inline">await</strong> at the top level has been available for Node.js since version 14.8 (August 2020) and browsers since 2021, so it’s not yet widespread. So, as you can only use <strong class="source-inline">await</strong> within an <strong class="source-inline">async</strong> function, I opted to go with an IIFE here for <span class="No-Break">major compatibility.</span></p>
			<p>The critical problem is that all the functions we saw earlier in this chapter are not <strong class="source-inline">async</strong>-<em class="italic">aware</em>, so they won’t work as you’d expect. Let’s start looking <span class="No-Break">at this.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Some strange behaviors</h2>
			<p>Let’s start with a simple <a id="_idIndexMarker358"/>quiz: are results what you expected? Let’s look at a couple of examples of code involving <strong class="source-inline">async</strong> calls, and we’ll see some unexpected results. First, let’s look at a typical straightforward sequence of <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break"> calls:</span></p>
			<pre class="source-code">
// continued...
(async () =&gt; {
  console.log("START SEQUENCE");
  const x1 = await fakeAPI(1000, 1);
  useResult(x1);
  const x2 = await fakeAPI(2000, 2);
  useResult(x2);
  const x3 = await fakeAPI(3000, 3);
  useResult(x3);
  const x4 = await fakeAPI(4000, 4);
  useResult(x4);
  console.log("END SEQUENCE");
})();</pre>
			<p>If you run this code, you’ll get the following results, which are indeed what you would expect—a <strong class="source-inline">START SEQUENCE</strong> text, four individual lines with the results of the fake API calls, and a final <strong class="source-inline">END SEQUENCE</strong> text. Nothing special here—everything <span class="No-Break">is fine!</span></p>
			<pre class="console">
<strong class="bold">START SEQUENCE</strong>
2022-10-29T01:32:11.671Z 1
2022-10-29T01:32:13.677Z 2
2022-10-29T01:32:16.680Z 3
2022-10-29T01:32:20.683Z 4
<strong class="bold">END SEQUENCE</strong></pre>
			<p>Let’s go for an alternative second version, which you’d expect to be equivalent to the first one. The only difference<a id="_idIndexMarker359"/> here is that we are using looping to do the four API calls; it should be the same, shouldn’t it? (We could also have used a <strong class="source-inline">forEach()</strong> loop with the <strong class="source-inline">range()</strong> function that we saw earlier, but that makes no difference.) I kept using an IIFE, though in this particular case, it wasn’t needed; can you <span class="No-Break">see why?</span></p>
			<pre class="source-code">
// continued...
(() =&gt; {
  console.log("START FOREACH");
  [1, 2, 3, 4].forEach(async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    useResult(x);
  });
  console.log("END FOREACH");
})();</pre>
			<p>This code certainly looks equivalent to the first one, but it produces something <span class="No-Break">entirely different!</span></p>
			<pre class="console">
<strong class="bold">START FOREACH</strong>
<strong class="bold">END FOREACH</strong>
2022-10-29T01:34:06.287Z 1
2022-10-29T01:34:07.287Z 2
2022-10-29T01:34:08.286Z 3
2022-10-29T01:34:09.286Z 4</pre>
			<p>The <strong class="source-inline">END FOREACH</strong> text appears before the results of the API calls. What’s happening? The answer is what we mentioned before: methods similar to <strong class="source-inline">forEach()</strong> and the like are meant to be used with<a id="_idIndexMarker360"/> standard, sync function calls and behave strangely with <strong class="source-inline">async</strong> <span class="No-Break">function calls.</span></p>
			<p>The key concept is that <strong class="source-inline">async</strong> functions always return promises, so after getting the <strong class="source-inline">START FOREACH</strong> text, the loop actually creates four promises (which will eventually be resolved at some point), <em class="italic">but without waiting for them</em>, and our code goes on to print the <strong class="source-inline">END</strong> <span class="No-Break"><strong class="source-inline">FOREACH</strong></span><span class="No-Break"> text.</span></p>
			<p>The problem is not only with <strong class="source-inline">forEach()</strong> but also affects all other similar methods. Let’s see how we can work around this situation and write <strong class="source-inline">async</strong>-aware functions to let us keep working in a declarative fashion, as we did earlier in <span class="No-Break">the chapter.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Async-ready looping</h2>
			<p>If we cannot directly use <a id="_idIndexMarker361"/>methods such as <strong class="source-inline">forEach()</strong>, <strong class="source-inline">map()</strong>, and<a id="_idIndexMarker362"/> the like, we’ll have to develop new versions of our own. Let’s see how to <span class="No-Break">achieve this.</span></p>
			<h3>Looping over async calls</h3>
			<p>Since <strong class="source-inline">async</strong> calls return promises, we can emulate <strong class="source-inline">forEach()</strong> with <strong class="source-inline">reduce()</strong> by starting with a resolved<a id="_idIndexMarker363"/> promise and chaining to it the promises for each value in the array. The <strong class="source-inline">then()</strong> methods will be called in the proper order, so the results will be correct. The following piece of code manages to get the right, <span class="No-Break">expected results:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">const forEachAsync = &lt;T&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; any</strong>
<strong class="bold">): Promise&lt;any&gt; =&gt;</strong>
<strong class="bold">  arr.reduce(</strong>
<strong class="bold">    (promise: Promise&lt;void&gt;, value: T) =&gt;</strong>
<strong class="bold">      promise.then(() =&gt; fn(value)),</strong>
<strong class="bold">    Promise.resolve()</strong>
<strong class="bold">  );</strong>
(async () =&gt; {
  console.log("START FOREACH VIA REDUCE");
  await forEachAsync([1, 2, 3, 4], async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    useResult(x);
  });
  console.log("END FOREACH VIA REDUCE");
})();</pre>
			<p>The result is <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker364"/></span><span class="No-Break"> follows:</span></p>
			<pre class="console">
<strong class="bold">START FOREACH VIA REDUCE</strong>
2022-10-29T01:42:09.385Z 1
2022-10-29T01:42:11.388Z 2
2022-10-29T01:42:14.391Z 3
2022-10-29T01:42:18.392Z 4
<strong class="bold">END FOREACH VIA REDUCE</strong></pre>
			<p>As <strong class="source-inline">forEachAsync()</strong> returns a promise, we must remember to await it before showing the final text message. Other than not forgetting all the <strong class="source-inline">await</strong> statements, the code is similar to what we build using <strong class="source-inline">forEach()</strong> with the crucial difference being that this does work <span class="No-Break">as expected!</span></p>
			<h3>Mapping async calls</h3>
			<p>Can we use the other functions? Writing <strong class="source-inline">mapAsync()</strong>, a version of <strong class="source-inline">map()</strong> that can work with an <strong class="source-inline">async</strong> mapping<a id="_idIndexMarker365"/> function, is simple because you can take advantage of <strong class="source-inline">Promise.all()</strong> to create a promise out of an array <span class="No-Break">of promises:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">const mapAsync = &lt;T, R&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; Promise&lt;R&gt;</strong>
<strong class="bold">) =&gt; Promise.all(arr.map(fn));</strong>
(async () =&gt; {
  console.log("START MAP");
  const mapped = await mapAsync([1, 2, 3, 4], async (n) =&gt; {
    const x = await fakeAPI(n * 1000, n);
    return x * 10;
  });
  useResult(mapped);
  console.log("END MAP");
})();</pre>
			<p>We get <span class="No-Break">the following:</span></p>
			<pre class="console">
START MAP
2022-10-29T01:47:06.726Z [ 10, 20, 30, 40 ]
END MAP</pre>
			<p>The structure of the solution is similar to the <strong class="source-inline">forEachAsync()</strong> code. As before, we must remember to <strong class="source-inline">await</strong> the result of <strong class="source-inline">mapAsync()</strong> before continuing the process. Other than that, the<a id="_idIndexMarker366"/> logic is straightforward, and the results are as expected; the mapping function delays for a while and returns 10 times its input argument, and we see the correct output <span class="No-Break">is produced.</span></p>
			<h3>Filtering with async calls</h3>
			<p>Filtering with an <strong class="source-inline">async</strong> function is <a id="_idIndexMarker367"/>a tad more complicated. We will have to use <strong class="source-inline">mapAsync()</strong> to produce an array of <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> results and then use the standard <strong class="source-inline">filter()</strong> method to pick values out of the original array depending on what the <strong class="source-inline">async</strong> filtering function returned. Let’s try out a simple example, calling the API and accepting only even results utilizing a <strong class="source-inline">fakeFilter()</strong> function, which, for our example, accepts even numbers and rejects <span class="No-Break">odd ones:</span></p>
			<pre class="source-code">
// continued...
const fakeFilter = (value: number): Promise&lt;boolean&gt; =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; resolve(value % 2 === 0), 1000)
  );</pre>
			<p>The needed <strong class="source-inline">async</strong> filtering<a id="_idIndexMarker368"/> code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
<strong class="bold">const filterAsync = &lt;T&gt;(</strong>
<strong class="bold">  arr: T[],</strong>
<strong class="bold">  fn: (x: T) =&gt; Promise&lt;boolean&gt;</strong>
<strong class="bold">) =&gt;</strong>
<strong class="bold">  mapAsync(arr, fn).then((arr2) =&gt;</strong>
<strong class="bold">    arr.filter((v, i) =&gt; Boolean(arr2[i]))</strong>
<strong class="bold">  );</strong>
(async () =&gt; {
  console.log("START FILTER");
  const filtered = await filterAsync(
    [1, 2, 3, 4],
    async (n) =&gt; {
      const x = await fakeFilter(n);
      return x;
    }
  );
  useResult(filtered);
  console.log("END FILTER");
})();</pre>
			<p>The result is <span class="No-Break">as follows:</span></p>
			<pre class="console">
START FILTER
2022-10-29T01:56:19.798Z [ 2, 4 ]
END FILTER</pre>
			<p>Note that the result of the mapping of <strong class="source-inline">async</strong> calls is a Boolean array (<strong class="source-inline">arr2</strong>), which we then use with <strong class="source-inline">filter()</strong> to select <a id="_idIndexMarker369"/>elements from the original array of values (<strong class="source-inline">arr</strong>); this can be tricky <span class="No-Break">to understand!</span></p>
			<h3>Reducing async calls</h3>
			<p>Finally, finding an <a id="_idIndexMarker370"/>equivalent for <strong class="source-inline">reduce()</strong> is a bit more complex, but not so much after the other functions that we’ve seen. The key idea is the same as for <strong class="source-inline">forEachAsync()</strong>: each function call will return a promise, which must be awaited in order to update the accumulator in an upcoming <strong class="source-inline">then()</strong>. We set up this iteration with an initial promise that immediately resolves to the initial value for <span class="No-Break">the accumulator:</span></p>
			<pre class="source-code">
// continued...
const reduceAsync = &lt;T, R&gt;(
  arr: T[],
  fn: (acc: R, val: T) =&gt; Promise&lt;R&gt;,
  init: R
) =&gt;
<strong class="bold">  Promise.resolve(init).then((accum) =&gt;</strong>
<strong class="bold">    forEachAsync(arr, async (v: T) =&gt; {</strong>
<strong class="bold">      accum = await fn(accum, v);</strong>
<strong class="bold">    }).then(() =&gt; accum)</strong>
<strong class="bold">  );</strong></pre>
			<p>To do the reducing, let’s use an <strong class="source-inline">async</strong> <strong class="source-inline">fakeSum()</strong> function that will sum the <span class="No-Break">API-returned values:</span></p>
			<pre class="source-code">
// continued...
const fakeSum = (
  value1: number,
  value2: number
): Promise&lt;number&gt; =&gt;
  new Promise((resolve) =&gt;
    setTimeout(() =&gt; resolve(value1 + value2), 1000)
  );
(async () =&gt; {
  console.log("START REDUCE");
  const summed = await reduceAsync(
    [1, 2, 3, 4],
    async (_accum, n) =&gt; {
      const accum = <strong class="bold">await _accum</strong>;
      const x = <strong class="bold">await fakeSum(accum, n)</strong>;
      useResult(`accum=${accum} value=${x} `);
      return x;
    },
    0
  );
  useResult(summed);
  console.log("END REDUCE");
})();</pre>
			<p>Note the critical detail: in <a id="_idIndexMarker371"/>our reducing function, we must first <strong class="source-inline">await</strong> the value of the accumulator and only afterward <strong class="source-inline">await</strong> the result of our <strong class="source-inline">async</strong> function. This is an important point you must not miss: since we are reducing in an <strong class="source-inline">async</strong> fashion, getting the accumulator is also an <strong class="source-inline">async</strong> matter, so we need to <strong class="source-inline">await</strong> both the accumulator and the new <span class="No-Break">API call.</span></p>
			<p>The result shows four intermediate values and the <span class="No-Break">final result:</span></p>
			<pre class="console">
<strong class="bold">START REDUCE</strong>
2022-10-29T02:04:20.862Z accum=0 value=1
2022-10-29T02:04:21.864Z accum=1 value=3
2022-10-29T02:04:22.865Z accum=3 value=6
2022-10-29T02:04:23.866Z accum=6 value=10
2022-10-29T02:04:23.866Z 10
<strong class="bold">END REDUCE</strong></pre>
			<p>By looking at these equivalents, we have seen that <strong class="source-inline">async</strong> functions, despite producing problems with the usual declarative methods that we studied at the beginning of the chapter, may also be handled by similar new functions of our own, so we can keep the new style even for these cases. Even if we have to use a somewhat different set of functions, your code will still be declarative, tighter, and clearer; an <span class="No-Break">all-around win!</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Working with parallel functions</h1>
			<p>JavaScript provides concurrency through <strong class="source-inline">async</strong> functions, meaning that several tasks can go on at the same time, even if a single CPU is <a id="_idIndexMarker372"/>doing all the jobs. <strong class="bold">Web workers</strong> (for the frontend) and <strong class="bold">worker threads</strong> (for the <a id="_idIndexMarker373"/>backend) allow processing in parallel in a different core, for better <a id="_idIndexMarker374"/>performance. This can offload work from the main thread and solve potential problems, in line with our <span class="No-Break">FP approach.</span></p>
			<p>In this section, we’ll see how to avoid bottlenecks in frontend and backend programming by using workers in functional ways, along the lines of the previous sections in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Unresponsive pages</h2>
			<p>Let’s return to our Fibonacci slow-performing code <a id="_idIndexMarker375"/>from the <em class="italic">Memoization</em> section in the previous chapter. Suppose we want to create a web page that will allow users to enter a number and calculate the corresponding Fibonacci number, as in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_5.6_B19301.jpg" alt="Figure 5.6 – A Fibonacci calculator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A Fibonacci calculator</p>
			<p>The code for this page is very basic—and no, I’m not even trying to do any styling; that’s not the <span class="No-Break">problem here!</span></p>
			<pre class="source-code">
// workers/test_worker_1.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Fibonacci&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Fibonacci:
    &lt;input id="num" type="number" min="0" value="0" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    <strong class="bold">&lt;button onclick="locally()"&gt;Locally&lt;/button&gt;</strong>
    &lt;br /&gt;
    &lt;br /&gt;
    Result: &lt;span id="res"&gt;&lt;/span&gt;
    &lt;script src="test_worker_1.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>The script code is <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker376"/></span><span class="No-Break"> follows:</span></p>
			<pre class="source-code">
// workers/test_worker_1.ts
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
function getNumber(): number {
  return Number(
    (document.getElementById("num") as HTMLInputElement)
      .value
  );
}
function showResult(result: number): void {
  document.getElementById("res")!.innerText =
    String(result);
}
<strong class="bold">function locally(): void {</strong>
<strong class="bold">  showResult(fib(getNumber()));</strong>
<strong class="bold">}</strong></pre>
			<p>The corresponding <a id="_idIndexMarker377"/>Fibonacci number is calculated and shown when the user enters a number and clicks on the <strong class="bold">Locally</strong> button, but what happens if a fairly large number (say, around 50) is entered? <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.7</em> illustrates <span class="No-Break">the problem.</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_5.7_B19301.jpg" alt="Figure 5.7 – A long-running process eventually blocks the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – A long-running process eventually blocks the browser</p>
			<p>As the code runs, the page becomes totally unresponsive, and you cannot click anywhere or enter a new number. Furthermore, if a process requires too much processing time, the browser will think there’s a problem and offer the user to kill the page… not what <span class="No-Break">we want!</span></p>
			<p>What’s the solution? We want to offload the calculation to a worker, which will run in parallel, freeing the browser. Let’s see how we’d set this up in not a particularly <span class="No-Break">functional way!</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>A frontend worker</h2>
			<p>Workers (see developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API for web <a id="_idIndexMarker378"/>workers and nodejs.org/api/worker_threads.html for Node.js worker threads) work in similar ways. They are plain <a id="_idIndexMarker379"/>JavaScript code that can listen to messages, and after doing their work, they respond to their caller by sending <span class="No-Break">another message.</span></p>
			<p>For our Fibonacci calculation, the following <span class="No-Break">would do:</span></p>
			<pre class="source-code">
// workers/web_fib_worker.ts
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
<strong class="bold">onmessage = (e: MessageEvent&lt;number&gt;) =&gt;</strong>
<strong class="bold">  postMessage(fib(e.data));</strong>;</pre>
			<p>The last line of the code provides all the interaction between the caller and the worker. On getting a message, <strong class="source-inline">e</strong>, its <strong class="source-inline">e.data</strong> value is passed to the <strong class="source-inline">fib()</strong> function, and the result is posted back to <span class="No-Break">the caller.</span></p>
			<p>How would this be used? <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.8</em> shows the result we try to achieve. We now want to allow two ways of calculating Fibonacci numbers: locally, as before, subject to lengthy processing time problems, or in <a id="_idIndexMarker380"/>parallel, by offloading the job to <span class="No-Break">a worker.</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_5.8_B19301.jpg" alt="Figure 5.8 – Calculating Fibonacci numbers by using workers as an option"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Calculating Fibonacci numbers by using workers as an option</p>
			<p>The new code is as<a id="_idIndexMarker381"/> follows; we’ll highlight <span class="No-Break">the additions:</span></p>
			<pre class="source-code">
// workers/test_worker_2.html
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Fibonacci&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Fibonacci:
    &lt;input id="num" type="number" min="0" value="0" /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;button onclick="locally()"&gt;Locally&lt;/button&gt;
<strong class="bold">    &lt;button onclick="parallelly()"&gt;Parallelly&lt;/button&gt;</strong>
    &lt;br /&gt;
    &lt;br /&gt;
    Result: &lt;span id="res"&gt;&lt;/span&gt;
    &lt;script src="test_worker_2.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
			<p>The new script file is just like the<a id="_idIndexMarker382"/> previous one, with some additions at <span class="No-Break">the end:</span></p>
			<pre class="source-code">
// workers/test_worker_2.ts
.
.
.
const worker = <strong class="bold">new Worker(</strong>
<strong class="bold">  "http://localhost:8887/test_fib_worker.js"</strong>
<strong class="bold">)</strong>;
worker.onmessage = <strong class="bold">(e: MessageEvent&lt;number&gt;) =&gt;</strong>
<strong class="bold">  showResult(e.data)</strong>;
/* eslint-disable-next-line */
function parallelly(): void {
  <strong class="bold">worker.postMessage(getNumber())</strong>;
}</pre>
			<p>The new <strong class="source-inline">Parallelly</strong> button calls the corresponding <strong class="source-inline">parallelly()</strong> function. This function gets the number that the user entered and posts it via a message to the worker that had been created <a id="_idIndexMarker383"/>earlier. The <strong class="source-inline">onmessage</strong> method of that worker receives the calculated result and shows <span class="No-Break">it onscreen.</span></p>
			<p>Using this method, the user can ask for any Fibonacci number, and the window will remain responsive, and no warning will pop up for the user to close the page; see <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_5.9_B19301.jpg" alt="Figure 5.9 – The page remains responsive even as calculations take a long time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The page remains responsive even as calculations take a long time</p>
			<p>OK, using workers<a id="_idIndexMarker384"/> clearly helps if you have lots of calculations to perform at the<a id="_idIndexMarker385"/> frontend; let’s see a similar implementation for <span class="No-Break">the backend.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>A backend worker</h2>
			<p>Let’s see a quick example of a backend worker, as we could use with Node.js or similar. The example will be<a id="_idIndexMarker386"/> very bare-bones; in real life, we’d include route definitions<a id="_idIndexMarker387"/> and much more, but we want to focus on worker creation and <span class="No-Break">usage here.</span></p>
			<p>Our worker is similar to the web worker; the differences are easy <span class="No-Break">to understand:</span></p>
			<pre class="source-code">
// workers/fib_worker.ts
import { parentPort } from "worker_threads";
function fib(n: number): number {
  return n &lt; 2 ? n : fib(n - 2) + fib(n - 1);
}
<strong class="bold">parentPort!.on("message", (m: number) =&gt;</strong>
<strong class="bold">  parentPort!.postMessage(fib(m))</strong>
<strong class="bold">);</strong></pre>
			<p>The idea is precisely the same; when the <strong class="source-inline">message</strong> event occurs, we call <strong class="source-inline">fib()</strong> to calculate the corresponding <a id="_idIndexMarker388"/>Fibonacci number, and we use <strong class="source-inline">postMessage()</strong> to send it to <span class="No-Break">the caller.</span></p>
			<p>The caller code would be <span class="No-Break">simple too:</span></p>
			<pre class="source-code">
// workers/fib_worker_test.ts
import { Worker } from "worker_threads";
const worker = <strong class="bold">new Worker("./fib_worker.js");</strong>
console.log("START");
<strong class="bold">worker.postMessage(40);</strong>
console.log("END");
<strong class="bold">worker.on("message", (msg) =&gt; {</strong>
<strong class="bold">  console.log("MESSAGE", msg);</strong>
<strong class="bold">  worker.terminate();</strong>
<strong class="bold">});</strong></pre>
			<p>The code is totally<a id="_idIndexMarker389"/> analogous to the frontend code. We create a worker (with the <strong class="source-inline">new Worker()</strong> call), we post a message to it with <strong class="source-inline">postMessage()</strong>, and we listen to the worker’s <strong class="source-inline">message</strong> event. When we receive the computed result, we display it, and <strong class="source-inline">terminate()</strong> the worker. Running this code produces the following simple result—the last line takes a while <span class="No-Break">to appear!</span></p>
			<pre class="console">
START
END
MESSAGE 102334155</pre>
			<p>We have seen how to use workers in event-oriented programming, but this isn’t particularly suited to our desired FP way of working; let’s <span class="No-Break">fix that.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Workers, FP style</h2>
			<p>Workers are appropriate <a id="_idIndexMarker390"/>for FP programming for the <span class="No-Break">following reasons:</span></p>
			<p>Workers run in separate contexts, so they cannot interact with the DOM or <span class="No-Break">global variables.</span></p>
			<p>All communication is done through messages; otherwise, workers are separated from <span class="No-Break">their caller.</span></p>
			<ul>
				<li>Data passed to and from workers is a copy; it is serialized before it is passed and deserialized when received. Even if the worker were to modify the arguments it received, that wouldn’t cause any problem for <span class="No-Break">the caller.</span></li>
			</ul>
			<p>We can work with events, but it would be better to wrap workers in promises so we can apply the <strong class="source-inline">async</strong> functions <a id="_idIndexMarker391"/>we developed in the <span class="No-Break">previous section.</span></p>
			<p class="callout-heading">Events or promises?</p>
			<p class="callout">Workers can send multiple messages to their caller. If this is the case, a promise won’t be a good idea because it will be resolved after the first result, disregarding future messages. In most cases, a single result is expected, so promises are OK, but keep in mind there are <span class="No-Break">other possibilities.</span></p>
			<p>A direct way to wrap a worker would be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// workers/fib_worker_test_with_promise.ts
import { Worker } from "worker_threads";
const callWorker = (filename: string, value: unknown) =&gt;
<strong class="bold">  new Promise((resolve) =&gt; {</strong>
<strong class="bold">    const worker = new Worker(filename);</strong>
<strong class="bold">    worker.on("message", resolve);</strong>
<strong class="bold">    worker.postMessage(value);</strong>
  });
console.log("START");
const result = await callWorker("./fib_worker.js", 40);
console.log("AWAITED", result);
console.log("END");
/* Result:
<strong class="bold">START</strong>
<strong class="bold">AWAITED 102334155</strong>
<strong class="bold">END</strong>
*/</pre>
			<p>The <strong class="source-inline">callWorker</strong> object we create is a promise that will resolve when the worker sends back a result. Results are as expected: the <strong class="source-inline">START</strong> text, the <strong class="source-inline">AWAITED</strong> result from the worker, and the <strong class="source-inline">END</strong> text. Note that we are using a point-free style for processing the <span class="No-Break"><strong class="source-inline">message</strong></span><span class="No-Break"> event.</span></p>
			<p>These code examples work well, but they have a performance issue: every time you call them, a worker is created (meaning that its JavaScript code must be read, parsed, and processed), so there<a id="_idIndexMarker392"/> will be delays. Let’s think about ways to <span class="No-Break">avoid that.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Long-living pooled workers</h2>
			<p>Workers can stay unterminated <a id="_idIndexMarker393"/>and will be able to receive new messages and reply to them. Messages get queued, so if you need to use the same worker more than once at the same time, there will be a logical delay; calls will go out sequentially. If you need a worker and it’s free, you can call it directly, but if you need it and it’s occupied, it makes sense to create a new worker. We’ll keep a pool of threads, and whenever a call comes in, we’ll check whether there’s an available worker to deal with it or whether we need to create a new <span class="No-Break">worker first.</span></p>
			<p>Let’s see how to do this. First, we’ll need <span class="No-Break">a pool:</span></p>
			<pre class="source-code">
// workers/pool.ts
import { Worker } from "worker_threads";
<strong class="bold">type PoolEntry = {</strong>
<strong class="bold">  worker: Worker;</strong>
<strong class="bold">  filename: string;</strong>
<strong class="bold">  value: any;</strong>
<strong class="bold">  inUse: boolean;</strong>
<strong class="bold">};</strong>
const <strong class="bold">pool: PoolEntry[] = []</strong>;</pre>
			<p>The <strong class="source-inline">PoolEntry</strong> objects will have <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <span class="No-Break"><strong class="source-inline">worker</strong></span><span class="No-Break"> object.</span></li>
				<li>The filename corresponding to the path with which the worker <span class="No-Break">was created.</span></li>
				<li>The value with which it was called the last time we used this worker (just for logging; we can do <span class="No-Break">without it).</span></li>
				<li>the <strong class="source-inline">inUse</strong> flag to show whether it’s available or not. <strong class="source-inline">pool</strong> is just an array of <span class="No-Break"><strong class="source-inline">PoolEntry</strong></span><span class="No-Break"> objects.</span></li>
			</ul>
			<p>We need a function that will allow us to call a worker; let’s name it <strong class="source-inline">workerCall()</strong>. We’ll have to specify the filename of the function to call, and the value to pass to it. The function will first see whether there’s an appropriate available free worker (with the same filename and not in use) in a very declarative fashion; if no worker of this kind is found, it will create a new one. Then, the worker will be called by using a promise, as in the previous section, and <a id="_idIndexMarker394"/>when a result comes, the worker will be marked as not in use, ready for a <span class="No-Break">new call:</span></p>
			<pre class="source-code">
// continued...
export const workerCall = (
  filename: string,
  value: any
): Promise&lt;any&gt; =&gt; {
<strong class="bold">  let available = pool</strong>
<strong class="bold">    .filter((v) =&gt; !v.inUse)</strong>
<strong class="bold">    .find((x) =&gt; x.filename === filename);</strong>
  if (available === undefined) {
    // console.log("CREATING", filename, value);
    available = {
      worker: new Worker(filename),
      filename,
      value,
      inUse: true,
    } as PoolEntry;
    pool.push(available);
  } else {
    // console.log("REUSING", filename, available.value);
  }
  return new Promise((resolve) =&gt; {
    available!.inUse = true;
    available!.worker.on("message", (x) =&gt; {
      resolve(x);
      available!.inUse = false;
      // console.log("RESOLVING", filename, value, x);
    });
    available!.worker.postMessage(value);
  });
};</pre>
			<p>We can see how this works with our previous Fibonacci worker, plus a new random one that delays a while before <a id="_idIndexMarker395"/>returning a <span class="No-Break">random number:</span></p>
			<pre class="source-code">
// workers/random_worker.ts
import { parentPort } from "worker_threads";
<strong class="bold">async function random(n: number): Promise&lt;number&gt; {</strong>
<strong class="bold">  await new Promise((resolve) =&gt; setTimeout(resolve, n));</strong>
<strong class="bold">  return Math.floor(n * Math.random());</strong>
<strong class="bold">}</strong>
parentPort!.on("message", async (m) =&gt;
  parentPort!.postMessage(await random(m))
);</pre>
			<p>We can verify <span class="No-Break">this works:</span></p>
			<pre class="source-code">
// workers/pool_test.ts
import { workerCall } from "./pool";
const FIB_WORKER = "./fib_worker.js";
const RANDOM_WORKER = "./random_worker.js";
const showResult = (s: string) =&gt; (x: any) =&gt;
  console.log(s, x);
workerCall(FIB_WORKER, 35).then(showResult("fib(35)"));
workerCall(RANDOM_WORKER, 3000).then(showResult("random"));
workerCall(FIB_WORKER, 20).then(showResult("fib(20)"));
workerCall(FIB_WORKER, 44).then(showResult("fib(44)"));
workerCall(FIB_WORKER, 10).then((x) =&gt; {
  console.log("fib(10)", x);
  workerCall(FIB_WORKER, 11).then((y) =&gt;
    console.log("fib(11)", y)
  );
});
workerCall(RANDOM_WORKER, 2000).then(showResult("random"));
workerCall(RANDOM_WORKER, 1000).then(showResult("random"));</pre>
			<p>The results of running<a id="_idIndexMarker396"/> this code are as follows—but I disabled the <strong class="source-inline">"Resolving"</strong> logging line since I was also logging output in <span class="No-Break">another way:</span></p>
			<pre class="console">
CREATING ./fib_worker.js 35
CREATING ./random_worker.js 3000
CREATING ./fib_worker.js 20
CREATING ./fib_worker.js 44
CREATING ./fib_worker.js 10
CREATING ./random_worker.js 2000
CREATING ./random_worker.js 1000
<strong class="bold">fib(10) 55</strong>
REUSING ./test_fib_worker.js 10
<strong class="bold">fib(11) 89</strong>
<strong class="bold">fib(20) 6765</strong>
<strong class="bold">fib(35) 9227465</strong>
<strong class="bold">random 602</strong>
<strong class="bold">random 135</strong>
<strong class="bold">random 17</strong>
<strong class="bold">fib(44) 701408733</strong></pre>
			<p>The results of Fibonacci calls come in order; this is logical since we know their calculation time grows. The 3 calls to the random worker take a bit longer, but less than the calculation of the 44<span class="superscript">th</span> <span class="No-Break">Fibonacci number.</span></p>
			<p>Notice that we didn’t ask<a id="_idIndexMarker397"/> for the 11<span class="superscript">th</span> Fibonacci number until the result for the 10<span class="superscript">th</span> had come in. Our pool correctly detected it had an available worker to use, and it didn’t create a <span class="No-Break">new one.</span></p>
			<p>You could explore several extra ideas (see the <em class="italic">Questions</em> section at the end of this chapter), but we achieved an efficient solution that let us run functional code in parallel with good performance; a <span class="No-Break">nice win!</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Summary</h1>
			<p>In this chapter, we started working with HOFs to show a more declarative way of working with shorter, more expressive code. We went over several operations: we used <strong class="source-inline">reduce()</strong> and <strong class="source-inline">reduceRight()</strong> to get a single result from an array, <strong class="source-inline">map()</strong> to apply a function to each element of an array, <strong class="source-inline">forEach()</strong> to simplify looping, <strong class="source-inline">flat()</strong> and <strong class="source-inline">flatMap()</strong> to work with arrays of arrays, <strong class="source-inline">filter()</strong> to pick elements from an array, <strong class="source-inline">find()</strong> and <strong class="source-inline">findIndex()</strong> to search in the arrays, and <strong class="source-inline">every()</strong> and <strong class="source-inline">some()</strong> (plus a made-up <strong class="source-inline">none()</strong>) to verify general logic conditions. We then considered some unexpected situations when you deal with <strong class="source-inline">async</strong> functions, and we wrote special functions for those cases. Finally, we showed how to do parallel work functionally for <span class="No-Break">extra performance.</span></p>
			<p>In <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we will continue working with HOFs, but we will write our own ones to gain more expressive power for <span class="No-Break">our coding.</span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/>Questions</h1>
			<p>5.1 <strong class="bold">Generating HTML code, with restrictions</strong>: Using the <strong class="source-inline">filter()</strong> → <strong class="source-inline">map()</strong> →<strong class="source-inline"> reduce()</strong> sequence is quite common (even though sometimes you won’t use all three), and we’ll come back to this in the <em class="italic">Functional design patterns</em> section of <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic">, Implementing Design Patterns</em>. The problem here is how to use those functions (and no others!) to produce an unordered list of elements (<strong class="source-inline">&lt;ul&gt;...&lt;/ul&gt;</strong>) that can later be used onscreen. Your input is an array of characters such as the following (does the list date me?), and you must produce a list of each name that corresponds to chess or <span class="No-Break">checkers players:</span></p>
			<pre class="source-code">
const characters = [
  { name: "Fred", plays: "bowling" },
  { name: "Barney", plays: "chess" },
  { name: "Wilma", plays: "bridge" },
  { name: "Betty", plays: "checkers" },
  .
  .
  .
  { name: "Pebbles", plays: "chess" },
];</pre>
			<p>The output would be something like the following (although it doesn’t matter if you don’t generate spaces and indentation). It would be easier if you could use, say, <strong class="source-inline">join()</strong>, but in this case, it won’t be allowed; only the three functions mentioned can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
&lt;div&gt;
  &lt;ul&gt;
    &lt;li&gt;Barney&lt;/li&gt;
    &lt;li&gt;Betty&lt;/li&gt;
    .
    .
    .
    &lt;li&gt;Pebbles&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;;</pre>
			<p>5.2 <strong class="bold">More formal testing</strong>: In some preceding examples, such as those in the <em class="italic">Emulating map() with reduce()</em> section, we didn’t write actual unit tests but were satisfied with doing some console logging. Can you write appropriate unit <span class="No-Break">tests instead?</span></p>
			<p>5.3 <strong class="bold">Reverse by summing</strong>: When we wrote our <strong class="source-inline">reverseString2()</strong> function, we used a summing function for the reduction, but we already had written a <strong class="source-inline">sum()</strong> function in the <em class="italic">Summing an array</em> section; couldn’t we use it here? Why not? How can we <span class="No-Break">solve that?</span></p>
			<pre class="source-code">
const reverseString2 = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight(sum, "")</strong>;</pre>
			<p>5.4 <strong class="bold">Reversed reverse?</strong>: What would happen with our <strong class="source-inline">reverseString2()</strong> function (see the previous question) if we summed <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> the reverse way, writing <span class="No-Break">this instead?</span></p>
			<pre class="source-code">
const reversedReverse = (str: string): string =&gt;
  <strong class="bold">str.split("").reduceRight((x, y) =&gt; y + x, "")</strong>;</pre>
			<p>5.5 <strong class="bold">Ranging far and wide</strong>: The <strong class="source-inline">range()</strong> function we saw here has many uses but lacks a bit of generality. Can you expand it to allow for descending ranges, as in, <strong class="source-inline">range(10,1)</strong>? (What should the last number in the range be?) Could you also include a step size to specify the difference between consecutive numbers in the range? With this, <strong class="source-inline">range(1,10,2)</strong> would produce <strong class="source-inline">[1, 3, 5, </strong><span class="No-Break"><strong class="source-inline">7, 9]</strong></span><span class="No-Break">.</span></p>
			<p>5.6 <strong class="bold">Range generators</strong>: JavaScript’s <strong class="bold">generators</strong> allow another solution to our <strong class="source-inline">range()</strong> function. Instead of first generating a whole array of numbers and then processing them, a generator-based solution generates the range numbers one at a time. Can you provide such <span class="No-Break">an implementation?</span></p>
			<p>5.7 <strong class="bold">Doing the alphabet</strong>: What would have happened in the <em class="italic">Working with ranges</em> section if instead of writing <strong class="source-inline">map(x =&gt; String.fromCharCode(x))</strong>, you had written <strong class="source-inline">map(String.fromCharCode)</strong>? Can you explain the different behavior? Hint: we have seen a similar problem elsewhere in <span class="No-Break">this chapter.</span></p>
			<p>5.8 <strong class="bold">Producing a CSV</strong>: In a certain scenario, you may want to enable the user to download a dataset as a <strong class="bold">comma-separated value</strong> (<strong class="bold">CSV</strong>) file by using a data URI. (You can read more about this at <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">en.wikipedia.org/wiki/Data_URI_scheme</a>.) Of course, the first problem is producing the CSV itself! Assume that you have an array of arrays of numeric values, as shown in the following snippet, and write a function that will transform that structure into a CSV string that you will then be able to plug into the URI. As usual, <strong class="source-inline">\n</strong> stands for the <span class="No-Break">newline character:</span></p>
			<pre class="source-code">
let myData = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]];
let myCSV = dataToCsv(myData);
// "1,2,3,4\n5,6,7,8\n9,10,11,12\n"</pre>
			<p>5.9 <strong class="bold">An empty question?</strong>: Check that <strong class="source-inline">flat1()</strong> and <strong class="source-inline">flat2()</strong> work properly if applied to arrays with empty places, such as <strong class="source-inline">[22, , 9, , , 60, , ]</strong>. Why do <span class="No-Break">they work?</span></p>
			<p>5.10 <strong class="bold">Producing better output</strong>: Modify the cities query to produce a list of strings that includes not only the name of the city but the state and country <span class="No-Break">as well.</span></p>
			<p>5.11 <strong class="bold">Old-style code only!</strong>: Can you rewrite the word-counting solution without using any mapping or reducing? This is more of a JavaScript problem than an FP one, but <span class="No-Break">why not?</span></p>
			<p>5.12 <strong class="bold">Filtering... but what?</strong>: Suppose you have an array called <strong class="source-inline">someArray</strong>, and apply the following <strong class="source-inline">filter()</strong> to it, which at first sight doesn’t even look like valid JavaScript code. What will be in the new array, <span class="No-Break">and why?</span></p>
			<pre class="source-code">
let newArray = someArray.filter(<strong class="bold">Boolean</strong>);</pre>
			<p>5.13 <strong class="bold">Yet another factorial question</strong>: Does <strong class="source-inline">fact4(0)</strong> produce the correct result, i.e., 1? Why, or <span class="No-Break">why not?</span></p>
			<p>5.14 <strong class="bold">Async chaining</strong>: Our <strong class="source-inline">...Async()</strong> functions are not methods; can you modify them and add them to <strong class="source-inline">Array.prototype</strong> so that we can write, for example, <strong class="source-inline">[1,2,3,4].mapAsync(…)</strong>? And by the way, will chaining work with <span class="No-Break">your solution?</span></p>
			<p>5.15 <strong class="bold">Missing equivalents</strong>: We wrote <strong class="source-inline">forEach()</strong>, <strong class="source-inline">map()</strong>, <strong class="source-inline">filter()</strong>, and <strong class="source-inline">reduce()</strong> equivalents for <strong class="source-inline">async</strong>, but we didn’t do the same for <strong class="source-inline">find()</strong>, <strong class="source-inline">findIndex()</strong>, <strong class="source-inline">some()</strong>, and <strong class="source-inline">every()</strong>; <span class="No-Break">can you?</span></p>
			<p>5.16 <strong class="bold">Emptying the pool</strong>: As coded, the pool of workers can only grow in size. What can you do to prevent it from growing indefinitely? Try this idea: whenever there are more than, say, 10 workers not in use, remove some from <span class="No-Break">the pool.</span></p>
			<p>5.17 <strong class="bold">Queueing for the pool</strong>: You cannot have an unlimited number of parallel workers running simultaneously. Implement a queueing procedure so that all calls will be accepted, but they will only call a worker when the number of workers in use is below a <span class="No-Break">certain threshold.</span></p>
			<p>5.18 <strong class="bold">Showing results</strong>: The <strong class="source-inline">showResult()</strong> function in the last section is interesting; how does it work? It’s a function that returns a function; an optimal example <span class="No-Break">of FP!</span></p>
			<p>5.19 <strong class="bold">Double filtering?</strong>: In <strong class="source-inline">workerCall()</strong> in the <em class="italic">Long-living pooled workers</em> section, we wrote the following—is this the best way to find the <span class="No-Break">available workers?</span></p>
			<pre class="source-code">
  let available = pool
    .filter((v) =&gt; !v.inUse)
    .find((x) =&gt; x.filename === filename);</pre>
			<p>5.20 <strong class="bold">Wishful thinking</strong>: The way we are working with parallel calls, we assume everything will be all right, with no errors or problems. What should you add to make <strong class="source-inline">workerCall()</strong> more suited to <span class="No-Break">real-world problems?</span></p>
		</div>
	</body></html>