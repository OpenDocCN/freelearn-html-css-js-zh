<html><head></head><body>
		<div><h1 id="_idParaDest-130" class="chapter-number"><a id="_idTextAnchor180"/>9</h1>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor181"/>The Ancient Spell Book – Building the Page Object Model</h1>
			<p>All frameworks have three to four abstraction layers. This might best be visualized as a book of ancient spells. The easiest incantations are at the beginning. These are building blocks for more complex and powerful enchantments in the middle. And the darkest secrets are always at the end of the cryptic grimoire. Similarly, there is the Test layer, which calls upon the methods referencing objects in the middle Page Object Class layer, which in turn utilizes helper wrappers and other functionality at the bottom-most Core layer. In a Cucumber framework, there is an additional abstraction layer from the Test Feature File layer to the step definitions to the Glue code to the core code layer. In this chapter, we focus on creating page elements and the methods used to perform actions on the page.</p>
			<p>Before that, here's a list of all the main topics we'll be covering in the chapter:</p>
			<ul>
				<li>Understanding what page object model is</li>
				<li>Creating a page class for the tests</li>
				<li>Adding object selectors</li>
				<li>The module.exports statement</li>
				<li>Reducing code with common objects and methods</li>
				<li>POM using Klassi-js</li>
			</ul>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor182"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub repository: <a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</a></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor183"/>What is Page Object Model?</h1>
			<p><strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) is a design pattern used in test automation to create a structured and maintainable framework<a id="_idIndexMarker371"/> for web application testing. It promotes the separation of test code from the implementation details of the web pages.</p>
			<p>In POM, each web page is represented as a separate class, and the properties and behaviors of the page are encapsulated within that class. Test methods interact with the web pages using the methods provided by the page classes, rather than directly accessing the web elements or using low-level browser APIs.</p>
			<p>POM can be implemented in <a id="_idIndexMarker372"/>Node.js using frameworks such as WebdriverIO or Klassi-js</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor184"/>What constitutes a good Page Object pattern?</h1>
			<p>A good Page Object pattern in test automation is one that promotes the maintainability, reusability, and readability of the code. Some characteristics of a well-implemented Page Object pattern are:</p>
			<ul>
				<li><strong class="bold">Adheres to the Single Responsibility Principle (SRP)</strong>: Each page class should have a single <a id="_idIndexMarker373"/>responsibility and represent a specific page or component of the application. This ensures that the code is well-organized and easy to maintain.</li>
				<li><strong class="bold">Encapsulation</strong>: The page class should encapsulate the details and behavior of the web page or component it represents. It should provide methods to interact with the page elements without exposing the underlying implementation details. This abstraction simplifies test code and makes it more readable.</li>
				<li><strong class="bold">Modular and reusable</strong>: Page classes should be modular and reusable across different tests and test suites. They should provide a consistent interface to interact with the page elements, allowing for easy reuse and reducing code duplication.</li>
				<li><strong class="bold">Adheres to separation of concerns (SoC)</strong>: The Page Object pattern separates the test logic from the implementation details of the web pages. Test methods should utilize the methods provided by the page classes rather than directly interacting with the web elements or using low-level browser APIs. This separation improves code maintainability and makes it easier to update the tests when the application changes.</li>
				<li><strong class="bold">Independent of test framework</strong>: Page classes should be independent of the specific test framework being used. They should not have any dependency on the testing framework, such as assertions or test execution logic. This ensures that the page classes can be easily reused with different testing frameworks or tools. Take a look at the following example:<pre class="source-code">
class LoginPage {
  get usernameField() { return $('#username'); }
  get passwordField() { return $('#password'); }
  get loginButton() { return $('#login'); }
  enterUsername(username) {
    this.usernameField.setValue(username);
  }</pre></li>				<li><strong class="bold">Clear naming conventions</strong>: Page classes, methods, and variables should have meaningful and descriptive names that accurately represent their purpose and functionality. This<a id="_idIndexMarker374"/> helps improve code readability and understanding:<pre class="source-code">
loadPage: Async (url, seconds) =&gt; {
Await browser.url(url, seconds)
}</pre></li>				<li><strong class="bold">Undergoes regular maintenance</strong>: Page classes should be regularly maintained and updated as the application evolves. They should be kept in sync with the changes in the application’s UI and functionality. Regularly reviewing and updating page classes helps ensure their accuracy and reliability.</li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor185"/>Creating a page class for the tests</h1>
			<p>We have created a <code>LoginPage</code> class that <a id="_idIndexMarker375"/>represents a specific page of the web application. The web element selectors are defined as getters using the <code>$</code> function from WebdriverIO, which allows us to locate elements on the page using CSS selectors.</p>
			<p>The class also includes page methods such as <code>enterUsername</code>, <code>enterPassword</code>, and <code>clickLoginButton</code>. These methods encapsulate actions that can be performed on the page, such as entering<a id="_idIndexMarker376"/> text into input fields and clicking buttons.</p>
			<p>The <code>mkdir</code> command in Linux/Unix allows users to create or make new directories. <code>mkdir</code> stands for “make directory”:</p>
			<p>Go to your <code>mkdir</code> command:</p>
			<pre class="console">
mkdir loginPage.ts
homePage.ts
testClass.ts</pre>			<h1 id="_idParaDest-136"><a id="_idTextAnchor186"/>Adding object selectors</h1>
			<p>The <code>TestClass</code> test class <a id="_idIndexMarker377"/>utilizes the exported instances of the page classes. In the test case, we interact with the web pages using the methods defined in the page objects.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor187"/>// LoginPage.ts</h2>
			<p><code>LoginPage</code>: This class encapsulates <a id="_idIndexMarker378"/>the properties and behaviors of it respective web pages:</p>
			<pre class="console">
class LoginPage {
  get usernameField() { return $('#us<a id="_idTextAnchor188"/>ername'); }
  get passwordField() { return $('#password'); }
  get loginButton() { return $('#login'); }
  enterUsername(username) {
    this.usernameField.setValue(username);
  }
  enterPassword(password) {
    this.passwordField.setValue(password);
  }
  clickLoginButton() {
    this.loginButton.click();
  }
}
module.exports = new LoginPage();</pre>			<h2 id="_idParaDest-138"><a id="_idTextAnchor189"/>// HomePage.ts</h2>
			<p><code>HomePage</code>: This class<a id="_idIndexMarker379"/> encapsulates the properties and behaviors of their respective web pages:</p>
			<pre class="console">
class HomePage {
  get welcomeMessage() { return $('#welcome'); }
  get logoutButton() { return $('#logout'); }
  getWelcomeMessage() {
    return this.welcomeMessage.getText();
  }
  clickLogoutButton() {
    this.logoutButton.click();
  }
}</pre>			<h1 id="_idParaDest-139"><a id="_idTextAnchor190"/>module.exports = new HomePage();Calling methods to be used in the test</h1>
			<p>The <code>module.exports</code> statement is used to<a id="_idIndexMarker380"/> export an instance of each page class as a module:</p>
			<pre class="console">
module.exports = new HomePage();
module.exports = new loginPage();</pre>			<h2 id="_idParaDest-140"><a id="_idTextAnchor191"/>// TestName.ts</h2>
			<p>The <code>TestName</code> test file utilizes the <a id="_idIndexMarker381"/>exported instances of the page classes. In this example test case, we interact with the LoginPage and the HomePage web pages using the methods and objects defined in the respective page classes:</p>
			<pre class="console">
import LoginPage from('../PageObjects/LoginPage');
import HomePage from('../PageObjects/HomePage');
import assert from('assert');
describe('Test Name', () =&gt; {
  before(() =&gt; {
    // Set up WebDriverIO configuration
  });
  it('should perform login and logout', () =&gt; {
    LoginPage.enterUsername('username');
    LoginPage.enterPassword('password');
    LoginPage.clickLoginButton();
    const welcomeMessage = HomePage.getWelcomeMessage();
    assert.strictEqual(welcomeMessage, 'Welcome, User!');
    HomePage.clickLogoutButton();
  });
  after(() =&gt; {
    // Quit WebDriverIO instance
  });
});</pre>			<h1 id="_idParaDest-141"><a id="_idTextAnchor192"/>Reducing code with common objects and methods</h1>
			<p>Reducing code duplication and improving maintainability can be achieved by leveraging common objects and methods in your Page Object pattern. Some strategies to achieve code reduction are set out here:</p>
			<ul>
				<li><strong class="bold">Base page class</strong>: Create a <a id="_idIndexMarker382"/>base page class that contains common objects and methods shared across multiple pages. This base class can encapsulate elements and behaviors that are common to multiple pages, such as a <strong class="bold">Home</strong> button, <strong class="bold">Halloween Party</strong> button, and then a <strong class="bold">Find My Candy!</strong> button, to reduce duplication:</li>
			</ul>
			<div><div><img src="img/B19395_09_1.jpg" alt="Figure 9.1 – Header of CandyMapper party page website with links common to all pages"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Header of CandyMapper party page website with links common to all pages</p>
			<p>These elements appear in the header of every page of the website. So, it makes sense to declare them in the top-level page class and extend it to all other pages.</p>
			<div><div><img src="img/B19395_09_2.jpg" alt="Figure 9.2 – Header page of the Candymapper landing page with three  common links"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Header page of the Candymapper landing page with three  common links</p>
			<p class="list-inset">If the selectors were in every page class, there would be an increasing level of maintenance<a id="_idIndexMarker383"/> over time. So, we will create selectors in the common page class like this:</p>
			<pre class="source-code">
  get homeButton() {return $(`//a[text()='Home']`); }</pre>			<div><div><img src="img/B19395_09_3.jpg" alt="Figure 9.3 – Highlight of HOME link from the link selector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Highlight of HOME link from the link selector</p>
			<p class="list-inset">Let’s take a moment to look at these three examples as some changes could be made. These selectors match buttons in the header and the footer of the page. We could lock into just the first element match like this:</p>
			<pre class="source-code">
get homeButton() {return $(`(//a[text()='Home'])[1]`); }
get halloweenPartyButton() {return $(` (//a[contains(text(), 'Party')])[1]`); }</pre>			<div><div><img src="img/B19395_09_4.jpg" alt="Figure 9.4 – Locator identified for first Halloween Party link"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Locator identified for first Halloween Party link</p>
			<p class="list-inset">Since these elements are common to all our pages, it would make sense to create a common base <code>Page</code> class and store all of them there:</p>
			<pre class="source-code">
export default class Page {
  get homeButton() {return $(`//a[text()='Home']`); }
  get halloweenPartyButton() {return $(` (//a[contains(text(), 'Party')])[1]`); }
}</pre>			<p class="list-inset">Other page classes can now inherit from this base <code>Page</code> class all its common objects and functionality. We can use the <code>extends</code> keyword to add these object to any <code>Page</code> class:</p>
			<pre class="source-code">
import * as helpers from "../../helpers/helpers";
import Page from "./page";
class CandymapperPage extends Page{
  await helpers.clickAdv(await    
    super.halloweenPartyButton);
}</pre>			<p class="list-inset">Last, we use the <code>super</code> keyword to reference objects and methods in the common parent class to reduce repeated code.</p>
			<p class="list-inset">If we find only the case of the text of common elements is different from page to page or is frequently changing release to release , we can use this next approach to reduce maintenance. Consider the 'FIND MY CANDY' link element below: </p>
			<pre class="source-code">
 get findMyCandyButton() {return $(` (//a[contains(translate(normalize-space(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'my candy') and not(contains(@style, 'display: none')) and not(contains(@style, 'visibility: hidden'))])[1]`); }</pre>			<div><div><img src="img/B19395_09_5.jpg" alt="Figure 9.5 – Case insensitive match Locator for Find my candy! link"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Case insensitive match Locator for Find my candy! link</p>
			<p class="list-inset">This is done via the<a id="_idIndexMarker384"/> display or visibility property of the element style.  There is a single trick to find only elements that are visible. Ultimately, a collection of elements could be returned and each check for immediate visibility.</p>
			<p class="list-inset">Other page classes can be inherited from this base class and inherit its common functionality.</p>
			<ul>
				<li><strong class="bold">Page components</strong>: Identify common components or sections within your application’s pages that are repeated across multiple pages. Create separate page component classes to represent these reusable components. Then, include these components within your page classes to reuse the common functionality and reduce code duplication.</li>
				<li><strong class="bold">Helper methods</strong>: Identify common operations or actions performed across multiple pages, such as logging in, navigating between pages, or handling popups. Extract these operations into helper methods that can be called from different page classes. This centralizes the implementation and avoids duplicating the code for these common actions.</li>
				<li><strong class="bold">Parameterization</strong>: If you have similar elements or actions that vary based on input parameters, you can create parameterized methods in your page classes. These methods can accept parameters and perform the desired actions based on the provided input, reducing the need for separate methods for similar functionality.</li>
				<li><strong class="bold">External configuration</strong>: Move configurable values such as URLs, timeouts, or test data into external configuration files. This allows you to centralize and reuse the configuration across multiple tests and pages, reducing the need for hardcoding values in individual page classes.</li>
				<li><strong class="bold">Maintainable selectors:</strong> Use a reliable and maintainable way to locate elements on the page, such as CSS selectors or XPath expressions. Avoid using hardcoded selectors in your test methods. Instead, define selectors as properties within your page <a id="_idIndexMarker385"/>classes, making it easier to update them if the UI changes.</li>
			</ul>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor193"/>POM using Klassi-js</h1>
			<p>Klassi-js is a <a id="_idIndexMarker386"/>robust and versatile <strong class="bold">behavior-driven development</strong> (<strong class="bold">BDD</strong>) JavaScript test automation framework that empowers developers and QA professionals to create and execute comprehensive<a id="_idIndexMarker387"/> tests for web and mobile applications. At its core, Klassi-js leverages the power of WebdriverIO, which is a cutting-edge<a id="_idIndexMarker388"/> automation framework for Node.js. This foundation allows Klassi-js to seamlessly interact with web browsers and mobile devices, making it an excellent choice for cross-browser and cross-platform testing.</p>
			<p>One of Klassi-js’s standout features<a id="_idIndexMarker389"/> is its seamless integration with cucumber.js, a popular BDD testing tool. This integration allows for the creation of human-readable, expressive test scenarios that foster better collaboration between developers, testers, and other stakeholders. It promotes a common language for discussing application behavior and helps in building more reliable tests.</p>
			<p>Klassi-js goes a step further by offering integrated visual, accessibility, and API testing capabilities, ensuring that your application not only works but is also user-friendly, compliant with accessibility standards, and delivers the expected API responses. Moreover, Klassi-js provides the flexibility to run tests locally or harness the power of cloud-based testing platforms such as LambdaTest, BrowserStack, or Sauce Labs, allowing for scalable and efficient testing across various environments.</p>
			<p>POM is a design pattern for organizing your UI automation code to make it more maintainable and <a id="_idIndexMarker390"/>readable. When using Klassi-js with Cucumber, you can implement the POM design pattern <a id="_idIndexMarker391"/>as follows.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor194"/>Project structure</h2>
			<p>First, organize your project <a id="_idIndexMarker392"/>structure to separate different concerns. A common structure might look like this:</p>
			<pre class="source-code">
project-root
-- features
     -- login.feature
-- step-definitions
     -- login.steps.ts
-- pages
     -- login.page.ts
-- index.ts
-- runtime
-- world.ts
-- package.json</pre>			<p>Let’s break this down:</p>
			<ul>
				<li><code>features</code>: Stores your Cucumber feature files</li>
				<li><code>step-definitions</code>: Stores your Cucumber step definitions</li>
				<li><code>pages</code>: Stores your page objects</li>
			</ul>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor195"/>Cucumber feature files</h2>
			<p>Create Cucumber feature files in the<a id="_idIndexMarker393"/> features directory of your project. These feature files describe the behavior of your application in plain text. For example, you can create a <code>login.feature</code> file:</p>
			<pre class="console">
Feature: Login functionality
  Scenario: Successful login
    Given I am on the login page
    When I enter my username and password
    And I click the login button
    Then I should be logged in</pre>			<h2 id="_idParaDest-145"><a id="_idTextAnchor196"/>Page objects</h2>
			<p>Create a page object for <a id="_idIndexMarker394"/>each web page or component you want to interact with. Here’s an example, <code>login.page.ts</code>:</p>
			<pre class="console">
class LoginPage {
    get usernameInput() { return $('#username'); }
    get passwordInput() { return $('#password'); }
    get loginButton() { return $('#login-button'); }
    get welcomeMessage() { return $('#welcome-message'); }
    open() {
        browser.url('/login'); // Adjust the URL as needed
    }
    login(username, password) {
        this.usernameInput.setValue(username);
        this.passwordInput.setValue(password);
        this.loginButton.click();
    }
}
module.exports = new LoginPage();</pre>			<h2 id="_idParaDest-146"><a id="_idTextAnchor197"/>Cucumber step definitions</h2>
			<p>In your step definitions, use page<a id="_idIndexMarker395"/> objects to interact with web elements. Here’s an example, <code>login.steps.ts</code>:</p>
			<pre class="console">
const { Given, When, Then } = require('cucumber');
const LoginPage = require('../pageobjects/login.page');
Given('I am on the login page', () =&gt; { LoginPage.open(); });
When('I enter my username and password', () =&gt; {
    LoginPage.username.setValue('your_username');
    LoginPage.password.setValue('your_password');
});
When('I click the login button', () =&gt; {  LoginPage.loginButton.click(); });
Then('I should be logged in', () =&gt; {
    expect(LoginPage.welcomeMessage).toHaveText('Welcome, User');
});</pre>			<h2 id="_idParaDest-147"><a id="_idTextAnchor198"/>Running tests</h2>
			<p>You can run your<a id="_idIndexMarker396"/> Cucumber tests as usual with Klassi-js. Use a command such as this:</p>
			<pre class="console">
&gt; node index.ts --tags @login</pre>			<p>Klassi-js will automatically discover your Cucumber feature files and execute the corresponding step definitions.</p>
			<p>With this structure, your UI automation code becomes more modular and easier to maintain. Each <a id="_idIndexMarker397"/>page object encapsulates the functionality and interactions with a specific page or component, making it easier to update and manage your tests.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor199"/>Summary</h1>
			<p>Following the aforementioned principles, you can create a Page Object pattern akin to the meticulous planning of a superhero, ensuring your code becomes more maintainable, reusable, and readable. Just as a superhero fine-tunes their abilities to be more effective, by adhering to these strategies, you can reduce code duplication and enhance maintainability in your Page Object pattern. Reusing common objects, methods, and components across pages is like harnessing the compartments of a superhero's utility belt, streamlining your code and ensuring that modifications are easy to implement and maintain. </p>
			<p>In the next chapter, we will continue to amplify our framework's prowess by leveraging system variables and dynamic configurations, much like a superhero adapts to different environments, to seamlessly switch between dev and stage landing pages.</p>
		</div>
	</body></html>