- en: Chapter 6. Cloning, Inheritance, and Submodules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 克隆、继承和子模块
- en: In the previous chapter, we looked at how we can extend and modify modules using
    loose and tight augmentation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何使用松散和紧密增强来扩展和修改模块。
- en: In this chapter, we are going to explore some other techniques that may come
    handy when we are working with modules, which can help us extend and modify the
    functionality of our modules. Depending on the requirements of your applications,
    as well as your personal preferences, some or all of these techniques may be of
    use to you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些其他技术，这些技术在我们处理模块时可能很有用，可以帮助我们扩展和修改模块的功能。根据你应用程序的需求以及你的个人偏好，这些技术中的某些或全部可能对你有用。
- en: The beginning of the chapter will provide an overview of some of the approaches
    for creating object based on other objects which you may already be familiar with.
    Then, we will look at how object cloning can be used to create objects that are
    replicas of other objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开头将概述一些创建基于其他对象的某些方法，你可能已经熟悉。然后，我们将探讨如何使用对象克隆来创建其他对象的副本。
- en: We will also create another one of the core modules for our application, which
    will be utilized to clone objects as needed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建我们应用程序的核心模块之一，该模块将用于根据需要克隆对象。
- en: 'In this chapter we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Module cloning and when to use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块克隆及其使用场景
- en: Different methods for cloning objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆对象的多种方法
- en: Using inheritance to extend modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承扩展模块
- en: Adding functionality to already created modules using submodules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子模块向已创建的模块添加功能
- en: Internal private state and how it is affected when extending modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部私有状态及其在扩展模块时的影响
- en: Cloning modules
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆模块
- en: Cloning objects in general, and cloning modules in particular, is about creating
    an exact replica of the original object or module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，克隆对象，特别是克隆模块，是创建原始对象或模块的精确副本。
- en: But before we talk about cloning, let's consider some of the ways that we can
    create new objects based on other objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们讨论克隆之前，让我们考虑一些我们可以创建基于其他对象的新对象的方法。
- en: Creating instances of a constructor function
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构造函数的实例
- en: One way of creating objects based on another object is by creating instances
    of a constructor function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于另一个对象创建对象的一种方法是通过创建构造函数的实例。
- en: As you know, when we create an instance of an object using a constructor function
    in JavaScript, we use the `new` keyword. The created instance resides in a different
    memory address than the constructor function. When we assign properties to the
    `prototype` property of the constructor function, all the instances of the constructor
    function will share these properties of the `prototype` object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，当我们使用JavaScript中的构造函数创建一个对象实例时，我们使用`new`关键字。创建的实例位于与构造函数不同的内存地址。当我们将属性分配给构造函数的`prototype`属性时，构造函数的所有实例都将共享这些`prototype`对象的属性。
- en: Let's have a look at a simple example and review creating objects based on constructor
    functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，并回顾基于构造函数创建对象。
- en: 'Consider the following code snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we have added a property to the `prototype` object of our constructor
    function, which logs the value of the `this.someValue` property to the console.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经向我们的构造函数的`prototype`对象添加了一个属性，它将`this.someValue`属性的值记录到控制台。
- en: 'Now, we create two instances of our constructor function as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建我们构造函数的两个实例，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we run the following code in the console:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在控制台中运行以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that the same value for `someValue` property will be displayed for
    both of the instances. Of course, if we change the value of `someValue` property
    for each instance as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`someValue`属性的相同值将显示在两个实例中。当然，如果我们像以下这样为每个实例的`someValue`属性更改值：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And log the values of the properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并记录属性的值：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The value of `someValue` property for each instance will be different. Here,
    each instance has its own copy of `someValue` property, but they both share the
    same method, (`testFunc`) since all the properties that are residing on the `prototype`
    object are shared among all the instances of the constructor function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例的`someValue`属性值将不同。在这里，每个实例都有其自己的`someValue`属性副本，但它们都共享相同的方法（`testFunc`），因为所有位于`prototype`对象上的属性都是构造函数所有实例共享的。
- en: There is also one more thing that we should keep in mind. After creating instances
    of the constructor function, if we add new properties to the constructor function,
    the instances will not have access to these new properties.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该记住一件事。在创建构造函数的实例之后，如果我们向构造函数添加新的属性，这些实例将无法访问这些新属性。
- en: 'Consider the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you see, none of the instances have access to this new property which was
    added to the constructor function **after** the instances were created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有任何实例可以访问在构造函数 **之后** 添加到构造函数中的这个新属性。
- en: If you are thinking that alternatively, we could have defined properties defined
    on the `prototype` object directly on the constructor function itself (`testFunc`
    in our example), you are correct but with a caveat!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为我们可以直接在构造函数本身上定义 `prototype` 对象上的属性（在我们的例子中是 `testFunc`），你是正确的，但有一个前提条件！
- en: Doing so would mean that every time we make an instance of the object, we would
    be making unnecessary copies of the properties, which are identical for all the
    instances of the object. Thus, we would be creating an unnecessary overhead for
    our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做意味着每次我们创建对象的实例时，我们都会创建不必要的属性副本，而这些属性对所有对象实例都是相同的。因此，我们会在代码中创建不必要的开销。
- en: It is a good practice that, when we have properties which are identical for
    all the instances of constructor function (in most cases, this applies to methods),
    they should be defined on the `prototype` object and be shared among all the instances.
    We did this in our example by adding `testFunc` method to the `prototype` object
    instead of defining it on the constructor function itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有对所有构造函数实例（在大多数情况下，这适用于方法）都相同的属性时，这是一个好的实践，它们应该定义在 `prototype` 对象上，并由所有实例共享。我们在示例中通过将
    `testFunc` 方法添加到 `prototype` 对象上，而不是在构造函数本身上定义它，来实现这一点。
- en: When it comes to constructor functions and creating other objects (instances)
    based on these objects, there is one other thing that we need to consider. What
    happens to private properties in the constructor function?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构造函数和基于这些对象创建其他对象（实例）时，我们还需要考虑另一件事。构造函数中的私有属性会发生什么？
- en: 'Let''s consider the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The private variable `privateValue` will not be copied to the instances of the
    object and will not be shared.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 私有变量 `privateValue` 不会被复制到对象的实例中，也不会被共享。
- en: 'We can test this as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下进行测试：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So how can we access these private properties from an object which is created
    based on this object?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从基于此对象创建的对象中访问这些私有属性呢？
- en: We'll talk about how we can provide access to such private members when we talk
    about cloning modules.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到克隆模块时，我们将讨论如何提供对这些私有成员的访问。
- en: Using the assignment operator for copying objects
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用赋值运算符进行对象的复制
- en: 'When we are using primitive types in JavaScript, we can easily use the assignment
    operator to copy the value of one variable to another, as shown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 JavaScript 中使用原始类型时，我们可以很容易地使用赋值运算符将一个变量的值复制到另一个变量，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code we are simply assigning the sting value of one variable
    to another variable, and there is no mystery here, but how would that work for
    two objects?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是将一个变量的字符串值赋给另一个变量，这里没有神秘之处，但这对两个对象来说是如何工作的呢？
- en: 'Let''s put that to the test as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们如下进行测试：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are assigning `testObj1` to `testObj2` using the assignment operator,
    which might appear as creating a new object based on another object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用赋值运算符将 `testObj1` 赋值给 `testObj2`，这可能会看起来像是基于另一个对象创建了一个新对象。
- en: However, as you can see, when we create a new property for `testObj1`, even
    after the assignment of `testObj1` to `testObj2` has taken place, the new property
    is available to `testObj2` as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，当我们为 `testObj1` 创建一个新属性时，即使在将 `testObj1` 赋值给 `testObj2` 之后，这个新属性对
    `testObj2` 也是可用的。
- en: The reason is that when we use the assignment operator to assign the value of
    a variable which holds a reference to an object to another variable, we are in
    fact assigning the memory address of the object to another variable. This results
    in both variables referencing the same object. So, in the code above, both `testObj1`
    and `testObj2` are referencing the same object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，当我们使用赋值运算符将一个变量（该变量持有对对象的引用）的值赋给另一个变量时，我们实际上是将对象的内存地址赋给另一个变量。这导致两个变量都引用了同一个对象。因此，在上面的代码中，`testObj1`
    和 `testObj2` 都引用了同一个对象。
- en: While this result might be desirable at times, there are occasions when we need
    to create an object that is an exact copy (replica) of another object, but we
    want the new object to be a completely independent object from the original one.
    So how do we do that?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时这种结果可能是期望的，但有时我们需要创建一个与另一个对象完全相同的对象（复制品），但我们希望新对象与原始对象完全独立。那么我们该如何做呢？
- en: One way to achieve that is to create a clone of the original object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的一种方法就是创建原始对象的克隆。
- en: Creating a clone of an object
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象的克隆
- en: When we create a clone of an object, our objective is to create an exact replica
    of the original object, without the newly created object having any ties to the
    original object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个对象的克隆时，我们的目标是创建原始对象的精确复制品，而新创建的对象不应与原始对象有任何关联。
- en: Cloning objects in JavaScript (as with some other languages) is not as straightforward
    as you might think. While there are different ways of implementing cloning, each
    approach has its own pros and cons.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中克隆对象（与其他一些语言一样）并不像你想象的那么简单。虽然存在不同的克隆实现方式，但每种方法都有其优缺点。
- en: 'If we consider cloning as copying all the properties of an object to another
    object, we can categorize cloning into two types:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将克隆视为将一个对象的全部属性复制到另一个对象，我们可以将克隆分为两种类型：
- en: Shallow cloning
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浅克隆
- en: Deep cloning
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度克隆
- en: Shallow cloning and deep cloning
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅克隆和深克隆
- en: '**Shallow cloning** copies all the top-level properties of the original object,
    but if this object contains other reference types, only the *references* of these
    reference types are copied to the newly created clone, as opposed to the actual
    reference types. This type of cloning is used when we want to have separate copies
    of the primitive types in the new object but we want the original object, and
    the newly cloned object, to share the same reference types.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**浅克隆**会复制原始对象的所有顶层属性，但如果这个对象包含其他引用类型，则只会复制这些引用类型的*引用*到新创建的克隆中，而不是实际的引用类型。这种类型的克隆用于当我们希望在新的对象中拥有原始类型的独立副本，但希望原始对象和新的克隆对象共享相同的引用类型时。'
- en: '**Deep Cloning** on the other hand, copies all the primitive type properties
    of the original object into the new object as well as making new copies of all
    the reference types of the original object in the new object.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**深度克隆**会将原始对象的全部原始类型属性复制到新对象中，同时在新对象中创建原始对象所有引用类型的副本。
- en: The important distinction is that true copies of the reference types are created
    in the new object and not just the references (the memory addresses) of the reference
    types. This type of cloning is desirable if we want to have two distinct objects
    with no ties between them of any kind. Deep cloning is generally considered slower
    than shallow cloning and consumes more resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的区别在于，在新的对象中创建了引用类型的真正副本，而不仅仅是引用（内存地址）。如果我们希望有两个没有任何关联的独立对象，这种类型的克隆是可取的。深度克隆通常被认为比浅克隆慢，并且消耗更多资源。
- en: 'To implement either of the cloning types, we can leverage one of the following
    approaches:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现任何一种克隆类型，我们可以利用以下方法之一：
- en: Use a third-party library such as jQuery or lodash
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库，如jQuery或lodash
- en: Use the JSON exploit hack
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON漏洞黑客技术
- en: Create our own custom clone method
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的自定义克隆方法
- en: Using external libraries for cloning
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部库进行克隆
- en: '**jQuery** provides the `extend` method which enables us to create both shallow
    and deep cloning of objects.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery** 提供了 `extend` 方法，使我们能够创建对象的浅克隆和深克隆。'
- en: 'The general format for the `extend` method is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 方法的通用格式如下：'
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'While this approach is generally a good option for cloning objects, it does
    have some limitations, such as when dealing with built-in JavaScript types. For
    complete information regarding this method, please refer to the jQuery documentation
    at the following URL:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法通常是一个好的克隆对象选项，但它确实有一些限制，例如处理内置JavaScript类型时。有关此方法的完整信息，请参阅以下URL的jQuery文档：
- en: '[http://api.jquery.com/jQuery.extend/](http://api.jquery.com/jQuery.extend/)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://api.jquery.com/jQuery.extend/](http://api.jquery.com/jQuery.extend/)'
- en: Another good library that can be used for cloning of objects is **lodash**,
    which also provides functionality for both shallow and deep cloning. The cloning
    functionality that lodash provides seems to be ideal for most cases.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可用于对象克隆的好库是 **lodash**，它也提供了浅克隆和深克隆的功能。lodash提供的克隆功能似乎适用于大多数情况。
- en: 'The general format for creating deep clones of an object in lodash is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在lodash中创建对象深度克隆的一般格式是：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are however some limitations when using lodash for deep cloning, such
    as dealing with maps and sets. Please refer to the loadash documentation online
    at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用lodash进行深度克隆时有一些局限性，例如处理map和set。请参阅在线的lodash文档：
- en: '[https://lodash.com/docs#cloneDeep](https://lodash.com/docs#cloneDeep)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://lodash.com/docs#cloneDeep](https://lodash.com/docs#cloneDeep)'
- en: Using JSON exploit for cloning
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON利用进行克隆
- en: A simple but effective way of cloning objects is to use a technique (hack) known
    as JSON exploit.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种称为JSON利用的技术（hack）来克隆对象是一种简单但有效的方法。
- en: 'The idea is to stringify the original object and then parse the string into
    a new object, using JSON methods. This is shown as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将原始对象序列化为字符串，然后使用JSON方法将字符串解析为新对象。如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This approach is simple to use, however it has limited capabilities, especially
    when it comes to copying function properties.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用简单，然而它的功能有限，尤其是在复制函数属性时。
- en: 'To view a good discussion on using this technique, please refer to the following
    URL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看关于使用此技术的良好讨论，请参阅以下URL：
- en: '[https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json](https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json](https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json)'
- en: Creating a custom clone method
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义克隆方法
- en: When it comes to relatively simple cloning of objects, we can create our own
    custom cloning method. This method satisfies most of our needs, most of the time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到相对简单的对象克隆时，我们可以创建自己的自定义克隆方法。这种方法通常能满足我们的大部分需求。
- en: 'Consider the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function takes a Boolean parameter to perform either a shallow clone or
    a deep clone of an object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个布尔参数，用于执行对象的浅克隆或深克隆。
- en: 'When a deep clone is required, a recursive call to the function is made to
    copy the properties of an object property (a reference type) of the original object.
    Notice the following snippet in the cloning function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要深度克隆时，会对函数进行递归调用，以复制原始对象的一个属性（引用类型）的属性。注意以下克隆函数中的片段：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, as with the approaches discussed previously, this approach also has
    its own limitations, for instance, when dealing with closures. However, it does
    a pretty good job in most cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与之前讨论的方法一样，这种方法也有其局限性，例如处理闭包。然而，它在大多数情况下都做得相当不错。
- en: In the next section, we will be adding this function to one of our application's
    core modules so it can be used in our application, when needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把这个函数添加到我们应用的一个核心模块中，以便在需要时可以在应用中使用它。
- en: Creating ImagesInc_Utilites module
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ImagesInc_Utilites模块
- en: 'Since a utilities module is a good place to implement our object cloning code,
    let''s create our `ImagesInc_Utilites` module as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工具模块是实现我们的对象克隆代码的好地方，让我们按照以下方式创建我们的`ImagesInc_Utilites`模块：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this module, we have implemented our cloning function which takes care of
    copying an object's properties into a new object. I have also modified this function
    a little from its previous version that you saw earlier. This is so it will only
    copy the properties of the object itself and not its parent's properties (if there
    is one). We can do this by using JavaScript's native `hasOwnProperty` method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们实现了我们的克隆函数，该函数负责将一个对象的属性复制到一个新对象中。我还对这个函数进行了一些修改，从你之前看到的版本中。这样做是为了它只会复制对象本身的属性，而不会复制其父对象的属性（如果有的话）。我们可以通过使用JavaScript的本地`hasOwnProperty`方法来实现这一点。
- en: We have assigned the cloning function as a property to `Object.prototype` object,
    so all the objects in the application can have access to this method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将克隆函数作为属性分配给了`Object.prototype`对象，因此应用中的所有对象都可以访问这个方法。
- en: Testing our custom cloning method in ImagesInc_Utilites module
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ImagesInc_Utilites模块中测试我们的自定义克隆方法
- en: 'Let''s create a test module to see how our cloning mechanism works. Consider
    the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个测试模块来查看我们的克隆机制是如何工作的。考虑以下代码：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we have created a simple module which exposes a public interface with controlled
    access to its private variable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个简单的模块，它提供了一个受控访问其私有变量的公共接口。
- en: 'Now, if we run the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行以下代码：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can create a clone of the original module, `TestModule`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建原始模块`TestModule`的克隆。
- en: 'We can run a simple test as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行一个简单的测试：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the expected output is displayed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，预期的输出已经显示。
- en: 'To verify that all the properties have been copied from our original module
    to our new module, we can examine all the properties in both modules, using our
    browser''s debugger (I''m using Chrome''s debugger) as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证所有属性都已从我们的原始模块复制到新模块中，我们可以检查两个模块中的所有属性，使用我们浏览器的调试器（我在这里使用的是Chrome的调试器）如下所示：
- en: '![Testing our custom cloning method in ImagesInc_Utilites module](img/B04910_06_01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![在ImagesInc_Utilites模块中测试我们的自定义克隆方法](img/B04910_06_01.jpg)'
- en: An important aspect of our cloning method
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们克隆方法的一个重要方面
- en: There is also another interesting aspect of this cloning method that you need
    to be mindful of.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个克隆方法还有一个你需要注意的有趣方面。
- en: Remember that our `TestModule` has a hidden property by design, which is `privateTestValue`.
    What happens to this property when we do our cloning?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的`TestModule`设计上有一个隐藏的属性，即`privateTestValue`。当我们进行克隆时，这个属性会发生什么变化？
- en: Well, the best way to find out is by running a test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，最好的办法是运行一个测试。
- en: 'In our `TestModule`, we have a method property (`changePrivateVar`) which modifies
    this hidden property. So if we run the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`TestModule`中，我们有一个方法属性（`changePrivateVar`），它修改了这个隐藏的属性。所以如果我们运行以下代码：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can change the value of this property to `the private value has been changed`,
    in our `TestModule`. Now, let's see if our `CloneModule` has access to this value
    and if so, does it hold on to the old value of this property or will the value
    will be changed for our `CloneModule` as well?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`TestModule`中更改这个属性的值到`the private value has been changed`。现在，让我们看看`CloneModule`是否可以访问这个值，如果是的话，它是否会保留这个属性的旧值，或者这个值也会为我们的`CloneModule`而改变？
- en: 'If we run the following code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下代码片段：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We see that not only our `CloneModule` has access to this property but also
    that the value has been changed for this module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，不仅我们的`CloneModule`可以访问这个属性，而且这个模块的值已经改变。
- en: This shows us that because of the closure in our original `TestModule` module,
    our `CloneModule` also has access to the private scope of this module and it also
    retains the state of the scope that is provided by the closure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，由于我们的原始`TestModule`模块中的闭包，我们的`CloneModule`也可以访问这个模块的私有作用域，并且它也保留了闭包提供的作用域状态。
- en: This may, or may not, be a desirable result for us, depending on how we want
    to clone our modules. However, it is very important to keep in mind that, because
    of the closure in our original module, our cloning outcome is a little different
    than when we clone objects which do not have embedded closures.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能，也可能不是我们想要的克隆模块的结果，这取决于我们如何克隆模块。然而，非常重要的一点是要记住，由于我们的原始模块中的闭包，我们的克隆结果与克隆没有嵌入闭包的对象的克隆结果略有不同。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Running more tests on our cloning method**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**对我们的克隆方法进行更多测试**'
- en: I have included a few tests for module cloning in the accompanying code for
    this chapter. You can see these tests in the `AppTester.js` file. Please have
    a look, read the comments and modify the code to see how the results can be affected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书的配套代码中包含了一些模块克隆的测试。你可以在`AppTester.js`文件中看到这些测试。请查看，阅读注释，并修改代码以了解结果如何受到影响。
- en: As you can see, cloning can be used when we want to create a replica of our
    original module with access to the original module's closure context. This in
    turn can provide us with access to the private members of the original module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们想要创建一个可以访问原始模块闭包上下文的原始模块的副本时，可以使用克隆。这反过来又为我们提供了访问原始模块私有成员的权限。
- en: Most of the time, when we clone a module, we use it as the base module for a
    new module. We can then add more functionality or modify the existing functionality
    of the new module, using one of the other techniques that we discussed previously,
    such as loose or tight augmentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当我们克隆一个模块时，我们将其用作新模块的基模块。然后我们可以添加更多功能或修改新模块的现有功能，使用我们之前讨论的其他技术之一，例如松散或紧密增强。
- en: This approach allows us to extend the clone of a module instead of the original
    module, thus shielding the original module from all the changes, while having
    access to all the functionality of the original module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们扩展模块的克隆版本而不是原始模块，从而保护原始模块免受所有更改的影响，同时仍然可以访问原始模块的所有功能。
- en: Of course, cloning is not the only way that we can achieve this, but nonetheless,
    it is another valuable tool to have in our toolbox.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，克隆并不是我们实现这一点的唯一方法，但无论如何，它都是我们工具箱中另一个有价值的工具。
- en: Inheritance in modules
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块中的继承
- en: In [Chapter 2](ch02.html "Chapter 2. Review of Important JavaScript OOP Concepts"),
    *Review of Important JavaScript OOP Concepts*, we talked about what inheritance
    is and looked at different approaches to creating inheritance relationship among
    objects. Here, we will leverage the techniques that we learned in that chapter
    to create inheritance among modules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. JavaScript OOP 重要概念回顾")中，我们讨论了继承是什么，并探讨了在对象之间创建继承关系的方法。在这里，我们将利用我们在那一章中学到的技术来创建模块间的继承。
- en: Generally, we use inheritance to utilize our base module's functionality and
    then either add new functionality or modify the existing functionality in our
    child modules.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用继承来利用我们的基础模块的功能，然后在子模块中添加新功能或修改现有功能。
- en: There are various ways of creating inheritance among modules and we will examine
    two of these approaches in this section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模块间继承有多种方式，在本节中我们将探讨这两种方法之一。
- en: Module inheritance using __proto__ object
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`__proto__`对象的模块继承
- en: In this type of inheritance implementation, we use the child module's `__proto__`
    object to inherit properties from the parent module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种继承实现类型中，我们使用子模块的`__proto__`对象从父模块继承属性。
- en: 'Let''s consider the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下内容：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, we have created two modules here: `Polygon_Module,` which is
    the parent module in our inheritance relationship, and `Rectangle_Module`, which
    is the child module.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里创建了两个模块：`Polygon_Module`，它是我们的继承关系中的父模块，以及`Rectangle_Module`，它是子模块。
- en: In our `Polygon_Module`, we have created private variables and functions, which
    are not accessible to the external code, except through the module's interface.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Polygon_Module`中，我们创建了私有变量和函数，这些变量和函数除了通过模块的接口外，对外部代码不可访问。
- en: '`Rectangle_Module` is designed in a way that it inherits some of its functionality
    from its parent module (`Polygon_Module`). It then modifies some of the inherited
    functionality as well as adding new functionality of its own.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle_Module`的设计方式使其从其父模块（`Polygon_Module`）继承了一些功能。然后它修改了一些继承的功能，并添加了自己的新功能。'
- en: 'The following line of code is the essential piece that creates the inheritance
    relationship between the two modules:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是创建两个模块之间继承关系的关键部分：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As shown, we have passed a reference from `Polygon_Module` to the `__proto__`
    object of `Rectangle` object. This allows the `Rectangle` object to have access
    to all the properties that were exposed in the parent module, through the parent
    module's interface.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们已经从`Polygon_Module`传递了一个引用到`Rectangle`对象的`__proto__`对象。这使得`Rectangle`对象能够通过父模块的接口访问在父模块中暴露的所有属性。
- en: 'Let''s see what we get when we run the following tests on our modules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们对模块运行以下测试时得到的结果：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The above tests demonstrate that the child module, `Rectangle_Module`, has all
    the methods that were inherited from the parent module; additionally, it has overridden
    some of these inherited properties.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试表明，子模块`Rectangle_Module`具有从父模块继承的所有方法；此外，它还覆盖了一些继承的属性。
- en: Notice `Rectangle_Module.getType()` method, which was not defined or overridden
    in the child module, but was accessed by the child module through the parent module's
    interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Rectangle_Module.getType()`方法，它没有在子模块中定义或覆盖，但通过父模块的接口被子模块访问。
- en: Module inheritance using parasitic combination
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用寄生组合的模块继承
- en: Another approach to creating inheritance among objects, which you are probably
    familiar with and have seen an example of in [Chapter 2](ch02.html "Chapter 2. Review
    of Important JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*,
    is **parasitic combination** inheritance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在对象之间创建继承的方法，你可能很熟悉，并在[第2章](ch02.html "第2章. JavaScript OOP 重要概念回顾")中看到了一个例子，*JavaScript
    OOP 重要概念回顾*，即**寄生组合**继承。
- en: As you may recall, the idea is that we use the base class's constructor function
    in the child's constructor to create an instance of the child object. We also
    use the base class's `prototype` object to get a reference to all the properties
    that are exposed on the base class's `prototype` object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆，这个想法是我们使用基类的构造函数在子类的构造函数中创建子对象的一个实例。我们还使用基类的`prototype`对象来获取对基类`prototype`对象上暴露的所有属性的引用。
- en: 'To refresh your memory, let''s have a look at the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新你的记忆，让我们看一下以下示例：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this version of our modules, `Polygon_Module2` has a constructor function
    called `Polygon`. All of our methods are also defined on the `prototype` object
    of the `Polygon` class (object).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们模块的这个版本中，`Polygon_Module2`有一个名为`Polygon`的构造函数。我们所有的方法也都定义在`Polygon`类的`prototype`对象（对象）上。
- en: '`Polygon_Module2` module also has an anonymous object as an interface, which
    holds a reference to `Polygon` class (object).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Polygon_Module2`模块还有一个匿名对象作为接口，它持有对`Polygon`类（对象）的引用。'
- en: 'In our child module, we have created another constructor function `Rectangle`,
    which uses the available interface in `Polygon_Module2` to borrow the `Polygon`
    constructor, as shown:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的子模块中，我们创建了一个名为`Rectangle`的另一个构造函数，它使用`Polygon_Module2`中可用的接口来借用`Polygon`构造函数，如下所示：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have also set the `prototype` object of `Rectangle` object to point to `Polygon.prototype`
    object so we can have access to all the methods defined in this object, as shown:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`Rectangle`对象的原型对象设置为指向`Polygon.prototype`对象，这样我们就可以访问在这个对象中定义的所有方法，如下所示：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And of course, since we have completely overwritten the `prototype` object of
    our `Rectangle` class, we need to reset its `constructor` property so that it
    points to the correct object, which in this case is `Rectangle`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们已经完全覆盖了`Rectangle`类的`prototype`对象，我们需要重置其`constructor`属性，使其指向正确的对象，在这种情况下是`Rectangle`。
- en: Notice that we have created an instance of `Rectangle` object to start the inheritance
    relationship between the two objects and set the objects' contexts properly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经创建了一个`Rectangle`对象的实例来启动两个对象之间的继承关系，并正确设置对象上下文。
- en: 'Let''s run a few tests to verify the inheritance relationship, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行几个测试来验证继承关系，如下所示：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the tests produce the results that were expected.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，测试产生了预期的结果。
- en: Deciding on the module inheritance approach
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定模块继承方法
- en: If you are wondering which approach to take (**__proto__ inheritance** or **parasitic
    inheritance**) when you need to create an inheritance relationship among your
    application modules, in my opinion it will be a matter of taste for the most part.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在思考需要创建应用程序模块之间的继承关系时采取哪种方法（`__proto__`继承或寄生继承），在我看来，这大部分将取决于个人喜好。
- en: However, consider that in our first approach (using `__proto__` inheritance),
    we did not need to create an instance of the child module to create the inheritance
    relationship. This means one less function call and probably a little less memory
    consumption as no instances of the object are held in memory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在我们的第一种方法（使用`__proto__`继承）中，我们不需要创建子模块的实例来创建继承关系。这意味着少一个函数调用，可能还有一点内存消耗减少，因为没有对象的实例被保存在内存中。
- en: On the other hand, keep in mind that older browsers may not support setting
    the `__proto__` property of an object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，请记住，较老的浏览器可能不支持设置对象的`__proto__`属性。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More information about inheritance**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于继承的更多信息**'
- en: If you would like to get a little more information regarding inheritance among
    JavaScript objects in general, please refer to [Chapter 2](ch02.html "Chapter 2. Review
    of Important JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于JavaScript对象之间继承的一般信息，请参阅[第2章](ch02.html "第2章. 重要JavaScript OOP概念回顾")，*重要JavaScript
    OOP概念回顾*。
- en: Submodules
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子模块
- en: The last technique that we consider in this chapter, which also allows us to
    extend our modules, is using **submodules**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们考虑的最后一种技术，它也允许我们扩展我们的模块，是使用**子模块**。
- en: Submodules are essentially independent modules, which can be added to another
    module as properties of the hosting module. There are various ways of adding submodules
    to other modules and we will cover two of these approaches in this section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块本质上是可以独立使用的模块，可以作为宿主模块的属性添加到另一个模块中。有各种方法可以将子模块添加到其他模块中，我们将在本节中介绍这两种方法之一。
- en: Let's stay with the shape theme that we have been using so far and create a
    `Shape` module. We will consider this module as our hosting module. This module
    is the parent module for all 2D and 3D shapes and we will add our `Polygon` module
    to it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用到目前为止一直在使用的形状主题，创建一个`Shape`模块。我们将把这个模块视为我们的宿主模块。这个模块是所有二维和三维形状的父模块，我们将把我们的`Polygon`模块添加到它里面。
- en: Adding submodules using dynamic properties
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态属性添加子模块
- en: Adding a submodule to a module as a dynamic property is straightforward, and
    as we can add dynamic properties to any JavaScript object, we can add a property
    to a hosting module which points to a submodule.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将子模块作为动态属性添加到模块中很简单，因为我们可以给任何JavaScript对象添加动态属性，所以我们可以给宿主模块添加一个属性，该属性指向子模块。
- en: 'Consider the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have created a submodule `Shape.Polygon` and have added it to our main
    module `Shape` as a property.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个子模块`Shape.Polygon`，并将其作为属性添加到我们的主模块`Shape`中。
- en: 'Of course, we can access the main module and the submodule as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以如下访问主模块和子模块：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the simplest way of adding a submodule to a main module but it does
    require the main module to be present in the scope, before we can add the submodule
    to it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将子模块添加到主模块的最简单方法，但它确实要求在我们可以将子模块添加到其中之前，主模块必须存在于作用域中。
- en: Adding submodules using asynchronous properties
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异步属性添加子模块
- en: Adding submodules to a hosting module using asynchronous properties has the
    advantage of being more flexible, in the sense that the hosting module does not
    need to be loaded before the submodule can be added to it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步属性将子模块添加到宿主模块的优点是更加灵活，这意味着在将子模块添加到宿主模块之前，宿主模块不需要被加载。
- en: Therefore, the submodule can potentially reside in a different file, and can
    be loaded and added to the hosting module at different times (either before or
    after the hosting module is loaded), in an asynchronous fashion.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子模块可以潜在地位于不同的文件中，并且可以在不同的时间（无论是宿主模块加载之前还是之后）以异步方式加载并添加到宿主模块中。
- en: 'Let''s have a look at the following code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code is responsible for adding our submodule `Polygon_Module`, to our main
    module `Shape`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责将我们的子模块`Polygon_Module`添加到主模块`Shape`中。
- en: As you can see, we are passing two parameters to our IIFE, one for the main
    module and the other for the submodule. When any of them does not yet exist in
    the execution context, we are passing an empty object to our IIFE.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们向IIFE传递了两个参数，一个用于主模块，另一个用于子模块。当它们中的任何一个在执行上下文中还不存在时，我们向IIFE传递一个空对象。
- en: Inside of the IIFE, we check to see if our `mainModule` has the property `Polygon`,
    which is in fact our submodule. If the property does exist, we just use it and
    add a new property to this submodule, called `description`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIFE内部，我们检查`mainModule`是否有属性`Polygon`，实际上这就是我们的子模块。如果属性确实存在，我们就使用它并向这个子模块添加一个新属性，称为`description`。
- en: If the property `Polygon` (the submodule) does not exist in our code execution
    context, we use the passed-in submodule and then add the new property `description`
    to it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码执行上下文中不存在属性`Polygon`（子模块），我们使用传入的子模块，然后向其添加新的属性`description`。
- en: 'Let''s check to see if we can access this new property on the submodule, as
    follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们是否可以按照以下方式访问子模块上的这个新属性：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, even if we add our `Shape` module (the hosting module) after our submodule
    to our execution context, we can still add our submodule to this module. We can
    also provide access to our submodule's properties, through the main (hosting)
    module.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使我们在执行上下文中将`Shape`模块（宿主模块）添加到子模块之后，我们仍然可以将子模块添加到这个模块中。我们还可以通过主（宿主）模块提供对子模块属性的访问。
- en: 'Consider the code below:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This implementation of our `Shape` module accepts one parameter, which can be
    either an empty object or a reference to an already existing `Shape` module. This
    means that, even if our `Shape` module was already created in our previous IIFE,
    which was responsible for adding our `Polygon_Module` to our `Shape` module, we
    are still able to re-define it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Shape`模块的实现接受一个参数，这个参数可以是空对象或者一个已经存在的`Shape`模块的引用。这意味着，即使我们的`Shape`模块已经在之前的IIFE中创建，负责将`Polygon_Module`添加到`Shape`模块中，我们仍然能够重新定义它。
- en: 'To test this, we can run the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以运行以下代码：
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The result confirms that we are able to access properties of the `Shape` module
    as well as our submodule, no matter which one is loaded first in our application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证实，无论在应用中哪个先被加载，我们都能访问`Shape`模块以及我们的子模块的属性。
- en: You might also notice that the implementation above is very similar to our loose
    augmentation pattern that we discussed previously. The only real difference is
    that we are adding our submodule as a completely independent module to our main
    module, as opposed to just augmenting the main module with new properties.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到，上述实现与我们之前讨论的松散增强模式非常相似。唯一的真正区别在于，我们将子模块作为一个完全独立的模块添加到我们的主要模块中，而不是仅仅通过添加新属性来增强主要模块。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a few more techniques which enable us to extend
    and modify our modules.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了更多技术，这些技术使我们能够扩展和修改我们的模块。
- en: We considered how we can use various cloning approaches to create replicas of
    our modules and talked about the pros and cons of each approach. We also examined
    how we can use inheritance among modules so that a child module can utilize the
    functionality of its parent module as well as override its parent module's functionality,
    as needed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了如何使用各种克隆方法来创建我们模块的副本，并讨论了每种方法的优缺点。我们还探讨了如何在模块之间使用继承，以便子模块可以利用其父模块的功能，并在需要时覆盖其父模块的功能。
- en: In the last section of this chapter, we talked about submodules and looked at
    a couple of different techniques for adding submodules to our main (hosting) modules.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们讨论了子模块，并查看了几种向我们的主要（宿主）模块添加子模块的不同技术。
- en: The next chapter will be more focused on the design of our application as a
    whole. We'll see how a flexible ecosystem can be created for our modules, which
    allows them to interact and work together, without being dependent on each other.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将更多地关注我们应用程序的整体设计。我们将看到如何为我们的模块创建一个灵活的生态系统，这允许它们相互交互并协同工作，而无需相互依赖。
