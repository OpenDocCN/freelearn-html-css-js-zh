- en: Chapter 6. Cloning, Inheritance, and Submodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how we can extend and modify modules using
    loose and tight augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore some other techniques that may come
    handy when we are working with modules, which can help us extend and modify the
    functionality of our modules. Depending on the requirements of your applications,
    as well as your personal preferences, some or all of these techniques may be of
    use to you.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of the chapter will provide an overview of some of the approaches
    for creating object based on other objects which you may already be familiar with.
    Then, we will look at how object cloning can be used to create objects that are
    replicas of other objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will also create another one of the core modules for our application, which
    will be utilized to clone objects as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Module cloning and when to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different methods for cloning objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance to extend modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functionality to already created modules using submodules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal private state and how it is affected when extending modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloning objects in general, and cloning modules in particular, is about creating
    an exact replica of the original object or module.
  prefs: []
  type: TYPE_NORMAL
- en: But before we talk about cloning, let's consider some of the ways that we can
    create new objects based on other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances of a constructor function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of creating objects based on another object is by creating instances
    of a constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, when we create an instance of an object using a constructor function
    in JavaScript, we use the `new` keyword. The created instance resides in a different
    memory address than the constructor function. When we assign properties to the
    `prototype` property of the constructor function, all the instances of the constructor
    function will share these properties of the `prototype` object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at a simple example and review creating objects based on constructor
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added a property to the `prototype` object of our constructor
    function, which logs the value of the `this.someValue` property to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create two instances of our constructor function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run the following code in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the same value for `someValue` property will be displayed for
    both of the instances. Of course, if we change the value of `someValue` property
    for each instance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And log the values of the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The value of `someValue` property for each instance will be different. Here,
    each instance has its own copy of `someValue` property, but they both share the
    same method, (`testFunc`) since all the properties that are residing on the `prototype`
    object are shared among all the instances of the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: There is also one more thing that we should keep in mind. After creating instances
    of the constructor function, if we add new properties to the constructor function,
    the instances will not have access to these new properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you see, none of the instances have access to this new property which was
    added to the constructor function **after** the instances were created.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking that alternatively, we could have defined properties defined
    on the `prototype` object directly on the constructor function itself (`testFunc`
    in our example), you are correct but with a caveat!
  prefs: []
  type: TYPE_NORMAL
- en: Doing so would mean that every time we make an instance of the object, we would
    be making unnecessary copies of the properties, which are identical for all the
    instances of the object. Thus, we would be creating an unnecessary overhead for
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice that, when we have properties which are identical for
    all the instances of constructor function (in most cases, this applies to methods),
    they should be defined on the `prototype` object and be shared among all the instances.
    We did this in our example by adding `testFunc` method to the `prototype` object
    instead of defining it on the constructor function itself.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to constructor functions and creating other objects (instances)
    based on these objects, there is one other thing that we need to consider. What
    happens to private properties in the constructor function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The private variable `privateValue` will not be copied to the instances of the
    object and will not be shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So how can we access these private properties from an object which is created
    based on this object?
  prefs: []
  type: TYPE_NORMAL
- en: We'll talk about how we can provide access to such private members when we talk
    about cloning modules.
  prefs: []
  type: TYPE_NORMAL
- en: Using the assignment operator for copying objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are using primitive types in JavaScript, we can easily use the assignment
    operator to copy the value of one variable to another, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we are simply assigning the sting value of one variable
    to another variable, and there is no mystery here, but how would that work for
    two objects?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put that to the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are assigning `testObj1` to `testObj2` using the assignment operator,
    which might appear as creating a new object based on another object.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you can see, when we create a new property for `testObj1`, even
    after the assignment of `testObj1` to `testObj2` has taken place, the new property
    is available to `testObj2` as well.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that when we use the assignment operator to assign the value of
    a variable which holds a reference to an object to another variable, we are in
    fact assigning the memory address of the object to another variable. This results
    in both variables referencing the same object. So, in the code above, both `testObj1`
    and `testObj2` are referencing the same object.
  prefs: []
  type: TYPE_NORMAL
- en: While this result might be desirable at times, there are occasions when we need
    to create an object that is an exact copy (replica) of another object, but we
    want the new object to be a completely independent object from the original one.
    So how do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve that is to create a clone of the original object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a clone of an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a clone of an object, our objective is to create an exact replica
    of the original object, without the newly created object having any ties to the
    original object.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning objects in JavaScript (as with some other languages) is not as straightforward
    as you might think. While there are different ways of implementing cloning, each
    approach has its own pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider cloning as copying all the properties of an object to another
    object, we can categorize cloning into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Shallow cloning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep cloning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shallow cloning and deep cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Shallow cloning** copies all the top-level properties of the original object,
    but if this object contains other reference types, only the *references* of these
    reference types are copied to the newly created clone, as opposed to the actual
    reference types. This type of cloning is used when we want to have separate copies
    of the primitive types in the new object but we want the original object, and
    the newly cloned object, to share the same reference types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deep Cloning** on the other hand, copies all the primitive type properties
    of the original object into the new object as well as making new copies of all
    the reference types of the original object in the new object.'
  prefs: []
  type: TYPE_NORMAL
- en: The important distinction is that true copies of the reference types are created
    in the new object and not just the references (the memory addresses) of the reference
    types. This type of cloning is desirable if we want to have two distinct objects
    with no ties between them of any kind. Deep cloning is generally considered slower
    than shallow cloning and consumes more resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement either of the cloning types, we can leverage one of the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a third-party library such as jQuery or lodash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the JSON exploit hack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own custom clone method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using external libraries for cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**jQuery** provides the `extend` method which enables us to create both shallow
    and deep cloning of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general format for the `extend` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While this approach is generally a good option for cloning objects, it does
    have some limitations, such as when dealing with built-in JavaScript types. For
    complete information regarding this method, please refer to the jQuery documentation
    at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://api.jquery.com/jQuery.extend/](http://api.jquery.com/jQuery.extend/)'
  prefs: []
  type: TYPE_NORMAL
- en: Another good library that can be used for cloning of objects is **lodash**,
    which also provides functionality for both shallow and deep cloning. The cloning
    functionality that lodash provides seems to be ideal for most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general format for creating deep clones of an object in lodash is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are however some limitations when using lodash for deep cloning, such
    as dealing with maps and sets. Please refer to the loadash documentation online
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://lodash.com/docs#cloneDeep](https://lodash.com/docs#cloneDeep)'
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON exploit for cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple but effective way of cloning objects is to use a technique (hack) known
    as JSON exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to stringify the original object and then parse the string into
    a new object, using JSON methods. This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach is simple to use, however it has limited capabilities, especially
    when it comes to copying function properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view a good discussion on using this technique, please refer to the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json](https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom clone method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to relatively simple cloning of objects, we can create our own
    custom cloning method. This method satisfies most of our needs, most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a Boolean parameter to perform either a shallow clone or
    a deep clone of an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a deep clone is required, a recursive call to the function is made to
    copy the properties of an object property (a reference type) of the original object.
    Notice the following snippet in the cloning function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as with the approaches discussed previously, this approach also has
    its own limitations, for instance, when dealing with closures. However, it does
    a pretty good job in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be adding this function to one of our application's
    core modules so it can be used in our application, when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ImagesInc_Utilites module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since a utilities module is a good place to implement our object cloning code,
    let''s create our `ImagesInc_Utilites` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this module, we have implemented our cloning function which takes care of
    copying an object's properties into a new object. I have also modified this function
    a little from its previous version that you saw earlier. This is so it will only
    copy the properties of the object itself and not its parent's properties (if there
    is one). We can do this by using JavaScript's native `hasOwnProperty` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have assigned the cloning function as a property to `Object.prototype` object,
    so all the objects in the application can have access to this method.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our custom cloning method in ImagesInc_Utilites module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a test module to see how our cloning mechanism works. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we have created a simple module which exposes a public interface with controlled
    access to its private variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can create a clone of the original module, `TestModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run a simple test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the expected output is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that all the properties have been copied from our original module
    to our new module, we can examine all the properties in both modules, using our
    browser''s debugger (I''m using Chrome''s debugger) as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our custom cloning method in ImagesInc_Utilites module](img/B04910_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An important aspect of our cloning method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is also another interesting aspect of this cloning method that you need
    to be mindful of.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that our `TestModule` has a hidden property by design, which is `privateTestValue`.
    What happens to this property when we do our cloning?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the best way to find out is by running a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `TestModule`, we have a method property (`changePrivateVar`) which modifies
    this hidden property. So if we run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can change the value of this property to `the private value has been changed`,
    in our `TestModule`. Now, let's see if our `CloneModule` has access to this value
    and if so, does it hold on to the old value of this property or will the value
    will be changed for our `CloneModule` as well?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We see that not only our `CloneModule` has access to this property but also
    that the value has been changed for this module.
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that because of the closure in our original `TestModule` module,
    our `CloneModule` also has access to the private scope of this module and it also
    retains the state of the scope that is provided by the closure.
  prefs: []
  type: TYPE_NORMAL
- en: This may, or may not, be a desirable result for us, depending on how we want
    to clone our modules. However, it is very important to keep in mind that, because
    of the closure in our original module, our cloning outcome is a little different
    than when we clone objects which do not have embedded closures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Running more tests on our cloning method**'
  prefs: []
  type: TYPE_NORMAL
- en: I have included a few tests for module cloning in the accompanying code for
    this chapter. You can see these tests in the `AppTester.js` file. Please have
    a look, read the comments and modify the code to see how the results can be affected.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, cloning can be used when we want to create a replica of our
    original module with access to the original module's closure context. This in
    turn can provide us with access to the private members of the original module.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when we clone a module, we use it as the base module for a
    new module. We can then add more functionality or modify the existing functionality
    of the new module, using one of the other techniques that we discussed previously,
    such as loose or tight augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows us to extend the clone of a module instead of the original
    module, thus shielding the original module from all the changes, while having
    access to all the functionality of the original module.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, cloning is not the only way that we can achieve this, but nonetheless,
    it is another valuable tool to have in our toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Review of Important JavaScript OOP Concepts"),
    *Review of Important JavaScript OOP Concepts*, we talked about what inheritance
    is and looked at different approaches to creating inheritance relationship among
    objects. Here, we will leverage the techniques that we learned in that chapter
    to create inheritance among modules.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we use inheritance to utilize our base module's functionality and
    then either add new functionality or modify the existing functionality in our
    child modules.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways of creating inheritance among modules and we will examine
    two of these approaches in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Module inheritance using __proto__ object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this type of inheritance implementation, we use the child module's `__proto__`
    object to inherit properties from the parent module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have created two modules here: `Polygon_Module,` which is
    the parent module in our inheritance relationship, and `Rectangle_Module`, which
    is the child module.'
  prefs: []
  type: TYPE_NORMAL
- en: In our `Polygon_Module`, we have created private variables and functions, which
    are not accessible to the external code, except through the module's interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`Rectangle_Module` is designed in a way that it inherits some of its functionality
    from its parent module (`Polygon_Module`). It then modifies some of the inherited
    functionality as well as adding new functionality of its own.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code is the essential piece that creates the inheritance
    relationship between the two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As shown, we have passed a reference from `Polygon_Module` to the `__proto__`
    object of `Rectangle` object. This allows the `Rectangle` object to have access
    to all the properties that were exposed in the parent module, through the parent
    module's interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we get when we run the following tests on our modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The above tests demonstrate that the child module, `Rectangle_Module`, has all
    the methods that were inherited from the parent module; additionally, it has overridden
    some of these inherited properties.
  prefs: []
  type: TYPE_NORMAL
- en: Notice `Rectangle_Module.getType()` method, which was not defined or overridden
    in the child module, but was accessed by the child module through the parent module's
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Module inheritance using parasitic combination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach to creating inheritance among objects, which you are probably
    familiar with and have seen an example of in [Chapter 2](ch02.html "Chapter 2. Review
    of Important JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*,
    is **parasitic combination** inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, the idea is that we use the base class's constructor function
    in the child's constructor to create an instance of the child object. We also
    use the base class's `prototype` object to get a reference to all the properties
    that are exposed on the base class's `prototype` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refresh your memory, let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this version of our modules, `Polygon_Module2` has a constructor function
    called `Polygon`. All of our methods are also defined on the `prototype` object
    of the `Polygon` class (object).
  prefs: []
  type: TYPE_NORMAL
- en: '`Polygon_Module2` module also has an anonymous object as an interface, which
    holds a reference to `Polygon` class (object).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our child module, we have created another constructor function `Rectangle`,
    which uses the available interface in `Polygon_Module2` to borrow the `Polygon`
    constructor, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also set the `prototype` object of `Rectangle` object to point to `Polygon.prototype`
    object so we can have access to all the methods defined in this object, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And of course, since we have completely overwritten the `prototype` object of
    our `Rectangle` class, we need to reset its `constructor` property so that it
    points to the correct object, which in this case is `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have created an instance of `Rectangle` object to start the inheritance
    relationship between the two objects and set the objects' contexts properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a few tests to verify the inheritance relationship, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the tests produce the results that were expected.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the module inheritance approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are wondering which approach to take (**__proto__ inheritance** or **parasitic
    inheritance**) when you need to create an inheritance relationship among your
    application modules, in my opinion it will be a matter of taste for the most part.
  prefs: []
  type: TYPE_NORMAL
- en: However, consider that in our first approach (using `__proto__` inheritance),
    we did not need to create an instance of the child module to create the inheritance
    relationship. This means one less function call and probably a little less memory
    consumption as no instances of the object are held in memory.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, keep in mind that older browsers may not support setting
    the `__proto__` property of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**More information about inheritance**'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to get a little more information regarding inheritance among
    JavaScript objects in general, please refer to [Chapter 2](ch02.html "Chapter 2. Review
    of Important JavaScript OOP Concepts"), *Review of Important JavaScript OOP Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: Submodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last technique that we consider in this chapter, which also allows us to
    extend our modules, is using **submodules**.
  prefs: []
  type: TYPE_NORMAL
- en: Submodules are essentially independent modules, which can be added to another
    module as properties of the hosting module. There are various ways of adding submodules
    to other modules and we will cover two of these approaches in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's stay with the shape theme that we have been using so far and create a
    `Shape` module. We will consider this module as our hosting module. This module
    is the parent module for all 2D and 3D shapes and we will add our `Polygon` module
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding submodules using dynamic properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding a submodule to a module as a dynamic property is straightforward, and
    as we can add dynamic properties to any JavaScript object, we can add a property
    to a hosting module which points to a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a submodule `Shape.Polygon` and have added it to our main
    module `Shape` as a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we can access the main module and the submodule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest way of adding a submodule to a main module but it does
    require the main module to be present in the scope, before we can add the submodule
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding submodules using asynchronous properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding submodules to a hosting module using asynchronous properties has the
    advantage of being more flexible, in the sense that the hosting module does not
    need to be loaded before the submodule can be added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the submodule can potentially reside in a different file, and can
    be loaded and added to the hosting module at different times (either before or
    after the hosting module is loaded), in an asynchronous fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code is responsible for adding our submodule `Polygon_Module`, to our main
    module `Shape`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are passing two parameters to our IIFE, one for the main
    module and the other for the submodule. When any of them does not yet exist in
    the execution context, we are passing an empty object to our IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the IIFE, we check to see if our `mainModule` has the property `Polygon`,
    which is in fact our submodule. If the property does exist, we just use it and
    add a new property to this submodule, called `description`.
  prefs: []
  type: TYPE_NORMAL
- en: If the property `Polygon` (the submodule) does not exist in our code execution
    context, we use the passed-in submodule and then add the new property `description`
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check to see if we can access this new property on the submodule, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, even if we add our `Shape` module (the hosting module) after our submodule
    to our execution context, we can still add our submodule to this module. We can
    also provide access to our submodule's properties, through the main (hosting)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of our `Shape` module accepts one parameter, which can be
    either an empty object or a reference to an already existing `Shape` module. This
    means that, even if our `Shape` module was already created in our previous IIFE,
    which was responsible for adding our `Polygon_Module` to our `Shape` module, we
    are still able to re-define it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The result confirms that we are able to access properties of the `Shape` module
    as well as our submodule, no matter which one is loaded first in our application.
  prefs: []
  type: TYPE_NORMAL
- en: You might also notice that the implementation above is very similar to our loose
    augmentation pattern that we discussed previously. The only real difference is
    that we are adding our submodule as a completely independent module to our main
    module, as opposed to just augmenting the main module with new properties.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a few more techniques which enable us to extend
    and modify our modules.
  prefs: []
  type: TYPE_NORMAL
- en: We considered how we can use various cloning approaches to create replicas of
    our modules and talked about the pros and cons of each approach. We also examined
    how we can use inheritance among modules so that a child module can utilize the
    functionality of its parent module as well as override its parent module's functionality,
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we talked about submodules and looked at
    a couple of different techniques for adding submodules to our main (hosting) modules.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be more focused on the design of our application as a
    whole. We'll see how a flexible ecosystem can be created for our modules, which
    allows them to interact and work together, without being dependent on each other.
  prefs: []
  type: TYPE_NORMAL
