<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Implementing a Dispatcher</h1></div></div></div><p>Up until this point in the book, we've<a id="id362" class="indexterm"/> relied on the reference implementation of the Flux dispatcher. There's nothing wrong with doing this—it's a functional piece of software, and the dispatcher doesn't have many moving parts. On the other hand, it is just a reference implementation of a larger idea—that actions need to be dispatched to stores, and store dependencies need to be managed.</p><p>We'll kick things off by talking about the abstract dispatcher interface that's required by Flux architectures. Next, we'll discuss some of the motivations behind implementing our own dispatcher. Finally, we'll devote the remainder of the chapter to implementing our own dispatcher module, and then improving our store components so that they're able to seamlessly interact with the new dispatcher.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Abstract dispatcher interface</h1></div></div></div><p>The idea <a id="id363" class="indexterm"/>with any reference implementation is to directly illustrate, using code, how something is supposed to work. The Facebook reference<a id="id364" class="indexterm"/> implementation of the Flux dispatcher does just that—we can use it in a real Flux architecture and get results. We also gain an understating of the abstract dispatcher interface. Put another way, the reference implementation is kind of like software requirements, expressed in code form.</p><p>In this section, we'll try to better understand what these minimum requirements are before we dive into our own dispatcher implementation. The first essential piece of functionality that the dispatcher must implement is store registration so that the dispatcher can dispatch payloads to it. Then, we need the actual dispatching mechanism, which iterates over the registered stores and delivers payloads. Finally, we have the dependency semantics to think about while we're dispatching payloads.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec121"/>Store registration</h2></div></div></div><p>When <a id="id365" class="indexterm"/>we instantiate a store, we have to tell the dispatcher about it. Otherwise, the dispatcher doesn't know about the store's existence. The pattern generally looks something like this:</p><div><img src="img/B05419_10_01.jpg" alt="Store registration"/></div><p>The dispatcher maintains an internal collection of callbacks to run whenever an action is dispatched. It simply needs to iterate over this collection of callback functions, calling each of them in turn. This really is as easy as it sounds, when everything during a Flux update round is synchronous. The question is, what would we want to change about the way the store registration process works?</p><p>Maybe instead of registering a callback function within the store constructor, we were to pass the dispatcher a reference to the store instance itself? Then, when it comes time to notify the store about an action that's been dispatched, the dispatcher would iterate over a collection of store instances and call some predefined method. The advantage to this approach would be that since the dispatcher has a reference to the store, it could access other metadata about the store, such as its dependencies.</p><p>We'll explore this idea further once we start writing code, a bit later on in the chapter. The bottom line is this—we need a means to tell the dispatcher that a given store instance would like to receive action notifications.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec122"/>Dispatching payloads</h2></div></div></div><p>The<a id="id366" class="indexterm"/> actual dispatching of payloads is quite simple. The only complicated part is handling dependencies between stores—we'll talk about that next. For now, just imagine an architecture where there are no inter-store dependencies. It's just a simple collection to iterate over, calling each function with the action payload as the argument. Here's an illustration of the process:</p><div><img src="img/B05419_10_02.jpg" alt="Dispatching payloads"/></div><p>Apart from dependency management, is there anything else that's missing from this picture? Well, there is one situation we could find ourselves in—nested dispatches. These are strictly forbidden in Flux architectures as they would disrupt the synchronous unidirectional update rounds. In fact, the reference implementation of the dispatcher by Facebook tracks the state of any given update round and will catch this if it happens.</p><p>This doesn't mean that a dispatcher component that we implement has to check for such conditions. However, it's never a bad idea to fail fast when something so disruptive to the nature of the architecture is taking place.</p><p>Something else worth thinking about is the necessity of calling every registered store in a given update round. Sure, it makes sense as far as consistency goes—treat every store the same and notify them about <em>all the things</em>. On the other hand, we could have a large application with hundreds of actions being dispatched. Would it make sense to always dispatch actions to stores that never respond to them? When we implement our own dispatcher component, we're free to think about how we can implement such heuristics that benefit our application while staying true to the principles of Flux.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec123"/>Handling dependencies</h2></div></div></div><p>Perhaps the <a id="id367" class="indexterm"/>most challenging aspect of dispatching actions is making sure that store dependencies are handled correctly. On the other hand, the dispatcher just has to make sure that the store action handlers are called in the correct order. Dispatching actions with dependencies in mind is illustrated here:</p><div><img src="img/B05419_10_03.jpg" alt="Handling dependencies"/></div><p>As long as stores that fall on the right-hand side of <code class="literal">waitFor()</code> calls get the dispatch notifications first, then all is well. So in essence, store dependencies are an ordering problem as far as the dispatcher is concerned. Order the callbacks in such a way that satisfies the dependency graph, then iterate and call each handler.</p><p>Here's the thing—do we really want to rely on the <code class="literal">waitFor()</code> dispatcher method as a means to manage store dependencies? Possibly a better way to handle this would be to declare an array of stores that we depend on. This would then be passed to the dispatcher at registration time, and we would no longer require the <code class="literal">waitFor()</code> calls.</p><p>We have the basic blueprint of what's required to implement our own dispatcher. But before we go ahead with the implementation, let's spend a little more time discussing the challenges faced with the Facebook dispatcher.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Challenges with the dispatcher</h1></div></div></div><p>In the <a id="id368" class="indexterm"/>preceding<a id="id369" class="indexterm"/> section, we caught a glimpse of some of the potential challenges with the Facebook reference implementation of a Flux dispatcher. In this section, we'll elaborate on some some of this reasoning, in an attempt to provide motivation to implement our own custom dispatcher.</p><p>In this <a id="id370" class="indexterm"/>section, we'll reiterate the fact that the Flux NPM package mainly exists as an educational tool. Depending on a package like this is fine, especially since it does the job, but we'll go over some of the risks that something like this carries in a production context. Then, we'll talk about the fact that dispatcher components are singleton instances and they probably don't need to be.</p><p>We'll then think about the store registration process and the fact that it's a more manual process than it needs to be. Finally, we'll touch on the store dependency management problem again with a discussion on <code class="literal">waitFor()</code> and possible declarative alternatives.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec124"/>Educational purposes</h2></div></div></div><p>The <a id="id371" class="indexterm"/>Facebook Flux NPM package, as we know, provides a reference implementation of a dispatcher. The best way to learn how such a component is supposed to work is to write code that uses it. It's for educational purposes, in other words. This gets us off the ground quickly, as we figure out the best way to write Flux code. Facebook could have just as easily left out the dispatcher implementation and left it up to programmers reading the Flux documentation to figure this out. Code is highly educational though, and serves as a form of documentation. Even if we decide that we're not crazy about how the dispatcher is implemented, we can at least read the code to figure out what the dispatcher is supposed to do.</p><p>So is there any risk involved if we were to use this package in a production setting? If we use the default Flux dispatcher in our project, and everything we've developed against it works, there's no reason we couldn't use it in a production application. If it works, it works. However, the fact that this is a reference implementation meant for educational purposes probably means that there's no serious development happening with it. Take React as a counter example, where millions of people use this software in a production environment. There's motivation that this technology moves forward and improves upon itself. This simply isn't the case with a reference dispatcher implementation. Rolling our own is definitely worth thinking about, especially if there's room for improvement.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec125"/>Singleton dispatchers</h2></div></div></div><p>If we use <a id="id372" class="indexterm"/>the Flux dispatcher from Facebook, we have to instantiate it, as it's just a class. However, since there's only one update round happening at any given time, there's no need for more than one dispatcher instance across the entire application. This is the singleton pattern, and it isn't always the best pattern to use. For one thing, it's needless indirection.</p><p>For example, any time we want to dispatch an action, we need to access the <code class="literal">dispatch()</code> method of the dispatcher. This means that we have to import the dispatcher instance and invoke the<a id="id373" class="indexterm"/> method using the instance as the context, like this: <code class="literal">dispatcher.dispatch()</code>. The same is true with the <code class="literal">register()</code> method; when a store wants to register itself with the dispatcher, it first needs to access the instance before it calls the method.</p><p>So, it would seem that this singleton dispatcher instance serves no real purpose other than to get in the way and make for more verbose code. What if instead of a singleton class instance, the dispatcher were just a simple module that exported the relevant functions? This would greatly simplify the code in places where the dispatcher is required, which is probably quite a few if our application has a lot of stores and actions.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec126"/>Manual store registration</h2></div></div></div><p>One invariant <a id="id374" class="indexterm"/>of Flux architectures is that stores are connected to dispatchers. There's no other way to change the state of a store, other than by dispatching an action. So unless we want a static store that never changes state, we need to register it with the dispatcher. All the example stores we've looked at in this book so far set up their dispatcher handlers in the constructor. This is where we handle actions that could potentially change the state of a store.</p><p>Since dispatcher registration is a given, do we really need to explicitly register a callback function when every store is created? An alternative approach might involve a base store class that takes care of this registration for us; this isn't necessarily a dispatcher-specific problem.</p><p>The other aspect of store registration that feels unnecessary for the most part is managing dispatcher IDs. For example, if we implement a store that depends on another store, we have to reference that other store's dispatch ID. The reason IDs are used is simple—a callback function doesn't identify the store. So we have to use the dispatcher to map the callback ID to the store. The whole approach just feels messy, so when we implement our own dispatcher, we can do away with these dispatch IDs entirely.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec127"/>Error-prone dependency management</h2></div></div></div><p>The final <a id="id375" class="indexterm"/>gripe that we'll want to address with the default Facebook Flux dispatcher is the way that dependencies between stores are handled. The <code class="literal">waitFor()</code> mechanism does its job in that it blocks further execution of the handler until all its dependencies have handled the action. This way, we know that the store that we depend on is always up to date. The trouble is that <code class="literal">waitFor()</code> feels kind of error-prone.</p><p>For one thing, it always has to be in the same place—right at the top of the store action handler. We have to remember to use the dispatch IDs from the stores that we depend on so that <code class="literal">waitFor()</code> knows which stores to process next. A more declarative approach would mean that we could set the store's dependencies as an array of store references or something along these lines. This way, the dependencies are declared outside of the actual <a id="id376" class="indexterm"/>callback function and are a little more obvious. We'll figure out a way to implement this in our dispatcher, which we'll now get started on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>Building a dispatcher module</h1></div></div></div><p>In this <a id="id377" class="indexterm"/>section, we're going to implement our own <a id="id378" class="indexterm"/>dispatcher module. This will serve as a replacement for the Facebook reference implementation that we've relied upon so far in this book. First, we'll think about how the dispatcher will track references to store modules. Then, we'll discuss the functions that this module needs to expose, followed by a walk-through of the <code class="literal">dispatch()</code> implementation. Lastly, we'll figure out how we want to handle dependency management with this dispatcher module.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec128"/>Encapsulating store references</h2></div></div></div><p>The <a id="id379" class="indexterm"/>first aspect of our dispatcher module to consider are the stores themselves. With Facebook's reference implementation, there are no references to stores—only references to callback functions. That is, when we register with Facebook's dispatcher, we're passing the <code class="literal">register()</code> method a function instead of the store instance itself. Our dispatcher module will hold onto store references instead of just callback functions. Here's a diagram that illustrates the approach taken by the reference implementation:</p><div><img src="img/B05419_10_04.jpg" alt="Encapsulating store references"/></div><p>Each <a id="id380" class="indexterm"/>time <code class="literal">register()</code> is called, it adds a callback function to the list of callbacks to be processed by the dispatcher any time an action is dispatched. However, the downside is that the dispatcher might need access to the store for more advanced capabilities that we want to implement, as we'll see shortly. So we'll want to register the store instance itself, rather than just a callback function. This approach is illustrated here:</p><div><img src="img/B05419_10_05.jpg" alt="Encapsulating store references"/></div><p>The list of callback functions is now a list of store instances, and when an action is dispatched, the dispatcher now has access to store data, which is useful for things, such as methods <a id="id381" class="indexterm"/>and dependency lists. The trade-off here is that callback functions are more generic, and they're simply called by the dispatcher. As we'll see momentarily, there are advantages to this approach that make for simplified store code.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec129"/>Handling dependencies</h2></div></div></div><p>The first thing<a id="id382" class="indexterm"/> we'll think about in terms of our dispatcher implementation is how dependencies between stores are managed. The standard approach is to implement a <code class="literal">waitFor()</code> method that blocks execution in the store handler function until the stores it depends on have been handled. As you're now aware, this approach can be problematic due to the fact that it's used within the handler function. A more declarative approach is what we're shooting for with our implementation.</p><p>The idea is that the list of stores that are depended upon are declared as a property of the store. This allows the store to be queried for other stores that it depends on. It also takes the dependency management aspect of stores out of the handler code that's supposed to focus on actions. Here's a visual comparison of the two approaches:</p><div><img src="img/B05419_10_06.jpg" alt="Handling dependencies"/></div><p>Trying to access dependencies that are specified in <code class="literal">waitFor()</code> is like peeling back an onion—they're hidden. Our goal is to separate the handler code from the dependency specification. So how do we do that exactly?</p><p>Rather than trying to handle dependencies during the dispatching process, we could sort out our dependencies as stores are registered. If a store has its dependencies listed in a property, then<a id="id383" class="indexterm"/> the dispatcher can organize the store list in such a way that satisfies those dependencies. Here's an implementation of a <code class="literal">register()</code> function for our dispatcher module:</p><div><pre class="programlisting">// This is used by stores so that they can register
// themselves with the dispatcher.
export function register(store) {

  // Don't let a store register itself twice...
  if (stores.includes(store)) {
    throw `Store ${store} already registered`;
  }

  // Adds the "store" reference to "stores".
  stores.push(store);

  // Sorts our stores based on dependencies. If a store
  // depends on another store, the other store is
  // considered "less than" the store. This means that
  // dependencies will be satisfied if the stores are
  // processed in this sort order.
  stores.sort((a, b) =&gt; {
    if (a.deps.includes(b)) {
      return 1;
    }

    if (b.deps.includes(a)) {
      return -1;
    }

    return 0;
  });
}</pre></div><p>This is the function that stores can use to register themselves. The first thing this function does is it checks if the store has already been registered with the dispatcher. This is an easy check to perform, because the references are stored in an array; we can use the <code class="literal">includes()</code> method. If the store hasn't already been registered, then we can push the store onto the array.</p><p>Next, we handle store dependencies. Every time a store is registered, we re-sort the <code class="literal">stores</code> array. This sort is based on the <code class="literal">deps</code> property of the store. This is where the dependencies of the store are declared. The sort comparator is straightforward. It's based on whether <strong>Store A</strong> depends on <strong>Store B</strong> or vice-versa. For example, let's say these stores were registered in the following order:</p><div><img src="img/B05419_10_07.jpg" alt="Handling dependencies"/></div><p>Now, let's <a id="id384" class="indexterm"/>assume that the follow store dependencies have been declared:</p><div><img src="img/B05419_10_08.jpg" alt="Handling dependencies"/></div><p>This means that <strong>Store A</strong> depends on both <strong>Store B</strong> and <strong>Store D</strong>. After each of these stores have been registered, the order of the store list in our dispatcher modules would be as follows:</p><div><img src="img/B05419_10_09.jpg" alt="Handling dependencies"/></div><p>Now the store list is in an order that satisfies the dependencies of the stores. When the dispatcher iterates over the store list and calls each store handler, it will be done in the correct order. Since <strong>Store A</strong> depends on <strong>Store C</strong> and <strong>Store D</strong>, all that matters is that these two stores are handled first. The order of <strong>Store A</strong> and <strong>Store C</strong> are inconsequential since there's no dependency declared between them. Now, let's see how to implement the dispatching logic of our module.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec130"/>Dispatching actions</h2></div></div></div><p>In the<a id="id385" class="indexterm"/> Facebook reference implementation of a Flux dispatcher, the dispatching mechanism is a method of a dispatcher instance. Since there's really no need for a singleton dispatcher instance, our dispatcher is a simple module with a couple of functions exposed, including a <code class="literal">dispatch()</code> function. Thanks to the dependency sorting logic, we've implemented in the <code class="literal">register()</code> function; the work-flow of <code class="literal">dispatch()</code> will be nice and straightforward. Let's take a look at this code now:</p><div><pre class="programlisting">// Used by action creator functions to dispatch an
// action payload.
export function dispatch(payload) {

  // The dispatcher is busy, meaning that we've
  // called "dispatch()" while an update round
  // was already taking place.
  if (busy) {
    throw 'Nested dispatch() call detected';
  }

  // Marks the dispatcher as "busy" before we
  // start calling any store handlers.
  busy = true;

  // The action "type" determines the method
  // that we'll call on a the store.
  let { type } = payload;

  // Iterates over each registered store, looking
  // for a method name that matches "type". If found,
  // then we call it, passing it the "payload" that
  // was dispatched.
  for (let store of stores) {
    if (typeof store[type] === 'function') {
      store[type](payload);
    }
  }

  // The dispatcher isn't busy any more, so unmark it.
  busy = false;
}</pre></div><p>You can <a id="id386" class="indexterm"/>see that there's a <code class="literal">busy</code> variable that's checked at the top of the function. This is set just before we start calling store handlers. Essentially, this checks for anything that calls <code class="literal">dispatch()</code> as a result of a store handling an action. For example, we could accidentally call <code class="literal">dispatch()</code> from a store or from a view that's listening to a store. This is not allowed as it breaks the unidirectional data-flow of our Flux architecture. When this happens, it's better to detect it and fail fast than it is to let nested update rounds run their course.</p><p>Aside from the busy state handling logic, this function iterates over the stores collection and checks if there's an appropriate method to call. The method name is based on the action type. For example, if the action is <code class="literal">MY_ACTION</code> and store has a method of the same name, then<a id="id387" class="indexterm"/> that method is invoked with the payload as an argument. The process is visualized here:</p><div><img src="img/B05419_10_10.jpg" alt="Dispatching actions"/></div><p>This is quite the departure from the standard <code class="literal">switch</code> statement approach we've been using in this book so far. Instead, it's up to the dispatcher to locate the appropriate code to run within the store. This means that if the store doesn't implement a method that corresponds to the action that has been dispatched, it's ignored by the store. This is something that happens often within our store dispatch handlers, only now it happens more efficiently because it sidesteps the <code class="literal">switch</code> case checking. In the next section, we'll see how our stores can work with this new dispatcher implementation. But first, here's the dispatcher module in its entirety, so you can see how everything fits together:</p><div><pre class="programlisting">// References to registered stores...
const stores = [];

// This is true when the dispatcher is performing
// an update round. By default, it's not busy.
var busy = false;

// This is used by stores so that they can register
// themselves with the dispatcher.
export function register(store) {

  // Don't let a store register itself twice...
  if (stores.includes(store)) {
    throw `Store ${store} already registered`;
  }

  // Adds the "store" reference to "stores".
  stores.push(store);

  // Sorts our stores based on dependencies. If a store
  // depends on another store, the other store is
  // considered "less than" the store. This means that
  // dependencies will be satisfied if the stores are
  // processed in this sort order.
  stores.sort((a, b) =&gt; {
    if (a.deps.includes(b)) {
      return 1;
    }

    if (b.deps.includes(a)) {
      return -1;
    }

    return 0;
  });
}

// Used by action creator functions to dispatch an
// action payload.
export function dispatch(payload) {

  // The dispatcher is busy, meaning that we've
  // called "dispatch()" while an update round
  // was already taking place.
  if (busy) {
    throw 'Nested dispatch() call detected';
  }

  // Marks the dispatcher as "busy" before we
  // start calling any store handlers.
  busy = true;

  // The action "type" determines the method
  // that we'll call on a the store.
  let { type } = payload;

  // Iterates over each registered store, looking
  // for a method name that matches "type". If found,
  // then we call it, passing it the "payload" that
  // was dispatched.
  for (let store of stores) {
    if (typeof store[type] === 'function') {
      store[type](payload);
    }
  }

  // The dispatcher isn't busy any more, so unmark it.
  busy = false;
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Improving store registration</h1></div></div></div><p>We <a id="id388" class="indexterm"/>can't improve the work-flow of the dispatcher without improving the work-flow of our stores. Thankfully, the hard work has already <a id="id389" class="indexterm"/>been implemented by the dispatcher. We just need to implement our stores in a way that best utilizes the improvements we've made to the dispatcher. In this section, we'll discuss implementing a base store class, followed by some example implementations of stores that extend it and implement their own action methods.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec131"/>Base store class</h2></div></div></div><p>The <a id="id390" class="indexterm"/>new dispatcher we've just implemented has some important differences from Facebook's reference implementation. The two key differences are that the store registers an instance of itself instead of a callback function, and that the store needs to implement action methods. The base store class should be able to automatically register itself with the dispatcher when it's created. This would mean that stores extending this base class wouldn't need to worry about the dispatcher at all—just implementing action methods that change the state of the store accordingly.</p><p>The layout of the dispatcher, the base store, and stores that extend it is illustrated here:</p><div><img src="img/B05419_10_11.jpg" alt="Base store class"/></div><p>Let's go <a id="id391" class="indexterm"/>ahead and look at the implementation of our base store class now. Then, we'll implement some stores that extend it so that we can see our new dispatcher module in action:</p><div><pre class="programlisting">import { EventEmitter } from 'events';
import { register } from './dispatcher';

// Exports the base store for others to extend.
export default class Store extends EventEmitter {

  // The constructor sets the initial "state" of the
  // store, as well as any dependencies "deps" with
  // other stores.
  constructor(state = {}, deps = []) {
    super();

    // Stores the state and dependencies. The "deps"
    // property is actually required by the
    // dispatcher.
    this.state = state;
    this.deps = deps;

    // Registers the store with the dispatcher.
    register(this);
  }

  // This is a simple helper method that changes the
  // state of the store, by setting the "state"
  // property and then emitting the "change" event.
  change(state) {
    this.state = state;
    this.emit('change', state);
  }

}</pre></div><p>That's it, pretty simple right? The constructor accepts the initial state of the store and an array of store dependencies. Both of these arguments are optional—they have default argument values. This is especially important for the <code class="literal">deps</code> property because our dispatcher module expects it to be there. Then, we call the <code class="literal">register()</code> function so that the dispatcher is automatically aware of any stores. Remember, a Flux store is of no use if it's unable to handle actions as they're dispatched.</p><p>We've also<a id="id392" class="indexterm"/> added a handy little <code class="literal">change()</code> method that updates the state and emits the change event for us. Now that we have a base store class, we're free to implement little helper methods like this in order to reduce duplicate store code.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec132"/>An action method</h2></div></div></div><p>Let's <a id="id393" class="indexterm"/>complete our example that's been running through a few sections now. To do so, we'll implement a few stores that extend the base store we've just created. Here's the first store:</p><div><pre class="programlisting">import Store from '../store';
import second from './second';
import third from './third';

// The initial state of the store, we'll
// pass this to "super()" in the constructor.
const initialState = {
  foo: false
};

// The dependencies this store has on other
// stores. In this case, it's "second" and
// "third". These too, are passed through
// "super()".
const deps = [ second, third ];

class First extends Store {

  // The call to "super()" takes care for setting up
  // the initial store state, and the dependencies
  // for us.
  constructor() {
    super(initialState, deps);
  }

  // Called in response to the "FOO" action
  // being dispatched...
  FOO(payload) {
    this.change({ foo: true });
  }

  // Called in response to the "BAR" action
  // being dispatched...
  BAR(payload) {
    this.change(Object.assign({
      bar: true
    }, this.state));
  }
}

export default new First();</pre></div><p>This store <a id="id394" class="indexterm"/>has all of the relevant moving parts to work with our new base store class and our new dispatcher module. You can see in the constructor that we're passing the <code class="literal">initialState</code> and the <code class="literal">deps</code> values to the <code class="literal">Store</code> constructor. You can also see that we have two action methods implemented in this store: <code class="literal">FOO()</code> and <code class="literal">BAR()</code>. This means that if any actions with a type of <code class="literal">FOO</code> or <code class="literal">BAR</code> are dispatched, this store will respond to them. Now let's implement the two stores that this store depends on:</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>If you absolutely can't stand the look of all-caps method names, feel free to change the case of the action types that get dispatched. Another alternative is to implement case-insensitive matching in the dispatcher. The trade-off working against this latter option is that we'd lose the direct mapping from action type to method name. Be careful what you wish for.</p></div></div><div><pre class="programlisting">import Store from '../store';
import third from './third';

class Second extends Store {

  // The call to "super()" sets the initial
  // state for us.
  constructor() {
    super({
      foo: false
    });
  }

  // Called in response to the "FOO" action
  // being dispatched...
  FOO(payload) {
    this.change({ foo: true });
  }

  // Called in response to the "BAR" action
  // being dispatched. Note that we're
  // dependent on the "third" store, yet
  // we don't make this dependency explicit.
  // This could lead to trouble.
  BAR(payload) {
    this.change({
      foo: third.state.foo
    });
  }
}

export default new Second();</pre></div><p>The <code class="literal">Second</code> store is similar to the <code class="literal">First</code> store. It extends the base <code class="literal">Store</code> class and sets a default state. It <a id="id395" class="indexterm"/>also responds to two actions, as we can see by the two method names. However, this store doesn't declare any dependencies, yet it clearly depends on the third store in the <code class="literal">BAR()</code> action handler. This may or may not work, depending on where the <code class="literal">third</code> store lands in the collection of stores held by the dispatcher. If we declare <code class="literal">third</code> as a dependency, then we know for certain that it'll always be updated before this store. Let's look at our last store now:</p><div><pre class="programlisting">import Store from '../store';

class Third extends Store {

  // The call to "super()" sets the initial
  // state for us...
  constructor() {
    super({
      foo: false
    });
  }

  // Called in response to the "FOO" action
  // being dispatched.
  FOO(payload) {
    this.change({ foo: 'updated' });
  }
}

export default new Third();</pre></div><p>Once again, this store follows the same patterns as its two successors. The key difference being that it has no <code class="literal">BAR()</code> action handler. This means that nothing in this store will be called <a id="id396" class="indexterm"/>when <code class="literal">BAR</code> actions are dispatched. This is in contrast to our earlier handlers where every action would have <em>funnelled</em> through a <code class="literal">switch</code> statement only to be ignored. Finally, let's look at <code class="literal">main.js</code> to tie this all together:</p><div><pre class="programlisting">import first from './stores/first';
import second from './stores/second';
import third from './stores/third';

import { foo } from './actions/foo';
import { bar } from './actions/bar';

// Logs the state of each store as it changes...
first.on('change', (state) =&gt; {
  console.log('first', state);
});

second.on('change', (state) =&gt; {
  console.log('second', state);
});

third.on('change', (state) =&gt; {
  console.log('third', state);
});

foo();
// →
// third {foo: "updated"}
// second {foo: true}
// first {foo: true}

bar();
// →
// second {foo: "updated"}
// first {bar: true, foo: true}</pre></div><p>Note that the output of <code class="literal">foo()</code> reflects the correct dependency order and that the output of <code class="literal">bar()</code> reflects the missing action handler in <code class="literal">Third</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Summary</h1></div></div></div><p>In this chapter, you learned about some of the limitations that are inherent with the Facebook Flux component. For starters, it's not targeted for production environments, because it's a reference implementation for the Flux patterns. We're free to implement these dispatcher patterns however we like.</p><p>The essential aspects of a dispatcher are the ability to register store code that handles actions as they're dispatched and the ability to perform the dispatches. Given the simplicity of the requirements, it doesn't make sense to implement another singleton class. Instead, the dispatcher only needs to expose a <code class="literal">register()</code> and <code class="literal">dispatch()</code> function.</p><p>The big change with our implementation was with regard to dependency management. Instead of figuring out dependencies every time an action is dispatched, the <code class="literal">register()</code> function sorts the <code class="literal">stores</code> collection in such a way that satisfies the store dependencies. We then implemented a base store class that's used to simplify our store code by automatically registering the store with the dispatcher for us.</p><p>In the next chapter, we'll look at view components that rely on technologies other than ReactJS to render themselves.</p></div></body></html>