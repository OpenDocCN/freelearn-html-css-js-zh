- en: Chapter 7. Viewing Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The view layer is the last data flow stop in a Flux architecture. Views are
    the essence of our application because they provide information directly to the
    user and respond directly to user interactions. This chapter takes a detailed
    look at view components within the context of a Flux architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a discussion about getting views their data, and what they
    can do with it once they have it. Next, we'll look at some examples that emphasize
    the stateless nature of Flux views. Then, we'll review the responsibilities of
    views in Flux architectures, which are different from views in other types of
    frontend architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We'll wrap the chapter up with a look at using ReactJS components as the view
    layer. Let's get started!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Passing views data
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views don't have their own data source that they can use to render UI elements.
    Instead, they rely on the state of Flux stores, and they listen for changes in
    state. In this section, we'll cover the change event that stores will emit to
    signify that views can render themselves. We'll also discuss the idea that it's
    ultimately up to the view to decide when and how to render the UI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Data via the change event
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view components that we've seen so far in this book have all relied on the
    change event that stores emit when the state of a store has changed. This is how
    the view knows that it can render itself to the DOM—because there's new store
    state, meaning that there's probably a visual change that we want the user to
    see.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed from the earlier examples that all the handler functions
    that listen for change events had a state parameter—this is the state of the store.
    The question is—why do we need to include this state data? Why can''t the view
    just reference the store directly to reference the state data? This idea is illustrated
    here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Data via the change event](img/B05419_07_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'The change event is still necessary, even though the view is directly referencing
    the store''s state—how else would it know to render? The change event is emitted,
    and the view then knows that the state it''s referencing has changed as well.
    There''s a potential issue with this approach, and it has to do with immutability.
    Let''s look at some code to better understand the problem. Here''s a store with
    a `name` property as its state:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When this store responds to the `NAME_CAPS` action, its job is to transform
    the state of the `name` property, using a simple call to `toUpperCase()`. Then,
    the change event is emitted with the state as the event data. Let''s look at another
    store that does the same thing, but using a different approach to updating the
    `state` object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the two stores are basically identical, and they produce the
    same result when the `NAME_CAPS` action is dispatched. However, note that this
    transformation doesn''t mutate the `state` object. It replaces it instead. This
    approach keeps the state object immutable, meaning that the store will never change
    any of its properties. The difference is felt in the view layer, and it highlights
    the need for the state argument in the change event handler:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is why we can't make assumptions about the state of a store. In the preceding
    code, we just made a critical error in assuming that we could hold onto a `secondStore.state`
    reference. It turns out that this object is immutable, and so the only way for
    views to access the new state is through the state argument in the change handler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Views decide when to render
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The job of a Flux store is centered primarily on generating the correct information
    for views to consume. What isn't part of a store's job description is to know
    when a view actually needs to update or not. This means that it's up to the view
    to decide what happens when a store triggers a change event—it could be that nothing
    in the DOM needs to be updated. The question then becomes—why would a store emit
    a change event if nothing has changed?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The simple answer is that stores don't do enough bookkeeping to make a determination
    as to whether something has changed or not. The store knows how to perform the
    correct state transformations, but it doesn't necessarily keep track of previous
    states for diffing purposes—although it certainly could do that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a store that doesn''t mutate its state. Instead, it creates
    new state when something is transformed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This store is listening to the same `NAME_CAPS` message from the previous example.
    Its job is still the same—transform the `name` property to uppercase. However,
    this code works differently than in the last version of the store. It's immutable
    in that it doesn't mutate the `state` object—it replaces it. But it only does
    so if the value has actually changed. Otherwise, the `state` object stays the
    same. The idea here isn't to show that stores should detect state changes on individual
    properties, but rather that the change event can be emitted even when the state
    hasn't changed. In other words, our views shouldn't make the assumption that rendering
    to the DOM is necessary, just because of a change event.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn our attention to the view now. The plan is simple—don''t render
    unless we have to:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that the `previousState` property keeps a reference to the state
    of the store. But wait, isn''t that a bad thing, according to the section before
    this one? Well, no, because we''re not actually using the reference for anything
    other than strict equality checking. This is used to determine whether or not
    the view needs to render. Since the store state is immutable, we can assert that
    if the same reference is passed as an argument to the change event handler, nothing
    actually changed and we can safely ignore the event. Let''s see what happens when
    we call the same action several times in succession:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Later in this chapter when we look at ReactJS, we'll see more advanced scenarios
    of views that only render what they need to. Later in the book when we look at
    `Immutable.js`, we'll tackle more advanced state change detection.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Keeping views stateless
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views can't be completely stateless because they interact with the DOM, and
    the DOM elements associated with a view will always have a state. However, we
    can take steps to treat views as stateless entities within the context of our
    Flux architecture. In this section, we'll address two aspects of stateless views.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll go over the idea that all state in a Flux architecture belongs
    in a store, including any UI state that we might be tempted to keep in our view
    components. Second, we'll look at DOM querying and why we want to avoid doing
    this from within our Flux views.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: UI state belongs in stores
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you learned in the previous chapter, UI state is just like state that''s
    derived from application data—it all belongs in a store. UI state includes things
    such as the `disabled` property of a button or the name of a class that''s applied
    to a `div`. The reason these bits of state belong in a store is that other stores
    might depend on them. This in turn affects the rendering outcome of other views.
    This type of dependency is visualized as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![UI state belongs in stores](img/B05419_07_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: If the UI state that other stores might depend on isn't kept in a store, then
    they'd have to depend on the view or the DOM itself. This is inconsistent and
    goes against what Flux stands for—strict update ordering and keeping state confined.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: No querying the DOM
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the UI state is kept in a Flux store, there's no need to query the DOM
    to figure out whether or not a button is disabled. Think about the jQuery approach
    to manipulating application state. First, we have to issue a DOM query that gets
    us the relevant DOM elements, and then we have to figure out whether they're in
    the appropriate state by reading some of their properties. Then, we can make changes
    elsewhere in the application. Or perhaps there's a blend of state that's kept
    directly in the DOM and some JavaScript objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: It's the consistency that's the biggest difference maker in Flux architectures,
    because we don't have to query the DOM to get the `href` property of a link. The
    stores that hold onto UI state already have this information. This is always the
    case—it's never a matter of figuring out whether it's in the DOM or some other
    component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of having all the UI state that we need to make rendering
    decisions in our stores is that there's no performance bottleneck. Querying the
    DOM once or twice is not a big deal, and this does need to happen if we're going
    to display changes for the user. What we don't want is to have a long series of
    DOM query calls that don't even result in something being rendered. In other words,
    there's no need to query the DOM to extract information when it should already
    be in a store.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: This is the same strategy used by virtual DOM tree technologies such as ReactJS,
    where the DOM data is all stored in JavaScript objects. Looking up some UI state
    from a JavaScript object is inherently faster than looking up DOM element properties,
    and this is how ReactJS is able to perform so well—by minimizing the number of
    DOM interactions for a given UI change.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: View responsibilities
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in the book, you probably have a pretty good handle on the role
    of view components in a Flux architecture. Put simply, their job is to display
    store information for users by inserting it into the DOM. In this section, we'll
    break this core view concept into three parts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: First there's the input to the views—the store data. Next, we have the structure
    of the view itself, and the various ways that it can be decomposed into smaller
    views. Finally, there's the user interactivity. Each of these three areas of view
    components has a relation to the flow of data through our Flux architecture. Let's
    look at each of them now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Rendering store data
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the store transforms data into information that the user needs, then why
    have views at all? Why not have the stores directly render the information to
    the DOM? We need views for a couple reasons. First of all, a store could actually
    be used in several places, rendered by several views. Second of all, Flux isn't
    necessarily concerned with the visual display of information. For example, if
    we were to design some view that's doesn't render HTML but some other display
    format, that would be perfectly fine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Views don''t keep any state or perform any transformations on store information.
    However, they do need to transform the information a little, to turn it into valid
    markup for display in the browser or any other display medium where our application
    runs. But aside from marking up the information returned from stores, views have
    little to do. It''s the view technology, such as ReactJS, that does the majority
    of the legwork in terms of marking up JavaScript objects and inserting them into
    the DOM. Here is a diagram that shows the process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering store data](img/B05419_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Subview structure
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aim of stores in Flux architectures is to structure them so that there's
    only one store per top-level feature. This gets us around the issues created by
    having massive hierarchies of data structures. Views, on the other hand, can benefit
    from a little bit of hierarchical structure. Just because a top-level feature
    is driven by information from a single store, it doesn't mean that only a single
    view can drive the user experience.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in the book, we discussed the notion of hierarchical structure and
    how it should be avoided in Flux architectures. This is still true to an extent
    with views, because no matter how you slice it, deep hierarchies are difficult
    to comprehend. Views do need to be decomposed to an extent, because otherwise
    we''ll end of putting all the markup complexity in one place. HTML markup is hierarchical
    by nature, so to some degree our views should mimic this structure, as illustrated
    here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Subview structure](img/B05419_07_04.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Just like stores can be generic, so can views. More than one feature can use
    generic components to present information using a common display pattern. For
    instance, think about some kind of expandable/collapsible panel that's used by
    all of our features—would it not make sense to plug this into our larger features
    rather than duplicate the functionality? The view technology that we're using
    is also a deciding factor in how we want to decompose our views into smaller reusable
    pieces, since this is easier to do with some frameworks than others. For example,
    we'll see in the next section that ReactJS makes it easy to compose coarse-grained
    views out of smaller more fine-grained views because they're largely self-contained.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Something to be aware of when composing view hierarchies like this—be mindful
    of the data-flow. For example, when a Flux store changes, it emits the change
    event so that the top-level view can render itself. Then it renders its immediate
    children, who render their immediate children, and so on. As the store state flows
    through these views, no data transformations should be happening along the way.
    Put another way, the leaf views in the tree should get the same information as
    the root view.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: User interactivity
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final area of view responsibility we need to think about is user interactivity.
    Apart from passively watching the information on their screens change as the underlying
    stores of our architecture handle actions, they're going to need to do things.
    If nothing else, users need to be able to navigate around the application to use
    the various features we've implemented. To handle this sort of thing, the view
    components that render the UI should also intercept the DOM events as they're
    triggered. This generally results in a new action being dispatched, as we've already
    seen earlier in the book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to remember about these event handlers is that they should have
    essentially one responsibility—calling the right action creator function. What
    these event handlers should avoid is trying to execute any logic—this belongs
    in a store, along with the state that the logic affects. This is so fundamental
    to Flux that it's quite possible I'll repeat it at least twelve more times in
    the book. Once we start introducing logic in places other than stores, we lose
    the ability to reason about the state of something—and the state largely determines
    what the user sees.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's entirely plausible to pass action creator functions directly as event handlers
    to DOM nodes. This could actually help us, because it provides a very low chance
    of logic being introduced in the wrong place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Using ReactJS with Flux
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReactJS is a library for creating view components. In fact, React doesn't even
    label itself as a view library—it's a set of tools for creating components that
    render UI elements. This simple premise is easy to understand and powerful—a perfect
    fit as the view technology in our Flux architecture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at making ReactJS the technology of choice for views
    in our Flux applications, starting with passing state information from stores
    into React components. Next, we'll talk about the composition of views, and how
    Flux state flows from stores to parent views to child views. Lastly, we'll implement
    some event handling capabilities in our views using React mechanisms and a router
    using the `react-router` library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Setting the view state
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to render React components based on the state of our Flux
    stores. These involve two different types of components—statefull and stateless—both
    of which we''ll address here. First, let''s take a look at the store containing
    the state that drives our views:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The idea here is simple—any time an `ADD` action is dispatched, we''re pushing
    the action payload onto the `items` array. Any React components that wish to respond
    to this store state change can do so by listening for the change event. First,
    let''s look at a stateful React component that renders the items list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a typical React component, created using the ES2015 class syntax and
    extending the base React `Component` class. This approach is necessary for stateful
    components. As you can see, the constructor of this component directly interacts
    with a Flux store. When the store changes, it calls `setState()`, which is how
    the component renders to reflect new store state. The constructor also sets the
    initial state by setting the `state` property. Next, we have the `render()` method,
    which returns React elements based on this state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Note that our React component is using JSX syntax to define elements. We're
    not going to cover how this works in this book, nor will we cover other aspects
    of React in any level of detail. This is a book on Flux architecture, and we'll
    cover parts of React that are relevant in a Flux context. If you want more of
    a technical deep dive on React itself, there's plenty of free resources, as well
    as plenty of other books on the subject.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at another implementation of the exact same component, meaning
    the exact same output. This is the stateless approach to React components/views:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wait, what? This is the exact same component, only it doesn''t depend on state.
    This could be a good thing if we''re implementing this as a view component inside
    our Flux architecture. The thing that stands out most about this implementation
    is that there are more comments than code, which is a good thing, allowing us
    to focus on the resulting DOM structure. You''ll notice that there''s no interaction
    with a Flux store in this module. Remember, this is a stateless React component,
    a simple arrow function, which means we don''t have any life cycle methods to
    define, including the initial state. This is okay; let''s see how we use both
    types of components in our `main.js` module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The key difference here is that the `Stateless` view needs to have its interactions
    with the store set up manually here. The stateful component encapsulates this
    by setting up the change listener in the constructor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Is one approach superior to the other? Within a Flux architecture, stateless
    React components tend to have an advantage over their stateful counterparts. This
    is due to the simple fact that they enforce the idea that state belongs in stores,
    nowhere else. When our React components are simple functions, we have no choice
    but to figure out the correct way to transform store state into something that
    can be consumed as simple immutable properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Composing views
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as the state of our application is composed into stores, the views of
    that state are composed hierarchically to a degree. I say to a degree because
    we want to avoid decomposing the structure of our UI at a deep level, as this
    just makes it difficult to grasp. Where view composition really matters is when
    we have smaller parts that are used by many larger components. React is good at
    composing views without introducing too much complexity. In particular, stateless
    views are a good way to keep the vein of unidirectional data flow as it traverses
    the view levels. Let''s look at an example. Here''s a store with some initial
    state, which sorts this state upon a specific action:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, we would expect the array to be *Third*, *Second*, *First* (alphabetically)
    when the `SORT_DESC` action is dispatched. Now, let''s look at the main view component
    that listens to this store:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once again, we have a simple functional view that doesn''t hold on to any state,
    because there''s no need—all state is held in the Flux stores. Rather than use
    an `li` element here, we''re using a custom `Item` React component that we''ve
    implemented for our application. This is part of the larger `App` view, and perhaps
    its part of other larger views. The result is code reuse and simplified aggregate
    views. Let''s look at the `Item` component next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Not the most exciting view in the world, and in practice you''ll find more
    complex atomic views than this. But the idea is the same—the value of `props.children`
    ultimately comes from a Flux store, and it traverses a parent view to get here.
    Let''s see how all the pieces fit together in `main.js`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reacting to events
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React components have their own event system baked into them. They're actually
    a wrapper around the DOM event system, making it easier for us to include event
    handling functions as part of the component JSX markup. This has implications
    for our Flux architecture too, because these events often translate directly to
    action creator function calls.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for React events in a Flux context, let''s build on the previous
    example. We''ll add a button that toggles the sort order of our items. But first,
    we''ll take a look at the store modifications required to support this new behavior:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s a new piece of state in `MyStore`—`direction`. It''s relevant to both
    the sort direction of the items and the text content of the sort button in the
    view. Let''s take a look at the new application view now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that the element returned by this stateless function is a `div`.
    Although not strictly necessary from a markup perspective, it is necessary from
    a `React` component perspective—rendering functions can only return one element.
    The `Sort` element we''ve added above the list represents the sort button. Let''s
    take a look at this component now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This element is a simple `button` HTML element, with a style that will capitalize
    the `direction` label. You can see too that the `onClick` property is used to
    specify the event handler. In this case, it's simple—we're calling the `sort()`
    action creator function directly when the button is clicked.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, other state-handling actions might be dispatched in concert with
    the `SORT` action. For example, a `PRE_SORT` action might be necessary to handle
    button state.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Routing and actions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `react-router` library is the de facto routing solution of ReactJS projects.
    If we're using React component for in the view layer of our Flux architecture,
    then there's a good chance that we'll want to use this package for routing in
    our application. However, there are some subtle nuances to be aware of when using
    `react-router` in the context of Flux. In this final section of the chapter, we'll
    address some of the tradeoffs we need to make with `react-router` by implementing
    it in a Flux architecture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The basic premise of `react-router` is what makes it so attractive in the first
    place. The router and the routes within it are themselves React components that
    we can render into the DOM. We can declare that a given route should render a
    given React component when the route is activated. The router handles all of the
    nitty-gritty details for us. The question is, how does this work within the context
    of a Flux application? As we know, stores are where state lives in our application.
    So this means that they might want to know about the state of the router as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the `main.js` module, where the router component
    is declared and rendered:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can see here that there are three main routes, the default `/` route, followed
    by a `/first` and a `/second` route. Each route has a corresponding component
    that''s rendered when the route becomes active. What''s interesting about these
    route declarations is that the `First` and `Second` components are children of
    `App`. This means that when their routes are activated, they''re actually rendered
    within `App`. Let''s take a look at the `App` component now:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This component renders a list of links that point to our two routes—`first`
    and `second`. It also renders child components through `props.children`. This
    is where the child component is rendered. Let''s turn our attention to the `routeUpdate()`
    action creator function now. This is called by the `Router` component whenever
    the route changes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There''s actually two actions that are dispatched by this function. First,
    there''s the `PRE_ROUTE_UPDATE` action, which is dispatched so that stores have
    an opportunity to prepare for the changed route. Then, we perform some asynchronous
    behavior using `setTimeout()` and then dispatch the `ROUTE_UPDATE` action. Now
    let''s take a look at one of the stores used by our components. We''ll then look
    at one of the views that listens to this store. The stores and views are nearly
    identical, so there''s no need to look at more than one of each:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The store updates its `content` state based on the action type and the current
    route. This is important because other areas of the application might want to
    know that this store is waiting for a route update to complete. Now let''s look
    at the view that listens to this store:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This component is stateful because it has to be. Since it's the router that
    renders the component initially, we can't re-render it other than by setting its
    state. This is how we're able to re-render the component to reflect the state
    of the store—by setting up a handler for the change event. This component also
    has life cycle methods for listening to the change event of the store, as well
    as removing the listener. If we didn't remove it, it would try to set the state
    on a component that isn't mounted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter went into detail on the view layer of Flux architectures. Starting
    with getting information into views, you learned that the change event is fundamental
    in reflecting the state of the store in the view, and that views often read directly
    from stores during their initial render. Then, we went over the idea that views
    are stateless. The state of a given UI element belongs in a store, because other
    parts of the application might depend on this state, and we don't want to have
    to query the DOM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了Flux架构的视图层。从将信息引入视图开始，你了解到变化事件是反映存储在视图中的状态的基本方式，并且视图通常在它们的初始渲染期间直接从存储中读取。然后，我们讨论了视图是无状态的这一观点。给定UI元素的状态属于存储，因为应用程序的其他部分可能依赖于这个状态，我们不希望不得不查询DOM。
- en: Next, we went over some of the high-level responsibilities of view components.
    These include rendering store information, composing larger view structures out
    of smaller view components, and handling user interactivity. We wrapped the chapter
    up with a walkthrough of using ReactJS components as the view technology in a
    Flux architecture. In the following chapter, we'll dig into the life cycle of
    Flux components and how they differ from other architectures.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了视图组件的一些高级职责。这包括渲染存储信息，将较小的视图组件组合成较大的视图结构，以及处理用户交互。我们以使用ReactJS组件作为Flux架构中的视图技术为例，结束了这一章。在下一章中，我们将深入探讨Flux组件的生命周期以及它们与其他架构的不同之处。
