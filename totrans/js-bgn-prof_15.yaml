- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've come very far already! At this point, you should have the building blocks
    of JavaScript down. And you are able to create apps, write clever scripts, and
    read a lot of code. This is a great foundation for some serious next steps. In
    this chapter, we will be taking what you've learned to the next step by practicing
    and figuring out what interests you out of the endless possibilities that JavaScript
    offers.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into too much detail about all the topics here. The details will
    be outdated soon and there is an endless supply of very well-crafted tutorials
    and information on the internet for each one of them. Chances are that by the
    time you are reading this, the frameworks and libraries we are recommending are
    hopelessly old. The good news is that the likelihood that the next big thing will
    use the same concepts is huge.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will serve as a starting point for your next steps with JavaScript.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Libraries and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with libraries and frameworks. Libraries are basically pre-programmed
    JavaScript modules that you can use to speed up your development process. They
    typically do one specific thing for you. Frameworks are very similar, they are
    also pre-programmed, but instead of doing only one thing for you, they arrange
    a whole list of things. This is why it is called a framework, it really is providing
    you a solid place to start from and usually demands a certain structure for your
    files in order to do so. A framework is often a bundle of libraries that provide
    an all-in-one solution. Or at least a many-in-one. You'll eventually even find
    yourself using external libraries on top of the frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: To give a non-code example, if we started building a car, we could do so from
    scratch and make every single piece of this car ourselves. This is pretty much
    what we've been doing in this book so far. With libraries, we get ready-made parts—in
    our car example, we could get fully built chairs that we only would have to install
    onto the car frame we've built. If we used a framework to make a car, we would
    get the skeleton of the car itself, with all the essential parts in it already,
    and it would probably be capable of driving already. We would only need to focus
    on customizing the car and making sure it includes all the special things for
    our wants and needs. While doing that, we would have to keep in mind the skeleton
    of the car we already have and continue in that style.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, we would be done with our car project a lot faster using
    libraries and frameworks. Also, we would run into less trouble using libraries
    and frameworks, since the pre-made parts would have been well tested by many others
    already. If we were to make our own car chairs from scratch, chances are that
    after a year of driving they are no longer comfortable, whereas the standard solution
    has been thoroughly checked already.
  prefs: []
  type: TYPE_NORMAL
- en: So, libraries and frameworks don't just speed up the process, they also provide
    you with a more stable and better-tested solution. Are there no downsides? Well,
    of course there are. The most important one is probably flexibility, as you will
    have to stick to the structure of the framework you are using. To some extent,
    this could also be an advantage because it usually requires a well-structured
    coding style from you, which will improve the code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Another downside is that you'll have to keep on updating your app whenever the
    framework or library you are using is updated. This is very important, especially
    when the updates are fixes to security issues. On the one hand, frameworks and
    libraries are very reliable, but because they're so commonly used, it is not unusual
    for hackers to find weaknesses. If they find one, this will give them opportunities
    on many apps, including your own. On the other hand, your own code is probably
    weaker than an average framework, by a lot.
  prefs: []
  type: TYPE_NORMAL
- en: However, in many cases, hacking your custom app might be too costly. For example,
    when you just have a hobby project online, you are probably not going to pay a
    huge amount of ransom money to hackers and the data in your app also won't be
    worth the hackers' effort. Whereas a script that just tries to exploit a weakness
    of an often-used framework for apps on a random number of websites is common.
    To minimize the risk, update your dependencies often and keep an eye out for reported
    weaknesses by the owner of your library or framework.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, we cannot do anything more with frameworks and libraries than we
    can do without them. That is, if you leave time out of the equation. Frameworks
    and libraries allow us to develop to a higher quality a lot faster, and this is
    why they are so popular.
  prefs: []
  type: TYPE_NORMAL
- en: We will be discussing a few of the most popular libraries here. This is definitely
    not an exclusive list, and it is also very dynamic, so other libraries or frameworks
    might be more popular in a year's time. This is why we are not going to be covering
    full tutorials and how to get started here. We will just explain the basic principles
    and show some code snippets. However, this is still a solid foundation for the
    next big step in your development career.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the libraries can be included in a page by adding a script tag to the
    head of the HTML, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will start by discussing a few common libraries.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**jQuery** is arguably the most famous JavaScript library. It was great to
    use in the past, when it would be compiled into the latest version of JavaScript
    for the specific browser. Nowadays, it is just a different way of writing some
    of the things we have seen in the book. You can recognize jQuery easily by the
    amount of dollar signs in the code. You can also tell if a website is using jQuery
    if you type `$` or `jQuery` into the console of the website, and it returns the
    jQuery object. The jQuery library is mainly focused on selecting HTML elements
    from the DOM and interacting with and manipulating them. It roughly looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dollar sign you indicate that you want to start jQuery, and with the
    selector you can select the element in HTML. The signs here are a bit like CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a simple string value targets an HTML element: `$("p")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A period before a word or phrase indicates you want to select all elements
    with a certain class: `$(".special")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A hashtag targets an element with a certain ID: `$("#unique")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use any other CSS selector, including the more complicated chained
    ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example where the jQuery library is imported in the `script` element
    starting on line 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated with medium confidence](img/B16682_15_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.1: Page with a simple jQuery script'
  prefs: []
  type: TYPE_NORMAL
- en: When you click the **Great idea** button, all the paragraphs will be hidden.
    This is done inside the event that's been added using jQuery. First, we selected
    the button with the ID `hidebutton`, next we call the `click` function on it,
    which specifies what will happen on click. In that function, we state that we'll
    select all `p` elements and hide them. `hide` is a special jQuery function that
    adds the `display:none` style to the HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: So, after clicking, all the paragraphs are gone. When we click on **Found you!**,
    only one comes back, the last one reading **I'm easy to find**. This is because
    when the button with the ID `revealbutton` gets clicked, it selects all elements
    with class `easy` and removes the `display:none` from the style using the jQuery
    `show` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what jQuery really comes down to:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the selectors down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing some extra or differently named functions to manipulate the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use jQuery in your code, but this won't expand your possibilities to
    do more with JavaScript. It will just allow you to do the same thing with fewer
    characters of code. The reason jQuery was so popular is that it added a lot of
    value when browsers were less standardized, in which case using jQuery would actually
    provide the solution to standardizing JavaScript across multiple browsers. This
    is of little use nowadays, and if you are going to write new code, you would be
    better just using JavaScript. However, whenever you are working on older code,
    it is very likely you'll run into jQuery so knowing how it works will definitely
    help you in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can find the jQuery docs here: [https://api.jquery.com/](https://api.jquery.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: D3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**D3** stands for three Ds: **data-driven documents**. It is a JavaScript library
    that helps manipulate documents based on data and it can be used to visualize
    data using HTML, SVG, and CSS. It comes in very handy for dashboards that need
    to contain any sort of data representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make pretty much any kind of graph you could want with a lot of features
    using D3\. It can look rather intimidating, because all the settings for the graph
    figure need to be set. Diving into it and breaking it up in pieces will ensure
    you''ll overcome any hurdles. Below you''ll find a very basic example to add three
    spheres to an SVG using D3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The D3 library gets imported in the first `script` tag. And the `svg` variable
    gets created using the `d3.select` method on the `svg` with ID `drawing-area`.
  prefs: []
  type: TYPE_NORMAL
- en: We are not doing the possibilities of D3 any justice—in this case, this isn't
    a lot more useful than just doing this with a canvas. However, you can make beautiful
    animations of the data, such as a zoom effect, a sortable bar graph, a spin effect
    on a sphere, and so much more. That code would take up multiple pages of the book
    though.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can find the full documentation here: [https://devdocs.io/d3~4/](https://devdocs.io/d3~4/).'
  prefs: []
  type: TYPE_NORMAL
- en: Underscore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underscore is a JavaScript library that can be summarized as a toolkit for functional
    programming. Functional programming can be considered a programming paradigm,
    it revolves around using descriptive functions in a sequence rather than separate
    examples. **Object-oriented programming** (**OOP**) is also a programming paradigm,
    which is all about objects and their state, and the data can be encapsulated and
    hidden from the outside code. In functional programming the functions are very
    important, but there is less state to be concerned about. These functions do the
    same thing with different arguments all the time, and they can be easily chained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are many other functions for filtering, grouping elements, transforming
    elements, getting a random value, getting the current time, and a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: This snippet probably explains the name as well, since we access Underscore
    functions using an underscore. You will have to install Underscore first though,
    else the interpreter won't understand the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can find the full documentation here: [https://devdocs.io/underscore/](https://devdocs.io/underscore/).'
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React is the last frontend library we are going to discuss. If you would rather
    say React is a framework you are not completely wrong, but not right either. The
    reason that we consider React a library is that you'll need to use some other
    libraries to get to the point where it feels like a framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'React is used to build beautiful and dynamic user interfaces. It splits up
    pages into different components and the data gets sent and updated between components
    as it changes. Here is a very basic example that only scratches the very surface
    of what React can do. This HTML will give this sentence on the page: **Hi Emile,
    what''s up?**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It will do this when the following JavaScript is associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will only work when the React library is available. And it will render
    the DOM, replacing the `innerHTML` of the `div` with the first argument of the
    `render` function. We can do this by adding React in a `script` element in the
    header and not installing anything on our system. The completed script looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will write **Hi Emile, what's up?** to the page using React elements created
    manually in the `script` tag. This is not something you should be doing for large
    projects though. It is way more valuable to set up React and everything you need
    using a package manager such as **Node Package Manager** (**NPM**). This will
    allow you to easily manage all the dependencies and keep your code organized.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, more can be found here: [https://reactjs.org/docs/getting-started.html](https://reactjs.org/docs/getting-started.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The frameworks are more complex and usually you'll have to install them on your
    computer. How to do this can be found in the online documentation of the specific
    framework. And whenever you are done coding and you want to run your code, you'll
    have to run a command that will process your code into something the browser will
    understand. We are "serving" the application when we do this.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vue.js is a lightweight JavaScript framework. It can be used to build user
    interfaces and **single-page applications** (**SPAs**). The way user interfaces
    are written with Vue.js can be hard to get your head around the first time you
    encounter it. Have a look at this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple HTML page, importing a JavaScript link from Vue. There is
    something weird going on in the HTML of the `<p>` tag: there is a `v-if` element.
    This element will only be displayed when the condition in that `v-if` is true.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is looking at the `hide` property of our data object in our
    Vue instance. If you change the value of this `hide` to `true`, the negated `hide`
    statement will become `false`, and the element will disappear. This is something
    that we could have done without Vue as well, but we would then have specified
    a JavaScript event for the change of the value and used JavaScript to edit the
    CSS to hide the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even see HTML elements that are new to you. That is because these are
    not regular HTML elements, but rather from Vue, which lets you define your own
    elements. You can run into HTML that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And when you open the webpage associated with it, it shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a new Vue component is created, and it can actually hold
    data and have a function too, but this one is very basic and just to illustrate
    we can add HTML templates in the `template` property. There is a paragraph specified.
    When the webpage gets loaded, the `<maaike>` component will be replaced with whatever
    is in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The content of one page can come from many files. Usually these components all
    have their own file. There is a lot more official Vue tooling that you will get
    to know once you dive into Vue.js. It is actually a great framework for beginners
    with frameworks, as it is rather clear what is going on and is a great starting
    point for comprehending frameworks in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can find the full Vue docs here: [https://v3.vuejs.org/guide/introduction.html](https://v3.vuejs.org/guide/introduction.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular is a framework that originates from and is (currently) maintained by
    Google. Angular is a lot heavier than Vue.js, but it can be considered a complete
    package. This means that Angular takes up more disk space, and more disk space
    usually means it is slower to compile and install. Looking at Angular code isn't
    really that much different from Vue.js. However, Angular uses TypeScript instead
    of JavaScript. TypeScript is a superset of JavaScript and gets transpiled to JavaScript,
    but it is stricter and has a different syntax as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular can be recognized by the `ng` attributes in the HTML. We are not going
    to show a full example, but here is the HTML that will show all the tasks on a
    to-do list (when the code around it is set correctly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `ng-repeat` attribute is specifying the repeat action that for every task
    on the task list, it should create a `<li>` element. And `task` can be used as
    a variable inside `<li>` as well, as indicated by `{{ task }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more Angular-specific thing going on, `ng-click`, which tells
    Angular what to do when an element gets clicked. This is similar to the `onclick`
    event of JavaScript, but it can now be dynamically binded. This means that when
    writing the code, you don''t need to know about `onclick` yet. Clearly, you can
    achieve the same thing in JavaScript by specifying events that will lead to changes
    of the `onclick` attribute (and the complete element if necessary), but this is
    a lot more code that needs to be written. This goes for anything in Angular: it
    can be done with just JavaScript but it is a lot more work (and that might actually
    be an understatement, depending on the complexity of the situation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, you can find the full docs here: [https://angular.io/docs](https://angular.io/docs).'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to work with libraries and frameworks such as React, Angular, or Vue
    is a very logical and even must-have next step if you seek to be a frontend developer.
    In the authors' view, the difficulty of these options doesn't really differ that
    much. Which one is the best choice depends on the place you want to work and the
    region that you are in, because there are regional preferences for these frameworks
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only been dealing with the frontend. The frontend is the part
    that is running on the client side, which could be any device that the user is
    using, such as a phone, laptop, or tablet. In order for websites to do interesting
    stuff, we also need a backend. For example, if you want to log on to a website,
    this website somehow needs to know whether this user exists.
  prefs: []
  type: TYPE_NORMAL
- en: This is the job of the server-side code, the backend. This is code that is running
    not on the device of the user, but on some sort of server elsewhere, which is
    often owned or leased by the company hosting the website. Hosting the website
    usually means that they make it available to the world wide web by placing it
    on a server that can take outside requests via a URL.
  prefs: []
  type: TYPE_NORMAL
- en: The code on the server does many things, all related to deeper logic and data.
    For example, an e-commerce store has a bunch of items in the shop that come from
    a database. The server gets the items from the database, parsing the HTML template
    and sending the HTML, CSS, and JavaScript over to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for logging in: when you enter your username and password on
    a website and you click on login, the code on the server gets triggered. This
    code is going to verify the details you entered with those in the database. If
    you have the correct details, it will send you back the page of your portal for
    logged-in users. And if you have entered incorrect details, it will send back
    the error to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the basics of communication between the frontend
    and backend, and we will show you how you can use JavaScript to write backend
    code as well using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **API** (**Application Programming Interface**) is essentially an interface
    for code, written with more code. A request can be made to an API using (for example)
    a URL. This will trigger a certain piece of code and this piece of code will give
    a certain response back.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all very abstract, so let''s use an example. If we had a website for
    a hotel, it would make sense for people to be able to make bookings online. This
    would require us to have some sort of API. Whenever a user has filled out all
    the fields and clicks on **Submit booking**, the API will get triggered by calling
    the URL and sending all the data that the user has entered to that endpoint (a
    specific URL), for example: `www.api.hotelname.com/rooms/book`. This API will
    process and validate our data and when everything is fine, it will store the room
    booking in our database and probably send a confirmation mail to our guest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever one of the hotel clerks goes to check out the reservations, another
    API call will be made using one of the endpoints. It could be an endpoint that
    looks like this for example: `www.api.hotelname.com/reservations`. This would
    first go ahead and check whether our employee is logged in with the right role,
    and if so, it will fetch all the reservations for the selected date range from
    the database and send the page with the results back to our employee, who can
    then see all the bookings. So APIs are the connection points between the logic,
    database, and frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: 'APIs work with **Hypertext Transfer Protocol** (**HTTP**) calls. HTTP is just
    a protocol for communication between two parties: a client and a server, or a
    server and another server (in which the requesting server acts like the client).
    This means that it has to stick to certain conventions and rules that the other
    party expects, and the other party will respond in a certain way. For example,
    this means using a specific format to specify headers, using GET methods for getting
    information, using POST methods for creating new information on the server, and
    using PUT methods to change information on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: There can be more done with APIs, for example, your computer and printer communicate
    via an API as well. However, this is not too relevant from a JavaScript point
    of view.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how to consume these APIs in the *AJAX* section. You can also write
    your own APIs, and the ultimate basics of how to do this can be found in the *Node.js*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AJAX** stands for **Asynchronous JavaScript and XML**, which is a misnomer,
    because nowadays it is more common to use JSON instead of XML. We use it to make
    calls from the frontend to the backend, without refreshing the page (asynchronously).
    AJAX is not a programming language or a library, it is a combination of the built-in
    `XMLHttpRequest` object in the browser and the JavaScript language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably won''t be using plain AJAX in your day-to-day life as a frontend
    developer nowadays, but it is being used beneath the surface so it won''t hurt
    to know how it works. Here is an example of calling the backend using AJAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is not a working example, because there is no valid URL, but it demonstrates
    how AJAX works. It sets up what it needs to do when the request has been loaded,
    in this case, replacing the HTML inside the element with ID `content` with whatever
    the link returns. This could be a link to a file, or to some API that calls a
    database. It can give different responses when there is other (or no) data in
    the database. This response is in JSON, but it could also be in XML. This depends
    on how the server was coded.
  prefs: []
  type: TYPE_NORMAL
- en: 'More common now is the use of the **Fetch API** for AJAX requests. This is
    similar to what we can do with `XMLHttpRequest` but it provides a more flexible
    and powerful set of features. For example, in the following code we get the data
    from the URL, convert it to JSON with the `json()` method, and output it to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Fetch API works with promises, which should look familiar at this point.
    So after the promise is resolved, a new one gets created with `then`, and when
    that one is resolved, the next `then` gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, more information can be found here: [https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started).'
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 15.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a JSON file and using `fetch`, return the results as a usable object
    into your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JSON object and save it in a file called `list.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using JavaScript, assign the filename and path to a variable named `url`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `fetch`, make the request to the file URL. Return the results as JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the response object is ready, iterate through the data and output the results
    into the console of each item in the JSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write APIs in JavaScript using Node.js. Node.js is a very clever runtime
    environment that has taken the Google JavaScript engine, expanded it, and made
    it possible to run JavaScript on servers, interacting with the filesystem protocol
    and HTTP using JavaScript. Because of this, we can use JavaScript for the backend.
    This means that you can write both the backend and the frontend with only one
    language (along with HTML and CSS). Without Node.js, you would have to use another
    language such as PHP, Java, or C# for the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run Node.js, you first have to set it up and then run the `node
    nameOfFile.js` command. You can find out how to set it up on your system in the
    official Node.js documentation. Often it requires downloading and installing something,
    and then you are done.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the download instructions are accessible at [https://nodejs.org/en/download/](https://nodejs.org/en/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of some code that will receive HTTP calls that can be written
    for Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the `http` module. This is an external code file that
    needs to be imported in order to run. The `http` module comes with Node.js, but
    other modules might need to be installed. You will use a package manager for this,
    such as NPM, which will help to install all the dependencies and be able to manage
    all the different versions of the external modules.
  prefs: []
  type: TYPE_NORMAL
- en: The code above sets up a server that is listening to port `8080`, and whenever
    it gets accessed, it will return `Finally, hello Rob`. We create the server with
    the `createServer` method on the imported `http` module. We then say what needs
    to happen for a call to our server. We respond with a 200 status (indicating "OK")
    and write `Finally, hello Rob` to the response. We then specify the default port
    `8080` as the listening port.
  prefs: []
  type: TYPE_NORMAL
- en: This example uses the built-in `http` module for Node.js, which is very powerful
    for creating APIs. This is definitely something that's worth having some experience
    with. Being able to write your own APIs will enable you to write full applications
    yourself. This gets even easier when we add Express to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Express Node.js framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Node.js is not a framework, nor a library. It is a runtime environment. This
    means that it can run and interpret the JavaScript code written. There are frameworks
    for Node.js and currently Express is the most popular one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very basic Express application—again, you will have to set up Node.js
    first, then add the Express module (if you are using NPM, `npm install express`
    will do) and run it using the `node nameOfRootFile.js` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After running this and going to `localhost:3000` (assuming you are running it
    on localhost), you will get the message **Hello Express!** in your browser. In
    the terminal where you are running your `Node` app, it will print the console
    log message after loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more in the Node.js documentation, which at the time of writing
    is at the following address: [https://nodejs.org/en/docs/](https://nodejs.org/en/docs/).'
  prefs: []
  type: TYPE_NORMAL
- en: For the Express module, you can go to [https://expressjs.com/en/5x/api.html](https://expressjs.com/en/5x/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned a lot about JavaScript in this book and with this chapter you
    should have an idea of possible next steps you can take. This chapter hasn't taught
    you all of these topics in depth, as entire books could be (and have been) written
    about each of them, but you should have a good idea of where to look for your
    next steps and what to consider while deciding which next step to take.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn is by doing. So we highly recommend you just come up with
    a fun project idea and go ahead and try to make it. Alternatively, with this knowledge,
    you may feel ready for an entry-level JavaScript position! You can also do tutorials
    online or even work in a project team as a junior, using freelance platforms such
    as Upwork or Fiverr to get a project. These are hard to find though, and we can
    imagine that you'll learn a framework or get a bit more experience with Node.js
    first. However, this is often possible on the job if you can show your skills
    and potential in the hiring process.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a JSON file locally, connect to the JSON and data, and output the data
    from the JSON file into your console:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file with the extension JSON name it `people.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `people.json` create an array that contains multiple objects. Each item
    in the array should be an object that has the same structure, using `first`, `last`,
    and `topic` as the property names. Make sure you use double quotes around the
    property names and values as this is the proper JSON syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three or more entries into the array using the same object structure for
    each item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an HTML file and add a JavaScript file. Within the JavaScript file use
    `people.json` as the URL. Using `fetch` connect to the URL and retrieve the data.
    Since this is a JSON-formatted file, once you get the response data it can be
    formatted into JSON using the `.json()` method in `fetch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the full contents of the data into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `foreach`, loop through the items in the data and output the values into
    the console. You can use a template literal and output each value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List-making project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a list that saves to local storage so even if the page is refreshed,
    the data will persist within the browser. If the local storage is empty on the
    first load of the page, set up a JSON file that will be loaded to the local storage
    and saved as a default list to start the list:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an HTML file, adding a `div` to output the list results to, and an input
    field with a button that can be clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using JavaScript, add the page elements as objects that can be used within the
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your default JSON file (which can be empty) and add the path to the file
    into your JavaScript code using a variable called `url`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the button element that will run a function called
    `addToList()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `addToList()`, check if the value of the input field has a length of 3 or
    more. If it does then create an object with a name and the value of the input
    field. Create a global variable named `myList` to hold the list, and within `addToList()`
    push the new object data into `myList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function called `maker()`, which will create the page element and add
    text into the element, appending it to the output element. Invoke `maker()` to
    add the new item within the `addToList()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, save the item to local storage so that the visual content of `myList`
    will be synced with the local storage saved value. To do this, create a function
    called `savetoStorage()` and invoke it every time you update the `myList` in the
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `savetoStorage()` function, set the value of `myList` into `localStorage`
    using `setItem`. You will need to convert `myList` into a string value to save
    it into `localStorage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add to the code `getItem()` to retrieve a value of `myList` from `localStorage`.
    Set up a global variable for the `myList` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to listen for `DOMContentLoaded`. Within that function,
    check if the localstorage loaded a value. If it did then get `myList` from local
    storage and convert it from a string to a JavaScript object. Clear the output
    element contents. Loop through the items in `myList` and add them to the page
    with the `maker()` function created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `localStorage` does not have content, load the JSON file with the default
    values using `fetch`. Once the data is loaded, assign it to the global `myList`
    value. Loop through the items in `myList` and using `maker()`, output them to
    the page. Don't forget to invoke `savetoStorage()` after so that the storage will
    contain the same list items as are visible on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are JavaScript libraries and frameworks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell if a webpage is using the jQuery library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which library contains a lot of functionality for manipulating data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When Node.js is installed, how can you run a Node.js file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored a few of the possibilities to continue your
    JavaScript journey and keep on improving yourself. We started off by discussing
    the frontend and what libraries and frameworks are. Libraries and frameworks are
    both pre-made code that you can use in your project, but libraries typically solve
    one problem while frameworks provide a standard solution that usually controls
    the way you structure your application and will come with some limitations. On
    the other hand, frameworks are great fits for very many things you might want
    to do with your web apps.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to looking at the backend. The backend is the code that runs
    on the server and we can write this code in JavaScript when we use Node.js. Node.js
    is a runtime engine that can process JavaScript and has some additional features
    for JavaScript that we don't have when using JavaScript in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that''s it. You have a very solid understanding of JavaScript at this point.
    You have seen all the major building blocks, and had a lot of practice with smaller
    exercises and bigger projects. There are a few things for certain: you''ll never
    be done with learning as a JavaScript programmer, and you will keep on amazing
    yourself with the things you can make as you keep on progressing.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to have fun!
  prefs: []
  type: TYPE_NORMAL
