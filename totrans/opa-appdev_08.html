<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Internationalization</h1></div></div></div><p>In this chapter, we will talk about <strong>internationalization</strong> (<strong>i18n</strong>)<a id="id278" class="indexterm"/>. It is abbreviated as i18n because there are 18 letters between the initial <em>i</em> and the final <em>n</em>. Opa now provides two approaches for i18n: the internal approach and the external approach. To utilize <a id="id279" class="indexterm"/>the internal approach, we include translation functions directly inside our Opa code. If, however, we wish to separate the translation from our main code, then we can do so by using the external approach. To make it clear, we will discuss a very simple application that displays the word "hello" in three different languages: English, French, and Chinese.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Internal approach</h1></div></div></div><p>Opa now<a id="id280" class="indexterm"/> provides support for translation by means of the <code class="literal">@i18n</code> directive<a id="id281" class="indexterm"/>. We can put a translation function <a id="id282" class="indexterm"/>inside the <code class="literal">@i18n</code> directive, and it will be replaced by a proper value according to different languages. An example is worth a thousand words, so let's get started with a simple example:</p><div><pre class="programlisting">import stdlib.web.client
hello = function {
  case "en": "Hello"
  case "fr": "Bonjour"
  case "zh": "你好"
  default: "Hi"
}
function page(){
  &lt;h1&gt; {@i18n(hello)} &lt;/h1&gt;
  &lt;input type="button" value="English" onclick={set_lang("en")}/&gt;
  &lt;input type="button" value="French"  onclick={set_lang("fr")}/&gt;
  &lt;input type="button" value="Chinese" onclick={set_lang("zh")}/&gt;
}
function set_lang(lang)(_){
  I18n.set_lang(lang)
  Client.reload()
}
Server.start(Server.http, {title:"Opa Packt", ~page})</pre></div><p>Save this<a id="id283" class="indexterm"/> code into a file, <code class="literal">801.opa</code>, then compile and run it with the following command:</p><div><pre class="programlisting">
<strong>opa 801.opa --</strong>
</pre></div><p>The result looks as shown in the following screenshot:</p><div><img src="img/3749OS_08_01.jpg" alt="Internal approach"/></div><p>The page shows <strong>Hello</strong> in three different languages: English, French, and Chinese, and we can change the language by clicking on the language buttons.</p><p>As we can<a id="id284" class="indexterm"/> see from the code, we internationalize the page by enclosing a translation function, <code class="literal">hello</code>, in the <code class="literal">@i18n</code> directive—<code class="literal">@i18n(hello)</code>.</p><p>The function <code class="literal">hello</code> maps from the language code (for example, "<code class="literal">en</code>", "<code class="literal">fr</code>", and "<code class="literal">zh</code>", of the type <code class="literal">I18n.language</code>) to a string. Note that the function <code class="literal">hello</code> is written in a convenient way, in that <code class="literal">…</code>. This notation is permitted if the initial lines of code in a function consist of matching its parameter against some values, as we do in the <code class="literal">hello</code> function. The corresponding long notation would be:</p><div><pre class="programlisting">hello = function(lang){
  match(lang){
    case "en": "Hello"
    ...
  }
}</pre></div><p>Also note that the return type of a translation function is not restricted to the type <code class="literal">String</code>; an XHTML fragment can also be returned from the function:</p><div><pre class="programlisting">hello = function{
  case "en": &lt;font color="red"&gt; Hello &lt;/font&gt;
  case "fr": &lt;font color="blue"&gt; Bonjour &lt;/font&gt;
  case "zh": &lt;font color="green"&gt; 你好 &lt;/font&gt;
  default:   &lt;font color="yellow"&gt; Hi &lt;/font&gt;
}</pre></div><p>Now that <a id="id285" class="indexterm"/>we have reviewed how to write a translation function, we now need to clarify how users control the language of the website they are seeing. The module <code class="literal">I18n</code>, the internationalization module, contains the answer. The <code class="literal">I18n.lang()</code> function returns the currently selected language. Note that this is not the language of the browser, it is the language that the user selected. We can change the selected language programmatically by invoking the function <code class="literal">I18n.set_lang(lang)</code>. This is just what we did after clicking on the three language buttons <strong>English</strong>, <strong>French</strong>, and <strong>Chinese</strong> in the example we just saw. This function allows us to change the language for a specific client. The language our program defines is then stored in a cookie. Since the changes our program makes will only take effect during the next page request, to make them effective right away our program must refresh the page by calling the function <code class="literal">Client.reload</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>External approach</h1></div></div></div><p>The internal approach<a id="id286" class="indexterm"/> suffers from one important problem,<a id="id287" class="indexterm"/> that is, it mixes the source code and the translations. The remedy for this problem is the external approach. Using it, we can separate the program code and the translations.</p><p>To use external translations, we use the same <code class="literal">@i18n</code> directive, but we provide it with a key string instead of a function. Thus, <code class="literal">@i18n(hello)</code> can be replaced by:</p><div><pre class="programlisting">@i18n("hello")</pre></div><p>Here is an example of an external approach:</p><div><pre class="programlisting">//802.opa
function page(){
  &lt;div onready={function(_) { I18n.set_lang("fr") }}&gt;
    &lt;h1&gt;{@i18n("hello")}&lt;/h1&gt;
  &lt;/div&gt;
}
Server.start(Server.http, {title:"Opa Packt", ~page})</pre></div><p>Save the file as <code class="literal">802.opa</code>. If we do not provide any translation, <code class="literal">@i18n("hello")</code> will be replaced by <a id="id288" class="indexterm"/>the string <code class="literal">"hello"</code>. How do we add the translation? The solution is to compile our source code with the translation switch <code class="literal">--i18n-template-opa</code>:</p><div><pre class="programlisting">opa 802.opa --i18n-template-opa --i18n-pkg trans --i18n-dir langs</pre></div><p>Make a directory named <code class="literal">langs</code> and execute this line. This will create a file named <code class="literal">trans.opa</code> in the <code class="literal">langs</code> directory. The option <code class="literal">--i18n-pkg</code> specifies the package name of the translation code. If it is not provided, the default name will be <code class="literal">linking.translation</code>. The option <code class="literal">--i18n-dir</code> specifies the directory of translation code. If it is not provided, the current directory will be used. The content of <code class="literal">trans.opa</code> looks as follows:</p><div><pre class="programlisting">package trans
import stdlib.core.i18n

// Template for 801.opa
// "hello"
// string, 15
__i18n_5d41402abc4b2a76b9719d911017c592()= match I18n.lang()
  _   -&gt; "hello"</pre></div><p>The file <a id="id289" class="indexterm"/>contains all the messages that require translation in all the source code files of a given package. The long sequence <code class="literal">5d41402abc4b2a76b9719d911017c592</code> is an automatically generated identifier.</p><p>Next, we must edit the translation file that Opa generated, adding our translation messages to the file. In our example case, for instance, we could add the following translation instructions:</p><div><pre class="programlisting">package trans
import stdlib.core.i18n
// Template for 801.opa
// "hello"
// string, 15
__i18n_5d41402abc4b2a76b9719d911017c592()= match I18n.lang()
 "en" -&gt; "Hello"
 "fr" -&gt; "Bonjour"
 "zh" -&gt; "你好"
  _   -&gt; "hello"</pre></div><p>The translation file is a normal Opa file, and its contents can be intuitively comprehended. Such a notation is called classic syntax. We must tell the compiler that we are utilizing classic Opa source code when we compile the translation:</p><div><pre class="programlisting">
<strong>opa --parser classic langs/trans.opa</strong>
</pre></div><p>And finally, compile our source code with the translation:</p><div><pre class="programlisting">
<strong>opa 801.opa --i18n-dir langs --i18n-pkg trans</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we discussed how to internationalize a web page in Opa. We can either use the internal approach of writing a translate function in our code, or the external approach of utilizing an external file that is translated separately from our code.</p></div></body></html>