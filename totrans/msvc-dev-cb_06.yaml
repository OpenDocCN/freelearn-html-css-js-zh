- en: Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Authenticating your microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证您的微服务
- en: Securing containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护容器
- en: Secure configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全配置
- en: Secure logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全日志
- en: Infrastructure as Code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As with many of the topics covered in this book, security in a microservice
    architecture is about trade-offs. In a microservice architecture, individual code
    bases have limited responsibilities. If an attacker is able to compromise a single
    running service, they will only be able to perform actions that are governed by
    that particular microservice. The distributed nature of a microservice architecture,
    however, means that there are more targets for an attacker to potentially exploit
    in services running in separate clusters. The network traffic between those clusters,
    including traffic between edge services and internal services, presents many opportunities
    for an attacker to discover vulnerabilities.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中涵盖的许多主题一样，微服务架构中的安全性是关于权衡的。在微服务架构中，单个代码库的责任有限。如果攻击者能够破坏单个运行的服务，他们只能执行由该特定微服务管理的操作。然而，微服务架构的分布式特性意味着攻击者有更多的目标可以在运行在不同集群中的服务中进行潜在利用。这些集群之间的网络流量，包括边缘服务和内部服务之间的流量，为攻击者提供了许多发现漏洞的机会。
- en: Because of the distributed nature of microservice architectures, network topology
    must be considered when configuring how services are able to communicate with
    one another. This concern exists in monolithic code bases as well, where a running
    instance of a single code base needs to communicate over the network with database
    servers, caches, load balancers, and so on. It could be argued that microservice
    architectures make these challenges more obvious and therefore force engineers
    to consider them earlier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务架构的分布式特性，在配置服务如何相互通信时必须考虑网络拓扑。这种关注也存在于单体代码库中，其中单个代码库的运行实例需要通过网络与数据库服务器、缓存、负载均衡器等进行通信。可以认为微服务架构使这些挑战更加明显，因此迫使工程师更早地考虑这些问题。
- en: Security is a big topic. This chapter will discuss a number of good practices
    to consider when building, deploying, and operating microservices, but it's important
    to note that this is not an exhaustive list of considerations. Good API practices
    and defense in depth should be considered when developing any system and microservices
    are no exception. I heartily recommend **OWASP** ([https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page))
    as a resource for learning more about web application security.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个大话题。本章将讨论在构建、部署和运营微服务时需要考虑的一些良好实践，但重要的是要注意，这并不是一个详尽的考虑清单。在开发任何系统时，都应考虑良好的API实践和深度防御，微服务也不例外。我强烈推荐**OWASP**
    ([https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page))
    作为学习更多关于Web应用安全资源的参考。
- en: Authenticating your microservices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的微服务
- en: 'In [Chapter 1](d5b36f18-79eb-4c0a-bbde-3e94733ef97c.xhtml), *Breaking the Monolith*,
    we introduced a Ruby on Rails code base that powers our fictional image-sharing
    application, `pichat`. The Rails code base authenticates each request by inspecting
    the Authorization header. If the header is present, the application attempts to
    decode it using a shared secret read from an environment variable (see the *Secure* c*onfiguration*
    recipe). If the token provided in the Authorization header is valid, the decoded
    value contains contextual information about the user, including the user ID. That
    information is then used to retrieve the user from the database so that the application
    has context on the user making the request. If the Authorization header is missing
    or cannot be decoded successfully, the application raises an exception and returns
    an HTTP 401 to the caller, including an error message. In order to obtain a token
    to include in the Authorization header, a client application can send a `POST`
    request to the `/auth/login` endpoint with valid user credentials. The following
    CURL commands demonstrate this flow:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d5b36f18-79eb-4c0a-bbde-3e94733ef97c.xhtml)，*打破单体*，我们介绍了一个Ruby on Rails代码库，它为我们的虚构图片分享应用`pichat`提供动力。Rails代码库通过检查授权头来验证每个请求。如果存在头信息，应用程序将尝试使用从环境变量中读取的共享密钥对其进行解码（参见*安全*配置菜谱）。如果授权头中提供的令牌有效，解码的值包含有关用户的环境信息，包括用户ID。然后使用这些信息从数据库中检索用户，以便应用程序对发出请求的用户有上下文。如果授权头缺失或无法成功解码，应用程序将引发异常，并向调用者返回HTTP
    401，包括错误信息。为了获取要包含在授权头中的令牌，客户端应用程序可以向`/auth/login`端点发送带有有效用户凭据的`POST`请求。以下CURL命令演示了此流程：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have a token, we can include it in the headers of subsequent requests:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了令牌，我们可以将其包含在后续请求的头部中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because `pichat-api` is a monolithic code base, it is playing many different
    roles to support this flow. It is acting as an Authorization service, an Authentication
    gateway, a user store, and an Authorization client. This kind of coupling of responsibilities
    is exactly what we want to avoid in a microservice architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pichat-api`是一个单体代码库，它正在扮演许多不同的角色以支持此流程。它正在充当授权服务、认证网关、用户存储和授权客户端。这种责任的耦合正是我们希望在微服务架构中避免的。
- en: 'Luckily, it''s easy to divide these responsibilities into separate code bases
    while keeping the flow the same. Encoding information in **JSON Web Tokens** (**JWT**)
    using a shared secret allows individual microservices to securely authenticate
    requests without having to make requests to a centralized authentication service
    for each request. Obtaining an authentication token can be the responsibility
    of a centralized service, but this fact can be made transparent to the client
    using an API Gateway or a backend for a frontend. The following diagram demonstrates
    how some of the responsibilities will be divided:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在保持流程不变的同时，很容易将这些责任分割到单独的代码库中。使用共享密钥在**JSON Web Tokens**（**JWT**）中编码信息允许单个微服务在不需要对每个请求都向集中式认证服务发出请求的情况下安全地验证请求。获取认证令牌可以是集中式服务的责任，但可以使用API网关或前端的后端使这一事实对客户端透明。以下图表演示了某些责任将如何分割：
- en: '![](img/995d3ee1-7c63-4015-85ea-eafd43997426.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/995d3ee1-7c63-4015-85ea-eafd43997426.png)'
- en: We will create an **Authentication Service** that handles user registration
    and exchanges credentials for a JWT. We will then create a simple **API Gateway**
    using the Zuul open source project that we covered in [Chapter 2](ab796ed6-2bb5-4fc1-b6db-6283ab5c54b4.xhtml),
    *Edge Services*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个**认证服务**来处理用户注册并交换JWT凭证。然后我们将使用我们在[第2章](ab796ed6-2bb5-4fc1-b6db-6283ab5c54b4.xhtml)，*边缘服务*中介绍的Zuul开源项目创建一个简单的**API网关**。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s have a look at the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Let''s create the authentication service. Create a new Java project with the
    following `build.gradle` file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个认证服务。使用以下`build.gradle`文件创建一个新的Java项目：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We'll be storing user credentials in a MySQL database, so we declare `mysql-connector-java`
    as a dependency. We'll also use an open source JWT library called `jjwt`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在MySQL数据库中存储用户凭证，因此我们声明`mysql-connector-java`作为依赖项。我们还将使用一个名为`jjwt`的开源JWT库。
- en: 'Storing user credentials is an important topic. User passwords should never
    be stored in plain text and many hashing algorithms, such as MD5 and SHA1, have
    been shown to be vulnerable to various brute force attacks. In this example, we''ll
    be using `bcrypt`. In a real-world usage, we''d consider multiple hashing steps,
    such as hashing with SHA512 first and then running through `bcrypt`. We''d also
    consider adding a per-user salt. The **Open Web Application Security Project**
    has a lot of great recommendations for storing passwords: [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存储用户凭据是一个重要的话题。用户密码绝不应该以纯文本形式存储，许多散列算法，如 MD5 和 SHA1，已被证明容易受到各种暴力攻击。在这个例子中，我们将使用
    `bcrypt`。在实际应用中，我们会考虑多个散列步骤，例如首先使用 SHA512 散列，然后通过 `bcrypt`。我们还会考虑为每个用户添加一个盐。**开放网络应用安全项目**有很多关于存储密码的优秀建议：[https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet)。
- en: 'Create a new class called `Application`. It will contain our main method as
    well as `PasswordEncoder`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Application` 的新类。它将包含我们的主方法以及 `PasswordEncoder`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll model the user credentials as a simple POJO with `email` and `password`
    fields. Create a new package called `com.packtpub.microservices.ch06.auth.models`
    and a new class called `UserCredential`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用户凭据建模为一个简单的 POJO，包含 `email` 和 `password` 字段。创建一个名为 `com.packtpub.microservices.ch06.auth.models`
    的新包和一个名为 `UserCredential` 的新类：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a model to represent the response to successful login and registration
    requests. Successful responses will contain a JSON document containing a JWT.
    Create a new class called `AuthenticationToken`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模型来表示对成功登录和注册请求的响应。成功的响应将包含一个包含 JWT 的 JSON 文档。创建一个名为 `AuthenticationToken`
    的新类：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `UserCredential` class will be accessed using the Java Persistence API.
    To do this, we have to first create `CrudRepository`. Create a new package called
    `com.packtpub.microservices.ch06.auth.data` and a new class called `UserCredentialRepository`.
    In addition to inheriting from `CrudRepository`, we''ll define a single method
    used to retrieve a `UserCredential` instance by email:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserCredential` 类将通过 Java 持久化 API 访问。为此，我们必须首先创建 `CrudRepository`。创建一个名为 `com.packtpub.microservices.ch06.auth.data`
    的新包和一个名为 `UserCredentialRepository` 的新类。除了继承自 `CrudRepository`，我们还将定义一个用于通过电子邮件检索
    `UserCredential` 实例的单个方法：'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When a user attempts to register or log in with invalid credentials, we want
    to return an HTTP 401 status code as well as a message indicating that they provided
    invalid credentials. In order to do this, we''ll create a single exception that
    will be thrown in our controller methods:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户尝试使用无效凭据注册或登录时，我们希望返回 HTTP 401 状态码以及一条消息，指出他们提供了无效凭据。为了做到这一点，我们将在我们的控制器方法中创建一个单独的异常：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the controller. The login and registration endpoints will be served
    from a single controller. The registration method will simply validate input and
    create a new `UserCredential` instance, persisting it using the `CrudRepository` package
    we created earlier. It will then encode a JWT with the user ID of the newly registered
    user as the subject. The login method will verify the provided credentials and
    provide a JWT with the user ID as its subject. The controller will need access
    to `UserCredentialRepository` and `PasswordEncoder` defined in the main class.
    Create a new package called `com.packtpub.microservices.ch06.auth.controllers`
    and a new class called `UserCredentialController`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建控制器。登录和注册端点将由单个控制器提供服务。注册方法将简单地验证输入并创建一个新的 `UserCredential` 实例，使用我们之前创建的 `CrudRepository`
    包持久化它。然后，它将使用新注册用户的用户 ID 作为主题编码 JWT。登录方法将验证提供的凭据并提供一个以用户 ID 作为主题的 JWT。控制器需要访问在主类中定义的
    `UserCredentialRepository` 和 `PasswordEncoder`。创建一个名为 `com.packtpub.microservices.ch06.auth.controllers`
    的新包和一个名为 `UserCredentialController` 的新类：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because we are connecting to a local database, and because we use a shared
    secret when signing JWTs, we need to create a small properties file. Create a
    file called `application.yml` in the `src/main/resources` directory:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在连接到本地数据库，并且我们在签名 JWT 时使用共享密钥，因此我们需要创建一个小的属性文件。在 `src/main/resources` 目录下创建一个名为
    `application.yml` 的文件：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have a functioning authentication service, the next step is to create
    a simple API Gateway using the open source gateway service, Zuul. In addition
    to routing requests to downstream services, the API Gateway will also use an authentication
    filter to verify that valid JWTs are passed in headers for requests that require
    authentication.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的认证服务，下一步是创建一个简单的API网关，使用开源网关服务Zuul。除了将请求路由到下游服务外，API网关还将使用认证过滤器来验证需要认证的请求中是否传递了有效的JWT。
- en: 'Create a new Java project with the following `build.gradle` file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下`build.gradle`文件的Java项目：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we're using the same JWT library as the Authentication service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用与认证服务相同的JWT库。
- en: 'Create a new package called `com.packtpub.microservices.ch06.gateway` and a
    new class called `Application`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`com.packtpub.microservices.ch06.gateway`的新包和一个名为`Application`的新类：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll create an authentication filter by creating a subclass of `OncePerRequestFilter`,
    which aims to provide a single execution per request dispatch. The filter will
    parse the JWT out of the Authorization header and try to decode it using a shared
    secret. If the JWT can be verified and decoded, we can be sure that it was encoded
    by an issuer that had access to the shared secret. We''ll treat this as our trust
    boundary; anyone with access to the shared secret can be trusted, and therefore
    we can trust that the subject of the JWT is the ID of the authenticated user.
    Create a new class called `AuthenticationFilter`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过创建`OncePerRequestFilter`的子类来创建一个认证过滤器，该过滤器旨在为每个请求调度提供单次执行。该过滤器将解析`Authorization`头中的JWT，并尝试使用共享密钥对其进行解码。如果JWT可以被验证和解码，我们可以确信它是由有权访问共享密钥的发行者编码的。我们将此视为我们的信任边界；任何有权访问共享密钥的人都可以被信任，因此我们可以信任JWT的主题是认证用户的ID。创建一个名为`AuthenticationFilter`的新类：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Wire this together with a security configuration for the API Gateway project.
    Create a new class called `SecurityConfig`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此与API网关项目的安全配置一起连接起来。创建一个名为`SecurityConfig`的新类：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, we're permitting any requests to the authentication service (requests
    prefixed with `/auth/...`). We require that requests to the users or messages
    service be authenticated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们允许对认证服务（以`/auth/...`为前缀的请求）的任何请求。我们要求对用户或消息服务的请求进行认证。
- en: 'We need a configuration file to store the shared secret as well as the routing
    information for the Zuul server. Create a file called `application.yml` in the
    `src/main/resources` directory:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个配置文件来存储共享密钥以及Zuul服务器的路由信息。在`src/main/resources`目录中创建一个名为`application.yml`的文件：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have a working authentication service and an API Gateway capable
    of verifying JWTs, we can test our authentication scheme by running the API Gateway,
    authentication service, and message service using the ports defined in the preceding
    configuration file. The following CURL requests now show that valid credentials
    can be exchanged for a JWT and the JWT can be used to access protected resources.
    We can also show that requests to protected resources are rejected without a valid
    JWT.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个工作认证服务和能够验证JWT的API网关，我们可以通过使用前面配置文件中定义的端口来运行API网关、认证服务和消息服务来测试我们的认证方案。以下CURL请求现在显示，有效的凭据可以交换JWT，并且JWT可以用来访问受保护资源。我们还可以显示，没有有效JWT的请求会被拒绝访问受保护资源。
- en: Note that in this example, the message service still doesn't do any authorization
    of requests. Anyone making an authenticated request could theoretically access
    anyone else's messages. The message service should be modified to check the user
    ID from the subject of the JWT and only allow access to messages belonging to
    that user.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，消息服务仍然不做任何请求授权。任何进行认证请求的人理论上都可以访问任何人的消息。消息服务应该修改为检查JWT主题中的用户ID，并且只允许访问属于该用户的消息。
- en: 'We can use `curl` to test registering a new user account:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来测试注册新用户账户：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have a JWT, we can include it in the headers of requests to the
    message service to test that the API Gateway is able to verify and decode the
    token:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了JWT，我们可以将其包含在消息服务的请求头中，以测试API网关是否能够验证和解码令牌：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The fact that we get a 404 from the message service shows that the request
    is getting to that service. If we modify the JWT in the request headers, we should
    get a 401:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从消息服务得到404错误表明请求已经到达该服务。如果我们修改请求头中的JWT，我们应该得到401错误：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Securing containers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护容器
- en: The advent of containers has solved many problems for organizations that are
    managing microservice architectures. Containers allow services to be bundled as
    a self-contained unit, and the software and its dependencies can be built as a
    single artifact and then shipped into any environment to be run or scheduled.
    Instead of relying on complicated configuration-management solutions to manage
    small changes to production systems, containers support the idea of immutable
    infrastructure; once the infrastructure is built, it does not have to be upgraded
    or maintained. Instead, you just build new infrastructure and throw away the old.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的出现为管理微服务架构的组织解决了许多问题。容器允许将服务捆绑为自包含的单元，软件及其依赖项可以构建为一个单一的项目，然后将其运送到任何环境中运行或调度。而不是依赖于复杂的配置管理解决方案来管理生产系统的微小更改，容器支持不可变基础设施的概念；一旦基础设施构建完成，就不需要升级或维护。相反，你只需构建新的基础设施，然后丢弃旧的。
- en: Containers also allow organizations to optimize their use of storage and compute
    resources. Because software can be built as containers, multiple applications
    can be running on a single virtual machine or piece of hardware, each unaware
    of the others' existence. While multi-tenancy has many advantages, having multiple
    services running on the same VM introduces new attack scenarios that a malicious
    user could exploit. If an attacker is able to exploit a vulnerability in one service,
    they may be able to use that exploit to attack services running on the same VM.
    In this kind of setup, by default, the cluster is treated as the security boundary;
    if you have access to the cluster, you must be trusted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还允许组织优化其存储和计算资源的使用。由于软件可以构建为容器，多个应用程序可以在单个虚拟机或硬件上运行，每个应用程序都意识不到其他应用程序的存在。虽然多租户有许多优点，但在同一虚拟机上运行多个服务引入了新的攻击场景，恶意用户可能会利用这些场景。如果攻击者能够利用一个服务中的漏洞，他们可能会利用这个漏洞攻击同一虚拟机上运行的其他服务。在这种配置中，默认情况下，集群被视为安全边界；如果你有权访问集群，你必须被信任。
- en: Depending on the needs of an organization, treating the cluster as the security
    boundary may not be sufficient and there may be a desire for more security and
    isolation between containers. The seccomp security facility was introduced into
    the Linux kernel in Version 2.6.12\. It supports restricting the system calls
    that can be made from a process. Running containerized applications with a seccomp
    policy essentially sandboxes the service and any other process running in the
    container. In this recipe, we'll show you how to check that the seccomp is configured
    in your Linux kernel and demonstrate running a container with a custom seccomp
    policy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据组织的需要，将集群视为安全边界可能不足以满足需求，并且可能希望容器之间有更多的安全和隔离。seccomp 安全设施在 Linux 内核的 2.6.12
    版本中被引入。它支持限制从进程可以做出的系统调用。使用 seccomp 策略运行容器化应用程序实际上将服务以及容器中运行的任何其他进程隔离。在这个菜谱中，我们将向您展示如何检查
    Linux 内核中是否配置了 seccomp，并演示如何使用自定义 seccomp 策略运行容器。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to use a seccomp policy with a Docker container, you must be running
    the container on a host OS with a Linux kernel configured with seccomp support.
    To check this, you can search for `CONFIG_SECCOMP` in the kernel configuration
    file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在 Docker 容器中使用 seccomp 策略，你必须在配置了 seccomp 支持的 Linux 内核的主机操作系统上运行容器。要检查这一点，你可以在内核配置文件中搜索
    `CONFIG_SECCOMP`：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we've verified that seccomp is enabled in the Linux kernel, we can
    take a look at the default profile that is packaged with Docker ([https://github.com/moby/moby/blob/master/profiles/seccomp/default.json](https://github.com/moby/moby/blob/master/profiles/seccomp/default.json)).
    This default policy is sufficient for most needs and is fairly restrictive. If
    seccomp support is enabled, containers will be run with this policy.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经验证了 Linux 内核中已启用 seccomp，我们可以查看 Docker 一起打包的默认配置文件（[https://github.com/moby/moby/blob/master/profiles/seccomp/default.json](https://github.com/moby/moby/blob/master/profiles/seccomp/default.json)）。此默认策略对于大多数需求来说已经足够，并且相当严格。如果启用了
    seccomp 支持，容器将使用此策略运行。
- en: 'To further verify that seccomp is configured and Docker is able to support
    it, we''ll create a simple custom policy and then run a command in a container
    that demonstrates that the policy is being enforced. Create a file called `policy.json`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步验证 seccomp 是否已配置并且 Docker 能够支持它，我们将创建一个简单的自定义策略，然后在容器中运行一个命令来演示策略正在被强制执行。创建一个名为
    `policy.json` 的文件：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, run a container executing a shell and try to create a file, then change
    the ownership. The error message indicates that the container is being restricted
    by the seccomp policy:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行一个执行 shell 的容器，然后尝试创建一个文件，然后更改所有权。错误消息表明容器正在受到 seccomp 策略的限制：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Secure configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全配置
- en: Services usually require some form of configuration. A service configuration
    stores all of the information that could potentially vary depending on the environment
    the service is deployed in. For example, when running a service locally on a developer's
    workstation, the service should probably connect to a database that is also running
    locally. In production, however, the service should connect to the production
    database. Common data stored in configuration includes the location of and credentials
    to data stores, access tokens, or other credentials for third-party services and
    operational information, such as where to send metrics or what values to use when
    initializing connection pools or configuring timeouts for network connections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常需要某种形式的配置。服务配置存储了所有可能根据服务部署的环境而变化的信息。例如，当在开发人员的工作站上本地运行服务时，服务可能应该连接到也在本地运行的数据库。然而，在生产环境中，服务应该连接到生产数据库。配置中通常存储的数据包括数据存储的位置和凭证、访问令牌或其他第三方服务的凭证以及操作信息，例如发送指标的位置或初始化连接池或配置网络连接超时时应使用的值。
- en: It's important to store configuration separately from code. When you make a
    configuration change, you should not have to commit a change to a source code
    repository, create a new build, and run a separate deploy. Ideally, there should
    be an easy way to change configuration without deploying a new version of a service.
    Storing configuration in code (for example, hard coding a password in a source
    code file) is also a bad practice from a security perspective. Anyone with access
    to the source code has access to the configuration, and in the case of secrets,
    this is rarely desired. It is a good practice to roll keys and credentials as
    often as possible, so that even if a secret is compromised or is vulnerable to
    being compromised, it will not be valid for very long. Hardcoding secrets makes
    this difficult, which in practice often means it won't happen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置与代码分开存储很重要。当你进行配置更改时，你不应该需要将更改提交到源代码存储库、创建新的构建和运行单独的部署。理想情况下，应该有一种简单的方法来更改配置，而无需部署服务的新版本。将配置存储在代码中（例如，在源代码文件中硬编码密码）也是从安全角度的不良做法。任何有权访问源代码的人都可以访问配置，在秘密的情况下，这通常是不希望的。尽可能频繁地滚动密钥和凭证是一种良好的做法，这样即使秘密被泄露或容易受到泄露的威胁，它也不会有效很长时间。硬编码秘密会使这变得困难，在实践中通常意味着它不会发生。
- en: A common best practice is to store configuration in environment variables. This
    is a good way to expose configuration values to a process in a way that can be
    changed easily depending on the environment a service is running in. Environment
    variables are good for non-secret configuration values, such as hostnames, timeouts,
    and log levels. Environment variables are not sufficient for storing secrets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的最佳实践是将配置存储在环境变量中。这是一种将配置值暴露给进程的好方法，可以根据服务运行的环境轻松更改。环境变量对于非秘密配置值很好，例如主机名、超时和日志级别。环境变量不足以存储秘密。
- en: Storing secrets as environment variables makes the values accessible to any
    process running in the same container or process space as the service, which makes
    them susceptible to being intercepted. There are various solutions for storing
    secrets separately from the rest of an application's configuration. Applications
    deployed on a Kubernetes cluster can use a special object type called `secret`,
    which is intended for this purpose. Kubernetes secrets are encrypted using a private
    key residing on a master node while in transit between nodes, however, the secret
    is stored in plaintext at rest. Ideally, secrets should be stored as encrypted
    values and only decrypted by a process that is explicitly permitted to do so.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将秘密存储为环境变量会使这些值对在相同容器或进程空间中运行的所有进程都可用，这使得它们容易受到拦截。有各种方法可以将秘密与应用程序配置的其他部分分开存储。在
    Kubernetes 集群上部署的应用程序可以使用一种特殊类型的对象，称为 `secret`，它旨在用于此目的。Kubernetes 机密在节点之间传输时使用驻留在主节点上的私钥进行加密，然而，在静止状态下，机密以明文形式存储。理想情况下，秘密应该以加密值的形式存储，并且只有明确允许这样做的过程才能解密。
- en: Vault is an open source project actively maintained by HashiCorp. Its purpose
    is to provide an easy-to-use system for storing and accessing secrets securely.
    In addition to secret-storage, Vault provides access-log auditing, fine-grained
    access-control, and easy rolling. In this recipe, we'll create a new service,
    called attachment-service, that is responsible for handling messages' image and
    video attachments. Attachment-service will use Vault to obtain valid AWS credentials
    used to access an S3 bucket when uploading photo and video files. The service
    will also use Vault to obtain database credentials to a MySQL database where attachment
    metadata will be stored. Non-sensitive configurations, such as the name of the
    database or the name of the S3 bucket to upload photos and videos to, will be
    made available to the service as environment variables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 是一个由 HashiCorp 活跃维护的开源项目。其目的是提供一个易于使用的系统，用于安全地存储和访问机密。除了秘密存储外，Vault 还提供访问日志审计、细粒度访问控制和轻松滚动。在这个菜谱中，我们将创建一个新的服务，称为
    attachment-service，该服务负责处理消息的图像和视频附件。Attachment-service 将使用 Vault 获取用于上传照片和视频文件的
    S3 存储桶的有效 AWS 凭据。该服务还将使用 Vault 获取存储附件元数据的 MySQL 数据库的凭证。非敏感配置，如数据库名称或上传照片和视频的 S3
    存储桶名称，将作为环境变量提供给服务。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to demonstrate using Vault to securely store sensitive configuration
    data, we''ll first create an attachment service that stores sensitive information
    using environment variables. We''ll then integrate Vault so that the same configuration
    is read from a secure store:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用 Vault 安全存储敏感配置数据，我们首先将创建一个附件服务，该服务使用环境变量存储敏感信息。然后我们将集成 Vault，以便从安全存储中读取相同的配置：
- en: 'Create a new Java project called `attachment-service` with the following `build.gradle`
    file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `attachment-service` 的新 Java 项目，并使用以下 `build.gradle` 文件：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new package called `com.packtpub.microservices.ch06.attachment` and
    create a new class called `Application`, which will serve as our service''s entry
    point. In addition to running our Spring Boot application, this class will expose
    one bean, which is the Amazon S3 client. Note that we''re using the `EnvironmentVariableCredentialsProvider`
    class, which reads credentials from a set of environment variables for now, this
    is not what we want to do in production:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `com.packtpub.microservices.ch06.attachment` 的新包，并创建一个名为 `Application`
    的新类，该类将作为我们服务的入口点。除了运行我们的 Spring Boot 应用程序外，此类还将公开一个 bean，即 Amazon S3 客户端。请注意，我们目前使用的是
    `EnvironmentVariableCredentialsProvider` 类，它从一组环境变量中读取凭证，这不是我们希望在生产中做的事情：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new package called `com.packtpub.microservices.ch06.attachment.models`
    and a new class called `Attachment`. This will be the representation of attachments
    that we store in a relational database:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `com.packtpub.microservices.ch06.attachment.models` 的新包和一个名为 `Attachment`
    的新类。这将是我们存储在关系型数据库中的附件表示：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to perform basic operations on the previously defined `Attachment`
    class, we''ll create a new package called `com.packtpub.microservices.ch06.attachment.data`
    and an interface called `AttachmentRepository`, which extends `CrudRepository`.
    We''ll also define one custom method signature that allows a caller to find all
    attachments related to a specific message:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了对之前定义的 `Attachment` 类执行基本操作，我们将创建一个名为 `com.packtpub.microservices.ch06.attachment.data`
    的新包和一个名为 `AttachmentRepository` 的接口，该接口扩展了 `CrudRepository`。我们还将定义一个自定义方法签名，允许调用者找到与特定消息相关的所有附件：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need a way to model incoming requests. Our service will accept requests
    as JSON sent in the request body. The JSON object will have a file name and contain
    the file data as a Base64-encoded string. Create a new class called `AttachmentRequest`
    with the following definition:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一种方式来建模传入的请求。我们的服务将接受作为请求体中 JSON 发送的请求。JSON 对象将包含一个文件名，并包含作为 Base64 编码字符串的文件数据。创建一个名为
    `AttachmentRequest` 的新类，其定义如下：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our controller, which we''ll define next, we''ll need to return an HTTP
    404 response to callers if no attachments can be found for a particular message.
    In order to do this, create a new package called `com.packtpub.microservices.ch06.attachment.exceptions`
    and a new class called `AttachmentNotFoundException`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的控制器中，我们将在下一节定义它，如果找不到特定消息的附件，我们需要返回 HTTP 404 响应给调用者。为了做到这一点，创建一个名为 `com.packtpub.microservices.ch06.attachment.exceptions`
    的新包和一个名为 `AttachmentNotFoundException` 的新类：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll put everything together in our controller. In this basic example, two
    methods are defined; one that lists attachments for a specific message and one
    that creates a new attachment. The attachment is uploaded to an Amazon S3 bucket,
    the name of which is specified in a configuration value. Create a new package
    called `com.packtpub.microservices.ch06.attachment.controllers` and a new class
    called `AttachmentController`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在控制器中将所有内容组合在一起。在这个基本示例中，定义了两个方法；一个用于列出特定消息的附件，另一个用于创建新的附件。附件将上传到Amazon S3存储桶，其名称在配置值中指定。创建一个名为`com.packtpub.microservices.ch06.attachment.controllers`的新包和一个名为`AttachmentController`的新类：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order for any of this to work, we have to create a properties file. Java
    properties files support a syntax for getting values from environment variables,
    which is shown in the following code. Create a new file in the `src/main/resources`
    directory called `application.yml`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这一切都能正常工作，我们必须创建一个属性文件。Java属性文件支持从环境变量获取值的语法，如下面的代码所示。在`src/main/resources`目录中创建一个名为`application.yml`的新文件：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example works well enough. `EnvironmentVariableCredentialsProvider` in
    the AWS SDK expects `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` to be set,
    and we specify that a number of non-sensitive configuration values should be similarly
    read from environment variables. This is clearly better than hardcoding configuration
    values, but we're still exposing secrets to any process running in the same container
    or process space as our service. The environment variables also have to be set
    somewhere (by a configuration management system or specified in a Dockerfile),
    so we haven't solved the problem of storing sensitive secrets. Next, we'll modify
    our new service to read S3 credentials from Vault.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经足够好。AWS SDK中的`EnvironmentVariableCredentialsProvider`期望`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`被设置，我们指定许多非敏感配置值应该从环境变量中读取。这显然比硬编码配置值要好，但我们仍然将秘密暴露给了在同一个容器或进程空间中运行的所有进程。环境变量也必须在某个地方设置（通过配置管理系统或指定在Dockerfile中），所以我们还没有解决存储敏感秘密的问题。接下来，我们将修改我们的新服务以从Vault读取S3凭证。
- en: In this recipe, we'll be running Vault in development mode. Installing Vault
    for production use is a big topic that cannot be properly covered in a single
    recipe. For the production use of Vault, please consult the excellent documentation
    available at [https://www.vaultproject.io/intro/index.html](https://www.vaultproject.io/intro/index.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将以开发模式运行Vault。为生产使用安装Vault是一个大主题，无法在一个菜谱中适当覆盖。有关Vault的生产使用，请参阅[https://www.vaultproject.io/intro/index.html](https://www.vaultproject.io/intro/index.html)提供的优秀文档。
- en: 'Install `vault` on your local development machine. See [http://www.vaultproject.io](http://www.vaultproject.io)
    for instructions for any platform. If you are running macOS X and use **HomeBrew**,
    you can install Vault with a single command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的本地开发机器上安装`vault`。有关任何平台的说明，请参阅[http://www.vaultproject.io](http://www.vaultproject.io)。如果你运行的是macOS
    X并且使用**HomeBrew**，你可以使用单个命令安装Vault：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the `vault server` in development mode, providing a simple-to-remember
    root token:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以开发模式运行`vault server`，提供一个易于记住的根令牌：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Enable a new instance of a `kv` secrets engine with a path specific to this
    service:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用一个新的`kv`秘密引擎实例，其路径特定于此服务：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Write the AWS access key and secret pair to `vault` as secrets. Substitute
    the placeholders for your actual AWS access key ID and AWS secret access key:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将AWS访问密钥和密钥对写入`vault`作为秘密。用你的实际AWS访问密钥ID和AWS密钥访问密钥替换占位符：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order for our service to read these values from Vault, we''ll use a library
    that simplifies Vault integration for Spring Boot applications. Modify our project''s
    `build.gradle` file and add the following dependency:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使我们的服务能够从Vault读取这些值，我们将使用一个简化Spring Boot应用程序Vault集成的库。修改我们的项目`build.gradle`文件并添加以下依赖项：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our application needs a configuration class to store values read from Vault.
    Create a new package called `com.packtpub.microservices.ch06.attachment.config`
    and a new class called `Configuration`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个配置类来存储从Vault读取的值。创建一个名为`com.packtpub.microservices.ch06.attachment.config`的新包和一个名为`Configuration`的新类：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Modify the `Application` class to create an instance of the class we just created.
    Then use the instance when creating the S3 client so that we can use credentials
    taken from Vault instead of environment variables:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Application`类以创建我们刚刚创建的类的实例。然后在创建S3客户端时使用该实例，这样我们就可以使用从Vault获取的凭证而不是环境变量：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That's it! The attachment service is now configured to read AWS credentials
    from Vault.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！附件服务现在已配置为从Vault读取AWS凭证。
- en: Secure logging
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全日志
- en: Together with traces and metrics, logs are an essential component of an observable
    system (we'll discuss Observability more generally in [Chapter 7](fc3632cc-83c0-44ff-b11d-87f556f7b46b.xhtml),
    *Monitoring and Observability*). Logs are an ordered, timestamped sequence of
    events that originated in a particular system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与跟踪和指标一起，日志是可观察系统的一个基本组成部分（我们将在第7章*监控和可观察性*中更广泛地讨论可观察性）。日志是特定系统中事件的有序、带时间戳的序列。
- en: In a microservice architecture, the increased complexity of having multiple
    services makes having good logs essential. The exact criteria that makes logs
    good is subjective, but generally speaking, good logs should help an engineer
    piece together events that may have led to a specific error state or bug. Logs
    are usually organized by levels, a configurable toggle that allows a developer
    to instruct a service to be more or less verbose with the information sent to
    logs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，拥有多个服务带来的复杂性增加，使得良好的日志记录变得至关重要。良好的日志的具体标准是主观的，但一般来说，良好的日志应该帮助工程师拼凑出可能导致特定错误状态或错误的可能事件。日志通常按级别组织，这是一个可配置的切换，允许开发者指示服务对发送到日志的信息进行更多或更少的详细说明。
- en: While essential for observing the behavior of systems in production, logs can
    also present privacy and security risks. Having too much information sent from
    systems to logs can give a would-be attacker information about users of your system,
    or sensitive information such as tokens or keys that can be used to attack other
    parts of your system. Having a microservice architecture spreads out this possible
    attack surface, making it even more important to have a carefully planned strategy
    for how your services should log information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于观察生产环境中系统的行为至关重要，但日志也可能带来隐私和安全风险。从系统发送到日志的大量信息可能会给潜在的攻击者提供有关您系统用户的信息，或者可以用来攻击系统其他部分的敏感信息，如令牌或密钥。微服务架构将可能的攻击面分散开来，这使得精心规划的日志记录策略变得更加重要，以确定服务应该如何记录信息。
- en: Infrastructure as Code
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: Microservices architectures typically require more frequent provisioning of
    compute resources. Having more nodes in a system increases the attack surface
    that an attacker could scan for possible vulnerabilities. One of the easiest ways
    to leave a system vulnerable is to lose track of the inventory and leave multiple,
    heterogeneous configurations active. Before configuration-management systems,
    such as, Puppet or Ansible were popular, it was common to have a set of custom
    shell scripts that would *bootstrap* new servers in a system. This worked well
    enough, but as the needs of the system grew, and the shell scripts were modified,
    it became unwieldy to bring older parts of the system up to date with the changing
    standards. This type of configuration drift would often leave legacy parts of
    a system vulnerable to attack. Configuration-management solved many of these problems
    by allowing teams to use code, usually with a declarative syntax, to describe
    how nodes in a system should be configured. Configuration-management systems typically
    did not deal with provisioning actual compute resources, such as compute nodes,
    data stores, or network storage.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通常需要更频繁地提供计算资源。系统中的节点越多，攻击者可以扫描的可能漏洞的攻击面就越大。最容易让系统变得脆弱的方法之一是失去对库存的跟踪，并让多个异构配置保持活跃。在像Puppet或Ansible这样的配置管理系统流行之前，通常有一套自定义的shell脚本，这些脚本会在系统中*引导*新的服务器。这已经足够好了，但随着系统需求的增长和shell脚本的修改，将系统的旧部分更新到不断变化的标准变得难以管理。这种类型的配置漂移通常会使得系统的遗留部分容易受到攻击。配置管理系统通过允许团队使用代码（通常使用声明性语法）来描述系统中的节点应该如何配置，从而解决了许多这些问题。配置管理系统通常不处理实际计算资源的提供，例如计算节点、数据存储或网络存储。
- en: Infrastructure as Code is the process of managing infrastructure-provisioning
    and maintenance through machine-readable code files rather than manually. Using
    code to describe the infrastructure allows for effective versioning, reviews,
    and rollbacks of changes to a system. Being able to automate the process of bringing
    up a database node or adding a compute node to a cluster frees developers up to
    worry about their applications, relatively assured that they are not leaving old
    configurations out in the wild. Together with immutable infrastructure, Infrastructure
    as Code provides an additional safety net against a system being compromised by
    vulnerable, forgotten components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码是通过机器可读的代码文件来管理基础设施的配置和运维过程，而不是手动操作。使用代码来描述基础设施可以有效地进行版本控制、代码审查和系统变更的回滚。能够自动化创建数据库节点或将计算节点添加到集群的过程，可以让开发者从关注应用程序中解放出来，相对有信心地确保他们不会在野外留下旧配置。与不可变基础设施相结合，基础设施即代码为系统免受易受攻击、被遗忘组件的侵害提供了额外的安全网。
- en: In this recipe, we'll demonstrate using *Terraform*, an open source tool created
    by HashiCorp, to provision a collection of AWS resources, including an EC2 instance
    and a Redis ElastiCache. We'll guarantee that resources provisioned with Terraform
    share configurations with regards to network access, backups, and other security
    considerations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将演示如何使用由HashiCorp创建的开源工具*Terraform*来配置一组AWS资源，包括EC2实例和Redis ElastiCache。我们将确保使用Terraform配置的资源在网络访问、备份和其他安全考虑方面共享配置。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Before using terraform, you''ll have to install it. Instructions are available
    on the [project site](https://www.terraform.io/intro/getting-started/install.html),
    but if you are running macOS X and use HomeBrew ([https://brew.sh/](https://brew.sh/)),
    you can issue the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Terraform之前，您必须安装它。安装说明可在[项目网站](https://www.terraform.io/intro/getting-started/install.html)上找到，但如果您正在运行macOS
    X并使用HomeBrew（[https://brew.sh/](https://brew.sh/)），则可以发出以下命令：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a new file called `example.tf`. This will contain configuration for
    our EC2 instance and ElastiCache instance. We''ll use a default **Amazon Machine
    Image** (**AMI**) and enable daily snapshots that will be kept for five days:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example.tf`的新文件。该文件将包含我们的EC2实例和ElastiCache实例的配置。我们将使用默认的**亚马逊机器镜像**（**AMI**），并启用每天保留五天的快照：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Replace `ACCESS_KEY` and `SECRET_KEY` with a valid AWS access key pair.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ACCESS_KEY`和`SECRET_KEY`替换为有效的AWS访问密钥对。
- en: 'Initialize terraform. This will install the AWS provider referenced in the
    preceding file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化Terraform。这将安装前面文件中引用的AWS提供程序：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Terraform works by presenting an execution plan and then asking whether you''d
    like to proceed by applying the plan. Run the following command and type `yes`
    when prompted:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform通过呈现执行计划并询问您是否希望通过应用该计划来继续操作。运行以下命令并在提示时输入`yes`：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: An execution plan has been generated and is shown in the following code. Resource
    actions are indicated with the following symbols: `+ create`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 已生成执行计划，如下面的代码所示。资源操作用以下符号表示：`+ create`。
- en: 'Terraform will perform the following actions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将执行以下操作：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Terraform will perform the actions described earlier. Only `yes` will be accepted
    to approve:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将执行前面描述的操作。只有`yes`会被接受以批准：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Log into your AWS management console and you''ll see that a new Redis cluster
    and EC2 instance have been created. Terraform can also help you clean up. In order
    to destroy these two resources, run the destroy command and type in `yes` when
    prompted:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的AWS管理控制台，您将看到已创建一个新的Redis集群和EC2实例。Terraform还可以帮助您清理。为了销毁这两个资源，运行销毁命令并在提示时输入`yes`：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Terraform is an incredibly powerful tool. In this recipe, we used it to create
    a single EC2 instance and an ElastiCache Cluster instance. You can do loads more
    with Terraform – the subject of Infrastructure as Code could fill a cookbook of
    its own. Thankfully, the docs provided by HashiCorp ([https://www.terraform.io/docs/index.html](https://www.terraform.io/docs/index.html))
    are excellent and I would recommend reading them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是一个功能强大的工具。在本食谱中，我们用它创建了一个EC2实例和一个ElastiCache集群实例。您可以用Terraform做更多的事情——基础设施即代码的主题可以填满一本自己的食谱。幸运的是，HashiCorp提供的文档（[https://www.terraform.io/docs/index.html](https://www.terraform.io/docs/index.html)）非常出色，我建议您阅读它们。
- en: Using an Infrastructure as Code solution will make provisioning and managing
    resources a much safer process, limiting the possibility of losing track of legacy
    infrastructure with out-of-date configurations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施即代码解决方案将使资源配置和管理过程变得更加安全，限制因配置过时而丢失旧有基础设施的可能性。
