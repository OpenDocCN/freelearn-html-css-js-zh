<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Web API Examples"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Web API Examples</h1></div></div></div><p>Many of the widgets that we explored in the previous chapters are most useful when paired with more advanced server-side code. For example, many web applications use databases and work with files. While the previous chapters showed the client-side code, such as HTML and JavaScript, that is necessary to use these widgets, they did not focus on the ASP.NET server-side C# code that many real-world applications utilize. To demonstrate how to use the Kendo UI Framework with these types of scenarios, this chapter will show some specialized examples of using the Kendo UI Framework with the ASP.NET Web API and with the Entity Framework.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If you are unfamiliar with the ASP.NET Web API framework, you can visit <a class="ulink" href="http://www.asp.net/web-api">www.asp.net/web-api</a> for some good examples, videos, and walkthroughs.</p></div></div><div class="section" title="Getting familiar with the ASP.NET Web API"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Getting familiar with the ASP.NET Web API</h1></div></div></div><p>The most recent<a id="id755" class="indexterm"/> release of the ASP.NET MVC Framework, MVC 4, included templates for a new feature known as <span class="strong"><strong>Web API controllers</strong></span>
<a id="id756" class="indexterm"/>. These controllers are specialized HTTP communication endpoints and allow for the creation of RESTful API services. <a id="id757" class="indexterm"/>A RESTful API service<a id="id758" class="indexterm"/> is a HTTP web service that allows clients to communicate using standard HTTP verbs (<code class="literal">Get</code>, <code class="literal">Post</code>, <code class="literal">Put</code>, <code class="literal">Delete</code>, and <code class="literal">Patch</code>) in order to perform operations on the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Traditionally, ASP.NET has had the ability to create web services as SOAP endpoints (as opposed to REST endpoints). SOAP web services use XML schemas and are very good at serializing and deserializing strongly-typed objects and have been widely adopted in production systems. Compared with RESTful services, SOAP services are very verbose and brittle, as a change to the schema is required to implement any new features. Additionally, the explosive growth around JavaScript has made RESTful services more appealing to developers since they can be easily accessed through HTML <code class="literal">script</code> blocks and common JavaScript code.</p></div></div><p>RESTful web services are becoming more and more common on the Internet. Many popular web-based services<a id="id759" class="indexterm"/> expose public RESTful APIs to enable integration with mobile apps, web-based dashboards, and other software projects. This widespread adoption is due largely in part to the equally widespread adoption of <span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>)<a id="id760" class="indexterm"/> for serializing and deserializing objects. JSON makes it simple for any web client to interpret data from any web server without requiring specialized or proprietary licenses or algorithms.</p><p>A RESTful web request<a id="id761" class="indexterm"/> is <a id="id762" class="indexterm"/>very simple and you use them every day, if you did not already know it. Every time you type a URL into a web browser, you are issuing an HTTP GET request to the server at that URL address. Likewise, most web pages that include forms use the HTTP POST verb to post that data back to the web server to be saved. This may also jog your memory back to some of our code samples in previous chapters. Do you remember seeing the <code class="literal">[HttpGet]</code> and <code class="literal">[HttpPost]</code> attributes on some of the controller action methods? These attributes indicated to ASP.NET that only a specific type of HTTP verb (either a GET or a POST) is allowed for that action method. This does have security implications of course, but it is actually more useful for determining which method the server should use depending on which HTTP verb the client sent along with the request. In other words, a controller could have five different action methods with different HTTP verb attributes for each one, as shown here:</p><div class="informalexample"><pre class="programlisting">[HttpGet]
public ActionResult Get(int objectId = 0)
{
  ...
}

[HttpPost]
public ActionResult Post(Object postedObject)
{
  ...
}

[HttpPut]
public ActionResult Put(Object objectToPut)
{
  ...
}

[HttpPatch]
public ActionResult Patch(Object objectToPatch)
{
  ...
}

[HttpDelete]
public ActionResult Delete(int objectId)
{
  ...
}</pre></div><p>The problem with the preceding code is that it creates a separate route for each of the different functions<a id="id763" class="indexterm"/> for the page. If this page were accessible from the route <code class="literal">http://mysite.com/movies</code>, we could use <code class="literal">http://mysite.com/movies/get/25</code> to see data for a specific movie, but we would have to use a completely different route in order to add a new movie or to delete a movie, such as <code class="literal">http://mysite.com/movies/put</code>. This may not seem like such a big problem for a website where URLs can be embedded in forms and links without much interaction from the user, but this is a big problem for developers trying to create a program to access the API from remote code.</p><p>The ASP.NET MVC Web API solves this problem by creating special controllers solely for the purpose of creating RESTful services. In a standard MVC controller, each action method creates a new route (or URL) that ultimately generates some web content inside a view. In a Web API controller, however, each action method specifies a single HTTP verb for the same route (or URL). In other words, a Web API controller serves only a single HTTP endpoint; it only operates for a single route. For an API developer, this is perfect. A single HTTP endpoint, such as <code class="literal">http://mysite.com/api/movies</code>, can respond to all of the HTTP verbs appropriately without having to use different URLs for each operation.</p><p>Inside of the API controller, each of the HTTP verbs gets one or more action methods for serving that specific type of request. The route to the controller defaults to the controller's name. So a controller called <code class="literal">MoviesController.cs</code> would default to the route <code class="literal">http://mysite.com/api/movies</code>. This is as far as the route goes; the only difference now between requests to this endpoint is in which HTTP verb the request includes and which parameters are passed in as arguments. The following is the default code generated by the ASP.NET Web API template for an API controller:</p><div class="informalexample"><pre class="programlisting">// GET api/values
public IEnumerable&lt;string&gt; Get()
{
  return new string[] { "value1", "value2" };
}

// GET api/values/5
public string Get(int id)
{
  return "value";
}

// POST api/values
public void Post([FromBody]string value)
{
}

// PUT api/values/5
public void Put(int id, [FromBody]string value)
{
}

// DELETE api/values/5
public void Delete(int id)
{
}</pre></div><p>Notice that the names of the action methods are the names of HTTP verbs. This is not an accident, it is required that the action method names either match an HTTP verb name or begin with an HTTP verb <a id="id764" class="indexterm"/>name. So an action method can either be called <code class="literal">Get</code> or it could be called <code class="literal">GetMovie</code>. Also notice that there are two different versions of the <code class="literal">Get</code> action method in this controller. Just like in a standard controller, the same action method can be listed multiple times as long as the signature for each method is unique. In this case, it allows us to have a standard <code class="literal">Get</code> method that does not require any parameters and a more specialized <code class="literal">Get</code> method that returns information for a specific record.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>You can visit <a class="ulink" href="http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api">http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api</a> for a good overview of Web API routing rules and naming conventions.</p></div></div><p>You will also notice that these action methods do not have the HTTP verb attributes on them. For an API controller, these attributes are not required. There is a new attribute in the code sample, however. You can see it in front of the parameters for the <code class="literal">Post</code> and <code class="literal">Put</code> action methods: <code class="literal">[FromBody]</code>. This special attribute is used to assist the model binder in locating the parameter in the body of the HTTP request. It is not always necessary, such as when you are binding a complex object that the model binder can clearly see is made up of specific properties with specific names. For a simple string value as in this code sample, however, it needs to know that you intend to bind the HTTP request body to that input parameter. There is also an attribute (<code class="literal">[FromUri]</code>) to indicate that a parameter comes from the URL. Most of the time, these parameters will be unnecessary but they are available to help solve<a id="id765" class="indexterm"/> problems that the model binder is unable to solve on its own. It is worth some more research if you unfamiliar with it. The basic rules that Web API uses for model binding work like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simple types are taken from the URL (URI)</li><li class="listitem" style="list-style-type: disc">Complex types are taken from the request body</li></ul></div><p>Simple types include all of the .NET Framework primitive types, plus <code class="literal">DateTime</code>, <code class="literal">Decimal</code>, <code class="literal">Guid</code>, <code class="literal">String</code>, and <code class="literal">TimeSpan</code>. For each action method, at most one parameter can read the request body. If you try to mark more than one parameter with <code class="literal">[FromBody]</code>, you will either get a runtime error or null values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>You can visit <a class="ulink" href="http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx">http://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx</a> for more information on parameter binding with Web API.</p></div></div><p>Another important concept to understand about API controllers is that they do not return views like standard controllers do. Rather than generating HTML markup for a web browser to display, API controllers generate raw data that is intended for specialized client code, such as JavaScript, to consume. The format of this data is something that you do not have to worry about. Notice how the action methods in the previous code sample simply return string values without using the <code class="literal">Json()</code> method that we have seen in some of the previous chapters. We do not need to tell the API controller how to format its data because it will auto-negotiate the correct format with the client during the communication process. The most common format is JSON, but some clients may prefer XML or other data types that the ASP.NET framework understands how to serialize.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>You may be interested in knowing how this auto-negotiation works. Here is the answer: it is based largely on the <code class="literal">Accept</code> header from the client during the API call. You can even create your own content types to extend the API framework for customized scenarios. See this page for more information: <a class="ulink" href="http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation">http://www.asp.net/web-api/overview/formats-and-model-binding/content-negotiation</a>.</p></div></div><p>Since API controllers are not designed to render web pages with markup, you will need to create normal controllers for your web pages as you are used to doing. To interact with the API controllers, it is very common to utilize JavaScript, especially jQuery, to access the API endpoints with a specific HTTP verb to accomplish whatever task your page is designed for.</p></div></div>
<div class="section" title="Getting familiar with Entity Framework Code First"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Getting familiar with Entity Framework Code First</h1></div></div></div><p>Most applications use a <a id="id766" class="indexterm"/>database to store information. Most databases, however, store information in a way that does not exactly match up with server-side object oriented programming. This is a very common problem and has given rise to the field of <span class="strong"><strong>Object Relational Mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>)<a id="id767" class="indexterm"/> systems. Many of these exist, but Microsoft has created one specific to the .NET framework known as the <span class="strong"><strong>Entity Framework</strong></span> (<span class="strong"><strong>EF</strong></span>)<a id="id768" class="indexterm"/>. It is basically a framework designed to more easily write code that stores information in a database but still behaves like an object oriented system. If you have downloaded the sample content for this chapter, go ahead and open the <code class="literal">Chapter 11</code> solution now to follow along. Otherwise, create a new ASP.NET MVC 4 project and choose the <span class="strong"><strong>Web API</strong></span> template when asked.</p><div class="mediaobject"><img src="graphics/4346OT_11_05.jpg" alt="Getting familiar with Entity Framework Code First"/></div><p>The particulars of the Entity Framework are numerous and there is not enough space here to explore them. We will go through a basic example of how to utilize the Entity Framework Code First model <a id="id769" class="indexterm"/>so that we can show this in the examples for this chapter. In order to use the Entity Framework, <a id="id770" class="indexterm"/>you must first install it into your Visual Studio project through NuGet. You can do this by right-clicking the project in the Solution Explorer in Visual Studio and choosing <span class="strong"><strong>Manage NuGet Packages…</strong></span>, as shown here:</p><div class="mediaobject"><img src="graphics/4346OT_11_01.jpg" alt="Getting familiar with Entity Framework Code First"/></div><p>On the next screen, you should make sure that you are viewing the <span class="strong"><strong>Online</strong></span> catalogue. Type the text <code class="literal">Entity Framework</code> into the search box and choose <span class="strong"><strong>Install</strong></span> when it appears in the results window. Once installed, it will display a green check mark indicating that it is ready for use:</p><div class="mediaobject"><img src="graphics/4346OT_11_02.jpg" alt="Getting familiar with Entity Framework Code First"/></div><p>This will install all of the necessary components of the Entity Framework into your Visual Studio solution. <a id="id771" class="indexterm"/>We will be using a feature of the Entity Framework known as <span class="strong"><strong>Code First</strong></span>
<a id="id772" class="indexterm"/>. This feature allows us to create classes, or entities, for our data first before the database even exists. The biggest benefit from this model is that it guarantees that the database will be designed and the data will be stored in accordance with our object oriented architecture.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>If you have not already done so, now is a good time to download the sample content for this chapter. All of these examples and files will already be present there, so you can follow along with working code.</p></div></div><p>For the sake of illustration, we will create our entity classes in the <code class="literal">Models</code> folder inside of our Visual Studio project. Create a class called <code class="literal">Movie.cs</code> in the <code class="literal">Models</code> folder like this:</p><div class="informalexample"><pre class="programlisting">public class Movie
{
  public int Id { get; set; }
  public string Name { get; set; }
  public int ReleaseYear { get; set; }
  public int Rating { get; set; }
  public int Rank { get; set; }
}</pre></div><p>The Entity Framework <a id="id773" class="indexterm"/>will infer from the properties here that the <code class="literal">Id</code> property should become the primary key inside the database. Now that we have our model, we need to tell the Entity Framework that we want to make a database that includes it. Create another class in the <code class="literal">Models</code> folder and call it <code class="literal">MoviesContext.cs</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">...
using System.Data.Entity;
...

public class MoviesContext : DbContext
{
  public DbSet&lt;Movie&gt; Movies { get; set; }
}</pre></div><p>This code informs the Entity Framework that we want a <code class="literal">DbContext</code> context that includes a <code class="literal">DbSet</code> of <code class="literal">Movie</code> entities. Let's go ahead and add some movies to our database, so that we can make use of them in our examples. To get started, we need a page where we can type in the movie data and have the web server save that data to the database.</p><p>Create a <code class="literal">MoviesController</code> controller with these options selected; it will automatically scaffold action methods and views with basic operations for managing the <code class="literal">Movie</code> entity that we just created.</p><div class="mediaobject"><img src="graphics/4346OT_11_03.jpg" alt="Getting familiar with Entity Framework Code First"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>If you cannot find your <code class="literal">Movie</code> entity or the <code class="literal">MoviesContext</code> class<a id="id774" class="indexterm"/>, try building your project and trying again.</p></div></div><p>Now go to the <code class="literal">Movies/Index</code> page and create some movies. The first time you run the project, it may <a id="id775" class="indexterm"/>be very slow. The reason for this is that Entity Framework is creating your database on-the-fly in the background from the model and the context that you provided earlier. By the time you see the web page, the database will be up and running. You can see how I have created a few in the following screenshot. Create at least ten so that the examples have some data later in the chapter.</p><div class="mediaobject"><img src="graphics/4346OT_11_04.jpg" alt="Getting familiar with Entity Framework Code First"/></div><p>Although there is a lot more to learn about the Entity Framework, this brief example has taken you all the <a id="id776" class="indexterm"/>way from a single class to a fully working database. We will be using this movies database in the rest of the examples for this chapter. If you are not familiar with the Entity Framework and would like to learn more, I recommend inspecting the <code class="literal">MoviesController.cs</code> class<a id="id777" class="indexterm"/> that we just created with Visual Studio to see how it created the default actions; you can then visit <a class="ulink" href="http://www.msdn.com">www.msdn.com</a> for the official documentation on the topic.</p></div>
<div class="section" title="Getting familiar with OData"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec63"/>Getting familiar with OData</h1></div></div></div><p>The ASP.NET Web API framework supports data queries through a syntax known as <span class="strong"><strong>OData</strong></span>. OData is <a id="id778" class="indexterm"/>a <a id="id779" class="indexterm"/>query language that is compatible with HTTP URLs so that it can appear in URL query strings. It provides two very powerful benefits to API action methods that are used to return lists of data. First, it automatically translates the OData query language into an actual data query on the data inside of your API action method. This is amazingly powerful and may be hard to believe until you can actually see it. Basically, it is a search engine for free. Second, the OData features allow the queries to occur on the server. This means that the server can query the data source for the specific elements that match and then return the result back to the client. The client does not have to query the full set of data and then filter on its own. This is a huge performance improvement and also simplifies both client and server code.</p><p>There are four ways by which you can enable the OData query features for your API controllers. Each providing more fine-grained control than its predecessor.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enable query support globally through <code class="literal">WebApiConfig.cs</code></li><li class="listitem" style="list-style-type: disc">Add the <code class="literal">[Queryable]</code> attribute to specific API action methods</li><li class="listitem" style="list-style-type: disc">Inherit from <code class="literal">ODataController</code> instead of <code class="literal">ApiController</code></li><li class="listitem" style="list-style-type: disc">Inherit from <code class="literal">EntitySetController</code> instead of <code class="literal">ODataController</code></li></ul></div><p>The first option <a id="id780" class="indexterm"/>will globally enable query support for any <code class="literal">ApiController</code> action method with an <code class="literal">IQueryable</code> return type. To enable this, open the <code class="literal">WebApiConfig.cs</code> file inside of the <code class="literal">App_Start</code> folder and un-comment the line of code with <code class="literal">config.EnableQuerySupport()</code>:</p><div class="informalexample"><pre class="programlisting">// Uncomment the following line of code to enable query support 
   for actions with an IQueryable or IQueryable&lt;T&gt; return type.
// To avoid processing unexpected or malicious queries, use the 
   validation settings on QueryableAttribute to validate 
   incoming queries.
// For more information, visit 
   http://go.microsoft.com/fwlink/?LinkId=279712.
config.EnableQuerySupport();</pre></div><p>The second option will enable query support for specific action methods that you decorate with the <code class="literal">[Queryable]</code> attribute. This gives you more configuration choices than the previous option because the <code class="literal">[Queryable]</code> attribute has many properties that you can configure to fine-tune its behavior. An action method decorated with this attribute looks like the following:</p><div class="informalexample"><pre class="programlisting">// GET api/values
[Queryable]
public IQueryable&lt;string&gt; Get()
{
  return new string[] { "value1", "value2" }.AsQueryable();
}</pre></div><p>The third option involves inheriting your controller class from <code class="literal">ODataController</code> instead of <code class="literal">ApiController</code>. This will enable the full OData support that the Web API offers and also requires some more configuration to be done, so that the OData engine understands the <span class="strong"><strong>Entity Data Model</strong></span> (<span class="strong"><strong>EDM</strong></span>)<a id="id781" class="indexterm"/> for the entities that it is exposing.</p><div class="informalexample"><pre class="programlisting">ODataModelBuilder modelBuilder = new ODataConventionModelBuilder();
modelBuilder.EntitySet&lt;Movie&gt;("Movies");
Microsoft.Data.Edm.IEdmModel model = modelBuilder.GetEdmModel();
config.Routes.MapODataRoute("ODataRoute", "OData", model);</pre></div><p>The preceding code needs to run as the web application starts, so it should be placed either in <code class="literal">Global.asax</code> or in one of the <code class="literal">App_Start</code> classes, such as <code class="literal">WebApiConfig.cs</code>. It reads the same type of entity model as the Entity Framework and loads this into an OData route so that Web API understands how each part of the model is related, what the primary keys are, and so on. This enables more advanced scenarios such as property navigation. For more information on this, you can visit <a class="ulink" href="http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint">http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api/getting-started-with-odata-in-web-api/create-a-read-only-odata-endpoint</a> for an introduction.</p><p>The fourth option is similar to the previous option, but it enables more OData functionality automatically that the <code class="literal">ODataController</code> class would have to do manually. It still requires the <code class="literal">ODataModelBuilder</code> class as in the last option. The URL just listed also covers information on this topic.</p><p>For our examples in<a id="id782" class="indexterm"/> this chapter, we will be using the <code class="literal">[Queryable]</code> attribute to enable query support for specific action methods. I encourage you to explore this technology more on your own, it is a powerful and extensible framework that can provide huge productivity boosts to your code. To learn more about OData, you can visit <a class="ulink" href="http://www.odata.org">www.odata.org</a>.</p></div>
<div class="section" title="Using DataSourceRequest with Kendo Grid"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec64"/>Using DataSourceRequest with Kendo Grid</h1></div></div></div><p>As we saw in the first chapter, <a id="id783" class="indexterm"/>the Kendo Grid widget is designed to allow a rich set of features such as <a id="id784" class="indexterm"/>paging, filtering, and sorting. We saw previously how this can be driven on the client side through JavaScript and the Kendo <code class="literal">DataSource</code> object. The <a id="id785" class="indexterm"/>Grid widget becomes even more powerful, however, when connected with server-side functionality to help drive its features.</p><p>The Kendo UI Framework for ASP.NET MVC includes a special object to help facilitate this functionality within standard MVC controllers. It does not require the Web API or OData, although you could use them if you want to configure the Kendo <code class="literal">DataSource</code> by hand. In this example, we will learn how to use the <code class="literal">DataSourceRequest</code> object and how it helps drive the functionality of a Kendo Grid widget.</p><p>First, add a new action method to the <code class="literal">MoviesController</code> class that we created earlier.</p><div class="informalexample"><pre class="programlisting">public ActionResult MoviesGrid([DataSourceRequest]DataSourceRequest request)
{
  return Json(
     db.Movies.ToDataSourceResult(request), JsonRequestBehavior.AllowGet);
}</pre></div><p>You should notice right away the special attribute in the signature of the action method called <code class="literal">[DataSourceRequest]</code>. This attribute comes from the <code class="literal">Kendo.Mvc.Extensions</code> namespace, so you will need to include that in a <code class="literal">using</code> statement at the top of the controller. This attribute is necessary for the Kendo UI Framework to properly understand the communication between the Grid widget and this server-side action method. It is also important <a id="id786" class="indexterm"/>that the <code class="literal">[DataSourceRequest]</code> attribute is decorating a <code class="literal">DataSourceRequest</code> object and that the return value from this action method is passed through the extension method called <code class="literal">ToDataSourceResult(request)</code>. These special methods drive the Kendo functionality for data binding, sorting, paging and filtering.</p><p>With this code in place, add a new action method to the <code class="literal">KendoController</code> called <code class="literal">Grid</code>, which will be the action method we use for the view.</p><div class="informalexample"><pre class="programlisting">public ActionResult Grid()
{
  return View();
}</pre></div><p>Create a view for this method and place the following Razor code inside it:</p><div class="informalexample"><pre class="programlisting">@using Kendo.Mvc.UI;

@{
    ViewBag.Title = "Grid";
}

@(Html.Kendo().Grid&lt;Chapter11.Models.Movie&gt;().Name("moviesGrid")
    .Columns(columns =&gt;
        {
            columns.Bound(p =&gt; p.Name);
            columns.Bound(p =&gt; p.ReleaseYear);
            columns.Bound(p =&gt; p.Rating);
            columns.Bound(p =&gt; p.Rank);
        }
        )
    .Pageable()
    .Sortable()
    .Filterable()
    .DataSource(dataSource =&gt; dataSource
        .Ajax()
        .PageSize(5)
        .Read(read =&gt; read.Action("MoviesGrid", "Movies"))
    ))</pre></div><p>As you have seen before, this <code class="literal">Html</code> helper method from the Kendo UI Framework generates a Grid widget on the view page. We have configured the columns and enabled the Grid to be <code class="literal">pageable</code>, <code class="literal">sortable</code>, and <code class="literal">filterable</code>. The significant part for this example is that we have set the <code class="literal">DataSource</code> object to point to the <code class="literal">MoviesGrid</code> action of the <code class="literal">Movies</code> controller, which we set up earlier with the special Kendo attribute and objects. When we run our project and navigate to this new view, we get a Kendo Grid widget like the following, which has working paging buttons, filter buttons, and sortable column headings:</p><div class="mediaobject"><img src="graphics/4346OT_11_06.jpg" alt="Using DataSourceRequest with Kendo Grid"/></div><p>Unlike in <a class="link" href="ch01.html" title="Chapter 1. Interacting with Data: DataSource, Templates, TabStrip, and Grid">Chapter 1</a>, <span class="emphasis"><em>Interacting with Data: DataSource, Templates, TabStrip, and Grid</em></span>, however, this Grid widget is asking the server to calculate the sort order, the pages, and the filtered results. It does this by sending special data instructions to the server that are interpreted by the special <a id="id787" class="indexterm"/>Kendo attribute and objects. To see these data instructions, you can turn on the Internet Explorer developer tools by pressing the <span class="emphasis"><em>F12</em></span> key while the website is running. In the toolbar that appears, click on the <span class="strong"><strong>Network</strong></span> tab and then click <span class="strong"><strong>Start Capturing</strong></span>. After clicking these buttons, click on one of the Grid functions, such as the page arrow or one of the column headings. You will see some activity in the developer toolbar, which means that the Grid is communicating with the server through JavaScript AJAX calls. Double-click on the first item in the list that shows the address <span class="strong"><strong>/Movies/MoviesGrid</strong></span>, as shown here:</p><div class="mediaobject"><img src="graphics/4346OT_11_07.jpg" alt="Using DataSourceRequest with Kendo Grid"/></div><p>Double-clicking this item will open up a detailed description of the HTTP request. Click on the <span class="strong"><strong>Request body</strong></span> tab to see what the Grid sent to the server:</p><div class="mediaobject"><img src="graphics/4346OT_11_08.jpg" alt="Using DataSourceRequest with Kendo Grid"/></div><p>You can see here that the Grid has asked for page number <code class="literal">2</code> with a page size of <code class="literal">5</code> records. This is how the Kendo Grid <a id="id788" class="indexterm"/>communicates with the server, through the HTTP request body.</p></div>
<div class="section" title="Driving the ListView with Web API"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Driving the ListView with Web API</h1></div></div></div><p>Similar to the Grid widget, <a id="id789" class="indexterm"/>the ListView widget is able to utilize<a id="id790" class="indexterm"/> the <code class="literal">[DataSourceRequest]</code> attribute to help drive special functionality for its operations. In this case, we will not simply be querying the data from the server, but also editing it with the Web API.</p><p>Create an action method for our ListView example in the <code class="literal">KendoController</code> class, as shown here:</p><div class="informalexample"><pre class="programlisting">private MoviesContext db = new MoviesContext();

public ActionResult ListView()
{
  return View(db.Movies);
}</pre></div><p>Then add a view for this action method and add the following HTML markup inside:</p><div class="informalexample"><pre class="programlisting">@using Kendo.Mvc.UI;

@model IEnumerable&lt;Chapter11.Models.Movie&gt;

@{
    ViewBag.Title = "ListView";
}
&lt;script type="text/x-kendo-tmpl" id="template"&gt;
    &lt;div class="movie-view"&gt;
        &lt;dl&gt;
            &lt;dt&gt;Name&lt;/dt&gt;
            &lt;dd&gt;${Name}&lt;/dd&gt;
            &lt;dt&gt;Rating&lt;/dt&gt;
            &lt;dd&gt;${Rating}&lt;/dd&gt;
            &lt;dt&gt;Rank&lt;/dt&gt;
            &lt;dd&gt;${Rank}&lt;/dd&gt;
        &lt;/dl&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;a class="k-button k-button-icontext k-edit-button"
            href="\\#"&gt;&lt;span class="k-icon k-edit"&gt;&lt;/span&gt;Edit&lt;/a&gt;
        &lt;a class="k-button k-button-icontext k-delete-button"
            href="\\#"&gt;&lt;span class="k-icon k-delete"&gt;&lt;/span&gt;Delete&lt;/a&gt;
    &lt;/div&gt;
&lt;/script&gt;
&lt;h2&gt;ListView&lt;/h2&gt;</pre></div><p>This basic HTML and Kendo template will be used to build the page once the data has been retrieved. You<a id="id791" class="indexterm"/> can see how the template is simply showing each element of a <code class="literal">Movie</code> object and then providing the edit and delete buttons. Next, add the following MVC Razor code at the bottom of this view to wire everything together:</p><div class="informalexample"><pre class="programlisting">@(Html.Kendo().ListView(Model)
    .Name("moviesListView")
    .TagName("div")
    .ClientTemplateId("template")
    .Editable()
    .DataSource(dataSource =&gt; {
        dataSource
            .Read(read =&gt; read.Action("MoviesGrid", "Movies"))
            .Update(update =&gt; update.Type(HttpVerbs.Post)
              .Url("/api/MovieApi"))
            .PageSize(5)
            .Model(config =&gt; config.Id("Id"));
    })
    .Pageable())</pre></div><p>Here, we have created a Kendo ListView, specified the ID of the template to use when rendering it on the page, marked it as editable, and specified the data source. Inside of the data source, we have indicated where to retrieve the data to display (the <code class="literal">Read</code> method) and where to send updated data (the <code class="literal">Update</code> method).</p><p>Next, we need to create an editor template for the <code class="literal">Movie</code> object, so that this ListView can edit our <code class="literal">Movie</code> objects. <a id="id792" class="indexterm"/>Make a new folder under the <code class="literal">Views/Shared</code> folder called <code class="literal">EditorTemplates</code>. Then, add a view to the <code class="literal">EditorTemplates</code> folder and call it <code class="literal">Movie.cshtml</code>.</p><div class="mediaobject"><img src="graphics/4346OT_11_11.jpg" alt="Driving the ListView with Web API"/></div><p>Open the <code class="literal">Movie.cshtml</code> view file and add the following code there:</p><div class="informalexample"><pre class="programlisting">@model Chapter11.Models.Movie

&lt;div class="movie-view"&gt;
    &lt;dl&gt;
        &lt;dt&gt;Name&lt;/dt&gt;
        &lt;dd&gt;@Html.EditorFor(model =&gt; model.Name)&lt;/dd&gt;
        &lt;dt&gt;Rating&lt;/dt&gt;
        &lt;dd&gt;@Html.EditorFor(model =&gt; model.Rating)&lt;/dd&gt;
        &lt;dt&gt;Rank&lt;/dt&gt;
        &lt;dd&gt;@Html.EditorFor(model =&gt; model.Rank)&lt;/dd&gt;
    &lt;/dl&gt;
    &lt;div&gt;
        &lt;a class="k-button k-button-icontext k-update-button"
            href="\\#"&gt;&lt;span class="k-icon k-update"&gt;&lt;/span&gt;Save&lt;/a&gt;
        &lt;a class="k-button k-button-icontext k-cancel-button"
            href="\\#"&gt;&lt;span class="k-icon k-cancel"&gt;&lt;/span&gt;Cancel&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This view will be used by the ListView widget when the <span class="strong"><strong>Edit</strong></span> button is clicked on a <code class="literal">Movie</code> item. The<a id="id793" class="indexterm"/> following is how the page looks by default (when viewing the movies). You can see the different elements of a move item and the buttons used to edit or delete it:</p><div class="mediaobject"><img src="graphics/4346OT_11_09.jpg" alt="Driving the ListView with Web API"/></div><p>This is how a movie item is rendered when you click on the <span class="strong"><strong>Edit</strong></span> button. See how the fields are now rendered as we specified in the <code class="literal">EditorTemplate</code> folder for the <code class="literal">Movie</code> data type.</p><div class="mediaobject"><img src="graphics/4346OT_11_10.jpg" alt="Driving the ListView with Web API"/></div><p>Since we have wired this up to the Web API, we can observe the changes being sent to the server for processing if we set a breakpoint in Visual Studio inside the API method that is being called. You can see that I have done this in the following screenshot:</p><div class="mediaobject"><img src="graphics/4346OT_11_12.jpg" alt="Driving the ListView with Web API"/></div><p>With Visual Studio set this way, the program will stop when an update is made and you can inspect the data to observe <a id="id794" class="indexterm"/>what is happening. For a production application, you would want to use the Entity Framework to edit the <code class="literal">movie</code> object and save the changes to the database.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec66"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to use the Web API for some more realistic scenarios involving two of the Kendo widgets that deal with managing data. We also quickly explored the ASP.NET Web API fundamentals as well as Entity Framework and OData. These tools, used together, can be a very powerful set and can create nearly any custom solution that you need.</p><p>The examples we just saw, both use a special attribute that Telerik has provided to help with model binding and server-side paging and filtering. It is nice to make use of special helpers like this when they are available. I encourage you to continue to explore these technologies on your own and see how you can create your own custom solutions on your own web pages.</p></div></body></html>