<html><head></head><body>
<div id="_idContainer099" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor250" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor251" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Event-Driven Programming Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Event-driven programming </span><a id="_idIndexMarker469" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.4.1">in JavaScript is very widespread and is the only way to handle certain scenarios. </span><span class="kobospan" id="kobo.4.2">Maintaining performance and security around event listeners is of paramount importance. </span><span class="kobospan" id="kobo.4.3">Mismanaged event listeners have been a historical source of bugs and critical performance issues; we’ll address this via the event delegation pattern. </span><span class="kobospan" id="kobo.4.4">Secure messaging between frames and contexts has always been crucial in the context of payments. </span><span class="kobospan" id="kobo.4.5">More recently, new primitives are being added to the web platform and JavaScript that exposes an event/messaging interface for maintaining isolation </span><span><span class="kobospan" id="kobo.5.1">between contexts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.6.1">In this chapter, we’ll cover the </span><span><span class="kobospan" id="kobo.7.1">following topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.8.1">Implementing </span><span><span class="kobospan" id="kobo.9.1">event delegation</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.10.1">Using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.11.1">postMessage</span></strong><span class="kobospan" id="kobo.12.1"> interface to communicate across contexts with an example of a </span><span><span class="kobospan" id="kobo.13.1">payment iframe</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Common event listener antipatterns and how to </span><span><span class="kobospan" id="kobo.15.1">remediate them</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">At the end of this chapter, you’ll have learned how to use advanced event-driven programming concepts in JavaScript to keep your code performant </span><span><span class="kobospan" id="kobo.17.1">and secure.</span></span></p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor252" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.18.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.19.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.20.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.21.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<p class="calibre3"><a id="_idTextAnchor253" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-137" class="calibre5"><a id="_idTextAnchor254" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.22.1">Optimizing event listeners through event delegation</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.23.1">Event delegation</span><a id="_idIndexMarker470" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.24.1"> is a common event listener pattern used to go from “many elements, many event listeners” to a “many elements, single event listener.” </span><span class="kobospan" id="kobo.24.2">At its core, event </span><a id="_idIndexMarker471" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.25.1">delegation attaches one event listener to the page’s </span><strong class="source-inline"><span class="kobospan" id="kobo.26.1">Document</span></strong><span class="kobospan" id="kobo.27.1">, and inside that listener, it checks what the </span><strong class="source-inline"><span class="kobospan" id="kobo.28.1">target</span></strong><span class="kobospan" id="kobo.29.1"> of the event is in order to figure out how the event should </span><span><span class="kobospan" id="kobo.30.1">be handled.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">Event delegation means fewer listeners are attached. </span><span class="kobospan" id="kobo.31.2">There’s only one per root node; if we’re doing event delegation at the document level, that means one listener. </span><span class="kobospan" id="kobo.31.3">Another benefit is that DOM nodes can be attached and removed without worrying about adding or removing the relevant </span><span><span class="kobospan" id="kobo.32.1">event listeners.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.33.1">The following </span><a id="_idIndexMarker472" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.34.1">sequence diagram details an implementation of listening to clicks on </span><span><span class="kobospan" id="kobo.35.1">two buttons.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer088">
<span class="kobospan" id="kobo.36.1"><img alt="Figure 8.1: Event handling without event delegation" src="image/B19109_08_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.37.1">Figure 8.1: Event handling without event delegation</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">Event handling without event delegation can be contrasted with the event delegation sequence, which instead of attaching one handler per event/element, attaches one and computes the relevant action in the </span><span><span class="kobospan" id="kobo.39.1">single listener.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer089">
<span class="kobospan" id="kobo.40.1"><img alt="Figure 8.2: Event handling with event delegation" src="image/B19109_08_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.41.1">Figure 8.2: Event handling with event delegation</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">We’ll implement </span><a id="_idIndexMarker473" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.43.1">simple event delegation for an email subscription form that is submitted via client-side JavaScript with </span><strong class="source-inline"><span class="kobospan" id="kobo.44.1">fetch</span></strong><span class="kobospan" id="kobo.45.1">. </span><span class="kobospan" id="kobo.45.2">To begin with, we’ll start laying out a form. </span><span class="kobospan" id="kobo.45.3">We have a form with the </span><strong class="source-inline"><span class="kobospan" id="kobo.46.1">data-newsletter-form</span></strong><span class="kobospan" id="kobo.47.1"> attribute, which we’ll pick up in JavaScript, a heading, a label, an email input, and a </span><span><span class="kobospan" id="kobo.48.1">submit button:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.49.1">
&lt;form data-newsletter-form&gt;
  &lt;h3&gt;Subscribe to the newsletter!&lt;/h3&gt;
  &lt;div&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input
      id="email"
      type="email"
      name="email"
      placeholder="test@example.com"
    /&gt;
  &lt;/div&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.50.1">To start on the event part of event delegation, we add a click listener to the document. </span><span class="kobospan" id="kobo.50.2">This listener switches based on </span><strong class="source-inline"><span class="kobospan" id="kobo.51.1">event.target.tagName</span></strong><span class="kobospan" id="kobo.52.1">; </span><strong class="source-inline"><span class="kobospan" id="kobo.53.1">tagName</span></strong><span class="kobospan" id="kobo.54.1"> takes uppercase values such as </span><strong class="source-inline"><span class="kobospan" id="kobo.55.1">P</span></strong><span class="kobospan" id="kobo.56.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.57.1">BUTTON</span></strong><span class="kobospan" id="kobo.58.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.59.1">DIV</span></strong><span class="kobospan" id="kobo.60.1">. </span><span class="kobospan" id="kobo.60.2">In order to make the code easier to follow, we’ll switch on the lowercase version </span><span><span class="kobospan" id="kobo.61.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.62.1">tagName</span></strong></span><span><span class="kobospan" id="kobo.63.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.64.1">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.65.1">When we detect a</span><a id="_idIndexMarker474" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.66.1"> click on a button element, we then check whether the </span><strong class="source-inline"><span class="kobospan" id="kobo.67.1">event.target</span></strong><span class="kobospan" id="kobo.68.1"> is inside a form, whether </span><strong class="source-inline"><span class="kobospan" id="kobo.69.1">event.target</span></strong><span class="kobospan" id="kobo.70.1"> is of the </span><strong class="source-inline"><span class="kobospan" id="kobo.71.1">submit</span></strong><span class="kobospan" id="kobo.72.1"> type, and whether the form that contains the event target element includes </span><strong class="source-inline"><span class="kobospan" id="kobo.73.1">newsletterForm</span></strong><span class="kobospan" id="kobo.74.1"> in its </span><strong class="source-inline"><span class="kobospan" id="kobo.75.1">dataset</span></strong><span class="kobospan" id="kobo.76.1">, in other words whether it has </span><strong class="source-inline"><span class="kobospan" id="kobo.77.1">data-newsletter-form</span></strong><span class="kobospan" id="kobo.78.1">. </span><span class="kobospan" id="kobo.78.2">In this case, we call </span><strong class="source-inline"><span class="kobospan" id="kobo.79.1">event.preventDefault</span></strong><span class="kobospan" id="kobo.80.1">. </span><span class="kobospan" id="kobo.80.2">We’ll be handling the form submission </span><span><span class="kobospan" id="kobo.81.1">using JavaScript.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.82.1">We provide some feedback to the user that the form is submitting by changing the contents of the event target button (to </span><strong class="source-inline"><span class="kobospan" id="kobo.83.1">Submitting</span></strong><span class="kobospan" id="kobo.84.1">) and we set the </span><strong class="source-inline"><span class="kobospan" id="kobo.85.1">disabled</span></strong><span class="kobospan" id="kobo.86.1"> attribute so that the form</span><a id="_idIndexMarker475" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.87.1"> can’t be submitted again until our handler </span><span><span class="kobospan" id="kobo.88.1">execution completes:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.89.1">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        const form = event.target.closest('form');
        if (
          form &amp;&amp;
          event.target.type === 'submit' &amp;&amp;
          'newsletterForm' in form.dataset
        ) {
          event.preventDefault();
          const formValues = new FormData(form);
          event.target.innerText = 'Submitting';
          event.target.setAttribute('disabled',
            'disabled');
          const email = formValues.get('email');
          return;
        }
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.90.1">When we click the </span><strong class="bold"><span class="kobospan" id="kobo.91.1">Submit</span></strong><span class="kobospan" id="kobo.92.1"> button, it </span><a id="_idIndexMarker476" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.93.1">now gets disabled, and its content is set </span><span><span class="kobospan" id="kobo.94.1">to </span></span><span><strong class="bold"><span class="kobospan" id="kobo.95.1">Submitting</span></strong></span><span><span class="kobospan" id="kobo.96.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer090">
<span class="kobospan" id="kobo.97.1"><img alt="Figure 8.3: When the Submit button is clicked, it is disabled and the text changes to Submitting" src="image/B19109_08_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.98.1">Figure 8.3: When the Submit button is clicked, it is disabled and the text changes to Submitting</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">We’ll now work on </span><a id="_idIndexMarker477" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.100.1">submitting the newsletter form. </span><span class="kobospan" id="kobo.100.2">In order to do this, we need a </span><strong class="source-inline"><span class="kobospan" id="kobo.101.1">fetch</span></strong><span class="kobospan" id="kobo.102.1">-based function that will </span><strong class="source-inline"><span class="kobospan" id="kobo.103.1">POST</span></strong><span class="kobospan" id="kobo.104.1"> the given </span><strong class="source-inline"><span class="kobospan" id="kobo.105.1">email</span></strong><span class="kobospan" id="kobo.106.1"> parameter to </span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">jsonplaceholder.typicode.com/users</span></strong><span class="kobospan" id="kobo.108.1">. </span><span class="kobospan" id="kobo.108.2">We then await the </span><strong class="source-inline"><span class="kobospan" id="kobo.109.1">fetch</span></strong><span class="kobospan" id="kobo.110.1"> promise and extract the JSON response </span><span><span class="kobospan" id="kobo.111.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.112.1">res.json()</span></strong></span><span><span class="kobospan" id="kobo.113.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.114.1">
&lt;script&gt;
  async function submitNewsletterSubscription(email) {
    const res = await fetch
      ('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      body: JSON.stringify({
        email,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    });
    return res.json();
  }
  // no change to the document "click" event listener
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.115.1">We’ll </span><a id="_idIndexMarker478" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.116.1">now extend the </span><strong class="source-inline"><span class="kobospan" id="kobo.117.1">button</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.118.1">type=submit</span></strong><span class="kobospan" id="kobo.119.1"> handler to call </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">submitNewsletterSubscription</span></strong><span class="kobospan" id="kobo.121.1">. </span><span class="kobospan" id="kobo.121.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.122.1">email</span></strong><span class="kobospan" id="kobo.123.1"> value comes from </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">formValues.get('email')</span></strong><span class="kobospan" id="kobo.125.1"> (the email field of the form). </span><span class="kobospan" id="kobo.125.2">when </span><strong class="source-inline"><span class="kobospan" id="kobo.126.1">submitNewsletterSubscription</span></strong><span class="kobospan" id="kobo.127.1"> completes successfully (i.e.. </span><span class="kobospan" id="kobo.127.2">the Promise resolves), we reset the </span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">submit</span></strong><span class="kobospan" id="kobo.129.1"> button to have the text </span><strong class="bold"><span class="kobospan" id="kobo.130.1">Submit</span></strong><span class="kobospan" id="kobo.131.1"> and to be enabled (by removing the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">disabled</span></strong></span><span><span class="kobospan" id="kobo.133.1"> attribute):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.134.1">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        const form = event.target.closest('form');
        if (
          form &amp;&amp;
          event.target.type === 'submit' &amp;&amp;
          'newsletterForm' in form.dataset
        ) {
          // no change to existing logic
          const email = formValues.get('email');
          submitNewsletterSubscription(email).then((result) =&gt; {
            event.target.innerText = 'Submit';
            event.target.removeAttribute('disabled');
          });
        }
        return;
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.135.1">To highlight</span><a id="_idIndexMarker479" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.136.1"> the requests/responses, we’ll add a </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">storeLogEvent</span></strong><span class="kobospan" id="kobo.138.1"> function and an API request/response log to </span><span><span class="kobospan" id="kobo.139.1">our page:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.140.1">
&lt;div style="height: 300px; overflow: scroll"&gt;
  &lt;h3&gt;API Request/Response Log&lt;/h3&gt;
  &lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;script&gt;
  // no change to other functionality
  function storeLogEvent(value) {
    $requestLog = document.querySelector('pre code');
    $requestLog.innerText += value;
    $logParent = $requestLog.closest('div');
    $logParent.scrollTo({ top: $logParent.scrollTopMax,
      behavior: 'smooth' });
  }
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.141.1">We can</span><a id="_idIndexMarker480" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.142.1"> then use </span><strong class="source-inline"><span class="kobospan" id="kobo.143.1">storeLogEvent</span></strong><span class="kobospan" id="kobo.144.1"> before and after </span><span><span class="kobospan" id="kobo.145.1">calling </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.146.1">submitNewsletterSubscription</span></strong></span><span><span class="kobospan" id="kobo.147.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.148.1">
// -&gt; inside the listener
// -&gt; switch
// -&gt; case 'button'
// -&gt; if (form in ancestors &amp;&amp; button type === submit &amp;&amp;
   form has data-newsletter-form)
const email = formValues.get('email');
storeLogEvent(`Request: ${email}`);
submitNewsletterSubscription(email).then((result) =&gt; {
  storeLogEvent(`\nResponse: ${JSON.stringify(result,
    null, 2)}\n\n`);
  event.target.innerText = 'Submit';
  event.target.removeAttribute('disabled');
});</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.149.1">Now, when we</span><a id="_idIndexMarker481" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.150.1"> click </span><strong class="bold"><span class="kobospan" id="kobo.151.1">Submit</span></strong><span class="kobospan" id="kobo.152.1"> with an email address in the input, it gets </span><strong class="source-inline"><span class="kobospan" id="kobo.153.1">POST</span></strong><span class="kobospan" id="kobo.154.1">-ed to </span><strong class="source-inline"><span class="kobospan" id="kobo.155.1">jsonplaceholder</span></strong><span class="kobospan" id="kobo.156.1"> and we get a response back, as we can see in the </span><span><span class="kobospan" id="kobo.157.1">following screenshot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer091">
<span class="kobospan" id="kobo.158.1"><img alt="Figure 8.4: When we enter an email and click Submit, we the API response is displayed" src="image/B19109_08_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.159.1">Figure 8.4: When we enter an email and click Submit, we the API response is displayed</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.160.1">To showcase the</span><a id="_idIndexMarker482" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.161.1"> benefit of event delegation in a situation where DOM elements can get dynamically added, we’ll create an </span><strong class="bold"><span class="kobospan" id="kobo.162.1">Add a form</span></strong><span class="kobospan" id="kobo.163.1"> button that will append an additional newsletter form to </span><span><span class="kobospan" id="kobo.164.1">the document.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.165.1">First, we add a </span><strong class="source-inline"><span class="kobospan" id="kobo.166.1">button</span></strong><span class="kobospan" id="kobo.167.1"> with </span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">data-add-form</span></strong><span class="kobospan" id="kobo.169.1">, we’ll use the data attribute to detect and handle clicks on </span><span><span class="kobospan" id="kobo.170.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.171.1">button</span></strong></span><span><span class="kobospan" id="kobo.172.1">.</span></span></p>
<pre class="source-code">
<strong class="source-inline2"><span class="kobospan1" id="kobo.173.1">&lt;button data-add-form&gt;Add a form!&lt;/button&gt;</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.174.1">Next, we’ll handle</span><a id="_idIndexMarker483" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.175.1"> clicks on elements with our </span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">data-add-form</span></strong><span class="kobospan" id="kobo.177.1"> attribute by adding </span><strong class="source-inline"><span class="kobospan" id="kobo.178.1">if ('addForm' in event.target.dataset)</span></strong><span class="kobospan" id="kobo.179.1">. </span><span class="kobospan" id="kobo.179.2">For now, we’ll return early to prevent any further handling code </span><span><span class="kobospan" id="kobo.180.1">from executing:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.181.1">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        if ('addForm' in event.target.dataset) {
          return;
        }
        // no change to newsletter form handling
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.182.1">We want to implement the add form functionality, and we want to find a </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">data-newsletter-form</span></strong><span class="kobospan" id="kobo.184.1"> element and clone it </span><span><span class="kobospan" id="kobo.185.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.186.1">.cloneNode(true)</span></strong></span><span><span class="kobospan" id="kobo.187.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.188.1">We’ll append a random number inside the heading so we can identify when new forms are added and reset the email input. </span><span class="kobospan" id="kobo.188.2">Finally, we append the new node to the </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">document.body</span></strong><span class="kobospan" id="kobo.190.1"> element </span><span><span class="kobospan" id="kobo.191.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">.appendChild</span></strong></span><span><span class="kobospan" id="kobo.193.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.194.1">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        if ('addForm' in event.target.dataset) {
          const $newsletterFormTemplate = document.
</span><span class="kobospan1" id="kobo.194.2">            querySelector(
            '[data-newsletter-form]',
          );
          const newForm = $newsletterFormTemplate.
</span><span class="kobospan1" id="kobo.194.3">            cloneNode(true);
          newForm.querySelector('h3').innerText += `
            (${Math.floor(
            Math.random() * 100,
          )})`;
          newForm.querySelector('[name=email]').value = '';
          document.body.appendChild(newForm);
          return;
        }
        // no change to newsletter form handling
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.195.1">With no changes to</span><a id="_idIndexMarker484" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.196.1"> the handling of the newsletter form submission, the cloned form functions just as the initial </span><span><span class="kobospan" id="kobo.197.1">one does.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer092">
<span class="kobospan" id="kobo.198.1"><img alt="Figure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! button" src="image/B19109_08_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.199.1">Figure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! </span><span class="kobospan" id="kobo.199.2">button</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.200.1">We’ve now seen </span><a id="_idIndexMarker485" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.201.1">how to implement event delegation to prevent having to add event listeners manually to dynamically added DOM nodes. </span><span class="kobospan" id="kobo.201.2">Next, we’ll look at patterns that use the </span><strong class="source-inline"><span class="kobospan" id="kobo.202.1">postMessage</span></strong><span class="kobospan" id="kobo.203.1"> interface </span><span><span class="kobospan" id="kobo.204.1">betwe</span><a id="_idTextAnchor255" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.205.1">en iframes.</span></span></p>
<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor256" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.206.1">Patterns for secure frame/native WebView bridge messaging</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.207.1">Gaining a </span><a id="_idIndexMarker486" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.208.1">deep understanding of messaging patterns with </span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">postMessage</span></strong><span class="kobospan" id="kobo.210.1"> in JavaScript is crucial for working in a variety of contexts. </span><strong class="source-inline"><span class="kobospan" id="kobo.211.1">postMessage</span></strong><span class="kobospan" id="kobo.212.1"> is defined on the following Web API objects: </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">Window</span></strong><span class="kobospan" id="kobo.214.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.215.1">MessagePort</span></strong><span class="kobospan" id="kobo.216.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">Worker</span></strong><span class="kobospan" id="kobo.218.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">Client</span></strong><span class="kobospan" id="kobo.220.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">ServiceWorker</span></strong><span class="kobospan" id="kobo.222.1">, </span><span><span class="kobospan" id="kobo.223.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">BroadcastChannel</span></strong></span><span><span class="kobospan" id="kobo.225.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.226.1">In other words, </span><strong class="source-inline"><span class="kobospan" id="kobo.227.1">postMessage</span></strong><span class="kobospan" id="kobo.228.1">-based messaging is useful for document-to-iframe, iframe-to-iframe, document-to-worker, and service worker-to-document communication and that’s only the Web APIs. </span><span class="kobospan" id="kobo.228.2">Due to how widespread the </span><strong class="source-inline"><span class="kobospan" id="kobo.229.1">postMessage</span></strong><span class="kobospan" id="kobo.230.1"> API is, it’s also adopted in non-standard APIs for handling multiple JavaScript contexts. </span><span class="kobospan" id="kobo.230.2">For example, web extensions for Chrome and Firefox contain multiple JavaScript contexts: the devtools panel, proxy, backend, and background script. </span><span class="kobospan" id="kobo.230.3">The </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">postMessage</span></strong><span class="kobospan" id="kobo.232.1"> API is also used for Android and iOS communication between the native code </span><span><span class="kobospan" id="kobo.233.1">and WebViews.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.234.1">The scenario that we’ll go through is about iframes and how they communicate. </span><span class="kobospan" id="kobo.234.2">A common e-commerce use-case is integrating a third-party payment service provider’s hosted card capture form into their e-commerce website. </span><span class="kobospan" id="kobo.234.3">By using a payment service provider and not knowing the customer’s card payment details, the e-commerce vendor can </span><a id="_idIndexMarker487" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.235.1">meet </span><strong class="bold"><span class="kobospan" id="kobo.236.1">Payment Card Industry Data Security Standard</span></strong><span class="kobospan" id="kobo.237.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.238.1">PCI DSS</span></strong><span class="kobospan" id="kobo.239.1">) compliance </span><span><span class="kobospan" id="kobo.240.1">more easily.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">The container or parent document will be a checkout form, inside of which we’ll iframe a hosted card capture document. </span><span class="kobospan" id="kobo.241.2">The two documents will communicate with </span><strong class="source-inline"><span class="kobospan" id="kobo.242.1">postMessage</span></strong><span class="kobospan" id="kobo.243.1">. </span><span class="kobospan" id="kobo.243.2">The container document will not read the card details in cleartext. </span><span class="kobospan" id="kobo.243.3">Instead, it will receive a public-key encrypted payload (which can only be decrypted via the paired </span><span><span class="kobospan" id="kobo.244.1">private key).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">Without being careful, it’s possible for </span><strong class="source-inline"><span class="kobospan" id="kobo.246.1">iframe</span></strong><span class="kobospan" id="kobo.247.1"> initialization to cause race conditions. </span><span class="kobospan" id="kobo.247.2">To work around this, we’ll implement the following </span><span><span class="kobospan" id="kobo.248.1">initialization scheme.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.249.1">Initially, we’ll load a container document with an </span><strong class="source-inline"><span class="kobospan" id="kobo.250.1">iframe</span></strong><span class="kobospan" id="kobo.251.1"> that has no </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">src</span></strong><span class="kobospan" id="kobo.253.1">. </span><span class="kobospan" id="kobo.253.2">Only after we’ve added important event listeners to the </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">iframe</span></strong><span class="kobospan" id="kobo.255.1"> element, will we add </span><strong class="source-inline"><span class="kobospan" id="kobo.256.1">src</span></strong><span class="kobospan" id="kobo.257.1">. </span><span class="kobospan" id="kobo.257.2">This </span><a id="_idIndexMarker488" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.258.1">means that the </span><strong class="source-inline"><span class="kobospan" id="kobo.259.1">iframe</span></strong><span class="kobospan" id="kobo.260.1"> can’t load before our listeners </span><span><span class="kobospan" id="kobo.261.1">are attached.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer093">
<span class="kobospan" id="kobo.262.1"><img alt="Figure 8.6: Sequence diagram of initialization messaging" src="image/B19109_08_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.263.1">Figure 8.6: Sequence diagram of initialization messaging</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.264.1">We need two files, one at </span><strong class="source-inline"><span class="kobospan" id="kobo.265.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.266.1"> (which will be our application shell) and one at </span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">frame-content.html</span></strong><span class="kobospan" id="kobo.268.1"> (which will represent our </span><span><span class="kobospan" id="kobo.269.1">iframe’s contents).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.270.1">Some payment service provider integrations won’t require a fully custom </span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">iframe</span></strong><span class="kobospan" id="kobo.272.1"> (sometimes, a JavaScript SDK is provided that helps manage the </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">iframe</span></strong><span class="kobospan" id="kobo.274.1"> part of it), but the important thing is that the </span><strong class="source-inline"><span class="kobospan" id="kobo.275.1">iframe</span></strong><span class="kobospan" id="kobo.276.1"> is loaded from an origin (server) that is owned by the payment service provider. </span><span class="kobospan" id="kobo.276.2">We won’t be able to represent this since we’re </span><span><span class="kobospan" id="kobo.277.1">working locally.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.278.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.280.1"> HTML</span><a id="_idIndexMarker489" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.281.1"> looks as follows: a few headings, a </span><strong class="source-inline"><span class="kobospan" id="kobo.282.1">form</span></strong><span class="kobospan" id="kobo.283.1">, an </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">input type=email</span></strong><span class="kobospan" id="kobo.285.1">, an </span><strong class="source-inline"><span class="kobospan" id="kobo.286.1">iframe</span></strong><span class="kobospan" id="kobo.287.1">, and a submit button. </span><span class="kobospan" id="kobo.287.2">Note that the </span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">iframe</span></strong><span class="kobospan" id="kobo.289.1"> element doesn’t have a </span><strong class="source-inline"><span class="kobospan" id="kobo.290.1">src</span></strong><span class="kobospan" id="kobo.291.1"> attribute. </span><span class="kobospan" id="kobo.291.2">We’ll add that via JavaScript to prevent </span><span><span class="kobospan" id="kobo.292.1">race conditions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.293.1">
&lt;form&gt;
  &lt;h2&gt;Checkout form&lt;/h2&gt;
  &lt;div&gt;
    &lt;span&gt;Price: &lt;span&gt;200&lt;/span&gt;€&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;h3&gt;Customer Details&lt;/h3&gt;
    &lt;div&gt;
      &lt;label for="email"&gt;Email&lt;/label&gt;
      &lt;input id="email" type="email" name="email"
        required="required" /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;iframe id="payment-capture" width="100%"
      height="300px"&gt;&lt;/iframe&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;button type="submit"&gt;Pay&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.294.1">To prevent race </span><a id="_idIndexMarker490" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.295.1">conditions when loading the </span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">iframe</span></strong><span class="kobospan" id="kobo.297.1">, we haven’t set the </span><strong class="source-inline"><span class="kobospan" id="kobo.298.1">src</span></strong><span class="kobospan" id="kobo.299.1"> in the HTML. </span><span class="kobospan" id="kobo.299.2">We want to prevent situations where the </span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">iframe</span></strong><span class="kobospan" id="kobo.301.1"> could load before we’ve attached a </span><strong class="source-inline"><span class="kobospan" id="kobo.302.1">load</span></strong><span class="kobospan" id="kobo.303.1"> event handler </span><span><span class="kobospan" id="kobo.304.1">to it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.305.1">We start by adding a </span><strong class="source-inline"><span class="kobospan" id="kobo.306.1">message</span></strong><span class="kobospan" id="kobo.307.1"> event listener to the </span><span><span class="kobospan" id="kobo.308.1">container window:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.309.1">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        case 'init': {
          console.log('Parent received init message');
          return;
        }
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.310.1">Next, we’ll select the payment capture </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">iframe</span></strong><span class="kobospan" id="kobo.312.1"> and add a </span><strong class="source-inline"><span class="kobospan" id="kobo.313.1">load</span></strong><span class="kobospan" id="kobo.314.1"> event listener to the iframe element. </span><span class="kobospan" id="kobo.314.2">Our handler will send an </span><strong class="source-inline"><span class="kobospan" id="kobo.315.1">init</span></strong><span class="kobospan" id="kobo.316.1"> message with some data to the </span><strong class="source-inline"><span class="kobospan" id="kobo.317.1">iframe</span></strong> <span><span class="kobospan" id="kobo.318.1">element’s </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.319.1">contentWindow</span></strong></span><span><span class="kobospan" id="kobo.320.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.321.1">
&lt;script&gt;
  // no change to the message listener
  const $paymentCaptureIframe = document.querySelector
   ('#payment-capture');
  // on iframe load, we'll send a message
  $paymentCaptureIframe.addEventListener('load', () =&gt; {
    $paymentCaptureIframe.contentWindow.postMessage(
      JSON.stringify({ type: 'init', data: { price: 20000,
        currency: 'EUR' } }),
    );
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.322.1">Finally, we can set the </span><strong class="source-inline"><span class="kobospan" id="kobo.323.1">iframe</span></strong><span class="kobospan" id="kobo.324.1"> element’s </span><strong class="source-inline"><span class="kobospan" id="kobo.325.1">src</span></strong><span class="kobospan" id="kobo.326.1"> attribute so that </span><span><span class="kobospan" id="kobo.327.1">it loads:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.328.1">
&lt;script&gt;
  // no change to message and iframe load listeners
  $paymentCaptureIframe.setAttribute(
    'src',
    new URL('/frame-content.html', window.location.origin),
  );
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.329.1">We now need to implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.330.1">frame-content.html</span></strong><span class="kobospan" id="kobo.331.1"> file to receive the message we sent. </span><span class="kobospan" id="kobo.331.2">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.332.1">iframe</span></strong><span class="kobospan" id="kobo.333.1">, again is mostly a heading and a form with multiple fields. </span><span class="kobospan" id="kobo.333.2">We have </span><strong class="source-inline"><span class="kobospan" id="kobo.334.1">type=hidden</span></strong><span class="kobospan" id="kobo.335.1"> inputs for the price </span><a id="_idIndexMarker491" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.336.1">and currency, as well as text inputs for the card number, expiry date, and </span><strong class="bold"><span class="kobospan" id="kobo.337.1">card verification value</span></strong><span class="kobospan" id="kobo.338.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.339.1">CVV</span></strong><span class="kobospan" id="kobo.340.1">) code. </span><span class="kobospan" id="kobo.340.2">We also include a </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">Messages</span></strong><span class="kobospan" id="kobo.342.1"> section to</span><a id="_idIndexMarker492" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.343.1"> illustrate which messages are being sent and received by </span><span><span class="kobospan" id="kobo.344.1">the iframe:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.345.1">
&lt;h2&gt;Payment iframe&lt;/h2&gt;
&lt;form&gt;
  &lt;input type="hidden" name="price" /&gt;
  &lt;input type="hidden" name="currency" /&gt;
  &lt;div&gt;
    &lt;label for="cardnumber"&gt;Card Number&lt;/label&gt;
    &lt;input required="required" name="cardnumber"
      id="cardnumber" type="text" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for="cardexpiry"&gt;Expiry Date&lt;/label&gt;
    &lt;input required="required" name="cardexpiry"
      id="cardexpiry" type="text" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for="cardcvv"&gt;CVV&lt;/label&gt;
    &lt;input name="cardcvv" id="cardcvv" type="text" /&gt;
  &lt;/div&gt;
&lt;/form&gt;
&lt;div&gt;
  &lt;h3&gt;Messages&lt;/h3&gt;
  &lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.346.1">In order to </span><a id="_idIndexMarker493" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.347.1">handle messages from the parent frame, we’ll add a </span><strong class="source-inline"><span class="kobospan" id="kobo.348.1">message</span></strong><span class="kobospan" id="kobo.349.1"> event listener. </span><span class="kobospan" id="kobo.349.2">It stores all received messages in the </span><strong class="source-inline"><span class="kobospan" id="kobo.350.1">pre code</span></strong><span class="kobospan" id="kobo.351.1"> element we </span><span><span class="kobospan" id="kobo.352.1">defined earlier.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.353.1">If the </span><strong class="source-inline"><span class="kobospan" id="kobo.354.1">event.data.type</span></strong><span class="kobospan" id="kobo.355.1"> is </span><strong class="source-inline"><span class="kobospan" id="kobo.356.1">init</span></strong><span class="kobospan" id="kobo.357.1">, we set the value of our </span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">price</span></strong><span class="kobospan" id="kobo.359.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.360.1">currency</span></strong></span><span><span class="kobospan" id="kobo.361.1"> inputs:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.362.1">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    document.querySelector('pre code').innerText +=
      `Received: ${event.data}\n`;
    const { type, data } = JSON.parse(event.data);
    switch (type) {
      case 'init': {
        document.querySelector('[name=price]').value =
          data.price;
        document.querySelector('[name=currency]').value =
          data.currency;
        return;
      }
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.363.1">Finally, we </span><a id="_idIndexMarker494" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.364.1">send an </span><strong class="source-inline"><span class="kobospan" id="kobo.365.1">init</span></strong><span class="kobospan" id="kobo.366.1"> message when our script finished running. </span><span class="kobospan" id="kobo.366.2">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.367.1">window.parent.postMessage</span></strong><span class="kobospan" id="kobo.368.1"> to </span><span><span class="kobospan" id="kobo.369.1">achieve this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.370.1">
&lt;script&gt;
  // no change to the message event listener
  const initMessage = JSON.stringify({ type: 'init' });
  document.querySelector('pre code').innerText += `Sent:
    ${initMessage}\n`;
  window.parent.postMessage(initMessage);
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.371.1">With this </span><a id="_idIndexMarker495" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.372.1">code in place, when we load the </span><strong class="source-inline"><span class="kobospan" id="kobo.373.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.374.1"> file in a browser, we see the following. </span><span class="kobospan" id="kobo.374.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.375.1">iframe</span></strong><span class="kobospan" id="kobo.376.1"> has sent an </span><strong class="source-inline"><span class="kobospan" id="kobo.377.1">init</span></strong><span class="kobospan" id="kobo.378.1"> message and received one </span><span><span class="kobospan" id="kobo.379.1">as well.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer094">
<span class="kobospan" id="kobo.380.1"><img alt="Figure 8.7: Container and iframe contents in their initial state" src="image/B19109_08_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.381.1">Figure 8.7: Container and iframe contents in their initial state</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.382.1">When we submit the container, we’ll want to ensure the card details are retrieved by the </span><strong class="source-inline"><span class="kobospan" id="kobo.383.1">iframe</span></strong><span class="kobospan" id="kobo.384.1"> and passed back to the container. </span><span class="kobospan" id="kobo.384.2">These details will be encrypted by the </span><strong class="source-inline"><span class="kobospan" id="kobo.385.1">iframe</span></strong><span class="kobospan" id="kobo.386.1"> (which, in our scenario, will be served from a domain from the payment service provider) before being sent to the </span><span><span class="kobospan" id="kobo.387.1">parent document.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.388.1">The following diagram details the </span><span><span class="kobospan" id="kobo.389.1">expected interactions.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer095">
<span class="kobospan" id="kobo.390.1"><img alt="Figure 8.8: Container and iframe communication sequence diagram during user interaction" src="image/B19109_08_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.391.1">Figure 8.8: Container and iframe communication sequence diagram during user interaction</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.392.1">The key change</span><a id="_idIndexMarker496" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.393.1"> we have to make to the container is to listen for a submit event on the </span><strong class="source-inline"><span class="kobospan" id="kobo.394.1">form</span></strong><span class="kobospan" id="kobo.395.1"> element. </span><span class="kobospan" id="kobo.395.2">We then send a message with </span><strong class="source-inline"><span class="kobospan" id="kobo.396.1">type="submit"</span></strong><span class="kobospan" id="kobo.397.1"> to </span><span><span class="kobospan" id="kobo.398.1">the iframe:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.399.1">
&lt;script&gt;
  // no message to iframe initialization code
  document.querySelector('form').addEventListener('submit',
    (event) =&gt; {
    event.preventDefault();
    $paymentCaptureIframe.contentWindow.postMessage(
      JSON.stringify({
        type: 'submit',
      }),
    );
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.400.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.401.1">iframe</span></strong><span class="kobospan" id="kobo.402.1"> receives the message and we’ll need to extend our </span><strong class="source-inline"><span class="kobospan" id="kobo.403.1">message</span></strong><span class="kobospan" id="kobo.404.1"> event handler to react to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">submit</span></strong></span><span><span class="kobospan" id="kobo.406.1"> message:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.407.1">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    // no change outside of the switch
    switch (type) {
      case 'submit': {
        $form = document.querySelector('form');
        const isFormValid = $form.reportValidity();
        if (!isFormValid) {
          const fields = [...$form];
          const invalidFields = fields
            .filter((f) =&gt; f.type !== 'hidden' &amp;&amp;
              !f.validity?.valid)
            .map((f) =&gt; f.name);
          const message = JSON.stringify({
            type: 'validation-error',
            data: invalidFields,
          });
          window.parent.postMessage(message);
          document.querySelector('pre code').innerText +=
            `Sent: ${message}\n`;
          return;
        }
      }
      // no change to other "case" statements
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.408.1">Now that we’ve </span><a id="_idIndexMarker497" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.409.1">implemented a new </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">iframe</span></strong><span class="kobospan" id="kobo.411.1"> to container “validation error” message, we need to handle that message type in </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.413.1">. </span><span class="kobospan" id="kobo.413.2">In this case, we’ve already done everything that’s necessary in the </span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">submit</span></strong><span class="kobospan" id="kobo.415.1"> form event handler (which calls </span><strong class="source-inline"><span class="kobospan" id="kobo.416.1">preventDefault()</span></strong><span class="kobospan" id="kobo.417.1">), so we’ll simply log out the </span><span><span class="kobospan" id="kobo.418.1">message contents:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.419.1">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        // no change to other "case" statements
        case 'validation-error': {
          console.log('Received message', type, data);
          return;
        }
      }
    }
  });</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.420.1">We can now</span><a id="_idIndexMarker498" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.421.1"> attempt to click </span><strong class="bold"><span class="kobospan" id="kobo.422.1">Pay</span></strong><span class="kobospan" id="kobo.423.1"> with the card number and card expiry empty, which yields the following state, where both fields are in the </span><strong class="source-inline"><span class="kobospan" id="kobo.424.1">validation-error</span></strong><span class="kobospan" id="kobo.425.1"> message as received by the </span><span><span class="kobospan" id="kobo.426.1">frame parent.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer096">
<span class="kobospan" id="kobo.427.1"><img alt="Figure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card number field" src="image/B19109_08_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.428.1">Figure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. </span><span class="kobospan" id="kobo.428.2">Also, note the HTML validation error message for the card number field</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.429.1">If we then </span><a id="_idIndexMarker499" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.430.1">enter the card number but still don’t enter the expiry date, then the second </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">validation-error</span></strong><span class="kobospan" id="kobo.432.1"> message only contains the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">cardexpiry</span></strong></span><span><span class="kobospan" id="kobo.434.1"> field:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer097">
<span class="kobospan" id="kobo.435.1"><img alt="Figure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card expiry field" src="image/B19109_08_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.436.1">Figure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. </span><span class="kobospan" id="kobo.436.2">Also, note the HTML validation error message for the card expiry field</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.437.1">We need </span><a id="_idIndexMarker500" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.438.1">a function to take a string (in our case containing a JSON-encoded JavaScript object) and turn it into a base64-encoded ciphertext (encrypted string in base64 format). </span><span class="kobospan" id="kobo.438.2">The payment service provider usually would manage this encryption, so we wouldn’t need this function or to fetch </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">public-key.json</span></strong><span class="kobospan" id="kobo.440.1"> to enable RSA-OAEP (asymmetric) encryption in </span><span><span class="kobospan" id="kobo.441.1">the browser.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.442.1">The code will convert the string to a Uint8Array, fetch a public key, and import it in order to use it with </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">crypto.subtle.encrypt</span></strong><span class="kobospan" id="kobo.444.1">. </span><span class="kobospan" id="kobo.444.2">We encrypt the message string (that was converted to a Uint8Array). </span><span class="kobospan" id="kobo.444.3">This yields an </span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">ArrayBuffer</span></strong><span class="kobospan" id="kobo.446.1"> that we encode to base64 by creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">Uint8Array</span></strong><span class="kobospan" id="kobo.448.1"> object with our data, converting it back to an array and for each character, looking up the relevant character code. </span><span class="kobospan" id="kobo.448.2">Once we have a string containing the character codes, we </span><span><span class="kobospan" id="kobo.449.1">base64-encode it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.450.1">
&lt;script&gt;
  async function encryptToBase64(message) {
    const msgUint8 = new TextEncoder().encode(message);
    const publicKeyExport = await fetch
      ('./public-key.json').then((res) =&gt;
      res.json(),
    );
    const publicKey = await crypto.subtle.importKey(
      'jwk',
      publicKeyExport,
      {
        name: 'RSA-OAEP',
        hash: 'SHA-256',
      },
      true,
      ['encrypt'],
    );
    const encryptedBuffer = await crypto.subtle.encrypt(
      {
        name: 'RSA-OAEP',
      },
      publicKey,
      msgUint8,
    );
    return btoa(
      return [...new Uint8Array(encryptedBuffer)]
        .map((el) =&gt; String.fromCharCode(el))
        .join(''),
    );
  }
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.451.1">We can now use the </span><strong class="source-inline"><span class="kobospan" id="kobo.452.1">encryptToBase64</span></strong><span class="kobospan" id="kobo.453.1"> function in our </span><strong class="source-inline"><span class="kobospan" id="kobo.454.1">type=submit</span></strong><span class="kobospan" id="kobo.455.1"> message-handling</span><a id="_idIndexMarker501" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.456.1"> code. </span><span class="kobospan" id="kobo.456.2">Once the validation passes, we’ll serialize the data using </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">FormData</span></strong><span class="kobospan" id="kobo.458.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">FormData().entries()</span></strong><span class="kobospan" id="kobo.460.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.461.1">Object.fromEntries</span></strong><span class="kobospan" id="kobo.462.1">. </span><span class="kobospan" id="kobo.462.2">We stringify it before encrypting it to a </span><span><span class="kobospan" id="kobo.463.1">base64 ciphertext.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.464.1">Finally, we send a </span><strong class="source-inline"><span class="kobospan" id="kobo.465.1">type=submit-reponse</span></strong><span class="kobospan" id="kobo.466.1"> message to the container document with the encrypted string as </span><span><span class="kobospan" id="kobo.467.1">the payload:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.468.1">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    // no change outside of the switch
    switch (type) {
      case 'submit': {
        $form = document.querySelector('form');
        // no change to form validity validation
        const data = new FormData($form);
        const serializableData = Object.fromEntries
          (data.entries());
        const message = JSON.stringify({
          type: 'submit-response',
          data: await encryptToBase64
            (JSON.stringify(serializableData)),
        });
        window.parent.postMessage(message);
        document.querySelector('pre code').innerText +=
          `Sent: ${message}\n`;
        return;
      }
      // no change to other "case" statements
    }
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.469.1">We now need to</span><a id="_idIndexMarker502" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.470.1"> handle the </span><strong class="source-inline"><span class="kobospan" id="kobo.471.1">type=submit-response</span></strong><span class="kobospan" id="kobo.472.1"> message in </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">iframe-parent.html</span></strong><span class="kobospan" id="kobo.474.1">. </span><span class="kobospan" id="kobo.474.2">Again, we’re just extending our </span><strong class="source-inline"><span class="kobospan" id="kobo.475.1">switch(type)</span></strong><span class="kobospan" id="kobo.476.1"> statement with an additional case for </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">submit-response</span></strong><span class="kobospan" id="kobo.478.1">. </span><span class="kobospan" id="kobo.478.2">We’ll log some messages, including the </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">event.data</span></strong><span class="kobospan" id="kobo.480.1"> and extract the values from the container </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">form</span></strong><span class="kobospan" id="kobo.482.1"> element using </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">FormData().entries()</span></strong><span class="kobospan" id="kobo.484.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.485.1">Object.fromEntries()</span></strong><span class="kobospan" id="kobo.486.1">. </span><span class="kobospan" id="kobo.486.2">At this point, we could send the </span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">event.data</span></strong><span class="kobospan" id="kobo.488.1"> and the container form data to a backend endpoint to complete </span><span><span class="kobospan" id="kobo.489.1">the transaction:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.490.1">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        // no change to other "case" statements
        case 'submit-response': {
          console.log('received submit-response');
          console.log(event.data);
          const formData = new FormData
            (document.querySelector('form'));
          Const pageData = Object.fromEntries
            (formData.entries());
          return;
        }
      }
    }
  });</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.491.1">We can see this</span><a id="_idIndexMarker503" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.492.1"> in action when we fill out the customer email and the payment details form and </span><span><span class="kobospan" id="kobo.493.1">click </span></span><span><strong class="bold"><span class="kobospan" id="kobo.494.1">Pay</span></strong></span><span><span class="kobospan" id="kobo.495.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer098">
<span class="kobospan" id="kobo.496.1"><img alt="Figure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives" src="image/B19109_08_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.497.1">Figure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.498.1">In order to avoid untrusted frames from sending arbitrary messages, we should check </span><strong class="source-inline"><span class="kobospan" id="kobo.499.1">event.origin</span></strong><span class="kobospan" id="kobo.500.1"> against </span><span><span class="kobospan" id="kobo.501.1">an allowlist.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.502.1">We’ll add this as a guard clause in the </span><strong class="source-inline"><span class="kobospan" id="kobo.503.1">window.addEventListener</span></strong><span class="kobospan" id="kobo.504.1"> in both </span><strong class="source-inline"><span class="kobospan" id="kobo.505.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.506.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.507.1">frame-content.html</span></strong><span class="kobospan" id="kobo.508.1">. </span><span class="kobospan" id="kobo.508.2">We’ll check the message origins against our allowlist. </span><span class="kobospan" id="kobo.508.3">If the </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">event.origin</span></strong><span class="kobospan" id="kobo.510.1"> is not in the allowlist, we log a warning and discard the message by doing an </span><span><span class="kobospan" id="kobo.511.1">early return.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.512.1">In the case of local development, the origin will be </span><strong class="source-inline"><span class="kobospan" id="kobo.513.1">'http://127.0.0.1:8000'</span></strong><span class="kobospan" id="kobo.514.1"> for both interactions. </span><span class="kobospan" id="kobo.514.2">As throughout this section, in a production use case, the allowed origin for receiving messages in the container window (</span><strong class="source-inline"><span class="kobospan" id="kobo.515.1">frame-parent.html</span></strong><span class="kobospan" id="kobo.516.1">) would be a domain managed by the payment service provider. </span><span class="kobospan" id="kobo.516.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.517.1">frame-content.html</span></strong><span class="kobospan" id="kobo.518.1"> equivalent would be what the payment service provider hosts, so the allowed </span><a id="_idIndexMarker504" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.519.1">domain would be the URL of the </span><span><span class="kobospan" id="kobo.520.1">container application:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.521.1">
&lt;script&gt;
  // handle receiving messages from iframe -&gt; parent
  const allowedMessageOrigins = ['http://127.0.0.1:8000'];
  window.addEventListener('message', (event) =&gt; {
    if (!allowedMessageOrigins.includes(event.origin)) {
      console.warn(
        `Dropping message due to non-allowlisted origin
          ${event.origin}`,
        event,
      );
      return;
    }
    // no change to the rest of the message handler
  });
&lt;/script&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.522.1">We’ve now seen how to implement secure messaging between an iframe and the page that contains it. </span><span class="kobospan" id="kobo.522.2">Next, we’ll recap on event listener </span><span><span class="kobospan" id="kobo.523.1">pe</span><a id="_idTextAnchor257" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.524.1">rformance anti-patterns.</span></span></p>
<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor258" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.525.1">Event listener performance antipatterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.526.1">Event listener performance antipatterns</span><a id="_idIndexMarker505" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.527.1"> change over time. </span><span class="kobospan" id="kobo.527.2">For example, when Internet Explorer support was broadly required due to its market share, adding event listeners to DOM nodes and subsequently deleting the nodes would not clean up the event listeners, causing memory leaks. </span><span class="kobospan" id="kobo.527.3">This doesn’t occur anymore in </span><span><span class="kobospan" id="kobo.528.1">modern browsers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.529.1">An event listener antipattern</span><a id="_idIndexMarker506" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.530.1"> that is often caught by the Lighthouse page performance auditing tool is </span><strong class="source-inline"><span class="kobospan" id="kobo.531.1">scroll</span></strong><span class="kobospan" id="kobo.532.1"> event listeners that aren’t set to be passive. </span><span class="kobospan" id="kobo.532.2">Passive event listeners are more performant because </span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">event.preventDefault()</span></strong><span class="kobospan" id="kobo.534.1"> doesn’t intercept and stop the event’s default behavior. </span><span class="kobospan" id="kobo.534.2">This allows browsers to set the event listener to be non-blocking since the listener can’t act on </span><span><span class="kobospan" id="kobo.535.1">the event.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.536.1">Making an event listener passive simply involves passing </span><strong class="source-inline"><span class="kobospan" id="kobo.537.1">{ passive: true }</span></strong><span class="kobospan" id="kobo.538.1"> as the third parameter </span><span><span class="kobospan" id="kobo.539.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">addEventListener()</span></strong></span><span><span class="kobospan" id="kobo.541.1">:</span></span></p>
<pre class="source-code">
<strong class="source-inline2"><span class="kobospan1" id="kobo.542.1">document.addEventListener(</span></strong>
<strong class="source-inline2"><span class="kobospan1" id="kobo.543.1">  'scroll',</span></strong>
<strong class="source-inline2"><span class="kobospan1" id="kobo.544.1">  (event) =&gt; {},</span></strong>
<strong class="source-inline2"><span class="kobospan1" id="kobo.545.1">  { passive: true }</span></strong>
<strong class="source-inline2"><span class="kobospan1" id="kobo.546.1">);</span></strong></pre> <p class="calibre3"><span class="kobospan" id="kobo.547.1">Another antipattern is to forgo using debounce or throttle on the event listener handler for high-volume events (scroll is a good example). </span><span class="kobospan" id="kobo.547.2">We covered how to implement debounce and throttle in </span><a href="B19109_07.xhtml#_idTextAnchor238" class="pcalibre1 calibre6 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.548.1">Chapter 7</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.549.1">, Asynchronous Programming Performance Patterns</span></em><span class="kobospan" id="kobo.550.1">, in the </span><em class="italic"><span class="kobospan" id="kobo.551.1">Throttling, debouncing and batching asynchronous </span></em><span><em class="italic"><span class="kobospan" id="kobo.552.1">operations</span></em></span><span><span class="kobospan" id="kobo.553.1"> section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.554.1">The final antipattern is solved by event delegation. </span><span class="kobospan" id="kobo.554.2">At some amount of DOM nodes and event listeners, adding one event listener per potential target starts causing performance implications. </span><span class="kobospan" id="kobo.554.3">Luckily, event delegation solves this problem. </span><span class="kobospan" id="kobo.554.4">It allows us to attach one event listener per event type while maintaining the ability to handle each </span><span><span class="kobospan" id="kobo.555.1">target differently.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.556.1">We’ve now covered event listener performance antipatterns to keep an eye out for </span><a id="_idTextAnchor259" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.557.1">and how to </span><span><span class="kobospan" id="kobo.558.1">remediate them.</span></span></p>
<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor260" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.559.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.560.1">In this chapter, we’ve covered advanced event-driven programming patterns to keep a JavaScript code base performant and secure when handling large numbers of events and </span><span><span class="kobospan" id="kobo.561.1">event listeners.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.562.1">Event delegation is useful to ensure that the number of event listeners doesn’t grow with the number of DOM nodes in a client-side application where elements are inserted and </span><span><span class="kobospan" id="kobo.563.1">removed dynamically.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.564.1">Patterns for secure frame messaging mean we’re able to orchestrate </span><strong class="source-inline"><span class="kobospan" id="kobo.565.1">iframe</span></strong><span class="kobospan" id="kobo.566.1"> initialization and bidirectional communication between an </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">iframe</span></strong><span class="kobospan" id="kobo.568.1"> and its </span><span><span class="kobospan" id="kobo.569.1">parent document.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.570.1">Finally, we covered common event listener performance antipatterns to avoid the common pitfalls of event listener-heavy </span><span><span class="kobospan" id="kobo.571.1">code bases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.572.1">Now that we’re familiar with advanced event-driven programming patterns in JavaScript, in the next chapter, we’ll cover lazy-loading and code-splitting to maximize the performance of </span><span><span class="kobospan" id="kobo.573.1">JavaScript applications.</span></span></p>
</div>
</body></html>