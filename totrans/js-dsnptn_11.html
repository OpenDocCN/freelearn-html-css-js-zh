<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-134"><a id="_idTextAnchor250" class="pcalibre1 calibre6 pcalibre"/>8</h1>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor251" class="pcalibre1 calibre6 pcalibre"/>Event-Driven Programming Patterns</h1>
<p class="calibre3">Event-driven programming <a id="_idIndexMarker469" class="pcalibre1 calibre6 pcalibre"/>in JavaScript is very widespread and is the only way to handle certain scenarios. Maintaining performance and security around event listeners is of paramount importance. Mismanaged event listeners have been a historical source of bugs and critical performance issues; we’ll address this via the event delegation pattern. Secure messaging between frames and contexts has always been crucial in the context of payments. More recently, new primitives are being added to the web platform and JavaScript that exposes an event/messaging interface for maintaining isolation between contexts.</p>
<p class="calibre3">In this chapter, we’ll cover the following topics:</p>
<ul class="calibre10">
<li class="calibre11">Implementing event delegation</li>
<li class="calibre11">Using the <strong class="source-inline1">postMessage</strong> interface to communicate across contexts with an example of a payment iframe</li>
<li class="calibre11">Common event listener antipatterns and how to remediate them</li>
</ul>
<p class="calibre3">At the end of this chapter, you’ll have learned how to use advanced event-driven programming concepts in JavaScript to keep your code performant and secure.</p>
<h1 id="_idParaDest-136" class="calibre5"><a id="_idTextAnchor252" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<p class="calibre3"><a id="_idTextAnchor253" class="pcalibre1 calibre6 pcalibre"/></p>
<h1 id="_idParaDest-137" class="calibre5"><a id="_idTextAnchor254" class="pcalibre1 calibre6 pcalibre"/>Optimizing event listeners through event delegation</h1>
<p class="calibre3">Event delegation<a id="_idIndexMarker470" class="pcalibre1 calibre6 pcalibre"/> is a common event listener pattern used to go from “many elements, many event listeners” to a “many elements, single event listener.” At its core, event <a id="_idIndexMarker471" class="pcalibre1 calibre6 pcalibre"/>delegation attaches one event listener to the page’s <code>Document</code>, and inside that listener, it checks what the <code>target</code> of the event is in order to figure out how the event should be handled.</p>
<p class="calibre3">Event delegation means fewer listeners are attached. There’s only one per root node; if we’re doing event delegation at the document level, that means one listener. Another benefit is that DOM nodes can be attached and removed without worrying about adding or removing the relevant event listeners.</p>
<p class="calibre3">The following <a id="_idIndexMarker472" class="pcalibre1 calibre6 pcalibre"/>sequence diagram details an implementation of listening to clicks on two buttons.</p>
<div><div><img alt="Figure 8.1: Event handling without event delegation" src="img/B19109_08_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1: Event handling without event delegation</p>
<p class="calibre3">Event handling without event delegation can be contrasted with the event delegation sequence, which instead of attaching one handler per event/element, attaches one and computes the relevant action in the single listener.</p>
<div><div><img alt="Figure 8.2: Event handling with event delegation" src="img/B19109_08_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2: Event handling with event delegation</p>
<p class="calibre3">We’ll implement <a id="_idIndexMarker473" class="pcalibre1 calibre6 pcalibre"/>simple event delegation for an email subscription form that is submitted via client-side JavaScript with <code>fetch</code>. To begin with, we’ll start laying out a form. We have a form with the <code>data-newsletter-form</code> attribute, which we’ll pick up in JavaScript, a heading, a label, an email input, and a submit button:</p>
<pre class="source-code">
&lt;form data-newsletter-form&gt;
  &lt;h3&gt;Subscribe to the newsletter!&lt;/h3&gt;
  &lt;div&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
    &lt;input
      id="email"
      type="email"
      name="email"
      placeholder="test@example.com"
    /&gt;
  &lt;/div&gt;
  &lt;button type="submit"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</pre> <p class="calibre3">To start on the event part of event delegation, we add a click listener to the document. This listener switches based on <code>event.target.tagName</code>; <code>tagName</code> takes uppercase values such as <code>P</code>, <code>BUTTON</code>, and <code>DIV</code>. In order to make the code easier to follow, we’ll switch on the lowercase version of <code>tagName</code>:</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">When we detect a<a id="_idIndexMarker474" class="pcalibre1 calibre6 pcalibre"/> click on a button element, we then check whether the <code>event.target</code> is inside a form, whether <code>event.target</code> is of the <code>submit</code> type, and whether the form that contains the event target element includes <code>newsletterForm</code> in its <code>dataset</code>, in other words whether it has <code>data-newsletter-form</code>. In this case, we call <code>event.preventDefault</code>. We’ll be handling the form submission using JavaScript.</p>
<p class="calibre3">We provide some feedback to the user that the form is submitting by changing the contents of the event target button (to <code>Submitting</code>) and we set the <code>disabled</code> attribute so that the form<a id="_idIndexMarker475" class="pcalibre1 calibre6 pcalibre"/> can’t be submitted again until our handler execution completes:</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        const form = event.target.closest('form');
        if (
          form &amp;&amp;
          event.target.type === 'submit' &amp;&amp;
          'newsletterForm' in form.dataset
        ) {
          event.preventDefault();
          const formValues = new FormData(form);
          event.target.innerText = 'Submitting';
          event.target.setAttribute('disabled',
            'disabled');
          const email = formValues.get('email');
          return;
        }
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">When we click the <strong class="bold">Submit</strong> button, it <a id="_idIndexMarker476" class="pcalibre1 calibre6 pcalibre"/>now gets disabled, and its content is set to <strong class="bold">Submitting</strong>.</p>
<div><div><img alt="Figure 8.3: When the Submit button is clicked, it is disabled and the text changes to Submitting" src="img/B19109_08_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3: When the Submit button is clicked, it is disabled and the text changes to Submitting</p>
<p class="calibre3">We’ll now work on <a id="_idIndexMarker477" class="pcalibre1 calibre6 pcalibre"/>submitting the newsletter form. In order to do this, we need a <code>fetch</code>-based function that will <code>POST</code> the given <code>email</code> parameter to <code>jsonplaceholder.typicode.com/users</code>. We then await the <code>fetch</code> promise and extract the JSON response using <code>res.json()</code>:</p>
<pre class="source-code">
&lt;script&gt;
  async function submitNewsletterSubscription(email) {
    const res = await fetch
      ('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      body: JSON.stringify({
        email,
      }),
      headers: {
        'Content-type': 'application/json; charset=UTF-8',
      },
    });
    return res.json();
  }
  // no change to the document "click" event listener
&lt;/script&gt;</pre> <p class="calibre3">We’ll <a id="_idIndexMarker478" class="pcalibre1 calibre6 pcalibre"/>now extend the <code>button</code> <code>type=submit</code> handler to call <code>submitNewsletterSubscription</code>. The <code>email</code> value comes from <code>formValues.get('email')</code> (the email field of the form). when <code>submitNewsletterSubscription</code> completes successfully (i.e.. the Promise resolves), we reset the <code>submit</code> button to have the text <code>disabled</code> attribute):</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        const form = event.target.closest('form');
        if (
          form &amp;&amp;
          event.target.type === 'submit' &amp;&amp;
          'newsletterForm' in form.dataset
        ) {
          // no change to existing logic
          const email = formValues.get('email');
          submitNewsletterSubscription(email).then((result) =&gt; {
            event.target.innerText = 'Submit';
            event.target.removeAttribute('disabled');
          });
        }
        return;
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">To highlight<a id="_idIndexMarker479" class="pcalibre1 calibre6 pcalibre"/> the requests/responses, we’ll add a <code>storeLogEvent</code> function and an API request/response log to our page:</p>
<pre class="source-code">
&lt;div style="height: 300px; overflow: scroll"&gt;
  &lt;h3&gt;API Request/Response Log&lt;/h3&gt;
  &lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;script&gt;
  // no change to other functionality
  function storeLogEvent(value) {
    $requestLog = document.querySelector('pre code');
    $requestLog.innerText += value;
    $logParent = $requestLog.closest('div');
    $logParent.scrollTo({ top: $logParent.scrollTopMax,
      behavior: 'smooth' });
  }
&lt;/script&gt;</pre> <p class="calibre3">We can<a id="_idIndexMarker480" class="pcalibre1 calibre6 pcalibre"/> then use <code>storeLogEvent</code> before and after calling <code>submitNewsletterSubscription</code>:</p>
<pre class="source-code">
// -&gt; inside the listener
// -&gt; switch
// -&gt; case 'button'
// -&gt; if (form in ancestors &amp;&amp; button type === submit &amp;&amp;
   form has data-newsletter-form)
const email = formValues.get('email');
storeLogEvent(`Request: ${email}`);
submitNewsletterSubscription(email).then((result) =&gt; {
  storeLogEvent(`\nResponse: ${JSON.stringify(result,
    null, 2)}\n\n`);
  event.target.innerText = 'Submit';
  event.target.removeAttribute('disabled');
});</pre> <p class="calibre3">Now, when we<a id="_idIndexMarker481" class="pcalibre1 calibre6 pcalibre"/> click <code>POST</code>-ed to <code>jsonplaceholder</code> and we get a response back, as we can see in the following screenshot:</p>
<div><div><img alt="Figure 8.4: When we enter an email and click Submit, we the API response is displayed" src="img/B19109_08_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4: When we enter an email and click Submit, we the API response is displayed</p>
<p class="calibre3">To showcase the<a id="_idIndexMarker482" class="pcalibre1 calibre6 pcalibre"/> benefit of event delegation in a situation where DOM elements can get dynamically added, we’ll create an <strong class="bold">Add a form</strong> button that will append an additional newsletter form to the document.</p>
<p class="calibre3">First, we add a <code>button</code> with <code>data-add-form</code>, we’ll use the data attribute to detect and handle clicks on the <code>button</code>.</p>
<pre class="source-code">
<code>data-add-form</code> attribute by adding <code>if ('addForm' in event.target.dataset)</code>. For now, we’ll return early to prevent any further handling code from executing:</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        if ('addForm' in event.target.dataset) {
          return;
        }
        // no change to newsletter form handling
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">We want to implement the add form functionality, and we want to find a <code>data-newsletter-form</code> element and clone it using <code>.cloneNode(true)</code>.</p>
<p class="calibre3">We’ll append a random number inside the heading so we can identify when new forms are added and reset the email input. Finally, we append the new node to the <code>document.body</code> element using <code>.appendChild</code>:</p>
<pre class="source-code">
&lt;script&gt;
  document.addEventListener('click', (event) =&gt; {
    switch (event.target.tagName?.toLowerCase()) {
      case 'button': {
        if ('addForm' in event.target.dataset) {
          const $newsletterFormTemplate = document.
            querySelector(
            '[data-newsletter-form]',
          );
          const newForm = $newsletterFormTemplate.
            cloneNode(true);
          newForm.querySelector('h3').innerText += `
            (${Math.floor(
            Math.random() * 100,
          )})`;
          newForm.querySelector('[name=email]').value = '';
          document.body.appendChild(newForm);
          return;
        }
        // no change to newsletter form handling
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">With no changes to<a id="_idIndexMarker484" class="pcalibre1 calibre6 pcalibre"/> the handling of the newsletter form submission, the cloned form functions just as the initial one does.</p>
<div><div><img alt="Figure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! button" src="img/B19109_08_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5: The effect of submit on multiple forms, one of which was added with an Add a form! button</p>
<p class="calibre3">We’ve now seen <a id="_idIndexMarker485" class="pcalibre1 calibre6 pcalibre"/>how to implement event delegation to prevent having to add event listeners manually to dynamically added DOM nodes. Next, we’ll look at patterns that use the <code>postMessage</code> interface betwe<a id="_idTextAnchor255" class="pcalibre1 calibre6 pcalibre"/>en iframes.</p>
<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor256" class="pcalibre1 calibre6 pcalibre"/>Patterns for secure frame/native WebView bridge messaging</h1>
<p class="calibre3">Gaining a <a id="_idIndexMarker486" class="pcalibre1 calibre6 pcalibre"/>deep understanding of messaging patterns with <code>postMessage</code> in JavaScript is crucial for working in a variety of contexts. <code>postMessage</code> is defined on the following Web API objects: <code>Window</code>, <code>MessagePort</code>, <code>Worker</code>, <code>Client</code>, <code>ServiceWorker</code>, and <code>BroadcastChannel</code>.</p>
<p class="calibre3">In other words, <code>postMessage</code>-based messaging is useful for document-to-iframe, iframe-to-iframe, document-to-worker, and service worker-to-document communication and that’s only the Web APIs. Due to how widespread the <code>postMessage</code> API is, it’s also adopted in non-standard APIs for handling multiple JavaScript contexts. For example, web extensions for Chrome and Firefox contain multiple JavaScript contexts: the devtools panel, proxy, backend, and background script. The <code>postMessage</code> API is also used for Android and iOS communication between the native code and WebViews.</p>
<p class="calibre3">The scenario that we’ll go through is about iframes and how they communicate. A common e-commerce use-case is integrating a third-party payment service provider’s hosted card capture form into their e-commerce website. By using a payment service provider and not knowing the customer’s card payment details, the e-commerce vendor can <a id="_idIndexMarker487" class="pcalibre1 calibre6 pcalibre"/>meet <strong class="bold">Payment Card Industry Data Security Standard</strong> (<strong class="bold">PCI DSS</strong>) compliance more easily.</p>
<p class="calibre3">The container or parent document will be a checkout form, inside of which we’ll iframe a hosted card capture document. The two documents will communicate with <code>postMessage</code>. The container document will not read the card details in cleartext. Instead, it will receive a public-key encrypted payload (which can only be decrypted via the paired private key).</p>
<p class="calibre3">Without being careful, it’s possible for <code>iframe</code> initialization to cause race conditions. To work around this, we’ll implement the following initialization scheme.</p>
<p class="calibre3">Initially, we’ll load a container document with an <code>iframe</code> that has no <code>src</code>. Only after we’ve added important event listeners to the <code>iframe</code> element, will we add <code>src</code>. This <a id="_idIndexMarker488" class="pcalibre1 calibre6 pcalibre"/>means that the <code>iframe</code> can’t load before our listeners are attached.</p>
<div><div><img alt="Figure 8.6: Sequence diagram of initialization messaging" src="img/B19109_08_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6: Sequence diagram of initialization messaging</p>
<p class="calibre3">We need two files, one at <code>frame-parent.html</code> (which will be our application shell) and one at <code>frame-content.html</code> (which will represent our iframe’s contents).</p>
<p class="calibre3">Some payment service provider integrations won’t require a fully custom <code>iframe</code> (sometimes, a JavaScript SDK is provided that helps manage the <code>iframe</code> part of it), but the important thing is that the <code>iframe</code> is loaded from an origin (server) that is owned by the payment service provider. We won’t be able to represent this since we’re working locally.</p>
<p class="calibre3">Our <code>frame-parent.html</code> HTML<a id="_idIndexMarker489" class="pcalibre1 calibre6 pcalibre"/> looks as follows: a few headings, a <code>form</code>, an <code>input type=email</code>, an <code>iframe</code>, and a submit button. Note that the <code>iframe</code> element doesn’t have a <code>src</code> attribute. We’ll add that via JavaScript to prevent race conditions:</p>
<pre class="source-code">
&lt;form&gt;
  &lt;h2&gt;Checkout form&lt;/h2&gt;
  &lt;div&gt;
    &lt;span&gt;Price: &lt;span&gt;200&lt;/span&gt;€&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;h3&gt;Customer Details&lt;/h3&gt;
    &lt;div&gt;
      &lt;label for="email"&gt;Email&lt;/label&gt;
      &lt;input id="email" type="email" name="email"
        required="required" /&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;iframe id="payment-capture" width="100%"
      height="300px"&gt;&lt;/iframe&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;button type="submit"&gt;Pay&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre> <p class="calibre3">To prevent race <a id="_idIndexMarker490" class="pcalibre1 calibre6 pcalibre"/>conditions when loading the <code>iframe</code>, we haven’t set the <code>src</code> in the HTML. We want to prevent situations where the <code>iframe</code> could load before we’ve attached a <code>load</code> event handler to it.</p>
<p class="calibre3">We start by adding a <code>message</code> event listener to the container window:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        case 'init': {
          console.log('Parent received init message');
          return;
        }
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">Next, we’ll select the payment capture <code>iframe</code> and add a <code>load</code> event listener to the iframe element. Our handler will send an <code>init</code> message with some data to the <code>iframe</code> element’s <code>contentWindow</code>:</p>
<pre class="source-code">
&lt;script&gt;
  // no change to the message listener
  const $paymentCaptureIframe = document.querySelector
   ('#payment-capture');
  // on iframe load, we'll send a message
  $paymentCaptureIframe.addEventListener('load', () =&gt; {
    $paymentCaptureIframe.contentWindow.postMessage(
      JSON.stringify({ type: 'init', data: { price: 20000,
        currency: 'EUR' } }),
    );
  });
&lt;/script&gt;</pre> <p class="calibre3">Finally, we can set the <code>iframe</code> element’s <code>src</code> attribute so that it loads:</p>
<pre class="source-code">
&lt;script&gt;
  // no change to message and iframe load listeners
  $paymentCaptureIframe.setAttribute(
    'src',
    new URL('/frame-content.html', window.location.origin),
  );
&lt;/script&gt;</pre> <p class="calibre3">We now need to implement the <code>frame-content.html</code> file to receive the message we sent. Our <code>iframe</code>, again is mostly a heading and a form with multiple fields. We have <code>type=hidden</code> inputs for the price <a id="_idIndexMarker491" class="pcalibre1 calibre6 pcalibre"/>and currency, as well as text inputs for the card number, expiry date, and <code>Messages</code> section to<a id="_idIndexMarker492" class="pcalibre1 calibre6 pcalibre"/> illustrate which messages are being sent and received by the iframe:</p>
<pre class="source-code">
&lt;h2&gt;Payment iframe&lt;/h2&gt;
&lt;form&gt;
  &lt;input type="hidden" name="price" /&gt;
  &lt;input type="hidden" name="currency" /&gt;
  &lt;div&gt;
    &lt;label for="cardnumber"&gt;Card Number&lt;/label&gt;
    &lt;input required="required" name="cardnumber"
      id="cardnumber" type="text" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for="cardexpiry"&gt;Expiry Date&lt;/label&gt;
    &lt;input required="required" name="cardexpiry"
      id="cardexpiry" type="text" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for="cardcvv"&gt;CVV&lt;/label&gt;
    &lt;input name="cardcvv" id="cardcvv" type="text" /&gt;
  &lt;/div&gt;
&lt;/form&gt;
&lt;div&gt;
  &lt;h3&gt;Messages&lt;/h3&gt;
  &lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</pre> <p class="calibre3">In order to <a id="_idIndexMarker493" class="pcalibre1 calibre6 pcalibre"/>handle messages from the parent frame, we’ll add a <code>message</code> event listener. It stores all received messages in the <code>pre code</code> element we defined earlier.</p>
<p class="calibre3">If the <code>event.data.type</code> is <code>init</code>, we set the value of our <code>price</code> and <code>currency</code> inputs:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    document.querySelector('pre code').innerText +=
      `Received: ${event.data}\n`;
    const { type, data } = JSON.parse(event.data);
    switch (type) {
      case 'init': {
        document.querySelector('[name=price]').value =
          data.price;
        document.querySelector('[name=currency]').value =
          data.currency;
        return;
      }
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">Finally, we <a id="_idIndexMarker494" class="pcalibre1 calibre6 pcalibre"/>send an <code>init</code> message when our script finished running. We use <code>window.parent.postMessage</code> to achieve this:</p>
<pre class="source-code">
&lt;script&gt;
  // no change to the message event listener
  const initMessage = JSON.stringify({ type: 'init' });
  document.querySelector('pre code').innerText += `Sent:
    ${initMessage}\n`;
  window.parent.postMessage(initMessage);
&lt;/script&gt;</pre> <p class="calibre3">With this <a id="_idIndexMarker495" class="pcalibre1 calibre6 pcalibre"/>code in place, when we load the <code>frame-parent.html</code> file in a browser, we see the following. The <code>iframe</code> has sent an <code>init</code> message and received one as well.</p>
<div><div><img alt="Figure 8.7: Container and iframe contents in their initial state" src="img/B19109_08_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.7: Container and iframe contents in their initial state</p>
<p class="calibre3">When we submit the container, we’ll want to ensure the card details are retrieved by the <code>iframe</code> and passed back to the container. These details will be encrypted by the <code>iframe</code> (which, in our scenario, will be served from a domain from the payment service provider) before being sent to the parent document.</p>
<p class="calibre3">The following diagram details the expected interactions.</p>
<div><div><img alt="Figure 8.8: Container and iframe communication sequence diagram during user interaction" src="img/B19109_08_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.8: Container and iframe communication sequence diagram during user interaction</p>
<p class="calibre3">The key change<a id="_idIndexMarker496" class="pcalibre1 calibre6 pcalibre"/> we have to make to the container is to listen for a submit event on the <code>form</code> element. We then send a message with <code>type="submit"</code> to the iframe:</p>
<pre class="source-code">
&lt;script&gt;
  // no message to iframe initialization code
  document.querySelector('form').addEventListener('submit',
    (event) =&gt; {
    event.preventDefault();
    $paymentCaptureIframe.contentWindow.postMessage(
      JSON.stringify({
        type: 'submit',
      }),
    );
  });
&lt;/script&gt;</pre> <p class="calibre3">The <code>iframe</code> receives the message and we’ll need to extend our <code>message</code> event handler to react to the <code>submit</code> message:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    // no change outside of the switch
    switch (type) {
      case 'submit': {
        $form = document.querySelector('form');
        const isFormValid = $form.reportValidity();
        if (!isFormValid) {
          const fields = [...$form];
          const invalidFields = fields
            .filter((f) =&gt; f.type !== 'hidden' &amp;&amp;
              !f.validity?.valid)
            .map((f) =&gt; f.name);
          const message = JSON.stringify({
            type: 'validation-error',
            data: invalidFields,
          });
          window.parent.postMessage(message);
          document.querySelector('pre code').innerText +=
            `Sent: ${message}\n`;
          return;
        }
      }
      // no change to other "case" statements
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">Now that we’ve <a id="_idIndexMarker497" class="pcalibre1 calibre6 pcalibre"/>implemented a new <code>iframe</code> to container “validation error” message, we need to handle that message type in <code>frame-parent.html</code>. In this case, we’ve already done everything that’s necessary in the <code>submit</code> form event handler (which calls <code>preventDefault()</code>), so we’ll simply log out the message contents:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        // no change to other "case" statements
        case 'validation-error': {
          console.log('Received message', type, data);
          return;
        }
      }
    }
  });</pre> <p class="calibre3">We can now<a id="_idIndexMarker498" class="pcalibre1 calibre6 pcalibre"/> attempt to click <code>validation-error</code> message as received by the frame parent.</p>
<div><div><img alt="Figure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card number field" src="img/B19109_08_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.9: If you click Pay with the card number and expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card number field</p>
<p class="calibre3">If we then <a id="_idIndexMarker499" class="pcalibre1 calibre6 pcalibre"/>enter the card number but still don’t enter the expiry date, then the second <code>validation-error</code> message only contains the <code>cardexpiry</code> field:</p>
<div><div><img alt="Figure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card expiry field" src="img/B19109_08_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.10: If you click Pay with the card number entered and the expiry date missing, a validation-error message between the iframe and the container occurs. Also, note the HTML validation error message for the card expiry field</p>
<p class="calibre3">We need <a id="_idIndexMarker500" class="pcalibre1 calibre6 pcalibre"/>a function to take a string (in our case containing a JSON-encoded JavaScript object) and turn it into a base64-encoded ciphertext (encrypted string in base64 format). The payment service provider usually would manage this encryption, so we wouldn’t need this function or to fetch <code>public-key.json</code> to enable RSA-OAEP (asymmetric) encryption in the browser.</p>
<p class="calibre3">The code will convert the string to a Uint8Array, fetch a public key, and import it in order to use it with <code>crypto.subtle.encrypt</code>. We encrypt the message string (that was converted to a Uint8Array). This yields an <code>ArrayBuffer</code> that we encode to base64 by creating a <code>Uint8Array</code> object with our data, converting it back to an array and for each character, looking up the relevant character code. Once we have a string containing the character codes, we base64-encode it:</p>
<pre class="source-code">
&lt;script&gt;
  async function encryptToBase64(message) {
    const msgUint8 = new TextEncoder().encode(message);
    const publicKeyExport = await fetch
      ('./public-key.json').then((res) =&gt;
      res.json(),
    );
    const publicKey = await crypto.subtle.importKey(
      'jwk',
      publicKeyExport,
      {
        name: 'RSA-OAEP',
        hash: 'SHA-256',
      },
      true,
      ['encrypt'],
    );
    const encryptedBuffer = await crypto.subtle.encrypt(
      {
        name: 'RSA-OAEP',
      },
      publicKey,
      msgUint8,
    );
    return btoa(
      return [...new Uint8Array(encryptedBuffer)]
        .map((el) =&gt; String.fromCharCode(el))
        .join(''),
    );
  }
&lt;/script&gt;</pre> <p class="calibre3">We can now use the <code>encryptToBase64</code> function in our <code>type=submit</code> message-handling<a id="_idIndexMarker501" class="pcalibre1 calibre6 pcalibre"/> code. Once the validation passes, we’ll serialize the data using <code>FormData</code>, <code>FormData().entries()</code>, and <code>Object.fromEntries</code>. We stringify it before encrypting it to a base64 ciphertext.</p>
<p class="calibre3">Finally, we send a <code>type=submit-reponse</code> message to the container document with the encrypted string as the payload:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', async (event) =&gt; {
    // no change outside of the switch
    switch (type) {
      case 'submit': {
        $form = document.querySelector('form');
        // no change to form validity validation
        const data = new FormData($form);
        const serializableData = Object.fromEntries
          (data.entries());
        const message = JSON.stringify({
          type: 'submit-response',
          data: await encryptToBase64
            (JSON.stringify(serializableData)),
        });
        window.parent.postMessage(message);
        document.querySelector('pre code').innerText +=
          `Sent: ${message}\n`;
        return;
      }
      // no change to other "case" statements
    }
  });
&lt;/script&gt;</pre> <p class="calibre3">We now need to<a id="_idIndexMarker502" class="pcalibre1 calibre6 pcalibre"/> handle the <code>type=submit-response</code> message in <code>iframe-parent.html</code>. Again, we’re just extending our <code>switch(type)</code> statement with an additional case for <code>submit-response</code>. We’ll log some messages, including the <code>event.data</code> and extract the values from the container <code>form</code> element using <code>FormData().entries()</code> and <code>Object.fromEntries()</code>. At this point, we could send the <code>event.data</code> and the container form data to a backend endpoint to complete the transaction:</p>
<pre class="source-code">
&lt;script&gt;
  window.addEventListener('message', (event) =&gt; {
    if (event?.data) {
      const { type, data } = JSON.parse(event?.data);
      switch (type) {
        // no change to other "case" statements
        case 'submit-response': {
          console.log('received submit-response');
          console.log(event.data);
          const formData = new FormData
            (document.querySelector('form'));
          Const pageData = Object.fromEntries
            (formData.entries());
          return;
        }
      }
    }
  });</pre> <p class="calibre3">We can see this<a id="_idIndexMarker503" class="pcalibre1 calibre6 pcalibre"/> in action when we fill out the customer email and the payment details form and click <strong class="bold">Pay</strong>:</p>
<div><div><img alt="Figure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives" src="img/B19109_08_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.11: When the form is complete and Pay has been clicked, the iframe receives the submit message and sends back a submit-response message with an encrypted base64 string, which the container page receives</p>
<p class="calibre3">In order to avoid untrusted frames from sending arbitrary messages, we should check <code>event.origin</code> against an allowlist.</p>
<p class="calibre3">We’ll add this as a guard clause in the <code>window.addEventListener</code> in both <code>frame-parent.html</code> and <code>frame-content.html</code>. We’ll check the message origins against our allowlist. If the <code>event.origin</code> is not in the allowlist, we log a warning and discard the message by doing an early return.</p>
<p class="calibre3">In the case of local development, the origin will be <code>'http://127.0.0.1:8000'</code> for both interactions. As throughout this section, in a production use case, the allowed origin for receiving messages in the container window (<code>frame-parent.html</code>) would be a domain managed by the payment service provider. The <code>frame-content.html</code> equivalent would be what the payment service provider hosts, so the allowed <a id="_idIndexMarker504" class="pcalibre1 calibre6 pcalibre"/>domain would be the URL of the container application:</p>
<pre class="source-code">
&lt;script&gt;
  // handle receiving messages from iframe -&gt; parent
  const allowedMessageOrigins = ['http://127.0.0.1:8000'];
  window.addEventListener('message', (event) =&gt; {
    if (!allowedMessageOrigins.includes(event.origin)) {
      console.warn(
        `Dropping message due to non-allowlisted origin
          ${event.origin}`,
        event,
      );
      return;
    }
    // no change to the rest of the message handler
  });
&lt;/script&gt;</pre> <p class="calibre3">We’ve now seen how to implement secure messaging between an iframe and the page that contains it. Next, we’ll recap on event listener pe<a id="_idTextAnchor257" class="pcalibre1 calibre6 pcalibre"/>rformance anti-patterns.</p>
<h1 id="_idParaDest-139" class="calibre5"><a id="_idTextAnchor258" class="pcalibre1 calibre6 pcalibre"/>Event listener performance antipatterns</h1>
<p class="calibre3">Event listener performance antipatterns<a id="_idIndexMarker505" class="pcalibre1 calibre6 pcalibre"/> change over time. For example, when Internet Explorer support was broadly required due to its market share, adding event listeners to DOM nodes and subsequently deleting the nodes would not clean up the event listeners, causing memory leaks. This doesn’t occur anymore in modern browsers.</p>
<p class="calibre3">An event listener antipattern<a id="_idIndexMarker506" class="pcalibre1 calibre6 pcalibre"/> that is often caught by the Lighthouse page performance auditing tool is <code>scroll</code> event listeners that aren’t set to be passive. Passive event listeners are more performant because <code>event.preventDefault()</code> doesn’t intercept and stop the event’s default behavior. This allows browsers to set the event listener to be non-blocking since the listener can’t act on the event.</p>
<p class="calibre3">Making an event listener passive simply involves passing <code>{ passive: true }</code> as the third parameter to <code>addEventListener()</code>:</p>
<pre class="source-code">
<strong class="source-inline2">document.addEventListener(</strong>
<strong class="source-inline2">  'scroll',</strong>
<strong class="source-inline2">  (event) =&gt; {},</strong>
<strong class="source-inline2">  { passive: true }</strong>
<strong class="source-inline2">);</strong></pre> <p class="calibre3">Another antipattern is to forgo using debounce or throttle on the event listener handler for high-volume events (scroll is a good example). We covered how to implement debounce and throttle in <a href="B19109_07.xhtml#_idTextAnchor238" class="pcalibre1 calibre6 pcalibre"><em class="italic">Chapter 7</em></a><em class="italic">, Asynchronous Programming Performance Patterns</em>, in the <em class="italic">Throttling, debouncing and batching asynchronous </em><em class="italic">operations</em> section.</p>
<p class="calibre3">The final antipattern is solved by event delegation. At some amount of DOM nodes and event listeners, adding one event listener per potential target starts causing performance implications. Luckily, event delegation solves this problem. It allows us to attach one event listener per event type while maintaining the ability to handle each target differently.</p>
<p class="calibre3">We’ve now covered event listener performance antipatterns to keep an eye out for <a id="_idTextAnchor259" class="pcalibre1 calibre6 pcalibre"/>and how to remediate them.</p>
<h1 id="_idParaDest-140" class="calibre5"><a id="_idTextAnchor260" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we’ve covered advanced event-driven programming patterns to keep a JavaScript code base performant and secure when handling large numbers of events and event listeners.</p>
<p class="calibre3">Event delegation is useful to ensure that the number of event listeners doesn’t grow with the number of DOM nodes in a client-side application where elements are inserted and removed dynamically.</p>
<p class="calibre3">Patterns for secure frame messaging mean we’re able to orchestrate <code>iframe</code> initialization and bidirectional communication between an <code>iframe</code> and its parent document.</p>
<p class="calibre3">Finally, we covered common event listener performance antipatterns to avoid the common pitfalls of event listener-heavy code bases.</p>
<p class="calibre3">Now that we’re familiar with advanced event-driven programming patterns in JavaScript, in the next chapter, we’ll cover lazy-loading and code-splitting to maximize the performance of JavaScript applications.</p>
</div>
</body></html>