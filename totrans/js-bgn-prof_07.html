<html><head></head><body><div><p>&#13;
    <h1 class="chapterNumber">7</h1>&#13;
    <h1 id="_idParaDest-195" class="chapterTitle">Classes</h1>&#13;
    <p class="normal">In this chapter, we are going to discuss JavaScript classes. We have seen JavaScript objects already, and classes are a blueprint or template for object creation. So, many of the things discussed here should not sound too unfamiliar or revolutionary.</p>&#13;
    <p class="normal">Classes <a id="_idIndexMarker317"/>enable object-oriented programming, which was one of the most important design advancements in software development. This development reduced the complexity of applications and increased maintainability by a huge margin.</p>&#13;
    <p class="normal">So, object-oriented programming and classes are of great importance for computer science in general. This is not necessarily the case when we apply it to JavaScript though. JavaScript classes are something special compared to other programming languages. Beneath the surface, classes are wrapped in some sort of special function. This means that they are actually an alternative syntax for defining objects using a constructor function. In this chapter, we will learn what classes are and how we can create and use them. Along the way, we will cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bullet">Object-oriented programming</li>&#13;
      <li class="bullet">Classes and objects</li>&#13;
      <li class="bullet">Classes</li>&#13;
      <li class="bullet">Inheritance</li>&#13;
      <li class="bullet">Prototypes<div>&#13;
          <p class="Information-Box--PACKT-">Note: exercise, project, and self-check quiz answers can be found in the <em class="italic">Appendix</em>.</p>&#13;
        </p>&#13;
      </li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-196" class="title">Object-oriented programming</h1>&#13;
    <p class="normal">Before we start diving right into the fun of classes, let's briefly say something about <strong class="keyword">object-oriented programming</strong> (<strong class="keyword">OOP</strong>). OOP is a <a id="_idIndexMarker318"/>very important programming paradigm wherein code is structured in objects, leading to more maintainable and reusable code. Working with OOP teaches you to really try to think of all sorts of topics in objects, by bundling properties in such a way that they can be wrapped in a blueprint called a class. This in turn might be inheriting properties from a parent class.</p>&#13;
    <p class="normal">For example, if we are thinking of an animal, we can come up with certain properties: name, weight, height, maximum speed, colors, and a lot more. And then if we think of a specific species of fish, we can reuse all the properties of "animal" and add a few fish-specific properties in there as well. The same for dogs; if we then think of a dog, we can reuse all the properties of "animal" and add a few dog-specific ones to it. This way we have reusable code of our animal class. And when we realize we forgot a very important property for the many animals in our application, we only need to add it to the animal class.</p>&#13;
    <p class="normal">This is very important for Java, .NET, and other classic object-oriented ways of writing code. JavaScript doesn't necessarily revolve around objects. We will need them and we will use them, but they are not the star of our code, so to speak.</p>&#13;
    <h1 id="_idParaDest-197" class="title">Classes and objects</h1>&#13;
    <p class="normal">As a quick refresher, objects<a id="_idIndexMarker319"/> are a collection of properties and methods. We saw them in <em class="chapterRef">Chapter 3</em>, <em class="italic">JavaScript Multiple Values</em>. The properties of an object should have sensible names. So for example, if we have a <code class="Code-In-Text--PACKT-">person</code> object, this object could have properties called <code class="Code-In-Text--PACKT-">age</code> and <code class="Code-In-Text--PACKT-">lastName</code> that contain values. Here is an example of an object:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let dog = { dogName: "JavaScript", &#13;
            weight: 2.4, &#13;
            color: "brown", &#13;
            breed: "chihuahua"&#13;
          };&#13;
</code></pre>&#13;
    <p class="normal">Classes in<a id="_idIndexMarker320"/> JavaScript encapsulate data and functions that are part of that class. If you create a class, you can later create objects using that class using the following syntax:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class ClassName {&#13;
  constructor(prop1, prop2) {&#13;
    this.prop1 = prop1;&#13;
    this.prop2 = prop2;&#13;
  }&#13;
}&#13;
 &#13;
let obj = new ClassName("arg1", "arg2");&#13;
</code></pre>&#13;
    <p class="normal">This code defines a class with <code class="Code-In-Text--PACKT-">ClassName</code> as a name, declares an <code class="Code-In-Text--PACKT-">obj</code> variable, and initializes this with a new instance of the object. Two arguments are provided. These arguments will be used by the constructor to initialize the properties. As you can see, the parameters of the constructor and the properties of the class (<code class="Code-In-Text--PACKT-">prop1</code> and <code class="Code-In-Text--PACKT-">prop2</code>) have the same name. The properties of the class can be recognized by the <code class="Code-In-Text--PACKT-">this</code> keyword in front of them. The <code class="Code-In-Text--PACKT-">this</code> keyword refers to<a id="_idIndexMarker321"/> the object it belongs to, so it is the first property of the instance of <code class="Code-In-Text--PACKT-">ClassName</code>.</p>&#13;
    <p class="normal">Remember we said that<a id="_idIndexMarker322"/> classes are just some special function beneath the surface. We could create the object with a special function like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">function Dog(dogName, weight, color, breed) {  &#13;
  this.dogName = dogName; &#13;
  this.weight = weight; &#13;
  this.color = color; &#13;
  this.breed = breed; &#13;
}  &#13;
let dog = new Dog("Jacky", 30, "brown", "labrador");&#13;
</code></pre>&#13;
    <p class="normal">The dog example could have been made using a class syntax as well. It would have looked like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Dog {&#13;
  constructor(dogName, weight, color, breed) {&#13;
    this.dogName = dogName;&#13;
    this.weight = weight;&#13;
    this.color = color;&#13;
    this.breed = breed;&#13;
  }&#13;
}&#13;
let dog = new Dog("JavaScript", 2.4, "brown", "chihuahua");&#13;
</code></pre>&#13;
    <p class="normal">This results in an object with the same properties. If we do some logging as follows, we will be able to see it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log(dog.dogName, "is a", dog.breed, "and weighs", dog.weight, "kg.");&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">JavaScript is a chihuahua and weighs 2.4 kg.&#13;
</code></pre>&#13;
    <p class="normal">In the next section, we will dive into all the parts of classes.</p>&#13;
    <h1 id="_idParaDest-198" class="title">Classes</h1>&#13;
    <p class="normal">You may <a id="_idIndexMarker323"/>wonder, if classes do the exact same thing as simply defining an object, why do we even need classes? The answer is that classes are essentially blueprints for object creation. This means that we need to do much less typing if we need to create 20 dogs when we have a <code class="Code-In-Text--PACKT-">dog</code> class. If we have to create the objects, we will have to specify all the properties' names each time. And it would be easy to make a typo and misspell a property name. Classes come in handy in these sorts of situations.</p>&#13;
    <p class="normal">As shown in the previous section, we use the <code class="Code-In-Text--PACKT-">class</code> keyword to tell JavaScript we want to create a class. Next, we give the class a name. It is the convention to start class names with a capital letter.</p>&#13;
    <p class="normal">Let's have a look at all the different elements of a class.</p>&#13;
    <h2 id="_idParaDest-199" class="title">Constructors</h2>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">constructor</code> method is a <a id="_idIndexMarker324"/>special method that we use to initialize objects with our class blueprint. There can only be one constructor in a class. This constructor contains properties that will be set when initiating the class.</p>&#13;
    <p class="normal">Here you can see an example of a <a id="_idIndexMarker325"/>constructor in a <code class="Code-In-Text--PACKT-">Person</code> class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  constructor(firstname, lastname) {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Beneath the surface, JavaScript creates a special function based on this constructor. This function gets the class name, and it will create an object with the given properties. With this special function, you can create instances (objects) of the class.</p>&#13;
    <p class="normal">Here is how you can create a new object from the <code class="Code-In-Text--PACKT-">Person</code> class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maaike", "van Putten");&#13;
</code></pre>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">new</code> word is what tells JavaScript to look for the special constructor function in the <code class="Code-In-Text--PACKT-">Person</code> class and create a new object. The constructor gets called and returns an instance of the person object with the specified properties. This object gets stored in the <code class="Code-In-Text--PACKT-">p</code> variable. </p>&#13;
    <p class="normal">If we use <a id="_idIndexMarker326"/>our new <code class="Code-In-Text--PACKT-">p</code> variable<a id="_idIndexMarker327"/> in a logging statement, you can see that the properties are really set:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log("Hi", p.firstname);&#13;
</code></pre>&#13;
    <p class="normal">This outputs:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hi Maaike&#13;
</code></pre>&#13;
    <p class="normal">What do you think will happen when we create a class without all of the properties? Let's find out:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maaike");&#13;
</code></pre>&#13;
    <p class="normal">Many languages would crash, but not JavaScript. It just sets the remaining properties to <code class="Code-In-Text--PACKT-">undefined</code>. You can see what happens by logging it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">console.log("Hi", p.firstname, p.lastname);&#13;
</code></pre>&#13;
    <p class="normal">This results in:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hi Maaike undefined&#13;
</code></pre>&#13;
    <p class="normal">You can specify default values in <code class="Code-In-Text--PACKT-">constructor</code>. You would do it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">constructor(firstname, lastname = "Doe") {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
</code></pre>&#13;
    <p class="normal">This way, it would not have printed <code class="Code-In-Text--PACKT-">Hi Maaike undefined</code>, but <code class="Code-In-Text--PACKT-">Hi Maaike Doe</code>.</p>&#13;
    <h3 id="_idParaDest-200" class="title">Practice exercise 7.1</h3>&#13;
    <p class="normal">Take the following steps to create a person class, and print instances of friends' names:</p>&#13;
    <ol>&#13;
      <li class="numbered">Create a class for <code class="Code-In-Text--PACKT-">Person</code> including the constructor for <code class="Code-In-Text--PACKT-">firstname</code> and <code class="Code-In-Text--PACKT-">lastname</code>.</li>&#13;
      <li class="numbered">Create a variable and assign a value of the new <code class="Code-In-Text--PACKT-">Person</code> object using your friend's first and last names.</li>&#13;
      <li class="numbered">Now add a second variable with another friend's name using their first name and last name.</li>&#13;
      <li class="numbered">Output both friends into the console with a greeting of <code class="Code-In-Text--PACKT-">hello</code>.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-201" class="title">Methods</h2>&#13;
    <p class="normal">In a class, we can <a id="_idIndexMarker328"/>specify functions. This means that our object can start doing things using the<a id="_idIndexMarker329"/> object's own properties—for example, printing a name. Functions on a class are called methods. When defining these methods, we don't use the <code class="Code-In-Text--PACKT-">function </code>keyword. We start directly with the name:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  constructor(firstname, lastname) {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
  greet() {&#13;
    console.log("Hi there! I'm", this.firstname);&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">We can call the <code class="Code-In-Text--PACKT-">greet</code> method on a <code class="Code-In-Text--PACKT-">Person</code> object like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maaike", "van Putten");&#13;
p.greet();&#13;
</code></pre>&#13;
    <p class="normal">It will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hi there! I'm Maaike&#13;
</code></pre>&#13;
    <p class="normal">You can specify as many methods on a class as you want. In this example, we are using the <code class="Code-In-Text--PACKT-">firstname</code> property. We do so by saying <code class="Code-In-Text--PACKT-">this.property</code>. If we had a person with a different value for the <code class="Code-In-Text--PACKT-">firstname</code> property, for example, <code class="Code-In-Text--PACKT-">Rob</code>, it would have printed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Hi there! I'm Rob&#13;
</code></pre>&#13;
    <p class="normal">Just like functions, methods can also take parameters and return results:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  constructor(firstname, lastname) {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
  greet() {&#13;
    console.log("Hi there!");&#13;
  }&#13;
  compliment(name, object) {&#13;
    return "That's a wonderful " + object + ", " + name;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">compliment</code> function does not output anything itself, so we are logging it</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let compliment = p.compliment("Harry", "hat");&#13;
console.log(compliment);&#13;
</code></pre>&#13;
    <p class="normal">The output will be:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">That's a wonderful hat, Harry&#13;
</code></pre>&#13;
    <p class="normal">In this case we are <a id="_idIndexMarker330"/>sending parameters into our method, because you don't usually compliment your own properties (that's a nice sentence, Maaike!). However, whenever the method doesn't require external input but only the properties of the object, no parameters will work and the method can use its object's properties. Let's do an exercise and then move on to using the properties of classes outside the class.</p>&#13;
    <h3 id="_idParaDest-202" class="title">Practice exercise 7.2</h3>&#13;
    <p class="normal">Get your friend's full name:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Using the <code class="Code-In-Text--PACKT-">Person</code> class from <em class="italic">Practice exercise 7.1</em>, add a method called <code class="Code-In-Text--PACKT-">fullname</code>, which returns the concatenated value of <code class="Code-In-Text--PACKT-">firstname</code> and <code class="Code-In-Text--PACKT-">lastname</code> when invoked.</li>&#13;
      <li class="numbered">Create values for <code class="Code-In-Text--PACKT-">person1</code> and <code class="Code-In-Text--PACKT-">person2</code> using two friends' first and last names.</li>&#13;
      <li class="numbered">Using the <code class="Code-In-Text--PACKT-">fullname</code> method within the class, return the full name of one or both people.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-203" class="title">Properties</h2>&#13;
    <p class="normal">Properties, sometimes<a id="_idIndexMarker331"/> also called fields, hold the data of the class. We have seen one kind of property <a id="_idIndexMarker332"/>already, when we created them in our constructors:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  constructor(firstname, lastname) {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here, the <code class="Code-In-Text--PACKT-">Person</code> class gets two properties from the constructor: <code class="Code-In-Text--PACKT-">firstname</code> and <code class="Code-In-Text--PACKT-">lastname</code>. Properties can be added or removed just like we did for objects. These properties can be accessed from outside the class, as we saw when we logged them outside the class by accessing them on the instance:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maaike", "van Putten");&#13;
console.log("Hi", p.firstname);&#13;
</code></pre>&#13;
    <p class="normal">Often, it is not desirable to provide direct access to our properties. We want our class to be in control of the values of properties for several reasons—perhaps we want to do validation on a property to assure it has a certain value. For example, imagine wanting to validate an age as not being lower than 18. We can achieve this by making direct access to the property from outside the class impossible.</p>&#13;
    <p class="normal">This is how to add properties that aren't accessible from outside. We prefix them with a <code class="Code-In-Text--PACKT-">#</code> symbol:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  #firstname;&#13;
  #lastname;&#13;
  constructor(firstname, lastname) {&#13;
    this.#firstname = firstname;&#13;
    this.#lastname = lastname;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Right now, the <code class="Code-In-Text--PACKT-">firstname</code> and <code class="Code-In-Text--PACKT-">lastname</code> properties cannot be accessed from outside the class. This is done by adding <code class="Code-In-Text--PACKT-">#</code> in front of the property. If we try it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maria", "Saga");&#13;
console.log(p.firstname);&#13;
</code></pre>&#13;
    <p class="normal">We'll get:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">undefined&#13;
</code></pre>&#13;
    <p class="normal">If we wanted to <a id="_idIndexMarker333"/>make sure we could only create objects with names starting with an "M," we could modify our constructor a bit:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">constructor(firstname, lastname) { &#13;
    if(firstname.startsWith("M")){&#13;
      this.#firstname = firstname; &#13;
    } else {&#13;
      this.#firstname = "M" + firstname; &#13;
    }&#13;
    this.#lastname = lastname; &#13;
  }&#13;
</code></pre>&#13;
    <p class="normal">Now when you try to create a person that has a <code class="Code-In-Text--PACKT-">firstname</code> value that doesn't start with an "M," it will add an <code class="Code-In-Text--PACKT-">M</code> in front. So for example, the value of the following first name is <code class="Code-In-Text--PACKT-">Mkay</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("kay", "Moon");&#13;
</code></pre>&#13;
    <p class="normal">This is a very silly example of validation. At this point, we cannot access it from outside the class at all after the constructor. We can only access it from inside the class. This is where getters and setters come into play.</p>&#13;
    <h3 id="_idParaDest-204" class="title">Getters and setters</h3>&#13;
    <p class="normal">Getters and setters<a id="_idIndexMarker334"/> are <a id="_idIndexMarker335"/>special properties that we can use to get data from a <a id="_idIndexMarker336"/>class and to set data fields on the class. Getters and setters are computed<a id="_idIndexMarker337"/> properties. So, they are more like properties than they are like functions. We call them accessors. They do look a bit like functions, because they have <code class="Code-In-Text--PACKT-">()</code> behind them, but they are not!</p>&#13;
    <p class="normal">These accessors<a id="_idIndexMarker338"/> start with the <code class="Code-In-Text--PACKT-">get</code> and <code class="Code-In-Text--PACKT-">set</code> keywords. It is considered good practice to make fields <a id="_idIndexMarker339"/>private as much as possible and provide access to them using getters and setters. This way, the properties cannot be set from outside without the object itself being in control. This principle is<a id="_idIndexMarker340"/> called <strong class="keyword">encapsulation</strong>. The class encapsulates the data, and the object is in control of its own fields.</p>&#13;
    <p class="normal">Here is how to do it:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  #firstname;&#13;
  #lastname;&#13;
  constructor(firstname, lastname) {&#13;
    this.#firstname = firstname;&#13;
    this.#lastname = lastname;&#13;
  }&#13;
  get firstname() {&#13;
    return this.#firstname;&#13;
  }&#13;
  set firstname(firstname) {&#13;
    this.#firstname = firstname;&#13;
  }&#13;
  get lastname() {&#13;
    return this.#lastname;&#13;
  }&#13;
  set lastname(lastname) {&#13;
    this.#lastname = lastname;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">The getter is used to get <a id="_idIndexMarker341"/>the property. Therefore, it doesn't take any parameters, but simply returns <a id="_idIndexMarker342"/>the property. The setter is the other way around: it takes a parameter, assigns this new value to the property, and returns nothing. The setter can<a id="_idIndexMarker343"/> contain more logic, for example, some validation, as we'll see<a id="_idIndexMarker344"/> below. The getter can be used outside the object as if it were a property. The properties are no longer directly accessible from outside the class, but can be accessed via the getter to get the value and via the setter to update the value. Here is how to use it outside the class instance:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maria", "Saga");&#13;
console.log(p.firstname);&#13;
</code></pre>&#13;
    <p class="normal">This will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Maria&#13;
</code></pre>&#13;
    <p class="normal">We have <a id="_idIndexMarker345"/>created a new <code class="Code-In-Text--PACKT-">Person</code> object with a first name of <code class="Code-In-Text--PACKT-">Maria</code> and last name of <code class="Code-In-Text--PACKT-">Saga</code>. The <a id="_idIndexMarker346"/>output is showing the first name, which is only possible because we have a getter accessor. We can also set the <a id="_idIndexMarker347"/>value to something else, because there is a setter. Here is how <a id="_idIndexMarker348"/>to update the first name, so the name is no longer <code class="Code-In-Text--PACKT-">Maria</code>, but <code class="Code-In-Text--PACKT-">Adnane</code>.</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">p.firstname = "Adnane";&#13;
</code></pre>&#13;
    <p class="normal">At this point, nothing special is happening in the setter. We could do a similar validation as in the constructor before, like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">set firstname(firstname) { &#13;
    if(firstname.startsWith("M")){&#13;
      this.#firstname = firstname; &#13;
    } else {&#13;
      this.#firstname = "M" + firstname; &#13;
    }&#13;
  }&#13;
</code></pre>&#13;
    <p class="normal">This will check whether <code class="Code-In-Text--PACKT-">firstname</code> starts with an <code class="Code-In-Text--PACKT-">M</code>, and if it does it will update the value to whatever the <code class="Code-In-Text--PACKT-">firstname</code> parameter is. If it doesn't, it will concatenate an <code class="Code-In-Text--PACKT-">M</code> in front of the parameter.</p>&#13;
    <p class="normal">Please note that we do not access <code class="Code-In-Text--PACKT-">firstname</code> as if it was a function. If you put two parentheses <code class="Code-In-Text--PACKT-">()</code> after it, you would actually get an error telling you that it is not a function.</p>&#13;
    <h1 id="_idParaDest-205" class="title">Inheritance</h1>&#13;
    <p class="normal">Inheritance is one <a id="_idIndexMarker349"/>of the key concepts of OOP. It is the concept that classes can have child classes that inherit the properties and methods from the parent class. For example, if you needed all sorts of vehicle objects in your application, you could specify a class named <code class="Code-In-Text--PACKT-">Vehicle</code> in which you specify some shared properties and methods of vehicles. You would then go ahead and create the specific child classes based on this <code class="Code-In-Text--PACKT-">Vehicle</code> class, for example, <code class="Code-In-Text--PACKT-">boat</code>, <code class="Code-In-Text--PACKT-">car</code>, <code class="Code-In-Text--PACKT-">bicycle</code>, and <code class="Code-In-Text--PACKT-">motorcycle</code>. </p>&#13;
    <p class="normal">This could be a very simple version of the <code class="Code-In-Text--PACKT-">Vehicle</code> class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Vehicle {&#13;
  constructor(color, currentSpeed, maxSpeed) {&#13;
    this.color = color;&#13;
    this.currentSpeed = currentSpeed;&#13;
    this.maxSpeed = maxSpeed;&#13;
  }&#13;
  move() {&#13;
    console.log("moving at", this.currentSpeed);&#13;
  }&#13;
  accelerate(amount) {&#13;
    this.currentSpeed += amount;&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Here we have two <a id="_idIndexMarker350"/>methods in our <code class="Code-In-Text--PACKT-">Vehicle</code> class: <code class="Code-In-Text--PACKT-">move</code> and <code class="Code-In-Text--PACKT-">accelerate</code>. And this could be a <code class="Code-In-Text--PACKT-">Motorcyle</code> class inheriting from this class using the <code class="Code-In-Text--PACKT-">extends</code> keyword:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Motorcycle extends Vehicle {&#13;
  constructor(color, currentSpeed, maxSpeed, fuel) {&#13;
    super(color, currentSpeed, maxSpeed);&#13;
    this.fuel = fuel;&#13;
  }&#13;
  doWheelie() {&#13;
    console.log("Driving on one wheel!");&#13;
   }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">With the <code class="Code-In-Text--PACKT-">extends</code> keyword we specify that a certain class is the child of another class. In this case, <code class="Code-In-Text--PACKT-">Motorcycle</code> is a child class of <code class="Code-In-Text--PACKT-">Vehicle</code>. This means that we'll have access to properties and methods from <code class="Code-In-Text--PACKT-">Vehicle</code> in our <code class="Code-In-Text--PACKT-">Motorcycle</code> class. We have added a special <code class="Code-In-Text--PACKT-">doWheelie()</code> method. This is not something that makes sense to add to the <code class="Code-In-Text--PACKT-">Vehicle</code> class, because this is an action that is specific to certain vehicles.</p>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">super</code> word in the constructor is calling the constructor from the parent, the <code class="Code-In-Text--PACKT-">Vehicle</code> constructor in this case. This makes sure that the fields from the parent are set as well and that the methods are available without having to do anything else: they are automatically inherited. Calling <code class="Code-In-Text--PACKT-">super()</code> is not optional, you must do it when you are in a class that is inheriting from another class, else you will get a <code class="Code-In-Text--PACKT-">ReferenceError</code>. </p>&#13;
    <p class="normal">Because we have access to the fields of <code class="Code-In-Text--PACKT-">Vehicle</code> in <code class="Code-In-Text--PACKT-">Motorcycle</code>, this will work:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let motor = new Motorcycle("Black", 0, 250, "gasoline");&#13;
console.log(motor.color);&#13;
motor.accelerate(50);&#13;
motor.move();&#13;
</code></pre>&#13;
    <p class="normal">And this is what it will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">Black&#13;
moving at 50&#13;
</code></pre>&#13;
    <p class="normal">We cannot<a id="_idIndexMarker351"/> access any <code class="Code-In-Text--PACKT-">Motorcycle</code> specific properties or methods in our <code class="Code-In-Text--PACKT-">Vehicle</code> class. This is because not all vehicles are motorcycles, so we cannot be sure that we would have the properties or methods from a child.</p>&#13;
    <p class="normal">Right now, we don't use any getters and setters here, but we clearly could. If there are getters and setters in the parent class, they are inherited by the child class as well. This way we could influence which properties could be fetched and changed (and how) outside our class. This is generally a good practice.</p>&#13;
    <h1 id="_idParaDest-206" class="title">Prototypes</h1>&#13;
    <p class="normal">A prototype<a id="_idIndexMarker352"/> is the mechanism in JavaScript that makes it possible to have objects. When nothing is specified when creating a class, the objects inherit from the <code class="Code-In-Text--PACKT-">Object.prototype</code> prototype. This is a rather complex built-in JavaScript class that we can use. We don't need to look at how this is implemented in JavaScript, as we can consider it the base object that is always on top of the inheritance tree and therefore always present in our objects.</p>&#13;
    <p class="normal">There is a <code class="Code-In-Text--PACKT-">prototype</code> property available on all classes, and it is always named "prototype." We can access it like this:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">ClassName.prototype&#13;
</code></pre>&#13;
    <p class="normal">Let's give an example of how to add a function to a class using the <code class="Code-In-Text--PACKT-">prototype</code> property. In order to do so, we'll be using this <code class="Code-In-Text--PACKT-">Person</code> class:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">class Person {&#13;
  constructor(firstname, lastname) {&#13;
    this.firstname = firstname;&#13;
    this.lastname = lastname;&#13;
  }&#13;
  greet() {&#13;
    console.log("Hi there!");&#13;
  }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">And here is how to add a function to this class using <code class="Code-In-Text--PACKT-">prototype</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Person.prototype.introduce = function () {&#13;
  console.log("Hi, I'm", this.firstname);&#13;
};&#13;
</code></pre>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">prototype</code> is a property<a id="_idIndexMarker353"/> holding all the properties and methods of an object. So, adding a function to <code class="Code-In-Text--PACKT-">prototype</code> is adding a function to the class. You can use <code class="Code-In-Text--PACKT-">prototype</code> to add properties or methods to an object, like we did in the above example in our code with the <code class="Code-In-Text--PACKT-">introduce</code> function. You can also do this for properties:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Person.prototype.favoriteColor = "green";&#13;
</code></pre>&#13;
    <p class="normal">And then you can call them from instances of <code class="Code-In-Text--PACKT-">Person</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">let p = new Person("Maria", "Saga");&#13;
console.log(p.favoriteColor);&#13;
p.introduce();&#13;
</code></pre>&#13;
    <p class="normal">It will output:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con">green&#13;
Hi, I'm Maria&#13;
</code></pre>&#13;
    <p class="normal">And it will be as if you had defined the class with a favorite color holding a default value, and a function, <code class="Code-In-Text--PACKT-">introduce</code>. They have been added to the class and are available for all instances and future instances. </p>&#13;
    <p class="normal">So the methods and properties defined via <code class="Code-In-Text--PACKT-">prototype</code> are really as if they were defined in the class. This means that overwriting them for a certain instance doesn't overwrite them for all instances. For example, if we were to have a second <code class="Code-In-Text--PACKT-">Person</code> object, this person could overwrite the <code class="Code-In-Text--PACKT-">favoriteColor</code> value and this wouldn't change the value for our object with <code class="Code-In-Text--PACKT-">firstname</code> as <code class="Code-In-Text--PACKT-">Maria</code>.</p>&#13;
    <p class="normal">This is something you should not be using when you have control over the class code and you want to change it permanently. In that case, just change the class. However, you can expand existing objects like this and even expand existing objects conditionally. It is also important to know<a id="_idIndexMarker354"/> that the JavaScript built-in objects have prototypes and inherit from <code class="Code-In-Text--PACKT-">Object.prototype</code>. However, be sure not to modify this prototype since it will affect how our JavaScript works.</p>&#13;
    <h2 id="_idParaDest-207" class="title">Practice exercise 7.3</h2>&#13;
    <p class="normal">Create a class that contains properties for different animal species and the sound that each species makes, and create two (or more) animals:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a method that prints a given animal and its sound. </li>&#13;
      <li class="numbered">Add a prototype with another action for the animal.</li>&#13;
      <li class="numbered">Output an entire animal object into the console.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-208" class="title">Chapter projects</h1>&#13;
    <h2 id="_idParaDest-209" class="title">Employee tracking app</h2>&#13;
    <p class="normal">Create a class to track the <a id="_idIndexMarker355"/>employees of a company:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Use first names, last names, and the number of years worked as values in the constructor.</li>&#13;
      <li class="numbered">Create two or more people with values for their first names, last names, and the number of years they've worked at the company. Add the people into an array.</li>&#13;
      <li class="numbered">Set up a prototype to return the details of the person's first and last names and how long they've worked at the company.</li>&#13;
      <li class="numbered">Iterate the contents of the array to output the results into the console, adding some text to make the output a full sentence.</li>&#13;
    </ol>&#13;
    <h2 id="_idParaDest-210" class="title">Menu items price calculator</h2>&#13;
    <p class="normal">Create a class which will allow you to work out the combined price of a number of items, and interact with it to work out the total cost of different orders.</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a class that contains the <a id="_idIndexMarker356"/>prices of two menu items as private field declarations.</li>&#13;
      <li class="numbered">Use the constructor in the class to get the argument values (how many of each item are being bought).</li>&#13;
      <li class="numbered">Create a method to calculate and return the total cost depending on how many of each item the user selects.</li>&#13;
      <li class="numbered">Use a getter property to grab the value output by the calculation method.</li>&#13;
      <li class="numbered">Create two or three objects with different combinations of menu selections, and output the total cost in the console.</li>&#13;
    </ol>&#13;
    <h1 id="_idParaDest-211" class="title">Self-check quiz</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">What is the keyword used to create a class?</li>&#13;
      <li class="numbered">How would you set up a class for a person's first and last names that could include <code class="Code-In-Text--PACKT-">first</code> and <code class="Code-In-Text--PACKT-">last</code> as initial properties?</li>&#13;
      <li class="numbered">What is the concept of one thing gaining the properties and behaviors of another thing called?</li>&#13;
      <li class="numbered">Which of the following are true about the <code class="Code-In-Text--PACKT-">constructor</code> method?<ul>&#13;
          <li class="bullet-l2">It gets executed automatically when a new object is created.</li>&#13;
          <li class="bullet-l2">It should only be added afterward.</li>&#13;
          <li class="bullet-l2">It has to include the <code class="Code-In-Text--PACKT-">constructor</code> keyword.</li>&#13;
          <li class="bullet-l2">It is used to initialize object properties.</li>&#13;
          <li class="bullet-l2">It can be used when you have multiple values.</li>&#13;
        </ul>&#13;
      </li>&#13;
      <li class="numbered">Troubleshoot the following code so that the prototype outputs the first and last name of the <code class="Code-In-Text--PACKT-">Person</code> into the console. Which is the correct syntax for the <code class="Code-In-Text--PACKT-">Person</code> prototype?&#13;
        <pre class="programlisting code"><code class="hljs-code">function Person(first,last) {&#13;
  this.first = first;&#13;
  this.last = last;&#13;
}&#13;
// What should go here: A, B, or C?&#13;
const friend1 = new Person("Laurence", "Svekis");&#13;
console.log(friend1.getName());&#13;
</code></pre>&#13;
      &#13;
		<p class="normal">A)</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Person.prototype.getName = (first,last) {&#13;
  return this.first + " " + this.last;&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">B)</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Person.prototype.getName = function getName() {&#13;
return this.first + " " + this.last;&#13;
};&#13;
</code></pre>&#13;
    <p class="normal">C) </p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Person.prototype = function getName() {&#13;
return this.first + " " + this.last;&#13;
};&#13;
</code></pre></li>&#13;
    </ol>&#13;
    &#13;
    <h1 id="_idParaDest-212" class="title">Summary</h1>&#13;
    <p class="normal">In this chapter, we introduced you to the concept of OOP. This means that we structure our code in such a way that objects are the central players of the logic. Classes are blueprints for objects. We can make a template for an object and create an instance easily by using the <code class="Code-In-Text--PACKT-">new</code> keyword.</p>&#13;
    <p class="normal">We then saw that classes can inherit from each other by using the <code class="Code-In-Text--PACKT-">extends</code> keyword. Classes that extend from another class will have to call the constructor of this class with <code class="Code-In-Text--PACKT-">super()</code> and will then automatically have access to all the properties and methods of the parent. This is great for reusable and highly maintainable code.</p>&#13;
    <p class="normal">Lastly, we encountered prototypes. This is the built-in JavaScript concept that makes classes possible. By adding properties and methods to a class using <code class="Code-In-Text--PACKT-">prototype</code>, we can modify the blueprint of that class.</p>&#13;
    <p class="normal">In the next chapter, we will consider some of JavaScript's built-in methods, which can be used to manipulate and add complexity to your code!</p>&#13;
  </div>&#13;
</div></body></html>