<html><head></head><body>
		<div><h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: Interacting with a page</h1>
			<p>Thanks to <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we now know how to open a browser and all the different options we have to launch browsers and create new pages. We also know how to navigate through other pages. We learned about HTTP responses and how they are related to a request.</p>
			<p>This chapter is about interaction. Emulating user interaction is essential in UI testing. There is one pattern in unit testing called <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>). This pattern enforces a particular order in the test code:</p>
			<ul>
				<li>Arrange – Prepare the context.</li>
				<li>Act – Interact with the page.  </li>
				<li>Assert – Check the page reaction.</li>
			</ul>
			<p>In this chapter, we will learn how to find elements on a page. We will understand how the development team can improve their HTML so that you can easily find elements. But if you cannot change the page HTML, we will also look at another set of tools to find the elements we need.</p>
			<p>Once we find an element, we will want to interact with it. Puppeteer provides two sets of APIs: One is action functions, such as click, select, or type. Then we have a set of emulation functions, such as mouse events or keyboard emulation. We will cover all those functions.</p>
			<p>This chapter will introduce a new object we haven't mentioned yet: <strong class="bold">The element handle</strong>.</p>
			<p>By the end of this chapter, we will have added another tool to our toolbox: The Visual Studio Code debugging tools.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to HTML, the DOM, and CSS</li>
				<li>Finding elements</li>
				<li>Finding elements using XPath</li>
				<li>Interacting with elements</li>
				<li>Keyboard and mouse emulation</li>
				<li>Interacting with multiple frames</li>
				<li>Debugging tests with Visual Studio Code</li>
			</ul>
			<p>By the end of this chapter, you will be able to emulate most types of user interaction. But first, we need to lay the groundwork. Let's talk about HTML, the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), and CSS.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <code>Chapter4</code> directory. Remember to run <code>npm install</code> on that directory and then go to the <code>Chapter4/vuejs-firebase-shopping-cart directory</code> directory and run <code>npm install</code> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <code>Chapter3</code> directory.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Introduction to HTML, the DOM, and CSS</h1>
			<p>You won't be able to find elements if you don't know CSS, and you won't understand CSS if you don't understand the <strong class="bold">DOM</strong> and <strong class="bold">HTML</strong>. So, we need to start with the basics.</p>
			<p>I bet you've heard that you can build a site with HTML, CSS, and JavaScript. You might be using different server-side technologies. Your frontend might be implemented using cool technologies such as React or Angular. But in the end, the result will be a page based on HTML, CSS, and JavaScript.</p>
			<p><strong class="bold">HTML</strong> is<a id="_idIndexMarker175"/> the page's content. If you go to any website, open the <strong class="bold">DevTools</strong>, and click on the <strong class="bold">Elements</strong> tab, you will see the content of the page. You will see the page's title. If it's a news site, you will see all the articles there. If you visit a blog post, you will see the text of that post.</p>
			<p>Without <strong class="bold">CSS</strong>, an HTML<a id="_idIndexMarker176"/> page would look like text written in Notepad. CSS not only brings color and fonts, but it's also the scaffolding that gives structure to a page.</p>
			<p class="callout-heading">Fun fact</p>
			<p class="callout">Firefox has a built-in tool to disable all the styles on a page. If you go to <strong class="bold">View</strong> | <strong class="bold">Page Style</strong> and click on <strong class="bold">No Style</strong>, you will see how our life would be without CSS.</p>
			<p>The last piece is JavaScript. JavaScript brings behavior to a page. Once the browser parses the HTML and builds the DOM, it allows us to manipulate and give life to a page.</p>
			<p>But, as I mentioned before, we need to go to the basics, to the foundations of the web. Let's begin with HTML.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>HTML</h2>
			<p><strong class="bold">HTML</strong> stands for <strong class="bold">HyperText Markup Language</strong>: HyperText because the HTML is not content per se; HTML<a id="_idIndexMarker177"/> contains the content. Markup because it uses tags to give meaning to that content. And language because, although many developers disagree and they get mad about the idea, HTML is a language.</p>
			<p>If we read an HTML file as a data structure, we can say that HTML is a <strong class="bold">relaxed</strong> version of XML. So, to better understand HTML, we need to look at the basics of XML.</p>
			<p>These are the basic elements of XML content:</p>
			<div><div><img src="img/Figure_4.1_B16113.jpg" alt="XML Content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">XML Content</p>
			<p>If you look at this <a id="_idIndexMarker178"/>figure, you already know almost everything you need to know about XML. Well, maybe I'm exaggerating. But this is the idea:</p>
			<ul>
				<li>You have elements, which are represented as <code>&lt;ElementName&gt;</code>. In our example, we have <code>element&gt;</code> and <code>&lt;child-element&gt;</code>.</li>
				<li>The element might have attributes, which are represented as <code>AttributeName=" AttributeValue"</code>. We have <code>value="3</code><code>value="4"</code> in our example.</li>
				<li>The element might contain other elements. You can see we have two <strong class="bold">child-element</strong> elements inside the main <strong class="bold">element</strong>.</li>
				<li>An element finishes (is closed) with <code>&lt;/ElementName&gt;</code>, or with <code>/&gt;</code> at the end instead of <code>&gt;</code>.</li>
			</ul>
			<p>XML parsers<a id="_idIndexMarker179"/> are very strict with these rules. If the XML content you are trying to parse breaks just a single rule, the parser will consider the entire XML invalid. Whether it's a missing closing element or an attribute without quotes, the parser will fail to evaluate the XML content.</p>
			<p>But we will find that browsers are not that strict when parsing HTML content. Let's take a look at the following HTML:</p>
			<div><div><img src="img/Figure_4.2_B16113.jpg" alt="A broken HTML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A broken HTML</p>
			<p>This simple HTML<a id="_idIndexMarker180"/> will print <em class="italic">Hello World</em> in red in the browser.</p>
			<p>Is this valid XML? No. As you can see, the <code>&lt;div&gt;</code> element is not closed. But is this valid HTML? Yes.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The fact that a browser would try to render <em class="italic">broken</em> HTML doesn't mean that you should take that lightly. It's possible you have heard a developer say that a particular bug was due to a <em class="italic">missing closing div</em>. If the HTML is broken, for instance, it has a missing closing <code>div</code>, the browser will try to guess the best way to render that HTML. The decision the browser makes when trying to fix broken HTML could end up with the page working as expected or with the full page layout broken.</p>
			<p>Another interesting concept is that the XML specification doesn't give meaning to the elements. The names of the elements, the attributes, and the resulting information coming from that content depend on who wrote the XML and who is reading it.</p>
			<p>HTML is XML<a id="_idIndexMarker181"/> with meaning. In <em class="italic">1993</em>, <em class="italic">Tim Berners-Lee</em>, who is known as the inventor of the World Wide Web, decided that the main element would be called <code>HTML</code> and that it would contain a <code>BODY</code>. He decided that images would be represented as <code>IMG</code> elements, paragraphs would be <code>P</code> elements, and so on. Over the years, browser and web developers followed and improved this convention, getting to what we today call HTML5. We, as a community, agreed on the meaning of HTML elements.</p>
			<p>We agreed that if we add the <code>text</code> attribute with the value <code>red</code>, we will get the text in red, and so on. How many types of elements do we have in HTML? A lot! The good news is that you don't need to know all of them. </p>
			<p>The more you know, the more productive you will be. However, these are the most common elements you will find on a page.</p>
			<h3>Document structure elements</h3>
			<p>Every HTML document will <a id="_idIndexMarker182"/>be contained inside an <code>&lt;html&gt;</code> element. That <a id="_idIndexMarker183"/>HTML element will have two child elements. The first element you will find is <code>&lt;head&gt;</code>. Inside that <code>&lt;head&gt;</code> element, you will find metadata elements, such as <code>&lt;title&gt;</code> with the page title, and many <code>&lt;meta&gt;</code> elements with metadata not supported by the standard HTML. Many sites use <code>&lt;meta&gt;</code> to enforce how the page should be shown on social media. The second set of elements you will find are <code>&lt;link&gt;</code> elements, including CSS files, and <code>&lt;script&gt;</code> files, including JavaScript code. Although the script elements are accepted in the header, most sites would add their script elements at the bottom of the page for faster rendering. </p>
			<p>The second element you will find is the <code>&lt;body&gt;</code> element. The page itself will be inside this element.</p>
			<h3>Text elements</h3>
			<p>Then <a id="_idIndexMarker184"/>we have the <a id="_idIndexMarker185"/>basic text elements. </p>
			<p><code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>, and <code>&lt;h6&gt;</code> are headings. If you have a text editor, you might have seen that there are many levels of headings and subheadings.</p>
			<p><code>&lt;p&gt;</code> will denote paragraphs. Then you might find <code>&lt;span&gt;</code> elements, which help style part of the text in a paragraph.</p>
			<p>Another type of<a id="_idIndexMarker186"/> text element is <code>&lt;label&gt;</code>. These labels are linked to an input <a id="_idIndexMarker187"/>control, such as a radio button, giving context to that control. For example, a radio button or a checkbox doesn't have text; it's just a check or a radio. You need a label to give them context:</p>
			<div><div><img src="img/Figure_4.3_B16113.jpg" alt="Radio buttons with labels&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Radio buttons with labels</p>
			<p>This HTML has three labels. <em class="italic">Huey</em> gives context to the first radio option, <em class="italic">Dewey</em> to the second, and <em class="italic">Louie</em> to the last one.</p>
			<p>The last type of text element we will look at is list elements. Lists are expressed as a parent element, <code>&lt;ul&gt;</code> for unordered lists or <code>&lt;ol&gt;</code> for ordered lists, and <code>&lt;li&gt;</code> elements. You will see lots of these in menu bars.</p>
			<h3>Action elements</h3>
			<p>There are two main<a id="_idIndexMarker188"/> action elements<a id="_idIndexMarker189"/> in HTML. The <code>&lt;a&gt;</code> anchor, also known as a link, was designed to take you to another page, but these days it's not limited to that, and it could trigger actions inside the page.</p>
			<p>The second element is <code>&lt;button&gt;</code>, which again, although it was designed to send data to the server using an HTTP POST request, is now being used for many other kinds of actions:</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The days when you would only use buttons and links to perform actions are in the past. As most HTML elements support click events, you will find pages that show elements as buttons, but in fact, those buttons are HTML elements <a id="_idIndexMarker190"/>such as <strong class="bold">DIVs</strong>.</p>
			<div><div><img src="img/Figure_4.4_B16113.jpg" alt="Links and buttons at packtpub.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Links and buttons at packtpub.com</p>
			<p>Many times, you<a id="_idIndexMarker191"/> won't notice the<a id="_idIndexMarker192"/> difference between a link and a button. For instance, in the <a href="http://packtpub.com">packtpub.com</a> site, the search button is a <code>button</code> element, whereas the cart button is, in fact, an <code>anchor</code>.</p>
			<p>Most of your automation code will involve clicking on these action elements.</p>
			<h3>Container Elements</h3>
			<p>The role<a id="_idIndexMarker193"/> of container elements<a id="_idIndexMarker194"/> is grouping elements, mostly for layout and style purposes. The most popular element is <code>DIV</code>. What is <code>DIV</code>? It can be anything: A list of items, a popup, a header, anything. It is used to create groups of elements.</p>
			<p>One element that was the king of the container elements was <code>TABLE</code>. As you can infer from the name, a table represents a grid. Inside a <code>TABLE</code> element, you can have <code>TR</code> elements representing rows, <code>TH</code> elements representing header cells, and <code>TD</code> elements representing a column inside a row. I mentioned that this <em class="italic">was</em> the king of containers because the community has now moved on from tables to <code>DIVs</code> due to performance issues, the need for more complex layouts, and responsiveness issues. But you might still see some tables on sites showing information using a grid style.</p>
			<p><code>&lt;header&gt;</code> for the site header, <code>&lt;footer&gt;</code> for the footer, <code>&lt;nav&gt;</code> for the navigation options, <code>&lt;articles&gt;</code> for blog posts, and so on. The purpose of these elements is to help external tools (such as screen readers, search engines, and even the same browser) to understand the HTML content.</p>
			<h3>Input elements</h3>
			<p>The last group of elements we need to<a id="_idIndexMarker199"/> know about are the input elements. The most common input element<a id="_idIndexMarker200"/> is the multifaceted <code>input</code> element. Depending on the <code>type</code> attribute, it can be <code>"text"</code>, <code>"password"</code>, <code>"checkbox"</code>, <code>"file"</code> (upload), and so on; the list goes on to a total of 22 types.</p>
			<p>Then we have <code>select</code> elements for drop-down lists and the <code>option</code> element to represent the items of a drop-down list. </p>
			<p>Of course, we shouldn't forget the <code>&lt;IMG&gt;</code> element. It's impossible to picture a site without images. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Not every input you will see these days will be one of these elements. To make inputs more user-friendly or just nicer, you will find that developers might build inputs based on many other elements. For instance, you could find a drop-down list, which instead of being a select element would be an input element, plus an arrow button, which would show a floating list on clicking it. This kind of control makes sites prettier but automation more challenging.</p>
			<p>HTML has not only a known list of elements but also a known list of attributes. These are the most common attributes you will find:</p>
			<ul>
				<li><code>id</code>: Identifies a unique element. It's the element ID in the <code>DOM</code> (we will talk about the DOM in the next section).</li>
				<li><code>class</code>: Contains the CSS classes applied to the element. It accepts more than one CSS class separated by a space.</li>
				<li><code>style</code>: CSS style assigned to the element.</li>
			</ul>
			<p>HTML won't limit<a id="_idIndexMarker201"/> the attributes you can add to an element. You can add any <a id="_idIndexMarker202"/>attribute you want, for instance, <code>defaultColor="blue"</code>. One convention is using <code>defaultColor</code> is a valid attribute, the general convention uses <code>data-default-color="blue"</code> instead.</p>
			<p>The other set of attributes of <a id="_idIndexMarker204"/>interest to us is the <code>role="treeitem"</code> and <code>aria-expanded="true"</code>.</p>
			<p>In the past few paragraphs, the DOM has been mentioned a few times. Let's talk about the DOM.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>The DOM</h2>
			<p>The DOM is <a id="_idIndexMarker205"/>the interface you can use in JavaScript to interact with the HTML. According to the MDN (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/dom">https://www.hardkoded.com/ui-testing-with-puppeteer/dom</a>), it is <em class="italic">the data representation of the objects that comprise the structure and content of a document on the web</em>. Why should we care about that? Because we are going to use the same tools to automate our pages.</p>
			<p>In the previous section, we mentioned that an element might have an ID. You'll find that the search input at <a href="https://www.packtpub.com/">https://www.packtpub.com/</a> has the ID search, so you will be able to get that element in JavaScript using <code>document.getElementById('search')</code>.</p>
			<p>You might be wondering: How do I know the ID of a button? Or how do I check that the ID is valid? Remember we talked about the dev tools?</p>
			<p>The developer <a id="_idIndexMarker206"/>tools can be opened by clicking on the three dots in the top-right corner of Chrome and then going to <strong class="bold">More Tools</strong> | <strong class="bold">Developer Tools</strong>. You can also use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">J</em> shortcut in Windows or <em class="italic">Cmd</em> + <em class="italic">Option</em> + <em class="italic">I</em> in macOS:</p>
			<div><div><img src="img/Figure_4.5_B16113.jpg" alt="Developer Tools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Developer Tools</p>
			<p>If you right-click on any element on the page, for instance, the search button, you will find the <strong class="bold">Inspect</strong> option, which will select that element in the <strong class="bold">Elements</strong> tab. There you will be able to see all the attributes of that element:</p>
			<div><div><img src="img/Figure_4.6_B16113.jpg" alt="Inspect option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Inspect option</p>
			<p>Another tab you<a id="_idIndexMarker207"/> will use a lot is the <strong class="bold">Console</strong> tab, where you will be able to run JavaScript code. If you are in the <strong class="bold">Elements</strong> tab and press the <em class="italic">Esc</em> key, you will get the <strong class="bold">Console</strong> tab below the <strong class="bold">Elements</strong> one. From there, you will be able to test your code:</p>
			<div><div><img src="img/Figure_4.7_B16113.jpg" alt="Console tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Console tab</p>
			<p>Another set of functions that you will use a lot are <code>document.querySelector</code> and <code>document.querySelectorAll</code>. The first function returns the first element matching a CSS selector, whereas the second function returns a list of elements matching a CSS selector. So, we need to learn about some CSS selectors next.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>CSS Selectors</h2>
			<p>You don't need to learn <a id="_idIndexMarker208"/>CSS to understand how to style a page, but you should master how to find elements on a page. There are around 60 different selectors (<a href="https://www.w3schools.com/cssref/css_selectors.asp">https://www.w3schools.com/cssref/css_selectors.asp</a>) we can use for finding elements. We won't cover all 60 here, but let's go through the most common selectors:</p>
			<ul>
				<li>Select by element name:<p>Selector: <code>ElementName</code>.</p><p>Example: <code>input</code> will select <code>&lt;input&gt;</code> elements.</p></li>
				<li>Select by class name:<p>Selector: <code>.ClassName</code>.</p><p>Example: <code>.input-text</code> will select any element that contains the <code>input-text</code> class. </p><p>If you look at the search input in <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>, the class attribute is <code>class="input-text algolia-search-input aa-input"</code>. This selector won't check whether the class attribute is equal to <code>input-text</code>. It has to contain it.</p></li>
				<li>Select by ID:<p>Selector: <code>#SomeID</code>.</p><p>Example: <code>#search</code> will select the element with the <code>search</code> ID. In this case, it does check equality.</p></li>
				<li>Select by attribute:<p>Selector: <code>[attribute=value]</code>.</p><p>Example: <code>[aria-labelledby= "search"]</code> will select the element with the <code>aria-labelledby</code> attribute with the value <code>search</code>. This is an excellent example of the use of ARIA attributes for automation.</p></li>
			</ul>
			<p>This selector is not<a id="_idIndexMarker209"/> limited by only the equality check (<code>=</code>). You could use only <code>[attribute]</code> to check whether the element contains the attribute, no matter the value. You can also use many other operators. For example, you can use <code>*=</code> to check whether the attribute contains a value or <code>|=</code> to check whether it begins with a value.</p>
			<h3>Combining selectors</h3>
			<p>What's great about CSS is<a id="_idIndexMarker210"/> that you can combine all these selectors. You could use <code>input.input-search[aria-labelledby=" search"]</code> to select an input with the <code>input-search</code> class and the <code>aria-labelledby</code> attribute with the value <code>search</code>.</p>
			<p>You can also look for child elements. CSS allows us to "cascade" (that's what the <em class="italic">C</em> in <em class="italic">CSS</em> stands for) selectors. You can search for child elements by adding new selectors separated by a space. Let's take, for instance, the following selector:</p>
			<pre><code>form .algolia-autocomplete input</code></pre>
			<p>If you read it backwards, it will select an <code>input</code> inside an element with the <code>algolia-autocomplete</code> class, which is inside a <code>form</code> element. Notice that I said an input <em class="italic">inside</em> an element with the <code>algolia-autocomplete</code> class. That doesn't need to be the direct parent of the input element. </p>
			<p>If you want to check strictly a parent-child relationship, you can separate selectors with a <code>&gt;</code> instead of a space:</p>
			<pre><code>.algolia-autocomplete &gt; input</code></pre>
			<p>This selector will look for an input whose direct parent element is an element with the <code>algolia-autocomplete</code> class.</p>
			<p>Maybe you are thinking, why do I need to know all this information? I just want to get up and running with Puppeteer! Let me tell you something: You will spend half of your time inside the developer tools, and the most frequent element in your code will be a CSS selector. The more you <a id="_idIndexMarker211"/>know about HTML, the DOM, and CSS, the more proficient you will be at browser automation.</p>
			<p>But now it's time to go back to the Puppeteer world.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Finding elements</h1>
			<p>It's time to apply <a id="_idIndexMarker212"/>everything we have learned so far. We need to master selectors because our Puppeteer code will be mostly about finding elements and interacting with them.</p>
			<p>Let's bring back the login page from our e-commerce app:</p>
			<div><div><img src="img/Figure_4.8_B16113.jpg" alt="Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Login page</p>
			<p>If we want to test the login page, we need to find these three elements: The <strong class="bold">email input</strong>, the <strong class="bold">password input</strong>, and the <strong class="bold">login button</strong>.</p>
			<p>If we right-click on each<a id="_idIndexMarker213"/> input and click on the <strong class="bold">Inspect element</strong> menu item, we will find the following:</p>
			<ul>
				<li>The email has the ID <code>email</code>.</li>
				<li>The password has the ID <code>password</code>.</li>
				<li>The login is a <code>button</code> element, with the <code>btn</code> and <code>btn-success</code> CSS classes, and the <code>style=" width: 100%;"</code> style.</li>
			</ul>
			<p>Puppeteer provides two functions to get elements from the page. The <code>$(selector)</code> function will run the <code>document.querySelector</code> function and return the first element matching that selector or <code>null</code> if no elements were found. The <code>$$(selector)</code> function will run the <code>document.querySelectorAll</code> function, returning an array of elements matching the selector or an empty array if no elements were found.</p>
			<p>If we want to implement the <code>login</code> function in our <code>LoginPageModel</code> class using these new functions, finding the login inputs would be easy:</p>
			<pre>const emailInput = await this.page.$('#email');
const passwordInput = await this.page.$('#password');</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">To find the login button, you might think that you could use the <code>btn-success</code> selector, and you could, but you shouldn't use classes used to style a button because they might change in the future if the development team changes the style. You should try to pick a CSS selector to overcome a design change.</p>
			<p>Let's re-evaluate our login button. If you look for <code>button</code> elements, you will find that you have five buttons on that page, so the <code>button</code> selector won't work. But, we can see that the login button is the only button with a <code>type="submit"</code> attribute, so we could use the <code>[type=submit]</code> CSS selector to find this element.</p>
			<p>But the <code>[type=submit]</code> selector is too generic. The developers might, for instance, add a new button with the <code>submit</code> type in the toolbar, breaking our code. But we can see that the login button is inside a form with the ID <code>login-form</code>. So now, we can create a more stable selector. So, we could look for the login button in our login function in this way:</p>
			<pre>const loginBtn = await this.page.$('#login-form [type=submit]');</pre>
			<p>Now we have everything<a id="_idIndexMarker214"/> we need to test our login page. But we are not going to interact with the login page yet. Let's go to the home page and find some more complex scenarios:</p>
			<div><div><img src="img/Figure_4.9_B16113.jpg" alt="Home Page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Home Page</p>
			<p>Let's say we want to test that the <strong class="bold">Macbook Pro 13.3' Retina MF841LL/A</strong> product has 15 items left in stock, and the price is $1,199.</p>
			<p>First, a piece of advice: It's better to code these kinds of tests down the testing pyramid. You could test the API that sends those values or the function that makes that query to the database.</p>
			<p>But let's try to solve this as a UI test:</p>
			<div><div><img src="img/Figure_4.10_B16113.jpg" alt="Product HTML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Product HTML</p>
			<p>If we take a look at the <a id="_idIndexMarker215"/>HTML, there is nothing that helps us find the product on the list, and if we were able to find the product, it's hard to find the elements inside that <code>div</code> element.</p>
			<p>Here is where the collaboration between the development team and the QA team becomes valuable. How can developers help the QA team? Using data- attributes. Your team can use a <code>data-test-</code> attribute to help you find the elements you need:</p>
			<div><div><img src="img/Figure_4.11_B16113.jpg" alt="HTML with data-test attributes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">HTML with data-test attributes</p>
			<p>As you can see in this HTML, it will be way easier to find elements with those new attributes. This is how we can get the values to test product ID <code>2</code>:</p>
			<pre>const productId = config.productToTestId;
const productDiv = await this.page.$(`[data-test-product-id="${productId}"]`);
const stockElement = await productDiv.$('[data-test-stock]');
const priceElement = await productDiv.$('[data-test-price]');</pre>
			<p>With these four lines, we were<a id="_idIndexMarker216"/> able to find the three elements for our new test: The product container and the elements containing the stock and the price.</p>
			<p>The are a few things to notice in this piece of code:</p>
			<ul>
				<li>First, remember not to hardcode values in your code. That's why we are going to grab the product ID from our config file.</li>
				<li>Second, notice that we are getting <code>stockElement</code> and <code>priceElement</code> using <code>productDiv.$</code> instead of <code>page.$</code>. That means that <em class="italic">the CSS selector you pass to that function will be processed in the element's context</em>.<p>If we'd used <code>page.$$('[data-test-stock]')</code>, we would get many elements because each product has a <code>data-test-stock</code> element, but as we use <code>productDiv.$('[data-test-stock]')</code>, we'll get the element inside <code>productDiv</code>. This is an important resource.</p></li>
				<li>The last thing to highlight here is that our development team gave us the number of items in stock inside the <code>data-test-stock</code> element. This will come in handy when we need to test the stock but notice that we don't need to use the value of the attribute, in this case, 15, to get the element. Passing the attribute as a selector will be enough. </li>
			</ul>
			<p>What if we don't have the chance to add these attributes? There is one more resource – trying to find those elements using XPath.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Finding elements using XPath</h1>
			<p>XPath <a id="_idIndexMarker217"/>is a language to query XML-like documents. Remember how we said that HTML was a relaxed kind of XML? This means that we could navigate through the DOM using some kind of XML query language such as XPath.</p>
			<p>Before digging<a id="_idIndexMarker218"/> into XPath's selectors, if you want to try XPath <a id="_idIndexMarker219"/>queries, Chrome DevTools includes a set of functions you can use inside the developer tools <code>$x</code>, which expects an XPath expression and returns an array of elements:</p>
			<div><div><img src="img/Figure_4.12_B16113.jpg" alt="Testing XPath inside the Chrome Developer Tools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Testing XPath inside the Chrome Developer Tools</p>
			<p>If you open the <code>$x('//*')</code> to test the <code>//*</code> selector.</p>
			<p>To better understand an XPath expression, you need to see your HTML as XML content. We are going to navigate this XML document from the very same root, the HTML attribute.</p>
			<h3>Select from the current node</h3>
			<p>Selector: <code>//</code>. This means "From the current node, bring me everything inside, no matter the position."</p>
			<p>Example: <code>$x('//div//a')</code> will return, from the root, all the <em class="italic">divs</em> inside the document, no <a id="_idIndexMarker220"/>matter the position, and from those <em class="italic">divs</em> all <code>a</code> elements inside that <code>div</code>, no matter the position.</p>
			<p>Are you confused about the "no matter the position" part? Well, let's now see the root selector.</p>
			<h3>Select from the root</h3>
			<p>Selector: <code>/</code>. This means "From the current node, bring me all the direct child elements."</p>
			<p>Example: If we use <code>$x('/div//a')</code>, we'll get no results because there is no <code>div</code> as a child of the <a id="_idIndexMarker221"/>root object. The only valid root option would be <code>$x('/HTML')</code> because the HTML element is the only one under the main root object. But we could do something such as <code>$x('//div/a')</code>, which would mean "Bring me all the <code>div</code> elements, and from there all the <code>a</code> elements that are a direct child of those <em class="italic">divs</em>."</p>
			<h3>Select all the elements</h3>
			<p>Selector: <code>*</code>. This means "Bring me all the elements."</p>
			<p>Example: When we say "all the elements," it will be based on the previous selector. <code>$x('/*')</code> will bring only the <a id="_idIndexMarker222"/>HTML element because that would mean "all the direct elements." But <code>$x('//*')</code> will bring you all the elements from the page.</p>
			<h3>Filter by attribute</h3>
			<p>Selector: <code>[@attributeName=value]</code>.</p>
			<p>Example: <code>$x('//div[@class="card-body"]')</code> will bring all the <code>div</code> elements where the class<a id="_idIndexMarker223"/> attribute is equal to <code>card-body</code>. This might look similar to the class selector in CSS, but it's not because this selector won't work if <code>div</code> has more than one class.</p>
			<p>Up to this point, it seems just like CSS with another syntax. What's so powerful about XPath? Well, let's get to some power tools.</p>
			<p>It turns out that the syntax we used to filter attributes is, in fact, expressions, also called predicates. This gives us the chance to not only use the <code>@attributeName</code> option but to also check for many other things.</p>
			<h3>Filter by text</h3>
			<p>Selector: <code>[text()=value]</code>.</p>
			<p>Example: <code>$x('//div[text()="Admin Panel (Testing purpose)"]')</code> will bring all the <code>div</code> elements <a id="_idIndexMarker224"/>where its content is a the text <em class="italic">Admin Panel (Testing purpose)</em>. You could even make it more generic and use something like this, <code>$x('//*[text()="Admin Panel (Testing purpose)"]')</code>, so you wouldn't care whether it's a <code>div</code> or another type of element.</p>
			<p>This function is by far one of the main reasons you would see people using XPath.</p>
			<h3>Contains a text</h3>
			<p>Selector: <code>[contains(text(), value)]</code>.</p>
			<p>Example: <em class="italic">Filter by text</em> can be tricky. The text could have some space before or after the content. If you try to select the grid button on the page using this command, <code>$x('//*[text()= "Grid"]')</code>, you won't get any results because the element has some spaces after and before <a id="_idIndexMarker225"/>the word. This <code>contains</code> function can help us when we have spaces before or after the word, or when the word is part of a larger piece of text. This is how we can use this function: <code>$x('//*[contains(text(),"Grid")]')</code>.</p>
			<p>There are many more functions. Mozilla has a good list of all the available functions (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/xpath">https://www.hardkoded.com/ui-testing-with-puppeteer/xpath</a>).</p>
			<p>We get to do really complex queries with XPath. Let's take a look our last example. We want all the elements with a price over $2,000:</p>
			<p><code>$x('//div[@class="row"]/p[1][number(substring-after(text(), "$")) &gt; 2000]')</code></p>
			<p>Wow, let's see what we are doing there:</p>
			<ul>
				<li>With <code>//div[@class="row"]</code>, we grab <code>DIVs</code> with the <code>row</code> class.</li>
				<li>With <code>p[1]</code>, we take the first <code>p</code> element. We can use positional filters here.</li>
				<li>We get the text using <code>text()</code>.</li>
				<li>As the price begins with a dollar sign, we remove it using <code>substring-after</code>.</li>
				<li>We convert that text into a number using <code>number</code>.</li>
				<li>So then, we can check whether that number is greater than 2,000.</li>
			</ul>
			<p>There is one more feature that makes XPath a powerful tool. Unlike CSS selectors, you can select the parent element with XPath using <code>..</code>.</p>
			<p>If we want to return the entire main <code>div</code> of the product with a price over $2,000, we can use the following:</p>
			<p><code>$x('//div[@class="row"]/p[1][number(substring-after(text(), "$")) &gt; 2000]/../..')</code></p>
			<p>How do we use XPath <a id="_idIndexMarker226"/>expressions in Puppeteer? You already know how to do it: We have a <code>$x</code> function.</p>
			<p>Let's go back to our test: <em class="italic">We want to test that the Macbook Pro 13.3' Retina MF841LL/A has 15 items left in stock, and the price is $1,199.</em></p>
			<p>What if the only way to find that product would be with the product name? We could do something like this:</p>
			<pre>const productName = config.productToTestName;
const productDiv = (await this.page.$x(`//a[text()="${productName}"]/../..`))[0];
const stockElement = (await productDiv.$('//h6'))[0];
const priceElement = (await productDiv.$(' //div[@class="row"]/p[1]'))[0];</pre>
			<p>Remember that <code>$x</code> returns an array of elements. In this case, as we know that they will always return one element, we take the first one.</p>
			<p>In the same way, we shouldn't rely on design classes for CSS selectors. We should try not to rely too much on the HTML structure in XPath selectors. We are assuming a couple of things in this code:</p>
			<ul>
				<li>We assume that the stock is an <code>h6</code> element.</li>
				<li>We assume that the price will be the first <code>p</code> element.</li>
			</ul>
			<p>If the design team decides that the stock will look better using <code>div</code> instead of <code>h6</code>, if they wrapped the price inside a <code>div</code> element to improve mobile navigation, your test will break.</p>
			<p>We learned how to get elements from the page, but it's important to know that the <code>$</code>, <code>$$</code>, and <code>$x</code> functions don't return an element from the DOM. They return something called <strong class="bold">element handles</strong>.</p>
			<p>Element handles<a id="_idIndexMarker227"/> are a<a id="_idIndexMarker228"/> reference to a DOM element on the page. They are a pointer that helps Puppeteer send commands to the browser, referencing an existing DOM element. They are also one of the ways we have to interact with those elements.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Interacting with Elements</h1>
			<p>Let's go back to our login test. We already have the three elements<a id="_idIndexMarker229"/> we need: The user input, the password input, and the login button. Now we need to enter the email and the password and click on the button.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Typing on input elements</h2>
			<p>The <code>ElementHandle</code> class has a <a id="_idIndexMarker230"/>function called <code>type</code>. The signature is <code>type(text, [options])</code>. The <code>options</code> class is not big this time. It only has a <code>delay</code> property. The delay is the number of milliseconds Puppeteer will wait between letters. This<a id="_idIndexMarker231"/> is great to emulate real user interaction.</p>
			<p>The first part of our test would look like this:</p>
			<pre>const emailInput = await this.page.$('#email');
await emailInput.type(user, {delay: 100});
const passwordInput = await this.page.$('#password');
await passwordInput.type(password, {delay: 100});</pre>
			<p>Here, we are looking for the email and password elements, and then emulating a user typing on those inputs. </p>
			<p>Now, we need to click on the button.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Clicking on elements</h2>
			<p>The <code>ElementHandle</code> class also has a<a id="_idIndexMarker232"/> function called <code>click</code>. I bet you are already getting the pattern. The signature is <code>click([options])</code>. You can simply call <code>click()</code>, and that would do the job. But we can also use the three available options:</p>
			<ul>
				<li><code>button</code>: This is a string with three valid options: "left," "right," or "middle."</li>
				<li><code>clickCount</code>: The default is <code>1</code>, but you could also have an impatient user clicking the same button many times, so you can emulate the user clicking on the element four times by passing <code>4</code>.</li>
				<li><code>delay</code>: This delay is not the time between clicks but the time (in milliseconds) between the mouse down action and mouse up.</li>
			</ul>
			<p>In our case, we don't need to use these options:</p>
			<pre>const loginBtn = await this.page.$('#login-form [type=submit]');
await loginBtn.click();</pre>
			<p>With these two lines, we can finally finish our <code>login</code> function. We find the login button and then we click on it.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Selecting options in drop-down lists</h2>
			<p>The<a id="_idIndexMarker233"/> site now has a<a id="_idIndexMarker234"/> drop-down list, a <code>SELECT</code> element in HTML, to switch between the grid and the list view:</p>
			<div><div><img src="img/Figure_4.13_B16113.jpg" alt="The site with a new switch option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">The site with a new switch option</p>
			<p>As you<a id="_idIndexMarker235"/> might have guessed, the function to select an option<a id="_idIndexMarker236"/> is called <code>select</code>, and the signature is <code>select(…values)</code>. It's a list of values if the <code>select</code> element has the <code>multiple</code> attribute.</p>
			<p>The next thing we need to know about this function is that the value <code>select</code> expects is not the text you see in the <code>option</code>, but the <code>option</code> of the value. We can see that by inspecting the element:</p>
			<div><div><img src="img/Figure_4.14_B16113.jpg" alt="Drop-down list options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Drop-down list options</p>
			<p>In this case, we are lucky as the value is almost the same as the visible text, but it's not the same. If we want to select the Grid item, we need to use <code>grid</code>, instead of <code>Grid</code>.</p>
			<p>If we <a id="_idIndexMarker237"/>switch the <code>option</code> to list mode, we can see that<a id="_idIndexMarker238"/> a <code>list-group-item</code> class is added to the elements:</p>
			<div><div><img src="img/Figure_4.15_B16113.jpg" alt="HTML in list mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">HTML in list mode</p>
			<p>This is how we can test this functionality:</p>
			<pre>var switchSelect = await page.$('#viewMode');
await switchSelect.select('list');
expect(await page.$$('.list-group-item')).not.to.be.empty;
await switchSelect.select('grid');
expect(await page.$$('.list-group-item')).to.be.empty;</pre>
			<p>Using <code>await</code> and <code>page.$</code> every time we need to interact with an element requires a lot of boilerplate. Imagine if we had eight inputs to fill; that would be a lot. That's why both <code>Page</code> and <code>Frame</code> (if you are dealing with child frames) have most of the functions an element <a id="_idIndexMarker239"/>handle has, but they expect a selector as a<a id="_idIndexMarker240"/> first argument.</p>
			<p>So, say we have this piece of code:</p>
			<pre>var switchSelect = await page.$('#viewMode');
await switchSelect.select('list');</pre>
			<p>It could be as simple as this:</p>
			<pre>await page.select('#viewMode', 'list');</pre>
			<p>You will find functions such as <code>page.click(selector, [options])</code>, <code>page.type(selector, text, [options])</code>, and many other interaction functions.</p>
			<p>We have covered the most common user interactions. But we can go a little deeper and try to emulate how the user would interact with the page using their keyboard and mouse.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Keyboard and Mouse emulation</h1>
			<p>Although you will be able to test the most common scenarios by typing or clicking on elements, there are other scenarios where you would need to emulate how the users interact with a site using the keyboard<a id="_idIndexMarker241"/> and the mouse. Let's take, for instance, a Google spreadsheet:</p>
			<div><div><img src="img/Figure_4.16_B16113.jpg" alt="Google Spreadsheet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Google Spreadsheet</p>
			<p>The Google spreadsheet page has a lot of keyboard and mouse interactions. You can move through the cells using your <a id="_idIndexMarker242"/>keyboard arrows or copy values by doing drag and drop with the mouse.</p>
			<p>But it doesn't need to be that complicated. Let's say that you work in the QA team at <a href="http://GitHub.com">GitHub.com</a>, and you need to test the search box from the home page.</p>
			<p>As <a href="http://GitHub.com">GitHub.com</a> is for <a id="_idIndexMarker243"/>developers, and developers for some weird reason hate using the mouse, the development team added many shortcuts on the site. We want to create a test to check that those shortcuts are working as expected:</p>
			<div><div><img src="img/Figure_4.17_B16113.jpg" alt="GitHub.com home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">GitHub.com home page</p>
			<p>As we can see there, the <a id="_idIndexMarker244"/>shortcut to the search input is a <strong class="bold">/</strong>. So, we need to do the following:</p>
			<ul>
				<li>Press slash.</li>
				<li>Type the repo name.</li>
				<li>And then press <em class="italic">Enter</em>.</li>
			</ul>
			<p>We are going to use the <code>Keyboard</code> class that the <code>Page</code> class exposes as a property.</p>
			<p>The first step is to press slash. To do that, we are going to use, you guessed it, the <code>press</code> function. The signature is <code>press(key, options)</code>. The first thing we need to know about press is that it's a shortcut to two other functions – <code>down(key, options)</code> and <code>up(key)</code>. As you can see, you can get an almost complete keyboard emulation.</p>
			<p>Notice that the first argument is not <code>text</code> but <code>key</code>. You will find the full list of supported keys here: <a href="https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout">https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout</a>. There, you will find keys such as <em class="italic">Enter</em>, <em class="italic">Backspace</em>, or <em class="italic">Shift</em>. The <code>press</code> function <a id="_idIndexMarker245"/>has two options available: First, if you assign the <code>text</code> property, Puppeteer will create an input event with that value. It would work like a macro. For instance, if the key is <code>p</code> and the text is <code>puppeteer</code>, when you would press <code>p</code>, you would get <code>puppeteer</code> in the input element. I've never found a usage for that argument, but it's there. The <code>down</code> function also has this option. The second option is <code>delay</code>, which is the time between the key down and the key up actions. </p>
			<p>The official Puppeteer documentation (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard">https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard</a>) has a perfect example for this:</p>
			<pre>await page.keyboard.type('Hello World!');
await page.keyboard.press('ArrowLeft');
await page.keyboard.down('Shift');
for (let i = 0; i &lt; ' World'.length; i++) {
  await page.keyboard.press('ArrowLeft');
}
await page.keyboard.up('Shift');
await page.keyboard.press('Backspace');</pre>
			<p>Let's unpack this code:</p>
			<ul>
				<li>It types <strong class="bold">Hello World!</strong>. The cursor is after the exclamation mark.</li>
				<li>It presses the left arrow key. Remember, <code>press</code> is <code>key down</code> and <code>key up</code>. So now the cursor is before the exclamation mark.</li>
				<li>Then, using <code>down</code>, it presses the <em class="italic">Shift</em> key, but it doesn't release the key.</li>
				<li>Then, it presses the left key as many times for the cursor to get to after the "Hello" word. But as the <em class="italic">Shift</em> key is still pressed, the "World" text got selected.</li>
				<li>Then, it releases the <em class="italic">Shift</em> key, using <code>up</code>.</li>
				<li>And what happens when you press <em class="italic">backspace</em> and we have text selected? You remove the entire selection, leaving the text <strong class="bold">Hello!</strong>. </li>
			</ul>
			<p>Now we can go and test the <a href="http://GitHub.com">GitHub.com</a> home page:</p>
			<pre>const browser = await puppeteer.launch({headless: false, defaultViewport: null});
const page = await browser.newPage();
await page.goto('https://www.github.com/');
await page.keyboard.press('Slash');
await page.keyboard.type('puppeteer')
await page.keyboard.press('Enter');</pre>
			<p>If we go back to our<a id="_idIndexMarker246"/> login example, we could test that you should be able to log in by pressing <em class="italic">Enter</em> instead of clicking on the login button. Or if the navigation between controls is important, you can jump from the user input to the password and then to the login button by pressing <em class="italic">Tab</em>.</p>
			<p>Do you want to play tic-tac-toe? Let's play it<a id="_idIndexMarker247"/> using the mouse. </p>
			<p>In the <code>Chapter4</code> folder, you will find a <code>tictactoe.html</code> file with a small tic-tac-toe game made in <strong class="bold">React</strong>:</p>
			<div><div><img src="img/Figure_4.18_B16113.jpg" alt="Tic-tac-toe game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Tic-tac-toe game</p>
			<p>If we consider the page as a canvas, where the top-left corner of the window is the coordinate <strong class="bold">(0;0)</strong> and the bottom right is the coordinate <strong class="bold">(window width, window height)</strong>, mouse interaction is about moving the mouse to an <strong class="bold">(X;Y)</strong> coordinate and clicking using one of the mouse buttons. Puppeteer offers the following functionalities.</p>
			<p>Move the mouse using <code>mouse.move(x, y, [options])</code>. The only option available in this <code>move</code> function is <code>steps</code>. With <code>steps</code>, you can tell Puppeteer how many times you want to send <code>mousemove</code> events to the page. By default, it will send only one event at the end of the mouse move action.</p>
			<p>In the same way as with the keyboard you have the <code>up</code>/<code>down</code> and <code>press</code> functions, with the mouse, you have <code>up</code>/<code>down</code> and <code>click</code>.</p>
			<p>The mouse has one extra action that the keyboard doesn't have, which is <code>wheel</code>. You can emulate mouse scrolling using <code>mouse.wheel([options])</code>. This option has two properties: <code>deltaX</code> and <code>deltaY</code>, which can be positive or negative scroll values expressed in CSS pixels.</p>
			<p>Let's go back to our tic-tac-toe game. We will do a simple test: Player 1 will use the first row and player 2 will use the second row, so player 1 will win after three moves. As this is a canvas, we need to know which coordinates we need to click.</p>
			<p>We can use the style section <a id="_idIndexMarker248"/>of the developer tools to get those coordinates. If we look at the body, we will see a 20-pixel margin that will make <code>(20;20)</code> the starting point: </p>
			<div><div><img src="img/Figure_4.19_B16113.jpg" alt="Body margin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Body margin</p>
			<p>We also know that each square is 32 px by 32 px, so the middle of the square should be <em class="italic">delta + (32 / 2)</em>. Let's test it:</p>
			<pre>const startingX = 20;
const startingY = 20;
const boxMiddle = 16;
// X turn 1;
await page.mouse.click(startingX + boxMiddle, startingY + boxMiddle);
// Y turn 1;
await page.mouse.click(startingX + boxMiddle, startingY + boxMiddle * 3);
// X turn 2;
await page.mouse.click(startingX + boxMiddle * 3, startingY + boxMiddle);
// Y turn 2;
await page.mouse.click(startingX + boxMiddle * 3, startingY + boxMiddle * 3);
// X turn 3;
await page.mouse.click(startingX + boxMiddle * 5, startingY + boxMiddle);
expect(await page.$eval('#status', status =&gt; status.innerHTML)).to.be('Winner: X');</pre>
			<p>So, here we know <a id="_idIndexMarker249"/>that the <em class="italic">tic-tac-toe</em> grid starts at the coordinate (<code>20</code>,<code>20</code>), and from there is simple math to find the right coordinates in our canvas. The first box will be clicked at the coordinate (<code>startingX + boxMiddle; startingY + boxMiddle</code>). If we want to click on the second row, it would be three middle squares, <code>startingX + boxMiddle * 3</code>, and so on until we know that we have a winner.</p>
			<p>Don't worry about the last <code>$eval</code>. We'll get there.</p>
			<p>But this is not just for games. Many modern UIs might require some mouse interactions, for instance, hoverable dropdowns or menus. We can see one example on the <em class="italic">W3Schools</em> site (<a href="https://www.w3schools.com/howto/howto_css_dropdown.asp">https://www.w3schools.com/howto/howto_css_dropdown.asp</a>):</p>
			<div><div><img src="img/Figure_4.20_B16113.jpg" alt="Hoverable dropdown&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Hoverable dropdown</p>
			<p>To be able to click<a id="_idIndexMarker250"/> on any item in that dropdown, we need to hover first on the button and then link on the option:</p>
			<pre>await page.goto("https://www.w3schools.com/howto/howto_css_dropdown.asp");
const btn = await page.$(".dropbtn");
const  box = await btn.boundingBox();
await page.mouse.move(box.x + (box.width / 2), box.y + (box.height / 2));
const  option = (await page.$x('//*[text()="Link 2"]'))[0];
await option.click();</pre>
			<p>As you can see, we don't need to guess the <code>boundingBox</code>, which returns the position (<em class="italic">x</em> and <em class="italic">y</em>) and the element's size (width and height).</p>
			<p>Is there an easier way? Yes, we can simply use <code>await btn.hover()</code>, which would hover on the element. I <a id="_idIndexMarker251"/>wanted to give you a complete example because sometimes UI components are quite sensitive to the mouse position, so you need to put the mouse in a precise location to get the desired result.</p>
			<p>Time for a bonus track. Let's talk about debugging.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Debugging tests with Visual Studio Code</h1>
			<p>Many developers consider <a id="_idIndexMarker252"/>debugging a last resort. Others<a id="_idIndexMarker253"/> would flood their code with <code>console.log</code> messages. I consider debugging a productivity tool.</p>
			<p><em class="italic">Debugging is trying to find bugs by running an application step by step.</em></p>
			<p>We have two ways of launching our tests in debug mode. The first option is creating a <strong class="bold">JavaScript debug terminal</strong> from the <strong class="bold">Terminal</strong> tab. That will create a new terminal as we did before, but in this case, Visual Studio will enable the debugger when you run a command from that terminal:</p>
			<div><div><img src="img/Figure_4.21_B16113.jpg" alt="Debugging from the terminal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Debugging from the terminal</p>
			<p>The second option is going to the <code>launch.json</code> file. You could also create that file manually inside the <code>.vscode</code> folder:</p>
			<div><div><img src="img/Figure_4.22_B16113.jpg" alt="Create a launch.json from the run tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Create a launch.json from the run tab</p>
			<p>Once we have the file, we<a id="_idIndexMarker254"/> can create a new configuration so<a id="_idIndexMarker255"/> that we can run <code>npm run test</code> in the terminal:</p>
			<pre>{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Test",
            "request": "launch",
            "runtimeArgs": [
                "run",
                "test"
            ],
            "runtimeExecutable": "npm",
            "skipFiles": [
                "&lt;node_internals&gt;/**"
            ],
            "type": "pwa-node"
        },
    ]
}</pre>
			<p>Which one is the best? Well, if you will work on this project for many days, creating the <code>launch.json</code> file is <a id="_idIndexMarker256"/>more productive; once created, you just <a id="_idIndexMarker257"/>need to hit <em class="italic">F5</em>, and you would be in debug mode. The terminal option is easier just to get running.</p>
			<p>Once you have everything set up, it is about <a id="_idIndexMarker258"/>creating <strong class="bold">breakpoints</strong> in the line you want the debugger to stop, and from there it is about taking advantage of all the tools Visual Studio Code offers:</p>
			<div><div><img src="img/Figure_4.23_B16113.jpg" alt="Visual Studio Code in debugging mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Visual Studio Code in debugging mode</p>
			<p>There you will<a id="_idIndexMarker259"/> find the following:</p>
			<ul>
				<li>At the left of the line numbers, you will find the breakpoints. You can create or remove breakpoints by clicking at the left of the line number.</li>
				<li>You will find the full list of breakpoints at the bottom left of the window. From there, you will be able to <a id="_idIndexMarker260"/>disable breakpoints temporarily.</li>
				<li>At the top right of the window, you will find debug actions: Pause, play, step in/out, and stop buttons.</li>
				<li>In the left panel, you will find two useful sections: Variables, where you can automatically get the values of all the variables in the current scope. The next panel is Watch, and you can add there the variables or expressions you want to look at while running your code.</li>
			</ul>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Summary</h1>
			<p>This chapter was massive. We began the chapter with a brief but complete introduction to HTML, the DOM, and CSS. These concepts are crucial to create top-notch tests. Then, we learned a lot about XPath, which is not a very popular tool, yet it is extremely powerful and will help you face scenarios where CSS selectors are not enough.</p>
			<p>In the second part of this chapter, we went through the most common ways to interact with a page. Not only did we learn how to interact with elements but we also covered keyboard and mouse emulation.</p>
			<p>I hope you enjoyed the tools section. Debugging with Visual Studio Code is a great tool to add to your toolbox.</p>
			<p>In the next chapter, we are going to wait for stuff. Things take time on the web. Pages take time to load. Some actions on the page might trigger network calls. The next chapter is important because you will learn how to make your tests even more stable.</p>
		</div>
	</body></html>