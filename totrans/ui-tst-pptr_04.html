<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-73"><em class="italic"><a id="_idTextAnchor072"/>Chapter 4</em>: Interacting with a page</h1>
			<p>Thanks to <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we now know how to open a browser and all the different options we have to launch browsers and create new pages. We also know how to navigate through other pages. We learned about HTTP responses and how they are related to a request.</p>
			<p>This chapter is about interaction. Emulating user interaction is essential in UI testing. There is one pattern in unit testing called <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>). This pattern enforces a particular order in the test code:</p>
			<ul>
				<li>Arrange – Prepare the context.</li>
				<li>Act – Interact with the page.  </li>
				<li>Assert – Check the page reaction.</li>
			</ul>
			<p>In this chapter, we will learn how to find elements on a page. We will understand how the development team can improve their HTML so that you can easily find elements. But if you cannot change the page HTML, we will also look at another set of tools to find the elements we need.</p>
			<p>Once we find an element, we will want to interact with it. Puppeteer provides two sets of APIs: One is action functions, such as click, select, or type. Then we have a set of emulation functions, such as mouse events or keyboard emulation. We will cover all those functions.</p>
			<p>This chapter will introduce a new object we haven't mentioned yet: <strong class="bold">The element handle</strong>.</p>
			<p>By the end of this chapter, we will have added another tool to our toolbox: The Visual Studio Code debugging tools.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to HTML, the DOM, and CSS</li>
				<li>Finding elements</li>
				<li>Finding elements using XPath</li>
				<li>Interacting with elements</li>
				<li>Keyboard and mouse emulation</li>
				<li>Interacting with multiple frames</li>
				<li>Debugging tests with Visual Studio Code</li>
			</ul>
			<p>By the end of this chapter, you will be able to emulate most types of user interaction. But first, we need to lay the groundwork. Let's talk about HTML, the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), and CSS.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter4</strong> directory. Remember to run <strong class="source-inline">npm install</strong> on that directory and then go to the <strong class="source-inline">Chapter4/vuejs-firebase-shopping-cart directory</strong> directory and run <strong class="source-inline">npm install</strong> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <strong class="source-inline">Chapter3</strong> directory.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Introduction to HTML, the DOM, and CSS</h1>
			<p>You won't be able to find elements if you don't know CSS, and you won't understand CSS if you don't understand the <strong class="bold">DOM</strong> and <strong class="bold">HTML</strong>. So, we need to start with the basics.</p>
			<p>I bet you've heard that you can build a site with HTML, CSS, and JavaScript. You might be using different server-side technologies. Your frontend might be implemented using cool technologies such as React or Angular. But in the end, the result will be a page based on HTML, CSS, and JavaScript.</p>
			<p><strong class="bold">HTML</strong> is<a id="_idIndexMarker175"/> the page's content. If you go to any website, open the <strong class="bold">DevTools</strong>, and click on the <strong class="bold">Elements</strong> tab, you will see the content of the page. You will see the page's title. If it's a news site, you will see all the articles there. If you visit a blog post, you will see the text of that post.</p>
			<p>Without <strong class="bold">CSS</strong>, an HTML<a id="_idIndexMarker176"/> page would look like text written in Notepad. CSS not only brings color and fonts, but it's also the scaffolding that gives structure to a page.</p>
			<p class="callout-heading">Fun fact</p>
			<p class="callout">Firefox has a built-in tool to disable all the styles on a page. If you go to <strong class="bold">View</strong> | <strong class="bold">Page Style</strong> and click on <strong class="bold">No Style</strong>, you will see how our life would be without CSS.</p>
			<p>The last piece is JavaScript. JavaScript brings behavior to a page. Once the browser parses the HTML and builds the DOM, it allows us to manipulate and give life to a page.</p>
			<p>But, as I mentioned before, we need to go to the basics, to the foundations of the web. Let's begin with HTML.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>HTML</h2>
			<p><strong class="bold">HTML</strong> stands for <strong class="bold">HyperText Markup Language</strong>: HyperText because the HTML is not content per se; HTML<a id="_idIndexMarker177"/> contains the content. Markup because it uses tags to give meaning to that content. And language because, although many developers disagree and they get mad about the idea, HTML is a language.</p>
			<p>If we read an HTML file as a data structure, we can say that HTML is a <strong class="bold">relaxed</strong> version of XML. So, to better understand HTML, we need to look at the basics of XML.</p>
			<p>These are the basic elements of XML content:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.1_B16113.jpg" alt="XML Content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">XML Content</p>
			<p>If you look at this <a id="_idIndexMarker178"/>figure, you already know almost everything you need to know about XML. Well, maybe I'm exaggerating. But this is the idea:</p>
			<ul>
				<li>You have elements, which are represented as <strong class="source-inline">&lt;ElementName&gt;</strong>. In our example, we have <strong class="bold">&lt;</strong><strong class="source-inline">element&gt;</strong> and <strong class="source-inline">&lt;child-element&gt;</strong>.</li>
				<li>The element might have attributes, which are represented as <strong class="source-inline">AttributeName=" AttributeValue"</strong>. We have <strong class="source-inline">value="3</strong><strong class="bold">"</strong> and <strong class="source-inline">value="4"</strong> in our example.</li>
				<li>The element might contain other elements. You can see we have two <strong class="bold">child-element</strong> elements inside the main <strong class="bold">element</strong>.</li>
				<li>An element finishes (is closed) with <strong class="source-inline">&lt;/ElementName&gt;</strong>, or with <strong class="source-inline">/&gt;</strong> at the end instead of <strong class="source-inline">&gt;</strong>.</li>
			</ul>
			<p>XML parsers<a id="_idIndexMarker179"/> are very strict with these rules. If the XML content you are trying to parse breaks just a single rule, the parser will consider the entire XML invalid. Whether it's a missing closing element or an attribute without quotes, the parser will fail to evaluate the XML content.</p>
			<p>But we will find that browsers are not that strict when parsing HTML content. Let's take a look at the following HTML:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.2_B16113.jpg" alt="A broken HTML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A broken HTML</p>
			<p>This simple HTML<a id="_idIndexMarker180"/> will print <em class="italic">Hello World</em> in red in the browser.</p>
			<p>Is this valid XML? No. As you can see, the <strong class="source-inline">&lt;div&gt;</strong> element is not closed. But is this valid HTML? Yes.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The fact that a browser would try to render <em class="italic">broken</em> HTML doesn't mean that you should take that lightly. It's possible you have heard a developer say that a particular bug was due to a <em class="italic">missing closing div</em>. If the HTML is broken, for instance, it has a missing closing <strong class="source-inline">div</strong>, the browser will try to guess the best way to render that HTML. The decision the browser makes when trying to fix broken HTML could end up with the page working as expected or with the full page layout broken.</p>
			<p>Another interesting concept is that the XML specification doesn't give meaning to the elements. The names of the elements, the attributes, and the resulting information coming from that content depend on who wrote the XML and who is reading it.</p>
			<p>HTML is XML<a id="_idIndexMarker181"/> with meaning. In <em class="italic">1993</em>, <em class="italic">Tim Berners-Lee</em>, who is known as the inventor of the World Wide Web, decided that the main element would be called <strong class="source-inline">HTML</strong> and that it would contain a <strong class="source-inline">BODY</strong>. He decided that images would be represented as <strong class="source-inline">IMG</strong> elements, paragraphs would be <strong class="source-inline">P</strong> elements, and so on. Over the years, browser and web developers followed and improved this convention, getting to what we today call HTML5. We, as a community, agreed on the meaning of HTML elements.</p>
			<p>We agreed that if we add the <strong class="source-inline">text</strong> attribute with the value <strong class="source-inline">red</strong>, we will get the text in red, and so on. How many types of elements do we have in HTML? A lot! The good news is that you don't need to know all of them. </p>
			<p>The more you know, the more productive you will be. However, these are the most common elements you will find on a page.</p>
			<h3>Document structure elements</h3>
			<p>Every HTML document will <a id="_idIndexMarker182"/>be contained inside an <strong class="source-inline">&lt;html&gt;</strong> element. That <a id="_idIndexMarker183"/>HTML element will have two child elements. The first element you will find is <strong class="source-inline">&lt;head&gt;</strong>. Inside that <strong class="source-inline">&lt;head&gt;</strong> element, you will find metadata elements, such as <strong class="source-inline">&lt;title&gt;</strong> with the page title, and many <strong class="source-inline">&lt;meta&gt;</strong> elements with metadata not supported by the standard HTML. Many sites use <strong class="source-inline">&lt;meta&gt;</strong> to enforce how the page should be shown on social media. The second set of elements you will find are <strong class="bold">include elements</strong>: <strong class="source-inline">&lt;link&gt;</strong> elements, including CSS files, and <strong class="source-inline">&lt;script&gt;</strong> files, including JavaScript code. Although the script elements are accepted in the header, most sites would add their script elements at the bottom of the page for faster rendering. </p>
			<p>The second element you will find is the <strong class="source-inline">&lt;body&gt;</strong> element. The page itself will be inside this element.</p>
			<h3>Text elements</h3>
			<p>Then <a id="_idIndexMarker184"/>we have the <a id="_idIndexMarker185"/>basic text elements. </p>
			<p><strong class="source-inline">&lt;h1&gt;</strong>, <strong class="source-inline">&lt;h2&gt;</strong>, <strong class="source-inline">&lt;h3&gt;</strong>, <strong class="source-inline">&lt;h4&gt;</strong>, <strong class="source-inline">&lt;h5&gt;</strong>, and <strong class="source-inline">&lt;h6&gt;</strong> are headings. If you have a text editor, you might have seen that there are many levels of headings and subheadings.</p>
			<p><strong class="source-inline">&lt;p&gt;</strong> will denote paragraphs. Then you might find <strong class="source-inline">&lt;span&gt;</strong> elements, which help style part of the text in a paragraph.</p>
			<p>Another type of<a id="_idIndexMarker186"/> text element is <strong class="source-inline">&lt;label&gt;</strong>. These labels are linked to an input <a id="_idIndexMarker187"/>control, such as a radio button, giving context to that control. For example, a radio button or a checkbox doesn't have text; it's just a check or a radio. You need a label to give them context:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.3_B16113.jpg" alt="Radio buttons with labels&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Radio buttons with labels</p>
			<p>This HTML has three labels. <em class="italic">Huey</em> gives context to the first radio option, <em class="italic">Dewey</em> to the second, and <em class="italic">Louie</em> to the last one.</p>
			<p>The last type of text element we will look at is list elements. Lists are expressed as a parent element, <strong class="source-inline">&lt;ul&gt;</strong> for unordered lists or <strong class="source-inline">&lt;ol&gt;</strong> for ordered lists, and <strong class="source-inline">&lt;li&gt;</strong> elements. You will see lots of these in menu bars.</p>
			<h3>Action elements</h3>
			<p>There are two main<a id="_idIndexMarker188"/> action elements<a id="_idIndexMarker189"/> in HTML. The <strong class="source-inline">&lt;a&gt;</strong> anchor, also known as a link, was designed to take you to another page, but these days it's not limited to that, and it could trigger actions inside the page.</p>
			<p>The second element is <strong class="source-inline">&lt;button&gt;</strong>, which again, although it was designed to send data to the server using an HTTP POST request, is now being used for many other kinds of actions:</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The days when you would only use buttons and links to perform actions are in the past. As most HTML elements support click events, you will find pages that show elements as buttons, but in fact, those buttons are HTML elements <a id="_idIndexMarker190"/>such as <strong class="bold">DIVs</strong>.</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.4_B16113.jpg" alt="Links and buttons at packtpub.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Links and buttons at packtpub.com</p>
			<p>Many times, you<a id="_idIndexMarker191"/> won't notice the<a id="_idIndexMarker192"/> difference between a link and a button. For instance, in the <a href="http://packtpub.com">packtpub.com</a> site, the search button is a <strong class="source-inline">button</strong> element, whereas the cart button is, in fact, an <strong class="source-inline">anchor</strong>.</p>
			<p>Most of your automation code will involve clicking on these action elements.</p>
			<h3>Container Elements</h3>
			<p>The role<a id="_idIndexMarker193"/> of container elements<a id="_idIndexMarker194"/> is grouping elements, mostly for layout and style purposes. The most popular element is <strong class="source-inline">DIV</strong>. What is <strong class="source-inline">DIV</strong>? It can be anything: A list of items, a popup, a header, anything. It is used to create groups of elements.</p>
			<p>One element that was the king of the container elements was <strong class="source-inline">TABLE</strong>. As you can infer from the name, a table represents a grid. Inside a <strong class="source-inline">TABLE</strong> element, you can have <strong class="source-inline">TR</strong> elements representing rows, <strong class="source-inline">TH</strong> elements representing header cells, and <strong class="source-inline">TD</strong> elements representing a column inside a row. I mentioned that this <em class="italic">was</em> the king of containers because the community has now moved on from tables to <strong class="source-inline">DIVs</strong> due to performance issues, the need for more complex layouts, and responsiveness issues. But you might still see some tables on sites showing information using a grid style.</p>
			<p><strong class="bold">HTML5</strong> brought a <a id="_idIndexMarker195"/>new kind of <a id="_idIndexMarker196"/>container element: The <strong class="bold">Semantic Elements</strong>. The goal of <a id="_idIndexMarker197"/>these semantic HTML elements is<a id="_idIndexMarker198"/> to communicate the type of content the element contains. So, instead of using DIVs for everything, developers should start using elements such as <strong class="source-inline">&lt;header&gt;</strong> for the site header, <strong class="source-inline">&lt;footer&gt;</strong> for the footer, <strong class="source-inline">&lt;nav&gt;</strong> for the navigation options, <strong class="source-inline">&lt;articles&gt;</strong> for blog posts, and so on. The purpose of these elements is to help external tools (such as screen readers, search engines, and even the same browser) to understand the HTML content.</p>
			<h3>Input elements</h3>
			<p>The last group of elements we need to<a id="_idIndexMarker199"/> know about are the input elements. The most common input element<a id="_idIndexMarker200"/> is the multifaceted <strong class="source-inline">input</strong> element. Depending on the <strong class="source-inline">type</strong> attribute, it can be <strong class="source-inline">"text"</strong>, <strong class="source-inline">"password"</strong>, <strong class="source-inline">"checkbox"</strong>, <strong class="source-inline">"file"</strong> (upload), and so on; the list goes on to a total of 22 types.</p>
			<p>Then we have <strong class="source-inline">select</strong> elements for drop-down lists and the <strong class="source-inline">option</strong> element to represent the items of a drop-down list. </p>
			<p>Of course, we shouldn't forget the <strong class="source-inline">&lt;IMG&gt;</strong> element. It's impossible to picture a site without images. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Not every input you will see these days will be one of these elements. To make inputs more user-friendly or just nicer, you will find that developers might build inputs based on many other elements. For instance, you could find a drop-down list, which instead of being a select element would be an input element, plus an arrow button, which would show a floating list on clicking it. This kind of control makes sites prettier but automation more challenging.</p>
			<p>HTML has not only a known list of elements but also a known list of attributes. These are the most common attributes you will find:</p>
			<ul>
				<li><strong class="source-inline">id</strong>: Identifies a unique element. It's the element ID in the <strong class="source-inline">DOM</strong> (we will talk about the DOM in the next section).</li>
				<li><strong class="source-inline">class</strong>: Contains the CSS classes applied to the element. It accepts more than one CSS class separated by a space.</li>
				<li><strong class="source-inline">style</strong>: CSS style assigned to the element.</li>
			</ul>
			<p>HTML won't limit<a id="_idIndexMarker201"/> the attributes you can add to an element. You can add any <a id="_idIndexMarker202"/>attribute you want, for instance, <strong class="source-inline">defaultColor="blue"</strong>. One convention is using <strong class="bold">data- attributes</strong> (pronounced data dash attributes). The browser will parse these <a id="_idIndexMarker203"/>attributes and make them available in the DOM. So, although <strong class="source-inline">defaultColor</strong> is a valid attribute, the general convention uses <strong class="source-inline">data-default-color="blue"</strong> instead.</p>
			<p>The other set of attributes of <a id="_idIndexMarker204"/>interest to us is the <strong class="bold">Accessible Rich Internet Applications</strong> (<strong class="bold">ARIA</strong>) attributes. These attributes are being added to help accessibility tools, such as screen readers. Why would we be interested in those attributes? Because developers express things such as the <em class="italic">role</em> or the <em class="italic">state</em> of an element. If you find a site using ARIA, finding the selected menu item would be a matter of finding the element with <strong class="source-inline">role="treeitem"</strong> and <strong class="source-inline">aria-expanded="true"</strong>.</p>
			<p>In the past few paragraphs, the DOM has been mentioned a few times. Let's talk about the DOM.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>The DOM</h2>
			<p>The DOM is <a id="_idIndexMarker205"/>the interface you can use in JavaScript to interact with the HTML. According to the MDN (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/dom">https://www.hardkoded.com/ui-testing-with-puppeteer/dom</a>), it is <em class="italic">the data representation of the objects that comprise the structure and content of a document on the web</em>. Why should we care about that? Because we are going to use the same tools to automate our pages.</p>
			<p>In the previous section, we mentioned that an element might have an ID. You'll find that the search input at <a href="https://www.packtpub.com/">https://www.packtpub.com/</a> has the ID search, so you will be able to get that element in JavaScript using <strong class="source-inline">document.getElementById('search')</strong>.</p>
			<p>You might be wondering: How do I know the ID of a button? Or how do I check that the ID is valid? Remember we talked about the dev tools?</p>
			<p>The developer <a id="_idIndexMarker206"/>tools can be opened by clicking on the three dots in the top-right corner of Chrome and then going to <strong class="bold">More Tools</strong> | <strong class="bold">Developer Tools</strong>. You can also use the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">J</em> shortcut in Windows or <em class="italic">Cmd</em> + <em class="italic">Option</em> + <em class="italic">I</em> in macOS:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.5_B16113.jpg" alt="Developer Tools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Developer Tools</p>
			<p>If you right-click on any element on the page, for instance, the search button, you will find the <strong class="bold">Inspect</strong> option, which will select that element in the <strong class="bold">Elements</strong> tab. There you will be able to see all the attributes of that element:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_4.6_B16113.jpg" alt="Inspect option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Inspect option</p>
			<p>Another tab you<a id="_idIndexMarker207"/> will use a lot is the <strong class="bold">Console</strong> tab, where you will be able to run JavaScript code. If you are in the <strong class="bold">Elements</strong> tab and press the <em class="italic">Esc</em> key, you will get the <strong class="bold">Console</strong> tab below the <strong class="bold">Elements</strong> one. From there, you will be able to test your code:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_4.7_B16113.jpg" alt="Console tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Console tab</p>
			<p>Another set of functions that you will use a lot are <strong class="source-inline">document.querySelector</strong> and <strong class="source-inline">document.querySelectorAll</strong>. The first function returns the first element matching a CSS selector, whereas the second function returns a list of elements matching a CSS selector. So, we need to learn about some CSS selectors next.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>CSS Selectors</h2>
			<p>You don't need to learn <a id="_idIndexMarker208"/>CSS to understand how to style a page, but you should master how to find elements on a page. There are around 60 different selectors (<a href="https://www.w3schools.com/cssref/css_selectors.asp">https://www.w3schools.com/cssref/css_selectors.asp</a>) we can use for finding elements. We won't cover all 60 here, but let's go through the most common selectors:</p>
			<ul>
				<li>Select by element name:<p>Selector: <strong class="source-inline">ElementName</strong>.</p><p>Example: <strong class="source-inline">input</strong> will select <strong class="source-inline">&lt;input&gt;</strong> elements.</p></li>
				<li>Select by class name:<p>Selector: <strong class="source-inline">.ClassName</strong>.</p><p>Example: <strong class="source-inline">.input-text</strong> will select any element that contains the <strong class="source-inline">input-text</strong> class. </p><p>If you look at the search input in <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>, the class attribute is <strong class="source-inline">class="input-text algolia-search-input aa-input"</strong>. This selector won't check whether the class attribute is equal to <strong class="source-inline">input-text</strong>. It has to contain it.</p></li>
				<li>Select by ID:<p>Selector: <strong class="source-inline">#SomeID</strong>.</p><p>Example: <strong class="source-inline">#search</strong> will select the element with the <strong class="source-inline">search</strong> ID. In this case, it does check equality.</p></li>
				<li>Select by attribute:<p>Selector: <strong class="source-inline">[attribute=value]</strong>.</p><p>Example: <strong class="source-inline">[aria-labelledby= "search"]</strong> will select the element with the <strong class="source-inline">aria-labelledby</strong> attribute with the value <strong class="source-inline">search</strong>. This is an excellent example of the use of ARIA attributes for automation.</p></li>
			</ul>
			<p>This selector is not<a id="_idIndexMarker209"/> limited by only the equality check (<strong class="source-inline">=</strong>). You could use only <strong class="source-inline">[attribute]</strong> to check whether the element contains the attribute, no matter the value. You can also use many other operators. For example, you can use <strong class="source-inline">*=</strong> to check whether the attribute contains a value or <strong class="source-inline">|=</strong> to check whether it begins with a value.</p>
			<h3>Combining selectors</h3>
			<p>What's great about CSS is<a id="_idIndexMarker210"/> that you can combine all these selectors. You could use <strong class="source-inline">input.input-search[aria-labelledby=" search"]</strong> to select an input with the <strong class="source-inline">input-search</strong> class and the <strong class="source-inline">aria-labelledby</strong> attribute with the value <strong class="source-inline">search</strong>.</p>
			<p>You can also look for child elements. CSS allows us to "cascade" (that's what the <em class="italic">C</em> in <em class="italic">CSS</em> stands for) selectors. You can search for child elements by adding new selectors separated by a space. Let's take, for instance, the following selector:</p>
			<p class="source-code"><strong class="source-inline">form .algolia-autocomplete input</strong></p>
			<p>If you read it backwards, it will select an <strong class="source-inline">input</strong> inside an element with the <strong class="source-inline">algolia-autocomplete</strong> class, which is inside a <strong class="source-inline">form</strong> element. Notice that I said an input <em class="italic">inside</em> an element with the <strong class="source-inline">algolia-autocomplete</strong> class. That doesn't need to be the direct parent of the input element. </p>
			<p>If you want to check strictly a parent-child relationship, you can separate selectors with a <strong class="source-inline">&gt;</strong> instead of a space:</p>
			<p class="source-code"><strong class="source-inline">.algolia-autocomplete &gt; input</strong></p>
			<p>This selector will look for an input whose direct parent element is an element with the <strong class="source-inline">algolia-autocomplete</strong> class.</p>
			<p>Maybe you are thinking, why do I need to know all this information? I just want to get up and running with Puppeteer! Let me tell you something: You will spend half of your time inside the developer tools, and the most frequent element in your code will be a CSS selector. The more you <a id="_idIndexMarker211"/>know about HTML, the DOM, and CSS, the more proficient you will be at browser automation.</p>
			<p>But now it's time to go back to the Puppeteer world.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Finding elements</h1>
			<p>It's time to apply <a id="_idIndexMarker212"/>everything we have learned so far. We need to master selectors because our Puppeteer code will be mostly about finding elements and interacting with them.</p>
			<p>Let's bring back the login page from our e-commerce app:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_4.8_B16113.jpg" alt="Login page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Login page</p>
			<p>If we want to test the login page, we need to find these three elements: The <strong class="bold">email input</strong>, the <strong class="bold">password input</strong>, and the <strong class="bold">login button</strong>.</p>
			<p>If we right-click on each<a id="_idIndexMarker213"/> input and click on the <strong class="bold">Inspect element</strong> menu item, we will find the following:</p>
			<ul>
				<li>The email has the ID <strong class="source-inline">email</strong>.</li>
				<li>The password has the ID <strong class="source-inline">password</strong>.</li>
				<li>The login is a <strong class="source-inline">button</strong> element, with the <strong class="source-inline">btn</strong> and <strong class="source-inline">btn-success</strong> CSS classes, and the <strong class="source-inline">style=" width: 100%;"</strong> style.</li>
			</ul>
			<p>Puppeteer provides two functions to get elements from the page. The <strong class="source-inline">$(selector)</strong> function will run the <strong class="source-inline">document.querySelector</strong> function and return the first element matching that selector or <strong class="source-inline">null</strong> if no elements were found. The <strong class="source-inline">$$(selector)</strong> function will run the <strong class="source-inline">document.querySelectorAll</strong> function, returning an array of elements matching the selector or an empty array if no elements were found.</p>
			<p>If we want to implement the <strong class="source-inline">login</strong> function in our <strong class="source-inline">LoginPageModel</strong> class using these new functions, finding the login inputs would be easy:</p>
			<p class="source-code">const emailInput = await this.page.$('#email');</p>
			<p class="source-code">const passwordInput = await this.page.$('#password');</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To find the login button, you might think that you could use the <strong class="source-inline">btn-success</strong> selector, and you could, but you shouldn't use classes used to style a button because they might change in the future if the development team changes the style. You should try to pick a CSS selector to overcome a design change.</p>
			<p>Let's re-evaluate our login button. If you look for <strong class="source-inline">button</strong> elements, you will find that you have five buttons on that page, so the <strong class="source-inline">button</strong> selector won't work. But, we can see that the login button is the only button with a <strong class="source-inline">type="submit"</strong> attribute, so we could use the <strong class="source-inline">[type=submit]</strong> CSS selector to find this element.</p>
			<p>But the <strong class="source-inline">[type=submit]</strong> selector is too generic. The developers might, for instance, add a new button with the <strong class="source-inline">submit</strong> type in the toolbar, breaking our code. But we can see that the login button is inside a form with the ID <strong class="source-inline">login-form</strong>. So now, we can create a more stable selector. So, we could look for the login button in our login function in this way:</p>
			<p class="source-code">const loginBtn = await this.page.$('#login-form [type=submit]');</p>
			<p>Now we have everything<a id="_idIndexMarker214"/> we need to test our login page. But we are not going to interact with the login page yet. Let's go to the home page and find some more complex scenarios:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_4.9_B16113.jpg" alt="Home Page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Home Page</p>
			<p>Let's say we want to test that the <strong class="bold">Macbook Pro 13.3' Retina MF841LL/A</strong> product has 15 items left in stock, and the price is $1,199.</p>
			<p>First, a piece of advice: It's better to code these kinds of tests down the testing pyramid. You could test the API that sends those values or the function that makes that query to the database.</p>
			<p>But let's try to solve this as a UI test:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_4.10_B16113.jpg" alt="Product HTML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Product HTML</p>
			<p>If we take a look at the <a id="_idIndexMarker215"/>HTML, there is nothing that helps us find the product on the list, and if we were able to find the product, it's hard to find the elements inside that <strong class="source-inline">div</strong> element.</p>
			<p>Here is where the collaboration between the development team and the QA team becomes valuable. How can developers help the QA team? Using data- attributes. Your team can use a <strong class="source-inline">data-test-</strong> attribute to help you find the elements you need:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_4.11_B16113.jpg" alt="HTML with data-test attributes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">HTML with data-test attributes</p>
			<p>As you can see in this HTML, it will be way easier to find elements with those new attributes. This is how we can get the values to test product ID <strong class="source-inline">2</strong>:</p>
			<p class="source-code">const productId = config.productToTestId;</p>
			<p class="source-code">const productDiv = await this.page.$(`[data-test-product-id="${productId}"]`);</p>
			<p class="source-code">const stockElement = await productDiv.$('[data-test-stock]');</p>
			<p class="source-code">const priceElement = await productDiv.$('[data-test-price]');</p>
			<p>With these four lines, we were<a id="_idIndexMarker216"/> able to find the three elements for our new test: The product container and the elements containing the stock and the price.</p>
			<p>The are a few things to notice in this piece of code:</p>
			<ul>
				<li>First, remember not to hardcode values in your code. That's why we are going to grab the product ID from our config file.</li>
				<li>Second, notice that we are getting <strong class="source-inline">stockElement</strong> and <strong class="source-inline">priceElement</strong> using <strong class="source-inline">productDiv.$</strong> instead of <strong class="source-inline">page.$</strong>. That means that <em class="italic">the CSS selector you pass to that function will be processed in the element's context</em>.<p>If we'd used <strong class="source-inline">page.$$('[data-test-stock]')</strong>, we would get many elements because each product has a <strong class="source-inline">data-test-stock</strong> element, but as we use <strong class="source-inline">productDiv.$('[data-test-stock]')</strong>, we'll get the element inside <strong class="source-inline">productDiv</strong>. This is an important resource.</p></li>
				<li>The last thing to highlight here is that our development team gave us the number of items in stock inside the <strong class="source-inline">data-test-stock</strong> element. This will come in handy when we need to test the stock but notice that we don't need to use the value of the attribute, in this case, 15, to get the element. Passing the attribute as a selector will be enough. </li>
			</ul>
			<p>What if we don't have the chance to add these attributes? There is one more resource – trying to find those elements using XPath.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Finding elements using XPath</h1>
			<p>XPath <a id="_idIndexMarker217"/>is a language to query XML-like documents. Remember how we said that HTML was a relaxed kind of XML? This means that we could navigate through the DOM using some kind of XML query language such as XPath.</p>
			<p>Before digging<a id="_idIndexMarker218"/> into XPath's selectors, if you want to try XPath <a id="_idIndexMarker219"/>queries, Chrome DevTools includes a set of functions you can use inside the developer tools <strong class="bold">Console</strong> tab (<a href="https://developers.google.com/web/tools/chrome-devtools/console/utilities">https://hardkoded.com/ui-testing-with-puppeteer/console</a>). One of these functions is <strong class="source-inline">$x</strong>, which expects an XPath expression and returns an array of elements:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_4.12_B16113.jpg" alt="Testing XPath inside the Chrome Developer Tools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Testing XPath inside the Chrome Developer Tools</p>
			<p>If you open the <strong class="bold">Console</strong> tab on any page, you can run <strong class="source-inline">$x('//*')</strong> to test the <strong class="source-inline">//*</strong> selector.</p>
			<p>To better understand an XPath expression, you need to see your HTML as XML content. We are going to navigate this XML document from the very same root, the HTML attribute.</p>
			<h3>Select from the current node</h3>
			<p>Selector: <strong class="source-inline">//</strong>. This means "From the current node, bring me everything inside, no matter the position."</p>
			<p>Example: <strong class="source-inline">$x('//div//a')</strong> will return, from the root, all the <em class="italic">divs</em> inside the document, no <a id="_idIndexMarker220"/>matter the position, and from those <em class="italic">divs</em> all <strong class="source-inline">a</strong> elements inside that <strong class="source-inline">div</strong>, no matter the position.</p>
			<p>Are you confused about the "no matter the position" part? Well, let's now see the root selector.</p>
			<h3>Select from the root</h3>
			<p>Selector: <strong class="source-inline">/</strong>. This means "From the current node, bring me all the direct child elements."</p>
			<p>Example: If we use <strong class="source-inline">$x('/div//a')</strong>, we'll get no results because there is no <strong class="source-inline">div</strong> as a child of the <a id="_idIndexMarker221"/>root object. The only valid root option would be <strong class="source-inline">$x('/HTML')</strong> because the HTML element is the only one under the main root object. But we could do something such as <strong class="source-inline">$x('//div/a')</strong>, which would mean "Bring me all the <strong class="source-inline">div</strong> elements, and from there all the <strong class="source-inline">a</strong> elements that are a direct child of those <em class="italic">divs</em>."</p>
			<h3>Select all the elements</h3>
			<p>Selector: <strong class="source-inline">*</strong>. This means "Bring me all the elements."</p>
			<p>Example: When we say "all the elements," it will be based on the previous selector. <strong class="source-inline">$x('/*')</strong> will bring only the <a id="_idIndexMarker222"/>HTML element because that would mean "all the direct elements." But <strong class="source-inline">$x('//*')</strong> will bring you all the elements from the page.</p>
			<h3>Filter by attribute</h3>
			<p>Selector: <strong class="source-inline">[@attributeName=value]</strong>.</p>
			<p>Example: <strong class="source-inline">$x('//div[@class="card-body"]')</strong> will bring all the <strong class="source-inline">div</strong> elements where the class<a id="_idIndexMarker223"/> attribute is equal to <strong class="source-inline">card-body</strong>. This might look similar to the class selector in CSS, but it's not because this selector won't work if <strong class="source-inline">div</strong> has more than one class.</p>
			<p>Up to this point, it seems just like CSS with another syntax. What's so powerful about XPath? Well, let's get to some power tools.</p>
			<p>It turns out that the syntax we used to filter attributes is, in fact, expressions, also called predicates. This gives us the chance to not only use the <strong class="source-inline">@attributeName</strong> option but to also check for many other things.</p>
			<h3>Filter by text</h3>
			<p>Selector: <strong class="source-inline">[text()=value]</strong>.</p>
			<p>Example: <strong class="source-inline">$x('//div[text()="Admin Panel (Testing purpose)"]')</strong> will bring all the <strong class="source-inline">div</strong> elements <a id="_idIndexMarker224"/>where its content is a the text <em class="italic">Admin Panel (Testing purpose)</em>. You could even make it more generic and use something like this, <strong class="source-inline">$x('//*[text()="Admin Panel (Testing purpose)"]')</strong>, so you wouldn't care whether it's a <strong class="source-inline">div</strong> or another type of element.</p>
			<p>This function is by far one of the main reasons you would see people using XPath.</p>
			<h3>Contains a text</h3>
			<p>Selector: <strong class="source-inline">[contains(text(), value)]</strong>.</p>
			<p>Example: <em class="italic">Filter by text</em> can be tricky. The text could have some space before or after the content. If you try to select the grid button on the page using this command, <strong class="source-inline">$x('//*[text()= "Grid"]')</strong>, you won't get any results because the element has some spaces after and before <a id="_idIndexMarker225"/>the word. This <strong class="source-inline">contains</strong> function can help us when we have spaces before or after the word, or when the word is part of a larger piece of text. This is how we can use this function: <strong class="source-inline">$x('//*[contains(text(),"Grid")]')</strong>.</p>
			<p>There are many more functions. Mozilla has a good list of all the available functions (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/xpath">https://www.hardkoded.com/ui-testing-with-puppeteer/xpath</a>).</p>
			<p>We get to do really complex queries with XPath. Let's take a look our last example. We want all the elements with a price over $2,000:</p>
			<p><strong class="source-inline">$x('//div[@class="row"]/p[1][number(substring-after(text(), "$")) &gt; 2000]')</strong></p>
			<p>Wow, let's see what we are doing there:</p>
			<ul>
				<li>With <strong class="source-inline">//div[@class="row"]</strong>, we grab <strong class="source-inline">DIVs</strong> with the <strong class="source-inline">row</strong> class.</li>
				<li>With <strong class="source-inline">p[1]</strong>, we take the first <strong class="source-inline">p</strong> element. We can use positional filters here.</li>
				<li>We get the text using <strong class="source-inline">text()</strong>.</li>
				<li>As the price begins with a dollar sign, we remove it using <strong class="source-inline">substring-after</strong>.</li>
				<li>We convert that text into a number using <strong class="source-inline">number</strong>.</li>
				<li>So then, we can check whether that number is greater than 2,000.</li>
			</ul>
			<p>There is one more feature that makes XPath a powerful tool. Unlike CSS selectors, you can select the parent element with XPath using <strong class="source-inline">..</strong>.</p>
			<p>If we want to return the entire main <strong class="source-inline">div</strong> of the product with a price over $2,000, we can use the following:</p>
			<p><strong class="source-inline">$x('//div[@class="row"]/p[1][number(substring-after(text(), "$")) &gt; 2000]/../..')</strong></p>
			<p>How do we use XPath <a id="_idIndexMarker226"/>expressions in Puppeteer? You already know how to do it: We have a <strong class="source-inline">$x</strong> function.</p>
			<p>Let's go back to our test: <em class="italic">We want to test that the Macbook Pro 13.3' Retina MF841LL/A has 15 items left in stock, and the price is $1,199.</em></p>
			<p>What if the only way to find that product would be with the product name? We could do something like this:</p>
			<p class="source-code">const productName = config.productToTestName;</p>
			<p class="source-code">const productDiv = (await this.page.$x(`//a[text()="${productName}"]/../..`))[0];</p>
			<p class="source-code">const stockElement = (await productDiv.$('//h6'))[0];</p>
			<p class="source-code">const priceElement = (await productDiv.$(' //div[@class="row"]/p[1]'))[0];</p>
			<p>Remember that <strong class="source-inline">$x</strong> returns an array of elements. In this case, as we know that they will always return one element, we take the first one.</p>
			<p>In the same way, we shouldn't rely on design classes for CSS selectors. We should try not to rely too much on the HTML structure in XPath selectors. We are assuming a couple of things in this code:</p>
			<ul>
				<li>We assume that the stock is an <strong class="source-inline">h6</strong> element.</li>
				<li>We assume that the price will be the first <strong class="source-inline">p</strong> element.</li>
			</ul>
			<p>If the design team decides that the stock will look better using <strong class="source-inline">div</strong> instead of <strong class="source-inline">h6</strong>, if they wrapped the price inside a <strong class="source-inline">div</strong> element to improve mobile navigation, your test will break.</p>
			<p>We learned how to get elements from the page, but it's important to know that the <strong class="source-inline">$</strong>, <strong class="source-inline">$$</strong>, and <strong class="source-inline">$x</strong> functions don't return an element from the DOM. They return something called <strong class="bold">element handles</strong>.</p>
			<p>Element handles<a id="_idIndexMarker227"/> are a<a id="_idIndexMarker228"/> reference to a DOM element on the page. They are a pointer that helps Puppeteer send commands to the browser, referencing an existing DOM element. They are also one of the ways we have to interact with those elements.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Interacting with Elements</h1>
			<p>Let's go back to our login test. We already have the three elements<a id="_idIndexMarker229"/> we need: The user input, the password input, and the login button. Now we need to enter the email and the password and click on the button.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Typing on input elements</h2>
			<p>The <strong class="source-inline">ElementHandle</strong> class has a <a id="_idIndexMarker230"/>function called <strong class="source-inline">type</strong>. The signature is <strong class="source-inline">type(text, [options])</strong>. The <strong class="source-inline">options</strong> class is not big this time. It only has a <strong class="source-inline">delay</strong> property. The delay is the number of milliseconds Puppeteer will wait between letters. This<a id="_idIndexMarker231"/> is great to emulate real user interaction.</p>
			<p>The first part of our test would look like this:</p>
			<p class="source-code">const emailInput = await this.page.$('#email');</p>
			<p class="source-code">await emailInput.type(user, {delay: 100});</p>
			<p class="source-code">const passwordInput = await this.page.$('#password');</p>
			<p class="source-code">await passwordInput.type(password, {delay: 100});</p>
			<p>Here, we are looking for the email and password elements, and then emulating a user typing on those inputs. </p>
			<p>Now, we need to click on the button.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Clicking on elements</h2>
			<p>The <strong class="source-inline">ElementHandle</strong> class also has a<a id="_idIndexMarker232"/> function called <strong class="source-inline">click</strong>. I bet you are already getting the pattern. The signature is <strong class="source-inline">click([options])</strong>. You can simply call <strong class="source-inline">click()</strong>, and that would do the job. But we can also use the three available options:</p>
			<ul>
				<li><strong class="source-inline">button</strong>: This is a string with three valid options: "left," "right," or "middle."</li>
				<li><strong class="source-inline">clickCount</strong>: The default is <strong class="source-inline">1</strong>, but you could also have an impatient user clicking the same button many times, so you can emulate the user clicking on the element four times by passing <strong class="source-inline">4</strong>.</li>
				<li><strong class="source-inline">delay</strong>: This delay is not the time between clicks but the time (in milliseconds) between the mouse down action and mouse up.</li>
			</ul>
			<p>In our case, we don't need to use these options:</p>
			<p class="source-code">const loginBtn = await this.page.$('#login-form [type=submit]');</p>
			<p class="source-code">await loginBtn.click();</p>
			<p>With these two lines, we can finally finish our <strong class="source-inline">login</strong> function. We find the login button and then we click on it.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Selecting options in drop-down lists</h2>
			<p>The<a id="_idIndexMarker233"/> site now has a<a id="_idIndexMarker234"/> drop-down list, a <strong class="source-inline">SELECT</strong> element in HTML, to switch between the grid and the list view:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_4.13_B16113.jpg" alt="The site with a new switch option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">The site with a new switch option</p>
			<p>As you<a id="_idIndexMarker235"/> might have guessed, the function to select an option<a id="_idIndexMarker236"/> is called <strong class="source-inline">select</strong>, and the signature is <strong class="source-inline">select(…values)</strong>. It's a list of values if the <strong class="source-inline">select</strong> element has the <strong class="source-inline">multiple</strong> attribute.</p>
			<p>The next thing we need to know about this function is that the value <strong class="source-inline">select</strong> expects is not the text you see in the <strong class="source-inline">option</strong>, but the <strong class="source-inline">option</strong> of the value. We can see that by inspecting the element:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_4.14_B16113.jpg" alt="Drop-down list options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Drop-down list options</p>
			<p>In this case, we are lucky as the value is almost the same as the visible text, but it's not the same. If we want to select the Grid item, we need to use <strong class="source-inline">grid</strong>, instead of <strong class="source-inline">Grid</strong>.</p>
			<p>If we <a id="_idIndexMarker237"/>switch the <strong class="source-inline">option</strong> to list mode, we can see that<a id="_idIndexMarker238"/> a <strong class="source-inline">list-group-item</strong> class is added to the elements:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_4.15_B16113.jpg" alt="HTML in list mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">HTML in list mode</p>
			<p>This is how we can test this functionality:</p>
			<p class="source-code">var switchSelect = await page.$('#viewMode');</p>
			<p class="source-code">await switchSelect.select('list');</p>
			<p class="source-code">expect(await page.$$('.list-group-item')).not.to.be.empty;</p>
			<p class="source-code">await switchSelect.select('grid');</p>
			<p class="source-code">expect(await page.$$('.list-group-item')).to.be.empty;</p>
			<p>Using <strong class="source-inline">await</strong> and <strong class="source-inline">page.$</strong> every time we need to interact with an element requires a lot of boilerplate. Imagine if we had eight inputs to fill; that would be a lot. That's why both <strong class="source-inline">Page</strong> and <strong class="source-inline">Frame</strong> (if you are dealing with child frames) have most of the functions an element <a id="_idIndexMarker239"/>handle has, but they expect a selector as a<a id="_idIndexMarker240"/> first argument.</p>
			<p>So, say we have this piece of code:</p>
			<p class="source-code">var switchSelect = await page.$('#viewMode');</p>
			<p class="source-code">await switchSelect.select('list');</p>
			<p>It could be as simple as this:</p>
			<p class="source-code">await page.select('#viewMode', 'list');</p>
			<p>You will find functions such as <strong class="source-inline">page.click(selector, [options])</strong>, <strong class="source-inline">page.type(selector, text, [options])</strong>, and many other interaction functions.</p>
			<p>We have covered the most common user interactions. But we can go a little deeper and try to emulate how the user would interact with the page using their keyboard and mouse.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Keyboard and Mouse emulation</h1>
			<p>Although you will be able to test the most common scenarios by typing or clicking on elements, there are other scenarios where you would need to emulate how the users interact with a site using the keyboard<a id="_idIndexMarker241"/> and the mouse. Let's take, for instance, a Google spreadsheet:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_4.16_B16113.jpg" alt="Google Spreadsheet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Google Spreadsheet</p>
			<p>The Google spreadsheet page has a lot of keyboard and mouse interactions. You can move through the cells using your <a id="_idIndexMarker242"/>keyboard arrows or copy values by doing drag and drop with the mouse.</p>
			<p>But it doesn't need to be that complicated. Let's say that you work in the QA team at <a href="http://GitHub.com">GitHub.com</a>, and you need to test the search box from the home page.</p>
			<p>As <a href="http://GitHub.com">GitHub.com</a> is for <a id="_idIndexMarker243"/>developers, and developers for some weird reason hate using the mouse, the development team added many shortcuts on the site. We want to create a test to check that those shortcuts are working as expected:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_4.17_B16113.jpg" alt="GitHub.com home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">GitHub.com home page</p>
			<p>As we can see there, the <a id="_idIndexMarker244"/>shortcut to the search input is a <strong class="bold">/</strong>. So, we need to do the following:</p>
			<ul>
				<li>Press slash.</li>
				<li>Type the repo name.</li>
				<li>And then press <em class="italic">Enter</em>.</li>
			</ul>
			<p>We are going to use the <strong class="source-inline">Keyboard</strong> class that the <strong class="source-inline">Page</strong> class exposes as a property.</p>
			<p>The first step is to press slash. To do that, we are going to use, you guessed it, the <strong class="source-inline">press</strong> function. The signature is <strong class="source-inline">press(key, options)</strong>. The first thing we need to know about press is that it's a shortcut to two other functions – <strong class="source-inline">down(key, options)</strong> and <strong class="source-inline">up(key)</strong>. As you can see, you can get an almost complete keyboard emulation.</p>
			<p>Notice that the first argument is not <strong class="source-inline">text</strong> but <strong class="source-inline">key</strong>. You will find the full list of supported keys here: <a href="https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout">https://www.hardkoded.com/ui-testing-with-puppeteer/USKeyboardLayout</a>. There, you will find keys such as <em class="italic">Enter</em>, <em class="italic">Backspace</em>, or <em class="italic">Shift</em>. The <strong class="source-inline">press</strong> function <a id="_idIndexMarker245"/>has two options available: First, if you assign the <strong class="source-inline">text</strong> property, Puppeteer will create an input event with that value. It would work like a macro. For instance, if the key is <strong class="source-inline">p</strong> and the text is <strong class="source-inline">puppeteer</strong>, when you would press <strong class="source-inline">p</strong>, you would get <strong class="source-inline">puppeteer</strong> in the input element. I've never found a usage for that argument, but it's there. The <strong class="source-inline">down</strong> function also has this option. The second option is <strong class="source-inline">delay</strong>, which is the time between the key down and the key up actions. </p>
			<p>The official Puppeteer documentation (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard">https://www.hardkoded.com/ui-testing-with-puppeteer/keyboard</a>) has a perfect example for this:</p>
			<p class="source-code">await page.keyboard.type('Hello World!');</p>
			<p class="source-code">await page.keyboard.press('ArrowLeft');</p>
			<p class="source-code">await page.keyboard.down('Shift');</p>
			<p class="source-code">for (let i = 0; i &lt; ' World'.length; i++) {</p>
			<p class="source-code">  await page.keyboard.press('ArrowLeft');</p>
			<p class="source-code">}</p>
			<p class="source-code">await page.keyboard.up('Shift');</p>
			<p class="source-code">await page.keyboard.press('Backspace');</p>
			<p>Let's unpack this code:</p>
			<ul>
				<li>It types <strong class="bold">Hello World!</strong>. The cursor is after the exclamation mark.</li>
				<li>It presses the left arrow key. Remember, <strong class="source-inline">press</strong> is <strong class="source-inline">key down</strong> and <strong class="source-inline">key up</strong>. So now the cursor is before the exclamation mark.</li>
				<li>Then, using <strong class="source-inline">down</strong>, it presses the <em class="italic">Shift</em> key, but it doesn't release the key.</li>
				<li>Then, it presses the left key as many times for the cursor to get to after the "Hello" word. But as the <em class="italic">Shift</em> key is still pressed, the "World" text got selected.</li>
				<li>Then, it releases the <em class="italic">Shift</em> key, using <strong class="source-inline">up</strong>.</li>
				<li>And what happens when you press <em class="italic">backspace</em> and we have text selected? You remove the entire selection, leaving the text <strong class="bold">Hello!</strong>. </li>
			</ul>
			<p>Now we can go and test the <a href="http://GitHub.com">GitHub.com</a> home page:</p>
			<p class="source-code">const browser = await puppeteer.launch({headless: false, defaultViewport: null});</p>
			<p class="source-code">const page = await browser.newPage();</p>
			<p class="source-code">await page.goto('https://www.github.com/');</p>
			<p class="source-code">await page.keyboard.press('Slash');</p>
			<p class="source-code">await page.keyboard.type('puppeteer')</p>
			<p class="source-code">await page.keyboard.press('Enter');</p>
			<p>If we go back to our<a id="_idIndexMarker246"/> login example, we could test that you should be able to log in by pressing <em class="italic">Enter</em> instead of clicking on the login button. Or if the navigation between controls is important, you can jump from the user input to the password and then to the login button by pressing <em class="italic">Tab</em>.</p>
			<p>Do you want to play tic-tac-toe? Let's play it<a id="_idIndexMarker247"/> using the mouse. </p>
			<p>In the <strong class="source-inline">Chapter4</strong> folder, you will find a <strong class="source-inline">tictactoe.html</strong> file with a small tic-tac-toe game made in <strong class="bold">React</strong>:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_4.18_B16113.jpg" alt="Tic-tac-toe game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Tic-tac-toe game</p>
			<p>If we consider the page as a canvas, where the top-left corner of the window is the coordinate <strong class="bold">(0;0)</strong> and the bottom right is the coordinate <strong class="bold">(window width, window height)</strong>, mouse interaction is about moving the mouse to an <strong class="bold">(X;Y)</strong> coordinate and clicking using one of the mouse buttons. Puppeteer offers the following functionalities.</p>
			<p>Move the mouse using <strong class="source-inline">mouse.move(x, y, [options])</strong>. The only option available in this <strong class="source-inline">move</strong> function is <strong class="source-inline">steps</strong>. With <strong class="source-inline">steps</strong>, you can tell Puppeteer how many times you want to send <strong class="source-inline">mousemove</strong> events to the page. By default, it will send only one event at the end of the mouse move action.</p>
			<p>In the same way as with the keyboard you have the <strong class="source-inline">up</strong>/<strong class="source-inline">down</strong> and <strong class="source-inline">press</strong> functions, with the mouse, you have <strong class="source-inline">up</strong>/<strong class="source-inline">down</strong> and <strong class="source-inline">click</strong>.</p>
			<p>The mouse has one extra action that the keyboard doesn't have, which is <strong class="source-inline">wheel</strong>. You can emulate mouse scrolling using <strong class="source-inline">mouse.wheel([options])</strong>. This option has two properties: <strong class="source-inline">deltaX</strong> and <strong class="source-inline">deltaY</strong>, which can be positive or negative scroll values expressed in CSS pixels.</p>
			<p>Let's go back to our tic-tac-toe game. We will do a simple test: Player 1 will use the first row and player 2 will use the second row, so player 1 will win after three moves. As this is a canvas, we need to know which coordinates we need to click.</p>
			<p>We can use the style section <a id="_idIndexMarker248"/>of the developer tools to get those coordinates. If we look at the body, we will see a 20-pixel margin that will make <strong class="source-inline">(20;20)</strong> the starting point: </p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_4.19_B16113.jpg" alt="Body margin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Body margin</p>
			<p>We also know that each square is 32 px by 32 px, so the middle of the square should be <em class="italic">delta + (32 / 2)</em>. Let's test it:</p>
			<p class="source-code">const startingX = 20;</p>
			<p class="source-code">const startingY = 20;</p>
			<p class="source-code">const boxMiddle = 16;</p>
			<p class="source-code">// X turn 1;</p>
			<p class="source-code">await page.mouse.click(startingX + boxMiddle, startingY + boxMiddle);</p>
			<p class="source-code">// Y turn 1;</p>
			<p class="source-code">await page.mouse.click(startingX + boxMiddle, startingY + boxMiddle * 3);</p>
			<p class="source-code">// X turn 2;</p>
			<p class="source-code">await page.mouse.click(startingX + boxMiddle * 3, startingY + boxMiddle);</p>
			<p class="source-code">// Y turn 2;</p>
			<p class="source-code">await page.mouse.click(startingX + boxMiddle * 3, startingY + boxMiddle * 3);</p>
			<p class="source-code">// X turn 3;</p>
			<p class="source-code">await page.mouse.click(startingX + boxMiddle * 5, startingY + boxMiddle);</p>
			<p class="source-code">expect(await page.$eval('#status', status =&gt; status.innerHTML)).to.be('Winner: X');</p>
			<p>So, here we know <a id="_idIndexMarker249"/>that the <em class="italic">tic-tac-toe</em> grid starts at the coordinate (<strong class="source-inline">20</strong>,<strong class="source-inline">20</strong>), and from there is simple math to find the right coordinates in our canvas. The first box will be clicked at the coordinate (<strong class="source-inline">startingX + boxMiddle; startingY + boxMiddle</strong>). If we want to click on the second row, it would be three middle squares, <strong class="source-inline">startingX + boxMiddle * 3</strong>, and so on until we know that we have a winner.</p>
			<p>Don't worry about the last <strong class="source-inline">$eval</strong>. We'll get there.</p>
			<p>But this is not just for games. Many modern UIs might require some mouse interactions, for instance, hoverable dropdowns or menus. We can see one example on the <em class="italic">W3Schools</em> site (<a href="https://www.w3schools.com/howto/howto_css_dropdown.asp">https://www.w3schools.com/howto/howto_css_dropdown.asp</a>):</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_4.20_B16113.jpg" alt="Hoverable dropdown&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Hoverable dropdown</p>
			<p>To be able to click<a id="_idIndexMarker250"/> on any item in that dropdown, we need to hover first on the button and then link on the option:</p>
			<p class="source-code">await page.goto("https://www.w3schools.com/howto/howto_css_dropdown.asp");</p>
			<p class="source-code">const btn = await page.$(".dropbtn");</p>
			<p class="source-code">const  box = await btn.boundingBox();</p>
			<p class="source-code">await page.mouse.move(box.x + (box.width / 2), box.y + (box.height / 2));</p>
			<p class="source-code">const  option = (await page.$x('//*[text()="Link 2"]'))[0];</p>
			<p class="source-code">await option.click();</p>
			<p>As you can see, we don't need to guess the <strong class="bold">Hover me</strong> button's location. The element handle provides a function called <strong class="source-inline">boundingBox</strong>, which returns the position (<em class="italic">x</em> and <em class="italic">y</em>) and the element's size (width and height).</p>
			<p>Is there an easier way? Yes, we can simply use <strong class="source-inline">await btn.hover()</strong>, which would hover on the element. I <a id="_idIndexMarker251"/>wanted to give you a complete example because sometimes UI components are quite sensitive to the mouse position, so you need to put the mouse in a precise location to get the desired result.</p>
			<p>Time for a bonus track. Let's talk about debugging.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Debugging tests with Visual Studio Code</h1>
			<p>Many developers consider <a id="_idIndexMarker252"/>debugging a last resort. Others<a id="_idIndexMarker253"/> would flood their code with <strong class="source-inline">console.log</strong> messages. I consider debugging a productivity tool.</p>
			<p><em class="italic">Debugging is trying to find bugs by running an application step by step.</em></p>
			<p>We have two ways of launching our tests in debug mode. The first option is creating a <strong class="bold">JavaScript debug terminal</strong> from the <strong class="bold">Terminal</strong> tab. That will create a new terminal as we did before, but in this case, Visual Studio will enable the debugger when you run a command from that terminal:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_4.21_B16113.jpg" alt="Debugging from the terminal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Debugging from the terminal</p>
			<p>The second option is going to the <strong class="bold">Run</strong> tab and creating a <strong class="source-inline">launch.json</strong> file. You could also create that file manually inside the <strong class="source-inline">.vscode</strong> folder:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_4.22_B16113.jpg" alt="Create a launch.json from the run tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Create a launch.json from the run tab</p>
			<p>Once we have the file, we<a id="_idIndexMarker254"/> can create a new configuration so<a id="_idIndexMarker255"/> that we can run <strong class="source-inline">npm run test</strong> in the terminal:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "version": "0.2.0",</p>
			<p class="source-code">    "configurations": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">            "name": "Test",</p>
			<p class="source-code">            "request": "launch",</p>
			<p class="source-code">            "runtimeArgs": [</p>
			<p class="source-code">                "run",</p>
			<p class="source-code">                "test"</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "runtimeExecutable": "npm",</p>
			<p class="source-code">            "skipFiles": [</p>
			<p class="source-code">                "&lt;node_internals&gt;/**"</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "type": "pwa-node"</p>
			<p class="source-code">        },</p>
			<p class="source-code">    ]</p>
			<p class="source-code">}</p>
			<p>Which one is the best? Well, if you will work on this project for many days, creating the <strong class="source-inline">launch.json</strong> file is <a id="_idIndexMarker256"/>more productive; once created, you just <a id="_idIndexMarker257"/>need to hit <em class="italic">F5</em>, and you would be in debug mode. The terminal option is easier just to get running.</p>
			<p>Once you have everything set up, it is about <a id="_idIndexMarker258"/>creating <strong class="bold">breakpoints</strong> in the line you want the debugger to stop, and from there it is about taking advantage of all the tools Visual Studio Code offers:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_4.23_B16113.jpg" alt="Visual Studio Code in debugging mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Visual Studio Code in debugging mode</p>
			<p>There you will<a id="_idIndexMarker259"/> find the following:</p>
			<ul>
				<li>At the left of the line numbers, you will find the breakpoints. You can create or remove breakpoints by clicking at the left of the line number.</li>
				<li>You will find the full list of breakpoints at the bottom left of the window. From there, you will be able to <a id="_idIndexMarker260"/>disable breakpoints temporarily.</li>
				<li>At the top right of the window, you will find debug actions: Pause, play, step in/out, and stop buttons.</li>
				<li>In the left panel, you will find two useful sections: Variables, where you can automatically get the values of all the variables in the current scope. The next panel is Watch, and you can add there the variables or expressions you want to look at while running your code.</li>
			</ul>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Summary</h1>
			<p>This chapter was massive. We began the chapter with a brief but complete introduction to HTML, the DOM, and CSS. These concepts are crucial to create top-notch tests. Then, we learned a lot about XPath, which is not a very popular tool, yet it is extremely powerful and will help you face scenarios where CSS selectors are not enough.</p>
			<p>In the second part of this chapter, we went through the most common ways to interact with a page. Not only did we learn how to interact with elements but we also covered keyboard and mouse emulation.</p>
			<p>I hope you enjoyed the tools section. Debugging with Visual Studio Code is a great tool to add to your toolbox.</p>
			<p>In the next chapter, we are going to wait for stuff. Things take time on the web. Pages take time to load. Some actions on the page might trigger network calls. The next chapter is important because you will learn how to make your tests even more stable.</p>
		</div>
	</body></html>