- en: Chapter 2. Review of Important JavaScript OOP Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start creating and using our modules in JavaScript, it is important
    to have a good grasp of important **Object Oriented Programming** (**OOP**) concepts
    in JavaScript. We will rely on such concepts to design and implement our application
    modules in later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: While my intent in this chapter is not to explore such conceptes in great depth,
    I will try to provide a good overview of some of the most important related topics.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel that you are quite familiar with these concepts in JavaScript, you
    could skip this chapter and move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are not very familiar with OOP in JavaScript, even if you are
    familiar with similar concepts in classical object oriented languages, I encourage
    you to follow along as things are a little different in JavaScript. I think it
    will be worthwhile for you to have a look at these concepts in the realm of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript objects and their constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What `this` keyword is and how it behaves in different contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure and its uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And other related topics.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have programmed in JavaScript before (as I'm sure you have, since this
    book is intended for intermediate to advanced JavaScript programmers), you will
    certainly have used objects, even if you have not been aware of their inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with other more classical object oriented languages (such
    as C++, C#, or Java), you'll be surprised to know that there is no formal syntax
    for defining classes in JavaScript (at least till **ECMAScript 6**). I think you'll
    be even more surprised to find out that, without having a formal syntax, you are
    still able to create classes in JavaScript and harness the full power of object
    oriented design and architecture (and one could even argue in a more flexible
    way).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Formal class definition in JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: In the newer version of JavaScript (ES6), new syntax allows you to define classes
    in a more formal and structured way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://es6-features.org/](http://es6-features.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create objects in JavaScript in many different ways but we will focus
    on three of these approaches for creating objects in this chapter. These approaches
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Using native object type constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object literal notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using constructor functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object type constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the easiest way to create objects in JavaScript is to create an instance
    of the Object type and then augment it with properties that we need.
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, the Object type is the top level object (the root object)
    in JavaScript that all other objects are created from behind the scenes. This
    object has many properties which have been defined for it by default. Every object
    created based on this type will inherit these default properties such as `toString`,
    `valueOf`, `hasOwnProperty`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following syntax as it shows the creation of an object using
    the `Object` constructor and augmenting it with custom properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This syntax for creating objects was very popular at one point. However, it
    is no longer used as much, since using other methods of creating objects allows
    for a better conceptual view of how the object properties are packaged. Also,
    using an object constructor is not as optimized, since the interpreter needs to
    do a scope resolution to determine whether there is a local constructor with the
    same name or not, in order to create the scope chain properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Regarding scope chains**'
  prefs: []
  type: TYPE_NORMAL
- en: A **scope chain** is a chain of objects whose properties are looked for when
    looking for the existence and value of a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu](https://blogs.msdn.microsoft.com/jscript/2007/07/26/scope-chain-of-jscript-fu)'
  prefs: []
  type: TYPE_NORMAL
- en: Object literal notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating objects using **object literal notation** allows for a good conceptual
    view of the object and all of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is also very popular for passing multiple parameters to functions
    instead of passing one parameter at a time. This method of passing parameters
    allows us to package all the parameters neatly into an object (usually as an anonymous
    object) and pass it as one parameter into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this syntax, an object in JavaScript can be created as simply as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this object does not do anything and is completely useless, but nonetheless
    it is a valid object (**Singleton**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another object using this approach, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we have created a variable that has been initialized with
    an object. Our object here consists of two value properties and a simple method
    (method property) to add these value properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with the object in the preceding code, we can use the variable
    that holds (references) the object `MyfirstObj` and access its members using the
    dot notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Function objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, functions are considered first class objects. In fact, anytime
    you are dealing with a function, you are dealing with an object.
  prefs: []
  type: TYPE_NORMAL
- en: We do not always use functions as objects in JavaScript but, when are used as
    objects, we can use them as constructors to create other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as object constructors (classes)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s mimic the object definition in the previous section, which was written
    as an object literal, and create a constructor function to achieve the same functionality.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I have created a function and called it `MyObjDefinition`. I named
    the function as such to indicate that this function is going to be used as a definition
    (class) to create other objects from.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `new` keyword, we can create an instance of this object and assign
    it to the `myFirstObj` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not used to using function objects as constructors, at this point
    you might wonder if `MyObjDefinition` is a function, a class, or an object?
  prefs: []
  type: TYPE_NORMAL
- en: Well, `MyObjDefinition` is all of those! I will explain this in more depth shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as static objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's modify the preceding code so we can see how `MyObjDefinition` can be better
    thought of as an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have moved our inner `addValues` method to the outside of
    the object definition and used the dot notation to add it to `MyObjDefinition`
    object as a property.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we can use such syntax is because JavaScript considers `MyObjDefinition`
    function as both a function and an object. Since we can assign properties to objects
    dynamically in JavaScript, we are able to assign the `addValues` function as a
    property to this object, using the dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have called our object definition as a regular function to initialize
    the default values for the `myFirstValue` and `mySecondValue` properties. Of course,
    we can do this because `MyObjDefinition` is also a function.
  prefs: []
  type: TYPE_NORMAL
- en: We also have changed the `myFirstValue` and `mySecondValue` variables inside
    the function definition to `MyObjDefinition.myFirstValue` and `MyObjDefinition.mySecondValue`,
    respectively. This is so `MyObjDefinition.addValues` can access them from outside
    the function definition. If you are not sure what `this` keyword is, do not be
    concerned as we will talk about it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the two values, we can still use the same syntax as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are not able to use `MyObjDefinition` as a constructor function
    as we did before, since now it is acting as a static object. So the following
    will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, while we are creating an object using the `new` keyword, the
    created object does not have the properties of the `MyObjDefinition` function.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise in re-factoring of our code shows how functions can act as function
    as well as objects in JavaScript, depending on the usage.
  prefs: []
  type: TYPE_NORMAL
- en: I like the flexibility that JavaScript offers in how objects can be defined,
    as well as how dynamic properties can be added to objects as needed. However,
    I can see why some programmers with a background in more classical object oriented
    languages might find the approach a little confusing.
  prefs: []
  type: TYPE_NORMAL
- en: My take on the subject is that JavaScript has its own realm and it is best to
    understand it within its realm, as opposed to trying to see it in the context
    of classical object oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: Object literal notation versus function objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While both object literal notation and function object syntax can be used to
    create objects, there are situations when one approach is better suited than the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, after the script is parsed, all the function declarations in
    the program are hoisted to the beginning of the script. That is why you can call
    a function before its actual definition in the code, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, every time `CreatePerson` function is called a new object
    is created, augmented, and then returned. This approach is also known as the **Object
    Factory** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design patterns in JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with design patterns in general or would like to become
    more familiar with design patterns in JavaScript, I highly recommend the following
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering JavaScript Design Patterns*, *Simon Timms*.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the call to the `CreatePerson` function is taking place before the
    actual function definition. This code will not generate an error when it is run
    because of function hoisting. Behind the scenes, the function `CreatePerson` has
    been hoisted to the top of the script so when the call is made to this function,
    the declaration has already been encountered by the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this mechanism, you don't have to worry if the call to the function
    takes place before the function declaration or not.
  prefs: []
  type: TYPE_NORMAL
- en: This does not apply to object literals since there are no function declarations
    and, thus, no hoisting involved. Therefore, all the calls to such objects need
    to happen AFTER the object definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are first defining an object, using object literal notation, and then
    adding a property to it. Everything works fine and as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we try to add a property to this object before the object definition,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will encounter an error.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that, in the case of constructor functions, the `Person`
    function in our example, we can pass arguments to the constructor and create different
    instances of `Person` with different names and different job titles. However,
    this cannot be done when using object literal notation to create objects.
  prefs: []
  type: TYPE_NORMAL
- en: As you can tell by now, these different approaches for creating objects are
    suited for different purposes. Most of the time, we use constructor functions
    when we need to create multiple instances of an object but use object literal
    notation to package parameters (data) that need to be passed to different parts
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Objects created using object literal notation are also best suited for creating
    modular code, which we will see a whole lot more of later in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make things a little more interesting and re-factor the preceding code
    so we can use both approaches to creating objects together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using object literal notation to create a person data object (`personData`)
    and then pass this data object as a package to the `CreatePerson` constructor
    to create our `firstPerson` instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the chapters ahead, we will be using both of these object creation approaches
    to create our modules.
  prefs: []
  type: TYPE_NORMAL
- en: The "this" keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw an example of using the `this` keyword when we looked at our static
    object in this chapter. We will now spend some time on `this` to understand what
    it is and how it can help us write better code.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` keyword is simply a reference to an object. However, that reference
    can point to different objects at different times, depending on the code execution
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what that means, let''s start by creating a simple constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `this` keyword has a global context. So inside the
    `Person` function, `this` refers to the `window` object (if the code is run in
    a browser). In fact, if we execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now created two properties for the `window` object, called `name` and
    `job`. We can prove this by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that adding properties to the global context (the `window` object)
    is not a good idea and will pollute the global context as well as creating a high
    possibility of naming collisions. This could result in unexpected behavior in
    the code and strange bugs that are hard to track.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `this` keyword can take a whole new context and reference a totally
    different object, when used as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a new person object using our `CreatePerson` constructor.
    By using the `new` keyword, an instance of person is created and the variable
    `firstPerson` now holds a reference to this instance. This person instance has
    its `name` property set to `Tom` and its `job` property to `Software Developer`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `this` keyword inside this object now refers to the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another person object definition as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And use our constructor function to create an instance of this second person.
  prefs: []
  type: TYPE_NORMAL
- en: Once the following code is executed, `this` will refer to the instance of this
    second person.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine the properties of the second person, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Things can get a little more interesting at times and a bit harder to figure
    out what the context of `this` can be in different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this example, we have defined an object using object literal
    notation. This object is assigned to the `myOwnObject` variable and its `getName`
    method returns the value of the `name` property in the object. So, as you might
    expect, `this` in this context refers to the context of `myOwnObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we make an assignment such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the result: **The window global**. This result is rather
    confusing.'
  prefs: []
  type: TYPE_NORMAL
- en: When we make the above assignment, only the function gets assigned from the
    left side of the expression to the right side of the expression and now `this`
    refers to the global object. Note that, in this scenario, `myOwnObject.getName`
    is just a function and as explained before `this` inside a function (not an instance
    of an object) always refers to the global context, which produces the result,
    **The window global**, when executed in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider another object definition and create an inner function (a **Closure**,
    which we will talk about shortly) inside this object. The context of `this` may
    not be what you expect in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the innermost function is an anonymous function inside another anonymous
    function, the context of the innermost function is different from the object that
    is hosting it. Therefore, `this` in this context is referencing the global context.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to preserve the context of `myOwnObject`, we can create a context
    in the first inner function and let the innermost function access this context.
    So we can rewrite our object definition as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach, we create a context inside the first inner function which
    references our object and then the innermost function can access this context,
    which is defined in its container (the first anonymous function). This results
    in the innermost anonymous function accessing the context of `myOwnObject` object.
  prefs: []
  type: TYPE_NORMAL
- en: As shown, it can be a little challenging to figure out what context `this` refers
    to at times but with practice and more experience you will become better at it.
    However, till then, don't take the context of `this` for granted and make sure
    that the context which you think `this` refers to is in fact the context that
    has been set for `this` in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have had a brief discussion regarding execution context as it relates
    to `this`, it is time to talk about Closures. If you don't have a lot of experience
    with JavaScript, or if you are coming from more classical object oriented languages
    such as C++, you might find the concept of Closures a bit confusing in the beginning.
    In this section, I will try to take the mystery out of this concept and explain
    why Closures can be very useful in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind Closures is about preserving context and (mostly) how an
    inner function can keep the context of its containing parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, innermost function `setTestValue` takes a number as a parameter
    and sets it as the starting value to be used for comparison later.
  prefs: []
  type: TYPE_NORMAL
- en: When this function is executed, it also returns an anonymous function whose
    reference will be stored in the `theNumberExaminer` variable. This anonymous function
    is then used to compare a value passed to it with the value that was set as the
    starting value (`firstNum`) in the `setTestValue` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we only pass one value `(2)` to `theNumberExaminer` to be compared
    against the starting number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is: how does `theNumberExaminer` have access to the previous value
    passed to the `setTestValue` function?'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when a function is returned, its execution context is removed and
    thus all the values related to that function's execution context are destroyed.
    However, with **Closures**, things work a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the inner anonymous function is returned from the `setTestValue` function
    call (`setTestValue(6)`) and, with it, the execution context of its parent function.
    This allows the anonymous function to have access to the value of `firstNum`.
  prefs: []
  type: TYPE_NORMAL
- en: This relationship will hold as long as the inner function (the anonymous function)
    is not destroyed. The context of the parent object remains in memory because there
    is still a reference to the inner function.
  prefs: []
  type: TYPE_NORMAL
- en: The most important point is that Closures allow for inner functions to have
    access to the execution context of their parent functions (objects) as part of
    their scope chain. As values in the scope of the outer function change, the inner
    function can have access to the most recent values.
  prefs: []
  type: TYPE_NORMAL
- en: 'One advantage of creating and using Closures can be shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first create an instance of `myClosedObject` and then
    we execute the `publicFunc` of this instance. This call changes the value of `privateValue`
    from `5` to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: When we call this method one more time, the value of `privateValue` will change
    to `20`. This is because after the first call to `publicFunc` the value of `privateValue`
    has been preserved (thanks to the created Closure). The second call to `publicFunc`,
    uses the most up to date value of `privateValue` (which is 10) to do its calculation,
    thus resulting in the value `20` being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and scoping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may know, in JavaScript the idea of encapsulation is handled a little
    differently from most classical object oriented languages, since we really don't
    have a formal definition for classes (ECMAScript 6 introduces formal class definition).
  prefs: []
  type: TYPE_NORMAL
- en: When we create a variable inside a function using the keyword `var`, we are
    creating a **private** variable inside of that function, thus the scope of the
    variable is contained within the function. This also means that, if we use the
    function as a constructor function, such variables are not copied to the instances
    created using this constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: Also, JavaScript does not have the concept of block scopes; instead it has function
    scope, so all the variables declared inside a function are accessible throughout
    the function block (ECMAScript 6 introduced block scopes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `thirdValue` variable has been defined within the `for`
    loop block, but we can access it after the end of the `for` loop, since in JavaScript
    the scope of variables is bound to the scope of the container function and not
    the container block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, code external to this function cannot access such variables, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the above code will produce `undefined` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also cannot get access to `this.instanceValue` since inside a function `this`
    references the window object, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we use the preceding function as a constructor function and
    create an instance of the `simpleFunc` object?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you know, when we define a variable with the `this` keyword, it is copied
    to the instances of the object and hence `testObj` has a copy of it and we can
    access it from the outside code.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we take this a step further and create a private scope (**namespace**)
    inside the constructor function, then even the inner functions of the constructor
    function will not have access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code above shows an immediately invoked anonymous function (also known as
    **IIFE**) inside our `simpleFunc` function, and even though this function has
    access to the execution context of its containing function, the containing function
    (`simpleFunc`) cannot access the variables and methods inside this inner function.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we have created a private namespace inside our `simpleFunc` that is
    completely hidden from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: The same is also true for when we create an instance of `simpleFunc` and try
    to access `this.inastanceValue`, since this variable is only accessible from inside
    the scope of the inner anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, while JavaScript may not have the same form of encapsulation
    as classical object oriented languages, we can still create private scopes, and
    define variables and methods inside that scope that are not accessible from the
    outside code.
  prefs: []
  type: TYPE_NORMAL
- en: We will be re-visiting this concept and its usages a lot more when we design
    our application modules in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You may also be asking yourself, "What if I want to create a constructor function
    which provides public methods, so I can access private members of the constructor
    function using these public methods?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this constructor, we have created a private member `privateValue` that is
    not accessible from the outside world. However, we have created a public method
    `this.readPrivateValue`, which can be accessed by the external code and can access
    the value of this private member.
  prefs: []
  type: TYPE_NORMAL
- en: So here, we have achieved two goals. First, we have kept our private member
    protected, and second, we have still provided read access to such private member
    through our public method.
  prefs: []
  type: TYPE_NORMAL
- en: The method `this.readPrivateValue` can be considered a **privileged method**,
    which means this public member has access to private members of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a background in classical object oriented languages such as C++,
    C#, or Java, you will be quite familiar with the concept of inheritance. In such
    languages, there are two types of inheritance: **interface inheritance** and **implementation
    inheritance**.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript however, only supports implementation inheritance, as there is no
    concept of function signature which is required for interface inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways of implanting inheritance in JavaScript and they all
    have their pros and cons. In this section, I will cover a few ways of implementing
    such relationship among objects and will briefly explain the advantages and disadvantages
    of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start by creating two different constructor functions and an inheritance
    relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two function objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created two extremely simple constructor functions.
    As you can see, we have defined a simple property for each one of them which are
    methods related to each object. However, we have created these simple methods
    as properties of the `prototype` object for each function as opposed to directly
    creating them on the constructor functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with the `prototype` property, you know that every function
    has this property by default. The value of this property is an object that is
    shared with all the instances that are created using the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of creating methods (properties) on `prototype` object as opposed
    to on the constructor function itself is that by doing so, all the instances that
    are created using the constructor share these methods. Therefore, these instances
    do not have to have their own copy of these properties, thus optimizing our code's
    performance and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, in the case of `BaseType`, we simply augmented the `prototype`
    object of this constructor with a method called `getBaseValue`, but for `ChildType`,
    we did something a little different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first created an instance of `BaseType` and then we assigned it to `ChildType`
    using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After the above assignment, the `ChildType.prototype` value becomes an instance
    of `BaseType`. This means that this `prototype` object has access to two properties
    now, `baseValue` and `getBaseValue`.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that there are two properties that instances of `ChildType`
    have access to but didn't need to create them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `childInstance` variable can return the value of the `baseValue` variable,
    using `getBaseValue` method.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `childInstance` also has access to its own variable `childTypeValue`.
    If we run the following code, `50` will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Property look up in prototype chaining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's examine how `ChildInstance` gets access to the properties of `BaseType`
    in a little more depth.
  prefs: []
  type: TYPE_NORMAL
- en: When we try to access a property on `ChildInstance`, behind the scenes, a search
    is conducted on the instance itself to see if that property is available. If the
    property is not found, then the search continues to the `prototype` object of
    the `ChildInstance` object. Since an instance of `BaseType` is the value of the
    `prototype` object belonging to `ChildInstance`, the search is continued in `BaseType`.
  prefs: []
  type: TYPE_NORMAL
- en: But there is more, the instance of `BaseType` (which is the value of the `prototype`
    object belonging to `ChildType`) itself has a `prototype` object and our `ChildType`
    prototype has a link to this `prototype` object. That prototype object has a property
    called `getBaseValue`. Since this method has access to the `BaseType` properties,
    it can return the value of `baseValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of how this lookup is conducted as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Property look up in prototype chaining](img/B04910_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is quite a bit of searching taking place in order to find
    the instance property. Also, keep in mind that if the property was not found in
    the `prototype` of `BaseType`, the search would have continued to the `prototype`
    object of the parent of all objects in JavaScript, the `Object` type. Let's talk
    about how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that every function has a `prototype` property which its value is an
    object. This `prototype` object itself has a `prototype` property which its value
    is the `prototype` object of the `Object` type.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, when we call the `BaseType.toString` method, even though we have
    not defined this method on `BaseType` or its `prototype` object, the call still
    succeeds and produces the string value of the object. The `toString` method is
    defined on the `prototype` object of `Object` type, and thus is available to all
    the children of `Object` type.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to keep in mind that the search is ceased and will not
    continue any further in the chain of `protoypes`, as soon as the property that
    the search is being conducted for is found.
  prefs: []
  type: TYPE_NORMAL
- en: To make it a little more clear, let's modify our `ChildType` to have a property
    (method) called `getBaseValue`. Doing so will result in what is known as **shadowing**
    (or masking) of this property on `BaseType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we modify the code for `ChildType` as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The call to `childInstance.getBaseValue` will now return the value `50` instead
    of `2`. This is because as soon as the search for the `getBaseValue` method (property)
    finds this method on `ChildType`, it will not search any further and will execute
    this method. This of course, will return the value of the `childTypeValue` property.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing that we need to keep in mind, is the fact that because of the
    relationship that has been created among all these reference types, the following
    instance check will return `true` for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can use this test to see if one reference type is inheriting properties
    from another reference type.
  prefs: []
  type: TYPE_NORMAL
- en: While prototype chaining has many advantages and allows us to create inheritance
    among our base objects and our child objects, it has the disadvantage that any
    changes to the base object's reference type properties are reflected in all the
    instances of the child classes. This at times may not be a desirable effect and
    you need to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting the constructor property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every `prototype` object has a `constructor` property. This property always
    refers back to the constructor function itself. When we overwrite the `prototype`
    property completely as we did in the previous code by setting it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `constructor` property of the `prototype` object will be referencing the
    parent object. This can be examined as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Which displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always a good idea to reset the `constructor` property of the `prototype`
    object after it has been completely replaced, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is so the `prototype` object can correctly point back to the correct constructor
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reset enables us to correctly find the constructor object of the instance
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Which now correctly reports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss the `constructor` property some more, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor stealing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach to creating inheritance in JavaScript is using a technique
    known as **constructor stealing**, which is similar to classical inheritance in
    other object oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we are using the `call` method to execute `BaseType` in the
    context of `ChildType`. This results in `ChildType` instances getting a copy of
    all the properties of `BaseType`. Since each instance of `ChildType` now has its
    own copy of the properties, modifying the properties of `BaseType` is not reflected
    in the child instances.
  prefs: []
  type: TYPE_NORMAL
- en: This approach, however, has its own issues. The main issue is that since we
    are not assigning an instance of `BaseType` to the `prototype` object of `ChildType`,
    the properties defined on the `prototype` object of `BaseType` are not shared
    among the instances of `ChildType`. This will no result in the most efficient
    approach in implementing inheritance and does not allow for code sharing of the
    parent's `prototype` object properties among child instances.
  prefs: []
  type: TYPE_NORMAL
- en: Parasitic combination inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to create inheritance relationships among reference types is to
    use a combination of the techniques that we have already discussed, while eliminating
    their inefficiencies. This is also my favorite technique for creating inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the code that we have already seen, so we can implement this
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this latest implementation, we are using the `call` method in the `ChildType`
    constructor to copy all the properties of `BaseType`. This provides the child
    object instance with the ability to modify the properties of `BaseType`, which
    only affects that particular instance of `ChildType` and does not get reflected
    in other instances of `ChildType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, this type of inheritance is initiated in the following statement
    in the `ChildType` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have assigned the `prototype` of `BaseType` to `ChildType`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have assigned only the `prototype` object of `BaseType` to the
    `prototype` object of `ChildType`, thus eliminating the second call to the `BaseType`
    constructor, resulting in more efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: This approach also has the advantage of allowing us to share all the properties
    that have been defined on the `prototype` object of `BaseType` among all the instances
    of the child object. Therefore, not every child object instance will have its
    own copy of such properties, which in turn leads to better code efficiency and
    memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create an instance of `ChildType`, this instance has access to copied
    properties from `BaseType` as well as all the shared properties defined on the
    `prototype` object of `BaseType`. Of course, each instance also has access to
    all of its own properties defined on the `ChildType` constructor and on the `ChildType`
    prototype object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parasitic combination inheritance** provides us with the best of both previously
    discussed techniques (**prototype chaining** and **constructor stealing**) and
    it is widely used by many experienced JavaScript developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every object in JavaScript has a `constructor` property that references the
    constructor object that was used to create the instance of that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in all functions, the `constructor` property has a reference
    to the `Function` type constructor. We could verify this by executing the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `prototype` property''s value is an object too, it also has a `constructor`
    property. However, this `constructor` property references the object (function)
    itself. So if we examine this property **before** we assign the `BaseType.prototype`
    object to `ChildType.prototype`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this property is referencing the object that `prototype` belongs
    to, which in this case is `ChildType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, if we completely replace the `prototype` object ,
    as in the case of the following statement, which was used in implementing our
    previous inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We overwrite the value of the `constructor` property on the `prototype` object
    of `Childtype`.
  prefs: []
  type: TYPE_NORMAL
- en: If we examine the `constructor` property of the `prototype` object now, it will
    be referencing `BaseType`, instead of `Childtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen before, we need to reset the `constructor` property of the `prototype`
    object as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that resetting the `constructor` property needs to happen after
    the `prototype` object has been re-written and not before. Otherwise, the re-write
    will completely remove the `constructor` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how this should be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: I encourage you to examine all the code discussed in this section closely to
    understand how all the pieces are tied together and how inheritance works among
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Native support for inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have had a look at different techniques for creating inheritance
    among constructor functions, it is a good idea to consider native support for
    creating such relationships in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 5 provides **prototypal inheritance** by way of `Object.create()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This method accepts two parameters. The first parameter is the object to be
    used as the `prototype` (base object) for the new object. The second parameter
    is optional and is used to add additional properties to the new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There are some interesting points that you need to keep in mind regarding the
    preceding code. As you can see, we have used the `BaseType` constructor and have
    passed it to the `Object.create` method to create an instance of our `BaseType`
    object and assign it to the `ChildType1` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then have added a new value to the property `secondValue` array of this new
    object (`ChildType1`). In the next line, we have also added a new method, `getBaseTypeFirstValue`
    to this instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a second object `ChildType2` using the method `Object.create`,
    and examine the value of the `secondValue` array, we see that the value is as
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the modified property `secondValue` is shared among all the
    instances that have inheritance relationships with the base object `BaseType`.
    Thus, all the changes done to the properties of the base object by one child instance
    are reflected in all the instances, as well as in the base object, `BaseType`
    itself. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is an important point to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, we could also use the second optional parameter of
    the `Object.create` method to add new properties to the child instance at the
    same time that we create the inheritance relationship between the base and the
    child object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `ChildType` object has now inherited all the properties of the `BaseType`
    object and has a new property `optionalObject`, which is specific to this instance
    of the child object.
  prefs: []
  type: TYPE_NORMAL
- en: Even though this is a native way for creating inheritance among objects in ECMAScript
    5, I have found this technique to not be as popular as parasitic combination inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: I personally find this approach to be a little too verbose in comparison to
    the other approaches that we covered in this chapter for implementing inheritance
    but it allows us to define attributes of the new property exactly as we like.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can refer to the following online resource for more information regarding
    the `Object.create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to provide a quick overview of some OOP concepts
    in JavaScript. Having a good understanding of these concepts is important as we
    will be using them in implementing our modular architecture in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways of creating objects as well as concepts
    such as closure, encapsulation, and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The assumption that I made was that you likely have a fairly good experience
    with JavaScript and are probably familiar with at least some of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: My intent was to provide "just enough" of a review of JavaScript OOP concepts
    to get you ready for future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: There are many good resources available that can help you extend your knowledge
    of Object Oriented JavaScript principles further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of my personal favorites on this topic are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-Oriented JavaScript*, *Stoyan Stefanov*, *Kumar Chetan Sharma*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Professional JavaScript for Web Developers*, *Nicholas C. Zakas*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will start focusing on a popular design pattern known
    as **Module Design Pattern** to get us ready for creating simple modules in our
    application.
  prefs: []
  type: TYPE_NORMAL
