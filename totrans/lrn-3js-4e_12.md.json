["```js\n$ yarn add @dimforge/rapier3d\n```", "```js\nimport * as THREE from 'three'\nimport { RigidBodyType } from '@dimforge/rapier3d'\n// maybe other imports\nimport('@dimforge/rapier3d').then((RAPIER) => {\n  // the code\n}\n```", "```js\nconst gravity = { x: 0.0, y: -9.81, z: 0.0 }\nconst world = new RAPIER.World(gravity)\n```", "```js\nconst floor = new THREE.Mesh(\n  new THREE.BoxGeometry(5, 0.25, 5),\n  new THREE.MeshStandardMaterial({color: 0xdddddd})\n)\nfloor.position.set(2.5, 0, 2.5)\nconst sampleMesh = new THREE.Mesh(\n  new THREE.BoxGeometry(1, 1, 1),\n  new THREE.MeshNormalMaterial()\n)\nsampleMesh.position.set(0, 4, 0)\nscene.add(floor)\nscene.add(sampleMesh)\n```", "```js\nconst floorBodyDesc = new RAPIER.RigidBodyDesc\n  (RigidBodyType.Fixed)\nconst floorBody = world.createRigidBody(floorBodyDesc)\nfloorBody.setTranslation({ x: 2.5, y: 0, z: 2.5 })\nconst floorColliderDesc = RAPIER.ColliderDesc.cuboid\n  (2.5, 0.125, 2.5)\nworld.createCollider(floorColliderDesc, floorBody)\n```", "```js\nConst rigidBodyDesc = new RAPIER.RigidBodyDesc\n(RigidBodyType.Dynamic)\n    .setTranslation(0, 4, 0)\nconst rigidBody = world.createRigidBody(rigidBodyDesc)\nconst rigidBodyColliderDesc = RAPIER.ColliderDesc.cuboid\n  (0.5, 0.5, 0.5)\nconst rigidBodyCollider = world.createCollider\n  (rigidBodyColliderDesc, rigidBody)\nrigidBodyCollider.setRestitution(1)\n```", "```js\n  const animate = (renderer, scene, camera) => {\n    // basic animation loop\n    requestAnimationFrame(() => animate(renderer, scene,\n      camera))\n    renderer.render(scene, camera)\n    world.step()\n    // copy over the position from Rapier to Three.js\n    const rigidBodyPosition = rigidBody.translation()\n    sampleMesh.position.set(\n      rigidBodyPosition.x,\n      rigidBodyPosition.y,\n      rigidBodyPosition.z)\n    // copy over the rotation from Rapier to Three.js\n    const rigidBodyRotation = rigidBody.rotation()\n    sampleMesh.rotation.setFromQuaternion(\n      new THREE.Quaternion(rigidBodyRotation.x,\n        rigidBodyRotation.y, rigidBodyRotation.z,\n          rigidBodyRotation.w)\n    )\n  }\n```", "```js\nconst createDominos = () => {\n    const getPoints = () => {\n      const points = []\n      const r = 2.8; const cX = 0; const cY = 0\n      let circleOffset = 0\n      for (let i = 0; i < 1200; i += 6 + circleOffset) {\n        circleOffset = 1.5 * (i / 360)\n        const x = (r / 1440) * (1440 - i) * Math.cos(i *\n          (Math.PI / 180)) + cX\n        const z = (r / 1440) * (1440 - i) * Math.sin(i *\n          (Math.PI / 180)) + cY\n        const y = 0\n        points.push(new THREE.Vector3(x, y, z))\n      }\n      return points\n    }\n    const stones = new Group()\n    stones.name = 'dominos'\n    const points = getPoints()\n    points.forEach((point, index) => {\n      const colors = [0x66ff00, 0x6600ff]\n      const stoneGeom = new THREE.BoxGeometry\n        (0.05, 0.5, 0.2)\n      const stone = new THREE.Mesh(\n        stoneGeom,\n        new THREE.MeshStandardMaterial({color: colors[index\n        % colors.length], transparent: true, opacity: 0.8})\n      )\n      stone.position.copy(point)\n      stone.lookAt(new THREE.Vector3(0, 0, 0))\n      stones.add(stone)\n    })\n    return stones\n  }\n```", "```js\nconst rapierDomino = (mesh) => {\n  const stonePosition = mesh.position\n  const stoneRotationQuaternion = new THREE.Quaternion().\n    setFromEuler(mesh.rotation)\n  const dominoBodyDescription = new RAPIER.RigidBodyDesc\n    (RigidBodyType.Dynamic)\n    .setTranslation(stonePosition.x, stonePosition.y,\n      stonePosition.z)\n    .setRotation(stoneRotationQuaternion))\n    .setCanSleep(false)\n    .setCcdEnabled(false)\n  const dominoRigidBody = world.createRigidBody\n    (dominoBodyDescription)\n  const geometryParameters = mesh.geometry.parameters\n  const dominoColliderDesc = RAPIER.ColliderDesc.cuboid(\n    geometryParameters.width / 2,\n    geometryParameters.height / 2,\n    geometryParameters.depth / 2\n  )\n  const dominoCollider = world.createCollider\n    (dominoColliderDesc, dominoRigidBody)\n  mesh.userData.rigidBody = dominoRigidBody\n  mesh.userData.collider = dominoCollider\n}\n```", "```js\n  const animate = (renderer, scene, camera) => {\n    requestAnimationFrame(() => animate(renderer, scene,\n      camera))\n    renderer.render(scene, camera)\n    world.step()\n    const dominosGroup = scene.getObjectByName('dominos')\n    dominosGroup.children.forEach((domino) => {\n      const dominoRigidBody = domino.userData.rigidBody\n      const position = dominoRigidBody.translation()\n      const rotation = dominoRigidBody.rotation()\n      domino.position.set(position.x, position.y,\n        position.z)\n      domino.rotation.setFromQuaternion(new\n        THREE.Quaternion(rotation.x, rotation.y,\n          rotation.z, rotation.w))\n    })\n  }\n```", "```js\nconst rigidBodyDesc = new RAPIER.RigidBodyDesc\n  (RigidBodyType.Dynamic)\nconst rigidBody = world.createRigidBody(rigidBodyDesc)\nconst rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)\nconst rigidBodyCollider = world.createCollider\n  (rigidBodyColliderDesc, rigidBody)\nrigidBodyCollider.setFriction(0.5)\n```", "```js\nconst rigidBodyDesc = new RAPIER.RigidBodyDesc\n  (RigidBodyType.Dynamic)\nconst rigidBody = world.createRigidBody(rigidBodyDesc)\nconst rigidBodyColliderDesc = RAPIER.ColliderDesc.ball(0.2)\nconst rigidBodyCollider = world.createCollider\n  (rigidBodyColliderDesc, rigidBody)\nrigidBodyCollider.setRestitution(0.9)\n```", "```js\n  let params = RAPIER.JointData.fixed(\n    { x: 0.0, y: 0.0, z: 0.0 },\n    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },\n    { x: 2.0, y: 0.0, z: 0.0 },\n    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 }\n  )\n```", "```js\nworld.createImpulseJoint(params, rigidBody1, rigidBody2,\n  true)\n```", "```js\n  let params = RAPIER.JointData.fixed(\n    { x: 0.0, y: 0.0, z: 0.0 },\n    { w: 1.0, x: 0.0, y: 0.0, z: 0.0 },\n    { x: 2.0, y: 2.0, z: 2.0 },\n    { w: 0.3, x: 1, y: 1, z: 1 }\n  )\n```", "```js\n  const createChain = (beads) => {\n    for (let i = 1; i < beads.length; i++) {\n      const previousBead = beads[i - 1].userData.rigidBody\n      const thisBead = beads[i].userData.rigidBody\n      const positionPrevious = beads[i - 1].position\n      const positionNext = beads[i].position\n      const xOffset = Math.abs(positionNext.x –\n        positionPrevious.x)\n      const params = RAPIER.JointData.spherical(\n        { x: 0, y: 0, z: 0 },\n        { x: xOffset, y: 0, z: 0 }\n        )\n      world.createImpulseJoint(params, thisBead,\n        previousBead, true)\n    }\n  }\n```", "```js\nconst bodyDesc = new RAPIER.RigidBodyDesc(RigidBodyType.Fixed)\nconst body = world.createRigidBody(bodyDesc)\nconst colliderDesc = RAPIER.ColliderDesc.cuboid(0.5, 0.5, 0.5)\nconst collider = world.createCollider(colliderDesc, body)\n```", "```js\nConst bodyDesc = new RAPIER.RigidBodyDesc\n  (RigidBodyType.Dynamic)\n  .setCanSleep(false)\n  .setTranslation(-1, 0, 0)\n  .setAngularDamping(0.1)\nconst body = world.createRigidBody(bodyDesc)\nconst colliderDesc = RAPIER.ColliderDesc.cuboid(0.25, 0.05,\n  2)\nconst collider = world.createCollider(colliderDesc, body)\n```", "```js\nConst bodyDesc = new RAPIER.RigidBodyDesc\n  (RigidBodyType.Dynamic)\n  .setCanSleep(false)\n  .setTranslation(-1, 1, 1)\nconst body = world.createRigidBody(bodyDesc)\nconst colliderDesc = RAPIER.ColliderDesc.cuboid\n  (0.1, 0.1, 0.1)\nconst collider = world.createCollider(colliderDesc, body)\n```", "```js\nconst params = RAPIER.JointData.revolute(\n  { x: 0.0, y: 0, z: 0 },\n  { x: 1.0, y: 0, z: 0 },\n  { x: 1, y: 0, z: 0 }\n)\nlet joint = world.createImpulseJoint(params, fixedCubeBody,\n  greenBarBody, true)\n```", "```js\nconst prismaticParams = RAPIER.JointData.prismatic(\n  { x: 0.0, y: 0.0, z: 0 },\n  { x: 0.0, y: 0.0, z: 3 },\n  { x: 1, y: 0, z: 0 }\n)\nprismaticParams.limits = [-2, 2]\nprismaticParams.limitsEnabled = true\nworld.createImpulseJoint(prismaticParams, fixedCubeBody,\n  redCubeBody, true)\n```", "```js\nconst listener = new THREE.AudioListener(); camera.add(listener1);\n```", "```js\nconst mesh1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1,\n  1), new THREE.MeshNormalMaterial({ visible: false }))\nmesh1.position.set(-4, -2, 10)\nscene.add(mesh1)\nconst posSound1 = new THREE.PositionalAudio(listener)\nconst audioLoader = new THREE.AudioLoader()\naudioLoader.load('/assets/sounds/water.mp3', function\n  (buffer) {\nposSound1.setBuffer(buffer)\nposSound1.setRefDistance(1)\nposSound1.setRolloffFactor(3)\nposSound1.setLoop(true)\nmesh1.add(posSound3)\n```"]