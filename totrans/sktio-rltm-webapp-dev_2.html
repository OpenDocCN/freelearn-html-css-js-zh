<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Getting Started with Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Getting Started with Node.js</h1></div></div></div><p>The definition of Node.js <a id="id28" class="indexterm"/>that is given on the Node.js website (<a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a>), is as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p></blockquote></div><p>What matters to us is, Node.js as a part of the platform, provides a scalable and high-performance web application development framework, which allows programming in JavaScript.</p><p>Many of us got introduced to JavaScript while building websites or web applications for DOM manipulation, AJAX, and related stuff. But JavaScript is much more than that. Just like C, Java, Python, and so on, JavaScript is also a full-fledged programming language. In all browsers, JavaScript is executed in a virtual machine (VM), in the context of the browser. But it can also be executed in another context—as in the case of a Node.js backend—without the browser.</p><p>Node.js uses Google Chrome's JavaScript VM to execute JavaScript applications outside the browser, on the server. Along with this runtime environment, Node.js also provides a library of modules, which provides a framework for building network applications. Node.js is not a web server like the Apache HTTP server, or an application server like Tomcat; but as part of its modules library, Node.js does provide an HTTP Server, which can be used to build web applications.</p><p>Apart from having JavaScript as the programming language for the applications, one thing that sets Node.js (and most of the Node.js modules and applications) apart from the traditional servers and applications is the asynchronous event-driven development model, which we will see in later sections.</p><div class="section" title="The origin of Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The origin of Node.js</h1></div></div></div><p>This is not the first time that JavaScript has been used for server-side programming. Netscape launched Netscape Enterprise Server in 1996, which allowed server-side programming in JavaScript. Since then, many servers, such as<a id="id29" class="indexterm"/> <span class="strong"><strong>RingoJS</strong></span> (<a class="ulink" href="http://ringojs.org/">http://ringojs.org/</a>), <a id="id30" class="indexterm"/>
<span class="strong"><strong>Persevere</strong></span> (<a class="ulink" href="http://www.persvr.org/">http://www.persvr.org/</a>), Mozilla's Rhino-based servers, and others have tried to follow suit. <a id="id31" class="indexterm"/>
</p><p>A major reason for these servers not being taken seriously was the pitiful performance of the JavaScript VMs used by them. JavaScript performance in browsers was also not very good. That was until Google launched its Chrome web browser.</p><p>At the time of its launch, Chrome's JavaScript VM, called <span class="strong"><strong>V8</strong></span>, <a id="id32" class="indexterm"/>was almost 10-20 times faster than any other JavaScript VM, and has since then been the fastest.</p><p>It was based on this VM that Ryan Dahl developed Node.js in 2008. He wanted to build a server that would enable and empower real-time interactive web applications like Gmail. But Node.js was not the first server he built. Ryan built Ebb, a web server based on Ruby and C, but realized that it wasn't working as fast as he wanted it to. This was followed by several experiments in building a number of small web servers.</p><p>Armed with the knowledge gained from his experiments and the study of various platforms, he decided to develop an event-driven or asynchronous server. In the January of 2008, he came up with the idea of building a small web server based on JavaScript. He was inclined towards JavaScript because it was independent of the OS and came without any I/O APIs. He quit his job and worked on Node.js for 6 months. In November 2009, he presented Node.js in JSConf, and has been working for Joyent since then. Initially, Node.js worked only on Unix-based systems; later, it came with support for Windows OS too.</p></div></div>
<div class="section" title="Why Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Why Node.js</h1></div></div></div><p>Node.js is a new platform and is still <a id="id33" class="indexterm"/>evolving (not even a version 1.0 has been released yet), but even in its infancy, it is probably one of the most popular platforms on the Web. It is already powering a large number of popular services. Let us take a look at what makes Node.js such a tempting and popular proposition.</p><div class="section" title="JavaScript everywhere"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>JavaScript everywhere</h2></div></div></div><p>The first and foremost advantage of <a id="id34" class="indexterm"/>Node.js is JavaScript. If you know and code in JavaScript regularly, you already know most of Node.js; all that's left to learn can be thought of as APIs and best practices.</p><p>Node.js—built over Google Chrome's V8 JavaScript engine—allows entire applications to be written using JavaScript. We have already been writing frontends in JavaScript; with Node.js, we write the backend as well, in the same language that we have honed our skills on and grown to love. It saves every frontend developer from learning one more language or relying on some other developer to expose <a id="id35" class="indexterm"/>the RESTful APIs required by their application.</p></div><div class="section" title="Event-driven design"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Event-driven design</h2></div></div></div><p>Node.js was designed around events and <a id="id36" class="indexterm"/>callbacks. As a JavaScript developer, you would already be familiar with the concept of listening to events and using callbacks. Node.js incorporates this philosophy in each and every aspect of the platform. Be it in server request handling, I/O, or database interactions, everything in Node.js will ideally be handled by a callback attached to an event by a listener.</p><p>This brings us to one of the most important concepts behind Node.js, that is, the <span class="emphasis"><em>event loop</em></span>. I like the fast food restaurant analogy by Dan York (<a class="ulink" href="http://code.danyork.com">http://code.danyork.com</a>) for explaining event loop-based systems.</p><p>Consider a restaurant where you go to the cashier, place your order, and wait till your food is ready. In this case, the cashier cannot serve the other customers till you have your order, and the queue is blocked. If the restaurant has a large inflow of customers and needs to scale up, they will have to invest in hiring more number of cashiers, creating more cash counters, and so on. This is similar <a id="id37" class="indexterm"/>to the traditional multithreading model.</p><p>In contrast, let us see the model many other restaurants use. In this case, you go to the cashier and place your order (which he/she hands over to the kitchen); he/she then accepts your payment and gives you a token. You then step aside, and the cashier moves on to the next customer. When your order is ready, the kitchen server announces this by calling your name or flashing your token number, and you walk up and fetch your order. This event-oriented approach optimizes the work of the cashier and lets you wait on the side, freeing up the relevant resources to service others until your work is done.</p><p>In Node.js, the server is the cashier, and all the handlers are the kitchen crew. The server accepts a request and spins it off to a handler. It then moves on to accept other requests. When the request is processed and the results are in place, the response is queued on the server and sent back to the client when it reaches the front of the queue.</p><p>As opposed to the traditional approach of launching the threads or processes of the server (which is similar to adding more cashiers), this method is more efficient, as the workers launched have dedicated responsibilities. This is much lighter and cheaper than replicating the entire server.</p><p>In the sections ahead, we will see that we register the handlers or the workers with the server to handle certain requests, and all the server does is delegate the requests to these workers.</p><p>The advantage of the event-driven design is that everything we design is non-blocking. "You don't wait on me, I call you" is the mantra that relieves us from the pain involved in waiting on a request to be fulfilled. It frees up the system resources that would have otherwise been spent in waiting on the request, so that they can be used for the other tasks in the queue. This allows the Node.js applications to give a very high performance and capability of handling a very high load. <a id="id38" class="indexterm"/>
</p><p>Node.js is a modular framework with a modern module system from the ground up. Everything in Node.js is built as modules running in the V8 JavaScript engine. Every functionality in the platform is provided by means of modules. This keeps the platform lean and brings in only that what is required. Having a native module system also helps in keeping our applications modular.</p><p>JavaScript has become one of the most widely-used languages in the past few years and has a vibrant community. Node.js provides developers with a good platform that assists them in developing end-to-end applications in JavaScript. Node.js has also brought in many revolutionary concepts, namely, always asynchronous, non-blocking I/O, event-oriented servers, and so on. This has resulted in a very vibrant, large, and active community. New modules are coming up continuously, and the community provides active support and is very helpful. Most of the popular modules and frameworks built for Node.js generally come from the community <a id="id39" class="indexterm"/>and are mostly open source.</p></div><div class="section" title="Corporate backing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Corporate backing</h2></div></div></div><p>Many companies have invested heavily in<a id="id40" class="indexterm"/> Node.js in the past couple of years. From Ryan Dahl's employer, Joyent, to the creators of the Mojito framework (Internet giant Yahoo!), many companies have built products, platforms, frameworks, and services around Node.js. This kind of corporate commitment assures a stable future.</p></div></div>
<div class="section" title="How to get Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>How to get Node.js</h1></div></div></div><p>Due to the popularity of Node.js, it is very easy to get it working on any operating system. You can go to <a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a> and download the appropriate distribution for your operating system. <a id="id41" class="indexterm"/>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Though Node.js works on any OS, as it comes from the *nix background, many modules might only work on Linux or other Unix systems; so it is best to use such a system if you have one at hand.</p></div></div><p>If you are using Linux, in most cases, you should be able to install Node.js using your distribution's package manager. As this information keeps changing, I'll just point out the location instead. You'll find the instructions <a id="id42" class="indexterm"/>for installing Node.js using package manager here:</p><p>
<a class="ulink" href="https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager">https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager</a>
</p><p>If you are using Mac OS or Windows, you should know that Node.js now provides an installer for these platforms, which is the recommended installation approach. You can also install using the source. Instead of repeating that process here, which is again subject to change, I'll suggest that you follow the official installation instructions on the Node.js wiki, on GitHub (<a class="ulink" href="https://github.com/joyent/node/wiki/Installation">https://github.com/joyent/node/wiki/Installation</a>).</p></div>
<div class="section" title="Node.js package manager (npm)"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Node.js package manager (npm)</h1></div></div></div><p>If you installed Node.js using the installer from the Node.js website, you will already have npm installed. <a id="id43" class="indexterm"/>
</p><p>Also, if you followed the instructions to build from the source, you will probably have installed npm. If that is a yes, very good! If no, please do so now. For this, I recommend that you follow the instructions mentioned in the npm installation documentation (<a class="ulink" href="https://github.com/isaacs/npm/">https://github.com/isaacs/npm/</a>).</p><p>You can check if you have npm installed by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm -v</strong></span>
</pre></div><p>This should display the version of npm installed.</p><p>For those who are wondering what npm is and why you would need a package manager for Node.js, npm is just what its name says; it provides an infrastructure in Node.js to distribute and manage packages. As I said earlier, Node.js is very modular. Node.js apps are built using many modules and third-party packages because npm provides an easy way of adding and managing third-party dependencies for our applications. We will see more on its use in a while.</p></div>
<div class="section" title="Hello World with Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Hello World with Node.js</h1></div></div></div><p>Here, the obligatory Hell World example<a id="id44" class="indexterm"/> uses Node.js. Write the following line in a file called <code class="literal">helloworld.js</code> and save it:</p><div class="informalexample"><pre class="programlisting">console.log("Hello World");</pre></div><p>And now to run it, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node helloworld.js</strong></span>
</pre></div><p>This should print <span class="strong"><strong>Hello World</strong></span> on the console. All the JavaScript developers will immediately recognize that these are the steps we follow to print anything on the console while developing a web application.</p><p>What happens is that Node.js loads the JavaScript file in the JavaScript VM, provides an environment for its execution, and the VM interprets the script. When it gets <code class="literal">console.log</code>, it checks the environment for the console, which in this case is <code class="literal">STDOUT</code>, and writes <span class="strong"><strong>Hello World</strong></span> to it.</p><p>But we are here to develop web applications, correct? So let's say hello to the Web!</p></div>
<div class="section" title="Hello Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Hello Web</h1></div></div></div><p>Let us make a very simple web <a id="id45" class="indexterm"/>application that greets the user with a hello. Write the following code in a file, and name it <code class="literal">helloweb.js</code>:</p><div class="informalexample"><pre class="programlisting">var http = require("http");

http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("&lt;html&gt;");
  response.write("&lt;head&gt;&lt;title&gt;Node.js&lt;/title&gt;&lt;/head&gt;");
  response.write("&lt;body&gt;Hello Web&lt;/body&gt;");
  response.write("&lt;/html&gt;");
  response.end();
}).listen(9999);</pre></div><p>To run the previous piece of code, execute <code class="literal">helloweb.js</code> in Node.js:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node helloweb.js</strong></span>
</pre></div><p>And then open <code class="literal">http://localhost:9999/</code> in your browser. You should see a page saying <span class="strong"><strong>Hello Web</strong></span>. There is a lot going on here! So let us walk through the code and understand what is going on.</p><p>The very first line of code introduces us to one of the fundamental building blocks of Node.js, the module system. Node.js has a very simple module system built on CommonJS. Those familiar with frontend development using RequireJS with <span class="strong"><strong>Asynchronous Module Definition (AMD)</strong></span> <a id="id46" class="indexterm"/>will immediately relate to this. All the functionality in Node.js is built as modules and you need to import it in your code using <code class="literal">require</code>. Node.js has several modules compiled in a binary form, called core modules, HTTP being one of them. We can also create and include our own custom or third-party modules using <code class="literal">require</code>. In case of file modules, there is one-to-one mapping between a file and a module; so we write every module in its own file. We will see more on writing our own modules later.</p><div class="informalexample"><pre class="programlisting">var http = require("http");</pre></div><p>With this statement, Node.js will load the core HTTP module, and it will be available in a variable called <code class="literal">http</code>. The next task is to create a server using the HTTP module. This is done using the <code class="literal">createServer</code> method <a id="id47" class="indexterm"/>from the module. The <code class="literal">createServer</code> method accepts <code class="literal">requestListener</code>. <a id="id48" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">http.createServer([requestListener]);</pre></div><p>The <code class="literal">requestListener</code> is a function that handles the incoming requests. In our case, this function is passed <span class="emphasis"><em>inline</em></span>. Just like JavaScript in a browser, Node.js also runs a single process and a single thread. This is different from the traditional application servers, which create a new thread or process to handle new requests. So to scale and handle multiple requests, Node.js uses asynchronous event handling. So every request that comes in triggers an event, which is then handled by the event handler asynchronously. This is the mechanism of the event loop explained in earlier sections.</p><div class="informalexample"><pre class="programlisting">http.createServer(function(request, response) {
  response.writeHead(200, {"Content-Type": "text/html"});
  response.write("&lt;html&gt;");
  response.write("&lt;head&gt;&lt;title&gt;Node.js JS&lt;/title&gt;&lt;/head&gt;");
  response.write("&lt;body&gt;Hello Web&lt;/body&gt;");
  response.write("&lt;/html&gt;");
  response.end();
});</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The way <code class="literal">createServer</code> works is similar to any event handler in JavaScript. The event in this case is receiving a request to serve. As we can see, <code class="literal">requestListener</code> takes two arguments, <code class="literal">request</code> and <code class="literal">response</code>. The <code class="literal">request</code> object is an instance of <code class="literal">http.ServerRequest</code>, and will have all the information about the request, such as URL, method, headers, and data.</p><p>The <code class="literal">response</code> object is an instance of <code class="literal">ServerResponse</code>, which implements a <code class="literal">WritableStream</code>. It exposes various methods to write the response to the client; the ones we are most interested in, for now, are <code class="literal">writeHead</code>, <code class="literal">write</code> and <code class="literal">end</code>. Let us first see <code class="literal">writeHead</code>:</p><div class="informalexample"><pre class="programlisting">response.writeHead(statusCode, [reasonPhrase], [headers]);</pre></div><p>Here, <code class="literal">statusCode</code> is the HTTP response code, <code class="literal">reasonPhrase</code> is the optional human-readable response phrase, and <code class="literal">headers</code> is the object that has the headers, which are to be sent in the response. This function should be called only once, before calling <code class="literal">response.end</code>. If we call <code class="literal">response.write</code> or <code class="literal">response.end</code> before this, the implicit/mutable headers will be calculated and the following function will be called automatically: <a id="id49" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">response.writeHead(200, {"Content-Type": "text/html"});</pre></div><p>In this call, we are setting the status code to <code class="literal">200</code>, that is, HTTP OK, and we are only setting the <code class="literal">Content-Type</code> header to <code class="literal">text/html</code>. The next method here is <code class="literal">response.write</code>, it's used to write the response content to the client. The call to this method is done as follows:</p><div class="informalexample"><pre class="programlisting">response.write(chunk, [encoding]);</pre></div><p>In this call, <code class="literal">chunk</code> is the content to write and <code class="literal">encoding</code> is the content encoding to use. If the chunk is a string and the encoding is not specified, UTF-8 will be used by default.</p><div class="informalexample"><pre class="programlisting">response.write("&lt;html&gt;");
response.write("&lt;head&gt;&lt;title&gt;Node.js JS&lt;/title&gt;&lt;/head&gt;");
response.write("&lt;body&gt;Hello Web&lt;/body&gt;");
response.write("&lt;/html&gt;");</pre></div><p>In the above code, the first time <code class="literal">write</code> is called, Node.js sends the response headers and the chunk of the body. But the <code class="literal">write</code> method<a id="id50" class="indexterm"/> can then be called multiple times. Node.js will assume that we are streaming data, and will keep sending the chunk whenever the calls are made. And the last call on the response is made to tell Node.js that we are done. This is just what <code class="literal">response.end</code> does.</p><div class="informalexample"><pre class="programlisting">response.end([data], [encoding]);</pre></div><p>
<code class="literal">response.end</code> signals to the server that all the response headers and body content have been sent and that the server should consider this message complete. We <span class="emphasis"><em>must</em></span> call this method for every message.</p><div class="informalexample"><pre class="programlisting">response.end();</pre></div><p>In our case, we call <code class="literal">response.end</code> without any of the optional arguments. If we do pass in the parameters, it is equivalent to calling <code class="literal">response.write</code> with the parameters, followed by <code class="literal">response.end</code>. I prefer keeping them separate, and hence, explicit.</p><p>Finally, we need to tell the HTTP server which port it should listen on. In this case, we tell it to listen on port 9999.</p><div class="informalexample"><pre class="programlisting">listen(9999);</pre></div></div>
<div class="section" title="Routing the requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Routing the requests </h1></div></div></div><p>Almost any web application serves <a id="id51" class="indexterm"/>more than a single resource. So now we know how to serve content using an HTTP server; but how do we handle multiple resources? Routing is the name of the game. We need to understand the incoming request and map it to the appropriate request handler. This is a bit more complicated than the previous example, so we will build it step by step, improving it with every step.</p><p>To demonstrate the routing of requests, let us build a simple application that serves two resources at <code class="literal">/start</code> and <code class="literal">/finish</code>, displaying <span class="strong"><strong>Hello</strong></span> and <span class="strong"><strong>Goodbye</strong></span> respectively. To simplify the code, we will serve plain text. So before anything else, let's take a look at the code:</p><div class="informalexample"><pre class="programlisting">var http = require("http");
var url = require("url");

function onRequest(request, response) {
  var pathname = url.parse(request.url).pathname;
  console.log("Request for " + pathname + " received.");
  if(pathname === "/start"){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello");
    response.end();
  }else if(pathname === "/finish"){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Goodbye");
    response.end();
  }else{
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.end("404 Not Found");
  }
}

http.createServer(onRequest).listen(9999);
console.log("Server has started.");</pre></div><p>Save the previous code snippet in a file called <code class="literal">routing.js</code> and execute it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node routing.js</strong></span>
</pre></div><p>Now, when we <a id="id52" class="indexterm"/>access <code class="literal">http://localhost:9999/start</code>, we will see <span class="strong"><strong>Hello</strong></span> in the browser. Similarly, when we access <code class="literal">http://localhost:9999/finish</code>, we will see a message saying <span class="strong"><strong>Goodbye</strong></span>. If we try to access any other path, we will get an HTTP 404 or Not Found error. Let us now try and understand the new things we are introducing in this example.</p><p>The first thing that we need in order to route a request, is to parse the URL; for this we will introduce another inbuilt module called <code class="literal">url</code>. When a URL string is parsed using the <code class="literal">url</code> module, it returns an<a id="id53" class="indexterm"/> instance of the URL. In this case, we are interested in the pathname.</p><div class="informalexample"><pre class="programlisting">var pathname = url.parse(request.url).pathname;</pre></div><p>In the previous line of code, we are passing the <code class="literal">url</code> string from the request, and parsing it using the <code class="literal">url</code> module, to get the <code class="literal">pathname</code>. The next step is to send an appropriate response, based on the path being accessed:</p><div class="informalexample"><pre class="programlisting">  if(pathname === "/start"){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello");
    response.end();
  }else if(pathname === "/finish"){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Goodbye");
    response.end();
  }</pre></div><p>Here we are comparing the pathname with the one we are expected to handle, and accordingly an appropriate response is sent out. And what happens to the requests we don't handle? That is what the last part of the if-else-if ladder does. It sends an HTTP 404 error.</p><div class="informalexample"><pre class="programlisting">    response.writeHead(404, {"Content-Type": "text/plain"});
    response.end("404 Not Found");</pre></div><p>Now let us think about extending this application. To handle more paths, we will have to add more if-else conditions. But that doesn't look clean, is difficult to read, and is very inefficient in execution. Think about the route handled in the last step of the if-else ladder; the process still has to go through the entire ladder, checking for every condition. Also, adding new routes to this will require us to go through and edit this if-else ladder, which will be at the very least, confusing, and can also easily result in errors, typos, and a high chance of unintentional modification to the existing routes. So let us make it a bit cleaner by putting the handlers in an object mapped by their paths, and also provide an API to extend it. So let us change our code to look like this:</p><div class="informalexample"><pre class="programlisting">var http = require("http");
var url = require("url");

var route = { 
  routes : {}, 
  for: function(path, handler){
    this.routes[path] = handler;
  }
};

  route.for("/start", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello");
    response.end();
  });

  route.for("/finish", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Goodbye");
    response.end();
  });

function onRequest(request, response) {
  var pathname = url.parse(request.url).pathname;
  console.log("Request for " + pathname + " received.");
  if(typeof route.routes[pathname] ==='function'){
    route.routes[pathname](request, response);
  }else{
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.end("404 Not Found");
  }
}

http.createServer(onRequest).listen(9999);
console.log("Server has started.");</pre></div><p>To run this code snippet, execute the file with Node.js, using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node resources.js</strong></span>
</pre></div><p>The functionality of the application will be the same as the result of the previous example. When we access either <code class="literal">/start</code> or <code class="literal">/finish</code>, it will respond with <span class="strong"><strong>Hello</strong></span> for the former, and <span class="strong"><strong>Goodbye</strong></span> for the latter. <a id="id54" class="indexterm"/>On trying to access any other path, we will get an HTTP 404 message.</p><p>The change we have made here is that we have thrown out the if-else-if ladder in favor of a clean and efficient design approach. In this approach, we don't need to play around with existing routes and can add new routes by calling the <code class="literal">route.for</code> method from any module. The route has a map of the path to the <code class="literal">handler</code> function and also has a <code class="literal">on</code> method to add new routes.</p><div class="informalexample"><pre class="programlisting">var route = {
  routes : {},
  for: function(path, handler){
    this.routes[path] = handler;
  }
}

route.on("/start", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello");
    response.end();
});

route.on("/finish", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Goodbye");
    response.end();
});</pre></div><p>Here we are adding two new handlers for the<a id="id55" class="indexterm"/> paths <code class="literal">/start</code> and <code class="literal">/finish</code>. The signature for the handlers is similar to the main request handler. We expect the handlers to get the request and response, so that the handler has everything it needs to process the request and send the response.</p><div class="informalexample"><pre class="programlisting">if(typeof(route.routes[pathname])==='function')</pre></div><p>In the if condition, we check whether the route for the pathname is present, and whether it is a function. If we find a handler for the requested path, we execute the <code class="literal">handler</code> function, passing the request and response to it.</p><div class="informalexample"><pre class="programlisting">route.routes[pathname](request, response);</pre></div><p>If it is not found, we respond with an HTTP 404 error. Now, to add a new path, we can call the <code class="literal">route.on</code> method <a id="id56" class="indexterm"/>with the path and its handler to register it.</p><div class="informalexample"><pre class="programlisting">route.on("/newpath", function(request, response){ 
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("new response");
    response.end();
});</pre></div></div>
<div class="section" title="HTTP Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>HTTP Methods </h1></div></div></div><p>HTTP is not only about the path, we also have to think about the HTTP methods. In this section, we will enhance our app to handle the different HTTP methods: <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DEL</code>
<code class="literal">TE</code>. <a id="id57" class="indexterm"/>
</p><p>As the first step towards this, we will add the ability to add different handlers for different methods. We will add the methods in the mapping in resources.js, which is a minor change. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">var http = require("http");
var url = require("url");
var route = {
  routes : {}, 
  for: function(method, path, handler){
    this.routes[method + path] = handler;
  }
}

  route.for("GET", "/start", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello");
    response.end();
  });

  route.for("GET", "/finish", function(request, response){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Goodbye");
    response.end();
  });

function onRequest(request, response) {
  var pathname = url.parse(request.url).pathname;
  console.log("Request for " + request.method + pathname +" received.");
  if(typeof(route.routes[request.method +pathname])==='function'){
    route.routes[request.method + pathname](request, response);
  }else{
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.end("404 Not Found");
  }
}

http.createServer(onRequest).listen(9999);
console.log("Server has started.");</pre></div><p>Save the file and execute with Node.js. The functionality still remains the same, but we will be able to handle different methods using different handlers. Let us create a new handler to echo the incoming data on <code class="literal">POST</code>. <a id="id58" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">  route.on("POST", "/echo", function(request, response){
    var incoming = "";
    request.on('data', function(chunk) {
      incoming += chunk.toString();
    });

    request.on('end', function(){
      response.writeHead(200, {"Content-Type": "text/plain"});
      response.write(incoming);
      response.end();
    });
  });</pre></div><p>Here we are adding a new handler for the <code class="literal">POST</code> request on the <code class="literal">/echo</code> path. We again see the use of the event-driven approach of Node.js, this time in handling the data that comes in with <code class="literal">POST</code>. Since <code class="literal">request</code> is an event emitter, we attach an event handler to it for each task: for handling chunks of<a id="id59" class="indexterm"/> incoming data and for completing the request processing once all the data is received.</p><div class="informalexample"><pre class="programlisting">    request.on('data', function(chunk) {
      incoming += chunk.toString();
    });</pre></div><p>In the previous piece of code, we add a listener on the request to handle chunks of incoming data. In this case, all we do is accumulate the incoming data.</p><div class="informalexample"><pre class="programlisting">    request.on('end', function(){
      response.writeHead(200, {"Content-Type": "text/plain"});
      response.write(incoming);
      response.end();
    });</pre></div><p>The event handler on <code class="literal">end</code> will be invoked once all the data sent in <code class="literal">POST</code> has been received. This is the time at which we finish receiving all the data. To build an echo service, we will send back all the accumulated data. We will now create a form to post the request to this handler.</p><div class="informalexample"><pre class="programlisting">  route.on("GET", "/echo", function(request, response){
    var body = '&lt;html&gt;' + 
    '&lt;head&gt;&lt;title&gt;Node.js Echo&lt;/title&gt;&lt;/head&gt;' + 
    '&lt;body&gt;' + 
    '&lt;form method="POST"&gt;' + 
    '&lt;input type="text" name="msg"/&gt;' + 
    '&lt;input type="submit" value="echo"/&gt;' + 
    '&lt;/form&gt;' + 
    '&lt;/body&gt;&lt;/html&gt;';

    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(body);
    response.end();
  });</pre></div><p>We will add an event handler to the same path (<code class="literal">/echo</code>), but this time, to handle a <code class="literal">GET</code> request. In the handler, we will return an HTML page with a form to post to the same path.</p><p>Add these two handlers to our <code class="literal">route-handlers.js</code> and execute it with Node.js. To open our form, go to <code class="literal">http://localhost:9999/echo</code>; then, to trigger our handler, type in a message in the form's textbox and click on the <span class="strong"><strong>echo</strong></span> button. This will post the content of the form, and in response we will see <code class="literal">msg=&lt;your text&gt;</code> in the browser.</p></div>
<div class="section" title="Creating our own Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Creating our own Modules </h1></div></div></div><p>Modules are the basic building blocks<a id="id60" class="indexterm"/> of Node.js applications. With all our changes, our file is becoming a bit clumsy; moreover, we are putting our infrastructure (server and router) with the application logic (the handlers) in the same place. As mentioned earlier, Node.js builds on the CommonJS module system. In Node.js, a module and a file have a one-to-one relation. Let us move the server and router to their own modules. Save the following in a file called <code class="literal">server.js</code>:</p><div class="informalexample"><pre class="programlisting">var http = require("http");
var url = require("url");

function onRequest(request, response) {
  var pathname = url.parse(request.url).pathname;
  console.log("Request for " + request.method + pathname +" received.");
  if(typeof(routes[request.method + pathname])==='function'){
    routes[request.method + pathname](request, response);
  }
  else{
    response.writeHead(404, {"Content-Type": "text/plain"});
    response.end("404 Not Found");
  }
}

var routes = {};

exports.forRoute = function(method, path, handler){
  routes[method + path] = handler;
};

exports.start = function(){
  http.createServer(onRequest).listen(9999);
  console.log("Server has started.");
};</pre></div><p>Most of the logical aspects of the code remain the same, but we have made some very subtle structural changes. The first one is that we have taken the routes out of the <code class="literal">route</code> object. Any variables declared in the file are available within the module and are not accessible from outside the module.</p><div class="informalexample"><pre class="programlisting">  if(typeof(routes[request.method + pathname])==='function'){
    routes[request.method + pathname](request, response);
  }</pre></div><p>As the <code class="literal">route</code> object is gone, we can now directly access the routes within the module and not through the <code class="literal">route</code> object.</p><p>The other and more obvious change is <code class="literal">exports</code>. Since nothing from within the module is available outside the module, we have to add the methods/objects that we want to expose to the implicit <code class="literal">exports</code> object. Ideally, you should expose only those methods relevant to the end user of your module.</p><div class="informalexample"><pre class="programlisting">exports.forRoute = function(method, path, handler){
  routes[method + path] = handler;
};

exports.start = function(){
  http.createServer(onRequest).listen(9999);
  console.log("Server has started.");
}</pre></div><p>We are exposing two methods <a id="id61" class="indexterm"/>from our module: the <code class="literal">forRoute</code> method (originally, the <code class="literal">on</code> method in the <code class="literal">route</code> object), and the <code class="literal">start</code> method<a id="id62" class="indexterm"/> that wraps the code to start the HTTP server. We also move the application logic to its own module called <code class="literal">app.js</code>, which is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">var server = require("./server.js");
server.forRoute("GET", "/start", function(request, response){
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello");
  response.end();
});

server.forRoute("GET", "/finish", function(request, response){
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Goodbye");
  response.end();
});

server.forRoute("POST", "/echo", function(request, response){
  
  var incoming = "";

  request.on('data', function(chunk) {
    incoming += chunk.toString();
  });

  request.on('end', function(){
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write(incoming);
    response.end();
  });
});

server.forRoute("GET", "/echo", function(request, response){
  var body = '&lt;html&gt;' + 
  '&lt;head&gt;&lt;title&gt;Node.js Echo&lt;/title&gt;&lt;/head&gt;' + 
  '&lt;body&gt;' + 
  '&lt;form method="POST"&gt;' + 
  '&lt;input type="text" name="msg"/&gt;' + 
  '&lt;input type="submit" value="echo"/&gt;' + 
  '&lt;/form&gt;' + 
  '&lt;/body&gt;&lt;/html&gt;';

  response.writeHead(200, {"Content-Type": "text/html"});
  response.write(body);
  response.end();
});

server.start();</pre></div><p>Again, the logical aspects remain unchanged; the changes are only in the structure.</p><div class="informalexample"><pre class="programlisting">var server = require("./server.js");</pre></div><a id="id63" class="indexterm"/><p>The previous line, which is also the first line in the previous code snippet, shows us how our server module is loaded. This is similar to loading core modules like HTTP or URL, but here we are loading the module and passing its filename. The object created by this <code class="literal">require</code> method, the <code class="literal">server</code> object, will have two methods that will be exposed: <code class="literal">forRoute</code> and <code class="literal">start</code>.</p><p>Next, we replace all the calls to <code class="literal">route.on</code> with the <code class="literal">server.forRoute</code> method. <a id="id64" class="indexterm"/>.  And finally, we call the <code class="literal">server.start</code> method to start the HTTP server.</p><div class="informalexample"><pre class="programlisting">server.start();</pre></div></div>
<div class="section" title="Serving files"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Serving files</h1></div></div></div><p>We can see <a id="id65" class="indexterm"/> that it's not very intuitive or easy to write HTML pages with our current infrastructure. Writing the HTML in the JS code as strings is not fun. We would like to serve the HTML content from the HTML files. We will begin with taking in two modules, which we will need to read from a file (on the disk) in our <code class="literal">app</code> module:</p><div class="informalexample"><pre class="programlisting">var path = require('path');
var fs = require('fs');</pre></div><p>The first one, <code class="literal">path</code>, is the module we use to work with paths, and <code class="literal">fs</code> is the module used to interact with the filesystem. The next step is to get the path to the application's root.</p><div class="informalexample"><pre class="programlisting">var root = __dirname;</pre></div><p>
<code class="literal">__dirname</code> is a variable managed by Node.js and has the absolute path to the directory of the Node.js application script. Now, we add the method that will be doing the heavy work of reading the file and sending it to the browser. Add this method to <code class="literal">app.js</code>:</p><div class="informalexample"><pre class="programlisting">var serveStatic = function(response, file){
  var fileToServe = path.join(root, file);
  var stream = fs.createReadStream(fileToServe);

  stream.on('data', function(chunk){
    response.write(chunk);
  });

  stream.on('end', function(){
    response.end();
  });
}</pre></div><p>The <code class="literal">serveStatic</code> method <a id="id66" class="indexterm"/> <a id="id67" class="indexterm"/>that we have created accepts two arguments, the HTTP response object and the file path to serve.</p><div class="informalexample"><pre class="programlisting">  var fileToServe = path.join(root, file);</pre></div><p>We append the file path to our root path to build the absolute path of the file to serve. Here we are implicitly assuming that all the files to be served are relative to the Node.js application root; this will prevent a file outside the application from being served by mistake. Node.js handles I/O as streams. We can see that this is similar to the way it handles the incoming <code class="literal">POST</code> data.</p><div class="informalexample"><pre class="programlisting">  var stream = fs.createReadStream(fileToServe);</pre></div><p>We use <code class="literal">createReadStream</code> from the <code class="literal">fs</code> module to create a stream that reads from the file. This stream again demonstrates the non-blocking, asynchronous, and event-driven approach of Node.js.</p><div class="informalexample"><pre class="programlisting"> stream.on('data', function(chunk){
    response.write(chunk);
  });</pre></div><p>The stream works as an event emitter, triggering the <code class="literal">'data'</code> event when there is new data on the stream. This allows the application to continue with the other processing activities, without having to wait for the data to be read. What we are doing here is, we are writing the data we receive on every <code class="literal">read</code> to the <code class="literal">response</code> stream.</p><div class="informalexample"><pre class="programlisting">  stream.on('end', function(){
    response.end();
  });</pre></div><p>Once all the data from the file is read and the stream gets an EOF, it will trigger the <code class="literal">'end'</code> event. We will call <code class="literal">end</code> on our response as well. Finally, we will modify the <code class="literal">GET</code> handler <code class="literal">"/echo"</code> to serve from a file called <code class="literal">echo.html</code>, and write the content of the HTML to be served to that file.</p><div class="informalexample"><pre class="programlisting">server.forRoute("GET", "/echo", function(request, response){
    serveStatic(response, "echo.html");
});</pre></div><p>We have removed <a id="id68" class="indexterm"/>all the code to build the <code class="literal">response</code> string, replacing it with a call to <code class="literal">serveStatic</code> to serve <code class="literal">echo.html</code>.</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Node.js Echo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form method="POST"&gt;
      &lt;input type="text" name="msg"/&gt;
      &lt;input type="submit" value="echo"/&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The content that we were previously building as a string is now written to this file. Once we make these changes and run <code class="literal">app.js</code> with Node.js, you should be able to see the form on <code class="literal">http://localhost:9999/echo</code> retaining its original functionality.</p><p>Those familiar with Unix-like operating systems will realize that the functionality we just implemented to read from one stream and write to another can also implemented by using pipes (<code class="literal">|</code>). It shouldn't come as a surprise that Node.js provides a high-level function to do exactly the same.</p><p>Using the <code class="literal">pipe</code> method provided on <code class="literal">stream</code> in Node, we can modify the <code class="literal">serveStatic</code> method as follows:</p><div class="informalexample"><pre class="programlisting">var serveStatic = function(response, file){
  var fileToServe = path.join(root, file);
  var stream = fs.createReadStream(fileToServe);
  stream.pipe(response);
}</pre></div><p>Here we are replacing the data and end event handlers using <code class="literal">stream.pipe(response)</code>.</p></div>
<div class="section" title="Third party modules and Express JS"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Third party modules and Express JS </h1></div></div></div><p>Now that we have built<a id="id69" class="indexterm"/>
<a id="id70" class="indexterm"/> a router of our own and understand the basics of Node.js, it is time to get introduced to one of the most widely-used frameworks for Node.js, Express (<a class="ulink" href="http://expressjs.com">http://expressjs.com</a>). Node.js provides the infrastructural components to build a web application, but there is too much stuff to handle. Therein lies the role of the web frameworks. There are quite a few web frameworks that provide a higher level of abstraction for building applications on Node. You can see a list of most of them here:</p><p>
<a class="ulink" href="https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full">https://github.com/joyent/node/wiki/Modules#wiki-web-frameworks-full</a>
</p><p>Express is a web application framework for Node, built over the Connect middleware, that provides many more helpers and structural aspects to build our web applications.</p><p>To get started with the Express framework, we need to install it using npm, the Node.js package manager.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo npm install -g express</strong></span>
</pre></div><p>The previous command will install Express as a global (<code class="literal">-g</code>) module and make <code class="literal">express</code> available as a command. Let us create an Express app:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>express hello-express</strong></span>
</pre></div><p>This will create a folder called <code class="literal">hello-express</code> with certain files and folders in it. Let us see and understand these files.</p><p>The first file to understand is <code class="literal">package.json</code>. This is the file that defines a Node.js application package. It has the application metadata such as the name, description, and version. More importantly, it has the module dependencies listed. The dependency list is used by npm to download the required modules.</p><div class="informalexample"><pre class="programlisting">{
  "name": "application-name",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app"
  },
  "dependencies": {
    "express": "3.1.0",
    "jade": "*"
  }
}</pre></div><p>The most important things in your <code class="literal">package.json</code> are the <code class="literal">name</code> and <code class="literal">version</code> fields. These fields are required, and together, they form a unique identifier for a particular release of the package. To begin with, let us change the name of our package to <code class="literal">hello-express</code>. The <code class="literal">version</code> field <a id="id71" class="indexterm"/>
<a id="id72" class="indexterm"/>consists of the following (in the same order):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A number (major version)</li><li class="listitem" style="list-style-type: disc">A period</li><li class="listitem" style="list-style-type: disc">A number (minor version)</li><li class="listitem" style="list-style-type: disc">A period</li><li class="listitem" style="list-style-type: disc">A number (patch version)</li><li class="listitem" style="list-style-type: disc">Optional: a hyphen, followed by a number (build)</li><li class="listitem" style="list-style-type: disc">Optional: a collection of pretty much any non-whitespace characters (tag)</li></ul></div><p>If we set <code class="literal">private</code> to true, npm will not publish it to a repository. This ensures that you don't end up publishing your code to a public repository by mistake.</p><p>The <code class="literal">scripts</code> object has a mapping of commands to those points in the application lifecycle at which they should be run. In this package, we are telling Node.js that it should run the <code class="literal">node app</code> command when the application is started with npm. There are some predefined lifecycle commands, such as <code class="literal">start</code>, <code class="literal">stop</code>, <code class="literal">restart</code>, and <code class="literal">test</code>, which can be run using <code class="literal">npm &lt;command&gt;</code> like <code class="literal">npm start</code>.</p><p>You can also run arbitrary commands using <code class="literal">run-script</code>. For this, you add the command to the <code class="literal">scripts</code> object and then run it as <code class="literal">npm run-script &lt;command&gt;</code>.</p><p>And finally—the most interesting part of the package that brings in the magic—<code class="literal">dependencies</code>. This object is a mapping of the name and version of your dependency packages and will be used by npm to pull in all the required dependencies.</p><p>In our package, <code class="literal">express</code> has already defined the dependency on Express and Jade. To pull in these dependencies, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install</strong></span>
</pre></div><p>The output will list all the dependencies it downloaded.</p><p>
<span class="strong"><strong>jade@0.27.2 node_modules/jade</strong></span>
</p><p>
<span class="strong"><strong>├── commander@0.6.1</strong></span>
</p><p>
<span class="strong"><strong>└── mkdirp@0.3.0</strong></span>
</p><p>
<span class="strong"><strong>express@3.0.0rc2 node_modules/express</strong></span>
</p><p>
<span class="strong"><strong>├── methods@0.0.1</strong></span>
</p><p>
<span class="strong"><strong>├── fresh@0.1.0</strong></span>
</p><p>
<span class="strong"><strong>├── range-parser@0.0.4</strong></span>
</p><p>
<span class="strong"><strong>├── cookie@0.0.4</strong></span>
</p><p>
<span class="strong"><strong>├── crc@0.2.0</strong></span>
</p><p>
<span class="strong"><strong>├── commander@0.6.1</strong></span>
</p><p>
<span class="strong"><strong>├── debug@0.7.0</strong></span>
</p><p>
<span class="strong"><strong>├── mkdirp@0.3.3</strong></span>
</p><p>
<span class="strong"><strong>├── send@0.0.3 (mime@1.2.6)</strong></span>
</p><p>
<span class="strong"><strong>└── connect@2.4.2 (pause@0.0.1, bytes@0.1.0, qs@0.4.2, formidable@1.0.11)</strong></span>
</p><p>The dependencies will be placed in<a id="id73" class="indexterm"/>
<a id="id74" class="indexterm"/> a folder called <code class="literal">node_modules</code>.</p><p>Next, we will take a look at the application file <code class="literal">app.js</code>:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , routes = require('./routes')
  , http = require('http')
  , path = require('path');

var app = express();

app.configure(function(){
  app.set('port', process.env.PORT || 3000);
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');
  app.use(express.favicon());
  app.use(express.logger('dev'));
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(path.join(__dirname, 'public')));
});

app.configure('development', function(){
  app.use(express.errorHandler());
});

app.get('/', routes.index);

http.createServer(app).listen(app.get('port'), function(){
  console.log("Express server listening on port " + app.get('port'));
});</pre></div><p>In the first few lines, Node.js loads<a id="id75" class="indexterm"/>
<a id="id76" class="indexterm"/> the modules required for us to work with. We are already familiar with <code class="literal">http</code> and <code class="literal">path</code>. The <code class="literal">express</code> module brings in the Express framework. And one more module that we are loading in is <code class="literal">./routes</code>, which will load the module defined in the local <code class="literal">routes</code> folder, defined by <code class="literal">./routes/index.js</code>. The following code snippet focuses on the first few lines of the previous code snippet:</p><div class="informalexample"><pre class="programlisting">var express = require('express')
  , routes = require('./routes')
  , http = require('http')
  , path = require('path');</pre></div><p>In the next line, it instantiates the Express framework as an app:</p><div class="informalexample"><pre class="programlisting">var app = express();</pre></div><p>Then comes the application configuration:</p><div class="informalexample"><pre class="programlisting">app.configure(function(){

});</pre></div><p>In the previous few lines, we are defining a function that will configure the app. The signature for <code class="literal">app.configure</code> is <code class="literal">app.configure([env], callback)</code>, where <code class="literal">env</code> is the runtime environment variable <span class="emphasis"><em>or</em></span> the production environment variable, as is defined by <code class="literal">process.env.NODE_ENV</code>. When we don't specify <code class="literal">env</code>, it will be set for all environments.</p><p>The following settings have been provided to alter how Express behaves:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">env</code>: Environment mode, defaults to <code class="literal">process.env.NODE_ENV</code> or "development"</li><li class="listitem" style="list-style-type: disc"><code class="literal">trust proxy</code>: Enables reverse proxy support, disabled by default</li><li class="listitem" style="list-style-type: disc"><code class="literal">jsonp callback</code>: Enables JSONP callback support, enabled by default</li><li class="listitem" style="list-style-type: disc"><code class="literal">jsonp callback name</code>: Changes the default callback name of <code class="literal">?callback=</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">json replacer</code>: JSON replacer callback, <code class="literal">null</code> by default</li><li class="listitem" style="list-style-type: disc"><code class="literal">json spaces</code>: JSON response spaces for formatting; defaults to <code class="literal">2</code> in development, <code class="literal">0</code> in production<a id="id77" class="indexterm"/><a id="id78" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">case sensitive routing</code>: Enables case sensitivity, disabled by default, treating <code class="literal">/Foo</code> and <code class="literal">/foo</code> as the same</li><li class="listitem" style="list-style-type: disc"><code class="literal">strict routing</code>: Enables strict routing, by default <code class="literal">/foo</code> and <code class="literal">/foo/</code> are treated the same by the router</li><li class="listitem" style="list-style-type: disc"><code class="literal">view cache</code>: Enables view template compilation caching, enabled in production by default</li><li class="listitem" style="list-style-type: disc"><code class="literal">view engine</code>: The default engine extension to use when omitted</li><li class="listitem" style="list-style-type: disc"><code class="literal">views</code>: The view directory path</li></ul></div><p>The following code snippet demonstrates how to assign settings to an application:</p><div class="informalexample"><pre class="programlisting">  app.set('port', process.env.PORT || 3000);
  app.set('views', __dirname + '/views');
  app.set('view engine', 'jade');</pre></div><p>The settings used by the application here are <code class="literal">port</code>, <code class="literal">views</code>, and <code class="literal">view engine</code>, specifying that the application should run on port <code class="literal">3000</code>, the views will be placed in the <code class="literal">views</code> folder, and the engine to be used is Jade. We will see more about views later. Certain features can also be specified, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">  app.use(express.favicon());
  app.use(express.logger('dev'));
  app.use(express.bodyParser());
  app.use(express.methodOverride());
  app.use(app.router);
  app.use(express.static(path.join(__dirname, 'public')));</pre></div><p>As Express builds over Connect middleware, it brings in a lot of existing functionality from Connect. Connect's <code class="literal">use</code> method configures the app to utilize the given middleware handle for the given route, where the route defaults to <code class="literal">/</code>. You can see the list of middleware provided by Connect at <a class="ulink" href="http://www.senchalabs.org/connect/">http://www.senchalabs.org/connect/</a>.</p><p>Let us walk through the middleware components being used here. The Favicon middleware will serve the favicon for the application. The Logger middleware logs requests in a custom format.</p><p>The Body parser parses the request bodies supporting different formats; this includes <code class="literal">application/json</code>, <code class="literal">application/x-www-form-urlencoded</code>, and <code class="literal">multipart/form-data</code>.</p><p>Method Override enables the faux HTTP method support. This means that if we would like to stimulate the <code class="literal">DELETE</code> and <code class="literal">PUT</code> method calls to our application, we can do it by adding a <code class="literal">_method</code> parameter to the request.</p><p>
<code class="literal">app.router</code> provides an enhanced version of Connect's <code class="literal">router</code> module. Basically, this is the component that determines what to do when we use routing methods like <code class="literal">app.get</code>. The last middleware, Static, provides a static file server and configures it, serving files from the <code class="literal">public</code> directory.</p><p>For the development environment, the following two lines of code show how to set up the Error handler middleware so as to<a id="id79" class="indexterm"/>
<a id="id80" class="indexterm"/> provide stack traces and error messages in the responses.</p><div class="informalexample"><pre class="programlisting">app.configure('development', function(){
  app.use(express.errorHandler());
});</pre></div><p>The next line configures the router to route <code class="literal">/</code> to be handled by the <code class="literal">index</code> method in the <code class="literal">routes</code> module:</p><div class="informalexample"><pre class="programlisting">app.get('/', routes.index);</pre></div><p>At the end, we start the HTTP server configured to use the app instance that we just configured.</p><div class="informalexample"><pre class="programlisting">http.createServer(app).listen(app.get('port'), function(){
  console.log("Express server listening on port " + app.get('port'));
});</pre></div><p>In the configuration of the app, we saw some folders coming into play, namely, <code class="literal">routes</code>, <code class="literal">views</code>, and <code class="literal">public</code>.</p><p>
<code class="literal">routes</code> is a module that we will be writing all our handlers to. In the case of <code class="literal">/</code>, we have mapped it to serve from the index method, using the <code class="literal">routes.index</code> method. If you open <code class="literal">routes/index.js</code>, you will see that <code class="literal">index</code> is a method exposed from this module.</p><div class="informalexample"><pre class="programlisting">exports.index = function(req, res){
  res.render('index', { title: 'Express' });
};</pre></div><p>This function signature is similar to the handlers we wrote. It is a function that takes a request and response as parameters. Here we are using the Express method <code class="literal">response.render</code>, which will render the mentioned view using the second parameter as the model or data.</p><p>The views are present in the <code class="literal">views</code> folder and use the <a id="id81" class="indexterm"/>Jade (<a class="ulink" href="http://jade-lang.com/">http://jade-lang.com/</a>) view engine. Jade is a high-performance template engine, heavily influencedby Haml <a id="id82" class="indexterm"/> (<a class="ulink" href="http://haml.info/">http://haml.info/</a>), and implemented with JavaScript for Node.js. Like many modern HTML generation engines, Jade tries to make the UI code easier, cleaner, and simpler, getting rid of the inline code and the HTML tags noise.</p><p>We will now see the views defined in our Express app. There are two files to see here: <code class="literal">layout.jade</code> and <code class="literal">index.jade</code>.</p><p>
<code class="literal">layout.jade</code>, as the name suggests, is the template for the layout that will be used by the different pages in our application. It may be used to place the common code of the skeleton for the pages in our<a id="id83" class="indexterm"/>
<a id="id84" class="indexterm"/> application, which is shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">doctype 5
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
  body
    block content</pre></div><p>In Jade, we don't need the <code class="literal">start</code> and <code class="literal">end</code> tags because it identifies the start and end of the tags by the indented blocks. So when we render this Jade file, it will generate the following HTML code:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{TITLE}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;{CONTENT}&lt;/body&gt;
&lt;/html&gt;</pre></div><p>In the previous piece of code, two things are left undefined, <code class="literal">{TITLE}</code> and <code class="literal">{CONTENT}</code>. In the Jade template, we define the title as follows: <a id="id85" class="indexterm"/>
<a id="id86" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">    title= title</pre></div><p>We tell Jade to use the title from the data passed to <code class="literal">render</code> as <code class="literal">title</code>. The second thing, <code class="literal">{CONTENT}</code>, is defined as block in Jade.</p><div class="informalexample"><pre class="programlisting">    block content</pre></div><p>
<code class="literal">block content</code> is a plugin point provided in the layout template, which can be described by any template extending from it.</p><p>
<code class="literal">index.jade</code> inherits from <code class="literal">layout.jade</code>. In our index handler, we render the index view using the data <code class="literal">{title: 'Express'}</code>. Take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">extends layout
block content
  h1= title
  p Welcome to #{title}</pre></div><p>In the previous file, we define the content block to have a <code class="literal">h1</code> and <code class="literal">p</code> tags. So, with the given input and because it extends <a id="id87" class="indexterm"/>
<a id="id88" class="indexterm"/>the layout, the Jade engine will generate the following HTML:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Express&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Express&lt;/h1&gt;
    &lt;p&gt;Welcome to Express&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We will see more functionality and syntax in Jade as we work on our chat application in the next chapter.</p><p>In the HTML code generated, we can see that <code class="literal">/stylesheets/style.css</code> is being referred to; this file is served by the static file server we configured in the app. We can find this and the other files in the public folder.</p><p>To run this application, we will use npm. Run the following command on the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm start</strong></span>
</pre></div><p>Then go to <code class="literal">http://localhost:3000/</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter we were introduced to the Node.js and Express web frameworks. As mentioned earlier, this is in no way a complete introduction to Node.js or Express. To learn more, please refer to the vast documentation available online or any of the books written on Node.js web development.</p></div></body></html>