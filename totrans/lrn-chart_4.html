<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Charts</h1>
                </header>
            
            <article>
                
<p>This chapter covers several charts that can be created with Chart.js to efficiently communicate quantitative information and relationships. The choice of a chart depends on the type of data, how each set of values is related to one another, and what kind of relationships you want to show. In the previous chapter, we learned how to efficiently display data in bar charts and compare quantitative information related to different categories. In this chapter, you will create line and radar charts to compare sequences of one-dimensional data, pie and doughnut charts to compare proportions, scatterplots and bubble charts to represent two or more dimensions, and polar area charts to display quantitative data in a radial grid.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Line and area charts</li>
<li>Radar and polar area charts</li>
<li>Pie and doughnut charts</li>
<li>Scatterplots and bubble charts</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Line and area charts</h1>
                </header>
            
            <article>
                
<p>Line charts are used to display a correlation between two sets of data, where one of the sets should contain categorical or ordered data (ascending or descending). The most common application of a line chart is th<em>e</em> time series<em>,</em> where the ordered set consists of instants of time. If arbitrary categories are used, it should be possible to establish some kind of connected sequence with them (for example, an ordered sequence of steps).</p>
<p>Line charts display estimates. The points that correlate the datasets are connected with straight or curved lines that represent estimated values. Line charts can be used to predict intermediate values and reveal trends.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a simple line chart</h1>
                </header>
            
            <article>
                
<p>Just like the bar chart, you need to load the Chart.js JavaScript library, place a <kbd>&lt;canvas&gt;</kbd> object somewhere in the <kbd>&lt;body&gt;</kbd> of your page, and create a new chart referring to the ID of the canvas, and an object with the chart data. The <kbd>chart</kbd> object should specify <kbd>line</kbd> as the chart type. The following code is the minimum you need to create a line chart with the global defaults provided by Chart.js:</p>
<pre>&lt;html&gt;<br/> &lt;head&gt;<br/>     &lt;script src=".../Chart.min.js"&gt;&lt;/script&gt;<br/> &lt;/head&gt;<br/> &lt;body&gt;<br/> <br/> &lt;canvas id="my-line-chart" width="400" height="200"&gt;&lt;/canvas&gt;<br/> <br/> &lt;script&gt;<br/>     const values =<br/>       [1.17,1.35,1.3,1.09,0.93,0.76,0.83,0.98,0.87,0.89,0.93,0.81];<br/>     const labels =<br/>             <br/>["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];<br/> <br/>     const dataObj = {<br/>         labels: labels,<br/>         datasets: [{ data: values }]<br/>     }<br/>     const chartObj = {<br/>         type: "line",<br/>         data: dataObj<br/>     };<br/>     new Chart("my-line-chart", chartObj);<br/> &lt;/script&gt;<br/> &lt;/body&gt;&lt;/html&gt;</pre>
<p>This data contains average global temperatures for 2016, obtained from NASA. The result is shown as follows. As you can see, the default line chart has a gray line and a gray fill. You can change these defaults using the <em>options</em> or <em>dataset</em> configurations. The full code is in <kbd>LineArea/line-1.html</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d50c0ef7-cc8f-43d0-a3b7-4854e0925677.png" width="1011" height="518"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Simple line chart with default Chart.js properties showing average global temperatures in 2016 (code: <em>LineArea/line-1.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dataset configuration</h1>
                </header>
            
            <article>
                
<p>Dataset-specific options can be applied to control attributes, such as color and width of each line. Adding a <kbd>borderColor</kbd> attribute to the dataset will set the color of the line (and legend box), as follows:</p>
<pre>let dataObj = {<br/>     labels: labels,<br/>     datasets: [{<br/>         data: values,<br/>         borderColor: 'hsla(300,100%,50%,1)'<br/>         backgroundColor: 'transparent';<br/>     }]<br/> }</pre>
<p>The following chart shows the effect of setting <kbd>borderColor</kbd> and <kbd>backgroundColor</kbd> for a dataset. This configuration only affects one dataset. You can also configure properties that affect all datasets. In this example, the legend was also removed using the options configuration (explained in a separate section). You can see the full code in <kbd>LineArea/line-2.html</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7be3bf28-c583-4fde-ba9f-72229ac1082e.png" width="1188" height="742"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Simple line chart with average global temperatures measured in 2016 (code: <em>LineArea/line-2.html)</em></div>
<p>The following <span>listed</span> dataset properties can be declared for each object of the <kbd>datasets</kbd> array. Many are also shared by other charts that display numerical data, such as radar, scatter, and bubble charts:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 29%">
<p><strong>Property</strong></p>
</td>
<td style="width: 25.2397%">
<p><strong>Value</strong></p>
</td>
<td style="width: 38.7603%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>data</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>An array of numbers containing the data to display (mandatory).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>label</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>String</kbd></p>
</td>
<td style="width: 38.7603%">
<p>A label for the dataset (appears in legend and tooltips).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>backgroundColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p>A CSS color property value string</p>
</td>
<td style="width: 38.7603%">
<p>The fill color under (or above) the line. Position depends on the <kbd>fill</kbd> property.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p>A CSS color property value string</p>
</td>
<td style="width: 38.7603%">
<p>The color of the line.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderWidth</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The width of the line in pixels.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderDash</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The canvas <kbd>setLineDash</kbd> method. An array describing the width of alternated line and space. For example, <kbd>[5, 10]</kbd> will create a dashed line with 5 pixel dashes and 10 pixel spaces.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderDashOffset</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The canvas <kbd>lineDashOffset</kbd> property. An offset for line dashes. If zero (default), a <kbd>[10,10]</kbd> dash will start with a <kbd>10</kbd> pixel line. If <kbd>10</kbd>, it will start with the 10 pixel space. If <kbd>5</kbd>, it will start with a <kbd>5</kbd> pixel line, followed by a <kbd>10</kbd> pixel space, <kbd>10</kbd> pixel line, and so on.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderJoinStyle</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>'bevel'</kbd>, <kbd>'round'</kbd>, or <kbd>'miter'</kbd> (default)</p>
</td>
<td style="width: 38.7603%">
<p>The canvas <kbd>lineJoin</kbd> property.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>borderCapStyle</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>'butt'</kbd> (default), <kbd>'round'</kbd>, or <kbd>'square'</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The canvas <kbd>lineCap</kbd> property.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointBackgroundColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Color</kbd> or <kbd>Color[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The background color of the point.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointBorderColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Color</kbd> or <kbd>Color[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The border color of the point.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointBorderWidth</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd> or <kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The border width of the point.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointRadius</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>String</kbd> or <kbd>String[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The radius of the point.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointStyle</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>circle </kbd>(default), <kbd>cross</kbd>, <kbd>line</kbd>, <kbd>crossRot</kbd>, <kbd>dash</kbd>, <kbd>rectRounded</kbd>, <kbd>rectRot</kbd>, <kbd>star</kbd>, or <kbd>triangle</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The style of the point. A string or a DOM reference to an <kbd>Image</kbd> object.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointHoverBackgroundColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Color</kbd> or <kbd>Color[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The background color of the point when the mouse hovers over it.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointHoverBorderColor</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Color</kbd> or <kbd>Color[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The border color of the point when the mouse hovers over it.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointHoverBorderWidth</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd> or <kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The width of the point when the mouse hovers over it.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointHoverRadius</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd> or <kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The radius of the point when the mouse hovers over it.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>pointHitRadius</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd> or <kbd>Number[]</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The invisible radius of the point that reacts to the mouse hover (to show a tooltip).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>cubicInterpolationMode</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>'default'</kbd> or <kbd>'monotone'</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The default algorithm employs a cubic weighted interpolation. It doesn't guarantee monotonicity (so, if values increase or decrease, the default algorithm may deviate from this behavior).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>lineTension</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>Number</kbd></p>
</td>
<td style="width: 38.7603%">
<p>The cubic bezier line tension (this applies only to default interpolation mode). If zero, the chart will draw straight lines.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>fill</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>false</kbd>, <kbd>start</kbd>, <kbd>end</kbd>, <kbd>origin</kbd>, or dataset index (relative or absolute)</p>
</td>
<td style="width: 38.7603%">
<p>This property describes how the space between lines is filled. <kbd>false</kbd> turns the feature off. <kbd>start</kbd> fills the space above or before the line, <kbd>end</kbd> fills the opposite space, <kbd>origin</kbd> fills to the origin of the chart, and index values fill the space between two datasets. A number represents the absolute index of a dataset. A string containing a signed number (for example: <kbd>+2</kbd>) represents a relative dataset (for example: the preceding two datasets).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>spanGaps</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>'bottom'</kbd>, <kbd>'left'</kbd>, <kbd>'top'</kbd>, or <kbd>'right'</kbd></p>
</td>
<td style="width: 38.7603%">
<p>If <kbd>false</kbd>, a null value or <em>NaN</em> (not zero) will cause a break in the line. The default is <kbd>false</kbd>.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>showLine</kbd></p>
</td>
<td style="width: 25.2397%">
<p>Boolean</p>
</td>
<td style="width: 38.7603%">
<p>If <kbd>false</kbd>, the line for this dataset is not shown (only points will be displayed).</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>steppedLine</kbd></p>
</td>
<td style="width: 25.2397%">
<p><kbd>true</kbd> = <kbd>'before'</kbd>, <kbd>false</kbd> (default), or <kbd>'after'</kbd></p>
</td>
<td style="width: 38.7603%">
<p>Draws line as a sequence of steps. If <kbd>true</kbd> or <kbd>before</kbd>, the initial point is used. If <kbd>after</kbd>, the final value is used. The default is <kbd>false</kbd>, which disables this algorithm.</p>
</td>
</tr>
<tr>
<td style="width: 29%">
<p><kbd>yAxisID</kbd> and <kbd>xAxisID</kbd></p>
</td>
<td style="width: 25.2397%">
<p>An axis ID (see <a href="f3bca5ff-1e17-4cb4-bbb9-6d71b8847ed0.xhtml" target="_blank">Chapter 7,</a><em> Advanced<br/>
Chart.js</em>)</p>
</td>
<td style="width: 38.7603%">
<p>This is used in axis configuration.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Dataset properties for line charts</div>
<p>Data points represent the actual data in a dataset, and serve as an anchor for tooltips. There are several different data point styles that can be selected with the <kbd>pointStyle</kbd> property. These are shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5379279d-700a-4066-bec1-07f1682da665.png" width="1023" height="538"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Point styles available for line charts (code: <em>LineArea/line-3-pointStyle.html)</em></div>
<p>Data points can also configure radius, background color, border color, and tooltip behaviors. In a line chart, only the points represent actual values. The lines are just estimates. Depending on the kind of data you are displaying or the amount of points you have to display, it may not make sense to show them. You might also want to render them differently.</p>
<p>There are several options to control the algorithm that draws the lines. The <kbd>lineTension</kbd> property is a number (usually between <kbd>0</kbd> and <kbd>0.5</kbd>) that configures the cubic Bezier interpolation of each line, drawing smooth curves between each point. If you set it to zero, the chart will draw straight lines, as demonstrated in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6bbd7036-f2a8-4819-8fdd-cf7db290db7c.png" style="width:37.67em;height:22.58em;" width="667" height="401"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Comparing different values for the lineTension property (code: <em>LineArea/line-4-tension.html)</em></div>
<p>If you are plotting discrete values, you may prefer to draw the lines as <em>steps</em>. You can place the step on a line based on the first or the second point of the line segment by choosing between the <kbd>before</kbd> or <kbd>after</kbd> strategies for the <kbd>steppedLine</kbd> property. The effects are shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f283de6f-583b-4c77-96a6-481b16fc8a8d.png" style="width:42.50em;height:14.58em;" width="865" height="297"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The effect of using different strategies for the steppedLine property (code: LineArea/line-5-stepped.html)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Options configuration for line charts</h1>
                </header>
            
            <article>
                
<p>The same general options we used for bar charts can be used to configure line charts, but there are some chart specific options, too. All charts come preconfigured with defaults, which can be overridden using local or global properties. One of the ways to remove the shading for all charts that use lines (instead of setting transparency per dataset) is to declare the fill global property for line elements as false, as follows:</p>
<pre>Chart.defaults.global.elements.line.fill = false;</pre>
<p>However, you can configure options per-chart setting properties in the options configuration object. We improved the way our first line chart was rendered, removing the legend, which is not necessary as there is only one dataset (see <kbd>LineArea/line-2.html</kbd>), as follows:</p>
<pre>let chartObj = {<br/>     type: "line",<br/>     data: dataObj,<br/>     options:{<br/>         legend: {<br/>             display: false<br/>         }<br/>     }<br/> };<br/> new Chart("my-line-chart", chartObj);</pre>
<p>Data points can be completely hidden by setting <kbd>pointRadius</kbd> to zero in each dataset. However, you can also configure them for all datasets and charts globally by setting the values of the properties in <kbd>Chart.defaults.global.elements.point.radius</kbd>. This hides all points from all charts that use points, as follows:</p>
<pre>Chart.defaults.global.elements.point.radius = 0;</pre>
<p>If you have a very large number of points, you may not want to draw the lines. To hide the line of a specific dataset, you can set its <kbd>showLine</kbd> property to <kbd>false</kbd>, but you can also configure line drawing for all lines with the options properties listed as follows.</p>
<p>They can be set locally for the current chart or globally for all charts:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>showLines</kbd></p>
</td>
<td>
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td>
<p>If this property is <kbd>false</kbd>, the lines between the points are not drawn. The default for line charts is <kbd>true</kbd>. The default <span>for scatter charts is </span><kbd>false</kbd> .</p>
</td>
</tr>
<tr>
<td>
<p><kbd>spanGaps</kbd></p>
</td>
<td>
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td>
<p>A <em>null</em> value or <em>NaN</em> (not zero) causes a break in the line if this property is <kbd>false</kbd>. The default is <kbd>false</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Configuration properties for line charts</div>
<p>Global options for line elements are configured using the <kbd>Chart.defaults.line</kbd> object. To hide all lines as default, use the following code:</p>
<pre>Chart.defaults.line.showLines = false;</pre>
<p>Locally, they are defined directly inside the <kbd>options</kbd> object. You can override the default in a chart with the following code:</p>
<pre>options: { showLines: true }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Line charts with more than one dataset</h1>
                </header>
            
            <article>
                
<p>Each dataset is displayed in a line chart by a separate line. The following example adds a new set of values to our chart, that is, the average monthly temperatures measured in 1880. We can now plot both datasets in the same grid and compare them with the average temperatures in 2016, as follows:</p>
<pre>// NASA/GISS Temperature anomalies from 1880 to 2016<br/> let values2016 =<br/>   [1.17,1.35,1.3,1.09,0.93,0.76,0.83,0.98,0.87,0.89,0.93,0.81];<br/> let values1880 =<br/>   [-0.3,-0.21,-0.18,-0.27,-0.14,-0.29,-0.24,-0.08,-0.17,-0.16,-0.19,<br/>   -0.22];<br/> Chart.defaults.global.elements.line.fill = false;<br/><br/> let labels =<br/>   ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov",<br/>   "Dec"];<br/> <br/> let dataObj = {<br/>     labels: labels,<br/>     datasets: [{<br/>         label: '2016',<br/>         data: values2016,<br/>         borderColor: 'hsla(300,100%,50%,1)',<br/>         borderDash: [5, 5],<br/>     },{<br/>         label: '1880',<br/>         data: values1880,<br/>         borderColor: 'hsla(200,100%,50%,1)'<br/>     }]<br/> }<br/>// the rest of the code is identical</pre>
<p>The result of the preceding code is shown in the following chart. The full code is in <kbd>LineArea/line-6-datasets.html</kbd>. The chart reveals that the average temperature anomalies in 2016 are approximately 1° C higher than the measurements in 1880:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/369524ec-645e-49a1-9ef0-9058595c80d2.png" width="911" height="578"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Line chart with two datasets (code: <em>LineArea/line-6-datasets.html)</em></div>
<p class="mce-root"/>
<p>The <kbd>fill</kbd> property can be used with a Boolean value to turn on/off shading for all lines, but it can also be used as a <kbd>dataset</kbd> property to configure a shading strategy for individual datasets. In this case, it receives a string identifying an axis line: <kbd>'start'</kbd>, <kbd>'end'</kbd>, or <kbd>'origin'</kbd>, which will shade the chart between the line and an axis line (smallest, largest, or zero axis, respectively). It can also shade between lines, specifying a relative number as a string: <kbd>'-1'</kbd> will shade between the current dataset and the previous one, <kbd>'+2'</kbd>, will shade from the current dataset to the dataset that is two positions higher in the <kbd>dataset</kbd> array. You can also refer to an absolute index of the <kbd>dataset</kbd> array. The following chart compares the effects of some of these fill strategies:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0a265173-0a29-4668-bd97-2b513726430d.png" width="829" height="623"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Fill strategies for line charts (code: <em>LineArea/line-7-fill.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Loading data from external files</h1>
                </header>
            
            <article>
                
<p>Line charts are great for revealing trends and relationships in large amounts of data. Public data is widely available in standard formats, such as CSV and JSON, but usually needs to be downscaled, parsed, and converted to a data format expected by Chart.js before using. In this section, we will extract data from a public data file and turn it into a trend-revealing visualization.</p>
<p>For all examples that use external files, you need to open your files using a web server. Double-clicking on the HTML file and opening it in your browser won't work. If you are not running your files with a web server, see the section <em>Loading d</em><em>ata files</em>, in <a href="25edc904-3528-40cc-8865-75ccf1fc78eb.xhtml">Chapter 2</a>, <em>Technology Fundamentals,</em> on how to configure a web server for testing.</p>
<p>The temperature data in the previous example was extracted from a JSON file obtained from the NASA <strong>Goddard Institute for Space Studies</strong> (<strong>GISS</strong>) website (<a href="http://data.giss.nasa.gov/gistemp">data.giss.nasa.gov/gistemp</a>), which includes monthly measurements for each year between 1880 and 2016. It would be very interesting to plot the numbers for all months in a single chart. We can do by this loading the file and using JavaScript to extract the data we want.</p>
<p>The following is a fragment of the JSON file from the GISS site. It's also available from the GitHub repository for this chapter in <kbd>Data/monthly_json.json</kbd>:</p>
<pre>[<br/>   {"Date": "2016-12-27", "Mean": 0.7895,  "Source": "GCAG"},<br/>   {"Date": "2016-12-27", "Mean": 0.81, "Source": "GISTEMP"},<br/>   {"Date": "2016-11-27", "Mean": 0.7504,  "Source": "GCAG"},<br/>   {"Date": "2016-11-27", "Mean": 0.93, "Source": "GISTEMP"},<br/>   {"Date": "2016-10-27", "Mean": 0.7292,  "Source": "GCAG"},<br/>   {"Date": "2016-10-27", "Mean": 0.89, "Source": "GISTEMP"},<br/>   /* ... many, many more lines ... */<br/>   {"Date": "1880-02-27", "Mean": -0.1229,  "Source": "GCAG"},<br/>   {"Date": "1880-02-27", "Mean": -0.21, "Source": "GISTEMP"},<br/>   {"Date": "1880-01-27", "Mean": 0.0009,   "Source": "GCAG"},<br/>   {"Date": "1880-01-27", "Mean": -0.3,  "Source": "GISTEMP"}<br/> ]</pre>
<p>Files should be loaded asynchronously. You can use any Ajax library for this (for example, JQuery) or use standard ES2015 features, supported by all modern browsers. In this book, we will use the standard JavaScript <kbd>fetch()</kbd> command (in the GitHub repository, there are also JQuery alternatives for most examples).</p>
<p>The <kbd>fetch()</kbd> command is reactive. It will wait until the whole file is loaded into memory before moving to the first <kbd>then()</kbd> step, which processes the response and extracts the JSON string (using the <kbd>text()</kbd> method). The second <kbd>then()</kbd> step only starts after all of the contents are placed in a string, made available for parsing in the final step, as follows:</p>
<pre>fetch('monthly_json.json') <br/>    .then(response =&gt; response.text())<br/>    .then((json) =&gt; {<br/>        const dataMap = new Map();<br/>    ...<br/>    });</pre>
<p>Before using a JSON file (which is a string), we need to parse it so that it will become a JavaScript object, from which we can read individual fields using the dot operator. This can be done with the standard JavaScript command, <kbd>JSON.parse()</kbd>, as follows:</p>
<pre>const obj = JSON.parse(json);</pre>
<p>If you are using JQuery or some other library instead of <kbd>fetch()</kbd>, you might prefer to use a function that loads and parses JSON. In this case, you should not run the preceding command.</p>
<p>The data contains two measurements, labeled <kbd>GCAC</kbd> and <kbd>GISTEMP</kbd>. We only need one of them, so we will filter only the objects that have <kbd>GISTEMP</kbd> as <kbd>Source</kbd>. We will also reverse the array so that the earlier measurements appear first in the chart. We can do all of this in one line, as follows:</p>
<pre>const obj = JSON.parse(json).reverse()<br/>                            .filter(field =&gt; field.Source == 'GISTEMP');<br/>console.log(obj);</pre>
<p>The last line will print the following code in your browser's JavaScript console:</p>
<pre> Array(1644)<br/>  [0 ... 99]<br/> 0:{Date: "1880-01-27", Mean: -0.3, Source: "GISTEMP"}<br/> 1:{Date: "1880-02-27", Mean: -0.21, Source: "GISTEMP"}<br/> 2:{Date: "1880-03-27", Mean: -0.18, Source: "GISTEMP"}<br/> 3:{Date: "1880-04-27", Mean: -0.27, Source: "GISTEMP"}<br/> …</pre>
<p>Now, it's easy to select the data we need to build a dataset for each year. The best way to do that is to create a <kbd>Map</kbd> storing each value and month, and use the year as a retrieval key. Split the date components to extract the year and month, and then store these values and the temperature anomaly in a new object (with properties: <kbd>year</kbd>, <kbd>month</kbd>, and <kbd>value</kbd>) for each <kbd>Map</kbd> entry.</p>
<p>These steps are performed in the following code:</p>
<pre>const dataMap = new Map();<br/>obj.forEach(d =&gt; {<br/>    const year = d.Date.split("-")[0], month = d.Date.split("-")[1];<br/>    if(dataMap.get(year)) {<br/>        dataMap.get(year).push({year: year, month: month, value: d.Mean});<br/>     } else {<br/>        dataMap.set(year, [{year: year, month: month, value: d.Mean}]);<br/>     }<br/> });<br/>console.log(dataMap); // check the structure of the generated map!<br/>draw(dataMap);</pre>
<p>The resulting map will contain one key for each year in the dataset. The value of each entry will be an array of 12 objects, one for each month. Use your browser's JavaScript console to inspect the generated map.</p>
<p>The <kbd>draw()</kbd> function will convert <kbd>dataMap</kbd> into a format that Chart.js can use. For each entry it will create a <kbd>dataset</kbd> object and add it to the <kbd>datasets</kbd> array. Each <kbd>dataset</kbd> object contains a <kbd>data</kbd> property with an array of data values (one per month), and dataset configuration properties, such as line color and label. The map's key (year) is the label, and the colors are generated in a gradient sequence using the year to change the hue, as follows:</p>
<pre>function draw(dataMap) {<br/>    const datasets = [];<br/>    dataMap.forEach((entry, key) =&gt; {<br/>        const dataset = {<br/>            label: key, // the year<br/>            data: entry.map(n =&gt; n.value), <br/>            // array w temperature for each month<br/>            borderColor:     'hsla('+(key*2)+',50%,50%,0.9)', <br/>            //gradient<br/>            backgroundColor: 'hsla('+(key*2)+',50%,50%,0.9)',<br/>            borderWidth: 1,<br/>            pointRadius: 0 // hide the data points<br/>         };<br/>         datasets.push(dataset);<br/>     });<br/> ...</pre>
<p>Now we can assemble the data object and instantiate the line chart, as follows:</p>
<pre>    const months = ["Jan","Feb", ...,"Oct","Nov","Dec"];<br/>    Chart.defaults.global.elements.line.fill = false;<br/>    const chartObj = {<br/>        type: "line",<br/>        data: {<br/>            labels: months,<br/>            datasets: datasets<br/>        }<br/>    };<br/>    new Chart("my-line-chart", chartObj);<br/> }</pre>
<p>The final result is shown as follows. The full code is available in <kbd>LineArea/line-8-load-fetch.html</kbd> (fetch version), and <kbd>LineArea/line-8-load-jquery.html</kbd> (JQuery Version):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d0a19ccb-f79b-4d17-9463-f554971970d7.png" width="1044" height="523"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Line chart using external data showing temperature variation from 1880 to 2016 (data: NASA/GISS; and code: <em>LineArea/line-8-load-fetch.html</em> for fetch version, or <em>LineArea/line-8-load-jquery.html</em> for JQuery version)</div>
<p>It looks nice, but there is too much information. We could filter out some results, but we can also just reduce the amount of labels. The <kbd>options.legend.labels.filter</kbd> property supports a <kbd>callback</kbd> function that we can use to filter out selected labels. In the following code, it will only display labels that are 20 years apart:</p>
<pre>const chartObj = {<br/>    type: "line",<br/>    data: {<br/>        labels: labels,<br/>        datasets: datasets<br/>    }<br/>    options:{<br/>        legend: {<br/>            labels: {<br/>                filter: function(item, chart) {<br/>                    return new Number(item.text) % 20 == 0;<br/>                }<br/>            }<br/>        }<br/>    }<br/>};</pre>
<p>The result is shown as follows and the full code is in <kbd>LineArea/line-10-filter.html</kbd>. Now only a few legends are shown, and the colors differ enough to relate them to different parts of the chart. Although there is still a lot of information in the chart, the colors are sufficient to reveal a trend toward increasing temperatures:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7aee54a0-e921-446d-86f1-987c5ef8bb0b.png" width="1038" height="529"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Line chart using external data after filtering out excess labels (code: <em>LineArea/line-10-filter.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stacked area charts</h1>
                </header>
            
            <article>
                
<p>A line chart could be used to show how much CO2 that each country releases in the atmosphere each year. It would reveal if a country's emissions were increasing, stable, or decreasing, but such a line chart would not be very useful to show the <em>total</em> amount of CO2 released in the air, and how each country contributes to this total. You can display this kind of information using a stacked area chart.</p>
<p>There is no special <kbd>area</kbd> type chart in Chart.js. Instead, you can create a simple overlapping area chart configuring the fill properties for each dataset in a line chart. To create a stacked area chart, you will need to set the stacked property to <kbd>true</kbd> in the <em>x</em> and y-axes.</p>
<p>Let's try an example. We will use a JSON file containing data about carbon emissions (in kilotonnes) from selected countries from 1960 to 2014. It's based on a CSV file containing data for all countries, which is available for download from the World Bank public database. I created a JSON Version of this file containing only the six greatest polluters, adding up all of the other countries in a single entry. This is the file we will use <kbd>(Data/world_bank_co2_kt.json)</kbd>, as follows:</p>
<pre>{ "labels":[1960,1961,…,2013,2014],<br/>   "entries":[<br/>      {"country":"Others",<br/>       "data":[983835.74025,1015886.52639,<br/>        …,10073290.7688,10300830.9827]},<br/>      {"country":"Russian Federation",<br/>       "data":[0,0,… ,1778561.006,1705345.684]},<br/>      {"country":"India",<br/>       "data":[120581.961,130402.187,… ,2034752.294,2238377.137]},<br/>      {"country":"Japan",<br/>       "data":[232781.16,283118.069,… ,1246515.976,1214048.358]},<br/>      {"country":"China",<br/>       "data":[780726.302,552066.85,… ,10258007.128,10291926.878]},<br/>      {"country":"European Union",<br/>       "data":[2359594.88616257,2445945.66448806,… <br/>        ,3421472.348,3241844.353]},<br/>      {"country":"United States",<br/>       "data":[2890696.1,2880505.507,2987207.873,… <br/>        ,5159160.972,5254279.285]}<br/> ]}</pre>
<p>As in the previous example, we need to load the file and parse the JSON string, as follows:</p>
<pre>fetch('world_bank_co2_kt.json')<br/>         .then(response =&gt; response.text())<br/>         .then((json) =&gt; {<br/>     draw(JSON.parse(json));<br/> });</pre>
<p>The next step is to set up an array of <kbd>labels</kbd> and <kbd>datasets</kbd> from the data. The JSON file already contains an array with the years, so all you have to do is copy it directly into the chart's data object <kbd>labels</kbd> property. The <kbd>datasets</kbd> array is assembled iterating through each entry in the data file's entries array to extract the label of the dataset (from the <kbd>country</kbd> property) and the data array (from the <kbd>data</kbd> property). We will use the array's index to generate different colors, as follows:</p>
<pre> function draw(datasetsObj) {<br/>     const datasets = [];<br/>     datasetsObj.entries.forEach((entry, index) =&gt; {<br/>         const color = 'hsla('+(index+5)*50+',75%,75%,1)';<br/>         const dataset = {<br/>             label: entry.country,<br/>             data: entry.data,<br/>             borderColor: color,<br/>             backgroundColor: color,<br/>             borderWidth: 3,<br/>             fill: 'start', // fills the space below each line<br/>             pointRadius: 0<br/>         };<br/>         datasets.push(dataset);<br/>     });<br/> <br/>     const dataObj = {<br/>         labels: datasetsObj.labels, // copied from the JSON data<br/>         datasets: datasets<br/>     }<br/> <br/>     new Chart("my-area-chart", {type: "line", data: dataObj });</pre>
<p>The result of this code is shown as follows. The full code is in <kbd>LineArea/line-11-area.html</kbd>. The step between 1990 and 1992 is caused by a lack of data in previous years, mostly from Warsaw Pact countries and the Soviet Union:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ed1bdad4-d713-4c64-9688-d04cdd530ee1.png" width="892" height="438"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">An area chart with overlapped (not stacked) datasets (code: <em>LineArea/line-11-area.html)</em></div>
<p>The <kbd>Chart</kbd> is probably not what you would expect. It's not stacking the data. The other dataset is overlapping all of the other datasets.</p>
<p>Datasets could be stacked in two ways: on the <em>x </em>axis, or on the <em>y </em>axis, so you have to tell Chart.js how you want to do it. In this example, it doesn't make sense to add up the years, but it does to add up carbon emissions, so we have to stack the <em>y </em>axis. This is done by setting the <kbd>scales.yAxes[0].stacked</kbd> property to <kbd>true</kbd>, in the options configuration object, as follows:</p>
<pre> const chartObj = {<br/>     type: "line",<br/>     data: dataObj,<br/>     options:{<br/>        scales: {<br/>            yAxes: [{<br/>               stacked: true<br/>            }]<br/>       },<br/>           legend: {<br/>            labels: {<br/>                boxWidth: 20,<br/>            }<br/>         }<br/>     }<br/> };</pre>
<p>In the preceding options configuration, we have also reduced the size of the legend boxes to half (the <kbd>boxWidth</kbd> property). You can see the final result as follows. The full code is in <kbd>LineArea/line-12-area-stacked.html</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/9ce1ca19-ef3c-4b99-a011-7b210d1ce32d.png" width="908" height="447"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A stacked area chart showing total and per-country CO2 emissions (code: <em>LineArea/line-12-area-stacked.html)</em></div>
<p>Now the chart reveals that the step from 1990 to 1992 is mostly due to Russia, for which the World Bank didn't have any carbon emission data before 1990, when it was the Soviet Union.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Radar charts</h1>
                </header>
            
            <article>
                
<p>Radar charts are line charts plotted on a radial axis. They can be used with one or more datasets that contain at least three values each. There is only one axis, which starts from the center. Each line begins and ends at the same point and, for that reason, radar charts are usually used to display values that are either cyclic in nature (such as hours, months, schedules, or repeating events), a sequential list of categories which end at the same place where it begins (such as round-trip), or categories that have no specific order. A radar chart can be used to compare different datasets by revealing strong and weak points, or showing outliers and commonality in data. It usually works best with a small number of datasets (that is, no more than three or four).</p>
<p>Radar charts are usually a poor choice for large datasets. In these cases, it's usually better to use a Cartesian line chart or a bar chart. Radial distances are also harder to perceive, although this limitation can be minimized with the grid.</p>
<p>The configurable properties for radar charts are the same as line charts. You can even reuse the same datasets and labels. The data property of each dataset must contain an array of numbers and the <kbd>chart</kbd> object should be configured with <kbd>type='radar'</kbd>.</p>
<p>In the following example, a radar chart is being used to compare three different travel schedules for a 30-day trip. Each dataset lists the number of days spent in each city. Using this chart, a tourist can quickly visualize how the days of the trip will be distributed, per city, making it easier to choose the best schedule:</p>
<pre>    let dataObj = {<br/>         labels: ["Lisbon", "Paris", "Berlin", "Moscow", "Rome", <br/>         "Barcelona"],<br/>         datasets: [<br/>             {<br/>                 label: "Trip schedule #1",<br/>                 data: [5,5,5,5,5,5],<br/>                 borderColor: 'red',<br/>                 backgroundColor: 'hsla(0,75%,75%,.25)'<br/>             },{<br/>                 label: "Trip schedule #2",<br/>                 data: [7,3,3,3,7,7],<br/>                 borderColor: 'blue',<br/>                 backgroundColor: 'hsla(240,75%,75%,.25)'<br/>             },{<br/>                 label: "Trip schedule #3",<br/>                 data: [4,7,7,7,3,2],<br/>                 borderColor: 'yellow',<br/>                 backgroundColor: 'hsla(60,75%,75%,.25)'<br/>             }<br/>         ]<br/>     }<br/> <br/>     const chartObj = {<br/>         type: "radar",<br/>         data: dataObj,<br/>         options: {<br/>             scale: {<br/>                 ticks: {<br/>                     beginAtZero: true,<br/>                     stepSize: 1 // show one gridline per day<br/>                 }<br/>             }<br/>         }<br/>     };<br/>     new Chart("my-radar-chart", chartObj);</pre>
<p>Instead of a <kbd>scales</kbd> property containing <em>x</em> axes and <em>y</em> axes, a radar chart has a single <kbd>scale</kbd> property. The grid structure is configured within the <kbd>ticks</kbd> property (more about scales at the end of this chapter).</p>
<p>The result is shown as follows. You can see the full code in <kbd>Radar/radar-1.html</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/89f74b3a-ca86-4a17-adc5-cd027376a91c.png" style="width:27.33em;height:27.08em;" width="650" height="644"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Radar chart comparing three different trip schedules for a 30-day trip (code: <em>Radar/radar-1.html)</em></div>
<p>Radar charts are great for cyclic data, such as the months in a year. Let's try to transform the Cartesian line chart we created in the previous section into a radar chart with the same data. Most of the code is the same. You only need to change the chart type, but some minor changes in the configuration will make it look better.</p>
<p>The following code shows a slightly modified <kbd>draw()</kbd> function that uses the same NASA/GISS monthly temperature data, but draws the lines in a radar chart:</p>
<pre> const months = ["Jan", "Feb", "Mar", ... , "Sep", "Oct", "Nov", <br/> "Dec"];<br/> <br/> function draw(datasetMap) {<br/>     const datasets = [];<br/> <br/>     datasetMap.forEach((entry, key) =&gt; {<br/>         const dataset = {<br/>             label: key,<br/>             data: entry.map(n =&gt; n.value),<br/>             borderColor:     'hsla('+(key*2)+',50%,50%,.9)',<br/>             backgroundColor: 'hsla('+(key*2)+',50%,50%,0.1)',<br/>             borderWidth: 1,<br/>             pointRadius: 0, // don't show the data points<br/>             lineTension: .4 // do draw lines as curves (not default in <br/>                              radar)<br/>         };<br/>         datasets.push(dataset);<br/>     });<br/> <br/>     const dataObj = {<br/>         labels: months,<br/>         datasets: datasets<br/>     }<br/> <br/>     const chartObj = {<br/>         type: "radar",<br/>         data: dataObj,<br/>         options: {<br/>             animation: {<br/>                 duration: 0<br/>             },<br/>             scale: {<br/>                 ticks: {<br/>                     max: 1.5<br/>                 }<br/>             },<br/>             legend: {<br/>                 labels: {<br/>                     boxWidth: 20,<br/>                     filter: function(item, chart) {<br/>                         return new Number(item.text) % 20 == 0<br/>                                       || item.text % 2016 == 0;<br/>                     }<br/>                 }<br/>             }<br/>         }<br/>     };<br/> <br/>     new Chart("my-radar-chart", chartObj);<br/> }</pre>
<p>The default line tension is <kbd>0</kbd> for radar charts, which draws straight lines. Since the values are averages, we selected a value between 0 and 0.5 for the <kbd>lineTension</kbd> property to make the chart draw curved lines.</p>
<p>The full code is available in <kbd>Radar/radar-3.html</kbd>. The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ac6637f1-2594-45cc-8800-dee2e3e9d673.png" style="width:30.08em;height:30.00em;" width="658" height="654"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A radar chart showing the increase in global temperatures from 1880 to 2016 (code: <em>Radar/radar-3.html)</em></div>
<p>The variation in color is sufficient to reveal that temperatures are increasing year after year. However, if you wish for more precision, you can try filtering out some <kbd>datasets</kbd> and display only the data for every two decades, as follows:</p>
<pre>datasets: datasets.filter(d =&gt; d.label % 20 == 0 || d.label % 2016 == 0)</pre>
<p>The result, showing only eight years is demonstrated as follows. The full code is in <kbd>Radar/radar-4.html</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b73b782a-ed1d-40b7-aa04-047128bb116b.png" style="width:37.33em;height:38.08em;" width="649" height="663"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A radar chart showing the increase in global temperatures every 20 years from 1880 to 2016 (code: <em>Radar/radar-4.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pie and doughnut charts</h1>
                </header>
            
            <article>
                
<p>Pie and doughnut charts are used to display numerical proportion between data as parts of a whole. Each data value is represented as a slice, which represents a proportional quantity. These charts are very popular but are also widely criticized. Since we don't perceive angles very well, it's much harder to compare data displayed in a pie chart, than in a bar or line chart. Using pie charts to compare only very small sets of data can avoid or reduce these problems.</p>
<p>A pie chart is usually used to display a single dataset. The <kbd>type</kbd> property of the chart object should be <kbd>pie</kbd>. Doughnut charts are equivalent to pie charts, but they are created with <kbd>type: doughnut</kbd>. You can also transform any pie chart into a doughnut by simply changing the dataset property <kbd>cutoutPercentage</kbd> to <kbd>50</kbd> (or some other value different than zero).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a simple pie chart</h1>
                </header>
            
            <article>
                
<p>Let's create a simple pie chart to compare CO2 emissions among the world's greatest polluters for a single year. You can use the same data we used for the area chart, but you will need to choose one of the datasets, place the country names in a <kbd>labels</kbd> array, the data for one year in the <kbd>data</kbd> array, and generate colors for each slice. All this can be done in JavaScript (see <kbd>Pie/pie-2-fetch.html</kbd>), but for the sake of simplicity and to focus on the construction of a simple pie chart, we will include the data directly in the HTML file, as shown in the following code block:</p>
<pre> const dataset = [1.21, 1.71, 2.24, 3.24, 5.25, 10.29, 10.3]; // 2014 data<br/> const labels = ["Japan", "Russian Federation", "India", "European Union",<br/>                 "United States", "China", "Others"];<br/> const colors = [];<br/> <br/> dataset.forEach((entry, index) =&gt; { // generate some colors<br/>     colors.push('hsla('+((index+5)*50)+',75%,75%,1)');<br/> });</pre>
<p class="mce-root">The <kbd>datasets</kbd> array contains a single dataset, as follows:</p>
<pre>const dataObj = {<br/>     labels: labels,<br/>     datasets: [{<br/>         data: dataset,<br/>         backgroundColor: colors,<br/>         borderWidth: 3<br/>     }]<br/> }</pre>
<p class="mce-root">The chart type should be <kbd>pie</kbd>, as follows:</p>
<pre>const chartObj = {<br/>     type: "pie",<br/>     data: dataObj,<br/>     options:{<br/>         title: {<br/>             text: "CO2 emissions (billions of tonnes)",<br/>             display: true,<br/>             fontSize: 24<br/>         },<br/>         legend: {<br/>             labels: {<br/>                 boxWidth: 20,<br/>             },<br/>             position: 'right'<br/>         }<br/> <br/>     }<br/> };<br/> new Chart("my-pie-chart", chartObj);</pre>
<p>The results are shown as follows. You can also see the full code in <kbd>Pie/pie-1.html</kbd>. Note that slices don't have any labels. You can only see the value of each slice if you hover the mouse over it. It will be shown in a tooltip:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/80ccafb3-5f6a-4c58-8dc7-c711e806ec5d.png" style="width:37.42em;height:22.58em;" width="634" height="383"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A simple pie chart showing CO2 emissions by the greatest polluters in billions of tonnes (code: <em>Pie/pie-1.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dataset properties for pie charts</h1>
                </header>
            
            <article>
                
<p>Besides <kbd>data</kbd> and <kbd>labels</kbd> properties, several other properties (listed as follows) can be used in each dataset object to configure the colors and style of each slice. All properties receive an array of attributes, and each attribute is applied to the corresponding slice:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>backgroundColor</kbd></p>
</td>
<td>
<p>Array of CSS color strings</p>
</td>
<td>
<p>The fill color of the slice</p>
</td>
</tr>
<tr>
<td>
<p><kbd>borderColor</kbd></p>
</td>
<td>
<p>Array of CSS color strings</p>
</td>
<td>
<p>The border color of the slice</p>
</td>
</tr>
<tr>
<td>
<p><kbd>borderWidth</kbd></p>
</td>
<td>
<p>Array of numbers</p>
</td>
<td>
<p>The border width of the slice</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hoverBackgroundColor</kbd></p>
</td>
<td>
<p>Array of CSS color strings</p>
</td>
<td>
<p>The fill color of the slice when the mouse hovers over it</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hoverBorderColor</kbd></p>
</td>
<td>
<p>Array of CSS color strings</p>
</td>
<td>
<p>The border color of the slice when the mouse hovers over it</p>
</td>
</tr>
<tr>
<td>
<p><kbd>hoverBorderWidth</kbd></p>
</td>
<td>
<p>Array of numbers</p>
</td>
<td>
<p>The border width of the slice when the mouse hovers over it</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Dataset options for pie and doughnut charts</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuration options</h1>
                </header>
            
            <article>
                
<p>Common configuration options are inherited for pie charts, but there are also some options that are specific to pie and doughnut charts. These are listed in the following table:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>cutoutPercentage</kbd></p>
</td>
<td>
<p><kbd>Number. Defaults</kbd>: <kbd>0</kbd> for <kbd>'pie'</kbd>, and <kbd>'50'</kbd> for doughnut</p>
</td>
<td>
<p>A percentage of the chart that is cut out from the middle</p>
</td>
</tr>
<tr>
<td>
<p><kbd>rotation</kbd></p>
</td>
<td>
<p><kbd>Number. Default</kbd>: <em>-0.5 * Math.PI</em></p>
</td>
<td>
<p>The starting angle to draw the arcs</p>
</td>
</tr>
<tr>
<td>
<p><kbd>circumference</kbd></p>
</td>
<td>
<p><kbd>Number. Default</kbd>: <em>2 * Math.PI</em></p>
</td>
<td>
<p>The circumference of the pie</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Configuration options for pie and doughnut charts</div>
<p>These options are merged (and override) global configuration options. Default options for each type of chart can also be set through the <kbd>Chart.defaults.doughnut</kbd> and <kbd>Chart.defaults.pie</kbd> objects, which support the same properties listed earlier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to show values in the slices</h1>
                </header>
            
            <article>
                
<p>Currently, there is no native Chart.js way to show values or percentages in a pie chart without tooltips. But you can achieve this using a plugin or extension. In the following example, we will use a very simple library called <kbd>Chart.Piecelabel.js</kbd>. You can download it from <a href="http://github.com/emn178/Chart.PieceLabel.js">github.com/emn178/Chart.PieceLabel.js</a> and include it your page using a script tag:</p>
<pre>&lt;script src="../JavaScript/Chart.PieceLabel.js"&gt;&lt;/script&gt;</pre>
<p>That's it! Now you can add the <kbd>pieceLabel</kbd> property to the <kbd>options</kbd> object, and configure labels for the slices. You can display absolute values or percentages, place the labels inside, at the border or outside the slices, draw the text on the arc and configure several font attributes. The following is a selection of these properties (you can check the library's documentation for more properties):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>render</kbd></p>
</td>
<td>
<p><kbd>'percentage'</kbd> (default) or <kbd>'value'</kbd></p>
</td>
<td>
<p>Displays the percentage or the value of the slice.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>precision</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td>
<p>The <kbd>precision</kbd> (number of digits after the decimal point) for percentages (does not work with other values).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fontSize</kbd>, <kbd>fontColor</kbd>, <kbd>fontSize</kbd>, and <kbd>fontFamily</kbd></p>
</td>
<td>
<p>CSS property value strings</p>
</td>
<td>
<p>Changes font attributes for the label.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>textShadow</kbd></p>
</td>
<td>
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td>
<p>Applies a shadow to the label (the shadow attributes, such as offset and color, can also be configured with additional properties).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>position</kbd></p>
</td>
<td>
<p><kbd>'default'</kbd>, <kbd>'border'</kbd> or <kbd>'outside'</kbd></p>
</td>
<td>
<p>Places the label in the different positions.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>arc</kbd></p>
</td>
<td>
<p><kbd>true</kbd> or <kbd>false</kbd></p>
</td>
<td>
<p>Draws the text aligned with the arc. Works better when the position is <kbd>'outside'</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Some configuration options for the <em>Chart.PieceLabel.js</em> plugin</div>
<p>To include labels in the pie chart you created in the previous example, add the following property to the <kbd>options</kbd> object of your chart (see <kbd>Pie/pie-3-plugin.html</kbd>):</p>
<pre>options:{<br/>     pieceLabel: {<br/>        fontColor: '#000',<br/>        render: 'value',<br/>        textShadow: true,<br/>        position: 'border'<br/>    },<br/> …</pre>
<p>Run the script and you have labels containing the value represented by each slice, as shown in the following chart:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/851535b1-6a8a-4df7-994c-391df477464e.png" width="653" height="395"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A simple pie chart using the Chart.PieceLabel.js extension to display labels on each slice (code: <em>Pie/pie-3-plugin.html)</em></div>
<p>If you want even more customization, you can try other plugins such as <kbd>ChartJS-Datalabels</kbd> and <kbd>ChartJS-Outlabels</kbd>, which support sophisticated label placement options. These two plugins will be explored in <a href="6a377615-9cab-4346-817a-cecda0a2d90c.xhtml" target="_blank"/><a href="6a377615-9cab-4346-817a-cecda0a2d90c.xhtml" target="_blank"/><a href="6a377615-9cab-4346-817a-cecda0a2d90c.xhtml" target="_blank">Chapter 6</a>, <em>Configuring Styles and Interactivity</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Preparing data for pie and doughnut charts</h1>
                </header>
            
            <article>
                
<p>Pie charts can't be used with any type of data. They should only be used to display part-whole relationships and contain not much more than half a dozen data values. The following screenshot shows what happens when you create a pie or doughnut chart with too much data. In this example, we loaded a doughnut chart containing the populations of almost 200 countries. It may be art, but not really a useful visualization:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fdf60085-508b-47c5-8815-7dd9c584c601.png" width="1316" height="349"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Abusing a pie chart (code: Pie/pie-4-evilpie.html; see also <em>Pie/pie-6-evilpie.html)</em></div>
<p>Even if you reduce this dataset to less than 20 values, it would still not be efficiently displayed in a pie chart. There aren't enough colors, and it would be difficult to place labels inside or beside so many slices, not considering the fact that angles are much harder to compare. In such cases, you should switch to a bar chart, which can be used to efficiently compare 20 values or even more.</p>
<p>The following screenshot shows a bar chart created with the same data, filtered to show the 35 most populous countries:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/67232af8-3a59-4064-b119-482277744876.png" width="1267" height="633"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A bar chart is a better choice than a pie chart to compare large datasets (code: Pie/pie-5-evilpie-as-bar.html; see also <em>Pie/pie-7-evilpie-as-bar.html)</em></div>
<p>If you still want to use a pie chart, you need to reduce the data sample, but it's not enough to simply filter out data (for example, by including only the most populous countries). Since a pie chart should display part-whole relationships, but you also need to add the excluded items (for example, add up the populations of the smaller countries, as in the CO2 emissions example).</p>
<p>This is done in the following example: it loads and parses a CSV data file, sorts the data by population, creates an array of objects with the largest countries, and finally, adds up all of the other populations into a new others entry.</p>
<p>To parse the CSV, we are using the popular <kbd>PapaParse</kbd> library (<a href="http://github.com/mholt/PapaParse">github.com/mholt/PapaParse</a>). You can include it in your page using the following code:</p>
<pre>&lt;script   <br/>src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.6.0/papaparse.min.js"&gt;<br/> &lt;/script&gt;</pre>
<p><kbd>PapaParse</kbd> reads CSV and transforms the data into a JavaScript array, where each row is an object with the column headers as keys. To obtain the data from any CSV file where the first row contains the headers (which is the most common case), use the following code:</p>
<pre>const data = Papa.parse(csv, {header: true}).data;</pre>
<p>Now, for each array item, you can access the values using <kbd>item.header</kbd> or <kbd>item['header']</kbd>.</p>
<p>The following code loads the CSV, parses it, and calls a function to reduce the data. The reduced data is then passed to the <kbd>drawData()</kbd> function that will use Chart.js to draw the pie, as follows:</p>
<pre> const numberOfEntries = 6; // change this to include more countries<br/> <br/> fetch('../Data/WPP2017_UN.csv')<br/>     .then(response =&gt; response.text())<br/>     .then((csv) =&gt; {<br/>         const data = Papa.parse(csv, {header: true}).data;<br/>         const reduced = reduceData(data);<br/>         drawData(reduced);<br/> });</pre>
<p>The <kbd>reduceData()</kbd> function filters the countries with the largest population (that is, by sorting by population, and then slicing the array), and adds the populations of the remaining countries to create the <kbd>others</kbd> entry, as follows:</p>
<pre> function reduceData(array) {<br/>     array.sort((a, b) =&gt;  a["2015"] - b["2015"]);<br/> <br/>     const topEntries =<br/>         array.slice(array.length - numberOfEntries,array.length)<br/>              .map(d =&gt; ({country: d["Country or region"], data: <br/>              +d["2015"]}));<br/> <br/>     let others = array.slice(0, array.length - numberOfEntries);<br/>     const sumOthers = others.map(d =&gt; +d["2015"]).reduce((a,b) =&gt; a+b, 0);<br/>     others = {country: "Others", data: sumOthers};<br/>     topEntries.push(others);<br/>     return topEntries;<br/> }</pre>
<p>The <kbd>drawData()</kbd> function prepares the data so that it can be used by Chart.js, and uses the result to populate the chart's labels, <kbd>datasets[0].data</kbd> and <kbd>datasets[0].backgroundColor</kbd>, as follows:</p>
<pre> function drawData(data) {<br/>     const dataset = [], labels = [], colors = [];<br/>     let count = 0;<br/>     data.forEach(d =&gt; {<br/>         dataset.push(Math.round(d.data/1000));<br/>         labels.push(d.country);<br/>         colors.push('hsla('+(count++ * <br/>         300/numberOfEntries)+',100%,70%,.9)');<br/>     });<br/> <br/>     const dataObj = {<br/>         labels: labels,<br/>         datasets: [<br/>             {<br/>                 data: dataset,<br/>                 backgroundColor: colors,<br/>                 borderWidth: 5,<br/>                 hoverBackgroundColor: 'black',<br/>                 hoverBorderColor: 'white'<br/>             }<br/>         ]<br/>     }<br/> <br/>     const chartObj = {<br/>         type: "doughnut",<br/>         data: dataObj,<br/>         options: {<br/>             title: {<br/>                 display: true,<br/>                 position: 'left',<br/>                 fontSize: 24,<br/>                 text: "World population (millions)"<br/>             },<br/>             legend: {<br/>                 position: 'right'<br/>             },<br/>             pieceLabel: {<br/>                 fontColor: '#000',<br/>                 render: 'value',<br/>                 textShadow: true,<br/>                 position: 'border'<br/>             }<br/>         }<br/>     };<br/>     new Chart("my-pie-chart", chartObj);<br/> }</pre>
<p>You can see the full code in <kbd>Pie/pie-8-filter.html</kbd>. The final result, showing six countries compared to all of the others, is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/aa763a56-cc19-4d17-8c60-a4e8d75cabf5.png" width="1029" height="521"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A doughnut chart comparing the most populous countries with the rest of the world (code: <em>Pie/pie-8-filter.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the circumference</h1>
                </header>
            
            <article>
                
<p>Pie and doughnut charts don't have to be complete circles. You can set the value of the <kbd>circumference</kbd> property (in radians) and use less than 360 degrees (<em>2 * Math.PI</em> radians). Using <kbd>Math.PI</kbd> as the circumference, you get a half-pie or half-doughnut chart. These charts are good to compare two or three values and may fit better in reduced spaces.</p>
<p>We modified the previous chart in the following example. It compares the 2017 populations of China and India with the rest of the world using a half-doughnut. The following fragment contains the relevant code. You can see the full code in <kbd>Pie/pie-9-halfpie.html</kbd>:</p>
<pre> const numberOfEntries = 2;<br/> // ...<br/> const chartObj = {<br/>     type: "doughnut",<br/>     data: dataObj,<br/>     options: {<br/>         circumference: Math.PI, // creates the half-pie<br/>         rotation: Math.PI / 2,  // rotates the half-pie 180 degrees<br/>         title: {...},<br/>         legend: {...},<br/>         pieceLabel: {...}<br/>     }<br/> };<br/>new Chart("my-pie-chart", chartObj);</pre>
<p>The resulting chart is shown as follows. The <kbd>rotation</kbd> property doesn't contain the amount of rotation, but a position (that is, the starting angle from where the arcs are drawn), and the default rotation position is <em>-Math.PI/2</em>, so the value of <em>Math.PI/2</em> actually rotates it 180 degrees, not 90 degrees, as it might seem (for that, use Math.PI to move it to a perpendicular position):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/276597cc-77f0-466a-9836-078add048752.png" style="width:43.00em;height:43.58em;" width="639" height="648"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Changing the circumference and rotation properties of a doughnut chart (code: <em>Pie/pie-9-halfpie.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pie and doughnut charts with multiple datasets</h1>
                </header>
            
            <article>
                
<p>Normally, you only display a single dataset with a pie chart, but multiple datasets are supported. They are displayed as concentric circles. Labeling the data in this case is mandatory, since it's impossible to visually compare the sizes of the slices.</p>
<p>The following example uses two datasets containing country population estimates from 1980 and 2015 to create a doughnut chart with the 1980 values in the inner circle, and the 2015 values in the outer circle. The relevant code fragments are shown as follows. You can see the full code in <kbd>Pie/pie-10-multiset.html</kbd>:</p>
<pre> const dataset2015 = [189,206,258,320,1309,1397,3703],<br/>       dataset1980 = [78,121,147,230,697,994,2191];<br/> <br/> const labels = ["Pakistan", "Brazil", "Indonesia", "United States of <br/>                America", "India", "China", "Others"];<br/> <br/> const colors2015 = [], colors1980 = [];<br/> <br/> let count = 0;<br/> labels.forEach(d =&gt; {<br/>     count++;<br/>     colors2015.push('hsla('+(count * 300 / labels.length)+', 100%,<br/>     50%, .9)');<br/>     colors1980.push('hsla('+(count * 300 / labels.length)+', 100%,<br/>     75%, .9)');<br/> });<br/> <br/> const dataObj = {<br/>     labels: labels,<br/>     datasets: [<br/>         { data: dataset2015, backgroundColor: colors2015 },<br/>         { data: dataset1980, backgroundColor: colors1980 }<br/>     ]<br/> }<br/> const canvas = document.getElementById("my-pie-chart");<br/> const ctx = canvas.getContext("2d");<br/> <br/> const chartObj = {<br/>     type: "doughnut",<br/>     data: dataObj,<br/>     options: {<br/>         animation: { // to draw on canvas use this callback<br/>             onComplete: function() {<br/>                 ctx.fillText("Population in 1980",<br/>                               canvas.width/2 - 140,canvas.height/2);<br/>                 ctx.fillText("Population in 2015",<br/>                               canvas.width/2 + 70,canvas.height - 10);<br/>             }<br/>         } // ...<br/>     }<br/> };<br/> <br/> const chart = new Chart("my-pie-chart", chartObj);<br/> chart.update();</pre>
<p>The label in the center of the doughnuts was created by drawing directly on the canvas. If you need to do that, you must use a callback. The <kbd>onComplete</kbd> callback (configured under <kbd>options.animation</kbd>) is called when the chart has finished drawing. If you don't use a callback, Chart.js may erase whatever you draw. This behavior will be detailed in <a href="6a377615-9cab-4346-817a-cecda0a2d90c.xhtml">Chapter 6</a>, <em>Configuring Styles and</em><br/>
<em>Interactivity</em>.</p>
<p>The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/88acb19f-9e25-482d-9f08-dfbb9d327478.png" width="1104" height="569"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A doughnut chart with two datasets (code: Pie/pie-10-multiset.html)</div>
<p>These charts may be visually attractive, but they can introduce some serious perception errors. The outer arcs are perceived to be much larger than they actually are. It's an optical illusion. A population growth in the preceding chart won't be noticed unless the difference is significant. You can visualize this problem if you invert the order of the datasets, placing the 1980 values on the outer circle. This is shown in the following chart, where it seems that some populations grew in proportion to the whole, when all of them actually decreased. This chart is lying to us:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0f8a6030-8ed6-4d5a-a63d-95455cbaa943.png" width="1092" height="573"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Multiple datasets cannot be compared in pie and doughnut charts: the smaller values seem to be larger (code: Pie/pie-11-evilmultiset.html)</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Polar area charts</h1>
                </header>
            
            <article>
                
<p>Polar area charts are like bar charts rendered on a radial axis. A bar chart is usually a better option if you need precision, but you might choose a polar area chart for its visual effects.</p>
<p>To create a polar area chart, you set up the data the same way you would for a bar chart, then change the type to <kbd>polarArea</kbd>. As in the radar chart, there is only one <kbd>scale</kbd> property and axis to configure.</p>
<p>In the following example, we use a polar area chart to compare the volumes of the world's oceans. It is based on the bar chart with the same data we created in <a href="af85e307-a9bc-47c5-be74-52727cbb7c2e.xhtml">Chapter 3</a>,<em> Chart.js – Quick Start</em>.</p>
<pre> const labels = ["Arctic", "Southern", "North Atlantic", "South <br/>                Atlantic", "Indian", "South Pacific", "North Pacific"];<br/> const volume = [18750, 71800,146000,160000,264000,329000,341000]; <br/> // km3*10^3<br/> <br/> Chart.defaults.global.elements.rectangle.borderWidth = 1;<br/> <br/> const chartObj = {<br/>     labels: labels,<br/>     datasets: [<br/>         {<br/>             label: "Volume",<br/>             data: volume,<br/>             borderWidth: 2,<br/>             backgroundColor: [<br/>                 'hsla(260,100%,75%,.7',<br/>                 'hsla(245,100%,75%,.7',<br/>                 'hsla(230,100%,75%,.7',<br/>                 'hsla(210,100%,75%,.7',<br/>                 'hsla(195,100%,75%,.7',<br/>                 'hsla(180,100%,75%,.7',<br/>                 'hsla(165,100%,75%,.7']<br/>         }<br/>     ]<br/> }<br/> new Chart("my-polar-area-chart", {<br/>     type: "polarArea",<br/>     data: chartObj,<br/>     options: {<br/>         title: {<br/>             display: true,<br/>             position: 'left',<br/>             fontSize: 24,<br/>             text: "Volume of water (in 1000 cubic km)"<br/>         },<br/>         legend: {<br/>             position: 'right'<br/>         }<br/>     }<br/> });</pre>
<p>You can see the full code in <kbd>PolarArea/polar-area-1.html</kbd>. The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6d563c44-54f2-440c-b273-b6790d900a3d.png" width="774" height="533"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A polar area chart comparing the volume of water in each ocean (code: <em>PolarArea/polar-area-1.html)</em></div>
<p>Polar area charts share the same dataset properties as pie and doughnut charts, which consist mostly of properties to set the border widths, border colors, and fill colors of the slices.</p>
<p>There is one configuration option specific to polar area charts, listed as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Property</strong></p>
</td>
<td>
<p><strong>Value</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>startAngle</kbd></p>
</td>
<td>
<p>Number</p>
</td>
<td>
<p>The angle to start drawing the arcs</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Configuration options for polar area charts</div>
<p>You can draw polar area charts containing multiple datasets, but they will be overlapped. The current version of Chart.js (2.7.2) does not support stacking or other ways of showing multiple datasets in these charts. You can also see <kbd>PolarArea/polar-area-2.html</kbd> and <kbd>polar-area-3.html</kbd> for other ways to configure polar area charts.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scatter and bubble charts</h1>
                </header>
            
            <article>
                
<p>Scatter charts or scatterplots are very popular in data science and statistics. They can be used to explore various kinds of correlations between variables, revealing trends, clusters, linear, and non-linear relationships. It's an essential tool in problem solving procedures and decision-making.</p>
<p>Scatter charts display the correlation between two variables by plotting their points in a system of Cartesian coordinates. Additional variables can be displayed by using different shapes and/or colors for the points.</p>
<p>A bubble chart is a scatter chart that uses circles with different radii to display an additional variable. It's also common to overlap scatter charts with other charts, such as line and bar charts, as to emphasize patterns and compare raw data with estimates, such as trendlines (best-fit).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a scatter chart</h1>
                </header>
            
            <article>
                
<p>The <kbd>type</kbd> property should be <kbd>scatter</kbd>. Scatter charts support the same properties as line charts, but instead of an array of numbers, the data property should contain an array of point objects with the following structure:</p>
<pre>{<br/>     x: number,<br/>     y: number<br/> }</pre>
<p>The following example creates a simple scatter chart with a single dataset. The data values consist of a sequence of numbers generated for the <em>x</em> property, and the sine function of each number for the <em>y</em> property:</p>
<pre>const dataset = [];<br/> for(let i = 0; i &lt;= 360; i+= 5) {<br/>     const point = {<br/>         x: i,<br/>         y: Math.sin(i * Math.PI / 180)<br/>     }<br/>     dataset.push(point);<br/> }<br/> <br/> const dataObj = {<br/>     datasets: [<br/>         {<br/>             data: dataset,<br/>             pointRadius: 2,<br/>             backgroundColor: 'red'<br/>         }<br/>     ]<br/> }<br/> <br/> const chartObj = {<br/>     type: "scatter",<br/>     data: dataObj,<br/>     options: {<br/>         legend: {<br/>             display: false<br/>         },<br/> <br/> <br/>     }<br/> };<br/> new Chart("my-scatter-chart", chartObj);</pre>
<p>You can see the full code in <kbd>ScatterBubble/scatter-1.html</kbd>. The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/981fdbb7-7a24-4e0f-94e7-43d4671c9de2.png" width="740" height="381"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A simple scatter chart with x = n and y = sin(x) (code: <em>ScatterBubble/scatter-1.html)</em></div>
<p>Multiple datasets can be displayed on the same chart. This following example generates two more mathematical functions and displays their graphs using the same scales:</p>
<pre>const dataset1 = [], dataset2 = [], dataset3 = [];<br/> for(let i = 0; i &lt;= 360; i+= 5) {<br/>     const n = i * Math.PI / 180;<br/>     const point1 = { x: n - Math.PI, y: Math.sin(n) }<br/>     const point2 = { x: n - Math.PI, y: Math.cos(n) }<br/>     const point3 = { x: Math.cos(n) + Math.sin(n), y: Math.cos(n) -<br/>     Math.sin(n) }<br/>     dataset1.push(point1);<br/>     dataset2.push(point2);<br/>     dataset3.push(point3);<br/> }<br/> <br/> const dataObj = {<br/>     datasets: [<br/>         {   data: dataset1,<br/>             pointRadius: 2,<br/>             backgroundColor: 'red'<br/>         },{<br/>             data: dataset2,<br/>             pointRadius: 2,<br/>             backgroundColor: 'blue'<br/>         },{<br/>             data: dataset3,<br/>             pointRadius: 2,<br/>             backgroundColor: 'green'<br/>         }<br/>     ]<br/> }<br/> <br/> const chartObj = {<br/>     type: "scatter",<br/>     data: dataObj,<br/>     options: {<br/>         legend: { display: false },<br/>         scales: {<br/>             yAxes: [{<br/>                 ticks: {min: -2, max: 2}<br/>             }]<br/>         }<br/>     }<br/> };<br/> new Chart("my-scatter-chart", chartObj);</pre>
<p> You can see the full code in <kbd>ScatterBubble/scatter-3.html</kbd>. The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/67da03c1-1cab-41e2-a1c5-9d5ad18de72e.png" width="1105" height="565"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Scatterplot with multiple datasets (code: <em>ScatterBubble/scatter-3.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Revealing correlations with scatter charts</h1>
                </header>
            
            <article>
                
<p>Scatter charts are great to show correlations between data. The following example will combine NASA/GISS global temperature data (<kbd>Data/monthly_json.json</kbd>) and CO2 emission data (<kbd>Data/co2_mm_mlo.csv</kbd>) measured in Mauna Loa, Hawaii, to discover if there is any correlation between the two. Since the Mauna Loa data is only available after 1959, we will only use the GISS data after that year.</p>
<p>Since we must load multiple files, we will use JavaScript promises. Each data source is parsed and the data is sent to the <kbd>combine()</kbd> function, which returns an array that can be used by Chart.js, as follows:</p>
<pre>const canvas = document.getElementById("my-scatter-chart");<br/> const files = ['../Data/monthly_json.json', '../Data/co2_mm_mlo.csv'];<br/> var promises = files.map(file =&gt; fetch(file).then(resp =&gt; resp.text()));<br/> Promise.all(promises).then(results =&gt; {<br/>     const temperatures = JSON.parse(results[0]);<br/>     const co2emissions = Papa.parse(results[1], {header: true}).data;<br/>     const data = combine(temperatures, co2emissions);<br/>     drawData(data);<br/> });</pre>
<p>The <kbd>combine()</kbd> function iterates through each object in the CO2 data, extracts the year and the month and uses it to obtain the corresponding mean temperature, then creates an object with the CO2 and temperature for each month/year. Each object is pushed into an array that is returned, as follows:</p>
<pre>function combine(tempData, co2Data) {<br/>     const entries = [];<br/>     co2Data.filter(n =&gt; +n.year &gt;= 1959).forEach(measure =&gt; {<br/>        const year = measure.year, month = measure.month;<br/>        let temperature = 0;<br/>        tempData.filter(n =&gt; n.Source=='GISTEMP' &amp;&amp; +n.Date.split("-")<br/>        [0] &gt;= 1959)<br/>                .forEach(temp =&gt; {<br/>                     if(+temp.Date.split("-")[0] == year<br/>                        &amp;&amp; +temp.Date.split("-")[1] == month) {<br/>                            temperature = temp.Mean;<br/>                        }<br/>                 });<br/>        entries.push({ co2: measure.average, temp: temperature });<br/>     });<br/>     return entries;<br/> }</pre>
<p>The following <kbd>drawData()</kbd> function uses the array of objects that contains <kbd>co2</kbd> and <kbd>temp</kbd> properties to draw the scatter chart by copying these values into <kbd>{x,y}</kbd> objects:</p>
<pre>function drawData(datasets) {<br/>     const entries = [];<br/>     datasets.forEach(entry =&gt; {<br/>         const obj = { x: entry.co2, y: entry.temp };<br/>         entries.push(obj);<br/>     });<br/>     const dataObj = {<br/>         datasets: [<br/>             {<br/>                 data: entries,<br/>                 pointRadius: 2,<br/>                 pointBackgroundColor: 'rgba(255,0,0,.5)'<br/>             }<br/>         ]<br/>     }<br/>     const chartObj = {<br/>         type: "scatter",<br/>         data: dataObj,<br/>         options: { legend: { display: false } }<br/>     };<br/>     new Chart("my-scatter-chart", chartObj);<br/> }</pre>
<p>You can see the full code in <kbd>ScatterBubble/scatter-4.html</kbd>. The result is shown in the following chart and reveals a possible relationship between growing CO2 emissions and global temperatures. It also shows some data that we should have filtered out (if we had read the documentation that comes with the data), such as missing CO2 measurements, which appear as <em>-99.99</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/48d10353-e78c-49c0-a587-fb29b1e770bc.png" width="1266" height="633"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Comparing CO2 emissions (source: Mauna Loa) and global temperature (source: NASA; code: <em>ScatterBubble/scatter-4.html)</em></div>
<p>We can filter out the bad measurements by adding an extra predicate to the <kbd>co2Data</kbd> filter, as follows:</p>
<pre>co2Data.filter(n =&gt; +n.year &gt;= 1959 &amp;&amp; n.average &gt; 0)</pre>
<p>It's also a good idea to label the axes, so the viewer knows what kind of data is being compared. The following configuration adds axis titles and also a title for the chart. The full code is in <kbd>ScatterBubble/scatter-5.html</kbd>:</p>
<pre>const chartObj = {<br/>     type: "scatter",<br/>     data: dataObj,<br/>     options: {<br/>         legend: { display: false},<br/>         title: {<br/>             display: true,<br/>             text: 'CO2 emissions vs. Global temperatures',<br/>             fontSize: 24<br/>         },<br/>         scales: {<br/>             xAxes: [{<br/>                 scaleLabel: {<br/>                     labelString: 'CO2 emissions (ppm)',<br/>                     display: true<br/>                 }<br/>             }],<br/>             yAxes: [{<br/>                 scaleLabel: {<br/>                     labelString: 'Temperature anomaly (Celsius)',<br/>                     display: true<br/>                 }<br/>             }],<br/>         }<br/>     }<br/> };<br/> new Chart("my-scatter-chart", chartObj);</pre>
<p> The final chart is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/741dddba-ae85-4a90-b258-15483c9e31fa.png" width="1274" height="635"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">CO2 vs temperature scatter chart after filtering out wrong measurements (code: <em>ScatterBubble/scatter-5.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scatter charts with large quantities of data</h1>
                </header>
            
            <article>
                
<p>Scatter charts are great to reveal hidden patterns in large datasets. In the following example, we will use a huge file obtained from a public database (<a href="http://geonames.org">geonames.org</a>) to plot a scatter chart showing the position of cities based on their latitude and longitude. The file contains a list of locations with populations above 15,000 (<kbd>Data/cities_15000.csv</kbd>). It contains over 100,000 entries (and because of this, it will take a few seconds to load). This is the general structure of the CSV file:</p>
<pre>geonameid;asciiname;latitude;longitude;country_code;population;timezone14256;Azadshahr;34.79049;48.57011;IR;514102;Asia/Tehran<br/>18918;Protaras;35.0125;34.05833;CY;20230;Asia/Nicosia<br/>23814;Kahriz;34.3838;47.0553;IR;766706;Asia/Tehran<br/>24851;Nurabad;34.0734;47.9725;IR;73528;Asia/Tehran<br/>// + than 100 000 lines</pre>
<p>To build the scatter chart, we need to process the file and convert latitudes and longitudes into the point data format. The axes also have to be configured to represent a cylindrical projection of the globe (limited by longitude: <em>-180</em> to <em>180</em> and latitude: <em>-90</em> to <em>90</em>). The following code configures the scales, loads the files, parses the data, builds the point object for each coordinate pair, and draws the chart:</p>
<pre>fetch('../Data/cities15000.csv')<br/>    .then(response =&gt; response.text())<br/>    .then(csv =&gt; drawData(Papa.parse(csv, {header: true}).data));<br/> <br/> function drawData(datasets) {<br/>     const locations = [];<br/>     datasets.forEach(city =&gt; {<br/>         const obj = {<br/>             x: city.longitude,<br/>             y: city.latitude,<br/>             name: city.asciiname<br/>         }<br/>         locations.push(obj);<br/>     });<br/> <br/>     const dataObj = {<br/>         datasets: [<br/>             {<br/>                 label: "Label",<br/>                 data: locations,<br/>                 pointRadius: .25,<br/>                 pointBackgroundColor: 'red'<br/>             }<br/>         ]<br/>     }<br/> <br/>     const chartObj = {<br/>         type: "scatter",<br/>         data: dataObj,<br/>         options: {<br/>             animation: { duration: 0 },<br/>             title: { display: false },<br/>             responsive: false,<br/>             legend: { display: false },<br/>             scales: {<br/>                 xAxes: [ { ticks: { min: -180, max: 180 } } ],<br/>                 yAxes: [ { ticks: { min: -90,  max: 90  } } ]<br/>             },<br/>             tooltips: {<br/>                 callbacks: {<br/>                     title: (items,data) =&gt; locations[items[0].index].name<br/>                 }<br/>             }<br/>         }<br/>     };<br/> <br/>     new Chart("my-scatter-chart", chartObj);<br/> }</pre>
<p>You can see the full code in <kbd>ScatterBubble/scatter-6-world.html</kbd>. The result reveals a surprising hidden pattern (and correlation between land and humans). You can move the mouse over the points and it will reveal the name and coordinates of the location (this was configured using tooltip callbacks):</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0010d633-267c-457b-b4f4-8c237c1a5a85.png" width="1002" height="504"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Scatter chart showing the position of over 100,000 human-populated locations (code: <em>ScatterBubble/scatter-6-world.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bubble charts</h1>
                </header>
            
            <article>
                
<p>Bubble charts are just like scatter charts, but they can display an extra variable in the diameter of the point (or shape). The <kbd>type</kbd> property should be <kbd>bubble</kbd>. Although they share the same dataset properties as scatter charts, most of them can receive callbacks in bubble charts, which allow a higher degree of interactivity. The data structure for bubble charts contains three properties, as follows:</p>
<pre>{x: number, y: number, r: number}</pre>
<p>The properties <kbd>x</kbd> and <kbd>y</kbd> are scaled automatically when the chart is scaled. The <kbd>r</kbd> property is the raw radius of the circle in pixels and is not scaled (but you can configure a callback if you need to scale it).</p>
<p>The following code (<kbd>ScatterBubble/bubble-1.html</kbd>) creates a simple bubble chart with a single dataset containing five entries. The color of each bubble is generated automatically according to the radius of the bubble using a callback:</p>
<pre>const dataObj = {<br/>     datasets: [<br/>         {<br/>             data: [{x:5, y:1, r:60},{x:3, y:1, r:30},{x:1, y:2, r:15},<br/>                    {x:3, y:5, r:90},{x:2, y:4, r:20}],<br/>             backgroundColor: function(context) {<br/>                 const point = context.dataset.data[context.dataIndex];<br/>                 return 'hsla('+(point.r * 4)+',100%,70%,.6)'<br/>             }<br/>         }<br/>     ]<br/> }<br/> <br/> const chartObj = { type: "bubble", data: dataObj,<br/>     options: {<br/>         scales: {<br/>             xAxes: [{ticks: {min: 0, max: 6}}],<br/>             yAxes: [{ticks: {min: 0, max: 7}}]<br/>         },<br/>     }<br/> };<br/> new Chart("my-bubble-chart", chartObj);</pre>
<p>The result is shown as follows. Note that if you resize the chart, the bubble sizes don't change:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3d415249-e7e3-4a19-a01f-9e88dee674ff.png" width="838" height="390"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A simple bubble chart with one dataset (code: <em>ScatterBubble/bubble-1.html)</em></div>
<p>Bubble charts are as not as informative as scatter charts when displaying large amounts of data, but they can still reveal interesting information. The following example converts the previously shown scatter chart into a bubble chart using the population of each location to generate the radius of the bubble.</p>
<p>Since bubbles may overlap, the dataset is sorted so that the smaller populations stay on top. The <kbd>scaleR()</kbd> function creates a simple scale to convert populations into circle radii, as follows:</p>
<pre>fetch('../Data/cities15000.csv')<br/>         .then(response =&gt; response.text())<br/>         .then(csv =&gt; {<br/>             const data = Papa.parse(csv, {header: true}).data;<br/>             drawData(data.sort((a, b) =&gt;  b.population - a.population));<br/>          });<br/> <br/> function scaleR(value) {<br/>     const r = Math.floor(value / 100000);<br/>     return r != 0 ? r/10 : .25;<br/> }</pre>
<p>The <kbd>drawData()</kbd> function creates a data point object for the bubble chart, with three properties <kbd>x</kbd>, <kbd>y</kbd> containing the longitudes and latitudes, and the scaled population converted into a radius, as follows:</p>
<pre>function drawData(datasets) {<br/>     const coordset = [];<br/>     datasets.forEach(city =&gt; {<br/>         const obj = {<br/>             x: city.longitude,<br/>             y: city.latitude,<br/>             r: scaleR(city.population)<br/>         };<br/>         coordset.push(obj);<br/>     });</pre>
<p>The data object includes the data array as its data, and configures the <kbd>backgroundColor</kbd> <br/>
property as a callback that returns different colors for the bubbles depending on the value of the radius, as follows:</p>
<pre>     const dataObj = {<br/>         datasets: [<br/>             {<br/>                 label: "Label",<br/>                 data: coordset,<br/>                 backgroundColor: function(context) {<br/>                     const value =     <br/>                     context.dataset.data[context.dataIndex].r;<br/>                     if(value &gt; 20) return 'hsla(0,100%,50%,.4)';<br/>                     if(value &gt; 10) return 'hsla(30,100%,50%,.5)';<br/>                     if(value &gt; 5) return 'hsla(60,100%,50%,.6)';<br/>                     if(value &gt; 1) return 'hsla(120,100%,50%,.7)';<br/>                     else return 'hsla(0,0%,50%,1)';<br/>                 }<br/>             }<br/>         ]<br/>     }<br/> <br/>     new Chart("my-bubble-chart", {type: 'bubble', data: dataObj, options: {...});<br/> }</pre>
<p> You can see the full code in <kbd>ScatterBubble/bubble-2.html</kbd>. The result is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/0993b6e9-4d5e-4788-814a-b2a9f4546fe4.png" width="1006" height="506"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">A bubble map of cities. The bubble's radius is proportional to the population of each location (code: <em>ScatterBubble/bubble-2.html)</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to create all of the standard types of charts supported by Chart.js: bar, horizontal bar, line, area, pie, doughnut, polar area, radar, scatter, and bubble charts.</p>
<p>Different charts are more suited for certain types of datasets and purposes than others. We explored the same examples with different charts and saw how each type communicates different aspects of the data, revealing correlations, proportions, trends, and hidden patterns.</p>
<p>Each chart was introduced with a simple example, but we also created some real world visualizations using public CSV and JSON data, which needed to be downscaled, combined, filtered, and mapped to data formats expected by Chart.js.</p>
<p>We also experimented with several configuration properties, for graphical elements, datasets, and charts, allowing a high degree of customization. Many of these will be explored in greater detail in the next chapters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<p><strong>Books and websites</strong>:</p>
<ul>
<li>Chart.js official documentation and samples: <a href="https://www.chartjs.org/docs/latest/">https://www.chartjs.org/docs/latest/</a></li>
<li>PieceLabel plugin (<kbd>Chart.PieceLabel.js</kbd>) <a href="https://github.com/emn178/Chart.PieceLabel.js">https://github.com/emn178/Chart.PieceLabel.js</a></li>
</ul>
<p><strong>Data sources</strong>:</p>
<ul>
<li>Mauna Loa CO2 measurements: <kbd>Chapter04/Data/co2_mm_mlo.csv</kbd><em>.</em> Dr. Pieter Tans, NOAA/ESRL (<a href="http://www.esrl.noaa.gov/gmd/ccgg/trends/">www.esrl.noaa.gov/gmd/ccgg/trends/</a>) and Dr. Ralph Keeling, Scripps Institution of Oceanography (<a href="http://scrippsco2.ucsd.edu/">scrippsco2.ucsd.edu/</a>).</li>
<li>Ocean temperatures: <kbd>Chapter04/Data/monthly_json.json</kbd>. GISTEMP Team, <em>2019: GISS Surface Temperature Analysis (GISTEMP)</em>. NASA Goddard Institute for Space Studies. Dataset accessed 2019-02-01 at <a href="https://data.giss.nasa.gov/gistemp/">https://data.giss.nasa.gov/gistemp/</a>. Hansen, J., R. Ruedy, M. Sato, and K. Lo, 2010: Global surface temperature change, Rev. Geophys., 48, RG4004, doi:10.1029/2010RG000345.</li>
<li>Geographical database: <kbd>Chapter02/Data/cities1000.csv</kbd>. GeoNames geographical database: <a href="http://www.geonames.org">www.geonames.org</a>.</li>
<li>CO2 emissions per country in kilotons (1960-2014): <kbd>Chapter04/world_bank_co2_kt.json</kbd>. <em>World bank public data.</em> <a href="https://data.worldbank.org">https://data.worldbank.org</a></li>
<li>World population: <kbd>Chapter04/WPP2017_UN.csv</kbd>. <em>United Nations World Population Prospects 2017</em>. <a href="https://www.un.org">https://www.un.org</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>