<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">E2E Testing in React</h1>
                </header>
            
            <article>
                
<p>For our backend development, we vehemently followed <strong>Test-Driven Development</strong> (<strong>TDD</strong>) <span>–</span> we started development by writing E2E tests, and we wrote some implementation code to make these tests pass. After we implemented this feature, we added unit and integration tests to add more confidence to our underlying code, and also to help catch regression.</p>
<p>Now that we have a basic understanding of React, we will, in this chapter, examine how we can implement TDD in React. Specifically, we will cover:</p>
<ul>
<li>Using <strong>Selenium</strong> to automate interaction with the browser</li>
<li>Working with <strong>React Router</strong> to implement <strong>client-side routing</strong></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing strategies</h1>
                </header>
            
            <article>
                
<p>As it turns out, TDD on the frontend follows a similar approach involving automated UI testing and Unit tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automated UI testing</h1>
                </header>
            
            <article>
                
<p>When we write E2E tests for our API, we first compose our request, send it, and assert that it returns what is expected. In other words, our E2E tests are mimicking how an end user would interact with our API. For the frontend, a user would interact with our application through the user interface (UI). Therefore, the equivalent to E2E testing would be automated UI testing.</p>
<p>UI tests automate the actions that a user of the application would take. For example, if we want to test that an user can register, we'd write a test that:</p>
<ul>
<li>Navigates to the <kbd>/register</kbd> page</li>
<li>Types in the email</li>
<li>Types in the password</li>
<li>Presses the Register button</li>
<li>Asserts that the user is registered</li>
</ul>
<p>These tests can be written in Gherkin and run with Cucumber. The actual mimicking of the user action can automate these using Browser Automation Tools like Selenium. For example, when we run the test step "Press the <span class="packt_screen">Register</span> button", we can instruct Selenium to select the button with the <kbd>id</kbd> value <kbd>register-button</kbd> and trigger a click event on it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>For the frontend, unit testing involves two different aspects—logical units and component units.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logical units</h1>
                </header>
            
            <article>
                
<p>A unit can be a function or class that does not interact with the UI; functions like <kbd>validateInput</kbd> are a prime example. These logical units uses plain JavaScript and should work independently from the environment. Therefore, we can unit test them using Mocha, Chai, and Sinon in the same manner as we did for our backend code.</p>
<p>Because logical units are the easiest to test. You should pull as much of that application logic as possible and test it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Component units</h1>
                </header>
            
            <article>
                
<p>A unit may also refer to a single component in React. For example, we can test that when the input has changed, that the state of the component is updated in an expected way; or for controlled components, that the right callback is called with the correct parameters</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Browser testing</h1>
                </header>
            
            <article>
                
<p>Thanks to headless browsers—browsers that don't render to a display interface—both E2E and unit tests can be run from the server. However, we should also test these unit tests in a real browser, as there might be inconsistencies between NodeJS (which uses the V8 JavaScript Engine), and other browsers like Firefox (which uses the SpiderMonkey engine), Microsoft Edge (which uses the Chakra engine), and Safari (which uses the Nitro engine).</p>
<p>To test on real browsers and devices, we can use a different test runner called <em>Karma</em> (<a href="https://karma-runner.github.io/2.0/index.html">https://karma-runner.github.io/2.0/index.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing E2E tests with Gherkin, Cucumber, and Selenium</h1>
                </header>
            
            <article>
                
<p>Now, we are ready to integrate with tools that can mimic user interaction with a browser. For our first test, let's test something very simple—<span>a</span> user will type in a valid email, but their password is too short. In this case, we want to assert that the Register button will be disabled.</p>
<p>Like our backend E2E tests, we will be writing our test cases in Gherkin, and using Cucumber to run our scenarios. So, let's add these as development dependencies:</p>
<pre><strong>$ yarn add cucumber babel-register --dev</strong></pre>
<p>Then, we need to create feature files and step definition files. For our first scenario, I have opted to group the features and steps in the following structure:</p>
<pre><strong>$ tree --dirsfirst spec</strong><br/><strong>spec</strong><br/><strong>└── cucumber</strong><br/><strong>    ├── features</strong><br/><strong>    │   └── users</strong><br/><strong>    │       └── register</strong><br/><strong>    │           └── main.feature</strong><br/><strong>    └── steps</strong><br/><strong>        ├── assertions</strong><br/><strong>        │   └── index.js</strong><br/><strong>        ├── interactions</strong><br/><strong>        │   ├── input.js</strong><br/><strong>        │   └── navigation.js</strong><br/><strong>        └── index.js</strong></pre>
<div class="mce-root packt_tip">Feel free to group them differently, as long as the features are separated from the step definitions.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding test script</h1>
                </header>
            
            <article>
                
<p>Although we haven't written any tests yet, we can simply copy the test script we wrote for our API and place it in <kbd>scripts/e2e.test.sh</kbd>:</p>
<pre>#!/bin/bash<br/><br/># Set environment variables from .env and set NODE_ENV to test<br/>source &lt;(dotenv-export | sed 's/\\n/\n/g')<br/>export NODE_ENV=test<br/><br/># Run our web server as a background process<br/>yarn run serve &gt; /dev/null 2&gt;&amp;1 &amp;<br/><br/># Polling to see if the server is up and running yet<br/>TRIES=0<br/>RETRY_LIMIT=50<br/>RETRY_INTERVAL=0.2<br/>SERVER_UP=false<br/>while [ $TRIES -lt $RETRY_LIMIT ]; do<br/>  if netstat -tulpn 2&gt;/dev/null | grep -q ":$SERVER_PORT_TEST.*LISTEN"; then<br/>    SERVER_UP=true<br/>    break<br/>  else<br/>    sleep $RETRY_INTERVAL<br/>    let TRIES=TRIES+1<br/>  fi<br/>done<br/><br/># Only run this if API server is operational<br/>if $SERVER_UP; then<br/>  # Run the test in the background<br/>  npx dotenv cucumberjs spec/cucumber/features -- --compiler js:babel-register --require spec/cucumber/steps &amp;<br/><br/>  # Waits for the next job to terminate - this should be the tests<br/>  wait -n<br/>fi</pre>
<pre><br/># Terminate all processes within the same process group by sending a SIGTERM signal<br/>kill -15 0</pre>
<p>The only difference between our script and the backend test script is this line:</p>
<pre><strong>yarn run serve &gt; /dev/null 2&gt;&amp;1 &amp;</strong></pre>
<p>With <kbd>&gt; /dev/null</kbd>, we are directing <kbd>stdout</kbd> into the <em>null device</em> (<kbd>/dev/null</kbd>), which discards anything piped into it. With <kbd>2&gt;&amp;1</kbd>, we are directing <kbd>stderr</kbd> to <kbd>stdout</kbd>, which will end up at <kbd>/dev/null</kbd> eventually. Basically, this line is saying "I don't care about the output of <kbd>yarn run serve</kbd>, just throw it away".</p>
<p>We do this because, as Selenium is navigating between different pages, the output from the <kbd>http-server</kbd> will be sent to <kbd>stdout</kbd> and interspersed between the test results, making it hard to read.</p>
<p>Also, don't forget to install the script's dependencies:</p>
<pre><strong>$ yarn add dotenv-cli --dev</strong></pre>
<p>We also need to create a <kbd>.babelrc</kbd> file to instruct <kbd>babel-register</kbd> to use the <kbd>env</kbd> preset:</p>
<pre>{<br/>  "presets": [<br/>    ["env", {<br/>      "targets": {<br/>        "node": "current"<br/>      }<br/>    }]<br/>  ]<br/>}</pre>
<p>Finally, update the <kbd>package.json</kbd> with the new script:</p>
<pre>"scripts": {<br/>  "build": "rm -rf dist/ &amp;&amp; webpack",<br/>  "serve": "./scripts/serve.sh",<br/>  "test:e2e": "./scripts/e2e.test.sh"<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying a feature</h1>
                </header>
            
            <article>
                
<p>Now, we are ready to define our first feature. In <kbd>spec/cucumber/features/users/reigster/main.feature</kbd>, add the following specification:</p>
<pre>Feature: Register User<br/><br/>  User visits the Registration Page, fills in the form, and submits<br/><br/>  Background: Navigate to the Registration Page<br/><br/>    When user navigates to /<br/><br/>  Scenario: Password Too Short<br/><br/>    When user types in "valid@ema.il" in the "#email" element<br/>    And user types in "shortpw" in the "#password" element<br/>    Then the "#register-button" element should have a "disabled" attribute</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding IDs to elements</h1>
                </header>
            
            <article>
                
<p>We will use Selenium to automate the interaction with the UI elements of our application. However, we must provide some sort of selector for Selenium to select the element we want to interact with. The most precise selector we can have is an <kbd>id</kbd> attribute.</p>
<p>So, before we use Selenium, let's add some ids to our elements. Open <kbd>src/components/registration-form/index.jsx</kbd> and add an <kbd>id</kbd> prop to each element:</p>
<pre>&lt;Input label="Email" type="email" name="email" id="email" ... /&gt;<br/>&lt;Input label="Password" type="password" name="password" id="password" ... /&gt;<br/>&lt;Button title="Register" id="register-button" ... /&gt;</pre>
<p>Then, in <kbd>src/components/input/index.jsx</kbd> and <kbd>src/components/button/index.jsx</kbd>, pass the <kbd>id</kbd> prop into the element as an attribute. For instance, the <kbd>Button</kbd> component would become:</p>
<pre>function Button(props) {<br/>  return &lt;button id={props.id} disabled={props.disabled}&gt;{props.title}&lt;/button&gt;<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selenium</h1>
                </header>
            
            <article>
                
<p>We are now ready to use Selenium. Selenium was written by Jason Huggins in 2004 while working at ThoughtWorks. It is not just a single tool, but a suite of tools, that allows you to automate browsers across multiple platforms. We will be using the JavaScript binding to Selenium WebDriver, but it's beneficial for us to take a quick look at each part of the tool suite:</p>
<ul>
<li>Selenium <strong>Remote Control</strong> (<strong>RC</strong>), also known as Selenium 1.0, is the first tool in the suite that allows you to automate browsers. It works by injecting JavaScript scripts into the browser when the page is first loaded. These scripts would simulate user interaction by clicking on buttons and inputting texts. Selenium RC has been deprecated and is superseded by Selenium WebDriver.</li>
<li>Selenium WebDriver, also known as Selenium 2, is the successor of Selenium RC, and uses the standardized WebDriver API to mimic user interaction. Most browsers have built-in support for the WebDriver API, and so the tool doesn't need to inject scripts onto the page anymore.</li>
<li>Selenium Server allows you to run your tests on a remote machine, such as when using Selenium Grid.</li>
<li>Selenium Grid allows you to distribute your tests over multiple machines or virtual machines (VMs). These tests can then run in parallel. If your test suite is large, and/or you need to run tests on multiple browsers and/or operating systems, then test execution is likely to take a long time. By distributing these tests across multiple machines, you can run them in parallel and reduce the total execution time.</li>
<li>Selenium IDE is a Chrome extension/Firefox plugin that provides a rapid prototyping tool for building test scripts. Essentially, it can record actions a user takes on a page, and exports them as a reusable script in many languages. A developer can then take this script and further customize it to their own needs.</li>
</ul>
<p>For testing our application, we are going to be using Selenium WebDriver.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebDriver API</h1>
                </header>
            
            <article>
                
<p><em>WebDriver</em> is a standardized API that allows you to inspect and control a user agent (for example, a browser or mobile application). It was originally conceived in 2006 by Simon Stewart, a Google engineer at the time. It has now been defined by the World Wide Web Consortium (W3C), and its specification can be found at <a href="https://www.w3.org/TR/webdriver/">https://www.w3.org/TR/webdriver/</a>. The document is currently in the <em>Candidate Recommendation</em> stage.</p>
<p>Instead of injecting JavaScript scripts into the web page and using them to mimic user interaction, Selenium WebDriver uses the WebDriver API, which most browsers support. However, you may see variation in the level of support, as well as how the standard is implemented, between different browsers.</p>
<p>While the API is platform- and language-neutral, there have been many implementations of it. Specifically, we are going to be using the official JavaScript binding, which is available as the "selenium-webdriver" package on NPM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Selenium WebDriver</h1>
                </header>
            
            <article>
                
<p>Let's start by adding the Selenium WebDriver JavaScript package to our project:</p>
<pre><strong>$ yarn add selenium-webdriver --dev</strong></pre>
<p>We will use <kbd>selenium-webdriver</kbd> to define our Step Definitions.</p>
<p>Selenium requires a browser to run tests on. This may be a real browser like Chrome, or a headless browser such a PhantomJS. You're likely familiar with the different real browsers, so let's spend some time taking a look at the headless browsers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Headless browsers</h1>
                </header>
            
            <article>
                
<p>Headless browsers are browsers that do not render the page on an interface. A header browser would fetch the content of the page and then download images, stylesheets, scripts, and so on, and process them just like a real browser.</p>
<p class="mce-root"/>
<p>The benefits of using a headless browser is that it is much faster. This is because the browser doesn't have a Graphical User Interface (GUI), and thus there's no need to wait for the display to actually render the output:</p>
<ul>
<li>PhantomJS (<a href="http://phantomjs.org/">http://phantomjs.org/</a>) uses the WebKit web browser engine, which is the same one that is used by Safari. It is arguably the most popular headless browser today. However, activity on its repository has almost come to a halt since the middle of 2016.</li>
<li>SlimerJS (<a href="https://slimerjs.org/">https://slimerjs.org/</a>) uses the Gecko web browser engine, and SpiderMonkey as the JavaScript engine, which is the same as Firefox. SlimerJS is not a headless browser by default, as it uses the X11 display server on the test machine. However, you can integrate it with <em>Xvfb</em> (short for <em>X virtual framebuffer</em>), which is an in-memory display server that does not require a display. Since Firefox 56, you can also enable headless mode with the <kbd>--headless</kbd> flag.</li>
<li>ZombieJS (<a href="http://zombie.js.org/">http://zombie.js.org/</a>) is a faster implementation of a headless browser because it does not use an actual web browser engine like PhantomJS or SlimerJS. Instead, it uses JSDOM, which is a pure-JavaScript implementation of the DOM and HTML. However, also because of this, the results may not be 100% accurate or as realistic as testing against an actual web browser engine.</li>
<li>HtmlUnit (<a href="http://htmlunit.sourceforge.net/">http://htmlunit.sourceforge.net/</a>) is a "GUI-less browser for Java programs". It uses the Rhino JavaScript engine, which, like Selenium, is written in Java. From experience, HtmlUnit is the quickest headless browser but also the most error-prone. It's ideal for simple static pages that do not involve heavy JavaScript usage.</li>
</ul>
<div class="mce-root packt_tip">There are many more headless browsers out there. Asad Dhamani has curated a list which you can find at <a href="https://github.com/dhamaniasad/HeadlessBrowsers">https://github.com/dhamaniasad/HeadlessBrowsers</a>.</div>
<p>However, purely-headless browsers might be a thing of the past soon, as many "real" browsers now support Headless Mode. The following browsers have Headless Mode support:</p>
<ul>
<li>Chrome 59</li>
<li>Firefox 55 (on Linux) and 56 (on macOS and Windows)</li>
</ul>
<p>For those that don't, we can use Xvfb to substitute for the X11 display server, and run the real browser on a CI server. However, this will lose the performance benefit of running a headless browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Browser drivers</h1>
                </header>
            
            <article>
                
<p>Selenium WebDriver supports many browsers, both real and headless, and each one requires its own driver that implements WebDriver's wire protocol for that specific browser.</p>
<p>For real browsers:</p>
<ul>
<li>Chrome and Chrome on Android uses the ChromeDriver (<a href="https://sites.google.com/a/chromium.org/chromedriver/">https://sites.google.com/a/chromium.org/chromedriver/</a>), which is maintained by the Chromium project itself</li>
<li>Firefox uses the geckodriver (<a href="https://github.com/mozilla/geckodriver/">https://github.com/mozilla/geckodriver/</a>)</li>
<li>Internet Explorer uses the Internet Explorer Driver</li>
<li>Edge uses Microsoft WebDriver (<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</a>)</li>
<li>Safari uses SafariDriver (<a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/">https://webkit.org/blog/6900/webdriver-support-in-safari-10/</a>)</li>
<li>Opera uses Opera Driver</li>
<li>iOS (native, hybrid, or mobile web application) uses ios-driver (<a href="http://ios-driver.github.io/ios-driver/">http://ios-driver.github.io/ios-driver/</a>)</li>
<li>Android (native, hybrid, or mobile web application) uses Selendroid</li>
</ul>
<p>For headless browsers:</p>
<ul>
<li>HtmlUnit uses HtmlUnitDriver (<a href="https://github.com/SeleniumHQ/htmlunit-driver">https://github.com/SeleniumHQ/htmlunit-driver</a>)</li>
<li>PhantomJS uses GhostDriver (<a href="https://github.com/detro/ghostdriver">https://github.com/detro/ghostdriver</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setup and teardown</h1>
                </header>
            
            <article>
                
<p>Before we can run any tests, we must tell Selenium which browser to use. Chrome is, by far, the most popular browser in use today, and so we will start with using ChromeDriver. Let's install it:</p>
<pre><strong>$ yarn add chromedriver --dev</strong></pre>
<p>Now, inside <kbd>spec/cucumber/steps/index.js</kbd>, define <kbd>Before</kbd> and <kbd>After</kbd> hooks which are run before each scenario:</p>
<pre>import { After, Before } from 'cucumber';<br/>import webdriver from 'selenium-webdriver';<br/><br/><br/>Before(function () {<br/>  this.driver = new webdriver.Builder()<br/>    .forBrowser("chrome")<br/>    .build();<br/>  return this.driver;<br/>});<br/><br/>After(function () {<br/>  this.driver.quit();<br/>});</pre>
<p>In the <kbd>Before</kbd> hook, we are creating a new instance of the driver. A driver is akin to an user session, and a session can have many windows opened (just like you can have multiple tabs opened at the same time).</p>
<p>The <kbd>webdriver.Builder</kbd> constructor function returns with an instance that implements the <kbd>ThenableWebDriver</kbd> interface, which allows us to specify parameters for the driver by chaining methods together. Some popular methods include the following:</p>
<ul>
<li><kbd>forBrowser</kbd>: Specify which browser to use.</li>
<li><kbd>withCapabilities</kbd>: Passes parameters to the browser command. Later on, we will use this to run Chrome in Headless Mode.</li>
</ul>
<p>Once the parameters have been set, terminate the chain using the <kbd>build</kbd> method to return an instance of the driver.</p>
<p>In the <kbd>After</kbd> hook, we are disposing the driver using the <kbd>quit</kbd> method. This will close all windows and end the session.</p>
<p>We are storing the driver instance in Cucumber's World (the context) for other steps to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing step definitions</h1>
                </header>
            
            <article>
                
<p>Next, we need to implement the step definitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating to a page</h1>
                </header>
            
            <article>
                
<p>Now that everything is set up, let's implement our first step, which is <kbd>When user navigates to /</kbd>. Navigation can be done using the <kbd>.get</kbd> method on our driver object:</p>
<pre>import { Given, When, Then } from 'cucumber';<br/><br/>When(/^user navigates to ([\w-_\/?=:#]+)$/, function (location) {<br/>  return this.driver.get(`http://${process.env.SERVER_HOST_TEST}:${process.env.SERVER_PORT_TEST}${location}`);<br/>});</pre>
<p>This step takes the server host and port from the environment variables. <kbd>this.driver.get</kbd> returns a promise which is returned. Cucumber will wait for this promise to be resolved or rejected before moving on to the next step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Typing into input</h1>
                </header>
            
            <article>
                
<p>This is our next step:</p>
<pre>When user types in "valid@ema.il" in the "#email" element</pre>
<p>This involves finding the element with the <kbd>id</kbd> of <kbd>email</kbd>, and then sending keystroke events to it. In <kbd>spec/cucumber/steps/interactions/input.js</kbd>, add the following step definition:</p>
<pre>import { Given, When, Then } from 'cucumber';<br/>import { By } from 'selenium-webdriver';<br/><br/>When(/^user types in (?:"|')(.+)(?:"|') in the (?:"|')([\.#\w]+)(?:"|') element$/, async function (text, selector) {<br/>  this.element = await this.driver.findElement(By.css(selector));<br/>  return this.element.sendKeys(text);<br/>});</pre>
<p class="mce-root"/>
<p>Here, <kbd>driver.findElement</kbd> returns an instance of <kbd>WebElementPromise</kbd>. We are using the <kbd>async</kbd>/<kbd>await</kbd> syntax to avoid callback hell or heavily chained promises. The same step definition would work for our next step, which types in a short password into the <kbd>#password</kbd> input element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asserting a result</h1>
                </header>
            
            <article>
                
<p>The last step is to do the following:</p>
<pre>Then the "#register-button" element should have a "disabled" attribute</pre>
<p>As before, we need to find the element, but this time read its <kbd>disabled</kbd> attribute and assert that it is set to <kbd>"true"</kbd>.</p>
<div class="mce-root packt_infobox">The HTML <em>content</em> attribute will always be a string, even when you'd expect a boolean or number.</div>
<p>In <kbd>spec/cucumber/steps/assertions/index.js</kbd>, add the following:</p>
<pre>import assert from 'assert';<br/>import { Given, When, Then } from 'cucumber';<br/>import { By } from 'selenium-webdriver';<br/><br/>When(/^the (?:"|')([\.#\w-]+)(?:"|') element should have a (?:"|')([\w_-]+)(?:"|') attribute$/, async function (selector, attributeName) {<br/>  const element = await this.driver.findElement(By.css(selector));<br/>  const attributeValue = await element.getAttribute(attributeName);<br/>  assert.equal(attributeValue, 'true');<br/>});</pre>
<p>Here, we use the <kbd>getAttribute</kbd> method from the <kbd>WebElement</kbd> instance to get the value of the <kbd>disabled</kbd> attribute. Again, this is an asynchronous operation, so we are using <kbd>async</kbd>/<kbd>await</kbd> syntax to keep things neat.</p>
<div class="mce-root packt_tip">If you have time, it's always a good idea to read the official documentation. The API of all classes and methods from <kbd>selenium-webdriver</kbd> can be found at <a href="https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/">https://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the tests</h1>
                </header>
            
            <article>
                
<p>Now, we are ready to run the tests:</p>
<pre><strong>$ yarn run test:e2e</strong></pre>
<p>This will run the <kbd>./scripts/e2e.test.sh</kbd> script, which will build the project using Webpack (this may take some time). Then, a Google Chrome browser will pop up, and you'll see the input fields being automatically populated with the text we specified. After Selenium has performed all actions required, the <kbd>driver.quit()</kbd> method call in our After hook will close the browser, and the results will be displayed in our terminal.:</p>
<pre>......<br/><br/>1 scenario (1 passed)<br/>4 steps (4 passed)<br/>0m02.663s</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding multiple testing browsers</h1>
                </header>
            
            <article>
                
<p>The biggest benefit of using Selenium is that you can use the same tests to test multiple browsers. If we are interested in just a single browser, like Chrome, we'd be better off using Puppeteer. So, let's add Firefox to our tests.</p>
<p>Firefox, like Chrome, requires a driver to work. Firefox's driver is <kbd>geckodriver</kbd>, which uses the <em>Marionette</em> proxy to send instructions to Firefox (<span>Marionette is similar to Chrome's DevTools Pro</span>tocol):</p>
<pre><strong>$ yarn add geckodriver --dev</strong></pre>
<p>Now, all we need to do is change the <kbd>forBrowser</kbd> call to use <kbd>"firefox"</kbd>:</p>
<pre>this.driver = new webdriver.Builder()<br/>  .forBrowser("firefox")<br/>  .build();</pre>
<p>When we run our tests again, Firefox will be used instead of Chrome.</p>
<p>However, instead of hard-coding the browser into our code, let's update our scripts to allow us to specify the browsers we want to test. We can do this by passing arguments into the shell script. For instance, if we execute the following:</p>
<pre><strong>$ yarn run test:e2e -- chrome firefox</strong></pre>
<p>Then, in our <kbd>scripts/e2e.test.sh</kbd>, we can access the arguments using <kbd>$1</kbd> for the first argument (<kbd>chrome</kbd>), <kbd>$2</kbd> for <kbd>firefox</kbd>, and so on. Alternatively, we can use the special argument <kbd>"$@"</kbd>, which is an array-like construct that contains all arguments. In <kbd>scripts/e2e.test.sh</kbd>, change the test block to the following:</p>
<pre>if $SERVER_UP; then<br/>  for browser in "$@"; do<br/>    export TEST_BROWSER="$browser"<br/>    echo -e "\n---------- $TEST_BROWSER test start ----------"<br/>    npx dotenv cucumberjs spec/cucumber/features -- --compiler js:babel-register --require spec/cucumber/steps<br/>    echo -e "----------- $TEST_BROWSER test end -----------\n"<br/>  done<br/>else<br/>  &gt;&amp;2 echo "Web server failed to start"<br/>fi</pre>
<p>This will loop through our list of browsers, <kbd>export</kbd> it in the <kbd>TEST_BROWSER</kbd> variable, and run our tests. Then, in the <kbd>forBrowser</kbd> call inside <kbd>spec/cucumber/steps/index.js</kbd>, pass in the browser name from <kbd>process.env</kbd> instead of hard-coding it:</p>
<pre>this.driver = new webdriver.Builder()<br/>  .forBrowser(process.env.TEST_BROWSER || "chrome")<br/>  .build();</pre>
<p>Now, try running it with <kbd>$ yarn run test:e2e -- chrome firefox</kbd>, and you should see our tests being run first on Chrome, and then Firefox, and then the results neatly displayed in a standard output:</p>
<pre><strong>$ yarn run test:e2e</strong><br/><br/><strong>---------- chrome test start ----------</strong><br/><strong>......</strong><br/><br/><strong>1 scenario (1 passed)</strong><br/><strong>4 steps (4 passed)</strong><br/><strong>0m01.899s</strong><br/><strong>----------- chrome test end -----------</strong><br/><br/><strong>---------- firefox test start ----------</strong><br/><strong>......</strong><br/><br/><strong>1 scenario (1 passed)</strong><br/><strong>4 steps (4 passed)</strong><br/><strong>0m03.258s</strong><br/><strong>----------- firefox test end -----------</strong></pre>
<p>Lastly, we should define NPM scripts to make it obvious to other developers what operations we can run. By adding it as an NPM script, all the user needs to do is look at the <kbd>package.json</kbd>, and won't have to study the shell script to see how it works. So, in the <kbd>scripts</kbd> section of the <kbd>package.json</kbd>, change our <kbd>test:e2e</kbd> to the following:</p>
<pre>"test:e2e": "yarn run test:e2e:all",<br/>"test:e2e:all": "yarn run test:e2e:chrome firefox",<br/>"test:e2e:chrome": "./scripts/e2e.test.sh chrome",<br/>"test:e2e:firefox": "./scripts/e2e.test.sh firefox"</pre>
<p>We have now successfully written our first test and run it. Next, let's make our scenario more generic by covering all the invalid cases:</p>
<pre>Scenario Outline: Invalid Input<br/><br/>  Tests that the 'Register' button is disabled when either input elements contain invalid values<br/><br/>  When user types in "&lt;email&gt;" in the "#email" element<br/>  And user types in "&lt;password&gt;" in the "#password" element<br/>  Then the "#register-button" element should have a "disabled" attribute<br/><br/>Examples:<br/><br/>| testCase       | email         | password       |<br/>| Both Invalid   | invalid-email | shortpw        |<br/>| Invalid Email  | invalid-email | abcd1234qwerty |<br/>| Short Password | valid@ema.il  | shortpw        |</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our backend API</h1>
                </header>
            
            <article>
                
<p>Next, we need to cater for the happy path scenario where a user fills in valid details and the Register button is clicked.</p>
<p>Here, we will write a test that says "When a user submits valid details, after the server response is received, the UI will display a success message". This feature has not been implemented yet, which means this would be our first step toward TDD in frontend!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic string substitution with Webpack</h1>
                </header>
            
            <article>
                
<p>There's one minor improvement we must make before we can do E2E testing with the API backend. At the moment, we are hard-coding the URL for our production API endpoint (<kbd>localhost:8080</kbd>), even though during the test, the testing URL (<kbd>localhost:8888</kbd>) will be used. Therefore, we need to replace this with a placeholder that we can override during build time.</p>
<p>First, in <kbd>src/components/registration-form/index.jsx</kbd>, replace the following line:</p>
<pre>const request = new Request('http://localhost:8080/users/', {})</pre>
<p>With this one:</p>
<pre>const request = new Request('http://%%API_SERVER_HOST%%:%%API_SERVER_PORT%%/users/', {})</pre>
<div class="mce-root packt_infobox">We are using <kbd>%%</kbd> to mark our placeholder because it's a relatively uncommon sequence of characters. You may choose any placeholder syntax you like.</div>
<p>Next, we need to add a new loader to replace this placeholder at build time. <kbd>string-replace-loader</kbd> fits the bill perfectly. Let's install it:</p>
<pre>yarn add string-replace-loader --dev</pre>
<p>Then, in <kbd>.env</kbd> and <kbd>.env.example</kbd>, add the details of the API host and port for different environment:</p>
<pre>API_SERVER_PORT_TEST=8888<br/> API_SERVER_HOST_TEST=localhost<br/> API_SERVER_PORT_PROD=8080<br/> API_SERVER_HOST_PROD=localhost</pre>
<p>Then, use the plugin inside <kbd>webpack.config.js</kbd>. We want the loader to transform all <kbd>.js</kbd> and <kbd>.jsx</kbd> files, and so we can use the same rules that we used for <kbd>babel-loader</kbd>:</p>
<pre>...<br/><br/>if (process.env.NODE_ENV === 'test') {<br/>  process.env.API_SERVER_HOST = process.env.API_SERVER_HOST_TEST;<br/>  process.env.API_SERVER_PORT = process.env.API_SERVER_PORT_TEST;<br/>} else {<br/>  process.env.API_SERVER_HOST = process.env.API_SERVER_HOST_PROD;<br/>  process.env.API_SERVER_PORT = process.env.API_SERVER_PORT_PROD;<br/>}<br/><br/>module.exports = { <br/>  entry: { ... },<br/>  output: { ... },<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.jsx?$/,<br/>        exclude: /node_modules/,<br/>        use: [<br/>          {<br/>            loader: "babel-loader",<br/>            options: { ... }<br/>          },<br/>          {<br/>            loader: 'string-replace-loader',<br/>            options: {<br/>              multiple: [<br/>                 { search: '%%API_SERVER_HOST%%', replace: process.env.API_SERVER_HOST, flags: 'g' },<br/>                 { search: '%%API_SERVER_PORT%%', replace: process.env.API_SERVER_PORT, flags: 'g' }<br/>              ]<br/>            }<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  },<br/>  plugins: [...]<br/>};</pre>
<p>At the top, we are checking the <kbd>NODE_ENV</kbd> environment variable and using it to determine which port the API is using. Then, in the options for our loader, we are instructing it to do a global RegEx search for the string, and replacing it with the dynamically-derived host and port.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serving the API from a submodule</h1>
                </header>
            
            <article>
                
<p>When we run our tests, we want to make sure that our backend API is running using the <kbd>NODE_ENV</kbd> environment variable set to <kbd>test</kbd>. At the moment, we are doing this manually. However, it's more ideal to add it as part of our test script. Just as we did for our Swagger UI, we can use Git submodules to include the Hobnob API repository in the client's repository without duplicating the code:</p>
<pre>git submodule add git@github.com:d4nyll/hobnob.git api</pre>
<p>Now, to make life easier for later, add the following NPM scripts to <kbd>package.json</kbd>:</p>
<pre>"api:init": "git submodule update --init",<br/>"api:install": "yarn install --cwd api",<br/>"api:serve": "yarn --cwd api run build &amp;&amp; dotenv -e api/.env.example node api/dist/index.js",<br/>"api:update": "git submodule update --init --remote",</pre>
<p><kbd>api:init</kbd> will download the Hobnob API repository using the commit hash that's been stored. <kbd>api:install</kbd> uses <kbd>--cwd</kbd> to change directory into the <kbd>api</kbd> directory before running <kbd>yarn install</kbd>. <kbd>api:serve</kbd> first runs the <kbd>build</kbd> script from our API repository, loads the environment variables, and then runs the API server. <kbd>api:update</kbd> will download but also update the API repository to the latest commit in the same branch.</p>
<p>Lastly, run the NPM scripts inside <kbd>scripts/e2e.test.sh</kbd>:</p>
<pre>...<br/>export NODE_ENV=test<br/><br/>yarn run api:init &gt; /dev/null 2&gt;&amp;1 &amp;<br/>yarn run api:install &gt; /dev/null 2&gt;&amp;1 &amp;<br/>yarn run api:serve &gt; /dev/null 2&gt;&amp;1 &amp;<br/><br/>yarn run serve &gt; /dev/null 2&gt;&amp;1 &amp;<br/>...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the happy scenario</h1>
                </header>
            
            <article>
                
<p>Let's begin defining our happy scenario by writing the feature file:</p>
<pre>Scenario: Valid Input<br/><br/>  Tests that the 'Register' button is enabled when valid values are provided, and that upon successful registration, the UI display will display the message "You've been registered successfully"<br/><br/>  When user types in a valid email in the "#email" element<br/>  And user types in a valid password in the "#password" element<br/>  Then the "#register-button" element should not have a "disabled" attribute<br/><br/>  When user clicks on the "#register-button" element<br/>  Then the "#registration-success" element should appear within 2000 milliseconds</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating random data</h1>
                </header>
            
            <article>
                
<p>In this scenario, we cannot hard-code a single email to test because it may lead to a <kbd>409 Conflict</kbd> error because an account with that email already exists. Therefore, we need to generate a random email each time the test is run. We need to define a new step definition where the data is randomly generated each time:</p>
<pre>When(/^user types in an? (in)?valid (\w+) in the (?:"|')([\.#\w-]+)(?:"|') element$/, async function (invalid, type, selector) {<br/>  const textToInput = generateSampleData(type, !invalid);<br/>  this.element = await this.driver.findElement(By.css(selector));<br/>  return this.element.sendKeys(textToInput);<br/>});</pre>
<p>Here, we create a generic step definition and use the yet-to-be-defined <kbd>generateSampleData</kbd> function to provide the random data. We will define the <kbd>generateSampleData</kbd> function in a new file at <kbd>spec/cucumber/steps/utils/index.js</kbd> and, just as we did for in our backend tests, use the <kbd>chance</kbd> package to generate the random data.</p>
<p>First, install the <kbd>chance</kbd> package:</p>
<pre>$ yarn add chance --dev</pre>
<p>And then define <kbd>generateSampleData</kbd> as follows:</p>
<pre>import Chance from 'chance';<br/>const chance = new Chance();<br/><br/>function generateSampleData (type, valid = true) {<br/>  switch (type) {<br/>    case 'email':<br/>      return valid ? chance.email() : chance.string()<br/>      break;<br/>    case 'password':<br/>      return valid ? chance.string({ length: 13 }) : chance.string({ length: 5 });<br/>      break;<br/>    default:<br/>      throw new Error('Unsupported data type')<br/>      break;<br/>  }<br/>}<br/><br/>export {<br/>  generateSampleData,<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making step definitions more generic</h1>
                </header>
            
            <article>
                
<p>This scenario checks the <kbd>disabled</kbd> attribute as before, but this time testing that it is <em>not</em> set. Therefore, update our step definition at <kbd>spec/cucumber/steps/assertions/index.js</kbd> to take this into account:</p>
<pre>When(/^the (?:"|')([\.#\w-]+)(?:"|') element should( not)? have a (?:"|')([\w_-]+)(?:"|') attribute$/, async function (selector, negation, attributeName) {<br/>  const element = await this.driver.findElement(By.css(selector));<br/>  const attributeValue = await element.getAttribute(attributeName);<br/>  const expectedValue = negation ? null : 'true';<br/>  assert.equal(attributeValue, expectedValue);<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clicking</h1>
                </header>
            
            <article>
                
<p>The final two step sees the WebDriver clicking on the Register button and waiting for the server to respond. For the click step, we just need to find the <kbd>WebElement</kbd> instance and invoke its <kbd>click</kbd> method. Define the following step definition at <kbd>spec/cucumber/steps/interactions/element.js</kbd>:</p>
<pre>import { Given, When, Then } from 'cucumber';<br/>import { By } from 'selenium-webdriver';<br/><br/>When(/^user clicks on the (?:"|')([\.#\w-]+)(?:"|') element$/, async function (selector) {<br/>  const element = await this.driver.findElement(By.css(selector));<br/>  return element.click();<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Waiting</h1>
                </header>
            
            <article>
                
<p>The last step requires us to wait for the API server to respond to our request, after which we should display a success message.</p>
<p>A naive, but very common, approach would be to wait a few seconds before making an assertion. However, this has two disadvantages:</p>
<ul>
<li>If the time set is too short, it can lead to flaky tests where the tests would pass on some instances, and fail on others.</li>
<li>If the time set is too long, it'll lengthen the test duration. In practice, lengthy tests means the tests are ran less often, and less useful in providing feedback to the developer.</li>
</ul>
<p>Luckily, Selenium provides the <kbd>driver.wait</kbd> method, which has the following signature:</p>
<pre>driver.wait(&lt;condition&gt;, &lt;timeout&gt;, &lt;message&gt;)</pre>
<p><kbd>condition</kbd> can be a <kbd>Condition</kbd> instance, a function, or a promise-like thenable. <kbd>driver.wait</kbd> will repeatedly evaluate the value of <kbd>condition</kbd> until it returns a truthy value. If <kbd>condition</kbd> is a promise, it will wait until the promise is resolved and check the resolved value to see if it is truthy. <kbd>timeout</kbd> is the time (in milliseconds) for which <kbd>driver.wait</kbd> will keep trying.</p>
<p>In <kbd>spec/cucumber/steps/assertions/index.js</kbd>, add the following step definition:</p>
<pre>import chai, { expect } from 'chai';<br/>import chaiAsPromised from 'chai-as-promised';<br/>import { By, until } from 'selenium-webdriver';<br/><br/>chai.use(chaiAsPromised);<br/><br/>Then(/^the (?:"|')([\.#\w-]+)(?:"|') element should appear within (\d+) milliseconds$/, function (selector, timeout) {<br/>  return expect(this.driver.wait(until.elementLocated(By.css(selector)), timeout)).to.be.fulfilled;<br/>});</pre>
<p>We are using <kbd>until.elementLocated</kbd> as the condition, which will resolve to a truthy value if the element is located. We are also using <kbd>chai</kbd> and <kbd>chai-as-promised</kbd> as our assertion library (instead of <kbd>assert</kbd>); they provide us with the <kbd>expect</kbd> and <kbd>.to.be.fulfilled</kbd> syntax which makes tests involving promises much more readable.</p>
<p>Run the tests, and the last step should fail. This is because we haven't implemented the <kbd>#registration-success</kbd> element yet:</p>
<pre>---------- firefox test start ----------<br/>........................F.<br/><br/>Failures:<br/><br/>1) Scenario: Valid Input # spec/cucumber/features/users/register/main.feature:24<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.33em;height:1.00em;"/> Before # spec/cucumber/steps/index.js:5<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.50em;height:1.08em;"/> When user navigates to / # spec/cucumber/steps/interactions/navigation.js:3<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.33em;height:1.00em;"/> When user types in a valid email in the "#email" element # spec/cucumber/steps/interactions/input.js:10<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.50em;height:1.08em;"/> And user types in a valid password in the "#password" element # spec/cucumber/steps/interactions/input.js:10<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.50em;height:1.08em;"/> Then the "#register-button" element should not have a "disabled" attribute # spec/cucumber/steps/assertions/index.js:9<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.50em;height:1.08em;"/> When user clicks on the "#register-button" element # spec/cucumber/steps/interactions/element.js:4<br/>   <img src="assets/385a3fa7-f59a-4d46-b23f-3604cdfcf8b9.png" style="width:1.25em;height:1.25em;"/> Then the "#registration-success" element should appear within 2000 milliseconds # spec/cucumber/steps/assertions/index.js:16<br/>       AssertionError: expected promise to be fulfilled but it was rejected with 'TimeoutError: Waiting for element to be located By(css selector, #registration-success)\nWait timed out after 2002ms'<br/>   <img src="assets/10013332-a237-42e2-bf30-5e597918bac4.png" style="width:1.25em;height:0.92em;"/> After # spec/cucumber/steps/index.js:12<br/><br/>4 scenarios (1 failed, 3 passed)<br/>18 steps (1 failed, 17 passed)<br/>0m10.403s<br/>----------- firefox test end -----------</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Render components based on state</h1>
                </header>
            
            <article>
                
<p>To be able to display the <kbd>#registration-success</kbd> element at the opportune time, we must store the results of our request in our state. Currently, inside our <kbd>RegistrationForm</kbd> component, we are only logging the results onto the console:</p>
<pre>fetch(request)<br/>  .then(response =&gt; {<br/>    if (response.status === 201) {<br/>      return response.text();<br/>    } else {<br/>      throw new Error('Error creating new user');<br/>    }<br/>  })<br/>  .then(console.log)<br/>  .catch(console.log)</pre>
<p>Instead, when the server responds with the new user's ID, we store it inside the state under the <kbd>userId</kbd> property:</p>
<pre>fetch(request)<br/>  .then(response =&gt; { ... })<br/>  .then(userId =&gt; this.setState({ userId }))<br/>  .catch(console.error)</pre>
<p>Also, make sure that you are setting the initial state of the <kbd>userId</kbd> to <kbd>null</kbd> in the class' constructor:</p>
<pre>constructor(props) {<br/>  super(props);<br/>  this.state = {<br/>    userId: null,<br/>    ...<br/>  };<br/>}</pre>
<p>Then, in our <kbd>render</kbd> method, check whether the <kbd>userId</kbd> state is truthy, and if so, display an element with an ID of <kbd>registration-success</kbd> instead of the form:</p>
<pre>render() {<br/>  if(this.state.userId) {<br/>    return &lt;div id="registration-success"&gt;You have registered successfully&lt;/div&gt;<br/>  }<br/>  ...<br/>}</pre>
<p class="mce-root"/>
<p>Run our tests again, and they should, once again, pass!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Routing with React Router</h1>
                </header>
            
            <article>
                
<p>Next, we will develop the Login page. This requires us to use a different path for each page. For instance, the Register page can be served under the path <kbd>/register</kbd>, and the Login page under the <kbd>/login</kbd> path. For this, we need a <em>router</em>. On the server, we use Express to route the request hitting our API; for the frontend, we need a client-side router to do the same. In the React ecosystem, the most mature router is <em>React Router</em>. Let's install it:</p>
<pre><strong>$ yarn add react-router react-router-dom</strong></pre>
<p><kbd>react-router</kbd> provides the core functionality, and <kbd>react-router-dom</kbd> allows us to use the React Router on the web. It's similar to how React on the web is split into <kbd>react</kbd> and <kbd>react-dom</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basics</h1>
                </header>
            
            <article>
                
<p>As explained previously, everything in React is a component. React Router is no different. React Router provides a set of <em>navigational components</em> that'll collect data from the URL, viewport, and device information, in order to display the appropriate component.</p>
<p>There are three types of components in React Router:</p>
<ul>
<li>Router components</li>
<li>Route matching components</li>
<li>Navigation components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Router</h1>
                </header>
            
            <article>
                
<p>A router component is a wrapper around our application. The router component is responsible for keeping a history of the routes, so that you can "Go back" to the previous screen. There are two router components <span>–</span> <kbd>&lt;BrowserRouter&gt;</kbd> and <kbd>&lt;HashRouter&gt;</kbd>. <kbd>&lt;HashRouter&gt;</kbd> is purely used for serving static files; therefore, we'll use the <kbd>&lt;BrowserRouter&gt;</kbd> component.</p>
<p>In <kbd>src/index.jsx</kbd>, wrap our root component (currently <kbd>&lt;RegistrationForm /&gt;</kbd>) with our <kbd>BrowserRouter</kbd> component:</p>
<pre>import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import { BrowserRouter } from 'react-router-dom';<br/>import RegistrationForm from './components/registration-form/index.jsx';<br/><br/>ReactDOM.render((<br/>  &lt;BrowserRouter&gt;<br/>    &lt;RegistrationForm /&gt;<br/>  &lt;/BrowserRouter&gt;<br/>), document.getElementById('renderTarget'));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Route matching</h1>
                </header>
            
            <article>
                
<p>At the moment, if you serve the application, nothing would have changed <span>–</span> we've simply wrapped our app in <kbd>BrowserRouter</kbd> so that <em>inside</em> <kbd>&lt;BrowserRouter&gt;</kbd> we can define <em>route matching</em> components. Let's suppose we want the <kbd>&lt;RegistrationForm&gt;</kbd> component to only render when the route is <kbd>/register</kbd>, we can use a <kbd>&lt;Route&gt;</kbd> component:</p>
<pre>...<br/>import { BrowserRouter, Route } from 'react-router-dom';<br/><br/>ReactDOM.render((<br/>  &lt;BrowserRouter&gt;<br/>    &lt;Route exact path="/register" component={RegistrationForm} /&gt;<br/>  &lt;/BrowserRouter&gt;<br/>), document.getElementById('renderTarget'));</pre>
<p>The <kbd>&lt;Route&gt;</kbd> component usually uses two props <span>–</span> <kbd>path</kbd> and <kbd>component</kbd>. If a <kbd>&lt;Route&gt;</kbd> component has a <kbd>path</kbd> prop that matches the current URL's path name (such as <kbd>window.location.pathname</kbd>), the component specified in the <kbd>component prop</kbd> will be rendered.</p>
<p>Matching is done in an <em>inclusive</em> fashion. For instance, the pathnames <kbd>/register/user</kbd>, <kbd>/register/admin</kbd>, and <kbd>register</kbd> will all match the path <kbd>/register</kbd>. However, for our use case, we want this element to show only if the path matches exactly, and so we are using the <kbd>exact</kbd> prop.</p>
<p>After making the change, let's serve the application again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting the History API</h1>
                </header>
            
            <article>
                
<p>But when we go to <kbd>http://localhost:8200/register</kbd>, we get a <kbd>404 Not Found</kbd> response. From the terminal, we can see that this is because the request is handled by <kbd>http-server</kbd>, and not by our application:</p>
<pre>"GET /register" "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36"<br/>"GET /register" Error (404): "Not found"</pre>
<p>This makes sense because <kbd>http-server</kbd> is a very simple <em>static</em> server, whereas we want our routing done <em>dynamically</em> on the client. Therefore, we need to a use a server that supports this. <kbd>pushstate-server</kbd> is a static server that also works with HTML5 History API. Let's install it:</p>
<pre><strong>$ yarn add pushstate-server --dev</strong></pre>
<p>Now, in <kbd>scripts/serve.sh</kbd>, replace the <kbd>http-server</kbd> line with the following:</p>
<pre>pushstate-server dist/ $WEB_SERVER_PORT_TEST</pre>
<p>When we run <kbd>yarn run serve</kbd> and navigate to <kbd>localhost:8200/register</kbd>, everything works as expected!</p>
<p>Lastly, update our Cucumber test feature file so that the test navigates to the correct page:</p>
<pre>- When user navigates to /<br/> + When user navigates to /register</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigation</h1>
                </header>
            
            <article>
                
<p>The last important component classes provided by React Router are the navigational components, of which there are three types:</p>
<ul>
<li><kbd>&lt;Link&gt;</kbd>: This will render an anchor (<kbd>&lt;a&gt;</kbd>) component, for example, <kbd>&lt;Link to='/'&gt;Home&lt;/Link&gt;</kbd></li>
<li><kbd>&lt;NavLink&gt;</kbd>: This is a special type of <kbd>&lt;Link&gt;</kbd> that will add a class to the element if the pathname matches the <kbd>to</kbd> prop, for example, <kbd>&lt;NavLink to='/profile' activeClassName='active'&gt;Profile&lt;/NavLink&gt;</kbd></li>
<li><kbd>&lt;Redirect&gt;</kbd>: This is a component that will navigate to the <kbd>to</kbd> prop, for example, <kbd>&lt;Redirect to='/login'/&gt;</kbd></li>
</ul>
<p>Therefore, we can update our <kbd>#registration-success</kbd> element to include links to the Home and Login page (which we haven't implemented yet!):</p>
<pre>import { Link } from 'react-router-dom';<br/><br/>...<br/>class RegistrationForm extends React.Component {<br/>  render() {<br/>    ...<br/>    &lt;div id="registration-success"&gt;<br/>      &lt;h1&gt;You have registered successfully!&lt;/h1&gt;<br/>      &lt;p&gt;Where do you want to go next?&lt;/p&gt;<br/>      &lt;Link to='/'&gt;&lt;Button title="Home"&gt;&lt;/Button&gt;&lt;/Link&gt;<br/>      &lt;Link to='/login'&gt;&lt;Button title="Login"&gt;&lt;/Button&gt;&lt;/Link&gt;<br/>    &lt;/div&gt;<br/>  }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TDD</h1>
                </header>
            
            <article>
                
<p>When we developed the Register page, we implemented the features before writing the test. We did this because we didn't know how E2E tests work with React. Now that we do, it's time to implement a proper TDD process.</p>
<p>To implement TDD, we should look at the design of the UI, identify key elements that our tests would need interact with, and assign each of them an unique <kbd>id</kbd>. These ids then form the contract between our tests and the implementation.</p>
<p>For instance, if we developed our Registration Page using TDD, we would first assign the inputs to the IDs <kbd>#email</kbd>, <kbd>#password</kbd>, and <kbd>#register-button</kbd>, and write our test code using these IDs to select the element. Then, when we implement the feature, we will make sure to use the same IDs as specified in the test.</p>
<p>By using an <kbd>id</kbd> field, we can change the implementation details but leave the tests untouched. Imagine if we used a different selector, say, <kbd>form &gt; input[name="email"]</kbd>; then, if we add an inner wrapper within the <kbd>&lt;form&gt;</kbd> element, we'd have to update our tests.</p>
<p class="mce-root"/>
<p>Design and frontend is one of the most volatile endeavors in the software development stage; it's wise to write tests that can withstand this volatility. It's not uncommon for a project to change frameworks completely. Let's say in a few years time, another frontend framework came along and totally revolutionizes the frontend landscape. By using ids to select elements, we can switch our implementation to this new framework without having to rewrite our tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Login</h1>
                </header>
            
            <article>
                
<p><span>We will follow a TDD process when developing the Login page.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests</h1>
                </header>
            
            <article>
                
<p>This means starting with composing the Cucumber features file.</p>
<pre>Feature: Login User<br/><br/>  User visits the Login Page, fills in the form, and submits<br/><br/>  Background: Navigate to the Login Page<br/><br/>    When user navigates to /login<br/><br/>  Scenario Outline: Invalid Input<br/><br/>    Tests that the 'Login' button is disabled when either input elements contain invalid values<br/><br/>    When user types in "&lt;email&gt;" in the "#email" element<br/>    And user types in "&lt;password&gt;" in the "#password" element<br/>    Then the "#login-button" element should have a "disabled" attribute<br/><br/>  Examples:<br/><br/>  | testCase | email | password |<br/>  | Both Invalid | invalid-email | shortpw |<br/>  | Invalid Email | invalid-email | abcd1234qwerty |<br/>  | Short Password | valid@ema.il | shortpw |<br/><br/>  Scenario: Valid Input<br/><br/>    Tests that the 'Login' button is enabled when valid values are provided, and that upon successful login, the UI display will display the message "You've been logged in successfully"<br/><br/>    When a random user is registered<br/>    And user types in his/her email in the "#email" element<br/>    And user types in his/her password in the "#password" element<br/>    Then the "#login-button" element should not have a "disabled" attribute<br/><br/>    When user clicks on the "#login-button" element<br/>    Then the "#login-success" element should appear within 2000 milliseconds</pre>
<p>This introduces several new steps. The <kbd>When a random user is registered</kbd> step directly calls the API to register a user. We will use this user to test our login step. It is implemented inside a new module called <kbd>spec/cucumber/steps/auth/index.js</kbd>:</p>
<pre>import chai, { expect } from 'chai';<br/>import chaiAsPromised from 'chai-as-promised';<br/>import { Given, When, Then } from 'cucumber';<br/>import { By, until } from 'selenium-webdriver';<br/>import bcrypt from 'bcryptjs';<br/>import fetch, { Request } from 'node-fetch';<br/>import { generateSampleData } from '../utils';<br/><br/>chai.use(chaiAsPromised);<br/><br/>Then(/^a random user is registered$/, function () {<br/><br/>  this.email = generateSampleData('email');<br/>  this.password = generateSampleData('password');<br/>  this.digest = bcrypt.hashSync(this.password, 10);<br/><br/>  const payload = {<br/>    email: this.email,<br/>    digest: this.digest<br/>  };<br/><br/>  const request = new Request(`http://${process.env.API_SERVER_HOST_TEST}:${process.env.API_SERVER_PORT_TEST}/users/`, {<br/>    method: 'POST',<br/>    headers: { 'Content-Type': 'application/json' },<br/>    mode: 'cors',<br/>    body: JSON.stringify(payload)<br/>  })<br/>  return fetch(request)<br/>    .then(response =&gt; {<br/>      if (response.status === 201) {<br/>        this.userId = response.text();<br/>      } else {<br/>        throw new Error('Error creating new user');<br/>      }<br/>    })<br/>});</pre>
<p>We are using the <kbd>generateSampleData</kbd> utility function we defined earlier to generate details for a new user. We are also storing these details within the context. Next, we use the Fetch API to send a Create User request to the API. However, the Fetch API is an API native to the browser. Therefore, in order to use the Fetch API in Node, we must install a polyfill, <kbd>node-fetch</kbd>:</p>
<pre><strong>$ yarn add node-fetch --dev</strong></pre>
<p>Then, for the steps <kbd>And user types in his/her email in the "#email" element</kbd> and <kbd>And user types in his/her password in the "#password" element</kbd>, we are using the details stored in the context to fill out the Login form and submit it. If the request is successful, an element with an ID of <kbd>login-success</kbd> is expected to appear.</p>
<div class="mce-root packt_tip">If you forget the endpoint and parameters for any of the endpoints for the API, just refer to the Swagger Documentation, which you can serve by running <kbd>yarn run docs:serve</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing Login</h1>
                </header>
            
            <article>
                
<p>Implementing the Login form is similar to the Register form, however, it involves two steps instead of one. The client must first retrieve the salt from the API, use it to hash the password, and then send a second request to the API to log in. Your implementation may look like this:</p>
<pre>import React from 'react';<br/>import bcrypt from 'bcryptjs';<br/>import { validator } from '../../utils';<br/>import Button from '../button/index.jsx';<br/>import Input from '../input/index.jsx';<br/><br/>function retrieveSalt (email) {<br/>  const url = new URL('http://%%API_SERVER_HOST%%:%%API_SERVER_PORT%%/salt/');<br/>  url.search = new URLSearchParams({ email });<br/><br/>  const request = new Request(url, {<br/>    method: 'GET',<br/>    mode: 'cors'<br/>  });<br/><br/>  return fetch(request)<br/>    .then(response =&gt; {<br/>      if (response.status === 200) {<br/>        return response.text();<br/>      } else {<br/>        throw new Error('Error retrieving salt');<br/>      }<br/>    })<br/>}<br/><br/>function login (email, digest) {<br/><br/>  // Send the credentials to the server<br/>  const payload = { email, digest };<br/>  const request = new Request('http://%%API_SERVER_HOST%%:%%API_SERVER_PORT%%/login/', {<br/>    method: 'POST',<br/>    headers: { 'Content-Type': 'application/json' },<br/>    mode: 'cors',<br/>    body: JSON.stringify(payload)<br/>  })<br/>  return fetch(request)<br/>    .then(response =&gt; {<br/>      if (response.status === 200) {<br/>        return response.text();<br/>      } else {<br/>        throw new Error('Error logging in');<br/>      }<br/>    })<br/>}<br/><br/>class LoginForm extends React.Component {<br/><br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      token: null,<br/>      email: {<br/>        value: "",<br/>        valid: null<br/>      },<br/>      password: {<br/>        value: "",<br/>        valid: null<br/>      }<br/>    };<br/>  }<br/><br/>  handleLogin = (event) =&gt; {<br/>    event.preventDefault();<br/>    event.stopPropagation();<br/><br/>    const email = this.state.email.value;<br/>    const password = this.state.password.value;<br/><br/>    retrieveSalt(email)<br/>      .then(salt =&gt; bcrypt.hashSync(password, salt))<br/>      .then(digest =&gt; login(email, digest))<br/>      .then(token =&gt; this.setState({ token }))<br/>      .catch(console.error)<br/>  }<br/><br/>  handleInputChange = (name, event) =&gt; {<br/>    const value = event.target.value;<br/>    const valid = validator[name](value);<br/>    this.setState({<br/>      [name]: { value, valid }<br/>    });<br/>  }<br/><br/>  render() {<br/>    if(this.state.token) {<br/>      return (<br/>        &lt;div id="login-success"&gt;<br/>          &lt;h1&gt;You have logged in successfully!&lt;/h1&gt;<br/>          &lt;p&gt;Where do you want to go next?&lt;/p&gt;<br/>          &lt;Link to='/'&gt;&lt;Button title="Home"&gt;&lt;/Button&gt;&lt;/Link&gt;<br/>          &lt;Link to='/profile'&gt;&lt;Button title="Profile"&gt;&lt;/Button&gt;&lt;/Link&gt;<br/>        &lt;/div&gt;<br/>      )<br/>    }<br/>    return [<br/>      &lt;form onSubmit={this.handleLogin}&gt;<br/>        &lt;Input label="Email" type="email" name="email" id="email" value={this.state.email.value} valid={this.state.email.valid} onChange={this.handleInputChange} /&gt;<br/>        &lt;Input label="Password" type="password" name="password" id="password" value={this.state.password.value} valid={this.state.password.valid} onChange={this.handleInputChange} /&gt;<br/>        &lt;Button title="Login" id="login-button" disabled={!(this.state.email.valid &amp;&amp; this.state.password.valid)}/&gt;<br/>      &lt;/form&gt;,<br/>      &lt;p&gt;Don't have an account? &lt;Link to='/register'&gt;Register&lt;/Link&gt;&lt;/p&gt;<br/>    ]<br/>  }<br/>}<br/><br/>export default LoginForm;</pre>
<p>Now that we have the form component ready, let's add it to the router. In React Router versions prior to v4, you can simply add a new <kbd>&lt;Route&gt;</kbd> component to <kbd>&lt;BrowserRouter&gt;</kbd>:</p>
<pre>&lt;BrowserRouter&gt;<br/>  &lt;Route exact path="/register" component={RegistrationForm} /&gt;,<br/>  &lt;Route exact path="/login" component={LoginForm} /&gt;<br/>&lt;/BrowserRouter&gt;</pre>
<p>However, with React Router v4, Router components can only have one child component. Therefore, we must encase the <kbd>&lt;Route&gt;</kbd> components inside a container.</p>
<p>The <kbd>react-router-dom</kbd> package provides a <kbd>&lt;Switch&gt;</kbd> component, which we will use as our container. The <kbd>&lt;Switch&gt;</kbd> component will render only the component specified in the <em>first</em> matching <kbd>&lt;Route&gt;</kbd>:</p>
<pre>import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import { BrowserRouter, Route, Switch } from 'react-router-dom';<br/>import RegistrationForm from './components/registration-form/index.jsx';<br/>import LoginForm from './components/login-form/index.jsx';<br/><br/>ReactDOM.render((<br/>  &lt;BrowserRouter&gt;<br/>    &lt;Switch&gt;<br/>      &lt;Route exact path="/register" component={RegistrationForm} /&gt;,<br/>      &lt;Route exact path="/login" component={LoginForm} /&gt;<br/>    &lt;/Switch&gt;<br/>  &lt;/BrowserRouter&gt;<br/>), document.getElementById('renderTarget'));</pre>
<p>In the preceding example, if we navigate to <kbd>/register</kbd>, the <kbd>&lt;Switch&gt;</kbd> component will see that there's a match in the first <kbd>&lt;Route&gt;</kbd> component, and will stop looking for any more matches and return <kbd>&lt;RegistrationForm&gt;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Over to you</h1>
                </header>
            
            <article>
                
<p>We have already gone over how to write E2E tests in a previous chapter, and we have demonstrated how to apply TDD for our Register and Login pages.</p>
<p>Now, we pass the baton to you so that you can improve on what we've done so that it conforms to the design, as well as complete the rest of the app in a TDD manner.</p>
<div class="mce-root packt_tip">You don't need to focus on making things look pretty <span>–</span> that's not the focus here. Just make sure that all of the components are there and that the user flow is correct.</div>
<p>After you've done this, take a look at our implementation and use it to improve yours. Then, we'll take a look at unit tests and other types of testing that can be applied to front-end code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have carried over what we did for our back-end API to the front-end code. We used Cucumber, Gherkin and Selenium to compose UI tests that runs directly on a real browser. We also implemented client-side routing using React Router.</p>
<p>In the next chapter, we will round off our excursion into the front-end world by learning about <strong>Redux</strong>, a powerful state management library.</p>


            </article>

            
        </section>
    </body></html>