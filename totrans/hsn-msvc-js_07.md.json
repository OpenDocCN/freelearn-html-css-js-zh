["```js\nenum Status {\n  CREATED\n  FAILED\n  APPROVED\n  DECLINED\n  FRAUD\n}\n```", "```js\nnpx prisma migrate dev --name transaction-status-updated\n```", "```js\nnpm install @nestjs/microservices kafkajs\n```", "```js\nnest generate module kafka\n```", "```js\nnest generate service kafka\n```", "```js\nimport { Module } from '@nestjs/common';\nimport { KafkaService } from './kafka.service';\nimport { ConfigModule } from '@nestjs/config';\n@Module({\n  imports: [ConfigModule],\n  providers: [KafkaService],\n})\nexport class KafkaModule {}\n```", "```js\nimport { Injectable, OnModuleInit, OnModuleDestroy } from \n  '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { Kafka, Producer } from 'kafkajs';\n@Injectable()\nexport class KafkaService implements OnModuleInit, OnModuleDestroy {\n  private readonly producer: Producer;\n  private readonly topic: string;\n  constructor(private readonly configService: ConfigService) {\n    const clientId = this.configService.get<\n      string>('KAFKA_CLIENT_ID');\n    const brokers = this.configService.get<string>('KAFKA_BROKERS')\n      .split(',');\n    this.topic = this.configService.get<string>('KAFKA_TOPIC');\n    const kafka = new Kafka({ clientId, brokers });\n    this.producer = kafka.producer({ retry: { retries: 3 }\n      });\n  }\n  async onModuleInit(): Promise<void> {\n    await this.producer.connect();\n  }\n  async onModuleDestroy(): Promise<void> {\n    await this.producer.disconnect();\n  }\n  async send(value: any, key?: string): Promise<void> {\n    const messages = [{ key, value: JSON.stringify(value)\n      }];\n    await this.producer.send({ topic: this.topic, messages\n      });\n  }\n}\n```", "```js\n#KAFKA Configuration\nKAFKA_CLIENT_ID=transaction-service\nKAFKA_BROKERS=localhost:29092\nKAFKA_TOPIC=transaction-service-topic\n```", "```js\nnpm install @nestjs/config\n```", "```js\nimport { Module } from '@nestjs/common';\nimport { TransactionService } from './transaction.service';\nimport { TransactionController } from './transaction.controller';\nimport { PrismaModule } from '../prisma/prisma.module';\nimport { HttpModule } from '@nestjs/axios';\nimport { KafkaService } from 'src/kafka/kafka.service';\nimport { ConfigService } from '@nestjs/config';\n@Module({\n  imports: [PrismaModule,HttpModule],\n  controllers: [TransactionController],\n  providers:\n    [TransactionService,KafkaService,ConfigService],\n})\nexport class TransactionModule {}\n```", "```js\nimport { Injectable } from \"@nestjs/common\";\nimport { CreateTransactionDto } from \"./dto/create-transaction.dto\";\nimport { PrismaService } from \"src/prisma/prisma.service\";\nimport { HttpService } from \"@nestjs/axios\";\nimport { AccountApiResponse } from \"./dto/account.dto\";\nimport { KafkaService } from \"src/kafka/kafka.service\";\n@Injectable()\nexport class TransactionService {\n  constructor(\n    private readonly prisma: PrismaService,\n    private readonly httpService: HttpService,\n    private readonly kafkaService: KafkaService\n  ) {}\n  async create(createTransactionDto: CreateTransactionDto)\n  {\n    //same as Chapter 6\n  }\n  findAll() {\n    //same as Chapter 6\n  }\n  findOne(id: number) {\n    //same as Chapter 6\n  }\n //newly added functionality\n    async fraud(id: number) {\n    const transaction = await this.findOne(id);\n    if (transaction.status !== \"FRAUD\" &&\n      transaction.status !== \"FAILED\") {\n        const newTransaction =\n          this.prisma.transaction.update({\n            where: { id },\n            data: { status: \"FRAUD\" },\n          });\n          this.kafkaService.send(transaction, null);\n          return newTransaction;\n        } else throw new Error(\"Transaction is not in a valid status\");\n  }\n```", "```js\n @Post(':id')\n  fraud(@Param(‹id›) id: string) {\n    return this.transactionService.fraud(+id);\n  }\n```", "```js\n{\n  \"id\": 1,\n  \"status\": \"FRAUD\",\n  \"accountId\": \"662c081370bd2ba6b5f04e94\",\n  \"description\": \"simple transaction\",\n  \"createdAt\": \"2024-05-10T08:43:41.389Z\",\n  \"updatedAt\": \"2024-05-29T17:47:07.233Z\"\n}\n```", "```js\nnpm install kafkajs\n```", "```js\n#KAFKA Configuration\nKAFKA_CLIENT_ID=account-service\nKAFKA_BROKERS=localhost:29092\nKAFKA_TOPIC=transaction-service-topic\nKAFKA_GROUP_ID=account-group\n```", "```js\nconst dotenv = require('dotenv');\nconst Joi = require('joi');\nconst envVarsSchema = Joi.object()\n    .keys({\n        PORT: Joi.number().default(3000),\n        MONGODB_URL:\n          Joi.string().required().description('Mongo DB url'),\n        KAFKA_CLIENT_ID: Joi.string().required(),\n        KAFKA_BROKERS: Joi.string().required(),\n        KAFKA_TOPIC: Joi.string().required(),\n        KAFKA_GROUP_ID: Joi.string().required()\n    })\n    .unknown();\nfunction createConfig(configPath) {\n    dotenv.config({ path: configPath });\n    const { value: envVars, error } = envVarsSchema\n        .prefs({ errors: { label: ‹key› } })\n        .validate(process.env);\n    if (error) {\n        throw new Error(`Config validation error:\n          ${error.message}`);\n    }\n    return {\n        port: envVars.PORT,\n        mongo: {\n            url: envVars.MONGODB_URL,\n        },\n        kafka: {\n            clientID: envVars.KAFKA_CLIENT_ID,\n            brokers: envVars.KAFKA_BROKERS,\n            topic: envVars.KAFKA_TOPIC,\n            groupId: envVars.KAFKA_GROUP_ID,\n        }\n    };\n}\nmodule.exports = {\n    createConfig,\n};\n```", "```js\nconst { Kafka } = require('kafkajs');\nconst Account = require('../models/account');\nconst path = require('path');\nconst { createConfig } = require('../config/config')\nconst configPath = path.join(__dirname, '../../configs/.env');\nconst appConfig = createConfig(configPath);\nconst kafka = new Kafka({\n    clientId: appConfig.kafka.clientId,\n    brokers: [appConfig.kafka.brokers],\n});\nconst consumer = kafka.consumer({ groupId:\n  appConfig.kafka.groupId });\nconst consumerModule = async () => {\n    await consumer.connect();\n    await consumer.subscribe({ topic: appConfig.kafka.topic });\n    await consumer.run({\n      eachMessage: async ({ topic, partition, message }) =>\n      {\n        const transaction =\n          JSON.parse(message.value.toString());\n        const accountId = transaction.accountId;\n        try {\n              const blockedAccount =\n                await Account.findOne({ accountId, status:\n                { $ne: 'blocked' } });\n              if (!blockedAccount) {\n                const updatedAccount =\n                  await Account.findOneAndUpdate(\n                        { _id: accountId },\n                        { $inc: { count: 1 } },\n                        { new: true }\n                    );\n                  if (updatedAccount.count === 3)\n                    await Account.findOneAndUpdate(\n                            { _id: accountId },\n                            { status: 'blocked' },\n                            { new: true }\n                   );\n                }\n                else\n                    console.log(`not a valid accountId ${accountId}`);\n            }\n            catch (error) {\n                console.log(error);\n            }\n        },\n    });\n};\nmodule.exports = consumerModule;\n```", "```js\n    const kafka = new Kafka({\n        clientId: appConfig.kafka.clientId,\n        brokers: [appConfig.kafka.brokers],\n    });\n    ```", "```js\nconst express = require('express');\nconst v1 = require('./routes/v1');\nconst consumerModule = require('./modules/kafkamodule');\nconst app = express();\nconsumerModule();\n// service\napp.use(express.json());\n// V1 API\napp.use('/v1', v1);\nmodule.exports = app;\n```", "```js\ncount: {\n            type: Number,\n            default: 0, // Optional:(defaults to 0)\n        },\n```", "```js\n    {\n        \"name\":\"AccName1\",\n        \"number\":\"Ac12345\",\n        \"type\":\"root\",\n        \"status\":\"new\"\n    }\n    ```", "```js\n    {\n        \"success\": true,\n        \"Account\": {\n            \"id\":{your_account_id}, //for the given request, it is  \"6658ae5284432e40604018d5\" for us\n            \"name\": \"AccName1\",\n            \"number\": \"Ac12345\",\n            \"type\": \"root\",\n            \"status\": \"new\"\n        }\n    }\n    ```", "```js\n{\n  \"_id\": {\n    \"$oid\": \"6658ae5284432e40604018d5\"\n  },\n  \"name\": \"AccName1\",\n  \"number\": \"Ac12345\",\n  \"type\": \"root\",\n  \"status\": \"new\",\n  …………………\n}\n```", "```js\n    {\n      \"accountId\": \"6658ae5284432e40604018d5\",\n      \"description\": \"Optional transaction description\"\n    }\n    ```", "```js\n    {\n      \"id\": {your_id},//it is '37' for us but in your case, it may have a different value\n      \"status\": \"CREATED\",\n      \"accountId\": \"6658ae5284432e40604018d5\",\n      \"description\": \"Optional transaction description\",\n    ………………\n    37 for us) to the POST /transaction/Id API. It is a fraud endpoint. The response will be like the following:\n\n    ```", "```js\n\n    Before executing the fraud endpoint, make sure that the Docker infrastructure is running. After running a fraud request, the account microservice should read and update the data. Running the same account ID in a fraud context three times should block the account itself in the account microservice:\n\n    ```", "```js\n\n    ```"]