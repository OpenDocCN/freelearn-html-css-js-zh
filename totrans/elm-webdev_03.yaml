- en: Creating Your Personal Portfolio with Elm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Elm 创建您的个人作品集
- en: Welcome to [Chapter 3](a0913cd7-9a18-4111-8d7a-7f39f0f2a07a.xhtml), *Creating
    Your Personal Portfolio with Elm*. The goal of this chapter is to create a simple
    personal portfolio website in Elm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [第 3 章](a0913cd7-9a18-4111-8d7a-7f39f0f2a07a.xhtml)，*使用 Elm 创建您的个人作品集*。本章的目标是使用
    Elm 创建一个简单的个人作品集网站。
- en: 'The topics we will cover include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的主题包括：
- en: Understanding Type Aliases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型别名
- en: Discussing the Model, View, Message, Update workflow in detail (a detailed look
    into the Elm Architecture)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细讨论模型、视图、消息、更新工作流程（对 Elm 架构的深入了解）
- en: Mapping and filtering Lists of values with `List.map` and `List.filter`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `List.map` 和 `List.filter` 映射和过滤值列表
- en: Using elm-make-app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 elm-make-app
- en: Adding Bootstrap 4 styles to our app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Bootstrap 4 样式添加到我们的应用程序中
- en: Working with the `HTML` module in Elm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Elm 中与 `HTML` 模块一起工作
- en: Understanding function signatures for HTML elements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HTML 元素的函数签名
- en: Modularizing our app by splitting the views into multiple files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将视图拆分为多个文件来模块化我们的应用程序
- en: Using case expressions to dynamically render sections of a web page
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用情况表达式动态渲染网页的各个部分
- en: Improving our *FizzBuzz* app using `List.map` and `String.concat`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `List.map` 和 `String.concat` 改进我们的 *FizzBuzz* 应用程序
- en: 'After completing this chapter, you will be able to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够：
- en: Work with type aliases in Elm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Elm 中使用类型别名
- en: Know how to use the Elm architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用 Elm 架构
- en: Be able to manipulate Lists in Elm with `List.map` and `List.filter`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用 `List.map` 和 `List.filter` 在 Elm 中操作列表
- en: Build Elm apps with elm-make-app
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 elm-make-app 构建 Elm 应用程序
- en: Modularize Elm apps into multiple files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Elm 应用程序模块化到多个文件中
- en: Use `case` expressions for dynamic updates to your Elm-powered web pages
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `case` 表达式为您的 Elm 驱动的网页进行动态更新
- en: Add custom styles to your Elm apps
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的 Elm 应用程序添加自定义样式
- en: Creating our portfolio with elm-make-app
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 elm-make-app 创建我们的作品集
- en: To start this chapter, let's remember that in [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml),
    *Why Is This a Great Time to Learn Elm?*, we have set up a workflow with the Atom
    editor. The beauty of this setup is in the fact that, although complicated, once
    the setup is complete, we have all the additional Elm tools at our disposal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章，让我们回顾一下在 [第 1 章](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml)，*为什么现在是学习
    Elm 的好时机？* 中，我们已经使用 Atom 编辑器设置了一个工作流程。这个设置的美妙之处在于，尽管它很复杂，但一旦设置完成，我们就拥有了所有额外的 Elm
    工具。
- en: To follow the instructions in this chapter, it's not absolutely necessary to
    use the said Atom setup, but it would make it easier to work with our *Portfolio*
    app. Alternatively, you can use any editor as these steps will still work, but
    in that case you'd be working without the linter and the syntax highlighter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，使用所提到的 Atom 设置并非绝对必要，但它会使与我们的 *Portfolio* 应用程序一起工作变得更加容易。或者，您可以使用任何编辑器，因为这些步骤仍然有效，但那样的话，您将没有使用代码检查器和语法高亮功能。
- en: 'Thus, to start, let''s create a folder for our new project using the console.
    For example, we can point our bash to Desktop, and make a new folder there:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，让我们使用控制台创建一个新的项目文件夹。例如，我们可以将 bash 指向桌面，并在那里创建一个新的文件夹：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, let's change the directory to `chapter3` by using the following command
    in our console: `cd chapter3`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令在我们的控制台中更改目录到 `chapter3`：`cd chapter3`。
- en: In [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml), *Why Is This a Great
    Time to Learn Elm?*, we discussed several ways to create a new Elm app. One of
    them was using the `create-elm-app` npm package. If you don't already have the
    package installed, refer back to [Chapter 1](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml), *Why
    Is This a Great Time to Learn Elm?*, to make sure you've set everything up correctly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml)，*为什么现在是学习 Elm 的好时机？* 中，我们讨论了创建新
    Elm 应用程序的几种方法。其中之一是使用 `create-elm-app` npm 包。如果您还没有安装该包，请参阅 [第 1 章](7ac82686-ac2c-4001-94b1-8006f6691fdc.xhtml)，*为什么现在是学习
    Elm 的好时机？*，以确保您已正确设置一切。
- en: 'Using the `create-elm-app` npm package, let''s create a new Elm app, called
    `my-portfolio`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `create-elm-app` npm 包，让我们创建一个新的 Elm 应用程序，命名为 `my-portfolio`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The console will print out the result of running the preceding command, as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台将打印出运行前面命令的结果，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once your new Elm app is created, open the `my-portfolio` folder in the Atom
    editor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的 Elm 应用程序，请打开 Atom 编辑器中的 `my-portfolio` 文件夹。
- en: 'From the Atom editor, twirl-open the `src` folder, and open the `Main.elm`
    file. Delete the existing code, and paste in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Atom 编辑器中，展开 `src` 文件夹，并打开 `Main.elm` 文件。删除现有的代码，并粘贴以下代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you could import the `h1` function directly, and change the
    `main` function accordingly, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以直接导入`h1`函数，并相应地更改`main`函数，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The difference between the above two examples is in the functions that we are
    importing. If we don't import the `h1` function, we need to use `HTML.h1`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个示例之间的区别在于我们导入的函数。如果我们不导入`h1`函数，我们需要使用`HTML.h1`。
- en: 'Finally, using your console, `cd` into the `my-portfolio` folder and run the
    following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用你的控制台，`cd`进入`my-portfolio`文件夹，并运行以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running the preceding command will open your default browser with the URL of
    `localhost:3000`. On the page that opens, you''ll see a nicely formatted `h1`
    heading: *My Portfolio*. In the next section, we''ll give our site some more content.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令将打开你的默认浏览器，并显示`localhost:3000`的URL。在打开的页面上，你会看到一个格式良好的`h1`标题：*我的作品集*。在下一节中，我们将为我们的网站添加更多内容。
- en: Building a static single-page portfolio
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建静态单页作品集
- en: We are building a simple single-page site to showcase a writer's portfolio.
    This should be a fun little exercise in which we will understand how to actually
    build websites with Elm. At the same time, we have removed a level of complexity
    as our site will consist almost entirely of text. Of course, as we progress with
    Elm, we will introduce more concepts, but for now, we'll stick with the basics.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个简单的单页网站来展示一个作家的作品集。这将是一个有趣的练习，我们将通过它了解如何实际上使用Elm构建网站。同时，我们简化了网站的复杂性，因为我们的网站几乎全部由文本组成。当然，随着我们对Elm的深入，我们将引入更多概念，但就目前而言，我们将坚持基础。
- en: 'Let''s expand our site by adding a few more sections to our home page. We will
    begin by making an error. The following code will not work:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的主页添加更多部分来扩展我们的网站。我们首先会犯一个错误。以下代码将无法工作：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll get the following error when we save the preceding code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存前面的代码时，我们会得到以下错误：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To resolve the issue, we need to structure the code we pass to the `main` function
    a bit differently. Basically, we need to have a wrapping HTML element for all
    our HTML. We''ll wrap everything we pass to `main` inside the wrapping `div` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要稍微改变我们传递给`main`函数的代码结构。基本上，我们需要为所有的HTML添加一个包装HTML元素。我们将把传递给`main`的所有内容都包裹在包装`div`函数中：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can add to our portfolio using a number of other elements. To make
    them all available, we will expose everything inside the `HTML` module. The updated
    code will now look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用许多其他元素来丰富我们的作品集。为了使它们全部可用，我们将暴露`HTML`模块中的所有内容。更新后的代码现在看起来像这样：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this time, you might start to appreciate the work that `elm-format` does
    for us. No matter how bad our formatting of Elm code is, it will fix it for us
    on every save.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，你可能会开始欣赏`elm-format`为我们所做的努力。无论我们的Elm代码格式有多糟糕，它都会在每次保存时为我们修复。
- en: Before going any further, let's add a CSS framework to our single-page site. For
    this example, we will be using the most recent version of the Bootstrap framework,
    namely Bootstrap 4. In order to obtain the link to the CSS of the framework, navigate
    to the following web page: [https://getbootstrap.com/docs/4.0/getting-started/introduction/?#css](https://getbootstrap.com/docs/4.0/getting-started/introduction/?#css).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们向我们的单页网站添加一个CSS框架。在这个例子中，我们将使用最新的Bootstrap框架版本，即Bootstrap 4。为了获取框架CSS的链接，导航到以下网页：[https://getbootstrap.com/docs/4.0/getting-started/introduction/?#css](https://getbootstrap.com/docs/4.0/getting-started/introduction/?#css)。
- en: 'The preceding link points to an HTML `link` element that serves Bootstrap 4
    from a **Content Delivery Network** (**CDN**).  There is even a handy `copy` button
    on the right-hand side. Once you copy the link, navigate to the `public` folder
    of your project, and paste in the copied `link` tag in the `index.HTML` file.
    The place to paste in the `link` tag is just above the `title` tag, inside the
    `head` of the document. The mentioned section of our `index.HTML` file should
    look like this after the update:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的链接指向一个HTML `link` 元素，该元素从**内容分发网络**（**CDN**）提供Bootstrap 4。右侧甚至还有一个方便的`copy`按钮。一旦你复制了链接，导航到你的项目`public`文件夹，并将复制的`link`标签粘贴到`index.HTML`文件中。将`link`标签粘贴的位置正好在`title`标签上方，文档的`head`部分。更新后的我们的`index.HTML`文件中的相关部分应该看起来像这样：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once that is done, save the `index.HTML` file and close it. Back in `Main.elm`,
    we need to import the `HTML.Attributes` module. We also need to specify the CSS
    classes to use. We'll begin by adding the `.card` class to the `div` that wraps
    the `ul` tag.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，保存`index.HTML`文件并关闭它。回到`Main.elm`，我们需要导入`HTML.Attributes`模块。我们还需要指定要使用的CSS类。我们将首先将`.card`类添加到包裹`ul`标签的`div`中。
- en: 'The updated code should look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的代码应该看起来像这样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After this update to our code, you will see a slight change to the `ul` element
    in our page. Let''s take it a step further by passing several Bootstrap 4 CSS
    classes to our `div`. To do that, we''ll simply replace this code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对代码进行这次更新之后，你将看到我们页面中的`ul`元素发生了一些细微的变化。让我们更进一步，通过向我们的`div`传递几个Bootstrap 4
    CSS类来实现这一点。为此，我们将简单地替换以下代码：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s change the preceding line by adding the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码来更改前面的行：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After saving `Main.elm`, you should see a nice blue background on the `ul` element,
    with the `li` items colored white.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存`Main.elm`之后，你应该会在`ul`元素上看到漂亮的蓝色背景，以及白色的`li`项。
- en: 'However, we are using the wrong kind of Bootstrap component. We are using a
    card, but it would be much more suitable to use the `nav` component, available
    at [https://getbootstrap.com/docs/4.0/components/navs/#horizontal-alignment](https://getbootstrap.com/docs/4.0/components/navs/#horizontal-alignment),
    with the following HTML code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们正在使用错误的Bootstrap组件。我们正在使用卡片，但使用可用的`nav`组件会更为合适，该组件位于[https://getbootstrap.com/docs/4.0/components/navs/#horizontal-alignment](https://getbootstrap.com/docs/4.0/components/navs/#horizontal-alignment)，以下HTML代码：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, the preceding code is plain HTML, and we need to turn it into Elm code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码是纯HTML，我们需要将其转换为Elm代码。
- en: It is a nice exercise to try to convert the aforementioned HTML code to Elm
    code by yourself. However, there is an online converter available at: [http://mbylstra.github.io/HTML-to-elm/](http://mbylstra.github.io/html-to-elm/).
    We can simply paste in the HTML code to the left pane of the provided URL.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己将上述HTML代码转换为Elm代码是一个很好的练习。然而，有一个在线转换器可供使用，位于：[http://mbylstra.github.io/HTML-to-elm/](http://mbylstra.github.io/html-to-elm/)。我们可以简单地粘贴HTML代码到提供的URL的左侧面板。
- en: 'The code we get back, in the right pane, will look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的代码，在右侧面板中，将看起来像这样：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can simply paste in the preceding code in place of the child `div`
    we had earlier. The complete code will now look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将前面的代码粘贴到我们之前使用的子`div`的位置。完整的代码现在将看起来像这样：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before we continue, we'll have to do some housekeeping and explain a few other
    important concepts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要做一些清理工作并解释几个其他重要概念。
- en: HTML for Elm
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm的HTML
- en: Up to this point in our journey through Elm, we have not referred to the official
    docs in any meaningful manner. In this section, we will focus on the official
    documentation and look at the practical ways it can help us.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过Elm的旅程到目前为止，我们还没有以任何有意义的方式参考官方文档。在本节中，我们将专注于官方文档，并探讨它如何以实际的方式帮助我们。
- en: 'To start, navigate to the official README for the HTML Elm package, available
    at:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到HTML Elm包的官方README，该包可在以下位置找到：
- en: '[http://package.elm-lang.org/packages/elm-lang/HTML/2.0.0/](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/).
    As it says on the website, the page we have opened describes the core HTML library
    for Elm. At the current stage of our learning, the best way to grow our Elm skills
    is to look at the actual HTML package, available at: [http://package.elm-lang.org/packages/elm-lang/HTML/2.0.0/HTML](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://package.elm-lang.org/packages/elm-lang/HTML/2.0.0/](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/).
    正如网站所述，我们打开的页面描述了Elm的核心HTML库。在我们当前的学习阶段，提高我们的Elm技能的最佳方式是查看可用的实际HTML包，位于：[http://package.elm-lang.org/packages/elm-lang/HTML/2.0.0/HTML](http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html)。'
- en: 'Specifically, we will look at the type definitions of all the HTML functions
    we have used in this chapter: `div`, `h1`, `text`, `p`, `ul`, `li`, and `a`. Being
    able to grasp the signatures of functions we use in our programs fully will make
    it that much easier to reason about them.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将查看本章中使用的所有HTML函数的类型定义：`div`、`h1`、`text`、`p`、`ul`、`li`和`a`。完全掌握我们在程序中使用的函数签名将使推理它们变得更加容易。
- en: Function signatures for HTML elements
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML元素的函数签名
- en: 'All HTML elements share the same function signature pattern:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTML元素都共享相同的函数签名模式：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Every HTML element takes in two lists: a List of Attributes and a List of Children
    elements. Then, they return an `HTML msg`. If the value returned from a function
    does not emit a message, that code will return the`msg` type.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTML元素接受两个列表：属性列表和子元素列表。然后，它们返回一个`HTML msg`。如果函数返回的值不发出消息，那么该代码将返回`msg`类型。
- en: In other words, every element returns a *value* of *HTML*. This *HTML value* is
    of type `msg`, because they end up as plain HTML nodes and they will not (cannot!)
    change our app's state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个元素都返回一个*值*，即*HTML*。这个*HTML值*是`msg`类型，因为它们最终成为普通的HTML节点，它们将不会（不能！）改变我们的应用状态。
- en: 'That''s why it is perfectly possible to just keep writing Elm''s HTML functions
    in our `main` function and never add the `view` or `update`, and still have a
    working web page. It is possible because we are rendering our code without any
    messages, so effectively, there is *never* going to be anything to update, and
    thus, we can do without the `update` function. That''s why we can replace the
    implicit type of `msg` with `a`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们可以在`main`函数中继续编写Elm的HTML函数，而永远不会添加`view`或`update`，仍然有一个工作的网页。这是可能的，因为我们正在渲染我们的代码而不发出任何消息，所以实际上，永远不会有什么东西需要更新，因此我们可以不需要`update`函数。这就是为什么我们可以用`a`替换`msg`的隐式类型：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By convention, `a` stands for `anything`. Since the `main` function will *never*
    return a message, we can be more explicit about it, and have the following code
    as the function signature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`a`代表`任何东西`。由于`main`函数永远不会返回消息，我们可以更明确地表示它，并以下面的代码作为函数签名：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we are explicitly declaring that we will *never* return a message. The
    Type of `Never` cannot ever be constructed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们明确声明我们永远不会返回一个消息。`Never`类型的值永远无法构造。
- en: Being able to grasp the signatures of functions we use in our programs fully
    will make it that much easier to reason about them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解我们在程序中使用的函数的签名将使我们对它们的推理更加容易。
- en: Function signature for text function
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本函数的函数签名
- en: 'The text function''s signature, as we can see in the official documentation,
    is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 文本函数的签名，正如我们在官方文档中看到的，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Thus, the `text` function takes a `String` and returns an `HTML msg`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`text`函数接受一个`String`并返回一个`HTML msg`。
- en: Adding our view function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的视图函数
- en: In this section, we will take out our `view` code from directly passing it to
    the `main` function, and instead assign it to the `view` function, which will
    then be passed to the `main` function. This way, we are beginning to make our
    code more modular and reusable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从直接将`view`代码传递给`main`函数中提取出来，而是将其分配给`view`函数，然后将其传递给`main`函数。这样，我们开始使我们的代码更加模块化和可重用。
- en: 'First, in our portfolio app, let''s rename the `main` function to `view` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的投资组合应用中，让我们将`main`函数重命名为`view`函数：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, at the very bottom of the file, we can simply add an updated `main` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在文件的底部，我们可以简单地添加一个更新的`main`函数：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A nice thing about this setup is that we can now pass our entire `view` to
    a wrapping `div`, for example, like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置的一个好处是，我们现在可以将整个`view`传递给一个包装的`div`，例如，如下所示：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can also begin to make our `view` even more modular and reusable by calling
    it from another file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从另一个文件调用它来使我们的`view`更加模块化和可重用。
- en: Calling the view function from another file
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个文件调用视图函数
- en: 'To begin, let''s make a new folder inside the `src` folder of our project.
    Inside your console, from the root of your project, run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在项目的`src`文件夹中创建一个新的文件夹。在你的控制台中，从项目的根目录运行以下命令：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, `cd` into `View` and create a new `View.elm` file by using the touch command. 
    If you have the `atom` command available in your console, you can open the `View.elm`
    file right from your command line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`cd`到`View`并使用`touch`命令创建一个新的`View.elm`文件。如果你在控制台中可用`atom`命令，你可以直接从命令行打开`View.elm`文件：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What does the preceding command do? It navigates to the `View` folder via command
    line, then creates a new file called `View.elm`, and then opens it in *Atom*.
    You don't have to use the command line at all—you can complete these actions using
    the graphical user interface of your operating system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令做了什么？它通过命令行导航到`View`文件夹，然后创建一个名为`View.elm`的新文件，然后将其在*Atom*中打开。你根本不需要使用命令行——你可以使用操作系统的图形用户界面完成这些操作。
- en: 'Because we are now putting our `view` function in a separate file, we will
    effectively use the view function as an Elm module. Since we will be using our
    `View.elm` file as a module, we need to be explicit about all the `HTML` functions
    we will use, similar to how it works in the original `Main.elm` file. Thus, our
    `View.elm` code needs to look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在将 `view` 函数放在一个单独的文件中，我们将有效地使用视图函数作为 Elm 模块。由于我们将使用我们的 `View.elm` 文件作为模块，我们需要明确所有我们将使用的
    `HTML` 函数，类似于原始的 `Main.elm` 文件中的方式。因此，我们的 `View.elm` 代码需要看起来像这样：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, let''s update our `Main.elm` file, so that it looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新我们的 `Main.elm` 文件，使其看起来像这样：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save everything and the app will still work, although with a warning from our
    linter, saying:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 保存一切，应用程序仍然可以工作，尽管我们的 linter 会发出警告：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Basically, what''s happened here is that we are importing `HTML.Attributes
    exposing (..)` in our `Main.elm`, but we are not using it at all. There are several
    ways we can deal with this. For example, we can simply pass only the `view` function
    to the `main` function. Or, we could add a class of, for example, `bg-warning`
    to our `div`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里发生的事情是我们正在将 `HTML.Attributes exposing (..)` 导入到我们的 `Main.elm` 中，但我们根本没用到它。我们可以用几种方法来处理这个问题。例如，我们可以简单地只将
    `view` 函数传递给 `main` 函数。或者，我们可以在 `div` 上添加一个类，例如 `bg-warning`：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Feel free to try out other solutions to solve this warning, as it is a useful
    little exercise.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试其他解决方案来解决这个警告，因为这是一个有用的练习。
- en: Adding some style
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些样式
- en: To continue, let's make an intentional error. If you've seen the result of using
    the `bg-warning` class on our *Portfolio* app, you'll see that it looks like an
    orange stripe, and everything else below is just plain old white. Let's say we'd
    like to increase the height of our wrapping `div`, so that it covers the height
    of 1,000 pixels, thus coloring everything orange. To achieve this in vanilla HTML,
    we could use the `style` attribute. Let's do that with Elm.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们故意犯一个错误。如果你看过我们在 *Portfolio* 应用中使用 `bg-warning` 类的结果，你会看到它看起来像一条橙色条纹，而下面的其他一切只是普通的白色。假设我们想要增加包裹
    `div` 的高度，使其覆盖 1,000 像素的高度，从而使一切变成橙色。在纯 HTML 中，我们可以使用 `style` 属性来实现这一点。让我们用 Elm
    来做这件事。
- en: 'Without knowing the signature of the `style` function that Elm uses, let''s
    just try to solve it without looking at the docs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道 Elm 使用的 `style` 函数签名的情况下，让我们尝试在不查看文档的情况下解决这个问题：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you''ve probably guessed, saving the preceding code results in an error.
    Let''s look at the linter message we get in Atom:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，保存前面的代码会导致错误。让我们看看在 Atom 中我们得到的 lint 消息：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Great! Now, we know how we need to change our `style` function. It needs to
    take one or more pairs of `Strings`, in parentheses, just like the compiler said
    previously. So, we''ll update our function like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们知道我们需要如何更改我们的 `style` 函数。它需要接受一个或多个括号中的 `Strings` 对，就像编译器之前说的那样。所以，我们将更新我们的函数如下：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, everything works again, and the height of our orange background has increased.
    Even better, to make sure that our screen is completely orange, let''s update
    the style again:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切又恢复正常了，我们橙色背景的高度也增加了。更好的是，为了确保我们的屏幕完全变成橙色，让我们再次更新样式：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Instead of using pixels, we are using `100vh`, that is, 100 viewport height,
    which translates to the full height of the screen. In the next section, we will
    make our view even more modular, by splitting it into multiple files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用像素，而是使用 `100vh`，即 100 视口高度，这相当于屏幕的全高度。在下一节中，我们将通过将其拆分为多个文件来使我们的视图更加模块化。
- en: Splitting the view into multiple files
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将视图拆分为多个文件
- en: In this section, we will split our view into multiple files. We will also add
    additional content to it, so that when we are finished, we have a complete single-page
    site.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把我们的视图拆分为多个文件。我们还将添加更多内容，这样当我们完成时，我们将拥有一个完整的单页网站。
- en: 'To begin, let''s think about what part of our view code we can split into a
    separate file. It''s obvious that the `ul` function is a separate chunk of code,
    so let''s turn it into a module. In your `View` folder, open a new file and call
    it `Navigation.elm`. Next, paste in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下我们可以在单独的文件中拆分视图代码的哪些部分。很明显，`ul` 函数是一段独立的代码，所以让我们将其转换为一个模块。在你的 `View`
    文件夹中，打开一个新文件，并将其命名为 `Navigation.elm`。接下来，粘贴以下代码：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have just built a new module called `View.Navigation`. Save the file, and
    go back to `View.elm`, where we will import this new module.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个名为 `View.Navigation` 的新模块。保存文件，然后回到 `View.elm`，我们将导入这个新模块。
- en: 'Back in `View.elm`, our updated code will look like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `View.elm` 中，我们的更新代码将看起来像这样：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the change in this version of `View.elm`—we have imported the `View.Navigation`
    module, exposing everything, and we have also put the navigation function in place
    of the modularized `ul [] []` code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`View.elm`这个版本的更改——我们导入了`View.Navigation`模块，暴露了一切，并且我们还用模块化的`ul [] []`代码替换了导航函数。
- en: We can follow this pattern to build up our entire page. The next thing that
    our page needs to have is a couple of poems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循这个模式来构建整个页面。我们的页面接下来需要的是几首诗歌。
- en: 'To add them, we will use the Bootstrap 4 `card` component. Thus, let''s make
    a new file in our `View` folder, call it `Poem.elm`, and add this code to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加它们，我们将使用Bootstrap 4的`card`组件。因此，让我们在我们的`View`文件夹中创建一个新文件，命名为`Poem.elm`，并将以下代码添加到其中：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, import the Poem module inside the `View.elm` file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`View.elm`文件中导入`Poem`模块：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you look at the website right now, you will see that the poem is stretching
    the entire width of the screen, which is not the best possible look. Let''s wrap
    the poem inside a container, `div`, by updating our `View.elm` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看网站，你会看到诗歌正在拉伸整个屏幕的宽度，这并不是最佳的外观。让我们通过更新我们的`View.elm`文件，将诗歌包裹在一个容器`div`中：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s also change our code so that we can fit more than one card on a single
    row. We''ll do that by adding another default Bootstrap 4 class, `row`. Inside
    the `row`, we''ll add three columns of equal widths. To do this, we''ll update
    the `View.elm` file as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更改我们的代码，以便我们可以在一行中放置多个卡片。我们将通过添加另一个默认的Bootstrap 4类`row`来实现这一点。在`row`内部，我们将添加三个等宽的列。为此，我们将更新`View.elm`文件如下：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you followed all the steps correctly up to this point, you should see the
    following web page in your browser:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确地遵循了到目前为止的所有步骤，你应该能在你的浏览器中看到以下网页：
- en: '![](img/ca7b8d1c-8fa3-4d7a-b07b-922bb29041e7.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca7b8d1c-8fa3-4d7a-b07b-922bb29041e7.png)'
- en: 'Now, we are fitting three cards nicely on a single row on our page. Before
    we continue building our page, it''s time to make it better looking. Back in `Main.elm`,
    let''s erase the `class` function, and add another CSS declaration to the `style`
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在页面上整齐地放置了三张卡片。在我们继续构建页面之前，是时候让它看起来更好了。回到`Main.elm`，让我们删除`class`函数，并给`style`函数添加另一个CSS声明：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will give our page a much calmer, light gray background.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们的页面带来一个更平静、浅灰色的背景。
- en: The `style` function takes a *List of 2-element tuples*. In the preceding example,
    the List consists of *two 2-element tuples*, where each element in the tuple is
    of type *String*. Thus, the first tuple is `("height", "100vh")`, and the second
    one is `("background", "#eee")`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`函数接受一个*2元素元组的列表*。在上面的例子中，列表由*两个2元素元组*组成，其中元组中的每个元素都是*String*类型。因此，第一个元组是`("height",
    "100vh")`，第二个是`("background", "#eee")`。'
- en: In the next section, we will finish our page by adding the remaining `view`
    files.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过添加剩余的`view`文件来完成我们的页面。
- en: Completing our Writer's portfolio
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成我们的作家组合
- en: In this section, we will finish our Writer's portfolio. Before we continue,
    let's list what it is that we still need to add.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成我们的作家组合。在我们继续之前，让我们列出我们还需要添加的内容。
- en: 'As we mentioned at the beginning of the chapter, the completed portfolio should
    have these sections:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，完成的组合应该包含以下部分：
- en: About Me
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于我
- en: Poems
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诗歌
- en: Stories
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事
- en: Contact
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系方式
- en: We have completed the Poems section. Now, let's add the remaining sections. As
    we already know how this is done, let's batch our processes to speed up development.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了诗歌部分。现在，让我们添加剩余的部分。因为我们已经知道如何这样做，所以让我们批量处理我们的过程以加快开发速度。
- en: 'First, inside the `View` folder, let''s create three new files:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`View`文件夹中，让我们创建三个新文件：
- en: '`About.elm`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`About.elm`'
- en: '`Stories.elm`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stories.elm`'
- en: '`Contact.elm`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contact.elm`'
- en: 'Next, let''s import all of these into `View.elm`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将这些导入到`View.elm`中：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, let''s add some content to each of the files we just made. First, the
    `About.elm` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为刚刚创建的每个文件添加一些内容。首先，是`About.elm`文件：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, let''s update the `Stories.elm` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新`Stories.elm`文件：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, let''s update the `Contact.elm` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们更新`Contact.elm`文件：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll also need to update the `View.elm` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新`View.elm`文件：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let''s update the `Main.elm` file too:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也更新一下`Main.elm`文件：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our Elm-powered website should, at this point, look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的Elm驱动的网站应该看起来像这样：
- en: '![](img/c35e7f33-149b-43ac-a9ca-92b10f53e591.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c35e7f33-149b-43ac-a9ca-92b10f53e591.png)'
- en: We have made a number of updates in the aforementioned files. Although all of
    these updates deal with concepts we have already covered in this book, writing
    out the preceding code in our app is a great way to reinforce what we've learned
    before moving on to more advanced topics.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的文件中进行了多次更新。尽管所有这些更新都涉及我们在本书中已经覆盖的概念，但在我们的应用程序中编写前面的代码是巩固我们之前所学知识并继续学习更高级主题的好方法。
- en: In the preceding code, one point of possible confusion could be the use of various
    Bootstrap 4 classes. For more information about these classes, please refer to
    the official documentation for Bootstrap 4, or to a number of titles in the Packt
    library that cover Bootstrap 4 in detail.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，可能引起混淆的一点是使用了各种 Bootstrap 4 类。有关这些类的更多信息，请参阅 Bootstrap 4 的官方文档，或 Packt
    图书馆中详细介绍 Bootstrap 4 的多个标题。
- en: Now that all our files are complete, let's save everything and look at the result. There
    are many ways in which we could have improved our *Portfolio* app. For example,
    we still need to give it a working navigation. Unfortunately, at this point of
    our journey into Elm, adding navigation to our web page would require being familiar
    with a number of relatively complex topics, which would only create confusion.
    That's why we'll leave our static page as it is.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的文件都已完成，让我们保存一切并查看结果。我们可以以许多方式改进我们的*投资组合*应用程序。例如，我们仍然需要给它一个工作的导航。不幸的是，在我们
    Elm 之旅的这个阶段，向我们的网页添加导航需要熟悉许多相对复杂的话题，这只会造成混淆。这就是为什么我们将保持我们的静态页面不变。
- en: If you would like to experiment with changing things up in the portfolio for
    the sake of practice, remember that you can use the HTML to Elm website at [https://mbylstra.github.io/HTML-to-elm/](https://mbylstra.github.io/html-to-elm/),
    which should make things both faster and easier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为了练习而尝试在投资组合中改变一些东西，请记住，您可以使用[https://mbylstra.github.io/HTML-to-elm/](https://mbylstra.github.io/html-to-elm/)这个
    HTML 到 Elm 网站，这应该会使事情更快、更容易。
- en: In the section that follows, rather than prematurely getting into more advanced
    concepts to build a complex navigation solution, we'll look at a simple alternative.
    This alternative will deal with using case expressions to display different sections
    of our static page on the screen. The advantage of this approach is that we'll
    reinforce how all the working parts of the Elm architecture fit together.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们不会过早地涉及更高级的概念来构建复杂的导航解决方案，而是将查看一个简单的替代方案。这个替代方案将处理使用`case`表达式在屏幕上显示我们静态页面的不同部分。这种方法的优势在于，我们将加强
    Elm 架构所有工作部分的协同作用。
- en: Rendering sections of our page using case expressions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`case`表达式渲染我们页面的部分
- en: 'We will start this section from scratch. Create a new folder and run the following
    command on it: `create-elm-app alternative-to-navigation`. Once the app is ready,
    navigate to the `alternative-to-navigation` folder, open `Main.elm` in `src`,
    and erase all the code. Add the following code to `Main.elm`. The following code
    works as is, so feel free to save it and run the app:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始这一节。创建一个新的文件夹，并在其上运行以下命令：`create-elm-app alternative-to-navigation`。一旦应用程序准备就绪，导航到`alternative-to-navigation`文件夹，在`src`中打开`Main.elm`，并删除所有代码。将以下代码添加到`Main.elm`中。以下代码按原样工作，所以您可以保存它并运行应用程序：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Before we can improve the preceding code, we first need to make sure that we
    understand it. As we previously discussed, the first five lines deal with importing
    modules that we will be using in our application. Next, we set the `model` to
    the value of an empty string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以改进前面的代码之前，我们首先需要确保我们理解它。正如我们之前讨论的，前五行处理导入我们将在应用程序中使用的模块。接下来，我们将`model`设置为空字符串的值。
- en: 'We follow this up by creating a union type of `Msg`, which can equate to only
    one of four values: `FirstButtonMessage`, `SecondButtonMessage`, and so on. Why
    the verbose `Msg` value names? Because we want to make it absolutely clear that
    the `Msg` union type holds messages. These messages will be emitted to the `update`
    function once a user clicks one of the buttons.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个`Msg`的联合类型，它可以等于以下四个值之一：`FirstButtonMessage`、`SecondButtonMessage`等等。为什么`Msg`值名称这么冗长？因为我们希望让它绝对清晰，`Msg`联合类型包含消息。一旦用户点击其中一个按钮，这些消息就会被发射到`update`函数中。
- en: Next, we write our `update` function, which takes a `message` and a `model`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写我们的`update`函数，它接受一个`message`和一个`model`。
- en: 'Reminder: The first parameter of the `update` function is the name of the `case`
    expression inside the update function.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：`update`函数的第一个参数是更新函数内部`case`表达式的`case`名称。
- en: Then, we pass it a `case` expression, which will execute one of the four pieces
    of code based on what message it received. So, if the `update` function receives
    the message which we aptly named `FirstButtonMessage`, the case expression will
    evaluate to the `You've clicked the first button!` string.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们传递给它一个 `case` 表达式，根据接收到的消息执行四段代码中的一段。所以，如果 `update` 函数接收到的消息是我们恰当地命名的 `FirstButtonMessage`，则
    `case` 表达式将评估为 `You've clicked the first button!` 字符串。
- en: Next, our `view` function takes in a `model`, and we pass it a `div` function,
    which holds an `h1` and a `div` with the class of `container`. In turn, this wrapping
    `div` holds an `h2`, an `hr`, and another `div`, which holds four buttons and
    a `p` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的 `view` 函数接收一个 `model`，我们传递给它一个 `div` 函数，它包含一个 `h1` 和一个具有 `container`
    类的 `div`。然后，这个包装 `div` 包含一个 `h2`、一个 `hr` 和另一个 `div`，它包含四个按钮和一个 `p` 函数。
- en: Each button's attributes list takes two attributes; the first one is the class
    to use on the button, and the second one is the `onClick` event. Each `onClick`
    event will emit a different message, ready to be accepted and used by the `update`
    function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮的属性列表包含两个属性；第一个是按钮上要使用的类，第二个是 `onClick` 事件。每个 `onClick` 事件将发出不同的消息，以便 `update`
    函数接受和使用。
- en: Finally, the `main` function takes in `HTML.beginnerProgram`, which was explained
    in [Chapter 2](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml), *Building Your First
    Elm App*. Now that we understand just what the preceding code is doing, we can
    improve it a bit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数接收 `HTML.beginnerProgram`，这在[第2章](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml)《构建你的第一个
    Elm 应用》中有解释。现在我们了解了前面的代码究竟在做什么，我们可以对其进行一些改进。
- en: Improving our messages
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的消息
- en: 'To begin this section, let''s look at the completed code, with all the improvements
    made to it, and after that, we''ll discuss the changes made to the code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，让我们看看经过所有改进后的完整代码，然后我们将讨论对代码所做的更改：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this iteration of our app, the focus was on improving the messages. Basically,
    we wanted each message to have some meaningful text, and in order to do that,
    we used multiline strings, which start and finish with three sets of double quotes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用的这次迭代中，重点是改进消息。基本上，我们希望每条消息都包含一些有意义的文本，为了做到这一点，我们使用了多行字符串，这些字符串以三组双引号开始和结束。
- en: While that makes it easier for us to see all the text that was typed, it does
    not give us a flexible way to style our strings better, since, as you can see
    in the preceding code, multiline quotes in Elm cannot be broken onto the next
    line by using the `newline` character.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这使我们更容易看到输入的所有文本，但它并没有给我们提供一种灵活的方式来更好地格式化字符串，因为，正如你可以在前面的代码中看到的那样，Elm 中的多行引号不能通过使用
    `newline` 字符换行。
- en: Another change that we made involved adding a `style` function on the fourth
    button so that when a user hovers over the button, it displays a pointer instead
    of the regular cursor. This improvement makes it more obvious that the button
    is clickable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的另一个改变是在第四个按钮上添加了一个 `style` 函数，这样当用户悬停在按钮上时，它显示一个指针而不是常规的光标。这个改进使得按钮的可点击性更加明显。
- en: Another improvement that we made was giving type annotations to each of our
    functions so that we can see that the `model` function takes a `String`. The `update`
    function takes a `message` and a `model` (which can be anything) and returns a
    `String`. The `view` function takes a `String` and returns an HTML `Msg`, which
    is our own custom union type, as discussed before.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的另一个改进是为我们每个函数添加类型注解，这样我们就可以看到 `model` 函数接收一个 `String`。`update` 函数接收一个 `message`
    和一个 `model`（可以是任何类型）并返回一个 `String`。`view` 函数接收一个 `String` 并返回一个 HTML `Msg`，这是我们之前讨论过的自定义联合类型。
- en: 'With the updated *Portfolio* app being served in our browser, upon clicking
    the first button on the navigation, the About Me button, we will get the following
    output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中提供更新后的 *Portfolio* 应用时，点击导航中的第一个按钮，即“关于我”按钮，我们将得到以下输出：
- en: '![](img/34adbf52-37b4-43d9-ae05-9f76b83bb548.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34adbf52-37b4-43d9-ae05-9f76b83bb548.png)'
- en: Clicking other buttons will swiftly change what we see on the screen.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击其他按钮将迅速改变屏幕上显示的内容。
- en: 'If you cannot see the styles, make sure to add the Bootstrap 4 CDN link to
    `public/index.HTML` (just like we did for the *Portfolio* app):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到样式，请确保将 Bootstrap 4 CDN 链接添加到 `public/index.HTML`（就像我们为 *Portfolio* 应用所做的那样）：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, we'll improve our portfolio just a bit more, by adding a type alias of
    `Model`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加 `Model` 类型别名来进一步改进我们的投资组合。
- en: Adding the type alias of Model
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型类型别名
- en: By adding a type alias for our Model, we'll make it easier to change our Model
    from something other than `String`, if we ever decide to do so, which makes our
    code more maintainable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为我们的`Model`添加类型别名，如果我们决定这样做，将使我们的代码更容易从`String`之外的内容进行更改，这使得我们的代码更容易维护。
- en: 'Just under the module imports, at line 8 of our app, add this snippet of code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块导入下方，在我们的应用的第8行，添加以下代码片段：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, let''s update type annotations throughout the app:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新整个应用中的类型注解：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It''s obvious what we are doing in the code: we are aliasing the value of `String`
    with the type alias `Model`. It is very important to understand this and commit
    it to memory since this simple example shows exactly what type alias does and
    how it works.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的操作很明显：我们正在将`String`的值与类型别名`Model`进行别名设置。理解这一点并记住它非常重要，因为这个简单的例子正好展示了类型别名的作用及其工作方式。
- en: 'Making these changes, we can now see an interesting pattern: the `update` function''s
    type annotation uses the `Msg`, with the capital `M`, while we pass it the `msg`,
    with the small `m`, since it''s the first argument.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改后，我们可以看到一个有趣的模式：`update`函数的类型注解使用了大写的`Msg`，而我们将小写的`msg`传递给它，因为它是最先的参数。
- en: Similarly, we are passing the `model` with the small letter m to our `view`,
    but in our `view` function's type annotation, we are referencing the `Model` with
    the capital letter M.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将小写字母`m`的`model`传递给我们的`view`，但在我们的`view`函数的类型注解中，我们使用大写字母`M`引用`Model`。
- en: What's going on here? The explanation is simple. We can think of the lowercase
    instances as simply generic labels, which can be anything. For example, consider
    the following changes to our code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？解释很简单。我们可以将小写实例视为简单的泛型标签，可以是任何东西。例如，考虑以下代码的以下更改。
- en: 'First, let''s replace the existing update function''s `msg` with this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用这个来替换现有的更新函数的`msg`：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let''s replace the existing `view` function''s `model` with `a`,  as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将现有的`view`函数的`model`替换为`a`，如下所示：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The fact that we replaced both `msg` and `model` with the more generic `a` in
    the preceding code, and did not break it, is great. The compiler happily performs
    its duties, and we still have a working app.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`msg`和`model`都替换为更通用的`a`，并且没有破坏它，这是一个很好的事实。编译器愉快地执行其任务，我们仍然有一个工作的应用。
- en: Type alias is used to make it easier to read complex type annotations. Also,
    type annotations are capitalized by default, and so are union types. Thus, both
    the `Model` and the `Msg` are capitalized in our code, and we cannot change them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名用于使复杂的类型注解更容易阅读。此外，类型注解默认为大写，联合类型也是如此。因此，在我们的代码中，`Model`和`Msg`都是大写的，我们不能更改它们。
- en: Working with List.map and List.filter
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`List.map`和`List.filter`
- en: As discussed in previous chapters, Elm works with immutable data structures.
    How do we then use the existing immutable data structure to find its members that
    satisfy only a certain condition or to produce different values based on existing
    values?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，Elm使用不可变数据结构。那么我们如何使用现有的不可变数据结构来找到满足特定条件的成员，或者根据现有值产生不同的值呢？
- en: To achieve these two goals, we can use the `map` and `filter` functions. To
    keep things simple, we'll look at the `List.map` and `List.filter` functions,
    although `.map` and `.filter` can also be used with some other data structures
    in Elm.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这两个目标，我们可以使用`map`和`filter`函数。为了保持简单，我们将查看`List.map`和`List.filter`函数，尽管`.map`和`.filter`也可以与Elm中的某些其他数据结构一起使用。
- en: 'Let''s say our goal is to take a `List` of `numbers` and find only those that
    are divisible by 3\. To begin, let''s define a function that will take an `Int`
    and return a `Boolean` (either `True` or `False`), based on whether the number
    given to the function is divisible by 3. Navigate to [elmrepl.cuberoot.in](http://elmrepl.cuberoot.in/),
    and type the following function definition:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的目标是取一个`List`的`numbers`并找到仅能被3整除的数。首先，让我们定义一个函数，该函数将接受一个`Int`并返回一个`Boolean`（`True`或`False`），基于传递给函数的数字是否可以被3整除。导航到[elmrepl.cuberoot.in](http://elmrepl.cuberoot.in/)，并输入以下函数定义：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Upon pressing the return key, the Elm REPL will return the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键后，Elm REPL将返回以下内容：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our `findThrees` function takes an `Int` and returns a `Boolean`. Put differently,
    the expression `num % 3 == 0` is evaluated first. Let''s say that `num` is `3`,
    making the expression look like this: `3 % 3 == 0`. This expression is true, and
    thus the expression evaluates to the value of `True`, which is of type `Boolean`.
    Next, this value is assigned to the `findThrees` function.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `findThrees` 函数接受一个 `Int` 并返回一个 `Boolean`。换句话说，表达式 `num % 3 == 0` 首先被评估。假设
    `num` 是 `3`，使表达式看起来像这样：`3 % 3 == 0`。这个表达式是真的，因此表达式评估为 `True` 的值，它是一个 `Boolean`
    类型的值。接下来，这个值被分配给 `findThrees` 函数。
- en: In other words, if we call the `findThrees` function and give it number 3 as
    its parameter, the `findThrees` function will return the value of `True`, which
    is of type `Boolean`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们调用 `findThrees` 函数并给它数字 3 作为参数，`findThrees` 函数将返回 `True` 的值，它是一个 `Boolean`
    类型的值。
- en: 'Next, let''s give our `findThrees` function to our `List.map`. The following
    code will not work. Try to guess why before reading the explanation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的 `findThrees` 函数传递给 `List.map`。以下代码将无法正常工作。在阅读解释之前，试着猜测一下原因：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you ran the preceding code in the REPL, you''d get the following error:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在 REPL 中运行了前面的代码，你会得到以下错误：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Obviously, we can''t give just a number as the second argument of the `List.map`
    function. Instead, to make this work, we need to give it a `List` of `numbers`.
    Like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不能只给 `List.map` 函数的第二个参数提供一个数字。相反，为了使它工作，我们需要提供一个包含 `numbers` 的 `List`。就像这样：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This time, success! REPL returns the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，成功了！REPL 返回以下内容：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s try giving it a List of three numbers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试给它一个包含三个数字的列表：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This time, REPL returns:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，REPL 返回：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, let''s type a List of 10 numbers, and store it in a variable:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们输入一个包含 10 个数字的列表，并将其存储在一个变量中：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running the preceding code in the REPL will return:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中运行前面的代码将返回：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Looking at the preceding code, we can say that a `List` of numbers is stored
    in a variable we called `ourList`. Now, let''s give the `findThrees` function
    to the `List.map` function, and pass the `ourList` as the second argument:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的代码，我们可以这样说，一个数字的 `List` 存储在一个我们称之为 `ourList` 的变量中。现在，让我们将 `findThrees`
    函数传递给 `List.map` 函数，并将 `ourList` 作为第二个参数传递：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'REPL returns a List of `Bool` values:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回一个 `Bool` 值的列表：
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, let''s try to replace `List.map` with `List.filter`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试用 `List.filter` 替换 `List.map`：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'REPL returns a filter of `ourList`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 返回 `ourList` 的一个过滤结果：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now that we have practiced using `List.map` a little bit, let's look at its
    anatomy. `List.map` takes two arguments, the first one being a function, and the
    second one being the actual `List`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经稍微练习了使用 `List.map`，让我们看看它的结构。`List.map` 接受两个参数，第一个是一个函数，第二个是实际的 `List`。
- en: The function that is passed as the first argument to `List.map` is used to convert
    the second argument (the `List`) to a new `List`, based on the logic in the function.
    `List.map` does that by running the function we give it over each single member
    of the `List` provided. This behavior of `List.map` makes it a great candidate
    for improving our *FizzBuzz* app, which we will do in the next section.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `List.map` 的第一个参数的函数用于根据函数中的逻辑将第二个参数（`List`）转换为一个新的 `List`。`List.map` 通过运行我们提供的函数来遍历提供的
    `List` 的每个单独成员来实现这一点。`List.map` 的这种行为使其成为改进我们的 *FizzBuzz* 应用程序的一个很好的候选者，我们将在下一节中这样做。
- en: 'For now, let''s run a `List.map` in our Elm-REPL. In order to be able to run
    `List.map`, we need to define a function it will use. So, let''s open Elm-REPL
    and define our custom `fizzBuzzer` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的 Elm-REPL 中运行一个 `List.map`。为了能够运行 `List.map`，我们需要定义一个它将使用的函数。所以，让我们打开
    Elm-REPL 并定义我们的自定义 `fizzBuzzer` 函数：
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The REPL gives us back the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 给我们返回以下内容：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can map over our `List` with the help of `fizzBuzzer` and `List.map`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以借助 `fizzBuzzer` 和 `List.map` 在我们的 `List` 上进行映射：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'What we get back in the REPL is this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中我们得到的是这个：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Feel free to play with various combinations of the building blocks we discussed
    previously. In the next section, we will revisit our *FizzBuzz* app and apply
    some of the things we learned in practice.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试我们之前讨论的各种构建块组合。在下一节中，我们将回顾我们的 *FizzBuzz* 应用程序，并应用我们在实践中学到的一些东西。
- en: Revisiting the FizzBuzz app
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾 FizzBuzz 应用程序
- en: We have covered a lot of ground in [Chapter 3](a0913cd7-9a18-4111-8d7a-7f39f0f2a07a.xhtml),
    *Creating Your Personal Portfolio with Elm*. Can we use our newfound knowledge
    to make a better implementation of the *FizzBuzz* app? Let's find out!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](a0913cd7-9a18-4111-8d7a-7f39f0f2a07a.xhtml) 中覆盖了很多内容，*使用 Elm 创建您的个人投资组合*。我们能用我们新获得的知识来制作一个更好的
    *FizzBuzz* 应用程序实现吗？让我们来看看！
- en: 'Let''s begin with the *FizzBuzz* app as it was in [Chapter 2](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml),
    *Building Your First Elm App*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [第 2 章](c80584ff-97c8-411b-8ec3-a4b122121579.xhtml)，*构建您的第一个 Elm 应用程序*中的
    *FizzBuzz* 应用程序开始：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How can we go about improving the preceding code?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进前面的代码？
- en: First, we can implement our *FizzBuzz* app as a `beginnerProgram`. We can also
    replace the `if` expressions with a `case` expression. Finally, we can introduce
    buttons and style everything nicely.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将我们的 *FizzBuzz* 应用程序实现为一个 `beginnerProgram`。我们还可以用 `case` 表达式替换 `if`
    表达式。最后，我们可以引入按钮并将一切设计得非常优雅。
- en: Implementing FizzBuzz with List.map
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 List.map 实现 FizzBuzz
- en: 'Let''s first list out the completed, improved `FizzBuzz` app:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先列出完成的、改进的 `FizzBuzz` 应用程序：
- en: '[PRE73]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Before we start discussing what''s going on in the preceding code, let''s quickly
    update the `main` function using the forward function application operator, `|>`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论前面的代码中发生的事情之前，让我们快速使用前向函数应用操作符 `|>` 更新 `main` 函数：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Seeing the `main` function written in this different notation might make it
    simpler to understand what is happening in the preceding code. After importing
    the `Main` and `HTML` modules, we declare the `ourList` variable and the `fizzBuzzCheck`
    function definition.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 看到用这种不同符号编写的 `main` 函数可能会使理解前面的代码变得更加简单。在导入 `Main` 和 `HTML` 模块后，我们声明 `ourList`
    变量和 `fizzBuzzCheck` 函数定义。
- en: As we can see, the `fizzBuzzCheck` function takes four parameters and returns
    a value of type `String`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`fizzBuzzCheck` 函数接受四个参数，并返回一个 `String` 类型的值。
- en: The `main` function maps `ourList` based on the logic in the `fizzBuzzCheck`
    function, then we use the `String.concat` function to take that `List` of `Strings`
    that the `List.map` produced, and turn it into a single `String`, because the
    `text` function receives a single `String` value as its parameter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数根据 `fizzBuzzCheck` 函数中的逻辑映射 `ourList`，然后我们使用 `String.concat` 函数将 `List.map`
    生成的 `String` 列表合并成一个单一的 `String`，因为 `text` 函数接收一个单一的 `String` 值作为其参数。'
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered a number of important topics, namely:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多个重要主题，包括：
- en: Using elm-make-app
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 elm-make-app
- en: Adding Bootstrap 4 styles to our app
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加 Bootstrap 4 样式
- en: Working with the `HTML` module in Elm, and understanding function signatures
    for HTML elements
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Elm 中使用 `HTML` 模块，并理解 HTML 元素的函数签名
- en: Modularizing our app by splitting the views into multiple files
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将视图拆分为多个文件来模块化我们的应用程序
- en: Using case expressions to render sections of a web page dynamically
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 case 表达式动态渲染网页部分
- en: Working with type aliases
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型别名
- en: Mapping and filtering Lists of values
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射和过滤值列表
- en: Improving our *FizzBuzz* app using `List.map` and `String.concat`
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `List.map` 和 `String.concat` 改进我们的 *FizzBuzz* 应用程序
- en: In the next chapter, we will start using `Records` for our `model` and `update`
    functions as we begin building our unit conversion website. We will also learn
    about *let* expressions and how to use them, and we will wrap everything up by
    using a third-party Elm module for the first time in our code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用 `Records` 为我们的 `model` 和 `update` 函数构建单位转换网站。我们还将学习 *let* 表达式及其使用方法，并通过使用第三方
    Elm 模块来结束这一章。
