- en: Chapter 8. Build Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to create an application from the ground up using tests with Jasmine.
    However, as the application grows and the number of files starts to increase,
    managing the dependencies between them can become a little difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we have a dependency between the Investment and Stock models,
    and they must be loaded in a proper order to work. So, we do what we can; we order
    the loading of the scripts so that Stock is available once Investment is loaded.
    Here''s how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, that can soon become cumbersome and unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the number of requests the application uses to load all of
    its files; it can get up to hundreds once the application starts to grow.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a paradox here; although it is good to break it up into small modules
    for code maintainability, it is bad for the client performance, where a single
    file is much more desirable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect world would be to match the following two requirements at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: In development, we have a bunch of small files containing different modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In production, we have a single file with the content of all those modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, what we need is some sort of build process. There are many different
    ways to achieve these goals with JavaScript, but we are going to focus on **webpack**.
  prefs: []
  type: TYPE_NORMAL
- en: Module bundler – webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is a module bundler created by Tobias Koppers to help create big and
    modular frontend JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Its main difference from other solutions is its support for any type of module
    system (AMD and CommonJS), languages (CoffeeScript, TypeScript, and JSX) and even
    assets (images and templates) through loaders.
  prefs: []
  type: TYPE_NORMAL
- en: You read it right, even images; if in a React application, everything is a component,
    in a webpack project, everything is a module.
  prefs: []
  type: TYPE_NORMAL
- en: It builds a dependency graph of all your assets, serving them in a development
    environment and optimizing them for production.
  prefs: []
  type: TYPE_NORMAL
- en: Module definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is a language based on the ECMA Script specification that, until
    version 6, still didn't have a standard definition of a module. This lack of formal
    standards led to a number of competing community standards (AMD and CommonJS)
    and implementations (RequireJS and browserify).
  prefs: []
  type: TYPE_NORMAL
- en: Now, there is a standard to follow, but unfortunately there is no support for
    it in modern browsers, so which style should we use to write our modules?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that it is possible to use ES6 today through transpilers, which
    gives us a future-proof advantage.
  prefs: []
  type: TYPE_NORMAL
- en: A popular transpiler is **Babel** ([http://babeljs.io/](http://babeljs.io/)),
    which we are going to use with webpack through a loader.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how to use it with webpack in a moment, but first it is important
    to understand what makes an ES6 module. Here is a simple definition without any
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare it to the way we''ve been declaring modules until now. The next
    example shows how that code would be if written using the conventions presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The biggest difference is the lack of an IIFE. An ES6 module, by default, has
    a scope of its own, so it is impossible to pollute the global namespace by accident.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that the module value is no longer being attached
    to the global object, but instead being exported as the default module value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding a module''s dependencies, up until now, everything was globally available,
    so we passed the dependencies to the module as parameters to the IIFE, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, as you start using ES6 modules on the project, there will be no more
    global variables. So, how do you get those dependencies into the module?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from before, the ES6 example was exporting the module value
    through the `export default` syntax. So, given a module has a value, all we have
    to do is ask for it as a dependency. Let''s add the jQuery dependency to our ES6
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$` represents the name of the variable the dependency will be loaded
    into, and `jQuery` is the filename.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to export multiple values as the result of a module and
    import these values into different variables, but for the scope of this book,
    default values will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: The ES6 standard introduces a number of different constructs to the JavaScript
    language that are also beyond the scope of this book. For more information, check
    Babel's excellent documentation at [http://babeljs.io/docs/learn-es6/](http://babeljs.io/docs/learn-es6/).
  prefs: []
  type: TYPE_NORMAL
- en: Webpack project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webpack is available as an NPM package, and its setup is very simple as it is
    going to be demonstrated in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to understand the difference between NPM and Node.js. NPM is
    both a package manager and a package format, while Node.js is a platform that
    NPM modules usually run.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies with NPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already got an embryo of a Node.js project, but as we are going to start
    using more dependencies throughout this chapter, we are going to need a formal
    definition of all the NPM packages that the project depends on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the project as an NPM package, and at the same time all of its dependencies,
    we need to create a special file called `package.json` at the root folder of the
    application. It can be easily created through a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It will prompt for a number of questions about the project that can all be
    left with their default values. In the end, you should have a file with content
    similar to the following output depending on your folder name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to install all of our dependencies, which, at the moment, is
    only express.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will not only install express as described in [Chapter
    4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"), *Asynchronous Testing
    – AJAX*, but will also add it as a dependency to the `package.json` file. On running
    the `npm init` command as done previously, we get the following output showing
    the `dependencies` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we understand how to manage the dependencies of our project, we can
    install **webpack** and **Babel** as development dependencies to start bundling
    our modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to add a script in `package.json` to start the development
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to start the development server with a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual location of the `webpack-dev-server` executable is in the `./node_modules/.bin`
    folder. So, `npm run dev` is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It works because when you run `npm run <scriptName>`, NPM adds the `./node_modules/.bin`
    folder to the path.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to configure webpack so that it knows what files to bundle. This
    can be achieved by creating a `webpack.config.js` file at the root folder of the
    project. Its content should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few key points about this configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: The `context` directive tells webpack to look for modules in `__dirname`, meaning
    the project's root folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `entry` directive specifies the application's entry points. Since we are
    only doing testing at the moment, there is a single entry point named `spec` that
    refers to all of our spec files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output.filename` directive is here to inform the filename of each of the
    entry points. The `[name]` pattern will be replaced by an entry point name on
    compilation. So `spec.js` will actually contain all of our spec code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `module.loaders` final directive tells webpack how to deal with different
    file types. We are using the `babel-loader` parameter here to add support for
    ES6 modules and the JSX syntax on our source files. The `exclude` directive is
    important so as not to waste compiling any dependency from the `node_modules`
    folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this setup completed, you can start the development server and check what
    the transpiled bundle looks like at `http://localhost:8080/spec.js` (the filename
    defined in the configuration file).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the webpack configuration is complete, and we can move to adapt
    the Jasmine runner to run the specs.
  prefs: []
  type: TYPE_NORMAL
- en: The spec runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated previously, we are using webpack to compile and bundle the source
    files, so the Jasmine spec is about to become a lot simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we no longer need the JSX transformer hack explained in the previous
    chapter; the transformation is now done by webpack and the babel-loader. As a
    result, we can use the default Jasmine boot just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we've chosen to leave the test runner dependencies as global (Jasmine,
    Mock Ajax, Jasmine JQuery, and the Spec helper). Leaving them global makes things
    a lot simpler for our test runner, and we don't hurt our code as far as modularity
    is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, trying to run the tests at `http://localhost:8080/SpecRunner.html`
    should produce a lot of fails due to missing references. That is because we still
    need to convert our specs and sources into ES6 modules.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to run all the tests requires that all the source and spec files
    be converted into ES6 modules. At the specs, it means adding, as dependencies
    all the source modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At the source files, it means declaring all the dependencies as well as exporting
    its default value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once all the code is converted, the tests should work upon starting the development
    server and pointing the browser once again to the runner URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test runner: Karma'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember we said back in the introduction that we could execute Jasmine without
    the need of a browser window? To do so, we are going to use **PhantomJS**, a scriptable
    headless WebKit browser (the same rendering engine that powers the Safari browser)
    and **Karma**, a test runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup is very simple; using NPM, we once again install some dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only strange dependency here is the `es5-shim`, which is used to give PhantomJS
    support for some ES5 features that it still is missing, and React requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is creating a configuration file, named `karma.conf.js`, for
    Karma at the project''s'' root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In it, we set up the Jasmine framework and the PhantomJS browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Fix the browser compatibility issues on PhantomJS by loading `es5-shim`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the test runner dependencies, which were previously global in the `SpecRunner.html`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, load all the specs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By now, you can remove the `SpecRunner.html` file, the spec entry in the `webpack.config.js`
    file, and the `lib/jasmine-2.1.3` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests by invoking Karma, which will print the test results in the console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it simpler to run the tests, it is possible to change the `package.json`
    project file and describe its test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the tests by simply invoking the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Quick feedback loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing is all about the quick feedback loop, so imagine being able
    to have the tests running in the console and the application refreshing on the
    browser after any file change. Would that be possible? The answer is yes!
  prefs: []
  type: TYPE_NORMAL
- en: Watch and run the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Via a simple parameter while starting Karma, we can achieve testing nirvana,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Try it by yourself; run this command, change a file, and see the tests running
    automatically—like magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we don''t want to remember these complicated commands, so let''s
    add another script to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run it through the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Watch and update the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve development nirvana, we are also just a parameter away.
  prefs: []
  type: TYPE_NORMAL
- en: 'While starting the development server, add the following to the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once again, try it on your browser; change a file in the text editor and the
    browser should refresh.
  prefs: []
  type: TYPE_NORMAL
- en: You are also encouraged to update the `package.json` file with these new parameters
    so that running `npm run dev` gets you the goodness of "live reload".
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final step of our module bundler goal is to generate a minified and ready-for-production
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the configuration is complete, missing just a few more steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up an entry point for the application, then an index
    file that will start it all, `index.js`, is to be placed inside the `src` folder
    with the contents as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We haven't covered in detail the implementation of this file in the book, so
    be sure to check the attached source files to understand better how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the webpack configuration file, we need to add both an output path to indicate
    where the bundled files will be placed and the new entry file we just created,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all that it is left is to create a build task in our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and check the built files into the `dist` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Static code analysis: JSHint'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the first chapter, JavaScript is not a compiled language, but running
    the code (as in the case of automated testing) is not the only way to check for
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: A whole class of tools is able to read source files, interpret them, and look
    for common errors or bad practices without needing to actually run the source
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very popular tool is **JSHint**—a simple binary that can also be installed
    through NPM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are also installing **JSXHint**, another tool to perform
    static analysis of JSX files. It is basically a wrapper around the original JSHint
    while performing the JSX transformations.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, JSXTransformer doesn't change the
    line numbers, so a warning in a given line number on a JavaScript file will be
    in the same line number in the original JSX file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute them is very simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also a good idea to have them running whenever we run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is configuring what errors we want JSHint and JSXHint to catch.
    Once again, we create another configuration file at the root folder of our project,
    this time called `.jshintrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a list of option flags either being enabled or disabled, where the
    most important are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`esnext`: This flag tells us we are using the ES6 version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unused`: This flag breaks on any unused declared variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undef`: This option flag breaks on any variable being used without being declared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a list of `globals` variables used by the tests to prevent errors
    due to the `undef` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the JSHint website at [http://jshint.com/docs/options/](http://jshint.com/docs/options/)
    for a complete list of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing step is preventing the linter from running in other people''s
    code (Jasmine, React, and so on). This is possible by simply creating a file with
    the folders it should ignore. This file called `.jshintignore` should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the static analysis and all the tests is now as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Continuous integration – Travis-CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a great deal of automation around the project, which is great
    for onboarding a new developer on the team; running the test is just two commands
    away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: However, that is not the only advantage; we can have the tests running via these
    same two commands while on a continuous integration environment.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate a possible setup, we are going to use Travis-CI ([https://travis-ci.org](https://travis-ci.org)),
    a free solution for open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start, it is required that you have a GitHub ([https://github.com/](https://github.com/))
    account and that the project is already hosted there. I expect that you are already
    familiar with git ([http://www.git-scm.com/](http://www.git-scm.com/)) and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are ready, we can start the Travis-CI setup.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a project to Travis-CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can add Travis-CI support to the project, first we need to add the
    project to Travis-CI.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Travis-CI website at [https://travis-ci.org](https://travis-ci.org)
    and click on **Sign in with GitHub** in the top-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your GitHub credentials and once you have signed in, it should show you
    the list with all your repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: If your repository doesn't show up, you can click on the **Sync Now** button
    to make Travis-CI update the list.
  prefs: []
  type: TYPE_NORMAL
- en: Once your repository appears, enable it by clicking on the switch. This will
    set up hooks on your GitHub project, so Travis-CI gets notified on any change
    pushed to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up a Travis-CI project couldn't be simpler. Since we have our build
    process and tests all scripted, all we have to do is tell Travis-CI what runtime
    it should use.
  prefs: []
  type: TYPE_NORMAL
- en: Travis-CI knows that Node.js project dependencies are installed through `npm
    install` and that tests are run through `npm test`, so there is no extra step
    to get our tests running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file at the project root directory called `.travis.yml` and configure
    the language for Travis as Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And that is all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: The steps taken to use Travis-CI were pretty straightforward, and it should
    be pretty simple to apply these same concepts to other continuous integration
    environments, such as Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I hope to have showed you the power of automation and how we
    can use scripts to make our life easier. You learned about webpack and how it
    can be used to manage the dependencies between your modules and help you generate
    the production code (packed and minified).
  prefs: []
  type: TYPE_NORMAL
- en: The power of static code analysis in helping us find bugs even before the code
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: You have also seen how to run your specs headlessly, and even automatically,
    letting you focus on the code editor all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have seen how simple it is to use a continuous integration environment
    and how we can use this powerful concept to keep our projectsalways tested.
  prefs: []
  type: TYPE_NORMAL
