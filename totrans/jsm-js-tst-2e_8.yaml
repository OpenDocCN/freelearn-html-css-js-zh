- en: Chapter 8. Build Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 构建自动化
- en: We saw how to create an application from the ground up using tests with Jasmine.
    However, as the application grows and the number of files starts to increase,
    managing the dependencies between them can become a little difficult.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用Jasmine测试从头开始创建一个应用程序。然而，随着应用程序的增长和文件数量的增加，管理它们之间的依赖关系可能会变得有些困难。
- en: 'For instance, we have a dependency between the Investment and Stock models,
    and they must be loaded in a proper order to work. So, we do what we can; we order
    the loading of the scripts so that Stock is available once Investment is loaded.
    Here''s how we do it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，投资模型和股票模型之间存在依赖关系，它们必须按正确的顺序加载才能工作。因此，我们尽我们所能；我们按顺序加载脚本，以便在投资加载后股票可用。下面是如何做到这一点的示例：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, that can soon become cumbersome and unmanageable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这很快就会变得繁琐且难以管理。
- en: Another problem is the number of requests the application uses to load all of
    its files; it can get up to hundreds once the application starts to grow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在加载所有文件时应用程序使用的请求数量；一旦应用程序开始增长，它可能达到数百。
- en: So, we have a paradox here; although it is good to break it up into small modules
    for code maintainability, it is bad for the client performance, where a single
    file is much more desirable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里遇到了一个悖论；虽然将代码拆分成小模块对于代码可维护性是有好处的，但对于客户端性能来说却是不利的，因为单个文件更受欢迎。
- en: 'A perfect world would be to match the following two requirements at the same
    time:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的世界是同时满足以下两个要求：
- en: In development, we have a bunch of small files containing different modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中，我们有一堆包含不同模块的小文件
- en: In production, we have a single file with the content of all those modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中，我们有一个包含所有这些模块内容的单个文件
- en: Clearly, what we need is some sort of build process. There are many different
    ways to achieve these goals with JavaScript, but we are going to focus on **webpack**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要某种构建过程。使用JavaScript实现这些目标有几种不同的方法，但我们将专注于**webpack**。
- en: Module bundler – webpack
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块打包器 – webpack
- en: Webpack is a module bundler created by Tobias Koppers to help create big and
    modular frontend JavaScript applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack是由Tobias Koppers创建的一个模块打包器，旨在帮助创建大型和模块化的前端JavaScript应用程序。
- en: Its main difference from other solutions is its support for any type of module
    system (AMD and CommonJS), languages (CoffeeScript, TypeScript, and JSX) and even
    assets (images and templates) through loaders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它与其他解决方案的主要区别在于它支持任何类型的模块系统（AMD和CommonJS），语言（CoffeeScript、TypeScript和JSX）以及通过加载器甚至资产（图像和模板）。
- en: You read it right, even images; if in a React application, everything is a component,
    in a webpack project, everything is a module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有看错，即使是图像；如果在React应用程序中，一切都是组件，在webpack项目中，一切都是模块。
- en: It builds a dependency graph of all your assets, serving them in a development
    environment and optimizing them for production.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它构建了所有资产的依赖关系图，在开发环境中提供服务，并针对生产环境进行优化。
- en: Module definition
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块定义
- en: JavaScript is a language based on the ECMA Script specification that, until
    version 6, still didn't have a standard definition of a module. This lack of formal
    standards led to a number of competing community standards (AMD and CommonJS)
    and implementations (RequireJS and browserify).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种基于ECMA Script规范的编程语言，直到版本6之前，还没有模块的标准定义。这种缺乏正式标准导致了多个竞争性的社区标准（AMD和CommonJS）和实现（RequireJS和browserify）。
- en: Now, there is a standard to follow, but unfortunately there is no support for
    it in modern browsers, so which style should we use to write our modules?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个标准可以遵循，但不幸的是，在现代浏览器中并没有对其的支持，所以我们应该使用哪种风格来编写我们的模块？
- en: The good news is that it is possible to use ES6 today through transpilers, which
    gives us a future-proof advantage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，现在可以通过转译器使用ES6，这给我们带来了未来保障的优势。
- en: A popular transpiler is **Babel** ([http://babeljs.io/](http://babeljs.io/)),
    which we are going to use with webpack through a loader.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的转译器是**Babel**([http://babeljs.io/](http://babeljs.io/))，我们将通过加载器与webpack一起使用。
- en: 'We''ll see how to use it with webpack in a moment, but first it is important
    to understand what makes an ES6 module. Here is a simple definition without any
    dependency:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到如何与webpack一起使用它，但首先重要的是要理解是什么让ES6模块成为可能。下面是一个没有依赖关系的简单定义：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s compare it to the way we''ve been declaring modules until now. The next
    example shows how that code would be if written using the conventions presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与我们之前声明模块的方式进行比较。下一个示例显示了如果使用第 3 章（[第 3 章](ch03.html "第 3 章。测试前端代码")）中提出的约定编写的代码将会是什么样子：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The biggest difference is the lack of an IIFE. An ES6 module, by default, has
    a scope of its own, so it is impossible to pollute the global namespace by accident.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别是缺少 IIFE。ES6 模块默认具有自己的作用域，因此不可能意外地污染全局命名空间。
- en: 'The second difference is that the module value is no longer being attached
    to the global object, but instead being exported as the default module value:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是模块值不再附加到全局对象上，而是作为默认模块值导出：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Regarding a module''s dependencies, up until now, everything was globally available,
    so we passed the dependencies to the module as parameters to the IIFE, as shown
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块的依赖项，到目前为止，所有内容都是全局可用的，因此我们将依赖项作为 IIFE（立即执行函数表达式）的参数传递给模块，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, as you start using ES6 modules on the project, there will be no more
    global variables. So, how do you get those dependencies into the module?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你在项目中开始使用 ES6 模块，将不再有全局变量。那么，你如何将这些依赖项放入模块中？
- en: 'If you remember from before, the ES6 example was exporting the module value
    through the `export default` syntax. So, given a module has a value, all we have
    to do is ask for it as a dependency. Let''s add the jQuery dependency to our ES6
    module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的内容，ES6 示例是通过 `export default` 语法导出模块值的。所以，给定一个模块有一个值，我们只需要将其作为依赖项请求。让我们将
    jQuery 依赖项添加到我们的 ES6 模块中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `$` represents the name of the variable the dependency will be loaded
    into, and `jQuery` is the filename.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$` 代表将加载依赖项的变量名称，而 `jQuery` 是文件名。
- en: It is also possible to export multiple values as the result of a module and
    import these values into different variables, but for the scope of this book,
    default values will suffice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将多个值作为模块的结果导出，并将这些值导入不同的变量中，但就本书的范围而言，默认值就足够了。
- en: The ES6 standard introduces a number of different constructs to the JavaScript
    language that are also beyond the scope of this book. For more information, check
    Babel's excellent documentation at [http://babeljs.io/docs/learn-es6/](http://babeljs.io/docs/learn-es6/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 标准向 JavaScript 语言引入了许多不同的结构，这些结构也超出了本书的范围。有关更多信息，请参阅 Babel 的优秀文档[http://babeljs.io/docs/learn-es6/](http://babeljs.io/docs/learn-es6/)。
- en: Webpack project setup
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack 项目设置
- en: Webpack is available as an NPM package, and its setup is very simple as it is
    going to be demonstrated in the next sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 作为 NPM 包可用，其设置非常简单，将在下一节中演示。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to understand the difference between NPM and Node.js. NPM is
    both a package manager and a package format, while Node.js is a platform that
    NPM modules usually run.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 NPM 和 Node.js 之间的区别很重要。NPM 既是包管理器也是包格式，而 Node.js 是一个平台，NPM 模块通常在其中运行。
- en: Managing dependencies with NPM
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NPM 管理依赖项
- en: We already got an embryo of a Node.js project, but as we are going to start
    using more dependencies throughout this chapter, we are going to need a formal
    definition of all the NPM packages that the project depends on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了一个 Node.js 项目的雏形，但随着我们在本章中开始使用更多依赖项，我们需要正式定义项目所依赖的所有 NPM 包。
- en: 'To define the project as an NPM package, and at the same time all of its dependencies,
    we need to create a special file called `package.json` at the root folder of the
    application. It can be easily created through a single command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要将项目定义为 NPM 包，同时包含其所有依赖项，我们需要在应用程序的根目录中创建一个特殊文件 `package.json`。它可以通过单个命令轻松创建：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It will prompt for a number of questions about the project that can all be
    left with their default values. In the end, you should have a file with content
    similar to the following output depending on your folder name:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提示一系列关于项目的问题，所有这些问题都可以保留它们的默认值。最后，你应该有一个包含类似以下内容的文件，具体取决于你的文件夹名称：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to install all of our dependencies, which, at the moment, is
    only express.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装所有依赖项，目前只有 express。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous command will not only install express as described in [Chapter
    4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"), *Asynchronous Testing
    – AJAX*, but will also add it as a dependency to the `package.json` file. On running
    the `npm init` command as done previously, we get the following output showing
    the `dependencies` attribute:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令不仅会安装第4章中描述的express，*异步测试 - AJAX*，还会将其添加到`package.json`文件的依赖项中。运行`npm init`命令（如之前所述）后，我们得到以下输出，显示了`dependencies`属性：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we understand how to manage the dependencies of our project, we can
    install **webpack** and **Babel** as development dependencies to start bundling
    our modules, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何管理我们项目的依赖关系，我们可以将**webpack**和**Babel**作为开发依赖项安装，以开始捆绑我们的模块，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final step is to add a script in `package.json` to start the development
    server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`package.json`中添加一个脚本来启动开发服务器：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This allows us to start the development server with a simple command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用简单的命令启动开发服务器：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual location of the `webpack-dev-server` executable is in the `./node_modules/.bin`
    folder. So, `npm run dev` is the same as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack-dev-server`可执行文件的实际位置在`./node_modules/.bin`文件夹中。因此，`npm run dev`与以下命令相同：'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It works because when you run `npm run <scriptName>`, NPM adds the `./node_modules/.bin`
    folder to the path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为当你运行`npm run <scriptName>`时，NPM会将`./node_modules/.bin`文件夹添加到路径中。
- en: Webpack configuration
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Webpack配置
- en: 'Next, we need to configure webpack so that it knows what files to bundle. This
    can be achieved by creating a `webpack.config.js` file at the root folder of the
    project. Its content should be:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置webpack，使其知道要捆绑哪些文件。这可以通过在项目的根目录下创建一个`webpack.config.js`文件来实现。其内容应该是：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are a few key points about this configuration file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此配置文件有几个要点：
- en: The `context` directive tells webpack to look for modules in `__dirname`, meaning
    the project's root folder.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`指令告诉webpack在`__dirname`中查找模块，这意味着项目的根目录。'
- en: The `entry` directive specifies the application's entry points. Since we are
    only doing testing at the moment, there is a single entry point named `spec` that
    refers to all of our spec files.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`指令指定了应用程序的入口点。由于我们目前只进行测试，因此有一个名为`spec`的单个入口点，它引用了所有规范文件。'
- en: The `output.filename` directive is here to inform the filename of each of the
    entry points. The `[name]` pattern will be replaced by an entry point name on
    compilation. So `spec.js` will actually contain all of our spec code.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output.filename`指令用于告知每个入口点的文件名。在编译过程中，`[name]`模式将被入口点名称替换。因此，`spec.js`实际上将包含我们所有的规范代码。'
- en: The `module.loaders` final directive tells webpack how to deal with different
    file types. We are using the `babel-loader` parameter here to add support for
    ES6 modules and the JSX syntax on our source files. The `exclude` directive is
    important so as not to waste compiling any dependency from the `node_modules`
    folder.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.loaders`的最终指令告诉webpack如何处理不同类型的文件。在这里，我们使用`babel-loader`参数来为源文件添加对ES6模块和JSX语法的支持。`exclude`指令很重要，以免浪费编译`node_modules`文件夹中的任何依赖。'
- en: With this setup completed, you can start the development server and check what
    the transpiled bundle looks like at `http://localhost:8080/spec.js` (the filename
    defined in the configuration file).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此设置后，您可以通过访问`http://localhost:8080/spec.js`（配置文件中定义的文件名）来检查转换后的捆绑包的外观。
- en: At this point, the webpack configuration is complete, and we can move to adapt
    the Jasmine runner to run the specs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，webpack配置已经完成，我们可以开始将Jasmine运行器适配以运行规范。
- en: The spec runner
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范运行器
- en: 'As stated previously, we are using webpack to compile and bundle the source
    files, so the Jasmine spec is about to become a lot simpler:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用webpack来编译和捆绑源文件，因此Jasmine规范将变得非常简单：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few takeaways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: First, we no longer need the JSX transformer hack explained in the previous
    chapter; the transformation is now done by webpack and the babel-loader. As a
    result, we can use the default Jasmine boot just fine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不再需要上一章中解释的JSX转换器黑客技巧；转换现在由webpack和babel-loader完成。因此，我们可以很好地使用默认的Jasmine引导。
- en: Second, we've chosen to leave the test runner dependencies as global (Jasmine,
    Mock Ajax, Jasmine JQuery, and the Spec helper). Leaving them global makes things
    a lot simpler for our test runner, and we don't hurt our code as far as modularity
    is concerned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们选择将测试运行器的依赖项作为全局（Jasmine、Mock Ajax、Jasmine JQuery和Spec helper）。将它们设置为全局使我们的测试运行器变得更加简单，并且从模块化的角度来看，我们不会伤害我们的代码。
- en: At this moment, trying to run the tests at `http://localhost:8080/SpecRunner.html`
    should produce a lot of fails due to missing references. That is because we still
    need to convert our specs and sources into ES6 modules.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，尝试在`http://localhost:8080/SpecRunner.html`运行测试应该会因为缺少引用而产生很多失败。这是因为我们仍然需要将我们的spec和源文件转换为ES6模块。
- en: Testing a module
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个模块
- en: 'To be able to run all the tests requires that all the source and spec files
    be converted into ES6 modules. At the specs, it means adding, as dependencies
    all the source modules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行所有测试，需要将所有源文件和spec文件转换为ES6模块。在spec中，这意味着添加所有源模块作为依赖项：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the source files, it means declaring all the dependencies as well as exporting
    its default value, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件中，这意味着声明所有依赖项以及导出其默认值，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once all the code is converted, the tests should work upon starting the development
    server and pointing the browser once again to the runner URL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有代码都转换为，在启动开发服务器并将浏览器再次指向运行器URL时，测试应该会工作。
- en: 'Test runner: Karma'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行器：Karma
- en: Remember we said back in the introduction that we could execute Jasmine without
    the need of a browser window? To do so, we are going to use **PhantomJS**, a scriptable
    headless WebKit browser (the same rendering engine that powers the Safari browser)
    and **Karma**, a test runner.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在介绍中提到过，我们可以执行Jasmine而不需要浏览器窗口？为了做到这一点，我们将使用**PhantomJS**，一个可脚本化的无头WebKit浏览器（与Safari浏览器相同的渲染引擎）和**Karma**，一个测试运行器。
- en: 'The setup is very simple; using NPM, we once again install some dependencies:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设置非常简单；使用NPM，我们再次安装一些依赖项：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only strange dependency here is the `es5-shim`, which is used to give PhantomJS
    support for some ES5 features that it still is missing, and React requires.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的奇怪依赖是`es5-shim`，它用于为PhantomJS提供一些它仍然缺少的ES5功能，而React需要。
- en: 'The next step is creating a configuration file, named `karma.conf.js`, for
    Karma at the project''s'' root folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个配置文件，命名为`karma.conf.js`，位于项目的根目录：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In it, we set up the Jasmine framework and the PhantomJS browser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们设置了Jasmine框架和PhantomJS浏览器：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fix the browser compatibility issues on PhantomJS by loading `es5-shim`, as
    shown in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加载`es5-shim`来修复PhantomJS上的浏览器兼容性问题，如下代码所示：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Load the test runner dependencies, which were previously global in the `SpecRunner.html`
    file, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 加载测试运行器依赖项，这些依赖项之前在`SpecRunner.html`文件中是全局的，如下代码所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, load all the specs, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加载所有spec，如下所示：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By now, you can remove the `SpecRunner.html` file, the spec entry in the `webpack.config.js`
    file, and the `lib/jasmine-2.1.3` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以删除`SpecRunner.html`文件，`webpack.config.js`文件中的spec条目，以及`lib/jasmine-2.1.3`文件夹。
- en: 'Run the tests by invoking Karma, which will print the test results in the console,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用Karma来运行测试，它将在控制台打印测试结果，如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make it simpler to run the tests, it is possible to change the `package.json`
    project file and describe its test script:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试的运行，我们可以更改`package.json`项目文件并描述其测试脚本：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can then run the tests by simply invoking the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地调用以下命令来运行测试：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Quick feedback loop
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速反馈循环
- en: Automated testing is all about the quick feedback loop, so imagine being able
    to have the tests running in the console and the application refreshing on the
    browser after any file change. Would that be possible? The answer is yes!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的核心是快速反馈循环，所以想象一下，在文件更改后，测试能在控制台运行，而应用在浏览器上刷新，这会是可能的吗？答案是肯定的！
- en: Watch and run the tests
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视并运行测试
- en: 'Via a simple parameter while starting Karma, we can achieve testing nirvana,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在启动Karma时使用一个简单的参数，我们可以实现测试的极乐境界，如下所示：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Try it by yourself; run this command, change a file, and see the tests running
    automatically—like magic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 亲自尝试；运行此命令，更改一个文件，看看测试是否自动运行——就像魔法一样。
- en: 'Once again, we don''t want to remember these complicated commands, so let''s
    add another script to the `package.json` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们不想记住这些复杂的命令，所以让我们在`package.json`文件中添加另一个脚本：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run it through the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令来运行它：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Watch and update the browser
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视并更新浏览器
- en: To achieve development nirvana, we are also just a parameter away.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到开发上的极乐境界，我们只需一个参数即可。
- en: 'While starting the development server, add the following to the `package.json`
    file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动开发服务器时，将以下内容添加到`package.json`文件中：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, try it on your browser; change a file in the text editor and the
    browser should refresh.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试在你的浏览器上运行；在文本编辑器中更改一个文件，浏览器应该刷新。
- en: You are also encouraged to update the `package.json` file with these new parameters
    so that running `npm run dev` gets you the goodness of "live reload".
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还被鼓励更新`package.json`文件，以便运行`npm run dev`时获得“实时重新加载”的好处。
- en: Optimizing for production
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化生产环境
- en: The final step of our module bundler goal is to generate a minified and ready-for-production
    file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块打包器目标的最后一步是生成一个压缩并准备好生产的文件。
- en: Most of the configuration is complete, missing just a few more steps.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的配置已经完成，只需再进行几个步骤。
- en: 'The first step is to set up an entry point for the application, then an index
    file that will start it all, `index.js`, is to be placed inside the `src` folder
    with the contents as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是为应用程序设置一个入口点，然后创建一个启动所有内容的索引文件，`index.js`，需要放置在`src`文件夹内，内容如下：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We haven't covered in detail the implementation of this file in the book, so
    be sure to check the attached source files to understand better how it works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中没有详细讨论此文件的实现，所以请确保检查附带的源文件以更好地理解其工作原理。
- en: 'In the webpack configuration file, we need to add both an output path to indicate
    where the bundled files will be placed and the new entry file we just created,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在webpack配置文件中，我们需要添加一个输出路径来指示捆绑文件将放置的位置，以及我们刚刚创建的新入口文件，如下所示：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, all that it is left is to create a build task in our `package.json` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，剩下的就是在我们`package.json`文件中创建一个构建任务：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run it and check the built files into the `dist` folder, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，并检查构建文件是否已放入`dist`文件夹，如下所示：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Static code analysis: JSHint'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析：JSHint
- en: As stated in the first chapter, JavaScript is not a compiled language, but running
    the code (as in the case of automated testing) is not the only way to check for
    errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一章所述，JavaScript不是一种编译型语言，但运行代码（如自动化测试的情况）并不是检查错误的唯一方式。
- en: A whole class of tools is able to read source files, interpret them, and look
    for common errors or bad practices without needing to actually run the source
    files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一类工具能够读取源文件，解释它们，并在不实际运行源文件的情况下查找常见的错误或不良实践。
- en: 'A very popular tool is **JSHint**—a simple binary that can also be installed
    through NPM, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常流行的工具是**JSHint**——一个可以通过NPM安装的简单二进制文件，如下所示：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see that we are also installing **JSXHint**, another tool to perform
    static analysis of JSX files. It is basically a wrapper around the original JSHint
    while performing the JSX transformations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们还在安装**JSXHint**，这是另一个用于执行JSX文件静态分析的工具。它基本上是在执行JSX转换的同时，围绕原始JSHint的一个包装器。
- en: If you remember from the previous chapter, JSXTransformer doesn't change the
    line numbers, so a warning in a given line number on a JavaScript file will be
    in the same line number in the original JSX file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得上一章的内容，JSXTransformer不会改变行号，所以JavaScript文件中给定行号的警告将在原始JSX文件中的相同行号处。
- en: 'To execute them is very simple, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行它们非常简单，如下所示：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, it is also a good idea to have them running whenever we run the tests:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行测试时让它们运行也是一个好主意：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The final step is configuring what errors we want JSHint and JSXHint to catch.
    Once again, we create another configuration file at the root folder of our project,
    this time called `.jshintrc`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是配置我们希望JSHint和JSXHint捕获的错误。再次，我们在项目的根目录中创建另一个配置文件，这次叫做`.jshintrc`：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is a list of option flags either being enabled or disabled, where the
    most important are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个选项标志列表，要么启用要么禁用，其中最重要的是以下内容：
- en: '`esnext`: This flag tells us we are using the ES6 version'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`esnext`：此标志告诉我们我们正在使用ES6版本'
- en: '`unused`: This flag breaks on any unused declared variable'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unused`：此标志会在任何未使用的声明变量上断言'
- en: '`undef`: This option flag breaks on any variable being used without being declared'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undef`：此选项标志会在任何未声明的变量被使用时断言'
- en: There is also a list of `globals` variables used by the tests to prevent errors
    due to the `undef` flag.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个由测试使用的`globals`变量列表，用于防止由于`undef`标志导致的错误。
- en: Head over to the JSHint website at [http://jshint.com/docs/options/](http://jshint.com/docs/options/)
    for a complete list of options.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 JSHint 网站 [http://jshint.com/docs/options/](http://jshint.com/docs/options/)
    查看选项的完整列表。
- en: 'The only missing step is preventing the linter from running in other people''s
    code (Jasmine, React, and so on). This is possible by simply creating a file with
    the folders it should ignore. This file called `.jshintignore` should contain:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的步骤是防止在别人的代码中运行 linter（Jasmine、React 等等）。这可以通过简单地创建一个包含它应该忽略的文件夹的文件来实现。这个名为
    `.jshintignore` 的文件应该包含：
- en: '`node_modules`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node_modules`'
- en: '`lib`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`'
- en: 'To run the static analysis and all the tests is now as simple as this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行静态分析和所有测试就像这样简单：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Continuous integration – Travis-CI
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成 – Travis-CI
- en: 'We have created a great deal of automation around the project, which is great
    for onboarding a new developer on the team; running the test is just two commands
    away:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目周围创建了很多自动化，这对团队中引入新开发者非常有用；运行测试只需两个命令：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, that is not the only advantage; we can have the tests running via these
    same two commands while on a continuous integration environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一的好处；我们可以在持续集成环境中通过这两个命令运行测试。
- en: To demonstrate a possible setup, we are going to use Travis-CI ([https://travis-ci.org](https://travis-ci.org)),
    a free solution for open source projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个可能的设置，我们将使用 Travis-CI ([https://travis-ci.org](https://travis-ci.org))，这是一个开源项目的免费解决方案。
- en: Before we can start, it is required that you have a GitHub ([https://github.com/](https://github.com/))
    account and that the project is already hosted there. I expect that you are already
    familiar with git ([http://www.git-scm.com/](http://www.git-scm.com/)) and GitHub.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，你需要有一个 GitHub ([https://github.com/](https://github.com/)) 账户，并且项目已经托管在那里。我预计你已经熟悉
    git ([http://www.git-scm.com/](http://www.git-scm.com/)) 和 GitHub。
- en: Once you are ready, we can start the Travis-CI setup.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，我们就可以开始 Travis-CI 的设置了。
- en: Adding a project to Travis-CI
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将项目添加到 Travis-CI
- en: Before we can add Travis-CI support to the project, first we need to add the
    project to Travis-CI.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将 Travis-CI 支持添加到项目中之前，首先我们需要将项目添加到 Travis-CI。
- en: Go to the Travis-CI website at [https://travis-ci.org](https://travis-ci.org)
    and click on **Sign in with GitHub** in the top-right corner.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 Travis-CI 网站 [https://travis-ci.org](https://travis-ci.org)，然后在右上角点击 **Sign
    in with GitHub**。
- en: 'Enter your GitHub credentials and once you have signed in, it should show you
    the list with all your repositories:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的 GitHub 凭据，一旦你登录，它应该会显示包含你所有仓库的列表：
- en: If your repository doesn't show up, you can click on the **Sync Now** button
    to make Travis-CI update the list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的仓库没有显示出来，你可以点击右上角的 **Sync Now** 按钮让 Travis-CI 更新列表。
- en: Once your repository appears, enable it by clicking on the switch. This will
    set up hooks on your GitHub project, so Travis-CI gets notified on any change
    pushed to the repository.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的仓库出现，通过点击开关来启用它。这将在你 GitHub 项目上设置钩子，这样 Travis-CI 就会在仓库中任何更改推送时收到通知。
- en: Project setup
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设置
- en: Setting up a Travis-CI project couldn't be simpler. Since we have our build
    process and tests all scripted, all we have to do is tell Travis-CI what runtime
    it should use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Travis-CI 项目非常简单。由于我们的构建过程和测试都已脚本化，我们只需要告诉 Travis-CI 它应该使用什么运行时。
- en: Travis-CI knows that Node.js project dependencies are installed through `npm
    install` and that tests are run through `npm test`, so there is no extra step
    to get our tests running.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Travis-CI 知道 Node.js 项目依赖是通过 `npm install` 安装的，测试是通过 `npm test` 运行的，因此没有额外的步骤来运行我们的测试。
- en: 'Create a new file at the project root directory called `.travis.yml` and configure
    the language for Travis as Node.js:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为 `.travis.yml` 的新文件，并将 Travis 的语言配置为 Node.js：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And that is all there is to it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: The steps taken to use Travis-CI were pretty straightforward, and it should
    be pretty simple to apply these same concepts to other continuous integration
    environments, such as Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Travis-CI 的步骤相当直接，将这些相同的概念应用到其他持续集成环境中，如 Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/))，应该相当简单。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I hope to have showed you the power of automation and how we
    can use scripts to make our life easier. You learned about webpack and how it
    can be used to manage the dependencies between your modules and help you generate
    the production code (packed and minified).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我希望已经向你展示了自动化的力量以及我们如何可以使用脚本使我们的生活变得更轻松。你学习了webpack及其如何被用来管理模块之间的依赖关系，并帮助你生成生产代码（打包和压缩）。
- en: The power of static code analysis in helping us find bugs even before the code
    runs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析在帮助我们甚至在代码运行之前发现错误方面的力量。
- en: You have also seen how to run your specs headlessly, and even automatically,
    letting you focus on the code editor all the time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了如何无头运行你的规范，甚至可以自动运行，让你可以一直专注于代码编辑器。
- en: Finally, we have seen how simple it is to use a continuous integration environment
    and how we can use this powerful concept to keep our projectsalways tested.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了使用持续集成环境是多么简单，以及我们如何可以使用这个强大的概念来确保我们的项目始终处于测试状态。
