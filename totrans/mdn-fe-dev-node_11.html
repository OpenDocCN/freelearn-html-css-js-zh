<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor105"/>11</h1>
<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor106"/>Using Alternative Runtimes</h1>
<p lang="en-GB">So far, you’ve seen what advantages and benefits the Node.js ecosystem offers to create great web applications. However, as with almost everything, there are a few downsides to the design decisions forming what we refer to as Node.js.</p>
<p lang="en-GB">One of the biggest challenges in Node.js is the so-called <em class="italic" lang="">dependency hell</em> – where many small packages are put together to create a slightly larger package. Another challenge is that Node.js is not guarding any of these dependencies from accessing system resources. As such, importing anything from a third-party package may have unwanted side effects.</p>
<p lang="en-GB">While ecosystem reliability and security can help us guard against dependency hell, improving performance is also an important strategy. Overall, the performance of Node.js can be regarded as decent; however, certain areas such as package resolution or processor core utilization could be improved by a fair share. Hence, performance is another area that could be regarded as a downside.</p>
<p lang="en-GB">In this chapter, you’ll get to know the two most popular alternative runtimes for mitigating some of the disadvantages that come with Node.js. To evaluate these alternatives in depth, we will keep a closer eye on their compatibility status with the existing Node.js ecosystem.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Exploring the Deno runtime</li>
<li lang="en-GB">Using Bun for bundling web apps</li>
</ul>
<h1 id="_idParaDest-108" lang="en-GB"><a id="_idTextAnchor107"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter11</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3Uqi9aq">https://bit.ly/3Uqi9aq</a>.</p>
<h1 id="_idParaDest-109" lang="en-GB"><a id="_idTextAnchor108"/>Exploring the Deno runtime</h1>
<p lang="en-GB">While Node.js is a <a id="_idIndexMarker392"/>tremendous success story, not everyone is a fan. Some critics say that the huge fragmentation combined with the lack of system controls offers too great an attack surface. In the past, we’ve seen countless attacks that have abused the vulnerabilities introduced by exactly this problem.</p>
<p lang="en-GB">Another issue is that Node.js did have to invent a lot of APIs – for example, to interact with the filesystem. There was no API available in the browser that looked similar to what was desired. Of course, as we now know, the browser APIs kept improving and even things such as filesystem access are implemented there. However, the APIs never aligned, mostly because the variants for Node.js are neither controllable nor fully asynchronous.</p>
<p lang="en-GB">Surely, the aforementioned problems were all known for a while, but it took several years until an alternative implementation to solve these issues appeared. Again, it was Ryan Dahl – the original creator of Node.js – who worked on the solution. The solution is called <strong class="bold" lang="">Deno</strong>.</p>
<p lang="en-GB">The main benefits <a id="_idIndexMarker393"/>of Deno are as follows:</p>
<ul>
<li lang="en-GB">It introduces system access controls to allow or block access to resources such as the filesystem.</li>
<li lang="en-GB">It uses explicit imports instead of magically resolved ones – no more implied package lookups or index files.</li>
<li lang="en-GB">It tries to be interchangeable with the browser – bringing exclusively native browser APIs instead of custom ones.</li>
<li lang="en-GB">It features first-class TypeScript support, not only improving the development experience but also strengthening the reliability of written code.</li>
<li lang="en-GB">It comes with handy tooling, such as an application bundler out of the box – reducing the need to install dependencies for starting development.</li>
</ul>
<p lang="en-GB">Under the hood, Deno uses the Rust programming language instead of C++. Here, the choice was made to avoid any potential memory leaks or vulnerabilities that are just a bit more likely with C++ than <strong class="bold" lang="">Rust</strong>. This<a id="_idIndexMarker394"/> also means that <em class="italic" lang="">libuv</em>, which is the main driver for Node.js as discussed in <a href="B18989_01.xhtml#_idTextAnchor015"><em class="italic" lang="">Chapter 1</em></a>, <em class="italic" lang="">Learning about the Internals of Node.js</em>, is gone. Instead, Deno uses another event loop system <a id="_idIndexMarker395"/>called <strong class="bold" lang="">Tokio</strong>. Still, both runtimes <a id="_idIndexMarker396"/>use <strong class="bold" lang="">V8</strong> to actually run JavaScript.</p>
<p class="callout-heading" lang="en-GB">Tokio</p>
<p class="callout" lang="en-GB">Tokio is an asynchronous runtime for Rust applications providing everything needed for interacting with networks. It is reliable, fast, and flexible. Besides being Rust-native, one of the core reasons for Deno to use Tokio was that it is also quite easy to integrate. Tokio comes with I/O helpers, timers, filesystem access, synchronization, and scheduling capabilities, making it a<a id="_idIndexMarker397"/> complete libuv replacement. More information can be found at <a href="https://tokio.rs/">https://tokio.rs/</a>.</p>
<p lang="en-GB">The architecture <a id="_idIndexMarker398"/>of Deno is shown in <em class="italic" lang="">Figure 11</em><em class="italic" lang="">.1</em>. Notably, the diagram is almost an exact match for <em class="italic" lang="">Figure 1</em><em class="italic" lang="">.1</em>, which showed the architecture of Node.js. The most striking difference is the acceptance of TypeScript, which will be translated into JavaScript by a combination of <code>swc</code> (transpilation) and <code>tsc</code> (type checking). Another crucial difference is the additional isolation layer:</p>
<div><div><img alt=" Figure 11.1 – The architecture of Deno " src="img/Figure_11.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 11.1 – The architecture of Deno</p>
<p lang="en-GB">The installation of Deno can be done on the command line. For instance, on macOS and Linux, you can just run the following Shell script:</p>
<pre class="console" lang="en-GB">
$ curl -fsSL https://deno.land/x/install/install.sh | sh</pre>
<p lang="en-GB">Whereas on Windows, you can use the PowerShell for this:</p>
<pre class="console" lang="en-GB">
$ irm https://deno.land/install.ps1 | iex</pre>
<p lang="en-GB">Alternative installations for common application package managers such as Scoop, Chocolatey, or Homebrew exist, too.</p>
<p lang="en-GB">To try Deno, you can run the following script:</p>
<pre class="console" lang="en-GB">
$ deno run https://deno.land/std/examples/welcome.ts

Download <img alt="" src="img/023.png"/> https://deno.land/std/examples/welcome.ts

Warning Implicitly using latest version (0.159.0) for https://deno.land/std/examples/welcome.ts

Welcome to Deno!</pre>
<p lang="en-GB">There are a couple of things happening already. First, we are not using a local source to run, but an <a id="_idIndexMarker399"/>address. Second, since this is an address, the source needs to be downloaded. Third, Deno always prefers to receive explicit versions, so it will complain that we just used whatever version of <code>stdlib</code> here. Instead, it redirects to the latest version, which was <code>0.159.0</code> at the time of writing.</p>
<p lang="en-GB">Finally, if you run the script again, you’ll just see the output without any download or warning. This is due to Deno’s cache. In order to stay well performing, every downloaded module is assumed to be immutable and will be cached locally. Future references will therefore not require another download, which makes their startup time acceptable.</p>
<p lang="en-GB">The big question is now: can Deno also just run Node.js libraries and applications? The unsatisfying answer is maybe. In theory, just JavaScript files can be used – however, Deno only supports ESM modules. Since many Node.js libraries are written using CommonJS, we would not have any success here.</p>
<p lang="en-GB">As mitigation, we could just transpile a package – bundle it into one file and run it without any trouble – but even then, we might face the issue of incompatibility with the ecosystem, as standard packages such as <code>fs</code> are available in Node.js but not in Deno.</p>
<p lang="en-GB">A better way out of this is to use the <em class="italic" lang="">Node compatibility mode</em> of Deno. Before version <em class="italic" lang="">1.25</em>, it worked by running <code>deno</code> with the <code>--unstable</code> and <code>--compat</code> flags. Right now, Deno seems to only allow this via custom imports. Let’s try this out to see it in action. For this, you can create a new Node.js project with a single third-party package and some code using it:</p>
<pre class="console" lang="en-GB">
$ npm init -y

$ npm install axios --save</pre>
<p lang="en-GB">To test this, the <a id="_idIndexMarker400"/>following code provides a solid basis:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.node.mjs</p>
<pre class="source-code" lang="en-GB">import axios from 'axios';
import { writeFile } from 'fs/promises';
const { data } = await
  axios.get('https://jsonplaceholder.typicode.com/photos');
const thumbnails = data.map(item =&gt; item.thumbnailUrl);
const content = JSON.stringify(thumbnails, undefined, 2);
await writeFile('thumbnails.json', content, 'utf8');</pre>
<p lang="en-GB">The code uses a third-party dependency made for Node.js together with a Node.js core module. It also makes use of modern features such as top-level <code>await</code> statements.</p>
<p lang="en-GB">You can try running this with Node.js to see it working, but more interesting is the case of running this with Deno:</p>
<pre class="console" lang="en-GB">
$ deno run index.node.mjs

error: Relative import path "axios" not prefixed with / or ./ or ../

    at file:///home/node/examples/example01/index.mjs:1:19</pre>
<p lang="en-GB">As mentioned, by default, Deno requires explicit paths. Without them, Deno does not work. Let’s modify this code to reflect the compatibility:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">index.deno.mjs</p>
<pre class="source-code" lang="en-GB">import axios from 'npm:axios';
import { writeFile } from
  'https://deno.land/std@0.159.0/node/fs/promises.ts';
const { data } = await
  axios.get('https://jsonplaceholder.typicode.com/photos');
const thumbnails = data.map(item =&gt; item.thumbnailUrl);
const content = JSON.stringify(thumbnails, undefined, 2);
await writeFile('thumbnails.json', content, 'utf8');</pre>
<p lang="en-GB">While the majority of the preceding code remains unchanged in comparison to <code>index.node.mjs</code>, the imports have been adapted slightly. The referenced npm packages need to be referenced using the <code>npm:</code> protocol. For Node.js core modules, we can refer to <a id="_idIndexMarker401"/>the <code>std/node</code> modules provided by Deno.</p>
<p lang="en-GB">Now, we can run the code with the <code>–</code><code>unstable</code> flag:</p>
<pre class="console" lang="en-GB">
$ deno run --unstable index.deno.mjs

<img alt="" src="img/017.png"/> Granted env access to "npm_config_no_proxy".

<img alt="" src="img/017.png"/> Granted env access to "NPM_CONFIG_NO_PROXY".

<img alt="" src="img/017.png"/> Granted env access to "no_proxy".

<img alt="" src="img/017.png"/> Granted env access to "NO_PROXY".

<img alt="" src="img/017.png"/> Granted env access to "npm_config_https_proxy".

<img alt="" src="img/017.png"/> Granted env access to "NPM_CONFIG_HTTPS_PROXY".

<img alt="" src="img/017.png"/> Granted env access to "https_proxy".

<img alt="" src="img/017.png"/> Granted env access to "HTTPS_PROXY".

<img alt="" src="img/017.png"/> Granted env access to "npm_config_proxy".

<img alt="" src="img/017.png"/> Granted env access to "NPM_CONFIG_PROXY".

<img alt="" src="img/017.png"/> Granted env access to "all_proxy".

<img alt="" src="img/017.png"/> Granted env access to "ALL_PROXY".

<img alt="" src="img/017.png"/> Granted read access to "/home/rapplf/.cache/deno/npm/node_modules".

<img alt="" src="img/017.png"/> Granted read access to "/home/rapplf/.cache/deno/node_modules".

<img alt="" src="img/017.png"/> Granted read access to "/home/rapplf/.cache/node_modules".

<img alt="" src="img/017.png"/> Granted read access to "/home/rapplf/node_modules".

<img alt="" src="img/017.png"/> Granted read access to "/home/node_modules".

<img alt="" src="img/017.png"/> Granted read access to "/node_modules".

<img alt="" src="img/017.png"/> Granted net access to "jsonplaceholder.typicode.com".

<img alt="" src="img/017.png"/> Granted write access to "thumbnails.json".</pre>
<p lang="en-GB">As we did not <a id="_idIndexMarker402"/>provide any additional CLI flags, Deno will run in a mode where every resource request will be reflected by a question on the command line. In the session here, every request was confirmed with <em class="italic" lang="">yes</em>, granting the access request.</p>
<p lang="en-GB">Alternatively, we could have used a Deno feature that we discussed already in <a href="B18989_02.xhtml#_idTextAnchor023"><em class="italic" lang="">Chapter 2</em></a>, <em class="italic" lang="">Dividing Code into Modules and Packages</em>, while discussing import maps. Let’s try to run our <em class="italic" lang="">unmodified</em> file again with the following import map:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">importmap.json</p>
<pre class="source-code" lang="en-GB">{
  "imports": {
      "axios": "npm:axios",
      "fs/promises":
        "https://deno.land/std@0.159.0/node/fs/promises.ts"
    }
}</pre>
<p lang="en-GB">The job of the import map is to teach Deno what to look for. Originally, Deno could not make sense of an import to <code>axios</code>, but now it knows that this should be resolved via npm. Similarly, the core Node.js packages can be added in there, too.</p>
<p lang="en-GB">This time, we set the <code>--allow-all</code> flag to skip all the access confirmations:</p>
<pre class="console" lang="en-GB">
$ deno run --unstable --import-map=importmap.json --allow-all index.node.mjs</pre>
<p lang="en-GB">And… it just works. No more work needed – all done with Deno primitives. Of course, quite often full compatibility cannot be achieved so easily.</p>
<p lang="en-GB">While Deno is <a id="_idIndexMarker403"/>mostly focused on security, a presumably even more interesting area is performance. This is where another alternative shines, which is called Bun.</p>
<h1 id="_idParaDest-110" lang="en-GB"><a id="_idTextAnchor109"/>Using Bun for bundling web apps</h1>
<p lang="en-GB">While Deno<a id="_idIndexMarker404"/> seems quite different from Node.js on first <a id="_idIndexMarker405"/>glance, it also offers a lot of similarities. After all, both runtimes use V8 and can work with ESMs, but what if you want to be even more compatible with Node.js? Another approach is to be Node.js-compatible without using libuv or V8 at all. Enter <strong class="bold" lang="">Bun</strong>.</p>
<p lang="en-GB">Bun is an alternative to Node.js that follows the approach of Deno in terms of developer friendliness. Here, tooling such as a npm client or an application bundler is also included out of the box. However, to speed things up significantly, Bun does not use libuv and V8. Instead, Bun is created using the programming<a id="_idIndexMarker406"/> language <strong class="bold" lang="">Zig</strong> and uses <strong class="bold" lang="">JavaScriptCore</strong> as <a id="_idIndexMarker407"/>its JavaScript runtime. JavaScriptCore is also the runtime behind<a id="_idIndexMarker408"/> the <strong class="bold" lang="">Webkit</strong> browser engine, empowering browsers such <a id="_idIndexMarker409"/>as <strong class="bold" lang="">Safari</strong>.</p>
<p lang="en-GB">The main benefits of Bun are as follows:</p>
<ul>
<li lang="en-GB">It comes with<a id="_idIndexMarker410"/> useful utilities out of the box, such as a bundler, a transpiler, a package manager, and a task runner.</li>
<li lang="en-GB">It outperforms Node.js, especially in terms of startup performance or request handling.</li>
<li lang="en-GB">It embraces the Node.js ecosystem, but also includes some standard web APIs such as <code>fetch</code> or <code>WebSocket</code>.</li>
</ul>
<p lang="en-GB">A comparison of the high-level architecture of Node.js and Bun is shown in <em class="italic" lang="">Figure 11</em><em class="italic" lang="">.2</em>. Most<a id="_idIndexMarker411"/> importantly, while<a id="_idIndexMarker412"/> extra tools such as a package manager or a bundler are required with Node.js, Bun comes with batteries already included. All these tools are available after installation – and since all of these tools are integrated into the Bun executable, they provide the best performance possible:</p>
<div><div><img alt="Figure 11.2 – High-level comparison of Node.js and Bun " src="img/Figure_11.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – High-level comparison of Node.js and Bun</p>
<p lang="en-GB">As with Deno, Bun<a id="_idIndexMarker413"/> can<a id="_idIndexMarker414"/> be installed via a Shell script. At the time of writing, Bun is not available as a direct installation for Windows. Instead, you’ll need to fall back to the <strong class="bold" lang="">Windows Subsystem for Linux</strong> (<strong class="bold" lang="">WSL</strong>) if <a id="_idIndexMarker415"/>you want to try out Bun.</p>
<p lang="en-GB">To install Bun on macOS and Linux, you can run the following Shell script:</p>
<pre class="console" lang="en-GB">
$ curl https://bun.sh/install | bash</pre>
<p lang="en-GB">Running a simple example (<code>hello.ts</code>) with Bun looks as follows:</p>
<pre class="console" lang="en-GB">
$ bun run hello.ts

Hello from Bun!</pre>
<p lang="en-GB">In the preceding example, the code is really simple – just using the console output here:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">hello.ts</p>
<pre class="source-code" lang="en-GB">console.log('Hello from Bun!');</pre>
<p lang="en-GB">An interesting aspect of Bun is that it also has the ability to automatically create a server. If we use<a id="_idIndexMarker416"/> a <a id="_idIndexMarker417"/>default export with a <code>fetch</code> function, then Bun will create a server, which, by default, runs on port <code>3000</code>. The port can also be changed by having another property called <code>port</code> in there:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">http.ts</p>
<pre class="source-code" lang="en-GB">export default {
  fetch() {
    return new Response("Hello from Bun!");
  },
};</pre>
<p lang="en-GB">Calling <code>bun run http.ts</code> will open the server. To see the result, go to the <code>http://localhost:3000</code> address using your browser.</p>
<p lang="en-GB">Finally, let’s use Bun as a bundler for the small demo project we did in <a href="B18989_06.xhtml#_idTextAnchor057"><em class="italic" lang="">Chapter 6</em></a>. The first thing you should notice is that you don’t need any development dependencies – just the runtime ones. Also, instead of running <code>npm install</code> or similar, you should resolve the dependencies via <code>bun install</code>:</p>
<pre class="console" lang="en-GB">
$ bun install

bun install v0.1.13

 + react@18.2.0

 + react-dom@18.2.0

 + react-router-dom@6.4.2

 + video.js@7.21.0

 32 packages installed [2.21s]</pre>
<p lang="en-GB">Frankly, <code>react</code>, <code>react-dom</code>, <code>react-router-dom</code>, and <code>video.js</code> comprise only four packages, but their installation speed is still quite good. Now, it’s time to bundle the JavaScript code:</p>
<pre class="console" lang="en-GB">
$ bun bun src/script.tsx

[...]

  2.34 MB JavaScript

       58 modules

       20 packages

 107.61k LOC parsed

     62ms elapsed

 Saved to ./node_modules.bun</pre>
<p lang="en-GB">The result is <a id="_idIndexMarker418"/>quite <a id="_idIndexMarker419"/>different to the bundlers we’ve seen beforehand. We get a single file, <code>node_modules.bun</code>, which contains the resulting JavaScript, as well as all the associated metadata. The file itself is an executable – ready to spit out the contained code.</p>
<p lang="en-GB">Extracting the JavaScript contained in the <code>node_modules.bun</code> file can be done by running the executable – and piping the output to a JavaScript file. For instance, see the following:</p>
<pre class="console" lang="en-GB">
$ ./node_modules.bun &gt; dist/app.js</pre>
<p lang="en-GB">Is this sufficient for all our bundling needs? Certainly not. Right now, the integrated bundler is essentially ignoring our code and only bundling together the code from the external packages sitting in the <code>node_modules</code> directory. However, even if our code was bundled, the process is not really ideal. Currently, Bun only considers JavaScript, TypeScript, JSON, and CSS files. There is no way to include assets such as images or videos.</p>
<p lang="en-GB">For the future, all these capabilities are planned. While Bun (in version <em class="italic" lang="">0.1.13</em>) is still experimental technology, what is out there is promising. All things considered, it’s certainly <a id="_idIndexMarker420"/>something <a id="_idIndexMarker421"/>to keep on the radar, but nothing that can be actively used to create production-ready code.</p>
<p lang="en-GB">Let’s recap what you’ve learned in this chapter.</p>
<h1 id="_idParaDest-111" lang="en-GB"><a id="_idTextAnchor110"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned why alternatives to Node.js exists and what the most popular options are. You’ve explored what Deno is all about and how it distinguishes itself from Node.js. You’ve also seen an up-and-coming alternative with Bun.</p>
<p lang="en-GB">Equipped with this knowledge, you are not only capable of writing tools that might be able to run in other runtimes than Node.js but you are also capable of deciding where your existing tools should run. Overall, this does not constrain you to the disadvantages of Node.js and gives you freedom to make the right choice aligned with the problem you want to solve.</p>
<h1 id="_idParaDest-112" lang="en-GB"><a id="_idTextAnchor111"/>Epilogue</h1>
<p lang="en-GB">In general, it makes sense to view Node.js as a great helper for getting the job done. The whole ecosystem – from its module system to its command-line utilities and from its libraries to its frameworks – is vast. Almost every problem has been cracked and a solution has been published.</p>
<p lang="en-GB">I hope that with this book, you have a proper guide to walk you through the jungle of available helpers, making you not only a more efficient user of Node.js but also a contributor. While the existing tools are all helpful and powerful, they are certainly not the end of the line. Everyone has a unique view and things progress all the time. Don’t wait for somebody else to solve a problem – tackle it yourself and share your solution.</p>
<p lang="en-GB">All the best!</p>
</div>
</body></html>