["```js\n|____.babelrc\n|____db.json\n|____server.js\n|____store.js\n|____jest.config.js\n|____tests\n| |____server.test.js\n| |____fixtures.js\n| |____store.test.js\n| |____utils.js\n|____index.js\n|____public\n| |____index.html\n| |____styles.css\n| |____app.js\n| |____people.jpg\n|____package-lock.json\n|____package.json\n|____.nvmrc\n|____views\n| |____about.ejs\n```", "```js\nnpm install express@4 body-parser@1\n```", "```js\nimport express from 'express'\nimport bodyParser from 'body-parser'\nconst app = express()\napp.use(bodyParser.json())\napp.get('/api/v1/whisper', (req, res) => {\n    res.json([])\n})\napp.get('/api/v1/whisper/:id', (req, res) => {\n    const id = parseInt(req.params.id)\n    res.json({ id })\n})\napp.post('/api/v1/whisper', (req, res) => {\n    res.status(201).json(req.body)\n})\napp.put('/api/v1/whisper/:id', (req, res) => {\n  //const id = parseInt(req.params.id)\n  res.sendStatus(200)\n})\napp.delete('/api/v1/whisper/:id', (req, res) => {\n    res.sendStatus(200)\n})\nexport { app }\n```", "```js\nimport { app } from \"./server.js\";\nconst port = 3000\napp.listen(port, () => {\n    console.log(`Running in http://localhost:${port}`)\n})\n```", "```js\n{\n    \"scripts\": {\n        \"start\": \"node index.js\"\n    }\n}\n```", "```js\nimport fs from 'node:fs/promises'\nimport path from 'node:path'\nconst filename = path.join(process.cwd(), 'db.json')\nconst saveChanges = data => fs.writeFile(filename, JSON.stringify(data))\nconst readData = async () => {\n    const data = await fs.readFile(filename, 'utf-8')\n    return JSON.parse(data)\n}\nconst getAll = readData\nconst getById = async (id) => {\n    const data = await readData()\n    return data.find(item => item.id === id)\n}\nconst create = async (message) => {\n    const data = await readData()\n    const newItem = { message, id: data.length +1}\n    await saveChanges(data.concat([newItem]))\n    return newItem\n}\nconst updateById = async (id, message) => {\n    const data = await readData()\n    const newData = data.map(current => {\n        if(current.id === id) {\n            return { ...current, message }\n        }\n        return current\n    })\n    await saveChanges(newData)\n}\nconst deleteById = async id => {\n    const data = await readData()\n    await saveChanges(data\n.filter(current => current.id !== id)\n    )\n}\nexport { getAll, getById, create, updateById, deleteById }\n```", "```js\nimport { getAll, getById, create, updateById, deleteById } from '../store.js'\nimport { writeFileSync } from 'node:fs'\nimport { join } from 'node:path'\nconst dbPath = join(process.cwd(), 'db.json')\nconst restoreDb = () => writeFileSync(dbPath, JSON.stringify([]))\nconst populateDb = (data) => writeFileSync(dbPath, JSON.stringify(data))\nconst fixtures = [{ id: 1, message: 'test' }, { id: 2, message: 'hello world' }]\nconst inventedId = 12345\nconst existingId = fixtures[0].id\ndescribe('store', () => {\n    beforeEach(() => populateDb(fixtures))\n    afterAll(restoreDb)\n    // Here we will be the tests\n})\n```", "```js\ndescribe('getAll', () => {\n    it(\"Should return an empty array when there's no data\", async () => {\n        restoreDb()\n        const data = await getAll()\n        expect(data).toEqual([])\n    })\n    it('Should return an array with one item when there is one item', async () => {\n        const data = await getAll()\n        expect(data).toEqual(fixtures)\n    })\n})\n```", "```js\ndescribe('getById', () => {\n    it('Should return undefined when there is no item with the given id', async () => {\n        const item = await getById(inventedId)\n        expect(item).toBeUndefined()\n    })\n    it('Should return the item with the given id', async () => {\n        const item = await getById(fixtures[0].id)\n        expect(item).toEqual(fixtures[0])\n    })\n})\n```", "```js\ndescribe('create', () => {\n    it('Should return the created item', async () => {\n        const newItem = { id: fixtures.length + 1, message: 'test 3' }\n        const item = await create(newItem.message)\n        expect(item).toEqual(newItem)\n    })\n    it('Should add the item to the db', async () => {\n        const newItem = { id: fixtures.length + 1, message: 'test 3' }\n        const { id } = await create(newItem.message)\n        const item = await getById(id)\n        expect(item).toEqual(newItem)\n    })\n})\n```", "```js\ndescribe('updateById', () => {\n    it('Should return undefined when there is no item with the given id', async() => {\n        const item = await updateById(inventedId)\n        expect(item).toBeUndefined()\n    })\n    it('Should not return the updated item', async () => {\n        const updatedItem = { id: existingId, message: 'updated' }\n        const item = await updateById(updatedItem.id, updatedItem.message)\n        expect(item).toBeUndefined()\n    })\n    it('Should update the item in the db', async () => {\n        const updatedItem = { id: existingId, message: 'updated' }\n        await updateById(updatedItem.id, updatedItem.message)\n        const item = await getById(existingId)\n        expect(item).toEqual(updatedItem)\n    })\n})\n```", "```js\ndescribe('deleteById', () => {\n    it('Should return undefined when there is no item with the given id', async () => {\n        const item = await deleteById(inventedId)\n        expect(item).toBeUndefined()\n    })\n    it('Should not return the deleted item', async () => {\n        const item = await deleteById(existingId)\n        expect(item).toBeUndefined()\n    })\n    it('Should delete the item from the db', async () => {\n        await deleteById(existingId)\n        const items = await getAll()\n        expect(items).toEqual(fixtures.filter(item => item.id !== existingId))\n    })\n})\n```", "```js\n{\n    \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\",\n        \"test:coverage\": \"jest --coverage\"\n    }\n}\n```", "```js\n{\n    \"scripts\": {\n        \"start\": \"node index.js\",\n        \"test\": \"jest\",\n        \"test:coverage\": \"jest --coverage\",\n        \"lint\": \"standard\",\n        \"lint:fix\": \"standard --fix\"\n    }\n}\n```", "```js\nconst app = express()\napp.use(express.static('public'))\napp.use(bodyParser.json())\n```", "```js\nnpm i ejs@3\n```", "```js\nimport express from 'express'\nimport bodyParser from 'body-parser'\nimport { getAll, getById, create, updateById, deleteById } from './store.js'\nconst app = express()\n```", "```js\napp.use(bodyParser.json())\napp.set('view engine', 'ejs')\napp.get('/api/v1/whisper', async (req, res) => {\n    const whispers = await getAll()\n    res.json(whispers)\n})\n```", "```js\napp.set('view engine', 'ejs')\napp.get('/about', async (req, res) => {\n    const whispers = await getAll()\n    res.render('about', { whispers })\n})\napp.get('/api/v1/whisper', async (req, res) => {/*...*/})\n```", "```js\napp.get('/api/v1/whisper', async (req, res) => {\n    const whispers = await getAll()\n    res.json(whispers)\n})\n```", "```js\napp.get('/api/v1/whisper/:id', async (req, res) => {\n    const id = parseInt(req.params.id)\n    const whisper = await getById(id)\n    if (!whisper) {\n        res.sendStatus(404)\n    } else {\n        res.json(whisper)\n    }\n})\n```", "```js\napp.post(\"/api/v1/whisper\", async (req, res) => {\n  const { message } = req.body;\n  if (!message) {\n    res.sendStatus(400);\n  } else {\n    const whisper = await create(message);\n    res.status(201).json(whisper);\n  }\n});\n```", "```js\napp.put('/api/v1/whisper/:id', async (req, res) => {\n    const { message } = req.body\n    const id = parseInt(req.params.id)\n    if(!message) {\n        res.sendStatus(400)\n    } else {\n        const whisper = await getById(id);\n        if (!whisper) {\n            res.sendStatus(404);\n        } else {\n            await updateById(id, message);\n            res.sendStatus(200);\n        }\n    }\nPOST /api/v1/whisper and we validate that the whisper exists before updating it. Now, let’s refactor the DELETE /api/v1/whisper/:id route:\n\n```", "```js\n\n\t\t\tIn this case, we validate that the whisper exists before deleting it. Now, let’s add the tests for the routes.\n\t\t\tCreating test utils\n\t\t\tBefore we start adding the tests, there is some code that we can reuse between the test files, such as the fixtures and the functions to populate and restore the database. So, let’s do a little refactoring first.\n\t\t\tAs the first step, let’s create a file called `fixtures.js` in the `tests` folder, and let’s add the following content:\n\n```", "```js\n\n\t\t\tThen, create a file called `utils.js` in the `tests` folder, and let’s add the following content:\n\n```", "```js\n\n\t\t\tNow, let’s refactor the `store.test.js` file to use the new files:\n\n```", "```js\n\n\t\t\tAlso, find and replace the `fixtures` variable with `whispers` in the tests.\n\t\t\tNow you can run the tests with `npm run test` and you will see that the tests are passing:\n\t\t\t![Figure 11.3 – Terminal screenshot](img/B21678_11_3.jpg)\n\n\t\t\tFigure 11.3 – Terminal screenshot\n\t\t\tAdding server tests\n\t\t\tNow, let’s add the tests for the routes. In this case, we will use supertest ([https://www.npmjs.com/package/supertest](https://www.npmjs.com/package/supertest)) to test the routes. As the first step, let’s install the new dependency:\n\n```", "```js\n\n\t\t\tDefining the tests\n\t\t\tYou can use `it.todo` to mark the tests that you need to add. This way, you can focus on the description of the tests and not on the implementation details. So, let’s create the `tests/server.test.js` file with the following content:\n\n```", "```js\n\n\t\t\tRun the tests with the `npm run` `test` command:\n\t\t\t![Figure 11.4 – Terminal screenshot](img/B21678_11_4.jpg)\n\n\t\t\tFigure 11.4 – Terminal screenshot\n\t\t\tYou will see that the previous tests pass, and the new tests are marked as *todo*. This is a good practice to keep track of the tests that you need to add, and it does not break the test suite.\n\t\t\tAdding the tests with supertest\n\t\t\tBasically, we will use supertest to make requests to the server and we will validate the response. Let’s start with the `GET /api/v1/whisper` route. Let’s replace the `it.todo` tests with the following code:\n\n```", "```js\n\n\t\t\tIn each request, we check that the status code and the response payload are correct. Now, let’s add the tests for the `GET /``api/v1/whisper/:id` route:\n\n```", "```js\n\n\t\t\tAs you can see, the tests are very similar to the ones we did for `storage.test.js`. Now, let’s add the tests for the `POST /``api/v1/whisper` route.\n\t\t\tWe will start by adding the parent description for the route:\n\n```", "```js\n\n\t\t\tAll the tests will be added inside the `describe` function. So, let’s define all the scenarios that we want to cover in the tests:\n\t\t\tWe want to be sure that we return a 400 status code when the request does not include a body:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 400 status code when the request does not include a proper body, for example, when some required properties are missing:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 201 status and the details of the new whisper when the payload in the request is correct. Also, we want to check that the whisper was properly stored in the database:\n\n```", "```js\n\n\t\t\tAs you can see, when we created a new whisper we also validated that the whisper was added to the database. This is because these tests are integration tests and we want to make sure that the changes are recorded in the *database* as well.\n\t\t\tNow, let’s add the tests for the `PUT /api/v1/whisper/:id` route. We will start by adding the parent description for the route:\n\n```", "```js\n\n\t\t\tAll the tests will be added inside the `describe` function. So, let’s define all the scenarios that we want to cover in the tests:\n\t\t\tWe want to be sure that we return a 400 status code when the request does not include a body:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 400 status code when the request does not include a proper body, for example, when some required properties are missing:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 404 status code when the request is targeting a non-existent whisper:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 200 status when the payload and the target are correct. Also, we want to check that the whisper was properly updated in the database:\n\n```", "```js\n\n\t\t\tFinally, let’s add the tests for the `DELETE /api/v1/whisper/:id` route. We will start by adding the parent description for the route:\n\n```", "```js\n\n\t\t\tAll the tests will be added inside the `describe` function. So, let’s define all the scenarios that we want to cover in the tests:\n\t\t\tWe want to be sure that we return a 404 status code when the request is targeting a non-existent whisper:\n\n```", "```js\n\n\t\t\tWe want to be sure that we return a 200 status code when the request is targeting a valid whisper. Also, we want to check that the whisper was properly removed from the database:\n\n```", "```js\n\n\t\t\tNow, you can run the tests with `npm run test` and you will see that the tests are passing:\n\t\t\t![Figure 11.5 – Terminal screenshot](img/B21678_11_5.jpg)\n\n\t\t\tFigure 11.5 – Terminal screenshot\n\t\t\tInformation\n\t\t\tIf you are having issues running the project in this chapter while following the steps, or you tried an alternative approach, you can use the `step2` folder from the source code that you downloaded at the beginning of the chapter to compare and fix possible bugs more easily.\n\t\t\tIn the next section, we will review the final result and we will see how to use the application and what we are planning to do in the next chapters.\n\t\t\tReviewing the final result of the project\n\t\t\tAt this point, you should have a fully functional REST API with Express and if your tests are passing, you can start using the application.\n\t\t\tThe about page\n\t\t\tIf you go to `http://localhost:3000/about`, you will see the about page:\n\t\t\t![Figure 11.6 – Web browser screenshot](img/B21678_11_6.0.jpg)\n\n\t\t\tFigure 11.6 – Web browser screenshot\n\t\t\tThis page was served using the server render approach, and we are using the EJS template engine to render the page. We are using the whispers data from the database to render the page. The text *Currently there are 3 whispers available* is dynamic text that will change depending on the number of whispers in the database.\n\t\t\tYou can see the reference in the `views/about.ejs` file:\n\n```", "```js\n\n\t\t\tWeb interface\n\t\t\tThe web interface is a simple page where you can create, update, and delete whispers. You can access the web interface at `http://localhost:3000`. It will start with an empty list of whispers. In my case, I have three whispers in the database, so I will see the following page:\n\t\t\t![Figure 11.7 – Web browser screenshot](img/B21678_11_7.0.jpg)\n\n\t\t\tFigure 11.7 – Web browser screenshot\n\t\t\tIn order to make the frontend source code more readable, I used plain JavaScript to make the requests to the API and old browser APIs such as `prompts` and `confirms` to interact with the user. You can see the source code in the `public/app.js` file. For a production application, you should avoid these browser APIs as they are quite limited and implement a solution that works on all devices using UI elements that are properly integrated. Also, you will need to handle errors and loading states. For larger projects, it is quite common to use UI libraries such as tailwind ([https://tailwindcss.com/](https://tailwindcss.com/)) or frameworks such as Vue ([https://vuejs.org/](https://vuejs.org/)).\n\t\t\tAdding whispers\n\t\t\tIt is possible to add whispers to the list. Just click on the **Spread a whisper** button and you will see a prompt asking for the message of the whisper:\n\t\t\t![Figure 11.8 – Web browser screenshot](img/B21678_11_8.0.jpg)\n\n\t\t\tFigure 11.8 – Web browser screenshot\n\t\t\tEditing whispers\n\t\t\tIt is possible to edit whispers. Just click on the pencil button and you will see a prompt asking for the new message of the whisper:\n\t\t\t![Figure 11.9 – Web browser screenshot](img/B21678_11_9.0.jpg)\n\n\t\t\tFigure 11.9 – Web browser screenshot\n\t\t\tDeleting whispers\n\t\t\tIt is possible to delete whispers. Just click on the trash button and you will see a confirm dialog asking for the confirmation:\n\t\t\t![Figure 11.10 – Web browser screenshot](img/B21678_11_10.jpg)\n\n\t\t\tFigure 11.10 – Web browser screenshot\n\t\t\tYour challenge\n\t\t\tIf you are familiar with frontend development, you can try to improve the web interface and make it more user-friendly or directly replace it with a modern frontend framework such as React, Vue, or Angular. If you are not familiar with front-end development, you can skip this challenge and continue with the next chapter.\n\t\t\tLet’s celebrate it!\n\t\t\tFeel free to explore the code and play with it, you can start the application with `npm run start` and you can go to `http://localhost:3000` and create a few whispers that you can later edit or remove from the web interface.\n\t\t\tNext steps\n\t\t\tCongratulations! You have created a solid REST API, but there are a lot of things that you can do to improve it. In the next chapter, we will see how to properly store the information in the database.\n\t\t\tIn [*Chapter 13*](B21678_13.xhtml#_idTextAnchor348), we will see how to add authentication to the API, so only authenticated users can create, update, or delete whispers and multiple users will be able to use our application.\n\t\t\tSummary\n\t\t\tIn this chapter, we learned how to use supertest to test our API in depth. We learned how to test the routes and how to test the stores. We created a solid API that we will evolve in the next chapters.\n\t\t\tIn the next chapter, we will see how to properly store the information in the database, using MongoDB. We will take the opportunity to refactor our project and use a better software pattern to organize the code and a MongoDB database to store the data.\n\n```"]