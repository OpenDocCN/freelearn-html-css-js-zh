<html><head></head><body>
		<div><h1 id="_idParaDest-323"><a id="_idTextAnchor373"/>Appendix</h1>
		</div>
		<div><h1 id="_idParaDest-324"><a id="_idTextAnchor374"/>1. TypeScript Fundamentals</h1>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor375"/><a id="_idTextAnchor376"/>Activity 1.01: Creating a Library for Working with Strings</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Here are the steps that will help you create all the functions listed in the activity problem statement.</p>
			<h3 id="_idParaDest-326"><a id="_idTextAnchor377"/>toTitleCase</h3>
			<p>The <code>toTitleCase</code> function will process a string and capitalize the first letter of each word, but will make all the other letters lowercase.</p>
			<p>Test cases for this function are as follows:</p>
			<pre>"war AND peace" =&gt; "War And Peace"
"Catcher in the Rye" =&gt; "Catcher In The Rye"
 "tO kILL A mOCKINGBIRD" =&gt; "To Kill A MockingBird"</pre>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li><a id="_idTextAnchor378"/>This function will take a single parameter that is a string and return a string as well:<pre>function toTitleCase (input:string) : string {</pre></li>
				<li>First off, we will split the input into an array of strings using the split string method. We'll split on every space character:<pre>    // split the string into an array on every occurrence of 
    //  the space character     const words = input.split(" ");</pre></li>
				<li>Next, we will define a new array that will hold each word as we transform it into title case, and use a for..of loop to loop through the array of words:<pre>    const titleWords = [];    // loop through each word     for (const word of words) {</pre></li>
				<li>For each word we will extract the first character and the rest of the characters using the slice string method. We will transform the initial to uppercase, and the rest of the characters to lowercase. Next, we'll join them back together to form a complete word and push the result to the holding array:<pre>    // take the first character using `slice` and convert it to uppercase     const initial = word.slice(0, 1).toLocaleUpperCase();    // take the rest of the character using `slice` and convert them to lowercase     const rest = word.slice(1).toLocaleLowerCase();    // join the initial and the rest and add them to the resulting array     titleWords.push(`${initial}${rest}`);</pre></li>
				<li>At last, we will join all the processed words together, with a separating space, and we have our result:<pre>    // join all the processed words     const result = titleWords.join(" ");    return result;}</pre></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<pre>console.log(`toTitleCase("war AND peace"):`);console.log(toTitleCase("war AND peace")); console.log(`toTitleCase("Catcher in the Rye"):`);console.log(toTitleCase("Catcher in the Rye"));console.log(`toTitleCase("tO kILL A mOCKINGBIRD"):`);console.log(toTitleCase("tO kILL A mOCKINGBIRD"));</pre></li>
				<li>We should receive the results:<pre>toTitleCase("war AND peace"):War And Peace toTitleCase("Catcher in the Rye"):Catcher In The Rye toTitleCase("tO kILL A mOCKINGBIRD"):To Kill A Mockingbird</pre></li>
			</ol>
			<h3 id="_idParaDest-327"><a id="_idTextAnchor379"/>countWords<a id="_idTextAnchor380"/></h3>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">The countWords function will count the number of separate words within a string. Words are delimited by spaces, dashes (-), or underscores (_). Test cases for this function are as follows:<pre>"War and Peace" =&gt; 3 
"catcher-in-the-rye" =&gt; 4 
"for_whom the-bell-tolls" =&gt; 5</pre></li>
				<li>Create the <code>countWords</code> function using the following code:<pre>function countWords (input: string): number {</pre></li>
				<li>Split the words using a regex that will match any occurrence of a space, underscore, or dash character:   <pre>    const words = input.split(/[ _-]/);</pre></li>
				<li>Return the length of the array that is the result of the split:<pre>    return words.length;
}</pre></li>
				<li>Test the function and console out the results:<pre>console.log(`countWords("War and Peace"):`);
console.log(countWords("War and Peace"));
 
console.log(`countWords("catcher-in-the-rye"):`);
console.log(countWords("catcher-in-the-rye"));
console.log(`countWords("for_whom the-bell-tolls"):`);
console.log(countWords("for_whom the-bell-tolls"));</pre></li>
			</ol>
			<h3 id="_idParaDest-328"><a id="_idTextAnchor381"/>toWords</h3>
			<p>The <code>toWords</code> function will return all the words that are within a string. Words are delimited by spaces, dashes (<code>-</code>), or underscores (<code>_</code>).</p>
			<p>Test cases for this function are as follows:</p>
			<pre>"War and Peace" =&gt; [War, and, peace]
"catcher-in-the-rye" =&gt; [catcher, in, the, rye]
"for_whom the-bell-tolls" =&gt; [for, whom, the, bell, tolls]</pre>
			<p>This function is very similar to the previous one we developed. The significant difference is that we need to return not only the number of words but also the actual words themselves. So, instead of a number, this function will return an array of strings:</p>
			<ol>
				<li value="1">Here is the code to create this function:<pre>function toWords (input: string): string[] {</pre></li>
				<li>Once more, we will need to split the input into an array of strings using the split string method, using the [ _-] regular expression. Split the words using a regular expression that will match any occurrence of a space, underscore, or dash character:<pre>   const words = input.split(/[ _-]/);</pre></li>
				<li>Once we have the words, we can just return them:<pre>    // return the words that were split     return words;}</pre></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<pre>console.log(`toWords("War and Peace"):`);console.log(toWords("War and Peace")); console.log(`toWords("catcher-in-the-rye"):`);console.log(toWords("catcher-in-the-rye"));console.log(`toWords("for_whom the-bell-tolls"):`);console.log(toWords("for_whom the-bell-tolls"));</pre></li>
				<li>We should receive the results:<pre>toWords("War and Peace"):[ 'War', 'and', 'Peace' ]toWords("catcher-in-the-rye"):[ 'catcher', 'in', 'the', 'rye' ]toWords("for_whom the-bell-tolls"):[ 'for', 'whom', 'the', 'bell', 'tolls' ]</pre></li>
			</ol>
			<h3 id="_idParaDest-329"><a id="_idTextAnchor382"/><a id="_idTextAnchor383"/>repeat</h3>
			<p><code>repeat</code> will take a string and a number and return that same string repeated that number of times.</p>
			<p>Test cases for this function are as follows:</p>
			<pre>„War", 3 =&gt; „WarWarWar"
„rye", 1 =&gt; „rye"
„bell", 0 =&gt; „"</pre>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take two parameters, one that is a string and a second one that is a number, and return a string as well:<pre>function repeat (input: string, times: number): string {</pre><p>There are many ways to implement this function, and we'll illustrate one approach. We can create an array with the required number of elements, and then use the array's <code>fill</code> method to fill it with the value of the string. In that way, we will have an array of <code>times</code> elements, and each element will have the <code>input</code> value:</p><pre>    // create a new array that with length of `times`    // and set each element to the value of the `input` string     const instances = new Array(times).fill(input);</pre></li>
				<li>Next, we just need to join all the instances, using an empty string as the delimiter. That way, we're making sure that no spaces or commas are inserted between the strings:<pre>    // join the elements of the array together     const result = instances.join("");    return result;}</pre></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<pre>console.log(`repeat("War", 3 ):`);console.log(repeat("War", 3 )); console.log(`repeat("rye", 1):`);console.log(repeat("rye", 1));console.log(`repeat("bell", 0):`);console.log(repeat("bell", 0));</pre></li>
				<li>We should receive the following results:<pre>repeat("War", 3 ):WarWarWar repeat("rye", 1):rye repeat("bell", 0):</pre></li>
			</ol>
			<h3 id="_idParaDest-330"><a id="_idTextAnchor384"/><a id="_idTextAnchor385"/>isAlpha</h3>
			<p><code>isAlpha</code> returns <code>true</code> if the string only has alpha characters (that is, letters). Test cases for this function are as follows:</p>
			<pre>"War and Peace" =&gt; false
"Atonement" =&gt; true
"1Q84" =&gt; false</pre>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take a single parameter that is a string and return a Boolean:<pre>function isAlpha (input: string): boolean {</pre></li>
				<li>For this function to work, we need to check whether each character is a lower- or uppercase letter. One of the best ways to determine that is to use a regular expression that checks it. In particular, the character group [a-z] will check for a single character and if we use the star quantifier (*), we can tell the regular expression to check for all the characters. We can add the i modifier to the regular expression to make the match case-insensitive, so we don't need to worry about letter casing:<pre>// regex that will match any string that only has upper and  //lowercase letters     const alphaRegex = /^[a-z]*$/i</pre></li>
				<li>Next, we need to actually test our input. Since we only need to know whether the string matches, we can use the test method of the regular expression and return its result:<pre>    // test our input using the regex     const result = alphaRegex.test(input);    return result;}</pre></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<pre>console.log(`isAlpha("War and Peace"):`);console.log(isAlpha("War and Peace")); console.log(`isAlpha("Atonement"):`);console.log(isAlpha("Atonement"));console.log(`isAlpha("1Q84"):`);console.log(isAlpha("1Q84"));</pre></li>
				<li>We should receive the results:<pre>isAlpha("War and Peace"):false isAlpha("Atonement"):true isAlpha("1Q84"):false</pre></li>
			</ol>
			<h3 id="_idParaDest-331"><a id="_idTextAnchor386"/><a id="_idTextAnchor387"/>isBlank</h3>
			<p><code>isBlank</code> returns <code>true</code> if the string is blank, that is, it consists only of whitespace characters.</p>
			<p>Test cases for this function are as follows:</p>
			<pre>"War and Peace" =&gt; false
"       " =&gt; true
"" =&gt; true</pre>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take a single parameter that is a string and return a Boolean:<pre>function isBlank (input: string): boolean {</pre></li>
				<li>For this function to work, we need to check whether each character in the string is a whitespace character. We can use a regular expression to determine that, or we can use some kind of looping construct that will iterate through the string. One approach would be to test whether the first character is a space, and if it is, slice it off:<pre>// test if the first character of our input is an empty space     while (input[0] === " ") {// successively slice off the first character of the input         input = input.slice(1);    }</pre></li>
				<li>This loop will execute until it reaches a non-whitespace character. If it does not encounter one, it will only stop when there is no first element of the string, that is, when the string is the empty string. If that's the case, our original input only contained whitespace, and we can return true. Otherwise, we should return false:<pre>// the loop will stop on the first character that is not a //space.// if we're left with an empty string, we only have spaces in // the input     const result = input === "";    return result;</pre></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<pre>console.log(`isBlank("War and Peace"):`);console.log(isBlank("War and Peace")); console.log(`isBlank("       "):`);console.log(isBlank("       "));console.log(`isBlank(""):`);console.log(isBlank(""));</pre></li>
				<li>We should receive the following results:<pre>isBlank("War and Peace"):false isBlank("       "):true isBlank(""):true</pre><p><a id="_idTextAnchor388"/><a id="_idTextAnchor389"/>Note that there are multiple ways to implement all the preceding functions. The code shown is just one way to implement them, and these implementations are mostly for illustrative purposes. For example, a proper string utility library will need to have much more robust and extensive test suites.</p></li>
			</ol>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor390"/>2. Declaration Files</h1>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>Activity 2.01: Building a Heat Map Declaration File</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll be building a TypeScript application named <code>heat map log system</code> that will track the baseball pitch data and ensure the integrity of the data. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the following GitHub repository at <a href="https://packt.link/dqDPk">https://packt.link/dqDPk</a> and download the activity project containing the specs and configuration elements.</li>
				<li> Open the Visual Studio Code editor and then open the terminal. </li>
				<li>Change to the <code>activity-starter</code> directory in the terminal or command prompt by writing the following command:<pre>cd activity-starter</pre></li>
				<li>Run the following command to install the dependencies:<pre>npm install</pre><p>You will now see the following files in the <code>activity-starter</code> directory:</p><div><img src="img/B14508_02_19.jpg" alt="Figure 2.19: Starter project files&#13;&#10;"/></div><p class="figure-caption">Figure 2.19: Starter project files</p></li>
				<li>Open the <code>HeatMapTypes.d.ts</code> declaration file in the <code>types/</code> directory, define a module called <code>HeatMapTypes</code>, and export the interface named <code>Pitcher</code>. Define three attributes for the <code>Pitcher</code><code>batterHotZones</code>, <code>pitcherHotZones</code>, and <code>coordinateMap</code>. The data structures should be the same for all three attributes, <code>Array&lt;Array&lt;number&gt;&gt;</code>, but <code>coordinateMap</code> should be optional. Write the following code to accomplish this:<pre>declare module "HeatMapTypes" {
  export interface Pitcher {
    batterHotZones: Array&lt;Array&lt;number&gt;&gt;;
    pitcherHotZones: Array&lt;Array&lt;number&gt;&gt;;
    coordinateMap?: Array&lt;any&gt;;
  }
}</pre><p>The preceding code in the editor looks like this:</p><div><img src="img/B14508_02_20.jpg" alt="Figure 2.20: Creating a pitcher interface&#13;&#10;"/></div><p class="figure-caption">Figure 2.20: Creating a pitcher interface</p></li>
				<li>Open <code>heat_map_data.ts</code> and import the declaration files. Create and export a <code>let</code> variable called <code>data</code> and assign it to the <code>Pitcher</code> type. You will need to import the <code>lodash</code> library, which was installed when you initially ran <code>npm install</code>. Write the following code to do this:<pre>/// &lt;reference path="./types/HeatMapTypes.d.ts"/&gt;
import hmt = require('HeatMapTypes');
import _ = require('lodash');
export let data: hmt.Pitcher;</pre></li>
				<li>Add values to the <code>data</code> variable that adhere to the declaration rules. Assign nested arrays as values to both the <code>batterHotZones</code> and <code>pitcherHotZones</code> attributes. Add the following code to do this:<pre>data = {
  batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],
  pitcherHotZones: [[3, 2], [-12.2, 3], [-10.2, 5]],
};</pre></li>
				<li>Create a new function named <code>findMatch()</code> that takes in both the <code>batterHotZones</code> and <code>pitcherHotZones</code> arrays and utilize the <code>lodash</code> function, <code>intersectionWith()</code>, to return the identical nested array. Finally, store the value of the <code>findMatch()</code> function in the <code>coordinateMap</code> attribute that was defined in the declaration file. Write the following code to do this:<pre>export const findMatch = (batterHotZones, pitcherHotZones) =&gt; {
  return _.intersectionWith(batterHotZones, pitcherHotZones, _.isEqual);
};
data.coordinateMap = findMatch(data.batterHotZones, data.pitcherHotZones);
console.log(data.coordinateMap);</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc heat_map_data.ts
node heat_map_data.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><pre>[[3,2]]</pre><p>In the preceding output, the common values from both the attributes are fetched and then printed. In this case, the common values are <code>[3, 2]</code>.</p></li>
				<li>Now, change the values of both the attributes. Write the following code:<pre>data = {
  batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],
  pitcherHotZones: [[3, 2], [-12.2, 3], [10.2, -5]],
};</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc heat_map_data.ts
node heat_map_data.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><pre>[[10.2, -5], [3, 2]]</pre></li>
			</ol>
			<p>In the preceding output, the common values are <code>[10.2, -5]</code> and <code>[3, 2]</code>. Finally, we built a heat map log system that will track the baseball pitch data and ensure the integrity of the data.</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor393"/>3. Functions</h1>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor394"/><a id="_idTextAnchor395"/>Activity 3.01: Building a Flight Booking System with Functions</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Start with the stubs provided in code samples. We have three files: <code>index.ts</code>, <code>bookings.ts</code>, and <code>flights.ts</code>. The <code>index.ts</code> file is a bit abstract and will just represent some of the transactions we push into our system. <code>bookings.ts</code> handles the user-facing activities of managing a booking, and <code>flights.ts</code> is the back office of filling up flights and making sure that everybody has a seat.</li>
				<li>The <code>index.ts</code> file won't change unless you feel like changing it and adding some new scenarios. Let's run it without adding any code:<pre>npx ts-node index.ts Not implemented!</pre><p>So we have work to do. Several functions are not yet implemented. Let's start by looking at <code>flights.ts</code>. There is a partial implementation there as we have an interface called <code>Flights</code> that describes the attributes of a flight, a list of available flights implementing that interface, and even a method to fetch the flights, called <code>getDestinations</code>. We need to implement logic to check to see whether the number of seats we want to book are still available, logic that can hold seats while we confirm a reservation, and logic that converts those seats held into reserved seats once our payment has been processed.</p></li>
				<li>To check availability, we should see whether the number of seats we're requesting exceeds the number of remaining seats while holding any held seats in reserve. We can express this as <code>seatsRequested &lt;= seatsRemaining - seatsHeld</code>, which is a Boolean expression that can be returned by the function. This can be written as an arrow function in the <code>flights.ts</code> file:<pre>export const checkAvailability = (
  flight: Flight,
  seatsRequested: number
): boolean =&gt; seatsRequested &lt;= flight.seatsRemaining - flight.seatsHeld;</pre></li>
				<li>The <code>holdSeats</code> function should confirm that the requested seats are available and hold them if they are. If there aren't enough seats remaining, we need to throw an error and interrupt the flow:<pre>export const holdSeats = (flight: Flight, seatsRequested: number): Flight =&gt; {
  if (flight.seatsRemaining - flight.seatsHeld &lt; seatsRequested) {
    throw new Error('Not enough seats remaining!');
  }
  flight.seatsHeld += seatsRequested;
  return flight;
};</pre></li>
				<li>To round out <code>flights.ts</code>, we have <code>reserveSeats</code>. This function operates similarly to <code>holdSeats</code>, but it confirms that the seats we wish to reserve have been held, and then converts them into reserved seats by increasing the <code>seatsHeld</code> property and reducing the <code>seatsRemaining</code> property by the same amount:<pre>export const reserveSeats = (
  flight: Flight,
  seatsRequested: number
): Flight =&gt; {
  if (flight.seatsHeld &lt; seatsRequested) {
    throw new Error('Seats were not held!');
  }
  flight.seatsHeld -= seatsRequested;
  flight.seatsRemaining -= seatsRequested;
  return flight;
};</pre><p>That should do it for <code>flights.ts</code>. However, our program still won't run until we implement <code>bookings.ts</code>. </p></li>
				<li>First of all, we're going to use a factory pattern for creating bookings. That means we'll have a function that returns a function to create bookings. We'll employ currying to create a closure so that we can initialize the <code>createBooking</code> function with <code>bookingNumber</code> in order to give each booking a unique identifier. The factory could look like this:<pre>const bookingsFactory = (bookingNumber: number) =&gt; (
  flight: Flight,
  seatsHeld: number
): Booking =&gt; ({
  bookingNumber: bookingNumber++,
  flight,
  paid: false,
  seatsHeld,
  seatsReserved: 0,
});</pre><p>Our factory takes <code>bookingNumber</code> as an argument to initialize this value and then increments the number each time it creates a new booking. We assign some default values to the booking to confirm to the <code>Booking</code> interface already provided in the module.</p></li>
				<li>To call the factory and get a <code>createBooking</code> function with <code>bookingNumber</code> already curried into it, we can simply write the following:<pre>const createBooking = bookingsFactory(1);</pre></li>
				<li>We have yet to write functions to start the booking process, handle the payment, and complete the booking, thereby reserving the seats on a flight. To begin the booking, we need to check availability on the flight we've chosen based on the number of seats we're requesting. If that is successful, we can create the booking and hold the seats. Otherwise, we can raise an error to alert the user to the fact that the booking cannot be completed:<pre>  export const startBooking = (
  flight: Flight,
  seatsRequested: number
): Booking =&gt; {
  if (checkAvailability(flight, seatsRequested)) {
    holdSeats(flight, seatsRequested);
    return createBooking(flight, seatsRequested);
  }
  throw new Error('Booking not available!');
};</pre></li>
				<li>In order to check flight availability and hold seats, we need to import these functions from <code>flights.ts</code>. This has already been done at the top of the <code>bookings.ts</code> module. The <code>export</code> keyword is used throughout these modules to make functions available to other modules. Some functions lack the <code>export</code> keyword, and so can only be invoked from within the module, effectively making them private.</li>
				<li>We'll cheat a little with our <code>processPayment</code> function since we aren't implementing a payment system. We will just mark the booking as paid and return it:<pre>export const processPayment = (booking: Booking): Booking =&gt; {
  booking.paid = true;
  return booking;
};</pre></li>
				<li>To complete the booking, we call <code>reserveSeats</code> in the <code>flights</code> module and then update our counts:<pre>export const completeBooking = (booking: Booking): Booking =&gt; {
reserveSeats(booking.flight, booking.seatsHeld);
booking.seatsReserved = booking.seatsHeld;
booking.seatsHeld = 0;
return booking;
};</pre></li>
				<li>With all the functions implemented, we can invoke our program again and see the output:<pre>npx ts-node index.ts
Booked to Lagos {
  bookingNumber: 1,
  flight: {
    destination: 'Lagos',
    flightNumber: 1,
    seatsHeld: 0,
    seatsRemaining: 29,
    time: '5:30'
  },
  paid: true,
  seatsHeld: 0,
  seatsReserved: 1
}
//...
Istanbul flight {
  destination: 'Istanbul',
  flightNumber: 7,
  seatsHeld: 0,
  seatsRemaining: 0,
  time: '14:30'
}
Booking not available!</pre></li>
			</ol>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor396"/><a id="_idTextAnchor397"/>Activity 3.02: Writing Unit Tests</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <code>describe</code> block, fetch the destinations for this scenario and then cache the first one as <code>flight</code>. Now, we can write a simple test to test that the correct number of destinations were returned:<pre>  test('get destinations', () =&gt; {
    expect(destinations).toHaveLength(7);
  });</pre><p>We could test each of the individual destinations and their properties as well.</p></li>
				<li>Check the availability of several of the destinations. We can introduce all sorts of scenarios. Here are a few:<pre>  test('checking availability', () =&gt; {
    const destinations = getDestinations();
    expect(checkAvailability(destinations[0], 3)).toBeTruthy();
    expect(checkAvailability(destinations[1], 5)).toBeFalsy();
    expect(checkAvailability(destinations[2], 300)).toBeFalsy();
    expect(checkAvailability(destinations[3], 3)).toBeTruthy();
  });</pre><p>The first destination has at least three seats available. The second does not have five available, and so on.</p></li>
				<li>Try holding some seats in the next test. We should test both success and failure scenarios:<pre>  test('hold seats', () =&gt; {
    expect.assertions(3);
    flight = holdSeats(flight, 3);
    expect(flight.seatsHeld).toBe(3);
    flight = holdSeats(flight, 13);
    expect(flight.seatsHeld).toBe(16);
    try {
      holdSeats(flight, 15);
    } catch (e) {
      expect(e.message).toBe('Not enough seats remaining!');
    }
  });</pre><p>Note that in order to ensure that the <code>catch</code> block was reached, we're expecting three assertions in this test. Without that, the test would still turn green even if, for some reason, the last call to <code>holdSeats</code> didn't throw an error.</p></li>
				<li>Finish up the flights test with a unit test to reserve seats:<pre>  test('reserve seats', () =&gt; {
    expect.assertions(3);
    flight = reserveSeats(flight, 3);
    expect(flight.seatsRemaining).toBe(27);
    flight = reserveSeats(flight, 13);
    expect(flight.seatsRemaining).toBe(14);
    try {
      reserveSeats(flight, 1);
    } catch (e) {
      expect(e.message).toBe('Seats were not held!');
    }
  });</pre><p>This test runs through a few scenarios, including another error condition. In some cases, it might be appropriate to put error conditions in separate tests. A good rule of thumb for this is that each of your tests should be easy to comprehend and maintain. If any module or function gets to be too big, just break it up.</p></li>
				<li>Now, write some tests for bookings using the same principles:<pre>describe('bookings tests', () =&gt; {
  test('create a booking', () =&gt; {
    const booking = startBooking(destinations[0], 3);
    expect(booking).toEqual({
      bookingNumber: 1,
      flight: destinations[0],
      paid: false,
      seatsHeld: 3,
      seatsReserved: 0,
    });
  });
  test('pay for a booking', () =&gt; {
    let booking = startBooking(destinations[0], 3);
    booking = processPayment(booking);
    expect(booking.paid).toBe(true);
  });
  test('complete a booking', () =&gt; {
    let booking = startBooking(destinations[0], 3);
    booking = processPayment(booking);
    booking = completeBooking(booking);
    expect(booking.paid).toBe(true);
    expect(booking.seatsReserved).toBe(3);
  });
});</pre></li>
				<li>Let's now try running the tests and see how things look:<pre>npm test
&gt; jest --coverage --testRegex="^((?!-solution).)*\\.test\\.tsx?$"
 PASS  ./bookings.test.ts
 PASS  ./flights.test.ts
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-------------|---------|----------|---------|---------|-------------------
All files    |   97.14 |    83.33 |     100 |   96.97 |
 bookings.ts |   94.74 |       50 |     100 |   94.44 | 34
 flights.ts  |     100 |      100 |     100 |     100 |
-------------|---------|----------|---------|---------|-------------------
Test Suites: 2 passed, 2 total
Tests:       7 passed, 7 total
Snapshots:   0 total
Time:        1.782 s
Ran all test suites.</pre><p>The tests passed! But we haven't hit 100% line coverage yet. We can actually open up the coverage report, which will be inside the <code>coverage/lcov-report</code> directory in the root of our project. The coverage tool (Istanbul) that comes bundled with Jest will produce an HTML report that we can open in any browser. This will show us the exact piece of code that hasn't been covered:</p><div><img src="img/B14508_03_02.jpg" alt="Figure 3.2: HTML report produced by the tool&#13;&#10;"/></div><p class="figure-caption">Figure 3.2: HTML report produced by the tool</p></li>
				<li>We've missed one error scenario. Let's add that as a new <code>describe</code> block to avoid further complicating the tests we've already written:<pre>describe('error scenarios', () =&gt; {
  test('booking must have availability', () =&gt; {
    expect.assertions(1);
    try {
      startBooking(destinations[6], 8);
    } catch (e) {
      expect(e.message).toBe('Booking not available!');
    }
  });
});</pre><p>There's no particular need to have a new <code>describe</code> block, but in this case, it might make the code a bit cleaner. Use <code>describe</code> and test blocks for readability and maintenance.</p></li>
				<li>Let's now run the tests again:<pre>npm test
&gt; jest --coverage --testRegex="^((?!-solution).)*\\.test\\.tsx?$" PASS  ./bookings-solution.test.ts
 PASS  ./flights-solution.test.ts
-------------|---------|----------|---------|---------|-------------------
File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-------------|---------|----------|---------|---------|-------------------
All files    |     100 |      100 |     100 |     100 |
 bookings.ts |     100 |      100 |     100 |     100 |
 flights.ts  |     100 |      100 |     100 |     100 |
-------------|---------|----------|---------|---------|-------------------
Test Suites: 2 passed, 2 total
Tests:       8 passed, 8 total
Snapshots:   0 total
Time:        0.694 s, estimated 1 s
Ran all test suites.</pre><p>We've hit our goal of 100% line coverage!</p></li>
			</ol>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor398"/>4. Classes and Objects</h1>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor399"/><a id="_idTextAnchor400"/>Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll be building a user authentication system that will pass login data to a backend API to register and sign users into our baseball scorecard application. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the following GitHub repository and download the activity project containing the specs and configuration elements: <a href="https://packt.link/oaWbW">https://packt.link/oaWbW</a>. <p>The  <code>activity-solution</code> directory contains the completed solution code, and the <code>activity-starter</code> directory provides the basic start code to work with.</p></li>
				<li>Open the Visual Studio Code editor and then open the terminal. Change into the <code>activity-starter</code> directory in the terminal or command prompt and run the following command to install the dependencies:<pre>npm install</pre><p>You will now see the following files in the <code>activity-starter</code> directory:</p><div><img src="img/B14508_04_10.jpg" alt="Figure 4.10: Activity project files&#13;&#10;"/></div><p class="figure-caption">Figure 4.10: Activity project files</p></li>
				<li>Open the <code>auth.ts</code> file inside the <code>activity-starter</code> folder and create an interface named <code>ILogin</code> containing two string attributes, namely, <code>email</code> and <code>password</code>. Write the following code to accomplish this:<pre>interface ILogin{
    email: string;
    password:string;
}</pre></li>
				<li>Create a <code>Login</code> class that takes in an object that contains the string attributes of <code>email</code> and <code>password</code>. Also, pass the <code>ILogin</code> interface as a parameter to the <code>constructor</code> function inside the <code>Login</code> class:<pre>export class Login{
    email: string;
    password: string;
    constructor(args: ILogin){
        this.email = args.email;
        this.password = args.password;
    }
}</pre></li>
				<li>Create an interface named <code>IAuth</code> containing two attributes, <code>user</code> and <code>source</code>. Here, the <code>user</code> attribute will be of the <code>Login</code> type, and the <code>source</code> attribute will be of the <code>string</code> type. Write the following code to implement this:<pre>interface IAuth{
    user: Login;
    source: string;
} </pre></li>
				<li>Create an <code>Auth</code> class that takes in an object containing the attributes of <code>user</code> and <code>source</code>. Also, create a <code>constructor</code> function that will take the <code>IAuth</code> interface as a parameter. Write the following code to accomplish this:<pre>export default class Auth{
    user: Login;
    source: string;
    constructor(args: IAuth){
        this.user = args.user;
        this.source = args.source;
    }
}</pre></li>
				<li>Next, we'll add a <code>validUser()</code> method to the <code>Auth</code> class, which returns a string stating that the user is authenticated if <code>email</code> is equal to <code>admin@example.com</code>, and if <code>password</code> is equal to <code>secret123</code>. If either of those values doesn't match, the function will return a string stating that the user is not authenticated. Write the following code to define this function:<pre>validUser(): string{
    const { email, password } = this.user;
    if(email === "admin@example.com"       &amp;&amp; password === "secret123"){
        return `Validating user…User is authenticated: true`;
    } else {
        return `Validating user…User is authenticated: false`;
    }
}</pre></li>
				<li>Create two objects of the <code>Login</code> class, namely, <code>goodUser</code> and <code>badUser</code>. For the <code>goodUser</code> object, set the <code>email</code> value to <code>admin@example.com</code> and <code>password</code> to <code>secret123</code>. For the <code>badUser</code> object, set the <code>email</code> value to <code>admin@example.com</code> and <code>password</code> to <code>whoops</code>. Write the following code to accomplish this:<pre>const goodUser = new Login({
    email: "admin@example.com",
    password: "secret123"
});
const badUser = new Login({
    email: "admin@example.com",
    password: "whoops"
});</pre></li>
				<li>Create two objects of the <code>Auth</code> class, namely, <code>authAttemptFromGoodUser</code> and <code>authAttemptFromBadUser</code>. For the first object, assign the <code>goodUser</code> object of the <code>Login</code> class to the <code>user</code> attribute and <code>Google</code> to the <code>source</code> attribute. For the second object, assign the <code>badUser</code> object of the <code>Login</code> class to the <code>user</code> attribute and <code>Google</code> to the <code>source</code> attribute. Once both objects are created, call the <code>validUser()</code> function of the <code>Auth</code> class and print the results in the terminal. Write the following code to accomplish this:<pre>const authAttemptFromGoodUser = new Auth({
    user: goodUser,
    source: "Google"
});
console.log(authAttemptFromGoodUser.validUser());
const authAttemptFromBadUser = new Auth({
    user: badUser,
    source: "Google"
});
console.log(authAttemptFromBadUser.validUser());</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc auth.ts
node auth.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><pre>Validating user…User is authenticated: true
Validating user…User is authenticated: false</pre></li>
			</ol>
			<p>In the preceding output, the <code>validUser()</code> function returns a <code>true</code> value when the correct details of <code>user</code> and <code>password</code> are passed. When incorrect details are passed, the function returns a <code>false</code> value.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor401"/>5. Interfaces and Inheritance</h1>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor402"/><a id="_idTextAnchor403"/>Activity 5.01: Building a User Management Component Using Interfaces</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a user object interface with the following properties: <code>email : string</code>, <code>loginAt : number</code>, and <code>token : string</code>. Make <code>loginAt</code> and <code>token</code> optional:<pre>interface UserObj {
    email: string
    loginAt?: number
    token?: string
}</pre></li>
				<li>Build a class interface with a global property user and use the interface created in <em class="italic">Step 1</em> to apply user object rules. You need to define a <code>getUser</code> method that returns the user object. Use the interface to ensure that the return object is a user object. Finally, define a <code>login</code> method that takes a <code>user</code> object and <code>password(type string)</code> as arguments. Use the user object interface as the <code>user</code> argument type:<pre>interface UserClass {
    user: UserObj
    getUser(): UserObj
    login(user: UserObj, password: string):UserObj
}</pre></li>
				<li>Declare a class called <code>UserClass</code> that implements the class interface from <em class="italic">Step 2</em>. Your login method should assign the local function's <code>user</code> argument to the global user property and return the global user. The <code>getUser</code> method should return the global user:<pre>class User implements UserClass {
    
    user:UserObj
    getUser(): UserObj {
        return this.user
    }
    login(user:  UserObj, password: string): UserObj {
        // set props user object
        return this.user = user
    }
}</pre></li>
				<li>Create an instance of your class, as declared in <em class="italic">Step 2</em>:<pre>const newUserClass:UserClass = new User()</pre></li>
				<li>Create a user object instance:<pre>const newUser: UserObj = {
    email: "home@home.com",
    loginAt: new Date().getTime(),
    token: "123456"
}</pre></li>
				<li>Console out our methods to ensure that they are working as expected:<pre>console.log(
    newUserClass.login(newUser, "password123")
)
console.log(
    newUserClass.getUser()
)</pre><p>The expected output is as follows:</p><pre>{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }
{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }</pre><p>Thi<a id="_idTextAnchor404"/>s user management class is a central location where you can isolate all your application's user-related functions and rules. The rules you have crafted by using interfaces to implement your code will ensure that your code is better supported, easier to work with, and bug-free. </p></li>
			</ol>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor405"/><a id="_idTextAnchor406"/>Activity 5.02: Creating a Prototype Web Application for a Vehicle Showroom Using Inheritance</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a parent class that will hold all common methods and properties for a base vehicle, define a constructor method that allows you to initialize the base properties of this class, and add a method that returns your properties as an object. If necessary, add an access modifier to properties and class methods you want to control access to:  <pre>class Motor {
    private name: string
    wheels: number
    bodyType: string
    constructor(name: string, wheels: number, bodyType: string) {
        this.name = name
        this.wheels = wheels
        this.bodyType = bodyType
    }
    protected getName(): string {
        return this.name
    }
    buildMotor() {
        return {
            wheels: this.wheels,
            bodyType: this.bodyType,
            name: this.name
        }
    }
}</pre></li>
				<li>Derive two child classes from your parent class that are types of vehicles, for example, <code>Car</code> and <code>Truck</code>. Override your constructor to add some unique properties to your child classes based on the type of vehicles:<pre>class Car extends Motor {
    rideHeight: number
    constructor(name: string, wheels: number, bodyType: string, rideHeight: number) {
        super(name, wheels, bodyType)
        this.rideHeight = rideHeight
    }
    _buildMotor() {
        return {
            ...super.buildMotor,
            rideHeight: this.rideHeight
        }
    }
}
class Truck extends Motor {
    offRoad: boolean
    constructor(name: string, wheels: number, bodyType: string, offRoad: boolean) {
        super(name, wheels, bodyType)
        this.offRoad = offRoad
    }
    _buildMotor() {
        return {
            wheels: this.wheels,
            bodyType: this.bodyType,
            offRoad: this.offRoad
        }
    }
}</pre></li>
				<li>Derive a class from one of the child classes created in <em class="italic">Step 3</em>, for example, <code>Suv</code>, which will have some of the things a truck might have, so it would be logical to extend <code>Truck</code>:<pre>class Suv extends Truck {
    roofRack: boolean
    thirdRow: boolean
    constructor(name: string, wheels: number, bodyType: string, 
        offRoad: boolean, roofRack: boolean, thirdRow: boolean) {
        super(name, wheels, bodyType, offRoad)
        this.roofRack = roofRack;
        this.thirdRow = thirdRow
    }
}</pre></li>
				<li>Instantiate your child class:<pre>const car: Car = new Car('blueBird', 4, 'sedan', 14)
const truck: Truck = new Truck('blueBird', 4, 'sedan', true)
const suv: Suv = new Suv('xtrail', 4, 'box', true, true, true)</pre></li>
				<li>Console out our child class instance:<pre>console.log(car)
console.log(truck)
console.log(suv)</pre><p>You will obtain the following output:</p><pre>Car { name: 'blueBird', wheels: 4, bodyType: 'sedan', rideHeight: 14 }
Truck { name: 'blueBird', wheels: 4, bodyType: 'sedan', offRoad: true }
Suv {
  name: 'xtrail',
  wheels: 4,
  bodyType: 'box',
  offRoad: true,
  roofRack: true,
  thirdRow: true
}</pre><p>In t<a id="_idTextAnchor407"/>his activity, you created the bare minimum classes that we require for the web application. We have shown how we can build complexity, reuse, and extend application code with inheritance in TypeScript.</p></li>
			</ol>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor408"/>6. Advanced Types</h1>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor409"/><a id="_idTextAnchor410"/>Activity 6.01: Intersection Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a <code>Motor</code> type, which will house some common properties you may reuse on their own or in combination with other types to describe a vehicle object. You can use the following properties as a starting point: <code>color</code>, <code>doors</code>, <code>wheels</code>, and <code>fourWheelDrive</code>:<pre>type Motor = {
    color: string;
    doors: number;
    wheels: number;
    fourWheelDrive: boolean;
}</pre></li>
				<li>Create a <code>Truck</code> type with properties common to a truck, for example, <code>doubleCab</code> and <code>winch</code>:<pre>type Truck = {
    doubleCab: boolean;
    winch: boolean;
} </pre></li>
				<li>Intersect the two types to create a <code>PickUpTruck</code> type:<pre>type PickUpTruck = Motor &amp; Truck;</pre></li>
				<li>Build a <code>TruckBuilder</code> function that returns our <code>PickUpTruck</code> type and also takes <code>PickUpTruck</code> as an argument: <pre>function TruckBuilder (truck: PickUpTruck): PickUpTruck {
    return truck
}
const pickUpTruck: PickUpTruck = {
    color: 'red',
    doors: 4,
    doubleCab: true,
    wheels: 4,
    fourWheelDrive: true,
    winch: true
}</pre></li>
				<li>Console out the function return:<pre>console.log (
    TruckBuilder(pickUpTruck)
)</pre><p>You should see the following output once you run the file:</p><pre>{
  color: 'red',
  doors: 4,
  doubleCab: true,
  wheels: 4,
  fourWheelDrive: true,
  winch: true
}</pre></li>
			</ol>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>Activity 6.02: Union Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Build a <code>LandPack</code> and an <code>AirPack</code> type. Make sure to have a literal to identify the package type:<pre>type LandPack = {
    height: number,
    weight: number,
    type: "land",
    label?: string };
type AirPack = {
    height: number,
    weight: number,
    type : "air",
    label?: string };</pre></li>
				<li>Construct a union type, <code>ComboPack</code>, which can be <code>LandPack</code> or <code>AirPack</code>: <pre>type ComboPack = LandPack | AirPack</pre></li>
				<li>Make a <code>Shipping</code> class to process your packages. Make sure to use your literal to identify your package types and modify your package with the correct label for its type:<pre>class Shipping {
    Process(pack: ComboPack) {
        // check package type
        if(pack.type === "land") {
            return this.ToLand(pack);
        } else {
            return this.ToAir(pack);
        }
    }
    ToAir(pack: AirPack): AirPack {
        pack.label = "air cargo"
        return pack;
    }
    ToLand(pack: LandPack): LandPack {
        pack.label = "land cargo"
        return pack;
    }
}</pre></li>
				<li>Create two package objects of the <code>AirPack</code> and <code>LandPack</code> types. Then, instantiate your <code>Shipping</code> class, process your new objects, and console out the modified objects:<pre>const airPack: AirPack = {
    height: 5,
    weight: 10,
    type: "air",
};
const landPack: LandPack = {
    height: 5,
    weight: 10,
    type: "land",
};
const shipping = new Shipping;
console.log(
    shipping.Process(airPack)
);
console.log(
    shipping.Process(landPack)
);</pre><p>Once you run the file, you will obtain the following output:</p><pre>{ height: 5, weight: 10, type: 'air', label: 'air cargo' }
{ height: 5, weight: 10, type: 'land', label: 'land cargo' } </pre></li>
			</ol>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>Activity 6.03: Index Type </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Build your <code>PackageStatus</code> index type using an interface with a <code>status</code> property of the <code>string</code> type and a value of the <code>Boolean</code> type:<pre>interface PackageStatus { 
    [status: string]: boolean;}</pre></li>
				<li>Create a <code>Package</code> type that includes a property of the <code>PackageStatus</code> type and some common properties of a typical package:<pre>type Package = {
    packageStatus: PackageStatus,
    barcode:  number,
    weight: number
}</pre></li>
				<li>Make a class to process your <code>Package</code> type, which takes the <code>Package</code> type on initialization, has a method to return your <code>packageStatus</code> property, and a method that updates and returns the <code>packageStatus</code> property:<pre>class PackageProcess {
    
    pack: Package
    constructor(pack: Package) {
        this.pack = pack;
    }
    
    Status () {
        return this.pack.packageStatus;
    }
    UpdateStatus(status: string, state: boolean) {
        this.pack.packageStatus[status] = state;
        return this.Status();}
}</pre></li>
				<li>Create a <code>Package</code> object called <code>pack</code>:<pre>const pack: Package = {
    packageStatus: {"shipped": false, "packed": true, "delivered": true},
    barcode: 123456,
    weight: 28 
};</pre></li>
				<li>Instantiate your <code>PackageProcess</code> class with your new <code>pack</code> object:<pre>const processPack = new PackageProcess(pack)</pre></li>
				<li>Console out your <code>pack</code> status:<pre>console.log(processPack.Status());</pre></li>
				<li>Update your <code>pack</code> status and console out your new <code>pack</code> status: <pre>console.log(
    processPack.UpdateStatus("shipped", true)
);</pre><p>Once you run the file, you should obtain the following output:</p><pre>{ shipped: false, packed: true, delivered: true }
{ shipped: true, packed: true, delivered: true }</pre><p>The first line in the preceding output displays the original <code>pack</code> status, whereas the second line displays the updated <code>pack</code> status.</p></li>
			</ol>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor415"/>7. Decorator</h1>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/>Activity 7.01: Creating Decorators for Call Counting</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a class called <code>Person</code> with the public properties <code>firstName</code>, <code>lastName</code>, and <code>birthday</code>.</li>
				<li>Add a constructor that initializes the properties via the constructor parameters:<pre>class Person {
         constructor (public firstName: string, 
                     public lastName: string, 
                     public birthDate: Date) {
         }
}</pre></li>
				<li>Add a private field called <code>_title</code> and expose it via a <code>getter</code> and <code>setter</code> as a property called <code>title</code>:<pre>    private _title: string;
    public get title() {
        return this._title;
    }
    public set title(value: string) {
        this._title = value;
    }</pre></li>
				<li>Add a method called <code>getFullName</code> that will return the full name of person:<pre>    public getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }</pre></li>
				<li>Add a method called <code>getAge</code> that will return the current age of the person (by subtracting the birthday from the current year):<pre>    public getAge() {
        // only sometimes accurate
        const now = new Date();
        return now.getFullYear() – this.birthDate.getFullYear();
    }</pre></li>
				<li>Create a global object called <code>count</code> and initialize it to the empty object:<pre>const count = {};</pre></li>
				<li>Create a constructor wrapping decorator factory called <code>CountClass</code> that will take a string parameter called <code>counterName</code>:<pre>type Constructable = { new (...args: any[]): {} };
function CountClass(counterName: string) {
    return function &lt;T extends Constructable&gt;(constructor: T) {
        // wrapping code here
    }
}</pre></li>
				<li>Inside the wrapping code, increase the <code>count</code> object's property defined in the <code>counterName</code> parameter by 1 and then set the prototype chain of the wrapped constructor:<pre>    const wrappedConstructor: any = function (...args: any[]) {
        const result = new constructor(...args);
        if (count[counterName]) {
            count[counterName]+=1;
        } else {
            count[counterName]=1;
        }
        return result;
    };
    wrappedConstructor.prototype = constructor.prototype;
    return wrappedConstructor;</pre></li>
				<li>Create a method wrapping decorator factory called <code>CountMethod</code> that will take a string parameter called <code>counterName</code>:<pre>function CountMethod(counterName: string) {
    return function (target: any, propertyName: string, 
                     descriptor: PropertyDescriptor) {
        // method wrapping code here
    }
}</pre></li>
				<li>Add checks for whether the descriptor parameter has <code>value</code>, <code>get</code>, and <code>set</code> properties:<pre>    if (descriptor.value) {
        // method decoration code
    }
    if (descriptor.get) {
        // get property accessor decoration code
    }
    if (descriptor.set) {
        // set property accessor decoration code
    }</pre></li>
				<li>In each respective branch, add code that wraps the method:<pre>    // method decoration code
    const original = descriptor.value;
    descriptor.value = function (...args: any[]) {
        // counter management code here
        return original.apply(this, args);
    }
    // get property accessor decoration code
    const original = descriptor.get;
    descriptor.get = function () {
        // counter management code here
        return original.apply(this, []);
    }
    // set property accessor decoration code
    const original = descriptor.set;
    descriptor.set = function (value: any) {
        // counter management code here
        return original.apply(this, [value]);
    }</pre></li>
				<li>Inside the wrapping code, increase the <code>count</code> object's property defined in the <code>counterName</code> parameter by 1:<pre>        // counter management code
        if (count[counterName]) {
            count[counterName]+=1;
        } else {
            count[counterName]=1;
        }          </pre></li>
				<li>Decorate the class using the <code>CountClass</code> decorator, with a <code>person</code> parameter:<pre>@CountClass('person')
class Person{</pre></li>
				<li>Decorate <code>getFullName</code>, <code>getAge</code>, and the <code>title</code> property getter with the <code>CountMethod</code> decorator, with the <code>person-full-name</code>, <code>person-age</code>, and <code>person-title</code> parameters, respectively:<pre>    @CountMethod('person-full-name')
    public getFullName() {
    @CountMethod('person-age')
    public getAge() {
    @CountMethod('person-title')
    public get title() {</pre></li>
				<li>Write code outside the class that will instantiate three <code>person</code> objects:<pre>const first = new Person("Brendan", "Eich", new Date(1961,6,4));
const second = new Person("Anders", "Hejlsberg ", new Date(1960,11,2));
const third = new Person("Alan", "Turing", new Date(1912,5,23));</pre></li>
				<li>Write code that will call the <code>getFullName</code> and <code>getAge</code> methods on the objects:<pre>const fname = first.getFullName();
const sname = second.getFullName();
const tname = third.getFullName();
const fage = first.getAge();
const sage = second.getAge();
const tage = third.getAge();</pre></li>
				<li>Write code that will check whether the <code>title</code> property is empty and set it to something if it is:<pre>if (!first.title) {
    first.title = "Mr."
}
if (!second.title) {
    second.title = "Mr."
}
if (!third.title) {
    third.title = "Mr."
}</pre></li>
				<li>Write code that will log the <code>count</code> object to the console:<pre>console.log(count);</pre><p>Once you run the file, you will obtain the following output on the console:</p><pre>{
  person: 3,
  'person-full-name': 3,
  'person-age': 3,
  'person-title': 6
}</pre></li>
			</ol>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor418"/><a id="_idTextAnchor419"/>Activity 7.02: Using Decorators to Apply Cross-Cutting Concerns</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create the code for the <code>BasketBallGame</code> class:<pre>    interface Team {
        score: number;
        name: string;
    }
    class BasketBallGame {
        private team1: Team;
        private team2: Team;
        constructor(teamName1: string, teamName2: string) {
            this.team1 = { score: 0, name: teamName1 };
            this.team2 = { score: 0, name: teamName2 };
        }
        getScore() {
            return `${this.team1.score}:${this.team2.score}`;
        }
        updateScore(byPoints: number, updateTeam1: boolean) {
            if (updateTeam1) {
                this.team1.score += byPoints;
            } else {
                this.team2.score += byPoints;
            }
        }
    }</pre></li>
				<li>Create a class decorator factory called <code>Authenticate</code> that will take a <code>permission</code> parameter and return a class decorator with constructor wrapping. The class decorator should load the <code>permissions</code> metadata property (array of <code>strings</code>), then check if the passed parameter is an element of the array. If the passed parameter is not an element of the array, the class decorator should throw an error, and if present, it should continue with the class creation:<pre>    type Constructable = { new (...args: any[]): {} };
    function Authenticate(permission: string) {
        return function &lt;T extends Constructable&gt;(constructor: T) {
            const wrappedConstructor: any = function (...args: any[]) {
                if (Reflect.hasMetadata("permissions", wrappedConstructor)) {
                    const permissions = Reflect.getMetadata("permissions", 
                                                     wrappedConstructor) as string[];
                    if (!permissions.includes(permission)) {
                        throw Error(`Permission ${permission} not present`);
                    }
                }
                const result = new constructor(...args);
                return result;
            };
            wrappedConstructor.prototype = constructor.prototype;
            return wrappedConstructor;
        };
    }</pre></li>
				<li>Define a metadata property of the <code>BasketballGame</code> class called <code>permissions</code> with the value ["<code>canUpdateScore</code>"]:<pre>    Reflect.defineMetadata("permissions", ["canUpdateScore"], BasketBallGame);</pre></li>
				<li>Apply the class decorator factory on the <code>BasketballGame</code> class with a parameter value of "<code>canUpdateScore"</code>:<pre>    @Authenticate("canUpdateScore")
    class BasketBallGame {</pre></li>
				<li>Create a method decorator called <code>MeasureDuration</code> that will use method wrapping to start a timer before the method body is executed and stop it after it's done. You need to calculate the duration and push it to a metadata property called <code>durations</code> for the method:<pre>    function MeasureDuration() {
        return function (target: any, propertyName: string, 
                                     descriptor: PropertyDescriptor) {
            if (descriptor.value) {
                const original = descriptor.value;
                descriptor.value = function (...args: any[]) {
                    const start = Date.now();
                    const result = original.apply(this, args);
                    const end = Date.now();
                    const duration = end-start;
                    if (Reflect.hasMetadata("durations", target, propertyName)) {
                      const existing = Reflect.getMetadata("durations", 
                                                   target, propertyName) as number[];
                      Reflect.defineMetadata("durations", existing.concat(duration),
                                                   target, propertyName);
                    } else {
                      Reflect.defineMetadata("durations", [duration], 
                                                   target, propertyName)
                    }
                    return result;
                }
            }
        }
    }</pre></li>
				<li>Apply the <code>MeasureDuration</code> method decorator on the <code>updateScore</code> method:<pre>    @MeasureDuration()
    updateScore(byPoints: number, updateTeam1: boolean) {</pre></li>
				<li>Create a method decorator factory called <code>Audit</code> that will take a message parameter and return a method decorator. The method decorator should use method wrapping to get the arguments and the return value of the method. After the successful execution of the original method, it should display the audit log to the console:<pre>    function Audit(message: string) {
        return function (target: any, propertyName: string, 
                                      descriptor: PropertyDescriptor) {
          if (descriptor.value) {
            const original = descriptor.value;
            descriptor.value = function (...args: any[]) {
              const result = original.apply(this, args);
              console.log(`[AUDIT] ${message} (${propertyName}) called with:`)
              console.log("[AUDIT]", args);
              console.log("[AUDIT] and returned result:")
              console.log("[AUDIT]", result);
              return result;
            }
          }
       }
    }</pre></li>
				<li>Apply the <code>Audit</code> method decorator factory on the <code>updateScore</code> method, with a parameter value of <code>Updated score</code>:<pre>    @MeasureDuration()
    @Audit("Updated score")
    updateScore(byPoints: number, updateTeam1: boolean) {</pre></li>
				<li>Create a parameter decorator called <code>OneTwoThree</code> that will add the decorated parameter in the <code>one-two-three</code> metadata property:<pre>    function OneTwoThree(target: any, propertyKey: string, 
                                      parameterIndex: number) {
        if (Reflect.hasMetadata("one-two-three", target, propertyKey)) {
            const existing = Reflect.getMetadata("one-two-three",
                                           target, propertyKey) as number[];
            Reflect.defineMetadata("one-two-three", 
                       existing.concat(parameterIndex), target, propertyKey);
        } else {
            Reflect.defineMetadata("one-two-three", 
                                      [parameterIndex], target, propertyKey);
        }
    }</pre></li>
				<li>Create a method decorator called <code>Validate</code> that will use method wrapping to load all values for the <code>one-two-three</code> metadata property, and for all marked parameters, check their value. If the value is 1, 2, or 3, you should continue the execution of the original method. If not, you should stop the execution with an error:<pre>    function Validate() {
      return function (target: any, propertyKey:string, 
                                      descriptor: PropertyDescriptor) {
            const original = descriptor.value;
            descriptor.value = function (...args: any[]) {
                // validate parameters
                if (Reflect.hasMetadata("one-two-three", 
                                        target, propertyKey)) {
                    const markedParams = Reflect.getMetadata("one-two-three",
                                        target, propertyKey) as number[];
                    for (const marked of markedParams) {
                        if (![1,2,3].includes(args[marked])) {
                            throw Error(`The parameter at position ${marked} can only be 1, 2 or 3`);
                        }
                    }
                }
                return original.apply(this, args);
            }
        }
    }</pre></li>
				<li>Apply the <code>OneTwoThree</code> decorator to the <code>byPoints</code> parameter of <code>updateScore</code> and apply the <code>Validate</code> decorator to the <code>updateScore</code> method.<pre>    @MeasureDuration()
    @Audit("Updated score")
    @Validate()
    updateScore(@OneTwoThree byPoints: number, updateTeam1: boolean) {</pre></li>
				<li>Create a <code>game</code> object and update its score a few times:<pre>const game = new BasketBallGame("LA Lakers", "Boston Celtics");
game.updateScore(3, true);
game.updateScore(2, false);
game.updateScore(2, true);
game.updateScore(2, false);
game.updateScore(2, false);
game.updateScore(2, true);
game.updateScore(2, false);</pre><p>When you run the file, the console should reflect the application of all decorators:</p><pre>[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 3, true ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, false ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, true ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, false ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, false ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, true ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, false ]
[AUDIT] and returned result:
[AUDIT] undefined
7:8</pre></li>
			</ol>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor420"/>8. Dependency Injection in TypeScript</h1>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor421"/><a id="_idTextAnchor422"/>Activity 8.01: DI-Based Calculator</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we will build a basic calculator that utilizes DI to evaluate mathematical expressions, as well as logging its output to either the console or a file:</p>
			<ol>
				<li value="1">To start things off, define the basic building block of our calculator – an operator. This is defined via an interface, which actual implementations can rely on:<pre>export interface Operator {
    readonly symbol: string;
    evaluate(a: number, b: number): number;
}</pre><p>You need to create this file in the <code>src/interfaces</code> folder and save it as <code>operator.interface.ts</code>.</p></li>
				<li>Next, implement the first operator – the addition operator. This will be a class that implements the <code>Operator</code> interface:<pre>import { Operator } from '../interfaces/operator.interface';
export class AddOperator implements Operator {
    readonly symbol = '+';
    public evaluate(a: number, b: number) {
    return a + b;
    }
}</pre><p>The preceding code needs to be written in a file called <code>add.operator.ts</code> in <code>src\operators</code>.</p></li>
				<li>Make this operator available for injection by InversifyJS by adding the <code>@injectable</code> decorator to the class:<pre><strong class="bold">import { injectable } from 'inversify';</strong>
import { Operator } from '../interfaces/operator.interface';
<strong class="bold">@injectable()</strong>
export class AddOperator implements Operator {
    readonly symbol = '+';
    public evaluate(a: number, b: number) {
        return a + b;
    }
}</pre></li>
				<li>Next, since interfaces don't exist at runtime, we need to create some runtime representation of our abstraction for <code>AddOperator</code>. This is usually done using symbols, and will be used by InversifyJS at runtime to understand what needs to be injected. We'll define it under a <code>TYPES</code> constant, which we'll be able to add other symbols for later:<pre>export const TYPES = {
    AddOperator: Symbol.for('AddOperator'),
};</pre><p>This code needs to be written in a new file saved in the <code>src\types\</code> folder. We have named this file <code>index.ts</code>. </p></li>
				<li>Now, build a first draft for our calculator, which will use <code>AddOperator</code>, via DI:<pre>import { injectable, inject } from 'inversify';
import { TYPES } from '../types';
import { AddOperator } from '../operators/add.operator';
@injectable()
export class Calculator {
    constructor(@inject(TYPES.AddOperator) private addOperator: AddOperator) {}
    evaluate(expression: string) {
        const expressionParts = expression.match(/[\d\.]+|\D+/g);
        if (expressionParts === null) return null;
        // for now, we're only going to support basic expressions: X+Y
        const [operandA, operator, operandB] = expressionParts;
        if (operator !== this.addOperator.symbol) {
            throw new Error(`Unsupported operator. Expected ${this.addOperator.symbol}, received: ${operator}.`);
        }
        const result = this.addOperator.evaluate(Number(operandA), Number(operandB));
        return result;
    }
}</pre><p>Here, we implement a <code>Calculator</code> class that has a single method – <code>evaluate</code>, which takes in an expression as a string, and returns the result for that expression. This code needs to be written in a new file called <code>index.ts</code>, saved in the <code>src/calculator</code> folder.</p><p class="callout-heading">Note</p><p class="callout">The current implementation only supports expressions in the form of X+Y (where X and Y can be any numbers). We'll fix that later in the activity.</p><p>Calculator gets <code>AddOperator</code> in DI, and in order to evaluate the expression, it first runs through a regular expression to split it by numbers, and then it <em class="italic">destructures</em> the result array. Lastly, it uses the <code>evaluate</code> method of <code>AddOperator</code> to perform the final expression evaluation.</p><p>This means that the calculator's responsibility is only to destructure the expression into its individual parts, and then pass it off to <code>AddOperator</code> to handle the math evaluation logic. This demonstrates how using DI helps to retain the single responsibility principle of SOLID.</p></li>
				<li>Configure the IoC container (in the <code>src/ioc.config.ts</code> file) so that <code>Calculator</code> can receive <code>AddOperator</code> when it asks for <code>TYPES.AddOperator</code>:<pre>import { Container } from 'inversify';
import { Calculator } from './calculator/index';
import { Operator } from './interfaces/operator.interface';
import { AddOperator } from './operators/add.operator';
import { TYPES } from './types';
export const container = new Container();
container.bind&lt;Operator&gt;(TYPES.AddOperator).to(AddOperator);
container.bind(Calculator).toSelf();</pre></li>
				<li>Finally, our main file (<code>src/main.ts</code>), which will kick things off when we run the application, is as follows:<pre>import 'reflect-metadata';
import { Calculator } from './calculator/index';
import { container } from './ioc.config';
const calculator = container.get(Calculator);
try {
    const result = calculator.evaluate('13+5');
    console.log('result is', result);
} catch (err) {
    console.error(err);
}</pre><p>This is just using our previously defined IoC container and asking it for a <code>Calculator</code> instance. This is how we ask for instances of symbols explicitly in InversifyJS in an imperative API, which we need here, since we want to kick things off. Since InversifyJS is the one creating <code>Calculator</code>, it also looks at its constructor and sees that we've asked for a <code>TYPES.AddOperator</code>, which it then looks up in the IoC container again to resolve and gives that to the calculator's constructor.</p><p>Once you run this file, you should obtain the following output:</p><pre>result is 18</pre><p>Note that you can either run the code by executing <code>npm start</code> in the <code>activity-starter</code> folder or by executing <code>npx ts-node main.ts</code> in the <code>src</code> folder.</p><p class="callout-heading">Note</p><p class="callout">If the <code>AddOperator</code> class were also to require dependencies using <code>@inject</code>, the same process described above would be repeated again to get them, and so on recursively until all dependencies have been resolved.</p></li>
				<li>Next, we can implement the other operators, similar to how we did with <code>AddOperator</code> – just replace the symbol with the relevant one (<code>-</code>, <code>*</code>, <code>/</code>) and the evaluate method's implementation with the relevant math operation:</li>
				<li>Here is the code for <code>SubtractOperator</code> (<code>subtract.operator.ts</code>):<pre>// operators/subtract.operator.ts
import { injectable } from 'inversify';
import { Operator } from '../interfaces/operator.interface';
@injectable()
export class SubtractOperator implements Operator {
    readonly symbol = '-';
    public evaluate(a: number, b: number) {
        return a - b;
    }
}</pre></li>
				<li>Here is the code for <code>MultiplyOperator</code> (<code>multiply.operator.ts</code>):<pre>// operators/multiply.operator.ts
import { injectable } from 'inversify';
import { Operator } from '../interfaces/operator.interface';
@injectable()
export class MultiplyOperator implements Operator {
    readonly symbol = '*';
    public evaluate(a: number, b: number) {
        return a * b;
    }
}</pre></li>
				<li>Here is the code for <code>DivideOperator</code> (<code>divide.operator.ts</code>):<pre>// operators/divide.operator.ts
import { injectable } from 'inversify';
import { Operator } from '../interfaces/operator.interface';
@injectable()
export class DivideOperator implements Operator {
    readonly symbol = '/';
    public evaluate(a: number, b: number) {
        return a / b;
    }
}</pre><p>Now, instead of creating an injection token for each <code>Operator</code>, injecting each one into <code>Calculator</code>, and then acting on each, we can create a more generic implementation of <code>Calculator</code> with the help of the <code>@multiInject</code> decorator. This decorator allows an injection token to be specified and an array of all implementations registered for that token to be obtained. This way, <code>Calculator</code> is not even coupled to an abstraction for any specific operator and only gets a dynamic list of operators, which can have any implementation as long as it conforms to the <code>Operator</code> interface.</p></li>
				<li>Update the <code>types/index.ts</code> file with the following code:<pre>export const TYPES = {
    Operator: Symbol.for('Operator'),
};</pre><p>This replaces our <code>AddOperator</code> symbol from earlier with a more generic one.</p></li>
				<li>Update the calculator app code (<code>src/calculator/index.ts</code>):<pre>import { injectable, <code>tryParseNumberString</code> and <code>tryParseOperatorSymbol</code>. Both these functions are created in the <code>math.ts</code> file placed in the <code>src/utils</code> folder.</p></li>
				<li>Update the <code>ioc.config.ts</code> file:<pre>import { Container } from 'inversify';
import { Calculator } from './calculator';
import { Operator } from './interfaces/operator.interface';
import { AddOperator } from './operators/add.operator';
import { DivideOperator } from './operators/divide.operator';
import { MultiplyOperator } from './operators/multiply.operator';
import { SubtractOperator } from './operators/subtract.operator';
import { TYPES } from './types';
export const container = new Container();
container.bind&lt;Operator&gt;(TYPES.Operator).to(AddOperator);
container.bind&lt;Operator&gt;(TYPES.Operator).to(SubtractOperator);
container.bind&lt;Operator&gt;(TYPES.Operator).to(MultiplyOperator);
container.bind&lt;Operator&gt;(TYPES.Operator).to(DivideOperator);
container.bind(Calculator).toSelf();</pre></li>
				<li>Next, fix the naïve <code>evaluate</code> method of <code>Calculator</code> to be more generic, too. First, instead of relying on a specific token, <code>tryParseNumberString</code> and <code>tryParseOperatorSymbol</code> yourself. However, you can refer to <code>utils/math.ts</code> to help you complete this step.</p></li>
				<li>Then, reduce this array to get our final result:<pre>evaluate(expression: string) {
    // ...
    const { result } = parsedExpressionParts.reduce&lt;{ result: number; queuedOperator: Operator | null }&gt;((acc, part) =&gt; {
        if (typeof part === 'number') {
            // this is the first number we've encountered, just set the result to that.
            if (acc.queuedOperator === null) {
                return { ...acc, result: part };
            }
            // there's a queued operator – evaluate the previous result with this and
            // clear the queued one.
            return {
                queuedOperator: null,
                result: acc.queuedOperator.evaluate(acc.result, part),
              };
        }
        // this is an operator – queue it for later execution
        return {
            ...acc,
            queuedOperator: part,
        };
    }, { result: 0, queuedOperator: null });
    return result;
}</pre></li>
				<li>Simplify the code in the <code>ioc.config.ts</code> file even further by leveraging barrels. Create <code>operator/index.ts</code> with the following code:<pre>// operators/index.ts
export * from './add.operator';
export * from './divide.operator';
export * from './multiply.operator';
export * from './subtract.operator';</pre></li>
				<li>Update the <code>ioc.config.ts</code> file:<pre>// ioc.config.ts
import { Container } from 'inversify';
import { Calculator } from './calculator';
import { Operator } from './interfaces/operator.interface';
import * as Operators from './operators';
import { TYPES } from './types';
export const container = new Container();
Object.values(Operators).forEach(Operator =&gt; {
    container.bind&lt;Operator&gt;(TYPES.Operator).to(Operator);
});
container.bind(Calculator).toSelf();</pre><p>This means we now import an <code>Operators</code> object from the barrel file, which includes everything that's exposed there. We take the values of that barrel object and bind each one to <code>TYPES.Operator</code>, generically.</p><p>This means that adding another <code>Operator</code> object only requires us to create a new class that implements the <code>Operator</code> interface and add it to our <code>operators/index.ts</code> file. The rest of the code should work without any changes.</p></li>
				<li>Our <code>main.ts</code> file is changed to a slightly more complicated expression:<pre>import 'reflect-metadata';
import { Calculator } from './calculator';
import { container } from './ioc.config';
const calculator = container.get(Calculator);
try {
    const result = calculator.evaluate('13*10+20');
    console.log('result is', result);
} catch (err) {
    console.error(err);
}</pre><p>When you run the <code>main.ts</code> file (using <code>npx ts-node main.ts</code>), you should obtain the following output:</p><pre>result is 150</pre></li>
			</ol>
			<h3 id="_idParaDest-351"><strong class="bold"><a id="_idTextAnchor423"/>Bonus:</strong></h3>
			<ol>
				<li value="1">As a bonus, let's say that we want some reporting on the operations performed in the calculator. We can add logging pretty easily without too many changes. We'll create two reporting implementations, one to the console and another to a filesystem:<p class="callout-heading">Note</p><p class="callout">The filesystem implementation will only work in a Node.js environment, since it will use some modules only available to it.</p></li>
				<li>Define the <code>Logger</code> interface:<pre>export interface Logger {
    log(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
}</pre><p>This will serve as the public API that the consumers wanting a logger can use, and that our implementations will need to adhere to.</p></li>
				<li>Create the console-based implementation of <code>Logger</code> first:<pre>import { injectable } from 'inversify';
import { Logger } from '../interfaces/logger.interface';
@injectable()
export class ConsoleLogger implements Logger {
    log(message: string, ...args: any[]) {
        console.log('[LOG]', message, ...args);
    }
    warn(message: string, ...args: any[]) {
        console.warn('[WARN]', message, ...args);
    }
    error(message: string, ...args: any[]) {
        console.error('[ERROR]', message, ...args);
    }
}</pre><p>This is a simple wrapper class around the <code>console</code> object that's built into browser engines and Node.js. It adheres to our <code>Logger</code> interface, and so allows consumers to depend on it. For the example, we've also added the type of the message to the beginning of the actual output.</p></li>
				<li>Next<a id="_idTextAnchor424"/>, create an injection token for it, and register it in our container. The updated code for the <code>types/index.ts</code> file is as follows:<pre>// types/index.ts
export const TYPES = {
    Operator: Symbol.for('Operator'),
    Logger: Symbol.for('Logger'),
};</pre><p>The updated code for the <code>src/ioc.config.ts</code> file is as follows:</p><pre>// ioc.config.ts
import { Container } from 'inversify';
import { Calculator } from './calculator';
import { Logger } from './interfaces/logger.interface';
import { Operator } from './interfaces/operator.interface';
import { ConsoleLogger } from './logger/console.logger';
import * as Operators from './operators';
import { TYPES } from './types';
export const container = new Container();
Object.values(Operators).forEach(Operator =&gt; {
    container.bind&lt;Operator&gt;(TYPES.Operator).to(Operator);
});
container.bind(Calculator).toSelf();
container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</pre></li>
				<li>Finally, use the logger in our <code>Calculator</code> class:<pre>import { injectable, multiInject, inject, optional } from 'inversify';
import { Operator } from '../interfaces/operator.interface';
import { TYPES } from '../types';
import { tryParseNumberString, tryParseOperatorSymbol } from '../utils/math';
import { Logger } from '../interfaces/logger.interface';
@injectable()
export class Calculator {
    constructor(
        @multiInject(TYPES.Operator) private operators: Operator[],
        @inject(TYPES.Logger) @optional() private logger?: Logger
    ) {}
    evaluate(expression: string) {
        // ...
        const { result } = parsedExpressionParts.reduce&lt;{ result: number; queuedOperator: Operator | null }&gt;( ... );
        this.logger &amp;&amp; this.logger.log(`Calculated result of expression: ${expression} to be: ${result}`);
        return result;
    }
}</pre><p>Notice that we use the <code>@optional</code> decorator to indicate to InversifyJS that <code>Calculator</code> doesn't <em class="italic">require</em> a <code>Logger</code> to operate, but if it has one it can inject, <code>Calculator</code> can use it. This is also why it's marked as an optional argument in the constructor, and why we need to check whether it exists before calling the <code>log</code> method.</p><p>The output to the console when running it should be as follows:</p><pre>[LOG] Calculated result of expression:13*10+20 is 150</pre><p>Now, let's say we want to replace our console-based logger with a file-based one, which will persist across runs so that we can track the calculator's evaluation history.</p></li>
				<li>Create a <code>FileLogger</code> class that implements <code>Logger</code>:<pre>import fs from 'fs';
import { injectable } from 'inversify';
import { Logger } from '../interfaces/logger.interface';
@injectable()
export class FileLogger implements Logger {
    private readonly loggerPath: string = '/tmp/calculator.log';
    log(message: string, ...args: any[]) {
        this.logInternal('LOG', message, args);
    }
    warn(message: string, ...args: any[]) {
        this.logInternal('WARN', message, args);
    }
    error(message: string, ...args: any[]) {
        this.logInternal('ERROR', message, args);
    }
    private logInternal(level: string, message: string, ...args: any[]) {
        fs.appendFileSync(this.loggerPath, this.logLineFormatter(level, message, args));
    }
    private logLineFormatter(level: string, message: string, ...args: any[]) {
        return `[${level}]: ${message}${args}\n`;
    }
}</pre></li>
				<li>And finally, all we need to do in order to replace our console-based logger with a file-based one is a single-line change in our IoC container configuration.<p>For console-based logging, use this command:</p><pre>container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</pre><p>For file-based logging, use this command:</p><pre>container.bind&lt;Logger&gt;(TYPES.Logger).to(FileLogger);</pre><p>Make sure to import this logger correctly in the <code>ioc.config.ts</code> file.</p><p>The final output to the file is as follows:</p><div><img src="img/B14508_08_08.jpg" alt="Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log, after changing the app to use it&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log, after changing the app to use it</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor425"/>9. Generics and Conditional Types</h1>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor426"/><a id="_idTextAnchor427"/>Activity 9.01: Creating a DeepPartial&lt;T&gt; Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Let's build this type up, step by step:</p>
			<ol>
				<li value="1">First, let's create a <code>PartialPrimitive</code> type:<pre>type PartialPrimitive = string | number | boolean | symbol | bigint | Function | Date;</pre></li>
				<li>Then, let's start by defining a basic <code>DeepPartial&lt;T&gt;</code> type:<pre>type DeepPartial&lt;T&gt; = T extends PartialPrimitive ? T : Partial&lt;T&gt;;</pre><p>Next, we need to handle more complex structures – such as array<a id="_idTextAnchor428"/><a id="_idTextAnchor429"/>s, sets, and maps. These require using the <code>infer</code> keyword, and in addition to that, require some more "manual wiring" for each of these types. </p></li>
				<li>Let's start with adding handling for the <code>Array</code> type: <pre>type DeepPartial&lt;T&gt; =
     T extends PartialPrimitive
     ? T
     : T extends Array&lt;infer U&gt;
     ? Array&lt;DeepPartial&lt;U&gt;&gt;
     : Partial&lt;T&gt;;</pre><p>This would've worked, but due to current limitations in TypeScript at the time of writing, this doesn't compile, since <code>DeepPartial&lt;T&gt;</code> circularly references itself:</p><div><img src="img/B14508_09_17.jpg" alt="Figure 9.17: Current TypeScript version limitation not allowing generic &#13;&#10;types to reference themselves&#13;&#10;"/></div><pre>interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}
type DeepPartial&lt;T&gt; =
     T extends PartialPrimitive
     ? T
     : T extends Array&lt;infer U&gt;
     ? DeepPartialArray&lt;U&gt;
     : Partial&lt;T&gt;;</pre><p>This works around the problem and compiles fine.</p></li>
				<li>Next, to support a <code>Set</code>, a similar approach to what we did in the previous step is needed, so we'll create an <code>interface</code> to serve as a "middle-man" for building the entire generic type:<pre>interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}
interface DeepPartialSet&lt;T&gt; extends Set&lt;DeepPartial&lt;T&gt;&gt; {}
type DeepPartial&lt;T&gt; = T extends PartialPrimitive
    ? T
    : T extends Array&lt;infer U&gt;
    ? DeepPartialArray&lt;U&gt;
    : T extends Set&lt;infer U&gt;
    ? DeepPartialSet&lt;U&gt;
    : Partial&lt;T&gt;;</pre></li>
				<li>Similarly to arrays and sets, maps also need the approach wherein we need create an <code>interface</code> to serve as a "middle-man" for building the entire generic type:<pre>interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}
interface DeepPartialSet&lt;T&gt; extends Set&lt;DeepPartial&lt;T&gt;&gt; {}
interface DeepPartialMap&lt;K, V&gt; extends Map&lt;DeepPartial&lt;K&gt;, DeepPartial&lt;V&gt;&gt; {}
type DeepPartial&lt;T&gt; = T extends PartialPrimitive
    ? T
    : T extends Array&lt;infer U&gt;
    ? DeepPartialArray&lt;U&gt;
    : T extends Map&lt;infer K, infer V&gt;
    ? DeepPartialMap&lt;K, V&gt;
    : T extends Set&lt;infer U&gt;
    ? DeepPartialSet&lt;U&gt;
    : Partial&lt;T&gt;;</pre><p class="callout-heading">Note</p><p class="callout">This workaround is no longer needed as of TypeScript 3.7.</p></li>
				<li>Lastly, let's make our <code>DeepPartial&lt;T&gt;</code> type support objects too:<pre>type DeepPartial&lt;T&gt; = T extends PartialPrimitive
    ? T
    : T extends Array&lt;infer U&gt;
    ? DeepPartialArray&lt;U&gt;
    : T extends Map&lt;infer K, infer V&gt;
    ? DeepPartialMap&lt;K, V&gt;
    : T extends Set&lt;infer U&gt;
    ? DeepPartialSet&lt;U&gt;
    : T extends {}
    ? { [K in keyof T]?: DeepPartial&lt;T[K]&gt; }
    : Partial&lt;T&gt;;</pre><p>This completes the <code>DeepPartial&lt;T&gt;</code> implementation.</p><p>A great use case for the <code>DeepPartial&lt;T&gt;</code> type is in a server-side <code>PATCH</code> method handler, which updates a given resource with new data. In <code>PATCH</code> requests, all fields are usually optional:</p><pre>import express from 'express';
const app = express();
app.patch('/users/:userId', async (req, res) =&gt; {
    const userId = req.params.userId;
    const userUpdateData: DeepPartial&lt;User&gt; = req.body;
    const user = await User.getById(userId);
    await user.update(userUpdateData);
    await user.save();
    res.status(200).end(user);
});</pre><p>Notice that we use <code>DeepPartial&lt;User&gt;</code> to correctly type the body of the request, before passing it in the <code>update</code> method:</p></li>
			</ol>
			<div><div><img src="img/B14508_09_18.jpg" alt="Figure 9.18: The correctly typed request body&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18: The correctly typed request body</p>
			<p>As can be seen in the preceding figure, due to the usage of <code>DeepPartial&lt;T&gt;</code>, the request's body is typed correctly, such that all fields are optional, including nested ones.</p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor430"/>10. Event Loop and Asynchronous Behavior</h1>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>Activity 10.01: Movie Browser Using XHR and Callbacks </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Construct a new <code>XMLHttpRequest</code> object:<pre>    const xhr = new XMLHttpRequest();</pre></li>
				<li>Construct a new string for the search result URL using the <code>getSearchUrl</code> method:<pre>    const url = getSearchUrl(value);</pre></li>
				<li>Call the <code>open</code> and <code>send</code> methods of the <code>xhr</code> object:<pre>    xhr.open('GET', url);    xhr.send();</pre></li>
				<li>Add an event handler for the <code>xhr</code> object's <code>onload</code> event. Take the response and parse it as a JSON object. Store the result in a variable of the <code>SearchResultApi</code> interface. This data will have the results of our search in a <code>results</code> field. If we get no results, this means that our search failed:<pre>    xhr.onload = function() {        const data = JSON.parse(this.response) as SearchResultApi;    }</pre></li>
				<li>If the search returned no results, call the <code>clearResults</code> method:<pre>    if (data.results.length === 0) {        clearResults(value);    } </pre></li>
				<li>If the search returned some results, just take the first one and store it in a variable, ignoring the other ones:<pre>    else {        const resultMovie = data.results[0];    }</pre></li>
				<li>Inside the <code>onload</code> handler, in the successful search branch, create a new <code>XMLHttpRequest</code> object:<pre>    const movieXhr = new XMLHttpRequest();</pre></li>
				<li>Construct a new string for the search result URL using the <code>getMovieUrl</code> method:<pre>    const movieUrl = getMovieUrl(resultMovie.id);</pre></li>
				<li>Call the <code>open</code> and <code>send</code> method of the constructed <code>xhr</code> object:<pre>    movieXhr.open('GET', movieUrl);    movieXhr.send();</pre></li>
				<li>Add an event handler for the <code>xhr</code> object's <code>onload</code> event. Take the response and parse it as a JSON object. Store the result in a variable of the <code>MovieResultApi</code> interface. This response will have the general data for our movie, specifically, everything except the people who were involved in the movie. We will need to have another call to the API to get the data about the people:<pre>    movieXhr.onload = function () {        const movieData: MovieResultApi = JSON.parse(this.response);</pre></li>
				<li>Inside the <code>onload</code> handler, create a new <code>XMLHttpRequest</code> object:<pre>    const peopleXhr = new XMLHttpRequest();</pre></li>
				<li>Construct a new string for the search result URL using the <code>getPeopleUrl</code> method:<pre>    const peopleUrl = getPeopleUrl(resultMovie.id);</pre></li>
				<li>Call the <code>open</code> and <code>send</code> method of the constructed <code>xhr</code> object:<pre>    peopleXhr.open('GET', peopleUrl);    peopleXhr.send();</pre></li>
				<li>Add an event handler for the <code>xhr</code> object's <code>onload</code> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <code>PeopleResultApi</code> interface. This response will have data about the people who were involved in the movie:<pre>    const data = JSON.parse(this.response) as PeopleResultApi;</pre></li>
				<li>Now we actually have all the data we need, so we can actually create our own object, inside the people <code>onload</code> handler, which is inside the movie <code>onload</code> handler, which is inside the search <code>onload</code> handler.<p>The people data has <code>cast</code> and <code>crew</code> properties. We'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array:</p><pre>    data.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = data.cast.slice(0, 6);</pre></li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into your own <code>Character</code> objects. We need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property:<pre>    const characters: Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</pre></li>
				<li>From the <code>crew</code> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const directors = data.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</pre></li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const writers = data.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</pre></li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses we've prepared so far:<pre>    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,
        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</pre></li>
				<li>Call the <code>showResults</code> function with the movie we constructed:<pre>    showResults(movie);</pre></li>
				<li>In your parent directory (<code>Activity01</code> in this case), install dependencies with <code>npm i</code>.</li>
				<li>Compile the program using <code>tsc ./script.ts ./interfaces.ts ./display.ts</code>.</li>
				<li>Verify that the compilation ended successfully.</li>
				<li>Open <code>index.html</code> using the browser of your choice. <p>You should see the following in your browser:</p></li>
			</ol>
			<div><div><img src="img/B14508_10_04.jpg" alt="Figure 10.5: The final web page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5: The final web page</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor433"/><a id="_idTextAnchor434"/>Activity 10.02: Movie Browser Using fetch and Promises</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Above the <code>search</code> function, create a helper function called <code>getJsonData</code>. This function will use the <code>fetch</code> API to get data from an endpoint and format it as JSON. It should take a single string called <code>url</code> as a parameter, and it should return a promise:<pre>const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {}</pre></li>
				<li>In the body of the <code>getJsonData</code> function, add code that calls the <code>fetch</code> function with the <code>url</code> parameter, and <code>then</code> call the <code>json</code> method on the returned response:<pre>const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {    return fetch(url)        .then(response =&gt; response.json());}</pre></li>
				<li>In the <code>search</code> method, construct a new string for the search result URL using the <code>getSearchUrl</code> method:<pre>    const searchUrl = getSearchUrl(value);</pre></li>
				<li>Call the <code>getJsonData</code> function with <code>searchUrl</code> as a parameter:<pre>    return getJsonData(searchUrl)</pre></li>
				<li>Add a <code>then</code> handler to the promise returned from <code>getJsonData</code>. The handler takes a single parameter of the type <code>SearchResultApi</code>:<pre>    return getJsonData(url)        .then((data:SearchResultApi) =&gt; {        }</pre></li>
				<li>In the body of the handler, check whether we have any results and if we don't, throw an error. If we do have results, return the first item. Note that the handler returns an object with <code>id</code> and <code>title</code> properties, but the <code>then</code> method actually returns a promise of that data. This means that after the handler, we can chain other <code>then</code> calls:<pre>    .then((data:SearchResultApi) =&gt; {        if (data.results.length === 0) {            throw Error("Not found");        }        return data.results[0];    })</pre></li>
				<li>Add another <code>then</code> call to the previous handler. This handler will take a <code>movieResult</code> parameter that contains the <code>id</code> and <code>title</code> of the movie. Use the <code>id</code> property to call the <code>getMovieUrl</code> and <code>getPeopleUrl</code> methods to, respectively, get the correct URLs for the movie details and for the cast and crew:<pre>    })    .then(movieResult =&gt; {        const movieUrl = getMovieUrl(movieResult.id);        const peopleUrl = getPeopleUrl(movieResult.id);    })</pre></li>
				<li>After getting the URLs, call the <code>getJsonData</code> function with both of them, and assign the resulting values to variables. Note that the <code>getJsonData(movieUrl)</code> call will return a promise of <code>MovieResultApi</code>, and <code>getJsonData(peopleUrl)</code> will return a promise of <code>PeopleResultApi</code>. Assign those result values to variables called <code>dataPromise</code> and <code>peoplePromise</code>:<pre>    const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);    const dataPromise: Promise&lt;MovieResultApi&gt; = getJsonData(movieUrl);    const peoplePromise: Promise&lt;PeopleResultApi&gt; = getJsonData(peopleUrl);</pre></li>
				<li>Call the static <code>Promise.all</code> method with <code>dataPromise</code> and <code>peoplePromise</code> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results:<pre>    const resultPromise = Promise.all([dataPromise, peoplePromise]);</pre></li>
				<li>Return the promise generated by the <code>Promise.all</code> call from the handler:<pre>        return resultPromise;    })</pre></li>
				<li>Add another <code>then</code> handler to the chain. This handler will take the array returned from <code>Promise.all</code> as a single parameter:<pre>    })    .then(dataResult =&gt; {    });</pre></li>
				<li>Deconstruct the parameter into two variables. The first element of the array should be the <code>movieData</code> variable of type <code>MovieResultApi</code>, and the second element of the array should be the <code>peopleData</code> variable of type <code>PeopleResultApi</code>:<pre>    const [movieData, peopleData] = dataResult // we can actually let TypeScripts type inference pick out the types</pre></li>
				<li>The people data has <code>cast</code> and <code>crew</code> properties. We'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array:<pre>    peopleData.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);</pre></li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into our own <code>Character</code> objects. We need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property:<pre>    const characters :Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</pre></li>
				<li>From the <code>crew</code> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const directors = peopleData.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</pre></li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const writers = peopleData.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</pre></li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses we've prepared so far:<pre>    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</pre></li>
				<li>Return the <code>Movie</code> object from the handler:<pre>        return movie;    });</pre><p>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <code>click</code> event handler of the <code>search</code> button. We should simply add a <code>then</code> handler to the <code>search</code> call that will call the <code>showResults</code> method, and a <code>catch</code> handler that will call the <code>clearResults</code> method:</p><pre>    search(movieTitle)        .then(movie =&gt; showResults(movie))        .catch(_ =&gt; clearResults(value));</pre></li>
			</ol>
			<p>The output should be the same as the previous activity.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor435"/><a id="_idTextAnchor436"/>Activity 10.03: Movie Browser Using fetch and async/await</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <code>script.ts</code> file, locate the <code>search</code> function and verify that it takes a single string parameter and that its body is empty. Note that this function is now marked with the <code>async</code> keyword, which allows us to use the <code>await</code> operator:<pre>const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {}</pre></li>
				<li>In the body of the <code>getJsonData</code> function, add code that calls and <code>await</code>s the <code>fetch</code> function with the <code>url</code> parameter, and then call calls the <code>json</code> method on the returned response:<pre>const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {    const response = await fetch(url);    return response.json();}</pre></li>
				<li>In the <code>search</code> method, construct a new string for the search result URL using the <code>getSearchUrl</code> method:<pre>    const url = getSearchUrl(value);</pre></li>
				<li>Call the <code>getJsonData</code> function with the <code>searchUrl</code> as a parameter, and <code>await</code> the result. Place the result in the <code>SearchResultApi</code> variable:<pre>    const data: SearchResultApi = await getJsonData(url);</pre></li>
				<li>Check whether we have any results and if we don't, throw an error. If we do have results, set the first item of the <code>result</code> property in a variable called <code>movieResult</code>. This object will contain the <code>id</code> and <code>title</code> properties of the movie:<pre>    if (data.results.length === 0) {        throw Error("Not found");    }    const movieResult = data.results[0];</pre></li>
				<li>Use the <code>id</code> property to call the <code>getMovieUrl</code> and <code>getPeopleUrl</code> methods to, respectively, get the correct URLs for the movie details and for the cast and crew:<pre>    const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);</pre></li>
				<li>After getting the URLs, call the <code>getJsonData</code> function with both and assign the resulting values to variables. Note that the <code>getJsonData(movieUrl)</code> call will return a promise of <code>MovieResultApi</code>, and <code>getJsonData(peopleUrl)</code> will return a promise of <code>PeopleResultApi</code>. Assign those result values to variables called <code>dataPromise</code> and <code>peoplePromise</code>:<pre>    const dataPromise: Promise&lt;MovieResultApi&gt; = getJsonData(movieUrl);    const peoplePromise: Promise&lt;PeopleResultApi&gt; = getJsonData(peopleUrl);</pre></li>
				<li>Call the static <code>Promise.all</code> method with <code>dataPromise</code> and <code>peoplePromise</code> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results. <code>await</code> this promise, and place its result in a variable of type array:<pre>    const dataArray = await Promise.all([dataPromise, peoplePromise]);</pre></li>
				<li>Deconstruct that array into two variables. The first element of the array should be the <code>movieData</code> variable of type <code>MovieResultApi</code>, and the second element of the array should be the <code>peopleData</code> variable of type <code>PeopleResultApi</code>:<pre>     const [movieData, peopleData] = dataArray;</pre></li>
				<li>The people data has <code>cast</code> and <code>crew</code> properties. We'll only take the first six cast members, so first sort the <code>cast</code> property according to the <code>order</code> property of the cast members. Then slice off the first six cast members into a new array:<pre>    peopleData.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);</pre></li>
				<li>Transform the cast data (which is <code>CastResultApi</code> objects) into our own <code>Character</code> objects. We need to map the <code>character</code> field of <code>CastResultApi</code> to the <code>name</code> field of <code>Character</code>, the <code>name</code> field to the <code>actor</code> name, and the <code>profile_path</code> field to the <code>image</code> property:<pre>    const characters :Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</pre></li>
				<li>From the <code>crew</code> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers, and concatenate them, respectively. For the directors, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Directing</code> and a <code>job</code> of <code>Director</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const directors = peopleData.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</pre></li>
				<li>For the writers, from the <code>crew</code> property, filter the people who have a <code>department</code> of <code>Writing</code> and a <code>job</code> of <code>Writer</code>. For those objects, take the <code>name</code> property, and <code>join</code> it together with an <code>&amp;</code> in between:<pre>    const writers = peopleData.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</pre></li>
				<li>Create a new <code>Movie</code> object (using object literal syntax). Fill in all the properties of the <code>Movie</code> object using the data from the movie and people responses we've prepared so far:<pre>    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</pre></li>
				<li>Return the <code>Movie</code> object from the function:<pre>    return movie; </pre></li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <code>click</code> event handler of the <code>search</code> button. We should simply <code>await</code> the result of the <code>search</code> call and then call the <code>showResults</code> method with it. We can use a standard <code>catch</code> expression to handle any errors:<pre>    try {        const movie = await search(movieTitle);        showResults(movie);    } catch {        clearResults(movieTitle);    }</pre></li>
			</ol>
			<p>The output should be the same as the previous activity.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor437"/>11. Higher-Order Functions and Callbacks</h1>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor438"/><a id="_idTextAnchor439"/>Activity 11.01: Higher-Order Pipe Function</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll build a higher-order <code>pipe</code> function that accepts functions as arguments, and composes them from left to right, returning a function that accepts the arguments of the first function, and returns the type of the last function. When the returned function is run, it iterates over the given functions, feeding the return value of each function to the next one:</p>
			<ol>
				<li value="1">Let's start by defining a type definition for the supported functions to compose, a function that accepts one argument of type <code>T</code> and returns one of type <code>R</code>:<pre>type UnaryFunction&lt;T, R&gt; = T extends void ? () =&gt; R : (arg: T) =&gt; R;</pre><p>As mentioned, we'll only support functions accepting up to one argument, for simplicity.</p><p>Note that in order to deal with the special case of 0 arguments, we need to check whether <code>T extends void</code> and returns a parameterless function.</p></li>
				<li>Next, let's start by writing a simple implementation of the <code>pipe</code> function, one that supports only a single function, making it essentially an identity function:<pre>function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;
function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt; {
    return fn;
}</pre><p>Note that we require two overloads for the function, one for the special case of no parameters, and another for a single-parameter function.</p></li>
				<li>Let's expand this to support two functions by adding another overload:<pre>function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;
function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2?: UnaryFunction&lt;A, R&gt;) {
  // TODO: Support two functions
}</pre><p>The previous implementation no longer works, since we need to support both a single function, as well as multiple functions, so we can no longer just return <code>fn</code>. We'll add a naïve implementation for now and expand it to a more generic solution in the next steps.</p></li>
				<li>The naïve implementation for supporting two functions is to simply check whether <code>fn2</code> is <code>undefined</code> – if it is, we only have a single function at hand, and can simply return <code>fn1</code>. Otherwise, we need to return a function that composes <code>fn1</code> and <code>fn2</code> on the given argument:<pre>function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;
function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2?: UnaryFunction&lt;A, R&gt;) {
  if (fn2 === undefined) {
    return fn1;
  }
  return (arg: T) =&gt; {
    return fn2(fn1(arg));
  };
}</pre></li>
				<li>We can persist with the preceding approach, but it is tedious, and supporting more functions means changing the implementation. Instead, we can make the actual implementation accept an array of functions and reduce them, starting with <code>arg</code> as the initial value, and running the current function, <code>fn</code>, on the accumulator (the previous result). Let's do that, while still only supporting up to two functions:<pre>function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;
function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;
function pipe&lt;T&gt;(...fns: UnaryFunction&lt;any, any&gt;[]): UnaryFunction&lt;any, any&gt; {
  return (arg: T) =&gt; {
    return fns.reduce((prev, fn) =&gt; fn(prev), arg);
  };
}</pre></li>
				<li>Lastly, we can expand our support for more functions by only needing to change the function declaration by adding another overload with the correct type:<p>In the case of three functions:</p><pre>function pipe&lt;T, A, B, R&gt;(
  fn1: UnaryFunction&lt;T, A&gt;,
  fn2: UnaryFunction&lt;A, B&gt;,
  fn3: UnaryFunction&lt;B, R&gt;,
): UnaryFunction&lt;T, R&gt;;</pre><p>In the case of four functions:</p><pre>function pipe&lt;T, A, B, C, R&gt;(
  fn1: UnaryFunction&lt;T, A&gt;,
  fn2: UnaryFunction&lt;A, B&gt;,
  fn3: UnaryFunction&lt;B, C&gt;,
  fn4: UnaryFunction&lt;C, R&gt;,
): UnaryFunction&lt;T, R&gt;;</pre><p> In the case of five functions:</p><pre>function pipe&lt;T, A, B, C, D, R&gt;(
  fn1: UnaryFunction&lt;T, A&gt;,
  fn2: UnaryFunction&lt;A, B&gt;,
  fn3: UnaryFunction&lt;B, C&gt;,
  fn4: UnaryFunction&lt;C, D&gt;,
  fn5: UnaryFunction&lt;D, R&gt;,
): UnaryFunction&lt;T, R&gt;;</pre><p>In each overload, we have the first generic as <code>T</code> – this is the type of argument that the returned function will have, and <code>R</code> – the return type of the returned function. Between them we have <code>A</code>, <code>B</code>, <code>C, </code>and so on, as the interim return type/argument type of the second…second to last functions. For all the preceding steps, make sure to export the functions by adding <code>export</code> before the <code>function</code> keyword.</p><p>Finally, we can use our <code>pipe</code> function to compose any functions we want, while staying completely type-safe:</p><pre>const composedFn = pipe(
  (x: string) =&gt; x.toUpperCase(),
  x =&gt; [x, x].join(','),
  x =&gt; x.length,
  x =&gt; x.toString(),
  x =&gt; Number(x),
);
console.log('result is:', composedFn('hello'))</pre><p>Running the this code should result in the following output:</p><pre>result is: 11</pre></li>
			</ol>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor440"/>12. Guide to Promises in TypeScript</h1>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor441"/><a id="_idTextAnchor442"/>Activity 12.01: Building a Promise App </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">We can get started the same way we started building our API from the sample from GitHub:<pre>npm i</pre><p>The only dependencies we're using here are <code>http-server</code> to power our web application and <code>typescript</code> to transpile our code. Now that our project is set up, let's quickly create an <code>index.html</code> file:</p><pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;The TypeScript Workshop - Activity 12.1&lt;/title&gt;
    &lt;link href="styles.css" rel="stylesheet"&gt;&lt;/link&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input type="text" placeholder="What promise will you make?" id="promise-input"&gt; &lt;button id="promise-save"&gt;save&lt;/button&gt;
    &lt;div&gt;
        &lt;table id="promise-table"&gt;&lt;/ul&gt;
    &lt;/div&gt;
  &lt;/body&gt;
  &lt;script type="module" src="img/app.js"&gt;&lt;/script&gt;
&lt;/html&gt;</pre></li>
				<li>And then a <code>styles.css</code> file:<pre>body {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 12px;
}
input {
  width: 200;
}
table {
  border: 1px solid;
}
td {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}</pre><p>Now we will create an <code>app.ts</code> file and create a very rough client library that implements a <code>fetch</code> abstraction similar to what we created in <em class="italic">Chapter 3, Functions</em>. Because TypeScript doesn't run natively in a web browser, we will need to use <code>tsc</code> to transpile our TypeScript code into JavaScript. There are some advanced tools such as webpack and Parcel that can help with this, but those are out of scope for this chapter so we will keep this simple and just use a single <code>app.ts</code> file.</p></li>
				<li>We'll use our <code>PromiseModel</code> interface again in our web app and create a <code>fetchClient</code> function using currying:<pre>interface PromiseModel {
  id?: number;
  desc: string;
}
const fetchClient = (url: string) =&gt; (resource: string) =&gt; (method: string) =&gt; (
  body?: PromiseModel
) =&gt; {
  return fetch(`${url}/${resource}`, {
    body: body &amp;&amp; JSON.stringify(body),
    headers: { "Content-Type": "application/json" },
    method,
  });
};</pre></li>
				<li>Building on the model of curried <code>fetch</code> functions, let's create some resources:<pre>const api = fetchClient("http://localhost:3000");
const resource = api("promise");
const getAction = resource("get");
const postAction = resource("post");</pre></li>
				<li>These functions handle invoking the resources and updating page elements:<pre>const deleteItem = (id: number) =&gt; {
  const resource = api(`promise/${id}`);
  resource("delete")().then(loadItems);
};
const loadItems = () =&gt; {
  getAction().then((res) =&gt; res.json().then(renderList));
};
const saveItem = () =&gt; {
  const input = document.getElementById("promise-input") as HTMLInputElement;
  if (input.value) {
    postAction({ desc: input.value }).then(loadItems);
    input.value = "";
  }
};</pre></li>
				<li>Finally, we'll do some ugly HTML manipulation to update the UI:<pre>const renderList = (data: PromiseModel[]) =&gt; {
  const table = document.getElementById("promise-table");
  if (table) {
    table.innerHTML = "";
    let tr = document.createElement("tr");
    ["Promise", "Delete"].forEach((label) =&gt; {
      const th = document.createElement("th");
      th.innerText = label;
      tr.appendChild(th);
    });
    table.appendChild(tr);
    data.forEach((el) =&gt; {
      table.appendChild(renderRow(el));
    });
  }
};
const renderRow = (el: PromiseModel) =&gt; {
  const tr = document.createElement("tr");
  const td1 = document.createElement("td");
  td1.innerHTML = el.desc;
  tr.appendChild(td1);
  const td2 = document.createElement("td");
  const deleteButton = document.createElement("button");
  deleteButton.innerText = "delete";
  deleteButton.onclick = () =&gt; deleteItem(el.id!);
  td2.appendChild(deleteButton);
  tr.appendChild(td2);
  return tr;
};
document.getElementById("promise-save")?.addEventListener("click", saveItem);
loadItems();</pre></li>
				<li>Altogether, the <code>app.ts</code> file looks like this:<pre>interface PromiseModel {
  id?: number;
  desc: string;
}
const fetchClient = (url: string) =&gt; (resource: string) =&gt; (method: string) =&gt; (
  body?: PromiseModel
) =&gt; {
  return fetch(`${url}/${resource}`, {
    body: body &amp;&amp; JSON.stringify(body),
    headers: { "Content-Type": "application/json" },
    method,
  });
};
const api = fetchClient("http://localhost:3000");
const resource = api("promise");
const getAction = resource("get");
const postAction = resource("post");
const deleteItem = (id: number) =&gt; {
  const resource = api(`promise/${id}`);
  resource("delete")().then(loadItems);
};
const loadItems = () =&gt; {
  getAction().then((res) =&gt; res.json().then(renderList));
};
const saveItem = () =&gt; {
  const input = document.getElementById("promise-input") as HTMLInputElement;
  if (input.value) {
    postAction({ desc: input.value }).then(loadItems);
    input.value = "";
  }
};
const renderList = (data: PromiseModel[]) =&gt; {
  const table = document.getElementById("promise-table");
  if (table) {
    table.innerHTML = "";
    let tr = document.createElement("tr");
    ["Promise", "Delete"].forEach((label) =&gt; {
      const th = document.createElement("th");
      th.innerText = label;
      tr.appendChild(th);
    });
    table.appendChild(tr);
    data.forEach((el) =&gt; {
      table.appendChild(renderRow(el));
    });
  }
};
const renderRow = (el: PromiseModel) =&gt; {
  const tr = document.createElement("tr");
  const td1 = document.createElement("td");
  td1.innerHTML = el.desc;
  tr.appendChild(td1);
  const td2 = document.createElement("td");
  const deleteButton = document.createElement("button");
  deleteButton.innerText = "delete";
  deleteButton.onclick = () =&gt; deleteItem(el.id!);
  td2.appendChild(deleteButton);
  tr.appendChild(td2);
  return tr;
};
document.getElementById("promise-save")?.addEventListener("click", saveItem);
loadItems();</pre><p>It's not hard to see why view frameworks are popular; however, this should do the trick for putting together a full-stack application. </p></li>
				<li>Now let's compile and run our web application. In one Command Prompt window, enter the following: <pre>npx tsc -w. </pre><p>This will transpile the TypeScript code in watch mode so that it restarts when changes are made. </p></li>
				<li>Start the HTTP server in another window with <code>npx http-server . -c-1</code> as we did in <em class="italic">Exercise 12.03, Promise.allSettled</em>.<p> Now navigate a web browser to <code>http://localhost:8080/</code>. You should see a form like the one that follows:  </p><div><img src="img/B14508_12_10.jpg" alt="Figure 12.10: Initial load&#13;&#10;"/></div><p class="figure-caption">Figure 12.10: Initial load</p><p class="callout-heading">Note</p><p class="callout">If you don't see "Promise Delete" then it could be that your API from Exercise 6, Implementing a RESTful API backed by sqlite isn't running. Return to that exercise and follow the steps there.</p><p>You can add and delete promises. Here are some examples:</p></li>
				<li>Add the promise <code>Always lint my code</code> and save it. You should see the following:<div><img src="img/B14508_12_11.jpg" alt="Figure 12.11: One promise made&#13;&#10;"/></div><p class="figure-caption">Figure 12.11: One promise made</p></li>
				<li>Add the promise <code>Never block the event loop</code> and save it: <div><img src="img/B14508_12_12.jpg" alt="Figure 12.12: Text entered&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.12: Text entered</p>
			<p>You should see the following promise saved:</p>
			<div><div><img src="img/B14508_12_13.jpg" alt="Figure 12.13: Text saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: Text saved</p>
			<p><em class="italic">Figure 12.14</em> and <em class="italic">Figure 12.15</em> show some more examples:</p>
			<div><div><img src="img/B14508_12_14.jpg" alt="Figure 12.14: Another promise saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: Another promise saved</p>
			<div><div><img src="img/B14508_12_15.jpg" alt="Figure 12.15: Another promise saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.15: Another promise saved</p>
			<p>Try to add to the application and make use of the API to get a single promise or update promises. </p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor443"/>13. Async/Await in TypeScript</h1>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor444"/><a id="_idTextAnchor445"/>Activity 13.01: Refactoring Chained Promises to Use await</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Let's go over what needed to change in order to make this work:</p>
			<ol>
				<li value="1">First of all, the <code>await</code> keyword can only be used inside an <code>async</code> function, so we must add that keyword to the function declaration:<pre>const renderAll = async () =&gt; {</pre></li>
				<li>Now we have to replace <code>then</code> with <code>await</code>. Let's look again at what the <code>render</code> function does. In our simple case, it just returns a promise that resolves to a string, but in the real world, it would render something in a web browser and then resolve to a string. Since we want to log out that string, we can actually resolve the promise inside a <code>console.log</code> statement. Even though <code>console.log</code> is a synchronous operation, putting <code>await</code> inside it will cause the function to print out the resolved promise value, exactly as we would hope.<p>The refactored program is six lines shorter and eliminates nesting:</p><pre>export class El {
  constructor(private name: string) {}
  render = () =&gt; {
    return new Promise((resolve) =&gt;
      setTimeout(
        () =&gt; resolve(`${this.name} is resolved`),
        Math.random() * 1000
      )
    );
  };
}
const e1 = new El('header');
const e2 = new El('body');
const e3 = new El('footer');
const renderAll = async () =&gt; {
  console.log(await e1.render());
  console.log(await e2.render());
  console.log(await e3.render());
};
renderAll();</pre></li>
				<li>Run the file using <code>npx</code> <code>ts-node</code> <code>refactor.ts</code>. You should get the following output:<pre>header is resolved
body is resolved
footer is resolved</pre></li>
			</ol>
			<h1 id="_idParaDest-364"><a id="_idTextAnchor446"/>14. TypeScript and React</h1>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor447"/><a id="_idTextAnchor448"/>Activity 14.01: The Blog</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new React application as outlined earlier in this chapter.</li>
				<li>Prepare a Firestore database with authentication on Firebase as outlined in <em class="italic">Exercise 14.04, Getting Started with Firebase</em>.</li>
				<li>Install the Firebase client with <code>npm i firebase</code>. Firebase includes typings so we won't need to install those separately.</li>
				<li>Create a directory called <code>services</code> under <code>src</code> and a file called <code>firebase.ts</code> there. The Firebase integration can be pretty basic:<pre>import firebase from 'firebase';const config = {  apiKey: 'abc123',  authDomain: 'blog-xxx.firebaseapp.com',  projectId: 'https://blog-xxx.firebaseio.com',  storageBucket: 'blog-xxx.appspot.com',  messagingSenderId: '999',  appId: '1:123:web:123abc',};firebase.initializeApp(config);export const auth = firebase.auth();export const db = firebase.firestore();</pre></li>
				<li>Make sure to use the values from the Firebase dashboard. This will expose Firebase's authentication and database capabilities to the rest of your application.</li>
				<li>Set up two providers under <code>src/providers</code> called <code>StoriesProvider.ts</code> and <code>UserProvider.ts</code>. Now, <code>UserProvider.ts</code> will be simpler, so let's do that one first. Like <em class="italic">Exercise 14.03</em>, <em class="italic">React Context</em>, we'll employ <code>createContext</code> and <code>useState</code>, but we'll also need <code>useEffect</code>:<pre>import firebase from 'firebase';
import React, { createContext, ReactNode, useEffect, useState } from 'react';
import { auth } from '../services/firebase';
interface ContextProps {
  children: ReactNode;
}
export const UserContext = createContext&lt;Partial&lt;firebase.User | undefined&gt;&gt;(
  {}
);
export const UserProvider = (props: ContextProps) =&gt; {
  const [user, setUser] = useState&lt;firebase.User&gt;();
  useEffect(() =&gt; {
    auth.onAuthStateChanged((userAuth) =&gt; {
      setUser(userAuth ?? undefined);
    });
  });
  return (
    &lt;UserContext.Provider value={user}&gt;{props.children}&lt;/UserContext.Provider&gt;
  );
};</pre></li>
				<li><code>StoriesProvider.ts</code> is responsible for persisting stories (the blog links) and comments on the stories. To make this work, start by creating interfaces for comments and stories. Comments should belong to stories. Here's a sample of how that could be done:<pre>export interface CommentModel {  comment: string;  timestamp: number;  user: string;}export interface StoryModel {  comments: CommentModel[];  id: string;  link: string;  title: string;  user: string;}</pre><p>With those interfaces created, we need to implement some methods in our provider, namely methods for adding comments and stories as well as a method that will fetch all the stories. To do that, we'll need to access a collection in our database. This can be done with a single line of code:</p><pre>const storiesDB = db.collection('stories');</pre><p>This code will create the collection if it doesn't exist. The <code>storiesDB</code> object we created has methods for fetching, adding, and updating documents from the collection. With those methods implemented, we add our stories data and the methods that handle the data to our provider value. This means that components that use <code>StoriesContext</code> will be able to call those methods or access that data.</p><p>Again, the solution to this somewhat complicated provider is available on GitHub.</p></li>
				<li>Raw document data is a bit difficult to work with, but Firebase has the concept of a converter that we can create, which will tell it how to map document fields to our TypeScript objects. Create and export a converter implementing the <code>fromFirestore</code> and <code>toFirestore</code> methods. Using those should eliminate some type errors and avoid us needing to use <code>any</code>.</li>
				<li>Install React Router (<code>react-dom</code> and <code>react-router-dom</code>). Set the default route to a home page. Then, create <code>Add</code>, <code>Signin</code>, and <code>Signup</code> pages. Put the pages under <code>src/pages</code>. Just put some text on them in a basic function component to verify routing is working as expected.</li>
				<li>Build out the <code>Signup</code> page first as it's hard to sign in without having signed up. Now we'll use Material-UI. Install <code>@material-ui/core</code> and <code>@material-ui/icons</code> and we can start building components.</li>
				<li>Our <code>Signup</code> page can be created using <code>Container</code>, <code>TextField</code>, and <code>Button</code>, which are all available components in Material-UI. How your page ultimately looks is up to you, but you will need two <code>TextField</code> components. One of those should have both a <code>type</code> and <code>name</code> of <code>"email"</code> and the other should have <code>"password"</code> for both of those props.<p>We'll track the state of both the email and password fields using <code>useState</code> and an <code>onChange</code> event.</p><p>When the button is clicked, we should call a method on the <code>auth</code> object we exported from our Firebase service earlier to create a new user using the given email address and password.</p></li>
				<li>Upon successfully signing in, let's send the user back to the home page with the <code>useHistory</code> React Hook.</li>
				<li>The <code>Signin</code> page will be a lot like the <code>Signup</code> page. It also needs to capture the user's email address and password and have a button to submit the form. This time we should call a method on <code>auth</code> to sign the user in via an email and password.</li>
				<li>Our <code>Add</code> page creates new posts to the blog. We'll capture the title of the post and a link. Add additional fields if you like. This will work similarly to the prior two pages, but now we will use <code>StoriesContext</code> instead of <code>UserContext</code> to expose the method to add stories.</li>
				<li>For the home page, we can just load up all the stories and display them as a Material-UI <code>List</code>. It's possible to just output the <code>story</code> object and wrap it in HTML tags to make it look presentable, but a better solution is to create a <code>Story</code> component that can better encapsulate the object. Add a <code>Story</code> component to <code>src/components</code> and use that for your story display.</li>
				<li>To manage comments, each story should have its own comments. It's a good idea to create this as a separate component that each story will contain. The <code>Comments</code> component can contain a list of each individual comments (another component!) as well as controls for grabbing that method to add comments from <code>StoriesContext</code>.</li>
				<li>At this point, everything is working quite well, but we should add some navigation elements so users don't have to key in the different routes. We can use the <code>AppBar</code>, <code>Toolbar</code>, <code>Menu</code>, <code>MenuItem</code>, and <code>Button</code> components from Material-UI to create some attractive navigation options. Navigation itself can be performed via the <code>useHistory</code> React Hook.</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	

		<div><div><img src="img/Author_Page1.png" alt=""/>
			</div>
		</div>
		<div><div></div>
		</div>
		<div><h2 id="_idParaDest-366">Hey!</h2>
			<p>We're Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski, the authors of this book. We really hope you enjoyed reading our book and found it useful for learning TypeScript.</p>
			<p>It would really help us (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on <em class="italic">The TypeScript Workshop</em>.</p>
			<p>Go to the link <a href="">https://packt.link/r/1838828494</a>.</p>
			<p>OR</p>
			<p>Scan the QR code to leave your review.</p>
			<div><div><img src="img/qr-code-https___packt.link_r_1838828494.jpg" alt="Barcode"/>
				</div>
			</div>
			<p>Your review will help us to understand what's worked well in this book and what could be improved upon for future editions, so it really is appreciated.</p>
			<p>Best wishes,</p>
			<p>Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski</p>
		</div>
		<div><div><img src="img/Packt_Logo.png" alt="Packt Logo"/>
			</div>
		</div>
	</body></html>