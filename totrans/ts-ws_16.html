<html><head></head><body>
		<div id="_idContainer176" class="Content">
			<h1 id="_idParaDest-323"><a id="_idTextAnchor373"/>Appendix</h1>
		</div>
		<div id="_idContainer191" class="Content">
			<h1 id="_idParaDest-324"><a id="_idTextAnchor374"/>1. TypeScript Fundamentals</h1>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor375"/><a id="_idTextAnchor376"/>Activity 1.01: Creating a Library for Working with Strings</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Here are the steps that will help you create all the functions listed in the activity problem statement.</p>
			<h3 id="_idParaDest-326"><a id="_idTextAnchor377"/>toTitleCase</h3>
			<p>The <strong class="source-inline">toTitleCase</strong> function will process a string and capitalize the first letter of each word, but will make all the other letters lowercase.</p>
			<p>Test cases for this function are as follows:</p>
			<p class="source-code">"war AND peace" =&gt; "War And Peace"</p>
			<p class="source-code">"Catcher in the Rye" =&gt; "Catcher In The Rye"</p>
			<p class="source-code"> "tO kILL A mOCKINGBIRD" =&gt; "To Kill A MockingBird"</p>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li><a id="_idTextAnchor378"/>This function will take a single parameter that is a string and return a string as well:<p class="source-code">function toTitleCase (input:string) : string {</p></li>
				<li>First off, we will split the input into an array of strings using the split string method. We'll split on every space character:<p class="source-code">    // split the string into an array on every occurrence of </p><p class="source-code">    //  the space character     const words = input.split(" ");</p></li>
				<li>Next, we will define a new array that will hold each word as we transform it into title case, and use a for..of loop to loop through the array of words:<p class="source-code">    const titleWords = [];    // loop through each word     for (const word of words) {</p></li>
				<li>For each word we will extract the first character and the rest of the characters using the slice string method. We will transform the initial to uppercase, and the rest of the characters to lowercase. Next, we'll join them back together to form a complete word and push the result to the holding array:<p class="source-code">    // take the first character using `slice` and convert it to uppercase     const initial = word.slice(0, 1).toLocaleUpperCase();    // take the rest of the character using `slice` and convert them to lowercase     const rest = word.slice(1).toLocaleLowerCase();    // join the initial and the rest and add them to the resulting array     titleWords.push(`${initial}${rest}`);</p></li>
				<li>At last, we will join all the processed words together, with a separating space, and we have our result:<p class="source-code">    // join all the processed words     const result = titleWords.join(" ");    return result;}</p></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<p class="source-code">console.log(`toTitleCase("war AND peace"):`);console.log(toTitleCase("war AND peace")); console.log(`toTitleCase("Catcher in the Rye"):`);console.log(toTitleCase("Catcher in the Rye"));console.log(`toTitleCase("tO kILL A mOCKINGBIRD"):`);console.log(toTitleCase("tO kILL A mOCKINGBIRD"));</p></li>
				<li>We should receive the results:<p class="source-code">toTitleCase("war AND peace"):War And Peace toTitleCase("Catcher in the Rye"):Catcher In The Rye toTitleCase("tO kILL A mOCKINGBIRD"):To Kill A Mockingbird</p></li>
			</ol>
			<h3 id="_idParaDest-327"><a id="_idTextAnchor379"/>countWords<a id="_idTextAnchor380"/></h3>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">The countWords function will count the number of separate words within a string. Words are delimited by spaces, dashes (-), or underscores (_). Test cases for this function are as follows:<p class="source-code">"War and Peace" =&gt; 3 </p><p class="source-code">"catcher-in-the-rye" =&gt; 4 </p><p class="source-code">"for_whom the-bell-tolls" =&gt; 5</p></li>
				<li>Create the <strong class="source-inline">countWords</strong> function using the following code:<p class="source-code">function countWords (input: string): number {</p></li>
				<li>Split the words using a regex that will match any occurrence of a space, underscore, or dash character:   <p class="source-code">    const words = input.split(/[ _-]/);</p></li>
				<li>Return the length of the array that is the result of the split:<p class="source-code">    return words.length;</p><p class="source-code">}</p></li>
				<li>Test the function and console out the results:<p class="source-code">console.log(`countWords("War and Peace"):`);</p><p class="source-code">console.log(countWords("War and Peace"));</p><p class="source-code"> </p><p class="source-code">console.log(`countWords("catcher-in-the-rye"):`);</p><p class="source-code">console.log(countWords("catcher-in-the-rye"));</p><p class="source-code">console.log(`countWords("for_whom the-bell-tolls"):`);</p><p class="source-code">console.log(countWords("for_whom the-bell-tolls"));</p></li>
			</ol>
			<h3 id="_idParaDest-328"><a id="_idTextAnchor381"/>toWords</h3>
			<p>The <strong class="source-inline">toWords</strong> function will return all the words that are within a string. Words are delimited by spaces, dashes (<strong class="source-inline">-</strong>), or underscores (<strong class="source-inline">_</strong>).</p>
			<p>Test cases for this function are as follows:</p>
			<p class="source-code">"War and Peace" =&gt; [War, and, peace]</p>
			<p class="source-code">"catcher-in-the-rye" =&gt; [catcher, in, the, rye]</p>
			<p class="source-code">"for_whom the-bell-tolls" =&gt; [for, whom, the, bell, tolls]</p>
			<p>This function is very similar to the previous one we developed. The significant difference is that we need to return not only the number of words but also the actual words themselves. So, instead of a number, this function will return an array of strings:</p>
			<ol>
				<li value="1">Here is the code to create this function:<p class="source-code">function toWords (input: string): string[] {</p></li>
				<li>Once more, we will need to split the input into an array of strings using the split string method, using the [ _-] regular expression. Split the words using a regular expression that will match any occurrence of a space, underscore, or dash character:<p class="source-code">   const words = input.split(/[ _-]/);</p></li>
				<li>Once we have the words, we can just return them:<p class="source-code">    // return the words that were split     return words;}</p></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<p class="source-code">console.log(`toWords("War and Peace"):`);console.log(toWords("War and Peace")); console.log(`toWords("catcher-in-the-rye"):`);console.log(toWords("catcher-in-the-rye"));console.log(`toWords("for_whom the-bell-tolls"):`);console.log(toWords("for_whom the-bell-tolls"));</p></li>
				<li>We should receive the results:<p class="source-code">toWords("War and Peace"):[ 'War', 'and', 'Peace' ]toWords("catcher-in-the-rye"):[ 'catcher', 'in', 'the', 'rye' ]toWords("for_whom the-bell-tolls"):[ 'for', 'whom', 'the', 'bell', 'tolls' ]</p></li>
			</ol>
			<h3 id="_idParaDest-329"><a id="_idTextAnchor382"/><a id="_idTextAnchor383"/>repeat</h3>
			<p><strong class="source-inline">repeat</strong> will take a string and a number and return that same string repeated that number of times.</p>
			<p>Test cases for this function are as follows:</p>
			<p class="source-code">„War", 3 =&gt; „WarWarWar"</p>
			<p class="source-code">„rye", 1 =&gt; „rye"</p>
			<p class="source-code">„bell", 0 =&gt; „"</p>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take two parameters, one that is a string and a second one that is a number, and return a string as well:<p class="source-code">function repeat (input: string, times: number): string {</p><p>There are many ways to implement this function, and we'll illustrate one approach. We can create an array with the required number of elements, and then use the array's <strong class="source-inline">fill</strong> method to fill it with the value of the string. In that way, we will have an array of <strong class="source-inline">times</strong> elements, and each element will have the <strong class="source-inline">input</strong> value:</p><p class="source-code">    // create a new array that with length of `times`    // and set each element to the value of the `input` string     const instances = new Array(times).fill(input);</p></li>
				<li>Next, we just need to join all the instances, using an empty string as the delimiter. That way, we're making sure that no spaces or commas are inserted between the strings:<p class="source-code">    // join the elements of the array together     const result = instances.join("");    return result;}</p></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<p class="source-code">console.log(`repeat("War", 3 ):`);console.log(repeat("War", 3 )); console.log(`repeat("rye", 1):`);console.log(repeat("rye", 1));console.log(`repeat("bell", 0):`);console.log(repeat("bell", 0));</p></li>
				<li>We should receive the following results:<p class="source-code">repeat("War", 3 ):WarWarWar repeat("rye", 1):rye repeat("bell", 0):</p></li>
			</ol>
			<h3 id="_idParaDest-330"><a id="_idTextAnchor384"/><a id="_idTextAnchor385"/>isAlpha</h3>
			<p><strong class="source-inline">isAlpha</strong> returns <strong class="source-inline">true</strong> if the string only has alpha characters (that is, letters). Test cases for this function are as follows:</p>
			<p class="source-code">"War and Peace" =&gt; false</p>
			<p class="source-code">"Atonement" =&gt; true</p>
			<p class="source-code">"1Q84" =&gt; false</p>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take a single parameter that is a string and return a Boolean:<p class="source-code">function isAlpha (input: string): boolean {</p></li>
				<li>For this function to work, we need to check whether each character is a lower- or uppercase letter. One of the best ways to determine that is to use a regular expression that checks it. In particular, the character group [a-z] will check for a single character and if we use the star quantifier (*), we can tell the regular expression to check for all the characters. We can add the i modifier to the regular expression to make the match case-insensitive, so we don't need to worry about letter casing:<p class="source-code">// regex that will match any string that only has upper and  //lowercase letters     const alphaRegex = /^[a-z]*$/i</p></li>
				<li>Next, we need to actually test our input. Since we only need to know whether the string matches, we can use the test method of the regular expression and return its result:<p class="source-code">    // test our input using the regex     const result = alphaRegex.test(input);    return result;}</p></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<p class="source-code">console.log(`isAlpha("War and Peace"):`);console.log(isAlpha("War and Peace")); console.log(`isAlpha("Atonement"):`);console.log(isAlpha("Atonement"));console.log(`isAlpha("1Q84"):`);console.log(isAlpha("1Q84"));</p></li>
				<li>We should receive the results:<p class="source-code">isAlpha("War and Peace"):false isAlpha("Atonement"):true isAlpha("1Q84"):false</p></li>
			</ol>
			<h3 id="_idParaDest-331"><a id="_idTextAnchor386"/><a id="_idTextAnchor387"/>isBlank</h3>
			<p><strong class="source-inline">isBlank</strong> returns <strong class="source-inline">true</strong> if the string is blank, that is, it consists only of whitespace characters.</p>
			<p>Test cases for this function are as follows:</p>
			<p class="source-code">"War and Peace" =&gt; false</p>
			<p class="source-code">"       " =&gt; true</p>
			<p class="source-code">"" =&gt; true</p>
			<p>Here are the steps to help you write this function:</p>
			<ol>
				<li value="1">This function will take a single parameter that is a string and return a Boolean:<p class="source-code">function isBlank (input: string): boolean {</p></li>
				<li>For this function to work, we need to check whether each character in the string is a whitespace character. We can use a regular expression to determine that, or we can use some kind of looping construct that will iterate through the string. One approach would be to test whether the first character is a space, and if it is, slice it off:<p class="source-code">// test if the first character of our input is an empty space     while (input[0] === " ") {// successively slice off the first character of the input         input = input.slice(1);    }</p></li>
				<li>This loop will execute until it reaches a non-whitespace character. If it does not encounter one, it will only stop when there is no first element of the string, that is, when the string is the empty string. If that's the case, our original input only contained whitespace, and we can return true. Otherwise, we should return false:<p class="source-code">// the loop will stop on the first character that is not a //space.// if we're left with an empty string, we only have spaces in // the input     const result = input === "";    return result;</p></li>
				<li>Next, we can test whether the function gives the expected results for the given test inputs:<p class="source-code">console.log(`isBlank("War and Peace"):`);console.log(isBlank("War and Peace")); console.log(`isBlank("       "):`);console.log(isBlank("       "));console.log(`isBlank(""):`);console.log(isBlank(""));</p></li>
				<li>We should receive the following results:<p class="source-code">isBlank("War and Peace"):false isBlank("       "):true isBlank(""):true</p><p><a id="_idTextAnchor388"/><a id="_idTextAnchor389"/>Note that there are multiple ways to implement all the preceding functions. The code shown is just one way to implement them, and these implementations are mostly for illustrative purposes. For example, a proper string utility library will need to have much more robust and extensive test suites.</p></li>
			</ol>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor390"/>2. Declaration Files</h1>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor391"/><a id="_idTextAnchor392"/>Activity 2.01: Building a Heat Map Declaration File</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll be building a TypeScript application named <strong class="source-inline">heat map log system</strong> that will track the baseball pitch data and ensure the integrity of the data. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the following GitHub repository at <a href="https://packt.link/dqDPk">https://packt.link/dqDPk</a> and download the activity project containing the specs and configuration elements.</li>
				<li> Open the Visual Studio Code editor and then open the terminal. </li>
				<li>Change to the <strong class="source-inline">activity-starter</strong> directory in the terminal or command prompt by writing the following command:<p class="source-code">cd activity-starter</p></li>
				<li>Run the following command to install the dependencies:<p class="source-code">npm install</p><p>You will now see the following files in the <strong class="source-inline">activity-starter</strong> directory:</p><div id="_idContainer177" class="IMG---Figure"><img src="image/B14508_02_19.jpg" alt="Figure 2.19: Starter project files&#13;&#10;"/></div><p class="figure-caption">Figure 2.19: Starter project files</p></li>
				<li>Open the <strong class="source-inline">HeatMapTypes.d.ts</strong> declaration file in the <strong class="source-inline">types/</strong> directory, define a module called <strong class="source-inline">HeatMapTypes</strong>, and export the interface named <strong class="source-inline">Pitcher</strong>. Define three attributes for the <strong class="source-inline">Pitcher</strong><strong class="bold"> </strong>module: <strong class="source-inline">batterHotZones</strong>, <strong class="source-inline">pitcherHotZones</strong>, and <strong class="source-inline">coordinateMap</strong>. The data structures should be the same for all three attributes, <strong class="source-inline">Array&lt;Array&lt;number&gt;&gt;</strong>, but <strong class="source-inline">coordinateMap</strong> should be optional. Write the following code to accomplish this:<p class="source-code">declare module "HeatMapTypes" {</p><p class="source-code">  export interface Pitcher {</p><p class="source-code">    batterHotZones: Array&lt;Array&lt;number&gt;&gt;;</p><p class="source-code">    pitcherHotZones: Array&lt;Array&lt;number&gt;&gt;;</p><p class="source-code">    coordinateMap?: Array&lt;any&gt;;</p><p class="source-code">  }</p><p class="source-code">}</p><p>The preceding code in the editor looks like this:</p><div id="_idContainer178" class="IMG---Figure"><img src="image/B14508_02_20.jpg" alt="Figure 2.20: Creating a pitcher interface&#13;&#10;"/></div><p class="figure-caption">Figure 2.20: Creating a pitcher interface</p></li>
				<li>Open <strong class="source-inline">heat_map_data.ts</strong> and import the declaration files. Create and export a <strong class="source-inline">let</strong> variable called <strong class="source-inline">data</strong> and assign it to the <strong class="source-inline">Pitcher</strong> type. You will need to import the <strong class="source-inline">lodash</strong> library, which was installed when you initially ran <strong class="source-inline">npm install</strong>. Write the following code to do this:<p class="source-code">/// &lt;reference path="./types/HeatMapTypes.d.ts"/&gt;</p><p class="source-code">import hmt = require('HeatMapTypes');</p><p class="source-code">import _ = require('lodash');</p><p class="source-code">export let data: hmt.Pitcher;</p></li>
				<li>Add values to the <strong class="source-inline">data</strong> variable that adhere to the declaration rules. Assign nested arrays as values to both the <strong class="source-inline">batterHotZones</strong> and <strong class="source-inline">pitcherHotZones</strong> attributes. Add the following code to do this:<p class="source-code">data = {</p><p class="source-code">  batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],</p><p class="source-code">  pitcherHotZones: [[3, 2], [-12.2, 3], [-10.2, 5]],</p><p class="source-code">};</p></li>
				<li>Create a new function named <strong class="source-inline">findMatch()</strong> that takes in both the <strong class="source-inline">batterHotZones</strong> and <strong class="source-inline">pitcherHotZones</strong> arrays and utilize the <strong class="source-inline">lodash</strong> function, <strong class="source-inline">intersectionWith()</strong>, to return the identical nested array. Finally, store the value of the <strong class="source-inline">findMatch()</strong> function in the <strong class="source-inline">coordinateMap</strong> attribute that was defined in the declaration file. Write the following code to do this:<p class="source-code">export const findMatch = (batterHotZones, pitcherHotZones) =&gt; {</p><p class="source-code">  return _.intersectionWith(batterHotZones, pitcherHotZones, _.isEqual);</p><p class="source-code">};</p><p class="source-code">data.coordinateMap = findMatch(data.batterHotZones, data.pitcherHotZones);</p><p class="source-code">console.log(data.coordinateMap);</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc heat_map_data.ts</p><p class="source-code">node heat_map_data.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><p class="source-code">[[3,2]]</p><p>In the preceding output, the common values from both the attributes are fetched and then printed. In this case, the common values are <strong class="source-inline">[3, 2]</strong>.</p></li>
				<li>Now, change the values of both the attributes. Write the following code:<p class="source-code">data = {</p><p class="source-code">  batterHotZones: [[12.2, -3], [10.2, -5], [3, 2]],</p><p class="source-code">  pitcherHotZones: [[3, 2], [-12.2, 3], [10.2, -5]],</p><p class="source-code">};</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc heat_map_data.ts</p><p class="source-code">node heat_map_data.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><p class="source-code">[[10.2, -5], [3, 2]]</p></li>
			</ol>
			<p>In the preceding output, the common values are <strong class="source-inline">[10.2, -5]</strong> and <strong class="source-inline">[3, 2]</strong>. Finally, we built a heat map log system that will track the baseball pitch data and ensure the integrity of the data.</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor393"/>3. Functions</h1>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor394"/><a id="_idTextAnchor395"/>Activity 3.01: Building a Flight Booking System with Functions</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Start with the stubs provided in code samples. We have three files: <strong class="source-inline">index.ts</strong>, <strong class="source-inline">bookings.ts</strong>, and <strong class="source-inline">flights.ts</strong>. The <strong class="source-inline">index.ts</strong> file is a bit abstract and will just represent some of the transactions we push into our system. <strong class="source-inline">bookings.ts</strong> handles the user-facing activities of managing a booking, and <strong class="source-inline">flights.ts</strong> is the back office of filling up flights and making sure that everybody has a seat.</li>
				<li>The <strong class="source-inline">index.ts</strong> file won't change unless you feel like changing it and adding some new scenarios. Let's run it without adding any code:<p class="source-code">npx ts-node index.ts Not implemented!</p><p>So we have work to do. Several functions are not yet implemented. Let's start by looking at <strong class="source-inline">flights.ts</strong>. There is a partial implementation there as we have an interface called <strong class="source-inline">Flights</strong> that describes the attributes of a flight, a list of available flights implementing that interface, and even a method to fetch the flights, called <strong class="source-inline">getDestinations</strong>. We need to implement logic to check to see whether the number of seats we want to book are still available, logic that can hold seats while we confirm a reservation, and logic that converts those seats held into reserved seats once our payment has been processed.</p></li>
				<li>To check availability, we should see whether the number of seats we're requesting exceeds the number of remaining seats while holding any held seats in reserve. We can express this as <strong class="source-inline">seatsRequested &lt;= seatsRemaining - seatsHeld</strong>, which is a Boolean expression that can be returned by the function. This can be written as an arrow function in the <strong class="source-inline">flights.ts</strong> file:<p class="source-code">export const checkAvailability = (</p><p class="source-code">  flight: Flight,</p><p class="source-code">  seatsRequested: number</p><p class="source-code">): boolean =&gt; seatsRequested &lt;= flight.seatsRemaining - flight.seatsHeld;</p></li>
				<li>The <strong class="source-inline">holdSeats</strong> function should confirm that the requested seats are available and hold them if they are. If there aren't enough seats remaining, we need to throw an error and interrupt the flow:<p class="source-code">export const holdSeats = (flight: Flight, seatsRequested: number): Flight =&gt; {</p><p class="source-code">  if (flight.seatsRemaining - flight.seatsHeld &lt; seatsRequested) {</p><p class="source-code">    throw new Error('Not enough seats remaining!');</p><p class="source-code">  }</p><p class="source-code">  flight.seatsHeld += seatsRequested;</p><p class="source-code">  return flight;</p><p class="source-code">};</p></li>
				<li>To round out <strong class="source-inline">flights.ts</strong>, we have <strong class="source-inline">reserveSeats</strong>. This function operates similarly to <strong class="source-inline">holdSeats</strong>, but it confirms that the seats we wish to reserve have been held, and then converts them into reserved seats by increasing the <strong class="source-inline">seatsHeld</strong> property and reducing the <strong class="source-inline">seatsRemaining</strong> property by the same amount:<p class="source-code">export const reserveSeats = (</p><p class="source-code">  flight: Flight,</p><p class="source-code">  seatsRequested: number</p><p class="source-code">): Flight =&gt; {</p><p class="source-code">  if (flight.seatsHeld &lt; seatsRequested) {</p><p class="source-code">    throw new Error('Seats were not held!');</p><p class="source-code">  }</p><p class="source-code">  flight.seatsHeld -= seatsRequested;</p><p class="source-code">  flight.seatsRemaining -= seatsRequested;</p><p class="source-code">  return flight;</p><p class="source-code">};</p><p>That should do it for <strong class="source-inline">flights.ts</strong>. However, our program still won't run until we implement <strong class="source-inline">bookings.ts</strong>. </p></li>
				<li>First of all, we're going to use a factory pattern for creating bookings. That means we'll have a function that returns a function to create bookings. We'll employ currying to create a closure so that we can initialize the <strong class="source-inline">createBooking</strong> function with <strong class="source-inline">bookingNumber</strong> in order to give each booking a unique identifier. The factory could look like this:<p class="source-code">const bookingsFactory = (bookingNumber: number) =&gt; (</p><p class="source-code">  flight: Flight,</p><p class="source-code">  seatsHeld: number</p><p class="source-code">): Booking =&gt; ({</p><p class="source-code">  bookingNumber: bookingNumber++,</p><p class="source-code">  flight,</p><p class="source-code">  paid: false,</p><p class="source-code">  seatsHeld,</p><p class="source-code">  seatsReserved: 0,</p><p class="source-code">});</p><p>Our factory takes <strong class="source-inline">bookingNumber</strong> as an argument to initialize this value and then increments the number each time it creates a new booking. We assign some default values to the booking to confirm to the <strong class="source-inline">Booking</strong> interface already provided in the module.</p></li>
				<li>To call the factory and get a <strong class="source-inline">createBooking</strong> function with <strong class="source-inline">bookingNumber</strong> already curried into it, we can simply write the following:<p class="source-code">const createBooking = bookingsFactory(1);</p></li>
				<li>We have yet to write functions to start the booking process, handle the payment, and complete the booking, thereby reserving the seats on a flight. To begin the booking, we need to check availability on the flight we've chosen based on the number of seats we're requesting. If that is successful, we can create the booking and hold the seats. Otherwise, we can raise an error to alert the user to the fact that the booking cannot be completed:<p class="source-code">  export const startBooking = (</p><p class="source-code">  flight: Flight,</p><p class="source-code">  seatsRequested: number</p><p class="source-code">): Booking =&gt; {</p><p class="source-code">  if (checkAvailability(flight, seatsRequested)) {</p><p class="source-code">    holdSeats(flight, seatsRequested);</p><p class="source-code">    return createBooking(flight, seatsRequested);</p><p class="source-code">  }</p><p class="source-code">  throw new Error('Booking not available!');</p><p class="source-code">};</p></li>
				<li>In order to check flight availability and hold seats, we need to import these functions from <strong class="source-inline">flights.ts</strong>. This has already been done at the top of the <strong class="source-inline">bookings.ts</strong> module. The <strong class="source-inline">export</strong> keyword is used throughout these modules to make functions available to other modules. Some functions lack the <strong class="source-inline">export</strong> keyword, and so can only be invoked from within the module, effectively making them private.</li>
				<li>We'll cheat a little with our <strong class="source-inline">processPayment</strong> function since we aren't implementing a payment system. We will just mark the booking as paid and return it:<p class="source-code">export const processPayment = (booking: Booking): Booking =&gt; {</p><p class="source-code">  booking.paid = true;</p><p class="source-code">  return booking;</p><p class="source-code">};</p></li>
				<li>To complete the booking, we call <strong class="source-inline">reserveSeats</strong> in the <strong class="source-inline">flights</strong> module and then update our counts:<p class="source-code">export const completeBooking = (booking: Booking): Booking =&gt; {</p><p class="source-code">reserveSeats(booking.flight, booking.seatsHeld);</p><p class="source-code">booking.seatsReserved = booking.seatsHeld;</p><p class="source-code">booking.seatsHeld = 0;</p><p class="source-code">return booking;</p><p class="source-code">};</p></li>
				<li>With all the functions implemented, we can invoke our program again and see the output:<p class="source-code">npx ts-node index.ts</p><p class="source-code">Booked to Lagos {</p><p class="source-code">  bookingNumber: 1,</p><p class="source-code">  flight: {</p><p class="source-code">    destination: 'Lagos',</p><p class="source-code">    flightNumber: 1,</p><p class="source-code">    seatsHeld: 0,</p><p class="source-code">    seatsRemaining: 29,</p><p class="source-code">    time: '5:30'</p><p class="source-code">  },</p><p class="source-code">  paid: true,</p><p class="source-code">  seatsHeld: 0,</p><p class="source-code">  seatsReserved: 1</p><p class="source-code">}</p><p class="source-code">//...</p><p class="source-code">Istanbul flight {</p><p class="source-code">  destination: 'Istanbul',</p><p class="source-code">  flightNumber: 7,</p><p class="source-code">  seatsHeld: 0,</p><p class="source-code">  seatsRemaining: 0,</p><p class="source-code">  time: '14:30'</p><p class="source-code">}</p><p class="source-code">Booking not available!</p></li>
			</ol>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor396"/><a id="_idTextAnchor397"/>Activity 3.02: Writing Unit Tests</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <strong class="source-inline">describe</strong> block, fetch the destinations for this scenario and then cache the first one as <strong class="source-inline">flight</strong>. Now, we can write a simple test to test that the correct number of destinations were returned:<p class="source-code">  test('get destinations', () =&gt; {</p><p class="source-code">    expect(destinations).toHaveLength(7);</p><p class="source-code">  });</p><p>We could test each of the individual destinations and their properties as well.</p></li>
				<li>Check the availability of several of the destinations. We can introduce all sorts of scenarios. Here are a few:<p class="source-code">  test('checking availability', () =&gt; {</p><p class="source-code">    const destinations = getDestinations();</p><p class="source-code">    expect(checkAvailability(destinations[0], 3)).toBeTruthy();</p><p class="source-code">    expect(checkAvailability(destinations[1], 5)).toBeFalsy();</p><p class="source-code">    expect(checkAvailability(destinations[2], 300)).toBeFalsy();</p><p class="source-code">    expect(checkAvailability(destinations[3], 3)).toBeTruthy();</p><p class="source-code">  });</p><p>The first destination has at least three seats available. The second does not have five available, and so on.</p></li>
				<li>Try holding some seats in the next test. We should test both success and failure scenarios:<p class="source-code">  test('hold seats', () =&gt; {</p><p class="source-code">    expect.assertions(3);</p><p class="source-code">    flight = holdSeats(flight, 3);</p><p class="source-code">    expect(flight.seatsHeld).toBe(3);</p><p class="source-code">    flight = holdSeats(flight, 13);</p><p class="source-code">    expect(flight.seatsHeld).toBe(16);</p><p class="source-code">    try {</p><p class="source-code">      holdSeats(flight, 15);</p><p class="source-code">    } catch (e) {</p><p class="source-code">      expect(e.message).toBe('Not enough seats remaining!');</p><p class="source-code">    }</p><p class="source-code">  });</p><p>Note that in order to ensure that the <strong class="source-inline">catch</strong> block was reached, we're expecting three assertions in this test. Without that, the test would still turn green even if, for some reason, the last call to <strong class="source-inline">holdSeats</strong> didn't throw an error.</p></li>
				<li>Finish up the flights test with a unit test to reserve seats:<p class="source-code">  test('reserve seats', () =&gt; {</p><p class="source-code">    expect.assertions(3);</p><p class="source-code">    flight = reserveSeats(flight, 3);</p><p class="source-code">    expect(flight.seatsRemaining).toBe(27);</p><p class="source-code">    flight = reserveSeats(flight, 13);</p><p class="source-code">    expect(flight.seatsRemaining).toBe(14);</p><p class="source-code">    try {</p><p class="source-code">      reserveSeats(flight, 1);</p><p class="source-code">    } catch (e) {</p><p class="source-code">      expect(e.message).toBe('Seats were not held!');</p><p class="source-code">    }</p><p class="source-code">  });</p><p>This test runs through a few scenarios, including another error condition. In some cases, it might be appropriate to put error conditions in separate tests. A good rule of thumb for this is that each of your tests should be easy to comprehend and maintain. If any module or function gets to be too big, just break it up.</p></li>
				<li>Now, write some tests for bookings using the same principles:<p class="source-code">describe('bookings tests', () =&gt; {</p><p class="source-code">  test('create a booking', () =&gt; {</p><p class="source-code">    const booking = startBooking(destinations[0], 3);</p><p class="source-code">    expect(booking).toEqual({</p><p class="source-code">      bookingNumber: 1,</p><p class="source-code">      flight: destinations[0],</p><p class="source-code">      paid: false,</p><p class="source-code">      seatsHeld: 3,</p><p class="source-code">      seatsReserved: 0,</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  test('pay for a booking', () =&gt; {</p><p class="source-code">    let booking = startBooking(destinations[0], 3);</p><p class="source-code">    booking = processPayment(booking);</p><p class="source-code">    expect(booking.paid).toBe(true);</p><p class="source-code">  });</p><p class="source-code">  test('complete a booking', () =&gt; {</p><p class="source-code">    let booking = startBooking(destinations[0], 3);</p><p class="source-code">    booking = processPayment(booking);</p><p class="source-code">    booking = completeBooking(booking);</p><p class="source-code">    expect(booking.paid).toBe(true);</p><p class="source-code">    expect(booking.seatsReserved).toBe(3);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
				<li>Let's now try running the tests and see how things look:<p class="source-code">npm test</p><p class="source-code">&gt; jest --coverage --testRegex="^((?!-solution).)*\\.test\\.tsx?$"</p><p class="source-code"> PASS  ./bookings.test.ts</p><p class="source-code"> PASS  ./flights.test.ts</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">All files    |   97.14 |    83.33 |     100 |   96.97 |</p><p class="source-code"> bookings.ts |   94.74 |       50 |     100 |   94.44 | 34</p><p class="source-code"> flights.ts  |     100 |      100 |     100 |     100 |</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">Test Suites: 2 passed, 2 total</p><p class="source-code">Tests:       7 passed, 7 total</p><p class="source-code">Snapshots:   0 total</p><p class="source-code">Time:        1.782 s</p><p class="source-code">Ran all test suites.</p><p>The tests passed! But we haven't hit 100% line coverage yet. We can actually open up the coverage report, which will be inside the <strong class="source-inline">coverage/lcov-report</strong> directory in the root of our project. The coverage tool (Istanbul) that comes bundled with Jest will produce an HTML report that we can open in any browser. This will show us the exact piece of code that hasn't been covered:</p><div id="_idContainer179" class="IMG---Figure"><img src="image/B14508_03_02.jpg" alt="Figure 3.2: HTML report produced by the tool&#13;&#10;"/></div><p class="figure-caption">Figure 3.2: HTML report produced by the tool</p></li>
				<li>We've missed one error scenario. Let's add that as a new <strong class="source-inline">describe</strong> block to avoid further complicating the tests we've already written:<p class="source-code">describe('error scenarios', () =&gt; {</p><p class="source-code">  test('booking must have availability', () =&gt; {</p><p class="source-code">    expect.assertions(1);</p><p class="source-code">    try {</p><p class="source-code">      startBooking(destinations[6], 8);</p><p class="source-code">    } catch (e) {</p><p class="source-code">      expect(e.message).toBe('Booking not available!');</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">});</p><p>There's no particular need to have a new <strong class="source-inline">describe</strong> block, but in this case, it might make the code a bit cleaner. Use <strong class="source-inline">describe</strong> and test blocks for readability and maintenance.</p></li>
				<li>Let's now run the tests again:<p class="source-code">npm test</p><p class="source-code">&gt; jest --coverage --testRegex="^((?!-solution).)*\\.test\\.tsx?$" PASS  ./bookings-solution.test.ts</p><p class="source-code"> PASS  ./flights-solution.test.ts</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">File         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">All files    |     100 |      100 |     100 |     100 |</p><p class="source-code"> bookings.ts |     100 |      100 |     100 |     100 |</p><p class="source-code"> flights.ts  |     100 |      100 |     100 |     100 |</p><p class="source-code">-------------|---------|----------|---------|---------|-------------------</p><p class="source-code">Test Suites: 2 passed, 2 total</p><p class="source-code">Tests:       8 passed, 8 total</p><p class="source-code">Snapshots:   0 total</p><p class="source-code">Time:        0.694 s, estimated 1 s</p><p class="source-code">Ran all test suites.</p><p>We've hit our goal of 100% line coverage!</p></li>
			</ol>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor398"/>4. Classes and Objects</h1>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor399"/><a id="_idTextAnchor400"/>Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll be building a user authentication system that will pass login data to a backend API to register and sign users into our baseball scorecard application. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the following GitHub repository and download the activity project containing the specs and configuration elements: <a href="https://packt.link/oaWbW">https://packt.link/oaWbW</a>. <p>The  <strong class="source-inline">activity-solution</strong> directory contains the completed solution code, and the <strong class="source-inline">activity-starter</strong> directory provides the basic start code to work with.</p></li>
				<li>Open the Visual Studio Code editor and then open the terminal. Change into the <strong class="source-inline">activity-starter</strong> directory in the terminal or command prompt and run the following command to install the dependencies:<p class="source-code">npm install</p><p>You will now see the following files in the <strong class="source-inline">activity-starter</strong> directory:</p><div id="_idContainer180" class="IMG---Figure"><img src="image/B14508_04_10.jpg" alt="Figure 4.10: Activity project files&#13;&#10;"/></div><p class="figure-caption">Figure 4.10: Activity project files</p></li>
				<li>Open the <strong class="source-inline">auth.ts</strong> file inside the <strong class="source-inline">activity-starter</strong> folder and create an interface named <strong class="source-inline">ILogin</strong> containing two string attributes, namely, <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong>. Write the following code to accomplish this:<p class="source-code">interface ILogin{</p><p class="source-code">    email: string;</p><p class="source-code">    password:string;</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Login</strong> class that takes in an object that contains the string attributes of <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong>. Also, pass the <strong class="source-inline">ILogin</strong> interface as a parameter to the <strong class="source-inline">constructor</strong> function inside the <strong class="source-inline">Login</strong> class:<p class="source-code">export class Login{</p><p class="source-code">    email: string;</p><p class="source-code">    password: string;</p><p class="source-code">    constructor(args: ILogin){</p><p class="source-code">        this.email = args.email;</p><p class="source-code">        this.password = args.password;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create an interface named <strong class="source-inline">IAuth</strong> containing two attributes, <strong class="source-inline">user</strong> and <strong class="source-inline">source</strong>. Here, the <strong class="source-inline">user</strong> attribute will be of the <strong class="source-inline">Login</strong> type, and the <strong class="source-inline">source</strong> attribute will be of the <strong class="source-inline">string</strong> type. Write the following code to implement this:<p class="source-code">interface IAuth{</p><p class="source-code">    user: Login;</p><p class="source-code">    source: string;</p><p class="source-code">} </p></li>
				<li>Create an <strong class="source-inline">Auth</strong> class that takes in an object containing the attributes of <strong class="source-inline">user</strong> and <strong class="source-inline">source</strong>. Also, create a <strong class="source-inline">constructor</strong> function that will take the <strong class="source-inline">IAuth</strong> interface as a parameter. Write the following code to accomplish this:<p class="source-code">export default class Auth{</p><p class="source-code">    user: Login;</p><p class="source-code">    source: string;</p><p class="source-code">    constructor(args: IAuth){</p><p class="source-code">        this.user = args.user;</p><p class="source-code">        this.source = args.source;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, we'll add a <strong class="source-inline">validUser()</strong> method to the <strong class="source-inline">Auth</strong> class, which returns a string stating that the user is authenticated if <strong class="source-inline">email</strong> is equal to <strong class="source-inline">admin@example.com</strong>, and if <strong class="source-inline">password</strong> is equal to <strong class="source-inline">secret123</strong>. If either of those values doesn't match, the function will return a string stating that the user is not authenticated. Write the following code to define this function:<p class="source-code">validUser(): string{</p><p class="source-code">    const { email, password } = this.user;</p><p class="source-code">    if(email === "admin@example.com"       &amp;&amp; password === "secret123"){</p><p class="source-code">        return `Validating user…User is authenticated: true`;</p><p class="source-code">    } else {</p><p class="source-code">        return `Validating user…User is authenticated: false`;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create two objects of the <strong class="source-inline">Login</strong> class, namely, <strong class="source-inline">goodUser</strong> and <strong class="source-inline">badUser</strong>. For the <strong class="source-inline">goodUser</strong> object, set the <strong class="source-inline">email</strong> value to <strong class="source-inline">admin@example.com</strong> and <strong class="source-inline">password</strong> to <strong class="source-inline">secret123</strong>. For the <strong class="source-inline">badUser</strong> object, set the <strong class="source-inline">email</strong> value to <strong class="source-inline">admin@example.com</strong> and <strong class="source-inline">password</strong> to <strong class="source-inline">whoops</strong>. Write the following code to accomplish this:<p class="source-code">const goodUser = new Login({</p><p class="source-code">    email: "admin@example.com",</p><p class="source-code">    password: "secret123"</p><p class="source-code">});</p><p class="source-code">const badUser = new Login({</p><p class="source-code">    email: "admin@example.com",</p><p class="source-code">    password: "whoops"</p><p class="source-code">});</p></li>
				<li>Create two objects of the <strong class="source-inline">Auth</strong> class, namely, <strong class="source-inline">authAttemptFromGoodUser</strong> and <strong class="source-inline">authAttemptFromBadUser</strong>. For the first object, assign the <strong class="source-inline">goodUser</strong> object of the <strong class="source-inline">Login</strong> class to the <strong class="source-inline">user</strong> attribute and <strong class="source-inline">Google</strong> to the <strong class="source-inline">source</strong> attribute. For the second object, assign the <strong class="source-inline">badUser</strong> object of the <strong class="source-inline">Login</strong> class to the <strong class="source-inline">user</strong> attribute and <strong class="source-inline">Google</strong> to the <strong class="source-inline">source</strong> attribute. Once both objects are created, call the <strong class="source-inline">validUser()</strong> function of the <strong class="source-inline">Auth</strong> class and print the results in the terminal. Write the following code to accomplish this:<p class="source-code">const authAttemptFromGoodUser = new Auth({</p><p class="source-code">    user: goodUser,</p><p class="source-code">    source: "Google"</p><p class="source-code">});</p><p class="source-code">console.log(authAttemptFromGoodUser.validUser());</p><p class="source-code">const authAttemptFromBadUser = new Auth({</p><p class="source-code">    user: badUser,</p><p class="source-code">    source: "Google"</p><p class="source-code">});</p><p class="source-code">console.log(authAttemptFromBadUser.validUser());</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc auth.ts</p><p class="source-code">node auth.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><p class="source-code">Validating user…User is authenticated: true</p><p class="source-code">Validating user…User is authenticated: false</p></li>
			</ol>
			<p>In the preceding output, the <strong class="source-inline">validUser()</strong> function returns a <strong class="source-inline">true</strong> value when the correct details of <strong class="source-inline">user</strong> and <strong class="source-inline">password</strong> are passed. When incorrect details are passed, the function returns a <strong class="source-inline">false</strong> value.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor401"/>5. Interfaces and Inheritance</h1>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor402"/><a id="_idTextAnchor403"/>Activity 5.01: Building a User Management Component Using Interfaces</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a user object interface with the following properties: <strong class="source-inline">email : string</strong>, <strong class="source-inline">loginAt : number</strong>, and <strong class="source-inline">token : string</strong>. Make <strong class="source-inline">loginAt</strong> and <strong class="source-inline">token</strong> optional:<p class="source-code">interface UserObj {</p><p class="source-code">    email: string</p><p class="source-code">    loginAt?: number</p><p class="source-code">    token?: string</p><p class="source-code">}</p></li>
				<li>Build a class interface with a global property user and use the interface created in <em class="italic">Step 1</em> to apply user object rules. You need to define a <strong class="source-inline">getUser</strong> method that returns the user object. Use the interface to ensure that the return object is a user object. Finally, define a <strong class="source-inline">login</strong> method that takes a <strong class="source-inline">user</strong> object and <strong class="source-inline">password(type string)</strong> as arguments. Use the user object interface as the <strong class="source-inline">user</strong> argument type:<p class="source-code">interface UserClass {</p><p class="source-code">    user: UserObj</p><p class="source-code">    getUser(): UserObj</p><p class="source-code">    login(user: UserObj, password: string):UserObj</p><p class="source-code">}</p></li>
				<li>Declare a class called <strong class="source-inline">UserClass</strong> that implements the class interface from <em class="italic">Step 2</em>. Your login method should assign the local function's <strong class="source-inline">user</strong> argument to the global user property and return the global user. The <strong class="source-inline">getUser</strong> method should return the global user:<p class="source-code">class User implements UserClass {</p><p class="source-code">    </p><p class="source-code">    user:UserObj</p><p class="source-code">    getUser(): UserObj {</p><p class="source-code">        return this.user</p><p class="source-code">    }</p><p class="source-code">    login(user:  UserObj, password: string): UserObj {</p><p class="source-code">        // set props user object</p><p class="source-code">        return this.user = user</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create an instance of your class, as declared in <em class="italic">Step 2</em>:<p class="source-code">const newUserClass:UserClass = new User()</p></li>
				<li>Create a user object instance:<p class="source-code">const newUser: UserObj = {</p><p class="source-code">    email: "home@home.com",</p><p class="source-code">    loginAt: new Date().getTime(),</p><p class="source-code">    token: "123456"</p><p class="source-code">}</p></li>
				<li>Console out our methods to ensure that they are working as expected:<p class="source-code">console.log(</p><p class="source-code">    newUserClass.login(newUser, "password123")</p><p class="source-code">)</p><p class="source-code">console.log(</p><p class="source-code">    newUserClass.getUser()</p><p class="source-code">)</p><p>The expected output is as follows:</p><p class="source-code">{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }</p><p class="source-code">{ email: 'home@home.com', loginAt: 1614068072515, token: '123456' }</p><p>Thi<a id="_idTextAnchor404"/>s user management class is a central location where you can isolate all your application's user-related functions and rules. The rules you have crafted by using interfaces to implement your code will ensure that your code is better supported, easier to work with, and bug-free. </p></li>
			</ol>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor405"/><a id="_idTextAnchor406"/>Activity 5.02: Creating a Prototype Web Application for a Vehicle Showroom Using Inheritance</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a parent class that will hold all common methods and properties for a base vehicle, define a constructor method that allows you to initialize the base properties of this class, and add a method that returns your properties as an object. If necessary, add an access modifier to properties and class methods you want to control access to:  <p class="source-code">class Motor {</p><p class="source-code">    private name: string</p><p class="source-code">    wheels: number</p><p class="source-code">    bodyType: string</p><p class="source-code">    constructor(name: string, wheels: number, bodyType: string) {</p><p class="source-code">        this.name = name</p><p class="source-code">        this.wheels = wheels</p><p class="source-code">        this.bodyType = bodyType</p><p class="source-code">    }</p><p class="source-code">    protected getName(): string {</p><p class="source-code">        return this.name</p><p class="source-code">    }</p><p class="source-code">    buildMotor() {</p><p class="source-code">        return {</p><p class="source-code">            wheels: this.wheels,</p><p class="source-code">            bodyType: this.bodyType,</p><p class="source-code">            name: this.name</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Derive two child classes from your parent class that are types of vehicles, for example, <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong>. Override your constructor to add some unique properties to your child classes based on the type of vehicles:<p class="source-code">class Car extends Motor {</p><p class="source-code">    rideHeight: number</p><p class="source-code">    constructor(name: string, wheels: number, bodyType: string, rideHeight: number) {</p><p class="source-code">        super(name, wheels, bodyType)</p><p class="source-code">        this.rideHeight = rideHeight</p><p class="source-code">    }</p><p class="source-code">    _buildMotor() {</p><p class="source-code">        return {</p><p class="source-code">            ...super.buildMotor,</p><p class="source-code">            rideHeight: this.rideHeight</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">class Truck extends Motor {</p><p class="source-code">    offRoad: boolean</p><p class="source-code">    constructor(name: string, wheels: number, bodyType: string, offRoad: boolean) {</p><p class="source-code">        super(name, wheels, bodyType)</p><p class="source-code">        this.offRoad = offRoad</p><p class="source-code">    }</p><p class="source-code">    _buildMotor() {</p><p class="source-code">        return {</p><p class="source-code">            wheels: this.wheels,</p><p class="source-code">            bodyType: this.bodyType,</p><p class="source-code">            offRoad: this.offRoad</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Derive a class from one of the child classes created in <em class="italic">Step 3</em>, for example, <strong class="source-inline">Suv</strong>, which will have some of the things a truck might have, so it would be logical to extend <strong class="source-inline">Truck</strong>:<p class="source-code">class Suv extends Truck {</p><p class="source-code">    roofRack: boolean</p><p class="source-code">    thirdRow: boolean</p><p class="source-code">    constructor(name: string, wheels: number, bodyType: string, </p><p class="source-code">        offRoad: boolean, roofRack: boolean, thirdRow: boolean) {</p><p class="source-code">        super(name, wheels, bodyType, offRoad)</p><p class="source-code">        this.roofRack = roofRack;</p><p class="source-code">        this.thirdRow = thirdRow</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Instantiate your child class:<p class="source-code">const car: Car = new Car('blueBird', 4, 'sedan', 14)</p><p class="source-code">const truck: Truck = new Truck('blueBird', 4, 'sedan', true)</p><p class="source-code">const suv: Suv = new Suv('xtrail', 4, 'box', true, true, true)</p></li>
				<li>Console out our child class instance:<p class="source-code">console.log(car)</p><p class="source-code">console.log(truck)</p><p class="source-code">console.log(suv)</p><p>You will obtain the following output:</p><p class="source-code">Car { name: 'blueBird', wheels: 4, bodyType: 'sedan', rideHeight: 14 }</p><p class="source-code">Truck { name: 'blueBird', wheels: 4, bodyType: 'sedan', offRoad: true }</p><p class="source-code">Suv {</p><p class="source-code">  name: 'xtrail',</p><p class="source-code">  wheels: 4,</p><p class="source-code">  bodyType: 'box',</p><p class="source-code">  offRoad: true,</p><p class="source-code">  roofRack: true,</p><p class="source-code">  thirdRow: true</p><p class="source-code">}</p><p>In t<a id="_idTextAnchor407"/>his activity, you created the bare minimum classes that we require for the web application. We have shown how we can build complexity, reuse, and extend application code with inheritance in TypeScript.</p></li>
			</ol>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor408"/>6. Advanced Types</h1>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor409"/><a id="_idTextAnchor410"/>Activity 6.01: Intersection Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Motor</strong> type, which will house some common properties you may reuse on their own or in combination with other types to describe a vehicle object. You can use the following properties as a starting point: <strong class="source-inline">color</strong>, <strong class="source-inline">doors</strong>, <strong class="source-inline">wheels</strong>, and <strong class="source-inline">fourWheelDrive</strong>:<p class="source-code">type Motor = {</p><p class="source-code">    color: string;</p><p class="source-code">    doors: number;</p><p class="source-code">    wheels: number;</p><p class="source-code">    fourWheelDrive: boolean;</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Truck</strong> type with properties common to a truck, for example, <strong class="source-inline">doubleCab</strong> and <strong class="source-inline">winch</strong>:<p class="source-code">type Truck = {</p><p class="source-code">    doubleCab: boolean;</p><p class="source-code">    winch: boolean;</p><p class="source-code">} </p></li>
				<li>Intersect the two types to create a <strong class="source-inline">PickUpTruck</strong> type:<p class="source-code">type PickUpTruck = Motor &amp; Truck;</p></li>
				<li>Build a <strong class="source-inline">TruckBuilder</strong> function that returns our <strong class="source-inline">PickUpTruck</strong> type and also takes <strong class="source-inline">PickUpTruck</strong> as an argument: <p class="source-code">function TruckBuilder (truck: PickUpTruck): PickUpTruck {</p><p class="source-code">    return truck</p><p class="source-code">}</p><p class="source-code">const pickUpTruck: PickUpTruck = {</p><p class="source-code">    color: 'red',</p><p class="source-code">    doors: 4,</p><p class="source-code">    doubleCab: true,</p><p class="source-code">    wheels: 4,</p><p class="source-code">    fourWheelDrive: true,</p><p class="source-code">    winch: true</p><p class="source-code">}</p></li>
				<li>Console out the function return:<p class="source-code">console.log (</p><p class="source-code">    TruckBuilder(pickUpTruck)</p><p class="source-code">)</p><p>You should see the following output once you run the file:</p><p class="source-code">{</p><p class="source-code">  color: 'red',</p><p class="source-code">  doors: 4,</p><p class="source-code">  doubleCab: true,</p><p class="source-code">  wheels: 4,</p><p class="source-code">  fourWheelDrive: true,</p><p class="source-code">  winch: true</p><p class="source-code">}</p></li>
			</ol>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor411"/><a id="_idTextAnchor412"/>Activity 6.02: Union Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Build a <strong class="source-inline">LandPack</strong> and an <strong class="source-inline">AirPack</strong> type. Make sure to have a literal to identify the package type:<p class="source-code">type LandPack = {</p><p class="source-code">    height: number,</p><p class="source-code">    weight: number,</p><p class="source-code">    type: "land",</p><p class="source-code">    label?: string };</p><p class="source-code">type AirPack = {</p><p class="source-code">    height: number,</p><p class="source-code">    weight: number,</p><p class="source-code">    type : "air",</p><p class="source-code">    label?: string };</p></li>
				<li>Construct a union type, <strong class="source-inline">ComboPack</strong>, which can be <strong class="source-inline">LandPack</strong> or <strong class="source-inline">AirPack</strong>: <p class="source-code">type ComboPack = LandPack | AirPack</p></li>
				<li>Make a <strong class="source-inline">Shipping</strong> class to process your packages. Make sure to use your literal to identify your package types and modify your package with the correct label for its type:<p class="source-code">class Shipping {</p><p class="source-code">    Process(pack: ComboPack) {</p><p class="source-code">        // check package type</p><p class="source-code">        if(pack.type === "land") {</p><p class="source-code">            return this.ToLand(pack);</p><p class="source-code">        } else {</p><p class="source-code">            return this.ToAir(pack);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    ToAir(pack: AirPack): AirPack {</p><p class="source-code">        pack.label = "air cargo"</p><p class="source-code">        return pack;</p><p class="source-code">    }</p><p class="source-code">    ToLand(pack: LandPack): LandPack {</p><p class="source-code">        pack.label = "land cargo"</p><p class="source-code">        return pack;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create two package objects of the <strong class="source-inline">AirPack</strong> and <strong class="source-inline">LandPack</strong> types. Then, instantiate your <strong class="source-inline">Shipping</strong> class, process your new objects, and console out the modified objects:<p class="source-code">const airPack: AirPack = {</p><p class="source-code">    height: 5,</p><p class="source-code">    weight: 10,</p><p class="source-code">    type: "air",</p><p class="source-code">};</p><p class="source-code">const landPack: LandPack = {</p><p class="source-code">    height: 5,</p><p class="source-code">    weight: 10,</p><p class="source-code">    type: "land",</p><p class="source-code">};</p><p class="source-code">const shipping = new Shipping;</p><p class="source-code">console.log(</p><p class="source-code">    shipping.Process(airPack)</p><p class="source-code">);</p><p class="source-code">console.log(</p><p class="source-code">    shipping.Process(landPack)</p><p class="source-code">);</p><p>Once you run the file, you will obtain the following output:</p><p class="source-code">{ height: 5, weight: 10, type: 'air', label: 'air cargo' }</p><p class="source-code">{ height: 5, weight: 10, type: 'land', label: 'land cargo' } </p></li>
			</ol>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor413"/><a id="_idTextAnchor414"/>Activity 6.03: Index Type </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Build your <strong class="source-inline">PackageStatus</strong> index type using an interface with a <strong class="source-inline">status</strong> property of the <strong class="source-inline">string</strong> type and a value of the <strong class="source-inline">Boolean</strong> type:<p class="source-code">interface PackageStatus { </p><p class="source-code">    [status: string]: boolean;}</p></li>
				<li>Create a <strong class="source-inline">Package</strong> type that includes a property of the <strong class="source-inline">PackageStatus</strong> type and some common properties of a typical package:<p class="source-code">type Package = {</p><p class="source-code">    packageStatus: PackageStatus,</p><p class="source-code">    barcode:  number,</p><p class="source-code">    weight: number</p><p class="source-code">}</p></li>
				<li>Make a class to process your <strong class="source-inline">Package</strong> type, which takes the <strong class="source-inline">Package</strong> type on initialization, has a method to return your <strong class="source-inline">packageStatus</strong> property, and a method that updates and returns the <strong class="source-inline">packageStatus</strong> property:<p class="source-code">class PackageProcess {</p><p class="source-code">    </p><p class="source-code">    pack: Package</p><p class="source-code">    constructor(pack: Package) {</p><p class="source-code">        this.pack = pack;</p><p class="source-code">    }</p><p class="source-code">    </p><p class="source-code">    Status () {</p><p class="source-code">        return this.pack.packageStatus;</p><p class="source-code">    }</p><p class="source-code">    UpdateStatus(status: string, state: boolean) {</p><p class="source-code">        this.pack.packageStatus[status] = state;</p><p class="source-code">        return this.Status();}</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Package</strong> object called <strong class="source-inline">pack</strong>:<p class="source-code">const pack: Package = {</p><p class="source-code">    packageStatus: {"shipped": false, "packed": true, "delivered": true},</p><p class="source-code">    barcode: 123456,</p><p class="source-code">    weight: 28 </p><p class="source-code">};</p></li>
				<li>Instantiate your <strong class="source-inline">PackageProcess</strong> class with your new <strong class="source-inline">pack</strong> object:<p class="source-code">const processPack = new PackageProcess(pack)</p></li>
				<li>Console out your <strong class="source-inline">pack</strong> status:<p class="source-code">console.log(processPack.Status());</p></li>
				<li>Update your <strong class="source-inline">pack</strong> status and console out your new <strong class="source-inline">pack</strong> status: <p class="source-code">console.log(</p><p class="source-code">    processPack.UpdateStatus("shipped", true)</p><p class="source-code">);</p><p>Once you run the file, you should obtain the following output:</p><p class="source-code">{ shipped: false, packed: true, delivered: true }</p><p class="source-code">{ shipped: true, packed: true, delivered: true }</p><p>The first line in the preceding output displays the original <strong class="source-inline">pack</strong> status, whereas the second line displays the updated <strong class="source-inline">pack</strong> status.</p></li>
			</ol>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor415"/>7. Decorator</h1>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/>Activity 7.01: Creating Decorators for Call Counting</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a class called <strong class="source-inline">Person</strong> with the public properties <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, and <strong class="source-inline">birthday</strong>.</li>
				<li>Add a constructor that initializes the properties via the constructor parameters:<p class="source-code">class Person {</p><p class="source-code">         constructor (public firstName: string, </p><p class="source-code">                     public lastName: string, </p><p class="source-code">                     public birthDate: Date) {</p><p class="source-code">         }</p><p class="source-code">}</p></li>
				<li>Add a private field called <strong class="source-inline">_title</strong> and expose it via a <strong class="source-inline">getter</strong> and <strong class="source-inline">setter</strong> as a property called <strong class="source-inline">title</strong>:<p class="source-code">    private _title: string;</p><p class="source-code">    public get title() {</p><p class="source-code">        return this._title;</p><p class="source-code">    }</p><p class="source-code">    public set title(value: string) {</p><p class="source-code">        this._title = value;</p><p class="source-code">    }</p></li>
				<li>Add a method called <strong class="source-inline">getFullName</strong> that will return the full name of person:<p class="source-code">    public getFullName() {</p><p class="source-code">        return `${this.firstName} ${this.lastName}`;</p><p class="source-code">    }</p></li>
				<li>Add a method called <strong class="source-inline">getAge</strong> that will return the current age of the person (by subtracting the birthday from the current year):<p class="source-code">    public getAge() {</p><p class="source-code">        // only sometimes accurate</p><p class="source-code">        const now = new Date();</p><p class="source-code">        return now.getFullYear() – this.birthDate.getFullYear();</p><p class="source-code">    }</p></li>
				<li>Create a global object called <strong class="source-inline">count</strong> and initialize it to the empty object:<p class="source-code">const count = {};</p></li>
				<li>Create a constructor wrapping decorator factory called <strong class="source-inline">CountClass</strong> that will take a string parameter called <strong class="source-inline">counterName</strong>:<p class="source-code">type Constructable = { new (...args: any[]): {} };</p><p class="source-code">function CountClass(counterName: string) {</p><p class="source-code">    return function &lt;T extends Constructable&gt;(constructor: T) {</p><p class="source-code">        // wrapping code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Inside the wrapping code, increase the <strong class="source-inline">count</strong> object's property defined in the <strong class="source-inline">counterName</strong> parameter by 1 and then set the prototype chain of the wrapped constructor:<p class="source-code">    const wrappedConstructor: any = function (...args: any[]) {</p><p class="source-code">        const result = new constructor(...args);</p><p class="source-code">        if (count[counterName]) {</p><p class="source-code">            count[counterName]+=1;</p><p class="source-code">        } else {</p><p class="source-code">            count[counterName]=1;</p><p class="source-code">        }</p><p class="source-code">        return result;</p><p class="source-code">    };</p><p class="source-code">    wrappedConstructor.prototype = constructor.prototype;</p><p class="source-code">    return wrappedConstructor;</p></li>
				<li>Create a method wrapping decorator factory called <strong class="source-inline">CountMethod</strong> that will take a string parameter called <strong class="source-inline">counterName</strong>:<p class="source-code">function CountMethod(counterName: string) {</p><p class="source-code">    return function (target: any, propertyName: string, </p><p class="source-code">                     descriptor: PropertyDescriptor) {</p><p class="source-code">        // method wrapping code here</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add checks for whether the descriptor parameter has <strong class="source-inline">value</strong>, <strong class="source-inline">get</strong>, and <strong class="source-inline">set</strong> properties:<p class="source-code">    if (descriptor.value) {</p><p class="source-code">        // method decoration code</p><p class="source-code">    }</p><p class="source-code">    if (descriptor.get) {</p><p class="source-code">        // get property accessor decoration code</p><p class="source-code">    }</p><p class="source-code">    if (descriptor.set) {</p><p class="source-code">        // set property accessor decoration code</p><p class="source-code">    }</p></li>
				<li>In each respective branch, add code that wraps the method:<p class="source-code">    // method decoration code</p><p class="source-code">    const original = descriptor.value;</p><p class="source-code">    descriptor.value = function (...args: any[]) {</p><p class="source-code">        // counter management code here</p><p class="source-code">        return original.apply(this, args);</p><p class="source-code">    }</p><p class="source-code">    // get property accessor decoration code</p><p class="source-code">    const original = descriptor.get;</p><p class="source-code">    descriptor.get = function () {</p><p class="source-code">        // counter management code here</p><p class="source-code">        return original.apply(this, []);</p><p class="source-code">    }</p><p class="source-code">    // set property accessor decoration code</p><p class="source-code">    const original = descriptor.set;</p><p class="source-code">    descriptor.set = function (value: any) {</p><p class="source-code">        // counter management code here</p><p class="source-code">        return original.apply(this, [value]);</p><p class="source-code">    }</p></li>
				<li>Inside the wrapping code, increase the <strong class="source-inline">count</strong> object's property defined in the <strong class="source-inline">counterName</strong> parameter by 1:<p class="source-code">        // counter management code</p><p class="source-code">        if (count[counterName]) {</p><p class="source-code">            count[counterName]+=1;</p><p class="source-code">        } else {</p><p class="source-code">            count[counterName]=1;</p><p class="source-code">        }          </p></li>
				<li>Decorate the class using the <strong class="source-inline">CountClass</strong> decorator, with a <strong class="source-inline">person</strong> parameter:<p class="source-code">@CountClass('person')</p><p class="source-code">class Person{</p></li>
				<li>Decorate <strong class="source-inline">getFullName</strong>, <strong class="source-inline">getAge</strong>, and the <strong class="source-inline">title</strong> property getter with the <strong class="source-inline">CountMethod</strong> decorator, with the <strong class="source-inline">person-full-name</strong>, <strong class="source-inline">person-age</strong>, and <strong class="source-inline">person-title</strong> parameters, respectively:<p class="source-code">    @CountMethod('person-full-name')</p><p class="source-code">    public getFullName() {</p><p class="source-code">    @CountMethod('person-age')</p><p class="source-code">    public getAge() {</p><p class="source-code">    @CountMethod('person-title')</p><p class="source-code">    public get title() {</p></li>
				<li>Write code outside the class that will instantiate three <strong class="source-inline">person</strong> objects:<p class="source-code">const first = new Person("Brendan", "Eich", new Date(1961,6,4));</p><p class="source-code">const second = new Person("Anders", "Hejlsberg ", new Date(1960,11,2));</p><p class="source-code">const third = new Person("Alan", "Turing", new Date(1912,5,23));</p></li>
				<li>Write code that will call the <strong class="source-inline">getFullName</strong> and <strong class="source-inline">getAge</strong> methods on the objects:<p class="source-code">const fname = first.getFullName();</p><p class="source-code">const sname = second.getFullName();</p><p class="source-code">const tname = third.getFullName();</p><p class="source-code">const fage = first.getAge();</p><p class="source-code">const sage = second.getAge();</p><p class="source-code">const tage = third.getAge();</p></li>
				<li>Write code that will check whether the <strong class="source-inline">title</strong> property is empty and set it to something if it is:<p class="source-code">if (!first.title) {</p><p class="source-code">    first.title = "Mr."</p><p class="source-code">}</p><p class="source-code">if (!second.title) {</p><p class="source-code">    second.title = "Mr."</p><p class="source-code">}</p><p class="source-code">if (!third.title) {</p><p class="source-code">    third.title = "Mr."</p><p class="source-code">}</p></li>
				<li>Write code that will log the <strong class="source-inline">count</strong> object to the console:<p class="source-code">console.log(count);</p><p>Once you run the file, you will obtain the following output on the console:</p><p class="source-code">{</p><p class="source-code">  person: 3,</p><p class="source-code">  'person-full-name': 3,</p><p class="source-code">  'person-age': 3,</p><p class="source-code">  'person-title': 6</p><p class="source-code">}</p></li>
			</ol>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor418"/><a id="_idTextAnchor419"/>Activity 7.02: Using Decorators to Apply Cross-Cutting Concerns</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create the code for the <strong class="source-inline">BasketBallGame</strong> class:<p class="source-code">    interface Team {</p><p class="source-code">        score: number;</p><p class="source-code">        name: string;</p><p class="source-code">    }</p><p class="source-code">    class BasketBallGame {</p><p class="source-code">        private team1: Team;</p><p class="source-code">        private team2: Team;</p><p class="source-code">        constructor(teamName1: string, teamName2: string) {</p><p class="source-code">            this.team1 = { score: 0, name: teamName1 };</p><p class="source-code">            this.team2 = { score: 0, name: teamName2 };</p><p class="source-code">        }</p><p class="source-code">        getScore() {</p><p class="source-code">            return `${this.team1.score}:${this.team2.score}`;</p><p class="source-code">        }</p><p class="source-code">        updateScore(byPoints: number, updateTeam1: boolean) {</p><p class="source-code">            if (updateTeam1) {</p><p class="source-code">                this.team1.score += byPoints;</p><p class="source-code">            } else {</p><p class="source-code">                this.team2.score += byPoints;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Create a class decorator factory called <strong class="source-inline">Authenticate</strong> that will take a <strong class="source-inline">permission</strong> parameter and return a class decorator with constructor wrapping. The class decorator should load the <strong class="source-inline">permissions</strong> metadata property (array of <strong class="source-inline">strings</strong>), then check if the passed parameter is an element of the array. If the passed parameter is not an element of the array, the class decorator should throw an error, and if present, it should continue with the class creation:<p class="source-code">    type Constructable = { new (...args: any[]): {} };</p><p class="source-code">    function Authenticate(permission: string) {</p><p class="source-code">        return function &lt;T extends Constructable&gt;(constructor: T) {</p><p class="source-code">            const wrappedConstructor: any = function (...args: any[]) {</p><p class="source-code">                if (Reflect.hasMetadata("permissions", wrappedConstructor)) {</p><p class="source-code">                    const permissions = Reflect.getMetadata("permissions", </p><p class="source-code">                                                     wrappedConstructor) as string[];</p><p class="source-code">                    if (!permissions.includes(permission)) {</p><p class="source-code">                        throw Error(`Permission ${permission} not present`);</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">                const result = new constructor(...args);</p><p class="source-code">                return result;</p><p class="source-code">            };</p><p class="source-code">            wrappedConstructor.prototype = constructor.prototype;</p><p class="source-code">            return wrappedConstructor;</p><p class="source-code">        };</p><p class="source-code">    }</p></li>
				<li>Define a metadata property of the <strong class="source-inline">BasketballGame</strong> class called <strong class="source-inline">permissions</strong> with the value ["<strong class="source-inline">canUpdateScore</strong>"]:<p class="source-code">    Reflect.defineMetadata("permissions", ["canUpdateScore"], BasketBallGame);</p></li>
				<li>Apply the class decorator factory on the <strong class="source-inline">BasketballGame</strong> class with a parameter value of "<strong class="source-inline">canUpdateScore"</strong>:<p class="source-code">    @Authenticate("canUpdateScore")</p><p class="source-code">    class BasketBallGame {</p></li>
				<li>Create a method decorator called <strong class="source-inline">MeasureDuration</strong> that will use method wrapping to start a timer before the method body is executed and stop it after it's done. You need to calculate the duration and push it to a metadata property called <strong class="source-inline">durations</strong> for the method:<p class="source-code">    function MeasureDuration() {</p><p class="source-code">        return function (target: any, propertyName: string, </p><p class="source-code">                                     descriptor: PropertyDescriptor) {</p><p class="source-code">            if (descriptor.value) {</p><p class="source-code">                const original = descriptor.value;</p><p class="source-code">                descriptor.value = function (...args: any[]) {</p><p class="source-code">                    const start = Date.now();</p><p class="source-code">                    const result = original.apply(this, args);</p><p class="source-code">                    const end = Date.now();</p><p class="source-code">                    const duration = end-start;</p><p class="source-code">                    if (Reflect.hasMetadata("durations", target, propertyName)) {</p><p class="source-code">                      const existing = Reflect.getMetadata("durations", </p><p class="source-code">                                                   target, propertyName) as number[];</p><p class="source-code">                      Reflect.defineMetadata("durations", existing.concat(duration),</p><p class="source-code">                                                   target, propertyName);</p><p class="source-code">                    } else {</p><p class="source-code">                      Reflect.defineMetadata("durations", [duration], </p><p class="source-code">                                                   target, propertyName)</p><p class="source-code">                    }</p><p class="source-code">                    return result;</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Apply the <strong class="source-inline">MeasureDuration</strong> method decorator on the <strong class="source-inline">updateScore</strong> method:<p class="source-code">    @MeasureDuration()</p><p class="source-code">    updateScore(byPoints: number, updateTeam1: boolean) {</p></li>
				<li>Create a method decorator factory called <strong class="source-inline">Audit</strong> that will take a message parameter and return a method decorator. The method decorator should use method wrapping to get the arguments and the return value of the method. After the successful execution of the original method, it should display the audit log to the console:<p class="source-code">    function Audit(message: string) {</p><p class="source-code">        return function (target: any, propertyName: string, </p><p class="source-code">                                      descriptor: PropertyDescriptor) {</p><p class="source-code">          if (descriptor.value) {</p><p class="source-code">            const original = descriptor.value;</p><p class="source-code">            descriptor.value = function (...args: any[]) {</p><p class="source-code">              const result = original.apply(this, args);</p><p class="source-code">              console.log(`[AUDIT] ${message} (${propertyName}) called with:`)</p><p class="source-code">              console.log("[AUDIT]", args);</p><p class="source-code">              console.log("[AUDIT] and returned result:")</p><p class="source-code">              console.log("[AUDIT]", result);</p><p class="source-code">              return result;</p><p class="source-code">            }</p><p class="source-code">          }</p><p class="source-code">       }</p><p class="source-code">    }</p></li>
				<li>Apply the <strong class="source-inline">Audit</strong> method decorator factory on the <strong class="source-inline">updateScore</strong> method, with a parameter value of <strong class="source-inline">Updated score</strong>:<p class="source-code">    @MeasureDuration()</p><p class="source-code">    @Audit("Updated score")</p><p class="source-code">    updateScore(byPoints: number, updateTeam1: boolean) {</p></li>
				<li>Create a parameter decorator called <strong class="source-inline">OneTwoThree</strong> that will add the decorated parameter in the <strong class="source-inline">one-two-three</strong> metadata property:<p class="source-code">    function OneTwoThree(target: any, propertyKey: string, </p><p class="source-code">                                      parameterIndex: number) {</p><p class="source-code">        if (Reflect.hasMetadata("one-two-three", target, propertyKey)) {</p><p class="source-code">            const existing = Reflect.getMetadata("one-two-three",</p><p class="source-code">                                           target, propertyKey) as number[];</p><p class="source-code">            Reflect.defineMetadata("one-two-three", </p><p class="source-code">                       existing.concat(parameterIndex), target, propertyKey);</p><p class="source-code">        } else {</p><p class="source-code">            Reflect.defineMetadata("one-two-three", </p><p class="source-code">                                      [parameterIndex], target, propertyKey);</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Create a method decorator called <strong class="source-inline">Validate</strong> that will use method wrapping to load all values for the <strong class="source-inline">one-two-three</strong> metadata property, and for all marked parameters, check their value. If the value is 1, 2, or 3, you should continue the execution of the original method. If not, you should stop the execution with an error:<p class="source-code">    function Validate() {</p><p class="source-code">      return function (target: any, propertyKey:string, </p><p class="source-code">                                      descriptor: PropertyDescriptor) {</p><p class="source-code">            const original = descriptor.value;</p><p class="source-code">            descriptor.value = function (...args: any[]) {</p><p class="source-code">                // validate parameters</p><p class="source-code">                if (Reflect.hasMetadata("one-two-three", </p><p class="source-code">                                        target, propertyKey)) {</p><p class="source-code">                    const markedParams = Reflect.getMetadata("one-two-three",</p><p class="source-code">                                        target, propertyKey) as number[];</p><p class="source-code">                    for (const marked of markedParams) {</p><p class="source-code">                        if (![1,2,3].includes(args[marked])) {</p><p class="source-code">                            throw Error(`The parameter at position ${marked} can only be 1, 2 or 3`);</p><p class="source-code">                        }</p><p class="source-code">                    }</p><p class="source-code">                }</p><p class="source-code">                return original.apply(this, args);</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Apply the <strong class="source-inline">OneTwoThree</strong> decorator to the <strong class="source-inline">byPoints</strong> parameter of <strong class="source-inline">updateScore</strong> and apply the <strong class="source-inline">Validate</strong> decorator to the <strong class="source-inline">updateScore</strong> method.<p class="source-code">    @MeasureDuration()</p><p class="source-code">    @Audit("Updated score")</p><p class="source-code">    @Validate()</p><p class="source-code">    updateScore(@OneTwoThree byPoints: number, updateTeam1: boolean) {</p></li>
				<li>Create a <strong class="source-inline">game</strong> object and update its score a few times:<p class="source-code">const game = new BasketBallGame("LA Lakers", "Boston Celtics");</p><p class="source-code">game.updateScore(3, true);</p><p class="source-code">game.updateScore(2, false);</p><p class="source-code">game.updateScore(2, true);</p><p class="source-code">game.updateScore(2, false);</p><p class="source-code">game.updateScore(2, false);</p><p class="source-code">game.updateScore(2, true);</p><p class="source-code">game.updateScore(2, false);</p><p>When you run the file, the console should reflect the application of all decorators:</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 3, true ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, false ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, true ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, false ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, false ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, true ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">[AUDIT] Updated score (updateScore) called with arguments:</p><p class="source-code">[AUDIT] [ 2, false ]</p><p class="source-code">[AUDIT] and returned result:</p><p class="source-code">[AUDIT] undefined</p><p class="source-code">7:8</p></li>
			</ol>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor420"/>8. Dependency Injection in TypeScript</h1>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor421"/><a id="_idTextAnchor422"/>Activity 8.01: DI-Based Calculator</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we will build a basic calculator that utilizes DI to evaluate mathematical expressions, as well as logging its output to either the console or a file:</p>
			<ol>
				<li value="1">To start things off, define the basic building block of our calculator – an operator. This is defined via an interface, which actual implementations can rely on:<p class="source-code">export interface Operator {</p><p class="source-code">    readonly symbol: string;</p><p class="source-code">    evaluate(a: number, b: number): number;</p><p class="source-code">}</p><p>You need to create this file in the <strong class="source-inline">src/interfaces</strong> folder and save it as <strong class="source-inline">operator.interface.ts</strong>.</p></li>
				<li>Next, implement the first operator – the addition operator. This will be a class that implements the <strong class="source-inline">Operator</strong> interface:<p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code">export class AddOperator implements Operator {</p><p class="source-code">    readonly symbol = '+';</p><p class="source-code">    public evaluate(a: number, b: number) {</p><p class="source-code">    return a + b;</p><p class="source-code">    }</p><p class="source-code">}</p><p>The preceding code needs to be written in a file called <strong class="source-inline">add.operator.ts</strong> in <strong class="source-inline">src\operators</strong>.</p></li>
				<li>Make this operator available for injection by InversifyJS by adding the <strong class="source-inline">@injectable</strong> decorator to the class:<p class="source-code"><strong class="bold">import { injectable } from 'inversify';</strong></p><p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code"><strong class="bold">@injectable()</strong></p><p class="source-code">export class AddOperator implements Operator {</p><p class="source-code">    readonly symbol = '+';</p><p class="source-code">    public evaluate(a: number, b: number) {</p><p class="source-code">        return a + b;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, since interfaces don't exist at runtime, we need to create some runtime representation of our abstraction for <strong class="source-inline">AddOperator</strong>. This is usually done using symbols, and will be used by InversifyJS at runtime to understand what needs to be injected. We'll define it under a <strong class="source-inline">TYPES</strong> constant, which we'll be able to add other symbols for later:<p class="source-code">export const TYPES = {</p><p class="source-code">    AddOperator: Symbol.for('AddOperator'),</p><p class="source-code">};</p><p>This code needs to be written in a new file saved in the <strong class="source-inline">src\types\</strong> folder. We have named this file <strong class="source-inline">index.ts</strong>. </p></li>
				<li>Now, build a first draft for our calculator, which will use <strong class="source-inline">AddOperator</strong>, via DI:<p class="source-code">import { injectable, inject } from 'inversify';</p><p class="source-code">import { TYPES } from '../types';</p><p class="source-code">import { AddOperator } from '../operators/add.operator';</p><p class="source-code">@injectable()</p><p class="source-code">export class Calculator {</p><p class="source-code">    constructor(@inject(TYPES.AddOperator) private addOperator: AddOperator) {}</p><p class="source-code">    evaluate(expression: string) {</p><p class="source-code">        const expressionParts = expression.match(/[\d\.]+|\D+/g);</p><p class="source-code">        if (expressionParts === null) return null;</p><p class="source-code">        // for now, we're only going to support basic expressions: X+Y</p><p class="source-code">        const [operandA, operator, operandB] = expressionParts;</p><p class="source-code">        if (operator !== this.addOperator.symbol) {</p><p class="source-code">            throw new Error(`Unsupported operator. Expected ${this.addOperator.symbol}, received: ${operator}.`);</p><p class="source-code">        }</p><p class="source-code">        const result = this.addOperator.evaluate(Number(operandA), Number(operandB));</p><p class="source-code">        return result;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we implement a <strong class="source-inline">Calculator</strong> class that has a single method – <strong class="source-inline">evaluate</strong>, which takes in an expression as a string, and returns the result for that expression. This code needs to be written in a new file called <strong class="source-inline">index.ts</strong>, saved in the <strong class="source-inline">src/calculator</strong> folder.</p><p class="callout-heading">Note</p><p class="callout">The current implementation only supports expressions in the form of X+Y (where X and Y can be any numbers). We'll fix that later in the activity.</p><p>Calculator gets <strong class="source-inline">AddOperator</strong> in DI, and in order to evaluate the expression, it first runs through a regular expression to split it by numbers, and then it <em class="italic">destructures</em> the result array. Lastly, it uses the <strong class="source-inline">evaluate</strong> method of <strong class="source-inline">AddOperator</strong> to perform the final expression evaluation.</p><p>This means that the calculator's responsibility is only to destructure the expression into its individual parts, and then pass it off to <strong class="source-inline">AddOperator</strong> to handle the math evaluation logic. This demonstrates how using DI helps to retain the single responsibility principle of SOLID.</p></li>
				<li>Configure the IoC container (in the <strong class="source-inline">src/ioc.config.ts</strong> file) so that <strong class="source-inline">Calculator</strong> can receive <strong class="source-inline">AddOperator</strong> when it asks for <strong class="source-inline">TYPES.AddOperator</strong>:<p class="source-code">import { Container } from 'inversify';</p><p class="source-code">import { Calculator } from './calculator/index';</p><p class="source-code">import { Operator } from './interfaces/operator.interface';</p><p class="source-code">import { AddOperator } from './operators/add.operator';</p><p class="source-code">import { TYPES } from './types';</p><p class="source-code">export const container = new Container();</p><p class="source-code">container.bind&lt;Operator&gt;(TYPES.AddOperator).to(AddOperator);</p><p class="source-code">container.bind(Calculator).toSelf();</p></li>
				<li>Finally, our main file (<strong class="source-inline">src/main.ts</strong>), which will kick things off when we run the application, is as follows:<p class="source-code">import 'reflect-metadata';</p><p class="source-code">import { Calculator } from './calculator/index';</p><p class="source-code">import { container } from './ioc.config';</p><p class="source-code">const calculator = container.get(Calculator);</p><p class="source-code">try {</p><p class="source-code">    const result = calculator.evaluate('13+5');</p><p class="source-code">    console.log('result is', result);</p><p class="source-code">} catch (err) {</p><p class="source-code">    console.error(err);</p><p class="source-code">}</p><p>This is just using our previously defined IoC container and asking it for a <strong class="source-inline">Calculator</strong> instance. This is how we ask for instances of symbols explicitly in InversifyJS in an imperative API, which we need here, since we want to kick things off. Since InversifyJS is the one creating <strong class="source-inline">Calculator</strong>, it also looks at its constructor and sees that we've asked for a <strong class="source-inline">TYPES.AddOperator</strong>, which it then looks up in the IoC container again to resolve and gives that to the calculator's constructor.</p><p>Once you run this file, you should obtain the following output:</p><p class="source-code">result is 18</p><p>Note that you can either run the code by executing <strong class="source-inline">npm start</strong> in the <strong class="source-inline">activity-starter</strong> folder or by executing <strong class="source-inline">npx ts-node main.ts</strong> in the <strong class="source-inline">src</strong> folder.</p><p class="callout-heading">Note</p><p class="callout">If the <strong class="source-inline">AddOperator</strong> class were also to require dependencies using <strong class="source-inline">@inject</strong>, the same process described above would be repeated again to get them, and so on recursively until all dependencies have been resolved.</p></li>
				<li>Next, we can implement the other operators, similar to how we did with <strong class="source-inline">AddOperator</strong> – just replace the symbol with the relevant one (<strong class="source-inline">-</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">/</strong>) and the evaluate method's implementation with the relevant math operation:</li>
				<li>Here is the code for <strong class="source-inline">SubtractOperator</strong> (<strong class="source-inline">subtract.operator.ts</strong>):<p class="source-code">// operators/subtract.operator.ts</p><p class="source-code">import { injectable } from 'inversify';</p><p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class SubtractOperator implements Operator {</p><p class="source-code">    readonly symbol = '-';</p><p class="source-code">    public evaluate(a: number, b: number) {</p><p class="source-code">        return a - b;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Here is the code for <strong class="source-inline">MultiplyOperator</strong> (<strong class="source-inline">multiply.operator.ts</strong>):<p class="source-code">// operators/multiply.operator.ts</p><p class="source-code">import { injectable } from 'inversify';</p><p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class MultiplyOperator implements Operator {</p><p class="source-code">    readonly symbol = '*';</p><p class="source-code">    public evaluate(a: number, b: number) {</p><p class="source-code">        return a * b;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Here is the code for <strong class="source-inline">DivideOperator</strong> (<strong class="source-inline">divide.operator.ts</strong>):<p class="source-code">// operators/divide.operator.ts</p><p class="source-code">import { injectable } from 'inversify';</p><p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class DivideOperator implements Operator {</p><p class="source-code">    readonly symbol = '/';</p><p class="source-code">    public evaluate(a: number, b: number) {</p><p class="source-code">        return a / b;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Now, instead of creating an injection token for each <strong class="source-inline">Operator</strong>, injecting each one into <strong class="source-inline">Calculator</strong>, and then acting on each, we can create a more generic implementation of <strong class="source-inline">Calculator</strong> with the help of the <strong class="source-inline">@multiInject</strong> decorator. This decorator allows an injection token to be specified and an array of all implementations registered for that token to be obtained. This way, <strong class="source-inline">Calculator</strong> is not even coupled to an abstraction for any specific operator and only gets a dynamic list of operators, which can have any implementation as long as it conforms to the <strong class="source-inline">Operator</strong> interface.</p></li>
				<li>Update the <strong class="source-inline">types/index.ts</strong> file with the following code:<p class="source-code">export const TYPES = {</p><p class="source-code">    Operator: Symbol.for('Operator'),</p><p class="source-code">};</p><p>This replaces our <strong class="source-inline">AddOperator</strong> symbol from earlier with a more generic one.</p></li>
				<li>Update the calculator app code (<strong class="source-inline">src/calculator/index.ts</strong>):<p class="source-code">import { injectable, <strong class="bold">multiInject</strong> } from 'inversify';</p><p class="source-code"><strong class="bold">import { Operator } from '../interfaces/operator.interface';</strong></p><p class="source-code"><strong class="bold">import { tryParseNumberString, tryParseOperatorSymbol } from "../utils/math";</strong></p><p class="source-code">import { TYPES } from '../types';</p><p class="source-code">@injectable()</p><p class="source-code">export class Calculator {</p><p class="source-code">    <strong class="bold">constructor(@multiInject(TYPES.Operator) private operators: Operator[]) {}</strong></p><p class="source-code">    evaluate(expression: string) {</p><p class="source-code">        // same as before…</p><p class="source-code">    }</p><p class="source-code">}</p><p>Note that in further steps, you will need to modify the preceding code to include two functions, <strong class="source-inline">tryParseNumberString</strong> and <strong class="source-inline">tryParseOperatorSymbol</strong>. Both these functions are created in the <strong class="source-inline">math.ts</strong> file placed in the <strong class="source-inline">src/utils</strong> folder.</p></li>
				<li>Update the <strong class="source-inline">ioc.config.ts</strong> file:<p class="source-code">import { Container } from 'inversify';</p><p class="source-code">import { Calculator } from './calculator';</p><p class="source-code">import { Operator } from './interfaces/operator.interface';</p><p class="source-code">import { AddOperator } from './operators/add.operator';</p><p class="source-code">import { DivideOperator } from './operators/divide.operator';</p><p class="source-code">import { MultiplyOperator } from './operators/multiply.operator';</p><p class="source-code">import { SubtractOperator } from './operators/subtract.operator';</p><p class="source-code">import { TYPES } from './types';</p><p class="source-code">export const container = new Container();</p><p class="source-code">container.bind&lt;Operator&gt;(TYPES.Operator).to(AddOperator);</p><p class="source-code">container.bind&lt;Operator&gt;(TYPES.Operator).to(SubtractOperator);</p><p class="source-code">container.bind&lt;Operator&gt;(TYPES.Operator).to(MultiplyOperator);</p><p class="source-code">container.bind&lt;Operator&gt;(TYPES.Operator).to(DivideOperator);</p><p class="source-code">container.bind(Calculator).toSelf();</p></li>
				<li>Next, fix the naïve <strong class="source-inline">evaluate</strong> method of <strong class="source-inline">Calculator</strong> to be more generic, too. First, instead of relying on a specific token, <strong class="bold">map</strong> all expression parts and parse them:<p class="source-code">evaluate(expression: string) {</p><p class="source-code">    // ...</p><p class="source-code">    const parsedExpressionParts = expressionParts.map(part =&gt; {</p><p class="source-code">        const numberParseResult = tryParseNumberString(part);</p><p class="source-code">        if (numberParseResult.isNumberString) return numberParseResult.number;</p><p class="source-code">        const operatorParseResult = tryParseOperatorSymbol(part, this.operators);</p><p class="source-code">        if (operatorParseResult.isOperatorSymbol) return operatorParseResult.operator;</p><p class="source-code">        throw new Error(`Unexpected part: ${part}`);</p><p class="source-code">    });</p><p class="source-code"> }</p><p>This will give us back an array of numbers and operators.</p><p class="callout-heading">Note</p><p class="callout">Try to implement <strong class="source-inline">tryParseNumberString</strong> and <strong class="source-inline">tryParseOperatorSymbol</strong> yourself. However, you can refer to <strong class="source-inline">utils/math.ts</strong> to help you complete this step.</p></li>
				<li>Then, reduce this array to get our final result:<p class="source-code">evaluate(expression: string) {</p><p class="source-code">    // ...</p><p class="source-code">    const { result } = parsedExpressionParts.reduce&lt;{ result: number; queuedOperator: Operator | null }&gt;((acc, part) =&gt; {</p><p class="source-code">        if (typeof part === 'number') {</p><p class="source-code">            // this is the first number we've encountered, just set the result to that.</p><p class="source-code">            if (acc.queuedOperator === null) {</p><p class="source-code">                return { ...acc, result: part };</p><p class="source-code">            }</p><p class="source-code">            // there's a queued operator – evaluate the previous result with this and</p><p class="source-code">            // clear the queued one.</p><p class="source-code">            return {</p><p class="source-code">                queuedOperator: null,</p><p class="source-code">                result: acc.queuedOperator.evaluate(acc.result, part),</p><p class="source-code">              };</p><p class="source-code">        }</p><p class="source-code">        // this is an operator – queue it for later execution</p><p class="source-code">        return {</p><p class="source-code">            ...acc,</p><p class="source-code">            queuedOperator: part,</p><p class="source-code">        };</p><p class="source-code">    }, { result: 0, queuedOperator: null });</p><p class="source-code">    return result;</p><p class="source-code">}</p></li>
				<li>Simplify the code in the <strong class="source-inline">ioc.config.ts</strong> file even further by leveraging barrels. Create <strong class="source-inline">operator/index.ts</strong> with the following code:<p class="source-code">// operators/index.ts</p><p class="source-code">export * from './add.operator';</p><p class="source-code">export * from './divide.operator';</p><p class="source-code">export * from './multiply.operator';</p><p class="source-code">export * from './subtract.operator';</p></li>
				<li>Update the <strong class="source-inline">ioc.config.ts</strong> file:<p class="source-code">// ioc.config.ts</p><p class="source-code">import { Container } from 'inversify';</p><p class="source-code">import { Calculator } from './calculator';</p><p class="source-code">import { Operator } from './interfaces/operator.interface';</p><p class="source-code">import * as Operators from './operators';</p><p class="source-code">import { TYPES } from './types';</p><p class="source-code">export const container = new Container();</p><p class="source-code">Object.values(Operators).forEach(Operator =&gt; {</p><p class="source-code">    container.bind&lt;Operator&gt;(TYPES.Operator).to(Operator);</p><p class="source-code">});</p><p class="source-code">container.bind(Calculator).toSelf();</p><p>This means we now import an <strong class="source-inline">Operators</strong> object from the barrel file, which includes everything that's exposed there. We take the values of that barrel object and bind each one to <strong class="source-inline">TYPES.Operator</strong>, generically.</p><p>This means that adding another <strong class="source-inline">Operator</strong> object only requires us to create a new class that implements the <strong class="source-inline">Operator</strong> interface and add it to our <strong class="source-inline">operators/index.ts</strong> file. The rest of the code should work without any changes.</p></li>
				<li>Our <strong class="source-inline">main.ts</strong> file is changed to a slightly more complicated expression:<p class="source-code">import 'reflect-metadata';</p><p class="source-code">import { Calculator } from './calculator';</p><p class="source-code">import { container } from './ioc.config';</p><p class="source-code">const calculator = container.get(Calculator);</p><p class="source-code">try {</p><p class="source-code">    const result = calculator.evaluate('13*10+20');</p><p class="source-code">    console.log('result is', result);</p><p class="source-code">} catch (err) {</p><p class="source-code">    console.error(err);</p><p class="source-code">}</p><p>When you run the <strong class="source-inline">main.ts</strong> file (using <strong class="source-inline">npx ts-node main.ts</strong>), you should obtain the following output:</p><p class="source-code">result is 150</p></li>
			</ol>
			<h3 id="_idParaDest-351"><strong class="bold"><a id="_idTextAnchor423"/>Bonus:</strong></h3>
			<ol>
				<li value="1">As a bonus, let's say that we want some reporting on the operations performed in the calculator. We can add logging pretty easily without too many changes. We'll create two reporting implementations, one to the console and another to a filesystem:<p class="callout-heading">Note</p><p class="callout">The filesystem implementation will only work in a Node.js environment, since it will use some modules only available to it.</p></li>
				<li>Define the <strong class="source-inline">Logger</strong> interface:<p class="source-code">export interface Logger {</p><p class="source-code">    log(message: string, ...args: any[]): void;</p><p class="source-code">    warn(message: string, ...args: any[]): void;</p><p class="source-code">    error(message: string, ...args: any[]): void;</p><p class="source-code">}</p><p>This will serve as the public API that the consumers wanting a logger can use, and that our implementations will need to adhere to.</p></li>
				<li>Create the console-based implementation of <strong class="source-inline">Logger</strong> first:<p class="source-code">import { injectable } from 'inversify';</p><p class="source-code">import { Logger } from '../interfaces/logger.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class ConsoleLogger implements Logger {</p><p class="source-code">    log(message: string, ...args: any[]) {</p><p class="source-code">        console.log('[LOG]', message, ...args);</p><p class="source-code">    }</p><p class="source-code">    warn(message: string, ...args: any[]) {</p><p class="source-code">        console.warn('[WARN]', message, ...args);</p><p class="source-code">    }</p><p class="source-code">    error(message: string, ...args: any[]) {</p><p class="source-code">        console.error('[ERROR]', message, ...args);</p><p class="source-code">    }</p><p class="source-code">}</p><p>This is a simple wrapper class around the <strong class="source-inline">console</strong> object that's built into browser engines and Node.js. It adheres to our <strong class="source-inline">Logger</strong> interface, and so allows consumers to depend on it. For the example, we've also added the type of the message to the beginning of the actual output.</p></li>
				<li>Next<a id="_idTextAnchor424"/>, create an injection token for it, and register it in our container. The updated code for the <strong class="source-inline">types/index.ts</strong> file is as follows:<p class="source-code">// types/index.ts</p><p class="source-code">export const TYPES = {</p><p class="source-code">    Operator: Symbol.for('Operator'),</p><p class="source-code">    Logger: Symbol.for('Logger'),</p><p class="source-code">};</p><p>The updated code for the <strong class="source-inline">src/ioc.config.ts</strong> file is as follows:</p><p class="source-code">// ioc.config.ts</p><p class="source-code">import { Container } from 'inversify';</p><p class="source-code">import { Calculator } from './calculator';</p><p class="source-code">import { Logger } from './interfaces/logger.interface';</p><p class="source-code">import { Operator } from './interfaces/operator.interface';</p><p class="source-code">import { ConsoleLogger } from './logger/console.logger';</p><p class="source-code">import * as Operators from './operators';</p><p class="source-code">import { TYPES } from './types';</p><p class="source-code">export const container = new Container();</p><p class="source-code">Object.values(Operators).forEach(Operator =&gt; {</p><p class="source-code">    container.bind&lt;Operator&gt;(TYPES.Operator).to(Operator);</p><p class="source-code">});</p><p class="source-code">container.bind(Calculator).toSelf();</p><p class="source-code">container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</p></li>
				<li>Finally, use the logger in our <strong class="source-inline">Calculator</strong> class:<p class="source-code">import { injectable, multiInject, inject, optional } from 'inversify';</p><p class="source-code">import { Operator } from '../interfaces/operator.interface';</p><p class="source-code">import { TYPES } from '../types';</p><p class="source-code">import { tryParseNumberString, tryParseOperatorSymbol } from '../utils/math';</p><p class="source-code">import { Logger } from '../interfaces/logger.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class Calculator {</p><p class="source-code">    constructor(</p><p class="source-code">        @multiInject(TYPES.Operator) private operators: Operator[],</p><p class="source-code">        @inject(TYPES.Logger) @optional() private logger?: Logger</p><p class="source-code">    ) {}</p><p class="source-code">    evaluate(expression: string) {</p><p class="source-code">        // ...</p><p class="source-code">        const { result } = parsedExpressionParts.reduce&lt;{ result: number; queuedOperator: Operator | null }&gt;( ... );</p><p class="source-code">        this.logger &amp;&amp; this.logger.log(`Calculated result of expression: ${expression} to be: ${result}`);</p><p class="source-code">        return result;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Notice that we use the <strong class="source-inline">@optional</strong> decorator to indicate to InversifyJS that <strong class="source-inline">Calculator</strong> doesn't <em class="italic">require</em> a <strong class="source-inline">Logger</strong> to operate, but if it has one it can inject, <strong class="source-inline">Calculator</strong> can use it. This is also why it's marked as an optional argument in the constructor, and why we need to check whether it exists before calling the <strong class="source-inline">log</strong> method.</p><p>The output to the console when running it should be as follows:</p><p class="source-code">[LOG] Calculated result of expression:13*10+20 is 150</p><p>Now, let's say we want to replace our console-based logger with a file-based one, which will persist across runs so that we can track the calculator's evaluation history.</p></li>
				<li>Create a <strong class="source-inline">FileLogger</strong> class that implements <strong class="source-inline">Logger</strong>:<p class="source-code">import fs from 'fs';</p><p class="source-code">import { injectable } from 'inversify';</p><p class="source-code">import { Logger } from '../interfaces/logger.interface';</p><p class="source-code">@injectable()</p><p class="source-code">export class FileLogger implements Logger {</p><p class="source-code">    private readonly loggerPath: string = '/tmp/calculator.log';</p><p class="source-code">    log(message: string, ...args: any[]) {</p><p class="source-code">        this.logInternal('LOG', message, args);</p><p class="source-code">    }</p><p class="source-code">    warn(message: string, ...args: any[]) {</p><p class="source-code">        this.logInternal('WARN', message, args);</p><p class="source-code">    }</p><p class="source-code">    error(message: string, ...args: any[]) {</p><p class="source-code">        this.logInternal('ERROR', message, args);</p><p class="source-code">    }</p><p class="source-code">    private logInternal(level: string, message: string, ...args: any[]) {</p><p class="source-code">        fs.appendFileSync(this.loggerPath, this.logLineFormatter(level, message, args));</p><p class="source-code">    }</p><p class="source-code">    private logLineFormatter(level: string, message: string, ...args: any[]) {</p><p class="source-code">        return `[${level}]: ${message}${args}\n`;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>And finally, all we need to do in order to replace our console-based logger with a file-based one is a single-line change in our IoC container configuration.<p>For console-based logging, use this command:</p><p class="source-code">container.bind&lt;Logger&gt;(TYPES.Logger).to(ConsoleLogger);</p><p>For file-based logging, use this command:</p><p class="source-code">container.bind&lt;Logger&gt;(TYPES.Logger).to(FileLogger);</p><p>Make sure to import this logger correctly in the <strong class="source-inline">ioc.config.ts</strong> file.</p><p>The final output to the file is as follows:</p><div id="_idContainer181" class="IMG---Figure"><img src="image/B14508_08_08.jpg" alt="Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log, after changing the app to use it&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.8: Final output of the file-based logger in activity-starter/src//tmp/calculator.log, after changing the app to use it</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor425"/>9. Generics and Conditional Types</h1>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor426"/><a id="_idTextAnchor427"/>Activity 9.01: Creating a DeepPartial&lt;T&gt; Type</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Let's build this type up, step by step:</p>
			<ol>
				<li value="1">First, let's create a <strong class="source-inline">PartialPrimitive</strong> type:<p class="source-code">type PartialPrimitive = string | number | boolean | symbol | bigint | Function | Date;</p></li>
				<li>Then, let's start by defining a basic <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type:<p class="source-code">type DeepPartial&lt;T&gt; = T extends PartialPrimitive ? T : Partial&lt;T&gt;;</p><p>Next, we need to handle more complex structures – such as array<a id="_idTextAnchor428"/><a id="_idTextAnchor429"/>s, sets, and maps. These require using the <strong class="source-inline">infer</strong> keyword, and in addition to that, require some more "manual wiring" for each of these types. </p></li>
				<li>Let's start with adding handling for the <strong class="source-inline">Array</strong> type: <p class="source-code">type DeepPartial&lt;T&gt; =</p><p class="source-code">     T extends PartialPrimitive</p><p class="source-code">     ? T</p><p class="source-code">     : T extends Array&lt;infer U&gt;</p><p class="source-code">     ? Array&lt;DeepPartial&lt;U&gt;&gt;</p><p class="source-code">     : Partial&lt;T&gt;;</p><p>This would've worked, but due to current limitations in TypeScript at the time of writing, this doesn't compile, since <strong class="source-inline">DeepPartial&lt;T&gt;</strong> circularly references itself:</p><div id="_idContainer182" class="IMG---Figure"><img src="image/B14508_09_17.jpg" alt="Figure 9.17: Current TypeScript version limitation not allowing generic &#13;&#10;types to reference themselves&#13;&#10;"/></div><p class="figure-caption">Figure 9.17: Current TypeScript version limitation not allowing generic types to reference themselves</p><p>To work around this, we'll create a helper type, <strong class="source-inline">DeepPartialArray&lt;T&gt;</strong>, and use it:</p><p class="source-code">interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}</p><p class="source-code">type DeepPartial&lt;T&gt; =</p><p class="source-code">     T extends PartialPrimitive</p><p class="source-code">     ? T</p><p class="source-code">     : T extends Array&lt;infer U&gt;</p><p class="source-code">     ? DeepPartialArray&lt;U&gt;</p><p class="source-code">     : Partial&lt;T&gt;;</p><p>This works around the problem and compiles fine.</p></li>
				<li>Next, to support a <strong class="source-inline">Set</strong>, a similar approach to what we did in the previous step is needed, so we'll create an <strong class="source-inline">interface</strong> to serve as a "middle-man" for building the entire generic type:<p class="source-code">interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}</p><p class="source-code">interface DeepPartialSet&lt;T&gt; extends Set&lt;DeepPartial&lt;T&gt;&gt; {}</p><p class="source-code">type DeepPartial&lt;T&gt; = T extends PartialPrimitive</p><p class="source-code">    ? T</p><p class="source-code">    : T extends Array&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialArray&lt;U&gt;</p><p class="source-code">    : T extends Set&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialSet&lt;U&gt;</p><p class="source-code">    : Partial&lt;T&gt;;</p></li>
				<li>Similarly to arrays and sets, maps also need the approach wherein we need create an <strong class="source-inline">interface</strong> to serve as a "middle-man" for building the entire generic type:<p class="source-code">interface DeepPartialArray&lt;T&gt; extends Array&lt;DeepPartial&lt;T&gt;&gt; {}</p><p class="source-code">interface DeepPartialSet&lt;T&gt; extends Set&lt;DeepPartial&lt;T&gt;&gt; {}</p><p class="source-code">interface DeepPartialMap&lt;K, V&gt; extends Map&lt;DeepPartial&lt;K&gt;, DeepPartial&lt;V&gt;&gt; {}</p><p class="source-code">type DeepPartial&lt;T&gt; = T extends PartialPrimitive</p><p class="source-code">    ? T</p><p class="source-code">    : T extends Array&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialArray&lt;U&gt;</p><p class="source-code">    : T extends Map&lt;infer K, infer V&gt;</p><p class="source-code">    ? DeepPartialMap&lt;K, V&gt;</p><p class="source-code">    : T extends Set&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialSet&lt;U&gt;</p><p class="source-code">    : Partial&lt;T&gt;;</p><p class="callout-heading">Note</p><p class="callout">This workaround is no longer needed as of TypeScript 3.7.</p></li>
				<li>Lastly, let's make our <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type support objects too:<p class="source-code">type DeepPartial&lt;T&gt; = T extends PartialPrimitive</p><p class="source-code">    ? T</p><p class="source-code">    : T extends Array&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialArray&lt;U&gt;</p><p class="source-code">    : T extends Map&lt;infer K, infer V&gt;</p><p class="source-code">    ? DeepPartialMap&lt;K, V&gt;</p><p class="source-code">    : T extends Set&lt;infer U&gt;</p><p class="source-code">    ? DeepPartialSet&lt;U&gt;</p><p class="source-code">    : T extends {}</p><p class="source-code">    ? { [K in keyof T]?: DeepPartial&lt;T[K]&gt; }</p><p class="source-code">    : Partial&lt;T&gt;;</p><p>This completes the <strong class="source-inline">DeepPartial&lt;T&gt;</strong> implementation.</p><p>A great use case for the <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type is in a server-side <strong class="source-inline">PATCH</strong> method handler, which updates a given resource with new data. In <strong class="source-inline">PATCH</strong> requests, all fields are usually optional:</p><p class="source-code">import express from 'express';</p><p class="source-code">const app = express();</p><p class="source-code">app.patch('/users/:userId', async (req, res) =&gt; {</p><p class="source-code">    const userId = req.params.userId;</p><p class="source-code">    const userUpdateData: DeepPartial&lt;User&gt; = req.body;</p><p class="source-code">    const user = await User.getById(userId);</p><p class="source-code">    await user.update(userUpdateData);</p><p class="source-code">    await user.save();</p><p class="source-code">    res.status(200).end(user);</p><p class="source-code">});</p><p>Notice that we use <strong class="source-inline">DeepPartial&lt;User&gt;</strong> to correctly type the body of the request, before passing it in the <strong class="source-inline">update</strong> method:</p></li>
			</ol>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B14508_09_18.jpg" alt="Figure 9.18: The correctly typed request body&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18: The correctly typed request body</p>
			<p>As can be seen in the preceding figure, due to the usage of <strong class="source-inline">DeepPartial&lt;T&gt;</strong>, the request's body is typed correctly, such that all fields are optional, including nested ones.</p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor430"/>10. Event Loop and Asynchronous Behavior</h1>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor431"/><a id="_idTextAnchor432"/>Activity 10.01: Movie Browser Using XHR and Callbacks </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Construct a new <strong class="source-inline">XMLHttpRequest</strong> object:<p class="source-code">    const xhr = new XMLHttpRequest();</p></li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method:<p class="source-code">    const url = getSearchUrl(value);</p></li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> methods of the <strong class="source-inline">xhr</strong> object:<p class="source-code">    xhr.open('GET', url);    xhr.send();</p></li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> object's <strong class="source-inline">onload</strong> event. Take the response and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">SearchResultApi</strong> interface. This data will have the results of our search in a <strong class="source-inline">results</strong> field. If we get no results, this means that our search failed:<p class="source-code">    xhr.onload = function() {        const data = JSON.parse(this.response) as SearchResultApi;    }</p></li>
				<li>If the search returned no results, call the <strong class="source-inline">clearResults</strong> method:<p class="source-code">    if (data.results.length === 0) {        clearResults(value);    } </p></li>
				<li>If the search returned some results, just take the first one and store it in a variable, ignoring the other ones:<p class="source-code">    else {        const resultMovie = data.results[0];    }</p></li>
				<li>Inside the <strong class="source-inline">onload</strong> handler, in the successful search branch, create a new <strong class="source-inline">XMLHttpRequest</strong> object:<p class="source-code">    const movieXhr = new XMLHttpRequest();</p></li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getMovieUrl</strong> method:<p class="source-code">    const movieUrl = getMovieUrl(resultMovie.id);</p></li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> method of the constructed <strong class="source-inline">xhr</strong> object:<p class="source-code">    movieXhr.open('GET', movieUrl);    movieXhr.send();</p></li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> object's <strong class="source-inline">onload</strong> event. Take the response and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">MovieResultApi</strong> interface. This response will have the general data for our movie, specifically, everything except the people who were involved in the movie. We will need to have another call to the API to get the data about the people:<p class="source-code">    movieXhr.onload = function () {        const movieData: MovieResultApi = JSON.parse(this.response);</p></li>
				<li>Inside the <strong class="source-inline">onload</strong> handler, create a new <strong class="source-inline">XMLHttpRequest</strong> object:<p class="source-code">    const peopleXhr = new XMLHttpRequest();</p></li>
				<li>Construct a new string for the search result URL using the <strong class="source-inline">getPeopleUrl</strong> method:<p class="source-code">    const peopleUrl = getPeopleUrl(resultMovie.id);</p></li>
				<li>Call the <strong class="source-inline">open</strong> and <strong class="source-inline">send</strong> method of the constructed <strong class="source-inline">xhr</strong> object:<p class="source-code">    peopleXhr.open('GET', peopleUrl);    peopleXhr.send();</p></li>
				<li>Add an event handler for the <strong class="source-inline">xhr</strong> object's <strong class="source-inline">onload</strong> event. Take the response, and parse it as a JSON object. Store the result in a variable of the <strong class="source-inline">PeopleResultApi</strong> interface. This response will have data about the people who were involved in the movie:<p class="source-code">    const data = JSON.parse(this.response) as PeopleResultApi;</p></li>
				<li>Now we actually have all the data we need, so we can actually create our own object, inside the people <strong class="source-inline">onload</strong> handler, which is inside the movie <strong class="source-inline">onload</strong> handler, which is inside the search <strong class="source-inline">onload</strong> handler.<p>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. We'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array:</p><p class="source-code">    data.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = data.cast.slice(0, 6);</p></li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into your own <strong class="source-inline">Character</strong> objects. We need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property:<p class="source-code">    const characters: Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</p></li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const directors = data.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</p></li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const writers = data.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</p></li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses we've prepared so far:<p class="source-code">    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,</p><p class="source-code">        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</p></li>
				<li>Call the <strong class="source-inline">showResults</strong> function with the movie we constructed:<p class="source-code">    showResults(movie);</p></li>
				<li>In your parent directory (<strong class="source-inline">Activity01</strong> in this case), install dependencies with <strong class="source-inline">npm i</strong>.</li>
				<li>Compile the program using <strong class="source-inline">tsc ./script.ts ./interfaces.ts ./display.ts</strong>.</li>
				<li>Verify that the compilation ended successfully.</li>
				<li>Open <strong class="source-inline">index.html</strong> using the browser of your choice. <p>You should see the following in your browser:</p></li>
			</ol>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B14508_10_04.jpg" alt="Figure 10.5: The final web page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5: The final web page</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor433"/><a id="_idTextAnchor434"/>Activity 10.02: Movie Browser Using fetch and Promises</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty.</li>
				<li>Above the <strong class="source-inline">search</strong> function, create a helper function called <strong class="source-inline">getJsonData</strong>. This function will use the <strong class="source-inline">fetch</strong> API to get data from an endpoint and format it as JSON. It should take a single string called <strong class="source-inline">url</strong> as a parameter, and it should return a promise:<p class="source-code">const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {}</p></li>
				<li>In the body of the <strong class="source-inline">getJsonData</strong> function, add code that calls the <strong class="source-inline">fetch</strong> function with the <strong class="source-inline">url</strong> parameter, and <strong class="source-inline">then</strong> call the <strong class="source-inline">json</strong> method on the returned response:<p class="source-code">const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {    return fetch(url)        .then(response =&gt; response.json());}</p></li>
				<li>In the <strong class="source-inline">search</strong> method, construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method:<p class="source-code">    const searchUrl = getSearchUrl(value);</p></li>
				<li>Call the <strong class="source-inline">getJsonData</strong> function with <strong class="source-inline">searchUrl</strong> as a parameter:<p class="source-code">    return getJsonData(searchUrl)</p></li>
				<li>Add a <strong class="source-inline">then</strong> handler to the promise returned from <strong class="source-inline">getJsonData</strong>. The handler takes a single parameter of the type <strong class="source-inline">SearchResultApi</strong>:<p class="source-code">    return getJsonData(url)        .then((data:SearchResultApi) =&gt; {        }</p></li>
				<li>In the body of the handler, check whether we have any results and if we don't, throw an error. If we do have results, return the first item. Note that the handler returns an object with <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> properties, but the <strong class="source-inline">then</strong> method actually returns a promise of that data. This means that after the handler, we can chain other <strong class="source-inline">then</strong> calls:<p class="source-code">    .then((data:SearchResultApi) =&gt; {        if (data.results.length === 0) {            throw Error("Not found");        }        return data.results[0];    })</p></li>
				<li>Add another <strong class="source-inline">then</strong> call to the previous handler. This handler will take a <strong class="source-inline">movieResult</strong> parameter that contains the <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> of the movie. Use the <strong class="source-inline">id</strong> property to call the <strong class="source-inline">getMovieUrl</strong> and <strong class="source-inline">getPeopleUrl</strong> methods to, respectively, get the correct URLs for the movie details and for the cast and crew:<p class="source-code">    })    .then(movieResult =&gt; {        const movieUrl = getMovieUrl(movieResult.id);        const peopleUrl = getPeopleUrl(movieResult.id);    })</p></li>
				<li>After getting the URLs, call the <strong class="source-inline">getJsonData</strong> function with both of them, and assign the resulting values to variables. Note that the <strong class="source-inline">getJsonData(movieUrl)</strong> call will return a promise of <strong class="source-inline">MovieResultApi</strong>, and <strong class="source-inline">getJsonData(peopleUrl)</strong> will return a promise of <strong class="source-inline">PeopleResultApi</strong>. Assign those result values to variables called <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong>:<p class="source-code">    const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);    const dataPromise: Promise&lt;MovieResultApi&gt; = getJsonData(movieUrl);    const peoplePromise: Promise&lt;PeopleResultApi&gt; = getJsonData(peopleUrl);</p></li>
				<li>Call the static <strong class="source-inline">Promise.all</strong> method with <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results:<p class="source-code">    const resultPromise = Promise.all([dataPromise, peoplePromise]);</p></li>
				<li>Return the promise generated by the <strong class="source-inline">Promise.all</strong> call from the handler:<p class="source-code">        return resultPromise;    })</p></li>
				<li>Add another <strong class="source-inline">then</strong> handler to the chain. This handler will take the array returned from <strong class="source-inline">Promise.all</strong> as a single parameter:<p class="source-code">    })    .then(dataResult =&gt; {    });</p></li>
				<li>Deconstruct the parameter into two variables. The first element of the array should be the <strong class="source-inline">movieData</strong> variable of type <strong class="source-inline">MovieResultApi</strong>, and the second element of the array should be the <strong class="source-inline">peopleData</strong> variable of type <strong class="source-inline">PeopleResultApi</strong>:<p class="source-code">    const [movieData, peopleData] = dataResult // we can actually let TypeScripts type inference pick out the types</p></li>
				<li>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. We'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array:<p class="source-code">    peopleData.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);</p></li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into our own <strong class="source-inline">Character</strong> objects. We need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property:<p class="source-code">    const characters :Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</p></li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const directors = peopleData.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</p></li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const writers = peopleData.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</p></li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses we've prepared so far:<p class="source-code">    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</p></li>
				<li>Return the <strong class="source-inline">Movie</strong> object from the handler:<p class="source-code">        return movie;    });</p><p>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <strong class="source-inline">click</strong> event handler of the <strong class="source-inline">search</strong> button. We should simply add a <strong class="source-inline">then</strong> handler to the <strong class="source-inline">search</strong> call that will call the <strong class="source-inline">showResults</strong> method, and a <strong class="source-inline">catch</strong> handler that will call the <strong class="source-inline">clearResults</strong> method:</p><p class="source-code">    search(movieTitle)        .then(movie =&gt; showResults(movie))        .catch(_ =&gt; clearResults(value));</p></li>
			</ol>
			<p>The output should be the same as the previous activity.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor435"/><a id="_idTextAnchor436"/>Activity 10.03: Movie Browser Using fetch and async/await</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">In the <strong class="source-inline">script.ts</strong> file, locate the <strong class="source-inline">search</strong> function and verify that it takes a single string parameter and that its body is empty. Note that this function is now marked with the <strong class="source-inline">async</strong> keyword, which allows us to use the <strong class="source-inline">await</strong> operator:<p class="source-code">const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {}</p></li>
				<li>In the body of the <strong class="source-inline">getJsonData</strong> function, add code that calls and <strong class="source-inline">await</strong>s the <strong class="source-inline">fetch</strong> function with the <strong class="source-inline">url</strong> parameter, and then call calls the <strong class="source-inline">json</strong> method on the returned response:<p class="source-code">const getJsonData = (url: string):Promise&lt;any&gt; =&gt; {    const response = await fetch(url);    return response.json();}</p></li>
				<li>In the <strong class="source-inline">search</strong> method, construct a new string for the search result URL using the <strong class="source-inline">getSearchUrl</strong> method:<p class="source-code">    const url = getSearchUrl(value);</p></li>
				<li>Call the <strong class="source-inline">getJsonData</strong> function with the <strong class="source-inline">searchUrl</strong> as a parameter, and <strong class="source-inline">await</strong> the result. Place the result in the <strong class="source-inline">SearchResultApi</strong> variable:<p class="source-code">    const data: SearchResultApi = await getJsonData(url);</p></li>
				<li>Check whether we have any results and if we don't, throw an error. If we do have results, set the first item of the <strong class="source-inline">result</strong> property in a variable called <strong class="source-inline">movieResult</strong>. This object will contain the <strong class="source-inline">id</strong> and <strong class="source-inline">title</strong> properties of the movie:<p class="source-code">    if (data.results.length === 0) {        throw Error("Not found");    }    const movieResult = data.results[0];</p></li>
				<li>Use the <strong class="source-inline">id</strong> property to call the <strong class="source-inline">getMovieUrl</strong> and <strong class="source-inline">getPeopleUrl</strong> methods to, respectively, get the correct URLs for the movie details and for the cast and crew:<p class="source-code">    const movieUrl = getMovieUrl(movieResult.id);    const peopleUrl = getPeopleUrl(movieResult.id);</p></li>
				<li>After getting the URLs, call the <strong class="source-inline">getJsonData</strong> function with both and assign the resulting values to variables. Note that the <strong class="source-inline">getJsonData(movieUrl)</strong> call will return a promise of <strong class="source-inline">MovieResultApi</strong>, and <strong class="source-inline">getJsonData(peopleUrl)</strong> will return a promise of <strong class="source-inline">PeopleResultApi</strong>. Assign those result values to variables called <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong>:<p class="source-code">    const dataPromise: Promise&lt;MovieResultApi&gt; = getJsonData(movieUrl);    const peoplePromise: Promise&lt;PeopleResultApi&gt; = getJsonData(peopleUrl);</p></li>
				<li>Call the static <strong class="source-inline">Promise.all</strong> method with <strong class="source-inline">dataPromise</strong> and <strong class="source-inline">peoplePromise</strong> as parameters. This will create another promise based on those two values, and this promise will be resolved successfully if and only if both (that is, all) promises that are contained within resolve successfully. Its return value will be a promise of an array of results. <strong class="source-inline">await</strong> this promise, and place its result in a variable of type array:<p class="source-code">    const dataArray = await Promise.all([dataPromise, peoplePromise]);</p></li>
				<li>Deconstruct that array into two variables. The first element of the array should be the <strong class="source-inline">movieData</strong> variable of type <strong class="source-inline">MovieResultApi</strong>, and the second element of the array should be the <strong class="source-inline">peopleData</strong> variable of type <strong class="source-inline">PeopleResultApi</strong>:<p class="source-code">     const [movieData, peopleData] = dataArray;</p></li>
				<li>The people data has <strong class="source-inline">cast</strong> and <strong class="source-inline">crew</strong> properties. We'll only take the first six cast members, so first sort the <strong class="source-inline">cast</strong> property according to the <strong class="source-inline">order</strong> property of the cast members. Then slice off the first six cast members into a new array:<p class="source-code">    peopleData.cast.sort((f, s) =&gt; f.order - s.order);    const mainActors = peopleData.cast.slice(0, 6);</p></li>
				<li>Transform the cast data (which is <strong class="source-inline">CastResultApi</strong> objects) into our own <strong class="source-inline">Character</strong> objects. We need to map the <strong class="source-inline">character</strong> field of <strong class="source-inline">CastResultApi</strong> to the <strong class="source-inline">name</strong> field of <strong class="source-inline">Character</strong>, the <strong class="source-inline">name</strong> field to the <strong class="source-inline">actor</strong> name, and the <strong class="source-inline">profile_path</strong> field to the <strong class="source-inline">image</strong> property:<p class="source-code">    const characters :Character[] = mainActors.map(actor =&gt; ({        name: actor.character,        actor: actor.name,        image: actor.profile_path     }))</p></li>
				<li>From the <strong class="source-inline">crew</strong> property of the people data, we'll only need the director and the writer. Since there can be multiple directors and writers, we'll get the names of all directors and writers, and concatenate them, respectively. For the directors, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Directing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Director</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const directors = peopleData.crew         .filter(person =&gt; person.department === "Directing" &amp;&amp; person.job === "Director")        .map(person =&gt; person.name)    const directedBy = directors.join(" &amp; ");</p></li>
				<li>For the writers, from the <strong class="source-inline">crew</strong> property, filter the people who have a <strong class="source-inline">department</strong> of <strong class="source-inline">Writing</strong> and a <strong class="source-inline">job</strong> of <strong class="source-inline">Writer</strong>. For those objects, take the <strong class="source-inline">name</strong> property, and <strong class="source-inline">join</strong> it together with an <strong class="source-inline">&amp;</strong> in between:<p class="source-code">    const writers = peopleData.crew         .filter(person =&gt; person.department === "Writing" &amp;&amp; person.job === "Writer")        .map(person =&gt; person.name);    const writtenBy = writers.join(" &amp; ");</p></li>
				<li>Create a new <strong class="source-inline">Movie</strong> object (using object literal syntax). Fill in all the properties of the <strong class="source-inline">Movie</strong> object using the data from the movie and people responses we've prepared so far:<p class="source-code">    const movie: Movie = {        id: movieData.id,        title: movieData.title,        tagline: movieData.tagline,        releaseDate: new Date(movieData.release_date),        posterUrl: movieData.poster_path,        backdropUrl: movieData.backdrop_path,        overview: movieData.overview,        runtime: movieData.runtime,        characters: characters,        directedBy: directedBy,        writenBy: writtenBy     }</p></li>
				<li>Return the <strong class="source-inline">Movie</strong> object from the function:<p class="source-code">    return movie; </p></li>
				<li>Note that we did not do any UI interactions in our code. We just received a string, did some promise calls, and returned a value. The UI work can now be done in UI-oriented code. In this case, that's in the <strong class="source-inline">click</strong> event handler of the <strong class="source-inline">search</strong> button. We should simply <strong class="source-inline">await</strong> the result of the <strong class="source-inline">search</strong> call and then call the <strong class="source-inline">showResults</strong> method with it. We can use a standard <strong class="source-inline">catch</strong> expression to handle any errors:<p class="source-code">    try {        const movie = await search(movieTitle);        showResults(movie);    } catch {        clearResults(movieTitle);    }</p></li>
			</ol>
			<p>The output should be the same as the previous activity.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor437"/>11. Higher-Order Functions and Callbacks</h1>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor438"/><a id="_idTextAnchor439"/>Activity 11.01: Higher-Order Pipe Function</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>In this activity, we'll build a higher-order <strong class="source-inline">pipe</strong> function that accepts functions as arguments, and composes them from left to right, returning a function that accepts the arguments of the first function, and returns the type of the last function. When the returned function is run, it iterates over the given functions, feeding the return value of each function to the next one:</p>
			<ol>
				<li value="1">Let's start by defining a type definition for the supported functions to compose, a function that accepts one argument of type <strong class="source-inline">T</strong> and returns one of type <strong class="source-inline">R</strong>:<p class="source-code">type UnaryFunction&lt;T, R&gt; = T extends void ? () =&gt; R : (arg: T) =&gt; R;</p><p>As mentioned, we'll only support functions accepting up to one argument, for simplicity.</p><p>Note that in order to deal with the special case of 0 arguments, we need to check whether <strong class="source-inline">T extends void</strong> and returns a parameterless function.</p></li>
				<li>Next, let's start by writing a simple implementation of the <strong class="source-inline">pipe</strong> function, one that supports only a single function, making it essentially an identity function:<p class="source-code">function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;</p><p class="source-code">function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt; {</p><p class="source-code">    return fn;</p><p class="source-code">}</p><p>Note that we require two overloads for the function, one for the special case of no parameters, and another for a single-parameter function.</p></li>
				<li>Let's expand this to support two functions by adding another overload:<p class="source-code">function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;</p><p class="source-code">function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2?: UnaryFunction&lt;A, R&gt;) {</p><p class="source-code">  // TODO: Support two functions</p><p class="source-code">}</p><p>The previous implementation no longer works, since we need to support both a single function, as well as multiple functions, so we can no longer just return <strong class="source-inline">fn</strong>. We'll add a naïve implementation for now and expand it to a more generic solution in the next steps.</p></li>
				<li>The naïve implementation for supporting two functions is to simply check whether <strong class="source-inline">fn2</strong> is <strong class="source-inline">undefined</strong> – if it is, we only have a single function at hand, and can simply return <strong class="source-inline">fn1</strong>. Otherwise, we need to return a function that composes <strong class="source-inline">fn1</strong> and <strong class="source-inline">fn2</strong> on the given argument:<p class="source-code">function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;</p><p class="source-code">function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2?: UnaryFunction&lt;A, R&gt;) {</p><p class="source-code">  if (fn2 === undefined) {</p><p class="source-code">    return fn1;</p><p class="source-code">  }</p><p class="source-code">  return (arg: T) =&gt; {</p><p class="source-code">    return fn2(fn1(arg));</p><p class="source-code">  };</p><p class="source-code">}</p></li>
				<li>We can persist with the preceding approach, but it is tedious, and supporting more functions means changing the implementation. Instead, we can make the actual implementation accept an array of functions and reduce them, starting with <strong class="source-inline">arg</strong> as the initial value, and running the current function, <strong class="source-inline">fn</strong>, on the accumulator (the previous result). Let's do that, while still only supporting up to two functions:<p class="source-code">function pipe&lt;R&gt;(fn: UnaryFunction&lt;void, R&gt;): UnaryFunction&lt;void, R&gt;;</p><p class="source-code">function pipe&lt;T, R = T&gt;(fn: UnaryFunction&lt;T, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T, A, R&gt;(fn1: UnaryFunction&lt;T, A&gt;, fn2: UnaryFunction&lt;A, R&gt;): UnaryFunction&lt;T, R&gt;;</p><p class="source-code">function pipe&lt;T&gt;(...fns: UnaryFunction&lt;any, any&gt;[]): UnaryFunction&lt;any, any&gt; {</p><p class="source-code">  return (arg: T) =&gt; {</p><p class="source-code">    return fns.reduce((prev, fn) =&gt; fn(prev), arg);</p><p class="source-code">  };</p><p class="source-code">}</p></li>
				<li>Lastly, we can expand our support for more functions by only needing to change the function declaration by adding another overload with the correct type:<p>In the case of three functions:</p><p class="source-code">function pipe&lt;T, A, B, R&gt;(</p><p class="source-code">  fn1: UnaryFunction&lt;T, A&gt;,</p><p class="source-code">  fn2: UnaryFunction&lt;A, B&gt;,</p><p class="source-code">  fn3: UnaryFunction&lt;B, R&gt;,</p><p class="source-code">): UnaryFunction&lt;T, R&gt;;</p><p>In the case of four functions:</p><p class="source-code">function pipe&lt;T, A, B, C, R&gt;(</p><p class="source-code">  fn1: UnaryFunction&lt;T, A&gt;,</p><p class="source-code">  fn2: UnaryFunction&lt;A, B&gt;,</p><p class="source-code">  fn3: UnaryFunction&lt;B, C&gt;,</p><p class="source-code">  fn4: UnaryFunction&lt;C, R&gt;,</p><p class="source-code">): UnaryFunction&lt;T, R&gt;;</p><p> In the case of five functions:</p><p class="source-code">function pipe&lt;T, A, B, C, D, R&gt;(</p><p class="source-code">  fn1: UnaryFunction&lt;T, A&gt;,</p><p class="source-code">  fn2: UnaryFunction&lt;A, B&gt;,</p><p class="source-code">  fn3: UnaryFunction&lt;B, C&gt;,</p><p class="source-code">  fn4: UnaryFunction&lt;C, D&gt;,</p><p class="source-code">  fn5: UnaryFunction&lt;D, R&gt;,</p><p class="source-code">): UnaryFunction&lt;T, R&gt;;</p><p>In each overload, we have the first generic as <strong class="source-inline">T</strong> – this is the type of argument that the returned function will have, and <strong class="source-inline">R</strong> – the return type of the returned function. Between them we have <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, <strong class="source-inline">C, </strong>and so on, as the interim return type/argument type of the second…second to last functions. For all the preceding steps, make sure to export the functions by adding <strong class="source-inline">export</strong> before the <strong class="source-inline">function</strong> keyword.</p><p>Finally, we can use our <strong class="source-inline">pipe</strong> function to compose any functions we want, while staying completely type-safe:</p><p class="source-code">const composedFn = pipe(</p><p class="source-code">  (x: string) =&gt; x.toUpperCase(),</p><p class="source-code">  x =&gt; [x, x].join(','),</p><p class="source-code">  x =&gt; x.length,</p><p class="source-code">  x =&gt; x.toString(),</p><p class="source-code">  x =&gt; Number(x),</p><p class="source-code">);</p><p class="source-code">console.log('result is:', composedFn('hello'))</p><p>Running the this code should result in the following output:</p><p class="source-code">result is: 11</p></li>
			</ol>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor440"/>12. Guide to Promises in TypeScript</h1>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor441"/><a id="_idTextAnchor442"/>Activity 12.01: Building a Promise App </h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">We can get started the same way we started building our API from the sample from GitHub:<p class="source-code">npm i</p><p>The only dependencies we're using here are <strong class="source-inline">http-server</strong> to power our web application and <strong class="source-inline">typescript</strong> to transpile our code. Now that our project is set up, let's quickly create an <strong class="source-inline">index.html</strong> file:</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;title&gt;The TypeScript Workshop - Activity 12.1&lt;/title&gt;</p><p class="source-code">    &lt;link href="styles.css" rel="stylesheet"&gt;&lt;/link&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;input type="text" placeholder="What promise will you make?" id="promise-input"&gt; &lt;button id="promise-save"&gt;save&lt;/button&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;table id="promise-table"&gt;&lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">  &lt;script type="module" src="app.js"&gt;&lt;/script&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>And then a <strong class="source-inline">styles.css</strong> file:<p class="source-code">body {</p><p class="source-code">  font-family: Arial, Helvetica, sans-serif;</p><p class="source-code">  font-size: 12px;</p><p class="source-code">}</p><p class="source-code">input {</p><p class="source-code">  width: 200;</p><p class="source-code">}</p><p class="source-code">table {</p><p class="source-code">  border: 1px solid;</p><p class="source-code">}</p><p class="source-code">td {</p><p class="source-code">  overflow: hidden;</p><p class="source-code">  white-space: nowrap;</p><p class="source-code">  text-overflow: ellipsis;</p><p class="source-code">}</p><p>Now we will create an <strong class="source-inline">app.ts</strong> file and create a very rough client library that implements a <strong class="source-inline">fetch</strong> abstraction similar to what we created in <em class="italic">Chapter 3, Functions</em>. Because TypeScript doesn't run natively in a web browser, we will need to use <strong class="source-inline">tsc</strong> to transpile our TypeScript code into JavaScript. There are some advanced tools such as webpack and Parcel that can help with this, but those are out of scope for this chapter so we will keep this simple and just use a single <strong class="source-inline">app.ts</strong> file.</p></li>
				<li>We'll use our <strong class="source-inline">PromiseModel</strong> interface again in our web app and create a <strong class="source-inline">fetchClient</strong> function using currying:<p class="source-code">interface PromiseModel {</p><p class="source-code">  id?: number;</p><p class="source-code">  desc: string;</p><p class="source-code">}</p><p class="source-code">const fetchClient = (url: string) =&gt; (resource: string) =&gt; (method: string) =&gt; (</p><p class="source-code">  body?: PromiseModel</p><p class="source-code">) =&gt; {</p><p class="source-code">  return fetch(`${url}/${resource}`, {</p><p class="source-code">    body: body &amp;&amp; JSON.stringify(body),</p><p class="source-code">    headers: { "Content-Type": "application/json" },</p><p class="source-code">    method,</p><p class="source-code">  });</p><p class="source-code">};</p></li>
				<li>Building on the model of curried <strong class="source-inline">fetch</strong> functions, let's create some resources:<p class="source-code">const api = fetchClient("http://localhost:3000");</p><p class="source-code">const resource = api("promise");</p><p class="source-code">const getAction = resource("get");</p><p class="source-code">const postAction = resource("post");</p></li>
				<li>These functions handle invoking the resources and updating page elements:<p class="source-code">const deleteItem = (id: number) =&gt; {</p><p class="source-code">  const resource = api(`promise/${id}`);</p><p class="source-code">  resource("delete")().then(loadItems);</p><p class="source-code">};</p><p class="source-code">const loadItems = () =&gt; {</p><p class="source-code">  getAction().then((res) =&gt; res.json().then(renderList));</p><p class="source-code">};</p><p class="source-code">const saveItem = () =&gt; {</p><p class="source-code">  const input = document.getElementById("promise-input") as HTMLInputElement;</p><p class="source-code">  if (input.value) {</p><p class="source-code">    postAction({ desc: input.value }).then(loadItems);</p><p class="source-code">    input.value = "";</p><p class="source-code">  }</p><p class="source-code">};</p></li>
				<li>Finally, we'll do some ugly HTML manipulation to update the UI:<p class="source-code">const renderList = (data: PromiseModel[]) =&gt; {</p><p class="source-code">  const table = document.getElementById("promise-table");</p><p class="source-code">  if (table) {</p><p class="source-code">    table.innerHTML = "";</p><p class="source-code">    let tr = document.createElement("tr");</p><p class="source-code">    ["Promise", "Delete"].forEach((label) =&gt; {</p><p class="source-code">      const th = document.createElement("th");</p><p class="source-code">      th.innerText = label;</p><p class="source-code">      tr.appendChild(th);</p><p class="source-code">    });</p><p class="source-code">    table.appendChild(tr);</p><p class="source-code">    data.forEach((el) =&gt; {</p><p class="source-code">      table.appendChild(renderRow(el));</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">const renderRow = (el: PromiseModel) =&gt; {</p><p class="source-code">  const tr = document.createElement("tr");</p><p class="source-code">  const td1 = document.createElement("td");</p><p class="source-code">  td1.innerHTML = el.desc;</p><p class="source-code">  tr.appendChild(td1);</p><p class="source-code">  const td2 = document.createElement("td");</p><p class="source-code">  const deleteButton = document.createElement("button");</p><p class="source-code">  deleteButton.innerText = "delete";</p><p class="source-code">  deleteButton.onclick = () =&gt; deleteItem(el.id!);</p><p class="source-code">  td2.appendChild(deleteButton);</p><p class="source-code">  tr.appendChild(td2);</p><p class="source-code">  return tr;</p><p class="source-code">};</p><p class="source-code">document.getElementById("promise-save")?.addEventListener("click", saveItem);</p><p class="source-code">loadItems();</p></li>
				<li>Altogether, the <strong class="source-inline">app.ts</strong> file looks like this:<p class="source-code">interface PromiseModel {</p><p class="source-code">  id?: number;</p><p class="source-code">  desc: string;</p><p class="source-code">}</p><p class="source-code">const fetchClient = (url: string) =&gt; (resource: string) =&gt; (method: string) =&gt; (</p><p class="source-code">  body?: PromiseModel</p><p class="source-code">) =&gt; {</p><p class="source-code">  return fetch(`${url}/${resource}`, {</p><p class="source-code">    body: body &amp;&amp; JSON.stringify(body),</p><p class="source-code">    headers: { "Content-Type": "application/json" },</p><p class="source-code">    method,</p><p class="source-code">  });</p><p class="source-code">};</p><p class="source-code">const api = fetchClient("http://localhost:3000");</p><p class="source-code">const resource = api("promise");</p><p class="source-code">const getAction = resource("get");</p><p class="source-code">const postAction = resource("post");</p><p class="source-code">const deleteItem = (id: number) =&gt; {</p><p class="source-code">  const resource = api(`promise/${id}`);</p><p class="source-code">  resource("delete")().then(loadItems);</p><p class="source-code">};</p><p class="source-code">const loadItems = () =&gt; {</p><p class="source-code">  getAction().then((res) =&gt; res.json().then(renderList));</p><p class="source-code">};</p><p class="source-code">const saveItem = () =&gt; {</p><p class="source-code">  const input = document.getElementById("promise-input") as HTMLInputElement;</p><p class="source-code">  if (input.value) {</p><p class="source-code">    postAction({ desc: input.value }).then(loadItems);</p><p class="source-code">    input.value = "";</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">const renderList = (data: PromiseModel[]) =&gt; {</p><p class="source-code">  const table = document.getElementById("promise-table");</p><p class="source-code">  if (table) {</p><p class="source-code">    table.innerHTML = "";</p><p class="source-code">    let tr = document.createElement("tr");</p><p class="source-code">    ["Promise", "Delete"].forEach((label) =&gt; {</p><p class="source-code">      const th = document.createElement("th");</p><p class="source-code">      th.innerText = label;</p><p class="source-code">      tr.appendChild(th);</p><p class="source-code">    });</p><p class="source-code">    table.appendChild(tr);</p><p class="source-code">    data.forEach((el) =&gt; {</p><p class="source-code">      table.appendChild(renderRow(el));</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">const renderRow = (el: PromiseModel) =&gt; {</p><p class="source-code">  const tr = document.createElement("tr");</p><p class="source-code">  const td1 = document.createElement("td");</p><p class="source-code">  td1.innerHTML = el.desc;</p><p class="source-code">  tr.appendChild(td1);</p><p class="source-code">  const td2 = document.createElement("td");</p><p class="source-code">  const deleteButton = document.createElement("button");</p><p class="source-code">  deleteButton.innerText = "delete";</p><p class="source-code">  deleteButton.onclick = () =&gt; deleteItem(el.id!);</p><p class="source-code">  td2.appendChild(deleteButton);</p><p class="source-code">  tr.appendChild(td2);</p><p class="source-code">  return tr;</p><p class="source-code">};</p><p class="source-code">document.getElementById("promise-save")?.addEventListener("click", saveItem);</p><p class="source-code">loadItems();</p><p>It's not hard to see why view frameworks are popular; however, this should do the trick for putting together a full-stack application. </p></li>
				<li>Now let's compile and run our web application. In one Command Prompt window, enter the following: <p class="source-code">npx tsc -w. </p><p>This will transpile the TypeScript code in watch mode so that it restarts when changes are made. </p></li>
				<li>Start the HTTP server in another window with <strong class="source-inline">npx http-server . -c-1</strong> as we did in <em class="italic">Exercise 12.03, Promise.allSettled</em>.<p> Now navigate a web browser to <strong class="source-inline">http://localhost:8080/</strong>. You should see a form like the one that follows:  </p><div id="_idContainer185" class="IMG---Figure"><img src="image/B14508_12_10.jpg" alt="Figure 12.10: Initial load&#13;&#10;"/></div><p class="figure-caption">Figure 12.10: Initial load</p><p class="callout-heading">Note</p><p class="callout">If you don't see "Promise Delete" then it could be that your API from Exercise 6, Implementing a RESTful API backed by sqlite isn't running. Return to that exercise and follow the steps there.</p><p>You can add and delete promises. Here are some examples:</p></li>
				<li>Add the promise <strong class="source-inline">Always lint my code</strong> and save it. You should see the following:<div id="_idContainer186" class="IMG---Figure"><img src="image/B14508_12_11.jpg" alt="Figure 12.11: One promise made&#13;&#10;"/></div><p class="figure-caption">Figure 12.11: One promise made</p></li>
				<li>Add the promise <strong class="source-inline">Never block the event loop</strong> and save it: <div id="_idContainer187" class="IMG---Figure"><img src="image/B14508_12_12.jpg" alt="Figure 12.12: Text entered&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.12: Text entered</p>
			<p>You should see the following promise saved:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B14508_12_13.jpg" alt="Figure 12.13: Text saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: Text saved</p>
			<p><em class="italic">Figure 12.14</em> and <em class="italic">Figure 12.15</em> show some more examples:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B14508_12_14.jpg" alt="Figure 12.14: Another promise saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: Another promise saved</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B14508_12_15.jpg" alt="Figure 12.15: Another promise saved&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.15: Another promise saved</p>
			<p>Try to add to the application and make use of the API to get a single promise or update promises. </p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor443"/>13. Async/Await in TypeScript</h1>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor444"/><a id="_idTextAnchor445"/>Activity 13.01: Refactoring Chained Promises to Use await</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Let's go over what needed to change in order to make this work:</p>
			<ol>
				<li value="1">First of all, the <strong class="source-inline">await</strong> keyword can only be used inside an <strong class="source-inline">async</strong> function, so we must add that keyword to the function declaration:<p class="source-code">const renderAll = async () =&gt; {</p></li>
				<li>Now we have to replace <strong class="source-inline">then</strong> with <strong class="source-inline">await</strong>. Let's look again at what the <strong class="source-inline">render</strong> function does. In our simple case, it just returns a promise that resolves to a string, but in the real world, it would render something in a web browser and then resolve to a string. Since we want to log out that string, we can actually resolve the promise inside a <strong class="source-inline">console.log</strong> statement. Even though <strong class="source-inline">console.log</strong> is a synchronous operation, putting <strong class="source-inline">await</strong> inside it will cause the function to print out the resolved promise value, exactly as we would hope.<p>The refactored program is six lines shorter and eliminates nesting:</p><p class="source-code">export class El {</p><p class="source-code">  constructor(private name: string) {}</p><p class="source-code">  render = () =&gt; {</p><p class="source-code">    return new Promise((resolve) =&gt;</p><p class="source-code">      setTimeout(</p><p class="source-code">        () =&gt; resolve(`${this.name} is resolved`),</p><p class="source-code">        Math.random() * 1000</p><p class="source-code">      )</p><p class="source-code">    );</p><p class="source-code">  };</p><p class="source-code">}</p><p class="source-code">const e1 = new El('header');</p><p class="source-code">const e2 = new El('body');</p><p class="source-code">const e3 = new El('footer');</p><p class="source-code">const renderAll = async () =&gt; {</p><p class="source-code">  console.log(await e1.render());</p><p class="source-code">  console.log(await e2.render());</p><p class="source-code">  console.log(await e3.render());</p><p class="source-code">};</p><p class="source-code">renderAll();</p></li>
				<li>Run the file using <strong class="source-inline">npx</strong> <strong class="source-inline">ts-node</strong> <strong class="source-inline">refactor.ts</strong>. You should get the following output:<p class="source-code">header is resolved</p><p class="source-code">body is resolved</p><p class="source-code">footer is resolved</p></li>
			</ol>
			<h1 id="_idParaDest-364"><a id="_idTextAnchor446"/>14. TypeScript and React</h1>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor447"/><a id="_idTextAnchor448"/>Activity 14.01: The Blog</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new React application as outlined earlier in this chapter.</li>
				<li>Prepare a Firestore database with authentication on Firebase as outlined in <em class="italic">Exercise 14.04, Getting Started with Firebase</em>.</li>
				<li>Install the Firebase client with <strong class="source-inline">npm i firebase</strong>. Firebase includes typings so we won't need to install those separately.</li>
				<li>Create a directory called <strong class="source-inline">services</strong> under <strong class="source-inline">src</strong> and a file called <strong class="source-inline">firebase.ts</strong> there. The Firebase integration can be pretty basic:<p class="source-code">import firebase from 'firebase';const config = {  apiKey: 'abc123',  authDomain: 'blog-xxx.firebaseapp.com',  projectId: 'https://blog-xxx.firebaseio.com',  storageBucket: 'blog-xxx.appspot.com',  messagingSenderId: '999',  appId: '1:123:web:123abc',};firebase.initializeApp(config);export const auth = firebase.auth();export const db = firebase.firestore();</p></li>
				<li>Make sure to use the values from the Firebase dashboard. This will expose Firebase's authentication and database capabilities to the rest of your application.</li>
				<li>Set up two providers under <strong class="source-inline">src/providers</strong> called <strong class="source-inline">StoriesProvider.ts</strong> and <strong class="source-inline">UserProvider.ts</strong>. Now, <strong class="source-inline">UserProvider.ts</strong> will be simpler, so let's do that one first. Like <em class="italic">Exercise 14.03</em>, <em class="italic">React Context</em>, we'll employ <strong class="source-inline">createContext</strong> and <strong class="source-inline">useState</strong>, but we'll also need <strong class="source-inline">useEffect</strong>:<p class="source-code">import firebase from 'firebase';</p><p class="source-code">import React, { createContext, ReactNode, useEffect, useState } from 'react';</p><p class="source-code">import { auth } from '../services/firebase';</p><p class="source-code">interface ContextProps {</p><p class="source-code">  children: ReactNode;</p><p class="source-code">}</p><p class="source-code">export const UserContext = createContext&lt;Partial&lt;firebase.User | undefined&gt;&gt;(</p><p class="source-code">  {}</p><p class="source-code">);</p><p class="source-code">export const UserProvider = (props: ContextProps) =&gt; {</p><p class="source-code">  const [user, setUser] = useState&lt;firebase.User&gt;();</p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    auth.onAuthStateChanged((userAuth) =&gt; {</p><p class="source-code">      setUser(userAuth ?? undefined);</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  return (</p><p class="source-code">    &lt;UserContext.Provider value={user}&gt;{props.children}&lt;/UserContext.Provider&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
				<li><strong class="source-inline">StoriesProvider.ts</strong> is responsible for persisting stories (the blog links) and comments on the stories. To make this work, start by creating interfaces for comments and stories. Comments should belong to stories. Here's a sample of how that could be done:<p class="source-code">export interface CommentModel {  comment: string;  timestamp: number;  user: string;}export interface StoryModel {  comments: CommentModel[];  id: string;  link: string;  title: string;  user: string;}</p><p>With those interfaces created, we need to implement some methods in our provider, namely methods for adding comments and stories as well as a method that will fetch all the stories. To do that, we'll need to access a collection in our database. This can be done with a single line of code:</p><p class="source-code">const storiesDB = db.collection('stories');</p><p>This code will create the collection if it doesn't exist. The <strong class="source-inline">storiesDB</strong> object we created has methods for fetching, adding, and updating documents from the collection. With those methods implemented, we add our stories data and the methods that handle the data to our provider value. This means that components that use <strong class="source-inline">StoriesContext</strong> will be able to call those methods or access that data.</p><p>Again, the solution to this somewhat complicated provider is available on GitHub.</p></li>
				<li>Raw document data is a bit difficult to work with, but Firebase has the concept of a converter that we can create, which will tell it how to map document fields to our TypeScript objects. Create and export a converter implementing the <strong class="source-inline">fromFirestore</strong> and <strong class="source-inline">toFirestore</strong> methods. Using those should eliminate some type errors and avoid us needing to use <strong class="source-inline">any</strong>.</li>
				<li>Install React Router (<strong class="source-inline">react-dom</strong> and <strong class="source-inline">react-router-dom</strong>). Set the default route to a home page. Then, create <strong class="source-inline">Add</strong>, <strong class="source-inline">Signin</strong>, and <strong class="source-inline">Signup</strong> pages. Put the pages under <strong class="source-inline">src/pages</strong>. Just put some text on them in a basic function component to verify routing is working as expected.</li>
				<li>Build out the <strong class="source-inline">Signup</strong> page first as it's hard to sign in without having signed up. Now we'll use Material-UI. Install <strong class="source-inline">@material-ui/core</strong> and <strong class="source-inline">@material-ui/icons</strong> and we can start building components.</li>
				<li>Our <strong class="source-inline">Signup</strong> page can be created using <strong class="source-inline">Container</strong>, <strong class="source-inline">TextField</strong>, and <strong class="source-inline">Button</strong>, which are all available components in Material-UI. How your page ultimately looks is up to you, but you will need two <strong class="source-inline">TextField</strong> components. One of those should have both a <strong class="source-inline">type</strong> and <strong class="source-inline">name</strong> of <strong class="source-inline">"email"</strong> and the other should have <strong class="source-inline">"password"</strong> for both of those props.<p>We'll track the state of both the email and password fields using <strong class="source-inline">useState</strong> and an <strong class="source-inline">onChange</strong> event.</p><p>When the button is clicked, we should call a method on the <strong class="source-inline">auth</strong> object we exported from our Firebase service earlier to create a new user using the given email address and password.</p></li>
				<li>Upon successfully signing in, let's send the user back to the home page with the <strong class="source-inline">useHistory</strong> React Hook.</li>
				<li>The <strong class="source-inline">Signin</strong> page will be a lot like the <strong class="source-inline">Signup</strong> page. It also needs to capture the user's email address and password and have a button to submit the form. This time we should call a method on <strong class="source-inline">auth</strong> to sign the user in via an email and password.</li>
				<li>Our <strong class="source-inline">Add</strong> page creates new posts to the blog. We'll capture the title of the post and a link. Add additional fields if you like. This will work similarly to the prior two pages, but now we will use <strong class="source-inline">StoriesContext</strong> instead of <strong class="source-inline">UserContext</strong> to expose the method to add stories.</li>
				<li>For the home page, we can just load up all the stories and display them as a Material-UI <strong class="source-inline">List</strong>. It's possible to just output the <strong class="source-inline">story</strong> object and wrap it in HTML tags to make it look presentable, but a better solution is to create a <strong class="source-inline">Story</strong> component that can better encapsulate the object. Add a <strong class="source-inline">Story</strong> component to <strong class="source-inline">src/components</strong> and use that for your story display.</li>
				<li>To manage comments, each story should have its own comments. It's a good idea to create this as a separate component that each story will contain. The <strong class="source-inline">Comments</strong> component can contain a list of each individual comments (another component!) as well as controls for grabbing that method to add comments from <strong class="source-inline">StoriesContext</strong>.</li>
				<li>At this point, everything is working quite well, but we should add some navigation elements so users don't have to key in the different routes. We can use the <strong class="source-inline">AppBar</strong>, <strong class="source-inline">Toolbar</strong>, <strong class="source-inline">Menu</strong>, <strong class="source-inline">MenuItem</strong>, and <strong class="source-inline">Button</strong> components from Material-UI to create some attractive navigation options. Navigation itself can be performed via the <strong class="source-inline">useHistory</strong> React Hook.</li>
			</ol>
		</div>
		<div>
			<div id="_idContainer192" class="Content">
			</div>
		</div>
	

		<div>
			<div id="_idContainer193">
				<img src="image/Author_Page1.png" alt=""/>
			</div>
		</div>
		<div>
			<div id="_idContainer194" class="Content">
			</div>
		</div>
		<div id="_idContainer196" class="Content">
			<h2 id="_idParaDest-366">Hey!</h2>
			<p>We're Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski, the authors of this book. We really hope you enjoyed reading our book and found it useful for learning TypeScript.</p>
			<p>It would really help us (and other potential readers!) if you could leave a review on Amazon sharing your thoughts on <em class="italic">The TypeScript Workshop</em>.</p>
			<p>Go to the link <a href="">https://packt.link/r/1838828494</a>.</p>
			<p>OR</p>
			<p>Scan the QR code to leave your review.</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/qr-code-https___packt.link_r_1838828494.jpg" alt="Barcode"/>
				</div>
			</div>
			<p>Your review will help us to understand what's worked well in this book and what could be improved upon for future editions, so it really is appreciated.</p>
			<p>Best wishes,</p>
			<p>Ben Grynhaus, Jordan Hudgens, Rayon Hunte, Matt Morgan, and Wekoslav Stefanovski</p>
		</div>
		<div>
			<div id="_idContainer197">
				<img src="image/Packt_Logo.png" alt="Packt Logo"/>
			</div>
		</div>
	</body></html>