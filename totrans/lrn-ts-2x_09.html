<html><head></head><body><div><h1 class="header-title">Automating Your Development Workflow</h1>
                
            
            
                
<p>In the previous chapters, we learned about the main elements of the TypeScript syntax and the main features of its type system. Over the next few chapters, we will focus on the TypeScript tools and other elements of its ecosystem.</p>
<p>In this chapter, we are going to learn how to use some tools to automate our development workflow. These tools will help us to reduce the amount of time that we usually spend in some trivial and repetitive tasks.</p>
<p>In this chapter, we will learn about the following topics:</p>
<ul>
<li>Source control tools</li>
<li>Package management tools</li>
<li>Task runners</li>
<li>Module bundlers</li>
<li>Test automation and test coverage</li>
<li>Integration tools</li>
<li>Scaffolding tools</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">A modern development workflow</h1>
                
            
            
                
<p>Developing a web application with high-quality standards has become a time-consuming activity. If we want to achieve a great user experience, we will need to ensure that our applications can run as smoothly as possible on many different web browsers, devices, internet connection speeds, and screen resolutions. Furthermore, we will need to spend a lot of our time working on quality assurance and performance optimization tasks.</p>
<p>As software engineers, we should try to minimize the time we spend on trivial and repetitive tasks. This might sound familiar as we have been doing this for years. We started by writing build scripts (such as makefiles) or automated tests and today, in a modern web development workflow, we use many tools to literally try to automate as many tasks as we can. These tools can be categorized into the following groups:</p>
<ul>
<li>Source control tools</li>
<li>Package managers tools</li>
<li>Task runners</li>
<li>Module bundlers</li>
<li>Test runners</li>
<li>Continuous integration (CI) tools</li>
<li>Scaffolding tools</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Prerequisites</h1>
                
            
            
                
<p>We are about to learn how to automate many tasks in our development workflow; however, before that, we need to install a few tools in our development environment.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Node.js</h1>
                
            
            
                
<p>Node.js is a platform built on V8 (Google's open source JavaScript engine). Node.js allows us to run JavaScript outside a web browser. We can write backend and desktop applications using TypeScript and Node.js.</p>
<p>Even if we are planning to write backend applications, we are going to need Node.js because many of the tools used in this chapter are Node.js applications.</p>
<p>If you didn't install Node.js in the previous chapters, you could visit <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> to download the installer for your operating system.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Visual Studio Code</h1>
                
            
            
                
<p>Visual Studio Code is an open source editor developed by Microsoft. The open source community around this editor is really active and has developed many plugins and themes. We can download Visual Studio Code from <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a>.</p>
<p>We can additionally visit the Visual Studio extensions panel (the fifth icon on the left-hand side of the screen) to browse and install an extension or theme.</p>
<p>Visual Studio Code is open source, and it is available for Linux, OS X, and Windows, so it will suit most readers. If you want to work with Visual Studio, you will be able to find the extension to enable TypeScript support in Visual Studio at <a href="https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304">https://visualstudiogallery.msdn.microsoft.com/2d42d8dc-e085-45eb-a30b-3f7d50d55304</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Git and GitHub</h1>
                
            
            
                
<p>Toward the end of this chapter, we will learn how to configure a CI service. The CI service will observe changes in our application's code and ensure that the changes don't break the application.</p>
<p>To be able to observe the changes in the code, we will need to use a source control system. There are a few source control systems available. Some of the most widely used ones are Subversion, Mercurial, and Git.</p>
<p>Source control systems have many benefits, among which we can highlight the following:</p>
<ul>
<li>Source control tools enable multiple developers to work on a source file without any work being potentially lost by one developer overriding previous changes.</li>
<li>Source control tools allow us to track and audit the changes in our source code. These features can be really useful, for example, when trying to find out when a new bug was introduced.</li>
</ul>
<p>While working through the examples in this chapter, we will perform some changes to the source code. We will use Git and GitHub to manage these changes.</p>
<p>We need to visit <a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a> to download the Git installer. We can then visit <a href="https://github.com/">https://github.com/</a> to create a GitHub account.</p>
<p>A GitHub account will offer a few different subscription plans. The free plan offers everything we need to follow the examples in this book.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Companion source code</h1>
                
            
            
                
<p>The companion source code for this book can be found online at <a href="https://github.com/remojansen/LearningTypeScript">https://github.com/remojansen/LearningTypeScript</a>. The source code for this chapter includes a small example with the following directory architecture:</p>
<div><img class="alignnone size-full wp-image-210 image-border" src="img/97401c5f-091d-40c0-aef8-1e02b83331a1.png" style="width:16.25em;height:26.67em;" width="289" height="474"/></div>
<p>There are two main files, named <kbd>main_server.ts</kbd> and <kbd>main_browser.ts</kbd>. Both files are located under the <kbd>src</kbd> directory. These files create an instance of a class named <kbd>Calculator</kbd> and use it to perform some operations. The result of the operations is logged in the console:</p>
<pre>import chalk from "chalk"; 
import { Calculator } from "./calculator"; 
 
const calculator = new Calculator(); 
 
const addResult = calculator.calculate("add", 2, 3); 
console.log(chalk.green(`2 + 3 = ${addResult}`)); 
 
const powResult = calculator.calculate("pow", 2, 3); 
console.log(chalk.green(`2 + 3 = ${powResult}`)); </pre>
<p>The <kbd>main_browser.ts</kbd> file displays the results inside an HTML element instead of displaying them in the console. The <kbd>main_browser.ts</kbd> file also imports a <kbd>.scss</kbd> file to demonstrate how we can work with <kbd>.css</kbd> and <kbd>.scss</kbd> files,  with Webpack.</p>
<p>The <kbd>Calculator</kbd> class can perform different kinds of mathematical operations and is defined in the <kbd>calculator.ts</kbd> file, which is located under the <kbd>src</kbd> directory:</p>
<pre>import { add } from "./operations/add"; 
import { pow } from "./operations/pow"; 
 
interface Operation { 
    name: string; 
    operation(a: number, b: number): number; 
} 
 
export class Calculator { 
    private readonly _operations: Operation[]; 
    public constructor() { 
        this._operations = [ 
            { name: "add", operation: add }, 
            { name: "pow", operation: pow } 
        ]; 
    } 
    public calculate(operation: string, a: number, b: number) { 
        const opt = this._operations.filter((o) =&gt; o.name === operation)[0]; 
        if (opt === undefined) { 
            throw new Error(`The operation ${operation} is not available!`); 
        } else { 
            return opt.operation(a, b); 
        } 
    } 
} </pre>
<p>The <kbd>Calculator</kbd> class can only perform two operations. Each operation is defined on its own file under the <kbd>operations</kbd> directory. The <kbd>add</kbd> operation is defined in the <kbd>add.ts</kbd> file and looks as follows:</p>
<pre>import { isNumber } from "./validation"; 
 
export function add(a: number, b: number) { 
    isNumber(a); 
    isNumber(b); 
    return a + b; 
} </pre>
<p>The <kbd>pow</kbd> operation is defined in the <kbd>pow.ts</kbd> file and looks as follows:</p>
<pre>import { isNumber } from "./validation"; 
 
export function pow(base: number, exponent: number) { 
    isNumber(base); 
    isNumber(exponent); 
    let result = base; 
    for (let i = 1; i &lt; exponent; i++) { 
        result = result * base; 
    } 
    return result; 
} </pre>
<p>Finally, the <kbd>isNumber</kbd> validation function looks as follows:</p>
<pre>export function isNumber(a: number) { 
    if (typeof a !== "number") { 
        throw new Error(`${a} must be a number!`); 
    } 
} </pre>
<p>We are going to use these files during the rest of this chapter, which means that we might need to come back to them later to fully understand the rest of the contents of this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Source control tools</h1>
                
            
            
                
<p>Now that we have installed Git and created a GitHub account, we will use GitHub to create a new code repository. A repository is a central file storage location. It is used by the source control systems to store multiple versions of files. While a repository can be configured on a local machine for a single user, it is often stored on a server, which can be accessed by multiple users.</p>
<p>To create a new repository on GitHub, log in to your GitHub account and click on the link to create a new repository, which you can find in the top-right corner of the screen:</p>
<div><img class="alignnone size-full wp-image-211 image-border" src="img/64ea8ec7-7154-4125-9e0d-4f5c45ec2b78.png" style="width:150.50em;height:22.33em;" width="1806" height="268"/></div>
<p>A form similar to the one in the following screenshot will then be displayed on screen:</p>
<div><img class="alignnone size-full wp-image-212 image-border" src="img/a239ba06-7171-4c13-9c3b-3126909fb8d4.png" style="width:144.50em;height:90.75em;" width="1734" height="1089"/></div>
<p>This form contains some fields that allow us to set the repository's name, description, and some privacy settings.</p>
<p>Please note that you will need a paid GitHub account if you want to use a private repository.</p>
<p>We can also add a <kbd>README.md</kbd> file, which uses markdown syntax and is used to add whatever text we want to the repository home page on GitHub. Furthermore, we can add a default <kbd>.gitignore</kbd> file, which is used to specify files that we would like to be ignored by Git and therefore not be saved into the repository.</p>
<p>The recommended option for the default <kbd>.gitignore</kbd> file is <kbd>Node</kbd>. We will use GitHub throughout this book. However, if you want to use a local repository, you can use the Git <kbd>init</kbd> command to create an empty repository. Refer to the Git documentation at <a href="http://git-scm.com/docs/git-init">http://git-scm.com/docs/git-init</a> to learn more about the <kbd>git init</kbd> command and working with a local repository.<br/></p>
<p>Last, but not less important, we can also select a software license to cover our source code.</p>
<p>Once we have created the repository, we will visit our profile page on GitHub, find the repository that we have just created, and visit it. In the repository's home page, we will be able to find the clone URL in the top-right corner of the page:</p>
<div><img class="alignnone size-full wp-image-214 image-border" src="img/32bb99ac-aa20-4a23-b183-eb6f53c0a427.png" style="width:41.33em;height:21.00em;" width="1170" height="594"/></div>
<p>clone URL</p>
<p>We need to copy the repository's clone URL, open a console, and use the URL as an argument of the following command:</p>
<pre><strong>git clone https://github.com/user-name/repository-name.git</strong> </pre>
<p>Sometimes the Windows <strong>command-line interface</strong> (<strong>CLI</strong>) is not able to find the Git and Node commands. The easiest way to get around this issue is to use the Git console (installed with Git) rather than using the Windows command line. If you want to use the Windows console, you will need to manually add the Git and Node installation paths to the Windows <kbd>PATH</kbd> environment variable. If you are working with OS X or Linux, the default CLI should work fine. Also, note that we will use the Unix path syntax in all the examples.<br/></p>
<p>The command's output should look similar to the following:</p>
<pre>    <strong>Cloning into 'repository-name'...</strong>
    <strong>remote: Counting objects: 3, done.</strong>
    <strong>remote: Compressing objects: 100% (3/3), done.</strong>
    <strong>remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0</strong>
    <strong>Unpacking objects: 100% (3/3), done.</strong>
    <strong>Checking connectivity... done.</strong></pre>
<p>We can then move into the repository's directory using the change directory command (<kbd>cd</kbd>) and use the <kbd>git status</kbd> command to check the local repository status. The command's output should look similar to the following:</p>
<pre>    <strong>cd repository-name</strong>
    <strong>git status</strong>
    <strong>On branch master</strong>
    <strong>Your branch is up-to-date with 'origin/master'.</strong>
    <strong>nothing to commit, working directory clean</strong>
  </pre>
<p>The <kbd>git status</kbd> command is telling us that there are no changes in our working directory. Let's open the repository folder in Visual Studio Code and create a new file called <kbd>gulpfile.js</kbd>. Now, run the <kbd>git status</kbd> command again, and we should see some new untracked files:</p>
<pre>    <strong>On branch master</strong>
    <strong>Your branch is up-to-date with 'origin/master'.</strong>
    
    <strong>Untracked files:</strong>
    <strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong>  gulpfile.js</strong>
    
    <strong>nothing added to commit but untracked files present (use "git add" to <br/> track)</strong>
  </pre>
<p>The project explorer in Visual Studio Code displays the files using a color code to help us to identify whether a file is new (green), has been removed (red), or has changed (yellow) since our last commit.</p>
<p>When we make some changes, such as adding a new file or changing an existing file, we need to execute the <kbd>git add</kbd> command to indicate that we want to add that change to a snapshot:</p>
<pre>    <strong>git add gulpfile.js</strong>
    <strong>git status</strong>
    <strong>On branch master</strong>
    <strong>Your branch is up-to-date with 'origin/master'.</strong>
    
    <strong>Changes to be committed:</strong>
    <strong>  (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
    <strong>  new file:   gulpfile.js</strong></pre>
<p>Now that we have staged the content we want to snapshot, we have to run the <kbd>git commit</kbd> command to actually record the snapshot. Recording a snapshot requires a commentary field, which can be provided using the <kbd>git commit</kbd> command together with the <kbd>-m</kbd> argument:</p>
<pre>    <strong>git commit -m "added the new gulpfile.js"</strong></pre>
<p>To run the preceding command you need to configure your GitHub email/username on the Terminal. You can use any one of the following commands to configure your GitHub account on the Terminal:<br/>
<kbd>git config --global user.email "you@example.com"</kbd><br/>
<kbd>git config --global user.name "Your Name"</kbd></p>
<p>If everything goes well, the command output should be similar to the following:</p>
<pre>    <strong>[master 2a62321] added the new file gulpfile.js</strong>
    <strong> 1 file changed, 1 insertions(+)</strong>
    <strong> create mode 100644 gulpfile.js</strong></pre>
<p>To share the commit with the other developers, we need to push our changes to the remote repository. We can do this by executing the <kbd>git push</kbd> command:</p>
<pre>    <strong>git push</strong>  </pre>
<p>The <kbd>git push</kbd> command will ask for our GitHub username and password and then send the changes to the remote repository. If we visit the repository's page on GitHub, we will be able to find the recently created file. We will return to GitHub later in this chapter to configure our CI server.</p>
<p>If we are working with a large team, we might encounter some file conflicts when attempting to push some changes to the remote repository. Resolving a file conflict is out of the scope of this book; however, if you need further information about Git, you will find an extensive user manual at <a href="https://www.kernel.org/pub/software/scm/git/docs/user-manual.html">https://www.kernel.org/pub/software/scm/git/docs/user-manual.html</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Package management tools</h1>
                
            
            
                
<p>Package management tools are used for dependency management, so that we no longer have to manually download and manage our application's dependencies. We are not going to cover package management tools in this chapter because we have already covered them in <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The TypeScript compiler</h1>
                
            
            
                
<p>Now that we have learned how to use <kbd>npm</kbd>, we can install TypeScript using the following command:</p>
<pre>    <strong>npm install typescript -g</strong></pre>
<p>The TypeScript compiler will then become available in our CLI as a command named <kbd>tsc</kbd>. We can check the version of TypeScript installed in our machine using the following command:</p>
<pre>    <strong>tsc -v</strong>  </pre>
<p>The TypeScript compiler accepts many more options. For example, we can use the <kbd>--target</kbd> or <kbd>-t</kbd> option to select which version of JavaScript we would like to target as the compilation output:</p>
<pre>    <strong>tsc --target es6</strong>  </pre>
<p>Alternatively, we can create a <kbd>tsconfig.json</kbd> file to set the desired compilation settings. We can also use the TypeScript compiler to autogenerate a <kbd>tsconfig.json</kbd> file with default settings using the following command:</p>
<pre>    <strong>tsc --init</strong>  </pre>
<p>After creating a <kbd>tsconfig.json</kbd> file, you can pass it to the TypeScript compiler using the <kbd>--project</kbd> or <kbd>-p</kbd> option:</p>
<pre>    <strong>tsc -p tsconfig.json</strong>  </pre>
<p>Please refer to the official TypeScript documentation at <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">https://www.typescriptlang.org/docs/handbook/compiler-options.html</a> if you wish to learn more about the available compilation options.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Unit testing and test coverage</h1>
                
            
            
                
<p>Unit testing refers to the practice of testing certain functions and areas (units) of our code. This gives us the ability to verify that our functions work as expected.</p>
<p>It is expected that the reader will have some understanding of the unit test process, but the contents exposed here will be covered at a much higher level of detail in <a href="e365ca9e-d510-4127-a701-959ad8e2626f.xhtml">Chapter 14</a>, <em>Application Testing</em>.</p>
<p>At the beginning of this chapter, we included the most important parts of the application included in the companion source code for this chapter. The source code defined a calculator with support for two operations: <kbd>pow</kbd> and <kbd>add</kbd>.</p>
<p>The <kbd>pow</kbd> operation expects two numbers as its arguments and has two possible execution paths:</p>
<ul>
<li>The <kbd>pow</kbd> function will throw an exception if one of the two arguments provided is not a number</li>
<li>The <kbd>pow</kbd> function will return a number if both arguments are valid numbers</li>
</ul>
<p>Ideally, we will write a unit test of each of the execution paths of our function.</p>
<p>The following code snippet declares a couple of unit tests for the <kbd>pow</kbd> operation using two testing libraries, <kbd>mocha</kbd> and <kbd>chai</kbd>:</p>
<pre>import { expect } from "chai"; 
import { pow } from "../src/operations/pow"; 
 
describe("Operation: pow", () =&gt; { 
 
    it ("Should be able to calculate operation", () =&gt; { 
        const result = pow(2, 3); 
        expect(result).to.eql(8); 
    }); 
 
    it ("Should throw if an invalid argument is provided", () =&gt; { 
        const a: any = "2"; 
        const b: any = 3; 
        const throws = () =&gt; pow(a, b); 
        expect(throws).to.throw(); 
    }); 
 
}); </pre>
<p>The preceding code snippet groups all the tests related to the <kbd>pow</kbd> operation in what is known as a <strong>test fixture</strong>. A test fixture can be defined using the <kbd>describe</kbd> function and is just a group of test cases. A test case can be defined using the <kbd>it</kbd> functions and can contain one or more test assertions.</p>
<p>Our test assertions are defined using the <kbd>assert</kbd> function, which is part of the Chai library.</p>
<p>Both the <kbd>describe</kbd> and the <kbd>it</kbd> functions are global functions declared by Mocha. We don’t need to import <kbd>Mocha</kbd> because it is imported as a global by our test runner configuration.</p>
<p>We can run the tests and generate a test coverage report using the following command:</p>
<pre>    <strong>nyc -x **/*.js --clean --all --require ts-node/register --extension .ts -- mocha --timeout 5000 **/*.test.ts</strong>
  </pre>
<p>The preceding command uses <kbd>nyc</kbd>, which is a tool used to generate test coverage reports. This tool uses <kbd>ts-node</kbd> and <kbd>mocha</kbd> to run the tests. This explains why we can run the test without compiling them and why we can use Mocha without importing it explicitly.</p>
<p>This command is not very convenient, but we can declare an <kbd>npm</kbd> command to solve this problem:</p>
<pre>"scripts": { 
  "nyc": "nyc -x **/*.js --clean --all --require ts-node/register --extension .ts -- mocha --timeout 5000 **/*.test.ts" 
} </pre>
<p>Please note that we need to install all these dependencies and their type definitions (when appropriate) using npm. We can then use the following npm command instead:</p>
<pre>    <strong>npm run nyc</strong>  </pre>
<p>The companion source code includes many more tests. The existing tests cover most of the possible execution paths of all the existing functions in the application but don't fully cover the <kbd>main_server.ts</kbd> file. This can be observed in the test coverage report generated by <kbd>nyc</kbd>:</p>
<div><img style="font-size: 1em;width:50.67em;height:46.75em;" class="alignnone size-full wp-image-216 image-border" src="img/a7835ccc-7b03-401d-ba39-c7fe34f9fef0.png" width="1186" height="1094"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Linting tools</h1>
                
            
            
                
<p>The following tool is a code linting tool. A linting tool helps us to enforce certain code styling rules in our code base. For example, in a large development team, it is very common to have long discussions about the code styling.</p>
<p>The term <em>code styling</em> refers to certain cosmetic elements of our code, such as using spaces or tabs. However, sometimes the code styling involves certain rules that are not purely cosmetic and are intended to make our code more maintainable. A good example of this would be a code styling rule that enforces using trailing commas.</p>
<p>Code styling guidelines and rules are great but enforcing them can take a significant amount of human effort. We would have to review every single code change to make sure that the code contributions respect our code styling rules.</p>
<p>The main goal of a linting tool is to automate the enforcement of the code styling rules.</p>
<p>In the TypeScript world, the leading linting tool is <strong>tslint</strong>. We can install <kbd>tslint</kbd> using <kbd>npm</kbd>:</p>
<pre>    <strong>npm install -g tslint</strong>  </pre>
<p>We then need to create a <kbd>tslint.json</kbd> file. This file contains the configuration that allows us to enable and disable certain styling rules. The following code snippet is an example of a <kbd>tslint.json</kbd> file:</p>
<pre>{ 
    "extends": "tslint:all", 
    "rules": { 
      "array-type": [true, "array"], 
      "ban-types": false, 
      "comment-format": false, 
      "completed-docs": false, 
      "cyclomatic-complexity": false, 
      "interface-name": false, 
      "linebreak-style": false, 
      "max-classes-per-file": false, 
      "max-file-line-count": false, 
      "max-line-length": [true, 140], 
      "member-ordering": false, 
      "newline-before-return": false, 
      "no-any": false, 
      "no-empty-interface": false, 
      "no-floating-promises": false, 
      "no-import-side-effect": false, 
      "no-inferred-empty-object-type": false, 
      "no-magic-numbers": false, 
      "no-namespace": false, 
      "no-null-keyword": false, 
      "no-parameter-properties": false, 
      "no-submodule-imports": false, 
      "no-unbound-method": false, 
      "no-unnecessary-class": false, 
      "no-unnecessary-qualifier": false, 
      "no-unsafe-any": false, 
      "no-reference": false, 
      "no-void-expression": false, 
      "only-arrow-functions": false, 
      "prefer-function-over-method": false, 
      "prefer-template": false, 
      "promise-function-async": false, 
      "space-before-function-paren": false, 
      "strict-boolean-expressions": false, 
      "strict-type-predicates": false, 
      "switch-default": false, 
      "trailing-comma": false, 
      "typedef": false, 
      "variable-name": false 
    } 
 } </pre>
<p>After creating the <kbd>tslint.json</kbd> file, we can check our source code using the following command:</p>
<pre>    <strong>tslint --project tsconfig.json -c tslint.json ./**/*.ts</strong>  </pre>
<p>The preceding command is not really convenient. We can use <kbd>npm</kbd> <kbd>scripts</kbd> to create a more convenient command, named <kbd>lint</kbd>:</p>
<pre>"scripts": { 
  "lint": "tslint --project tsconfig.json -c tslint.json ./**/*.ts" 
} </pre>
<p>We can then run <kbd>tslint</kbd> using the following <kbd>npm</kbd> command:</p>
<pre>    <strong>npm run lint</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with npm scripts</h1>
                
            
            
                
<p>The <kbd>package.json</kbd> file contains a field named <kbd>scripts</kbd>. This field can contain multiple entries, and each entry is used to create a command. A command can execute any kind of custom logic.</p>
<p>When we create the <kbd>package.json</kbd> file using the <kbd>npm init</kbd> command, the default command is not implemented:</p>
<pre>"scripts": { 
    "test": "echo "Error: no test specified" &amp;&amp; exit 1" 
  }, </pre>
<p>In a real-world scenario, we would have multiple commands as in the following example:</p>
<pre>{ 
  "name": "repository-name", 
  "version": "1.0.0", 
  "description": "example", 
  "main": "index.html", 
  "scripts": { 
    "start": "node ./src/index.js", 
    "test": "gulp test", 
    "lint": "tslint -c tslint.json ./**/*.ts" 
  }, 
  "repository": { 
    "type": "git", 
    "url": "https://github.com/username/repository-name.git" 
  }, 
 </pre>
<p>Some commands, such as the <kbd>test</kbd>, <kbd>install</kbd>, or <kbd>start</kbd> commands, are considered standard commands. You can execute a standard command by using the <kbd>npm</kbd> command followed by the name of the standard command:</p>
<pre>    <strong>npm test</strong>
    <strong>npm start</strong></pre>
<p>For the commands that are not considered standard, we need to use the <kbd>npm</kbd> command followed by the <kbd>run</kbd> command and the name of the command:</p>
<pre>    <strong>npm run lint</strong></pre>
<p>Please refer to the npm documentation at <a href="https://docs.npmjs.com">https://docs.npmjs.com</a> to learn more about all the npm features.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Gulp</h1>
                
            
            
                
<p>Two of the most popular JavaScript task runners are Grunt and Gulp. The main difference between Gulp and Grunt is that while in Grunt we work using files as the input and output of our tasks, in Gulp we work with streams and pipes.</p>
<p>Grunt is configured using some configuration fields and values. However, Gulp prefers code over configuration. This approach makes the Gulp configuration somehow more minimalist and easy to read.</p>
<p>In this book, we will work with Gulp; however, if you want to learn more about Grunt, you can do so at <a href="http://gruntjs.com/">http://gruntjs.com/</a>.</p>
<p>To gain a good understanding of Gulp, we are going to configure some tasks.</p>
<p>Let's start by installing <kbd>gulp</kbd> using <kbd>npm</kbd>:</p>
<pre>    <strong>npm install gulp -g</strong></pre>
<p>Then let's create a JavaScript file named <kbd>gulpfile.js</kbd> inside the root folder of our project, which should contain the following piece of code:</p>
<pre>let gulp = require("gulp"); 
 
gulp.task("hello", function() { 
    console.log("Hello Gulp!"); 
}); </pre>
<p>And, finally, run <kbd>gulp</kbd>:</p>
<pre>    <strong>gulp hello</strong>  </pre>
<p>Please note that we installed Gulp using the <kbd>-g</kbd> flag because we are going to invoke the <kbd>gulp</kbd> command directly from the command-line interface. However, if we are planning to use <kbd>npm scripts</kbd>, we should install Gulp and any other dependencies as project dependencies using the <kbd>--save-dev</kbd> flag instead. Note that using global (<kbd>-g</kbd>) dependencies is not recommended. Also, note that we must execute this command from the location in which the <kbd>gulpfile.js</kbd> file is located.</p>
<p>We have created our first Gulp task, which is named <kbd>hello</kbd>. When we run the <kbd>gulp</kbd> command, it will automatically try to search for the <kbd>gulpfile.js</kbd> in the current directory, and once found, it will try to find the <kbd>hello</kbd> task. If everything worked as expected, we should see an output similar to the following in our CLI:</p>
<pre><strong>Using gulpfile 
Starting 'hello'... 
Hello Gulp! 
Finished 'hello' after 255 μs</strong> </pre>
<p>We will now add a second task, which will use the <kbd>gulp-tslint</kbd> plugin to check whether our TypeScript code follows a series of recommended practices.</p>
<p>We need to install the plugin with <kbd>npm</kbd>:</p>
<pre>    <strong>npm install tslint gulp-tslint -g</strong></pre>
<p>We can then load the plugin in our <kbd>gulpfile.js</kbd> file and add a new task:</p>
<pre>let tslint = require("tslint"); 
let gulpTslint = require("gulp-tslint"); 
 
gulp.task("lint", function() { 
 
    let program = tslint.Linter.createProgram("./tsconfig.json"); 
     
    return gulp.src([ 
        "src/**/**.ts", 
        "test/**/**.test.ts" 
    ]) 
    .pipe(gulpTslint({ 
        formatter: "stylish", 
        program 
    })) 
    .pipe(gulpTslint.report()); <br/>});</pre>
<p>We have named the new task <kbd>lint</kbd>. Let's take a look at the operations performed by the <kbd>lint</kbd> task, step by step:</p>
<ol>
<li>The <kbd>gulp src</kbd> function will read the files with the file extension <kbd>.ts</kbd> located in the <kbd>src</kbd> directory and its subdirectories. We are also fetching all the files with the file extension <kbd>.test.ts</kbd> in the directory located in <kbd>test</kbd> and its subdirectories.</li>
<li>Many plugins allow us to indicate files to be ignored by adding the exclamation symbol (<kbd>!</kbd>) before a path. For example, the path <kbd>!path/*.d.ts</kbd> will ignore all files with the extension <kbd>.d.ts</kbd>.</li>
<li>The <kbd>pipe</kbd> function is used to pass the output stream of the <kbd>src</kbd> as the input of the <kbd>gulpTslint</kbd> function.</li>
<li>Finally, we use the output of the <kbd>tslint</kbd> function as the input of the <kbd>report</kbd> function.</li>
</ol>
<p>Now that we have added the <kbd>lint</kbd> task, we will modify the <kbd>gulpfile.js</kbd> file to add one more task, named <kbd>default</kbd>:</p>
<pre>gulp.task("default", ["hello", "lint"]); </pre>
<p>The default task can be used to invoke both the <kbd>hello</kbd> and <kbd>lint</kbd> tasks. When we define a <kbd>gulp</kbd> task, we invoke the <kbd>task</kbd> function with two arguments. The first argument is the task name. The second argument can take a function that defines a task or an array containing a list of subtasks.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Controlling the gulp task execution order</h1>
                
            
            
                
<p>We will now learn how to control the order in which the tasks are executed. If we try to execute the default, the <kbd>hello</kbd> and <kbd>lint</kbd> tasks will be executed in parallel because the subtasks are executed in parallel by default.</p>
<p>Sometimes we will need to run our tasks in a certain order. Controlling the execution order of our tasks can be challenging since in Gulp all the tasks are asynchronous by default.</p>
<p>However, there are three ways to make a task synchronous.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Passing in a callback to the task definition function</h1>
                
            
            
                
<p>All we need to do is to pass a callback function to the task definition function as follows:</p>
<pre>gulp.task("sync", function (cb) { 
    // We used setTimeout here to illustrate an async operation 
    setTimeout(function () { 
        console.log("Hello Gulp!"); 
        cb(); // note the cb usage here 
    }, 1000); 
}); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Returning a promise</h1>
                
            
            
                
<p>All we need to do is to use a promise as the return of the task definition function as follows:</p>
<pre>gulp.task("sync", function () { 
    return new Promise((resolve) =&gt; { 
        setTimeout(function () { 
            console.log("Hello Gulp!"); 
            resolve(); 
        }, 1000); 
    }); 
}); </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Returning a stream</h1>
                
            
            
                
<p>All we need to do is to use a stream as the return of the task definition function. This is simple because the pipe operator returns a stream:</p>
<pre>gulp.task("sync", function () { 
    return gulp.src([ 
        "src/**/**.ts" 
    ]) 
    .pipe(somePlugin({})) 
    .pipe(somePlugin ()); 
}); </pre>
<p>Now that we have some synchronous tasks, we can use them as a subtask of a new task named <kbd>async</kbd>:</p>
<pre>gulp.task("async", ["sync1", "sync2"], function () {   
    // This task will not start until 
    // the sync tasks are completed! 
    console.log("Done!"); 
}); </pre>
<p>As we can see in the preceding code snippet, it is also possible to define a task that has some subtasks. However, if the complexity of our build process increases, we can end up with a very difficult to follow task dependency graph. Fortunately, we can install the <kbd>run-sequence</kbd> Gulp plugin via <kbd>npm</kbd>, which will allow us to have better control over the task execution order:</p>
<pre>let runSequence = require('run-sequence'); 
 
gulp.task('default', function(cb) { 
  runSequence( 
    'lint',                      // lint 
    ['tsc', 'tsc-tests'],        // compile 
    ['bundle-js','bundle-test'], // optimize 
    'karma'                      // test 
    'browser-sync',              // serve 
    cb                           // callback 
  ); 
}); </pre>
<p>The preceding code snippet will run in the following order:</p>
<ol>
<li><kbd>lint</kbd></li>
<li><kbd>tsc</kbd> and <kbd>tsc-tests</kbd> in parallel</li>
<li><kbd>bundle-js</kbd> and <kbd>bundle-test</kbd> in parallel</li>
<li><kbd>karma</kbd></li>
<li><kbd>browser-sync</kbd></li>
</ol>
<p>The Gulp development team announced plans to improve the management of the task execution order without the need of external plugins. Refer to the Gulp documentation at <a href="https://github.com/gulpjs/gulp/">https://github.com/gulpjs/gulp/</a> to learn more about it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Webpack</h1>
                
            
            
                
<p>As we already know, when we compile our TypeScript code, the compiler will generate a JavaScript file for each existing TypeScript file. If we run the application in a web browser, these files won't be really useful on their own because the only way to use them would be to create an individual HTML <kbd>script</kbd> tag for each one of them.</p>
<p>However, this would be highly inconvenient and inefficient because each <kbd>script</kbd> tag will translate into a round trip between the web browser and the server serving the JavaScript files. Using <kbd>script</kbd> tags is also slower than using Ajax calls because <kbd>script</kbd> tags can prevent the browser from rendering.</p>
<p>Please note that in a modern web browser, we can make some of the <kbd>script</kbd> tags asynchronous but it is not always an option. Please refer to <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript</a> to learn more about asynchronous scripts.</p>
<p>Fortunately, there are a few potential solutions for this problem:</p>
<ul>
<li><strong>Load the files using AJAX calls</strong>: We can use a tool to load each of the JavaScript files on demand using AJAX calls. This approach is known as asynchronous module loading. To follow this approach, we will need to use Require.js and change the configuration of the TypeScript compiler to use the asynchronous module definition (AMD) notation.</li>
<li><strong>Bundle all the files into one unique file and load it using a script tag</strong>: We can use a tool to trace the application modules and dependencies and generate a highly optimized single file, which will contain all the application modules. To follow this approach, we will need to use a tool, such as Webpack or Browserify and change the configuration of the TypeScript compiler to use the correct module syntax (usually CommonJS).</li>
<li><strong>Hybrid approach</strong>: We can follow a hybrid approach by creating a highly optimized bundle that contains the minimum number of files required by the application to be able to work. Additional files are then loaded on demand using AJAX calls when they are required by the application users.</li>
</ul>
<p>Please refer to <a href="90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml">Chapter 5</a>, <em>Working with Dependencies</em>, to learn more about modules.</p>
<p>In this chapter, we are going to focus on the second approach. We will create a highly optimized module bundler using Webpack. Creating a highly optimized application bundle usually involves multiple steps; Webpack can perform each of these tasks but it is not really designed to be used as a task runner. We can install Webpack using <kbd>npm</kbd>:</p>
<pre>    <strong>npm install webpack --save-dev</strong>  </pre>
<p>We are also going to install a few extra modules required by this example:</p>
<pre>    <strong>npm install awesome-typescript-loader css-loader extract-text-webpack-plugin node-sass resolve-url-loader sass-loader style-loader --save-dev</strong>
  </pre>
<p>Most of these modules are Webpack plugins and their dependencies. We need them because we are going to use them in our Webpack configuration file.</p>
<p>We can configure Webpack by creating a file named <kbd>webpack.config.js</kbd> in the root directory of our project. The following code section displays the entire content of the Webpack configuration file used by the companion source code of this chapter.</p>
<p>The <kbd>webpack.config.js</kbd> file is importing some dependencies:</p>
<pre>const { CheckerPlugin, TsConfigPathsPlugin } = require("awesome-typescript-loader"); 
const webpack = require("webpack"); 
const ExtractTextPlugin = require("extract-text-webpack-plugin"); </pre>
<p>Then, we declare three variables:</p>
<ul>
<li>The <kbd>corePlugins</kbd> variable is an array that contains the configuration of Webpack plugins that are used in development builds and production builds</li>
<li>The <kbd>devPlugins</kbd> variable is an array that contains the configuration of Webpack plugins used in development builds only</li>
<li>The <kbd>prodPlugins</kbd> variable is an array that contains the configuration of Webpack plugins used in production builds only</li>
</ul>
<p>Each of the plugins requires some specific configuration. For example, the <kbd>ExtractTextPlugin</kbd> is used to extract our CSS code from the main application bundle:</p>
<pre>const corePlugins = [ 
    new CheckerPlugin(), 
    new webpack.DefinePlugin({ 
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development") 
    }), 
    new ExtractTextPlugin({ 
        filename: "[name]main.css", 
        allChunks: true 
    }) 
]; 
 
const devPlugins = []; 
 
const prodPlugins = [ 
    new webpack.optimize.UglifyJsPlugin({ 
        output: { comments: false } 
    }) 
]; 
 
const isProduction = process.env.NODE_ENV === "production"; 
const plugins = isProduction ? corePlugins.concat(prodPlugins) : corePlugins.concat(devPlugins); 
 </pre>
<p>The configuration file uses the environment variable <kbd>NODE_ENV</kbd> determine whether we are running a development build or a production build. The production build uses the <kbd>uglify</kbd> plugin, but it is not used by the development build.</p>
<p>We then use the <kbd>uglify</kbd> plugin to minimize the output size. The reduced file size will reduce the application loading time but will make it harder to debug. Fortunately, we can generate source maps to facilitate the debugging process. The source maps are generated by the <kbd>source-map-loader</kbd> plugin.</p>
<p>Uglify removes all line breaks and whitespaces and reduces the length of some variable names. Source map files allow us to map the source code of the reduced file to its original code while debugging. A source map provides a way of mapping code within a compressed file back to its original position in a source file. This means we can easily debug an application even after its assets have been optimized. The Chrome and Firefox developer tools both ship with built-in support for source maps.</p>
<p>At this point, we define the application's entry point. We use an object as a map to define an entry point, which means that we can define multiple entry points. Each entry point is transformed into a <kbd>bundle.js</kbd> file that will be stored under a directory named <kbd>public</kbd>.</p>
<p>As we can see in the rest of the <kbd>webpack.config.js</kbd> file, we have appended a forward slash to the name of the application's entry point. We have also used a special syntax to use the name of the entry point as part of the name of the output files (for example, <kbd>[name]bundle.js</kbd>). This is a trick that we can use to generate a unique folder for each of the output bundles.</p>
<p>Finally, the file declares the configuration for some of the plugins, such as the TypeScript plugin or the <kbd>sass</kbd> plugin:</p>
<pre>module.exports = { 
    entry: { 
        "calculator_app/": "./src/main_browser.ts" 
    }, 
    devServer: { 
        inline: true 
    }, 
    output: { 
        filename: "[name]bundle.js", 
        path: __dirname + "/public", 
        publicPath: "/public" 
    }, 
    devtool: isProduction ? "source-map" : "eval-source-map", 
    resolve: { 
        extensions: [".webpack.js", ".ts", ".tsx", ".js"], 
        plugins: [ 
            new TsConfigPathsPlugin({ 
                configFileName: "tsconfig.json" 
            }) 
        ] 
    }, 
    module: { 
        rules: [ 
            { 
                enforce: "pre", 
                test: /.js$/, 
                loader: "source-map-loader", 
                exclude: [/node_modules/, /experimental/] 
            }, 
            { 
                test: /.(ts|tsx)$/, 
                loader: "awesome-typescript-loader", 
                exclude: [/node_modules/, /experimental/] 
            }, 
            { 
                test: /.scss$/, 
                use: ExtractTextPlugin.extract({ 
                    fallback: "style-loader", 
                    use: ["css-loader", "resolve-url-loader", "sass-loader"] 
                }) 
            } 
        ] 
    }, 
    plugins: plugins 
}; </pre>
<p>We can execute the Webpack bundling process using the following command:</p>
<pre><strong>webpack </strong></pre>
<p>Please note that we must execute this command from the location in which the <kbd>gulpfile.js</kbd> file is located.</p>
<p>If everything went well, we should be able to see a new folder named <kbd>public</kbd>. The <kbd>public</kbd> folder should contain the following files:</p>
<div><img class="alignnone size-full wp-image-215 image-border" src="img/04a03f6d-0182-4c43-b7f7-7bd37b14bf4f.png" style="width:12.08em;height:5.75em;" width="209" height="99"/></div>
<p>The companion source code also includes a file named <kbd>index.html</kbd>. This file is the entry point of the frontend application that we just created:</p>
<pre>&lt;!doctype html&gt; 
&lt;html lang="en"&gt; 
  &lt;head&gt; 
    &lt;meta charset="utf-8"&gt; 
    &lt;link rel="stylesheet" href="./public/calculator_app/main.css"&gt; 
    &lt;title&gt;Calculator&lt;/title&gt; 
  &lt;/head&gt; 
  &lt;body&gt; 
    &lt;div id="main"&gt;&lt;!-- Content created by JavaScript --&gt;&lt;/div&gt; 
    &lt;script src="img/bundle.js"&gt;&lt;/script&gt; 
  &lt;/body&gt; 
&lt;/html&gt;</pre>
<p>This example should give us a good first impression about how to work with Webpack. The following section describes how we can use the Webpack development as a web server to access this application from a web browser.</p>
<p>Please refer to the documentation at <a href="https://webpack.js.org/concepts/">https://webpack.js.org/concepts/</a> if you need additional information about webpack. It is also recommended to refer to the documentation of each of the plugins to learn more about the available configuration options. Some npm modules might require some additional tools. It is not very common, but some modules might require tools such as the gcc/g++ compilers and the Python interpreter to be installed in your development environment. Please refer to the documentation of your operating system online to learn how to install the gcc/g++ compilers and the Python interpreter if you encounter this kind of issue.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Webpack development server</h1>
                
            
            
                
<p>The Webpack development server is a command-line utility that monitors our filesystem for changes and triggers the Webpack bundling process.</p>
<p>We can install the Webpack development server using npm:</p>
<pre>    <strong>npm install -g webpack-dev-server</strong>  </pre>
<p>We can then execute the webpack development server using the following command:</p>
<pre>    <strong>webpack-dev-server</strong>  </pre>
<p>The Webpack development server will then start watching our filesystem for changes. If a change is detected, it will automatically run the Webpack build process using the existing the <kbd>webpack.config.js</kbd> file.</p>
<p>The Webpack development server also starts a web server. The server is running on port 8080 by default.</p>
<p>Please refer to the documentation at <a href="https://github.com/webpack/webpack-dev-server">https://github.com/webpack/webpack-dev-server</a> to learn more about the Webpack development server.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Visual Studio Code</h1>
                
            
            
                
<p>Visual Studio is a lightweight but powerful code editor with an extensive number of features. Learning all these features is out of the scope of this book because we could dedicate an entire book to cover them. However, we are going to dedicate a little bit of time to learning about two of the best features available in this code editor: quick fixes and the code debugger.</p>
<p>It is recommended to read the Visual Studio Code user guide at <a href="https://code.visualstudio.com/docs/editor/codebasics">https://code.visualstudio.com/docs/editor/codebasics</a> to learn how to make the most of this IDE.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Quick fixes</h1>
                
            
            
                
<p>Visual Studio Code can detect some errors and automatically fix them using a set of features known as <em>quick fixes</em>.</p>
<p>Visual Studio Code will display a bulb icon on the left-hand side of our code near some error. If we click on the bulb icon, Visual Studio Code will display all the available quick fixes. If we select one of the available quick fixes, Visual Studio Code will perform the necessary changes to solve the problem automatically:</p>
<div><img class="alignnone size-full wp-image-217 image-border" src="img/0d016bb6-1551-4826-975d-f28ff5d27c01.png" style="width:20.42em;height:11.42em;" width="610" height="341"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Debugging utilities</h1>
                
            
            
                
<p>Before we can debug our application using Node.js, we need to configure a debugging task in Visual Studio Code. We need to select the debug panel and add a new configuration:</p>
<div><img class="alignnone size-full wp-image-218 image-border" src="img/6983883b-b282-4153-986a-7563557bccd9.png" style="width:25.67em;height:19.83em;" width="639" height="494"/></div>
<p>A panel with a few options will then be displayed. We need to select Node.js. If you want to run and debug the application using Docker, you will be able to do so as well but it is out of the scope of this book:</p>
<div><img style="font-size: 1em;border: 1em solid black;text-align: center;width:32.67em;height:15.92em;" class="alignnone size-full wp-image-219 image-border" src="img/44cf7ca9-791f-40b8-b905-01b19d51a4cf.png" width="1046" height="510"/></div>
<p>Selecting Node.js will create a folder named <kbd>.vscode</kbd> and a file named <kbd>launch.json</kbd>. This file allows us to define as many debugging tasks as we may need. A debug task declares the instructions required to debug our unit tests.</p>
<p>The configuration of the debugging task is different for each testing tool. In the example application, we have used <kbd>mocha</kbd>, which means that our debugging task will need to use the <kbd>mocha</kbd> binary and some arguments to start a debugging session.</p>
<p>The following configuration can be used to debug the tests in the example application:</p>
<pre>{ 
    "version": "0.2.0", 
    "configurations": [ 
        { 
            "type": "node", 
            "request": "launch", 
            "name": "Debug Mocha Tests", 
            "program": "${workspaceFolder}/node_modules/mocha/bin/_mocha", 
            "args": [ <br/>                "--require", 
                "ts-node/register", 
                "-u", 
                "tdd", 
                "--timeout", 
                "999999", 
                "--colors", 
                "${workspaceFolder}/test/**/*.test.ts" 
            ], 
            "internalConsoleOptions": "openOnSessionStart", 
            "sourceMaps": true 
        } 
    ] 
} </pre>
<p>Please note that the <kbd>.vscode</kbd> folder must be in the root of your project. The companion source code includes this folder under the chapter's folder instead of the root directory. If you want to try it, you will need to open the chapter's folder as the root directory with Visual Studio Code.</p>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">After creating and configuring the <kbd>launch.json</kbd> file, we can select the task that we just defined under the DEBUG panel and click on the <em>Play</em> button:</p>
<div><img style="font-size: 1em;border: 1em solid black;text-align: center;width:24.75em;height:6.92em;" class="alignnone size-full wp-image-220 image-border" src="img/1a3af054-7611-441f-ae71-a449e70cb5d9.png" width="673" height="188"/></div>
<p>The test execution will be paused when a breakpoint is reached. We can set a breakpoint by clicking on the left-hand side of a line in our source code:</p>
<div><img style="color: #000000;width:37.25em;height:18.42em;" class="alignnone size-full wp-image-222 image-border" src="img/e43488fa-9719-4e3e-9b08-f43a849cc3ec.png" width="1198" height="594"/></div>
<p>The Visual Studio Code debugging panel allows us to examine the current execution context using the debugging panel available on the left-hand side of the screen. This panel contains a few subpanels:</p>
<ul>
<li>The variables panel allows us to see all the variables declared in the current execution context.</li>
<li>The watch panel allows us to create a <em>watcher</em>. A watcher is just a filter that allows us to display the value of a variable of our choice.</li>
<li>The call stack panel allows us to see the function call stack. We can click on the function in the call stack to navigate to the selected function.</li>
<li>The breakpoints panel allows us to enable and disable the breakpoints that we have created, as well as to enable some generic ones (for example, uncaught exceptions):</li>
</ul>
<div><img class="alignnone size-full wp-image-223 image-border" src="img/3272fd3d-b6e2-4e1a-9f65-dc8e87360c79.png" style="width:59.50em;height:37.17em;" width="1800" height="1125"/></div>
<p>The execution panel located on the top of the screen allows us to control the execution of the test at our own pace.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Source control utilities</h1>
                
            
            
                
<p>Visual Studio Code also allows us to interact with Git through a graphical user interface. To access the Git features, we need to click on the Git panel on the left-hand side of the screen.</p>
<p>The Git panel allows us to see the current changes. We can select changes to be committed (stag) or roll back the changes. We can then commit the changes by introducing a message and clicking on the approval icon located on the top right-hand side of the Git panel:</p>
<div><img style="font-size: 1em;width:22.92em;height:16.17em;" class="alignnone size-full wp-image-224 image-border" src="img/f64be25d-0bc9-4030-97a6-8cbbc1ee25d9.png" width="688" height="485"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">ts-node</h1>
                
            
            
                
<p>The TypeScript community has developed an alternative version of Node.js that is able to work with TypeScript files as if it was natively supported. This alternative version of Node.js is known as <kbd>ts-node</kbd>.</p>
<p>The <kbd>ts-node</kbd> command allows us to execute TypeScript files without having to compile them first. We can execute a TypeScript file using the following command:</p>
<pre>    <strong>ts-node ./src/main_server.ts</strong>  </pre>
<p>The example application uses npm <kbd>scripts</kbd> to create a more convenient version of this command:</p>
<pre>"scripts": { 
  "ts-node": "ts-node ./src/main_server.ts" 
} </pre>
<p>The <kbd>npm</kbd> command can be executed as follows:</p>
<pre>    <strong>npm run ts-node</strong>  </pre>
<p>By default, the <kbd>ts-node</kbd> command tries to find the compilation setting in the <kbd>tsconfig.json</kbd> file and expects it to be located in the current directory.</p>
<p>The <kbd>ts-node</kbd> command is a very convenient tool when we want to try something without having to spend too much time configuring a tool such as Webpack.</p>
<p>It may feel like <kbd>ts-node</kbd> can execute TypeScript natively, but this is not the case. Our TypeScript code is first compiled and then executed using the Node.js binary. This means that using <kbd>ts-node</kbd> in a production Node.js application is not recommended because we will pay a performance penalty (the compilation time).</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Continuous integration (CI) tools</h1>
                
            
            
                
<p>CI is a development practice that helps to prevent potential integration issues. Software integration issues refer to the difficulties that may arise during the practice of combining individually tested software components into an integrated whole. Software is integrated when components are combined into subsystems or when subsystems are combined into products.</p>
<p>Components may be integrated after all are implemented and tested, as in a waterfall model or a big bang approach. On the other hand, CI requires developers to daily commit their code into a remote code repository. Each commit is then verified by an automated process, allowing teams to detect integration issues earlier.</p>
<p>In this chapter, we have learned how to create a code repository on GitHub and how to validate our application using unit tests and linting tools, but we haven't configured a CI server to observe our commits and run these validations accordingly.</p>
<p>We are going to use Travis CI as our CI server because it is highly integrated with GitHub and is free for open source projects and learning purposes. There are many other options when it comes to choosing a CI server, but exploring these options is out of the scope of this book.</p>
<p>To configure Travis CI, we need to visit <a href="https://travis-ci.org">https://travis-ci.org</a> and log in using our GitHub credentials. Once we have logged in, we will be able to see a list of our public GitHub repositories and will also be able to enable the CI:</p>
<div><br/>
<img class="alignnone size-full wp-image-330 image-border" src="img/c6564c10-d433-4db0-8fa1-7e364329eaf7.png" style="width:39.42em;height:3.25em;" width="876" height="73"/></div>
<p>To finish the configuration, we need to add a file named <kbd>travis.yml</kbd> to our application's root directory, which contains the Travis CI configuration:</p>
<pre>    <strong>language: node_js</strong>
    <strong>node_js:</strong>
    <strong>  - stable</strong>
  </pre>
<p>There are many other available Travis CI configuration options. Refer to <a href="http://docs.travis-ci.com/">http://docs.travis-ci.com/</a> to learn more about the available options.</p>
<p>After completing these two small configuration steps, Travis CI will be ready to observe the commits to our remote code repository.</p>
<p>We have used the configuration to indicate to Travis CI that our application is a Node.js application. The CI build for each potential kind of application can be highly customized, regardless of its technology stack.</p>
<p>However, in most cases, we will simply use the defaults set for a given kind of application. In the case of Node.js, Travis CI uses <kbd>npm install</kbd> and <kbd>npm test</kbd> as the default commands.</p>
<p>If the build works in the local development environment, but fails in the CI server, we will have to check the build error log and try to figure out what went wrong. Chances are that the software versions in our environment will be ahead of the ones in the CI server and we will need to indicate to Travis CI that a dependency needs to be installed or updated. We can find the Travis CI documentation at <a href="http://docs.travis-ci.com/user/build-configuration/">http://docs.travis-ci.com/user/build-configuration/</a> to learn how to resolve this kind of issue.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Scaffolding tools</h1>
                
            
            
                
<p>A scaffolding tool is used to autogenerate the project structure, building scripts, and much more. Some examples of popular scaffolding tools include the following:</p>
<ul>
<li>The Angular CLI</li>
<li>The React CLI (create-react-app-typescript)</li>
<li>Yeoman</li>
</ul>
<p>These tools are designed to support many kinds of projects. The scaffolding tools will save us time by autogenerating some things for us, such as the webpack configuration or the <kbd>package.json</kbd> file.</p>
<p>It is highly recommended to spend some time reading the documentation of these tools to learn more about their existing customization options.</p>
<p>Please note that you can learn more about the Angular CLI, the React CLI, and Yeoman at <a href="https://cli.angular.io">https://cli.angular.io</a>, <a href="https://github.com/wmonk/create-react-app-typescript">https://github.com/wmonk/create-react-app-typescript</a>, and <a href="http://yeoman.io">http://yeoman.io</a> respectively.<br/>
Please note that it is never a good idea to let a tool generate some code for us if we don't understand what that code does. While, in the future, you should consider using a tool to generate a new project, it is recommended to gain a good understanding of task and test runners before using a scaffolding tool.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Why does the command line win?</h1>
                
            
            
                
<p>You may have noticed that during this chapter, we have used the CLI a lot instead of visual tools. We have used the command-line terminal to perform many kinds of tasks:</p>
<ul>
<li>Work with source control</li>
<li>Install dependencies</li>
<li>Run tasks</li>
<li>Test our code</li>
<li>Debug our code</li>
<li>Create projects</li>
</ul>
<p>The CLI has always been popular but I remember that, a few years ago, I used to do some of these things using Visual tools. For example, I remember running unit tests in .NET applications using a visual test runner for NUnit (a unit testing library for .NET applications). You might be wondering why we stopped using the visual tool and went back to the command line like in the early days?</p>
<p>I believe that the CLI wins for two main reasons:</p>
<ul>
<li>Our software development teams have become much more diverse</li>
<li>Our software development methodologies have evolved toward automation</li>
</ul>
<p>Our software teams are much more diverse today and, as a result, it is common to encounter teams composed of DevOps engineers who work with a Linux distribution, mobile software engineers who work on OS X, and web engineers who work on Windows.</p>
<p>The team members may use different operating systems, but they all follow the same process, and they share one unique development process. For example, if one of the members of the team wants to execute the unit tests, it would be possible to do so by executing a command in the OS console. We can go one step further and also use the same command as part of our CI build.</p>
<p>The CLI wins because it enables our development teams to share one unique set of development processes and practices.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned how to work with a long list of different development tools. It is impossible to cover so many tools in depth in one chapter, but now that we know the basics, it should be much easier to gradually dive deeper into more advanced use cases.</p>
<p>In the next chapter, we will learn about the development of backend applications with Node.js and TypeScript.</p>


            

            
        
    </div>



  </body></html>