<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Working with Vector Layers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Vector Layers</h1></div></div></div><p>In this chapter we cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding a GML layer</li><li class="listitem" style="list-style-type: disc">Adding KML layer</li><li class="listitem" style="list-style-type: disc">Creating features programmatically</li><li class="listitem" style="list-style-type: disc">Reading and creating features from a WKT</li><li class="listitem" style="list-style-type: disc">Adding markers to the map</li><li class="listitem" style="list-style-type: disc">Using point features as markers</li><li class="listitem" style="list-style-type: disc">Working with popups</li><li class="listitem" style="list-style-type: disc">Adding features from a WFS server</li><li class="listitem" style="list-style-type: disc">Using the cluster strategy</li><li class="listitem" style="list-style-type: disc">Filtering features in WFS requests</li><li class="listitem" style="list-style-type: disc">Reading features directly using Protocols</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter talks about vector layers. In addition to raster, vector information is the other important type of information we can work with in a GIS system.<a class="indexterm" id="id93"/>
</p><p>The chapter tries to summarize the most common and important recipes you may need to work with in OpenLayers.</p><p>In GIS, a real-world phenomenon is represented by the concept of a feature. It can be a place—like a city or a village—it can be a road or a railway, it can be a region, a lake, the border of a country, or something similar.</p><p>Every feature has a set of attributes: population, length, and so on. It is represented visually by a geometrical symbol: point, line, polygon, and so on, using some visual style: color, radius, width, and so on.</p><p>As you can see, there are many concepts to take into account when working with vector information. Fortunately, OpenLayers provides us classes to work with them. We will learn more about these in this chapter.</p><p>The base class for vector layers is<code class="literal"> OpenLayers.Layer.Vector</code> class, which defines the common properties and behavior for all the subclasses.</p><p>The<code class="literal"> OpenLayers.Layer.Vector</code> class contains a set of features. These features are instances of the<code class="literal"> OpenLayers.Feature.Vector</code> subclasses (which, in fact, are inherited from a more generic<code class="literal"> OpenLayers.Feature</code> class).</p><p>Each feature has an<code class="literal"> attributes</code> property and an<code class="literal"> OpenLayers.Geometry</code> class instance associated with it.</p><p>The vector layer itself or each feature can have a visual style associated with it, which will be used to render the feature on the map.</p><p>In addition to the representation on the screen, we need to take into account the data source. OpenLayers offers classes to read/write features from/to many sources, or protocols, and using different formats: GML, KML, GeoJSON, GeoRSS, and so on.</p><p>The vector layer has optionally associated an instance of the<code class="literal"> OpenLayers.Protocol</code> class and a list of instances of the<code class="literal"> OpenLayers.Strategy</code> class. The first is responsible to read/write data using some protocol, such as HTTP or WFS, while the second (the strategy) is responsible to control tasks such as when to load or refresh the data in the layer: only once, every time the layer is moved, every few seconds, and so on.</p><p>Let's get started and see these classes in action.</p></div></div>
<div class="section" title="Adding a GML layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec02"/>Adding a GML layer</h1></div></div></div><p>The<span class="strong"><strong> Geography Markup Language (GML)</strong></span> is an XML grammar used to express geographic features. It is an OGC standard and is very well accepted by the GIS community.<a class="indexterm" id="id94"/>
</p><div class="mediaobject"><img alt="Adding a GML layer" src="graphics/7843_03_01.jpg"/></div><p>In this recipe, we will show you how to create a vector layer from a GML file.<a class="indexterm" id="id95"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note26"/>Note</h3><p>You can find the necessary files in the GML format attached to the source code of this book on the Packt Publishing website.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec01"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file with the required OpenLayers dependencies and insert the following code. First add the<code class="literal"> div</code> element to hold the map:<div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt; 
&lt;div id="ch3_gml" style="width: 100%; 
    height: 100%;"&gt;&lt;/div&gt; 
</pre></div></li><li class="listitem">Next, add the JavaScript code to initialize the map, add a base layer, and a layer switcher control:<div class="informalexample"><pre class="programlisting">&lt;!-- The magic comes here --&gt; 
&lt;script type="text/javascript"&gt; 
    // Create the map using the specified DOM element 
    var map = new OpenLayers.Map("ch3_gml");    
    
    var layer = new 
        OpenLayers.Layer.OSM("OpenStreetMap"); 
    map.addLayer(layer); 
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher()); 
    map.setCenter(new OpenLayers.LonLat(0,0), 2); 
</pre></div></li><li class="listitem">Finally, add a vector layer with the GML data:<div class="informalexample"><pre class="programlisting">    map.addLayer(new OpenLayers.Layer.Vector("Europe (GML)", { 
        protocol: new OpenLayers.Protocol.HTTP({ 
            url: "http://localhost:8080/
                openlayers-cookbook/recipes/
                data/europe.gml", 
            format: new OpenLayers.Format.GML() 
        }), 
        strategies: [new OpenLayers.Strategy.Fixed()] 
    })); 
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec02"/>How it works...</h3></div></div></div><p>Before using the<code class="literal"> OpenLayers.Layer.Vector</code> class, we need to take some aspects into consideration.<a class="indexterm" id="id96"/>
</p><p>If we need to load data from some source then we need to set a protocol and a strategy. In this case, we have used a fixed strategy, through the<code class="literal"> OpenLayers.Strategy.Fixed</code> class instance, which means the data content is loaded only once. It is never refreshed or loaded again.</p><div class="informalexample"><pre class="programlisting">new OpenLayers.Layer.Vector("Europe (GML)", { 
        protocol: new OpenLayers.Protocol.HTTP({ 
            url: "http://localhost:8080/openlayers-cookbook/recipes/data/europe.gml", 
            format: new OpenLayers.Format.GML() 
        }), 
        strategies: [new OpenLayers.Strategy.Fixed()] 
    })
</pre></div><p>The data to be loaded is accessible via the HTTP protocol and a URL to the file. The protocol, as an instance of the<code class="literal"> OpenLayers.Protocol.HTTP</code> class, is responsible to read the data from the specified resource and requires a URL and a format to know how to read the data.</p><p>OpenLayers offers many format classes to read/write data, but in this recipe we have made use of an<code class="literal"> OpenLayer.Format.GML</code> instance because our data source is a GML file.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec03"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding a KML layer</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Adding a KML layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec03"/>Adding a KML layer</h1></div></div></div><p>The arrival of Google Maps leads to an explosion in the world of GIS and web mapping. Google introduced not only an API but also some file formats.<a class="indexterm" id="id97"/>
</p><p>The<span class="strong"><strong> Keyhole Markup Language (KML)</strong></span> had become one of the most extensively used formats, and finally it became an OGC standard.<a class="indexterm" id="id98"/>
</p><div class="mediaobject"><img alt="Adding a KML layer" src="graphics/7843_03_02.jpg"/></div><p>This recipe will show you how easy it is to add features from a KML file. You can find the necessary files in the KML format attached to the source code of this book available on the Packt Publishing website.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec04"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file including the OpenLayers library and insert the following code in it. First, add the<code class="literal"> DOM</code> element that will hold the map:<a class="indexterm" id="id99"/><div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_kml" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Next, initialize a map instance, add a base layer, add a layer switcher control, and center the view:<div class="informalexample"><pre class="programlisting">&lt;!-- The magic comes here --&gt; 
&lt;script type="text/javascript"&gt; 

    // Create the map using the specified DOM element 
    var map = new OpenLayers.Map("ch3_kml");    
    
    var layer = new OpenLayers.Layer.OSM("OpenStreetMap"); 
    layer.wrapDateLine = false;
    map.addLayer(layer); 
    
    map.addControl(new OpenLayers.Control.LayerSwitcher()); 
    map.setCenter(new OpenLayers.LonLat(0,0), 2); 
</pre></div></li><li class="listitem">Finally, add a vector layer that will load data from a KML file:<div class="informalexample"><pre class="programlisting">    // Global Undersea Fiber Cables
    map.addLayer(new OpenLayers.Layer.Vector("Global 
        Undersea Fiber Cables", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/
            openlayers-cookbook/recipes/
            data/global_undersea.kml",
            format: new OpenLayers.Format.KML({
                extractStyles: true,
                extractAttributes: true
            })
        }),
        strategies: [new OpenLayers.Strategy.Fixed()]
    }));
&lt;/script&gt; 
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec05"/>How it works...</h3></div></div></div><p>After initializing the map, we centered the view and added some controls. Then we added a vector layer.<a class="indexterm" id="id101"/>
</p><p>Because we want to load data from a KML file, that is accessible via HTTP protocol, we have set an<code class="literal"> OpenLayers.Protocol.HTTP</code> instance as the protocol of the vector layer. It uses the URL of the file and uses an<code class="literal"> OpenLayers.Format.KML</code> instance as the<code class="literal"> format</code> property.</p><p>In addition, we have set an<code class="literal"> OpenLayers.Strategy.Fixed</code> instance as the strategy of the vector layer, which makes the file load only once.</p><p>In addition, we have used a couple of<code class="literal"> OpenLayers.Format.KML</code> classes,<code class="literal"> extractStyles</code> and<code class="literal"> extractAttributes</code>, to maintain the color styles and attributes specified in the source KML file. Otherwise, OpenLayers will apply a default style.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec06"/>There's more...</h3></div></div></div><p>The KML format, like GML, offers tons of options and possibilities at the cost of complexity.</p><p>In the KML format, placemarks can have a description attached to them and, if you load a KML file in Google Maps, the placemark's description is shown as a balloon (or popup) when you click on them.</p><p>In OpenLayers, this approach differs a bit. As we will see in the<span class="emphasis"><em> Working with popups</em></span> recipe, the process to load the KML data and the behavior to show them are completely different. So don't expect the vector layer that loads the data to also attach the required code to control the click event, show the popup, and so on. That is our work.<a class="indexterm" id="id102"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec07"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding a GML layer</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Working with popups</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Creating features programmatically"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec04"/>Creating features programmatically</h1></div></div></div><p>Loading data from an external source is not the only way to work with vector layers.</p><p>Imagine a web mapping application where the user can create new features on the fly: cities, rivers, areas of interest, and so on, and add them to a vector layer with some style. This scenario requires the ability to create and add the features programmatically.<a class="indexterm" id="id103"/>
</p><p>In this recipe we will see some ways to create and manage features programmatically.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec08"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by creating a new HTML file with the required OpenLayers dependencies. Add the<code class="literal"> div</code> element to hold the map:<div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_features_programmatically" 
    style="width: 100%; height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Next, initialize the map instance and add a base layer:<div class="informalexample"><pre class="programlisting">&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;

    // Create the map using the specified DOM element
    var map = new 
        OpenLayers.Map("ch3_features_programmatically");    
    
    // Add a WMS layer
    var wms = new OpenLayers.Layer.WMS("Basic", 
        "http://vmap0.tiles.osgeo.org/wms/vmap0",
    {
        layers: 'basic'
    });
    map.addLayer(wms);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Now, create three vector layers to put three different types of features:<div class="informalexample"><pre class="programlisting">    // Create some empty vector layers
    var pointLayer = new 
        OpenLayers.Layer.Vector("Points");
    var lineLayer = new OpenLayers.Layer.Vector("Lines");
    var polygonLayer = new 
        OpenLayers.Layer.Vector("Polygon");
    
    // Add layers to the map
    map.addLayers([polygonLayer, lineLayer, pointLayer]);
</pre></div></li><li class="listitem">Call the function that will create the point, line, and polygon features and add them to each of the previous layers:<a class="indexterm" id="id104"/><div class="informalexample"><pre class="programlisting">    // Fill layers
    initializePointLayer();
    initializeLineLayer();
    initializePolygonLayer();
    
    // Create some random points.
    function initializePointLayer() {
        var pointFeatures = [];
        for(var i=0; i&lt; 50; i++) {
            var px = Math.random()*360-180;
            var py = Math.random()*180-90;

            var pointGeometry = new 
                OpenLayers.Geometry.Point(px, py);
            var pointFeature = new 
                OpenLayers.Feature.Vector(pointGeometry);
            pointFeatures.push(pointFeature);
        }
        pointLayer.addFeatures(pointFeatures);
    }
    
    // Create some random lines
    function initializeLineLayer() {
        for(var j=0; j&lt; 2; j++) {
            var pointGeometries = [];
            for(var i=0; i&lt; 10; i++) {
                var px = Math.random()*240-120;
                var py = Math.random()*100-50;

                var pointGeometry = new 
                    OpenLayers.Geometry.Point(px, py);
                pointGeometries.push(pointGeometry);
            }
            var lineGeometry = new OpenLayers.Geometry.
                LineString(pointGeometries);
            var lineFeature = new 
                OpenLayers.Feature.Vector(lineGeometry);
            lineLayer.addFeatures(lineFeature);
        }
    }
    
    // Create some random polygons
    function initializePolygonLayer() {
        for(var j=0; j&lt; 2; j++) {
            var pointGeometries = [];
            for(var i=0; i&lt; 5; i++) {
                var px = Math.random()*240-180;
                var py = Math.random()*100-90;

                var pointGeometry = new 
                    OpenLayers.Geometry.Point(px, py);
                pointGeometries.push(pointGeometry);
            }
            var linearGeometry = new OpenLayers.Geometry.
                LinearRing(pointGeometries);
            var polygonGeometry = new OpenLayers.
                Geometry.Polygon([linearGeometry]);
            var polygonFeature = new OpenLayers.
                Feature.Vector(polygonGeometry);
            polygonLayer.addFeatures(polygonFeature);
        }
    }
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec09"/>How it works...</h3></div></div></div><p>As described in the chapter's introduction, a vector layer contains a set of features. Each feature represents some phenomenon of the real world and has a geometry and a style associated with it, which will determine the visual representation.<a class="indexterm" id="id105"/>
</p><p>Let's start looking at the code responsible for creating random points:</p><div class="informalexample"><pre class="programlisting">        var pointFeatures = [];
        for(var i=0; i&lt; 50; i++) {
            var px = Math.random()*360-180;
            var py = Math.random()*180-90;

            var pointGeometry = new 
                OpenLayers.Geometry.Point(px, py);
            var pointFeature = new 
                OpenLayers.Feature.Vector(pointGeometry);
            pointFeatures.push(pointFeature);
        }
        pointLayer.addFeatures(pointFeatures);
</pre></div><p>In this case, each feature is represented by a point geometry, because we first need to create an<code class="literal"> OpenLayers.Geometry.Point</code> instance with the coordinates of the point.<a class="indexterm" id="id106"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note27"/>Note</h3><p>Remember to express the coordinates in the appropriate projection, the one used by the map, or set the right projection in the vector layer so that OpenLayers can translate the coordinates.</p></div><p>Once we have the geometry instance, we can create a new<code class="literal"> OpenLayers.Feature.Vector</code> instance by passing the desired geometry instance to be used by the feature.</p><p>Note that we will cover working with feature styles in another chapter. It will be rendered with a default OpenLayers style.</p><p>All the features are stored in an array and passed at once to the vector layer using the<code class="literal"> addFeatures()</code> method.</p><p>Next in the difficulty order is the creation of lines, named in the geometry objects terminology as LineStrings. When you want to represent a feature as a LineString you need to use an instance of the geometry class<code class="literal"> OpenLayers.Geometry.LineString</code>. As we can see in the following block of code, the line string constructor needs an array of the<code class="literal"> OpenLayers.Geometry.Point</code> instance that conforms the set of points for the lines.</p><div class="informalexample"><pre class="programlisting">            var pointGeometries = [];
            for(var i=0; i&lt; 10; i++) {
                var px = Math.random()*240-120;
                var py = Math.random()*100-50;

                var pointGeometry = new OpenLayers.Geometry.Point(px, py);
                pointGeometries.push(pointGeometry);
            }
            var lineGeometry = new OpenLayers.Geometry.LineString(pointGeometries);
            var lineFeature = new OpenLayers.Feature.Vector(lineGeometry);
            lineLayer.addFeatures(lineFeature);
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note28"/>Note</h3><p>The OGC's Simple Feature Access specification (<a class="ulink" href="http://www.opengeospatial.org/standards/sfa">http://www.opengeospatial.org/standards/sfa</a>) contains an in-depth description of the standard. It also contains an UML class diagram where you can see all the geometry classes and hierarchy.</p></div><p>Finally, we found the code that creates some polygons.<a class="indexterm" id="id107"/>
</p><p>Polygons are great geometries to represent states or countries. We can think of polygons as a simple set of lines where the start and end point is the same, a so called<span class="emphasis"><em> LineRing</em></span>, and filled with some color. But be aware, polygons can be very complex structures that complicate the way we must express them.</p><p>For example, think of a region with a hole in it. In this case we have two line rings to describe the external and internal perimeters. We must also specify which part must be colored.</p><p>Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">            var pointGeometries = [];
            for(var i=0; i&lt; 5; i++) {
                var px = Math.random()*240-180;
                var py = Math.random()*100-90;

                var pointGeometry = new 
                    OpenLayers.Geometry.Point(px, py);
                pointGeometries.push(pointGeometry);
            }
            var linearGeometry = new 
                OpenLayers.Geometry.LinearRing(pointGeometries);
            var polygonGeometry = new 
                OpenLayers.Geometry.Polygon([linearGeometry]);
            var polygonFeature = new 
                OpenLayers.Feature.Vector(polygonGeometry);
            polygonLayer.addFeatures(polygonFeature);
</pre></div><p>Here we create an<code class="literal"> OpenLayers.Geometry.LineRing</code> instance by passing an array of<code class="literal"> OpenLayers.Geometry.Point</code> with the set of points that conforms the line ring.</p><p>Once we have one or more line rings, we can create a new instance of the<code class="literal"> OpenLayers.Geometry.Polygon</code> class, which will be used to render our new vector layer feature.<a class="indexterm" id="id108"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec10"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding marker to the map</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Reading and creating features from WKT</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Working with popups</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Styling features using symbolizers</em></span> recipe in<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>, <span class="emphasis"><em> Styling Features</em></span></li></ul></div></div></div></div>
<div class="section" title="Reading and creating features from a WKT"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec05"/>Reading and creating features from a WKT</h1></div></div></div><p>OpenLayers comes with a great set of format classes, which are used to read/write from/to different file data formats. GeoJSON, GML, or GPX are some of the many formats we can find.<a class="indexterm" id="id109"/>
</p><p>If you have read the<span class="emphasis"><em> Adding a GML layer</em></span> recipe in this chapter, you will know that a vector class can read the features stored in a file, specify the format of the data source, and place the contained features in the map.</p><p>This recipe wants to show us exactly that. We will see the magic step responsible to read data from a file using a format class, and transform it to the corresponding feature ready to be placed in the layer.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note29"/>Note</h3><p>For simplicity, we will only see how to read features from the WKT text. You can learn more about WKT (Well-Known Text) format from<a class="ulink" href="http://en.wikipedia.org/wiki/Well-known_text"> http://en.wikipedia.org/wiki/Well-known_text</a>.</p></div><p>As can be seen in the previous screenshot, we are going to create a map on the left side, and on the right we will place a couple of text area components to add and get features in the WKT format.<a class="indexterm" id="id110"/>
</p><div class="mediaobject"><img alt="Reading and creating features from a WKT" src="graphics/7843_03_09.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec11"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new HTML file with OpenLayers dependencies. Then, add the following HTML code for the map, text area, and buttons:<a class="indexterm" id="id111"/><div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;table style="width: 100%; height: 95%;"&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;div id="ch3_reading_wkt" style="width: 100%; 
                height: 100%;"&gt;&lt;/div&gt;
        &lt;/td&gt;
        &lt;td style="width: 30%; vertical-align: top;"&gt;
            &lt;p&gt;Write the WKT describing features:&lt;/p&gt;
            &lt;textarea id="wktText" 
                dojoType="dijit.form.SimpleTextarea" 
                rows="10" style="width: 100%;"&gt;
                MULTIPOLYGON 
                (((40 40, 20 45, 45 30, 40 40)),
                ((20 35, 45 20, 30 5, 10 10, 10 30, 20 35),
                (30 20, 20 25, 20 15, 30 20)))&lt;/textarea&gt;
            &lt;button dojoType="dijit.form.Button" 
                onClick="addFeature"&gt;Add Feature&lt;/button&gt;
            &lt;button dojoType="dijit.form.Button" 
                onClick="clearLayer"&gt;Clear Layer&lt;/button&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3><p>Remember, we are using Dojo toolkit framework (<a class="ulink" href="http://dojotoolkit.org">http://dojotoolkit.org</a>) to improve our components, so some elements will have attributes like<code class="literal"> dojoType="dijit.form.Button"</code>.</p></div></li><li class="listitem">Now, we will initialize the map component and place a base layer:<a class="indexterm" id="id112"/><div class="informalexample"><pre class="programlisting">&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_reading_wkt");    
    
    // Add a WMS layer
    var wms = new OpenLayers.Layer.WMS("Basic", 
        "http://vmap0.tiles.osgeo.org/wms/vmap0",
    {
        layers: 'basic'
    });
    map.addLayer(wms);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Let's go on to create a vector layer to hold the features we will read from the WKT:<div class="informalexample"><pre class="programlisting">    // Create some empty vector layers
    var wktLayer = new 
        OpenLayers.Layer.Vector("wktLayer");
    // Add layers to the map
    map.addLayer(wktLayer);
</pre></div></li><li class="listitem">We need a couple of functions to handle the button events. The first function is responsible to clean the vector layer:<div class="informalexample"><pre class="programlisting">    function clearLayer() {
        wktLayer.removeAllFeatures();
    }
</pre></div></li><li class="listitem">The second function reads the data from the WKT string and places the features on the vector layer:<a class="indexterm" id="id113"/><div class="informalexample"><pre class="programlisting">    function addFeature() {
        // Read features and add to the vector layer
        var text = dijit.byId('wktText').get('value');
        var wkt = new OpenLayers.Format.WKT();
        var features = wkt.read(text);
        wktLayer.addFeatures(features);
        
        // Dump the vector layer features to WKt format
        var currentWkt = wkt.write(wktLayer.features);
        dijit.byId('wktFeatures').set('value', currentWkt);
    }
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec12"/>How it works...</h3></div></div></div><p>All the format classes are inherited from the<code class="literal"> OpenLayers.Format</code> base class, which defines the basic behavior of the format classes, that is, have a<code class="literal"> read</code> and a<code class="literal"> write</code> method.<a class="indexterm" id="id114"/>
</p><p>The<code class="literal"> read()</code> method is supposed to read data in some format (a JSON string, a WKT string, and so on) and return an array of features as instances of the<code class="literal"> OpenLayers.Feature.Vector</code> class.</p><p>The<code class="literal"> write()</code> method, on the other hand, receives an array of features and returns a string that represents the desired format.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note30"/>Note</h3><p>Depending on the format subclass, the<code class="literal"> read</code> and<code class="literal"> write</code> methods can accept additional parameters. Always be careful and read the API documentation.</p></div><p>To read the features from a WKT string, we only need to instantiate the desired format class and call its<code class="literal"> read</code> method by passing a valid string as the argument:</p><div class="informalexample"><pre class="programlisting">        var wkt = new OpenLayers.Format.WKT();
        var features = wkt.read(text);
        wktLayer.addFeatures(features);
</pre></div><p>Then, we get the current features of the vector layer and convert them to a WKT representation by passing them to the<code class="literal"> write</code> method:</p><div class="informalexample"><pre class="programlisting">        // Dump the vector layer features to WKt format
        var currentWkt = wkt.write(wktLayer.features);
        dijit.byId('wktFeatures').set('value', currentWkt);
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec13"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding a GML layer</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Reading features directly using Protocols</em></span> recipe<a class="indexterm" id="id115"/></li></ul></div></div></div></div>
<div class="section" title="Adding markers to the map"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec06"/>Adding markers to the map</h1></div></div></div><p>Markers are widely used in web mapping applications. They allow us to quickly identify points of interest (POI) by showing an icon at the desired place.<a class="indexterm" id="id116"/>
</p><p>This recipe shows how to add markers to our maps by using the<code class="literal"> OpenLayers.Marker</code> and<code class="literal"> OpenLayers.Layer.Markers</code> classes.</p><div class="mediaobject"><img alt="Adding markers to the map" src="graphics/7843_03_03.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by creating an HTML page with dependencies on the OpenLayers library. Add the<code class="literal"> div</code> element that will hold the map:<div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_markers" style="width: 100%; height: 100%;"&gt;&lt;/div&gt;

Create the map instance, add a base layer and a layer switcher control:
&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;

    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_markers");    
    
    layer = new OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(layer);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 3);
</pre></div></li><li class="listitem">Now, add a new kind of layer,<code class="literal"> OpenLayers.Layer.Markers</code>, specially designed to contain the<code class="literal"> OpenLayers.Marker</code> instances:<a class="indexterm" id="id117"/><div class="informalexample"><pre class="programlisting">    var markers = new 
        OpenLayers.Layer.Markers("Markers");
    map.addLayer(markers);
</pre></div></li><li class="listitem">We will now create markers at random places by using a random icon from an array:<div class="informalexample"><pre class="programlisting">    // Create some random markers with random icons
    var icons = [
         // Here goes an array of image file names
    ];

    for(var i=0; i&lt; 150; i++) {
        // Compute a random icon and lon/lat position.
        var icon = Math.floor(Math.random() * 
            icons.length);
        var px = Math.random() * 360 - 180;
        var py = Math.random() * 170 - 85;
    
        // Create size, pixel and icon instances
        var size = new OpenLayers.Size(32, 37);
        var offset = new OpenLayers.Pixel(-(size.w/2), 
            -size.h);
        var icon = new OpenLayers.Icon('./recipes/data/
            icons/'+icons[icon], size, offset);
        icon.setOpacity(0.7);
        
        // Create a lonlat instance and transform it to 
        // the map projection.
        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new 
            OpenLayers.Projection("EPSG:4326"), new 
            OpenLayers.Projection("EPSG:900913"));
        
        // Add the marker
        var marker = new OpenLayers.Marker(lonlat, icon);
        
        // Event to handler when the mouse is over
        // Inflate the icon and change its opacity
        marker.events.register("mouseover", marker, 
            function() {
            console.log("Over the marker "+this.id+" 
                at place "+this.lonlat);
            this.inflate(1.2);
            this.setOpacity(1);
        });
        // Event to handler when the mouse is out
        // Inflate the icon and change its opacity
        marker.events.register("mouseout", marker, 
            function() {
            console.log("Out the marker "+this.id+" at 
                place "+this.lonlat);
            this.inflate(1/1.2);
            this.setOpacity(0.7);
        });
        
        markers.addMarker(marker);
    }
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec15"/>How it works...</h3></div></div></div><p>The class<code class="literal"> OpenLayers.Layer.Markers</code> is a direct subclass of the<code class="literal"> OpenLayers.Layer</code> base class, and is specially designed to contain markers.</p><p>On the other hand, a marker is represented by instances of the class<code class="literal"> OpenLayers. Layer.Markers</code>. Every marker has an associated point, expressed with an instance of the<code class="literal"> OpenLayers.LonLat</code> class, and an icon using an instance of<code class="literal"> OpenLayers.Icon</code>.</p><p>An icon requires a<span class="emphasis"><em> URL</em></span> of the image to be loaded, a<span class="emphasis"><em> size</em></span> expressed as an instance of<code class="literal"> OpenLayers.Size</code>, and an<span class="emphasis"><em> offset</em></span> expressed as an instance of<code class="literal"> OpenLayers.Pixel</code>.</p><p>In addition, for each marker we have registered two listeners, one to know when the mouse is over and one to know when it leaves the marker. In this way, we can modify the size and opacity of the marker to highlight when the mouse has selected or deselected it.</p><p>Inside the handler functions, we have made use of the methods<code class="literal"> inflate()</code>, to change the size of the icon augmenting its proportions, and<code class="literal"> setOpacity()</code>, to change the icon opacity:<a class="indexterm" id="id119"/>
</p><div class="informalexample"><pre class="programlisting">        marker.events.register("mouseover", marker, function() {
            console.log("Over the marker "+this.id+" at place "+this.lonlat);
            this.inflate(1.2);
            this.setOpacity(1);
        });
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note31"/>Note</h3><p>For beginners in JavaScript, remember the object that calls the anonymous function that handles the marker event is the marker itself. Because the<code class="literal"> this</code> keyword is referencing the marker with which we can call the<code class="literal"> inflate()</code> or<code class="literal"> setOpacity()</code> methods.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec16"/>There's more...</h3></div></div></div><p>The use of markers through the<code class="literal"> OpenLayers.Marker</code> and<code class="literal"> OpenLayers.Layer.Markers</code> classes is not the only way we can show POIs in our maps.</p><p>As you can see in the<span class="emphasis"><em> Using point features as markers</em></span> recipe, we can also use features to show POIs as an alternative that can be improved by the use of strategies, formats, and so on.</p><p>In addition, OpenLayers offers some classes, such as<code class="literal"> OpenLayers.Layer.GeoRSS</code> or<code class="literal"> OpenLayers.Layer.Text</code>, that create markers automatically from the GeoRSS and CSV files respectively. They are relatively simple and are implemented for a specific usage and, most probably, you will soon need more flexibility than offered by those classes.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec17"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Using point features as markers</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Reading features directly using Protocol</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Using point features as markers"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec07"/>Using point features as markers</h1></div></div></div><p>Displaying markers is not only limited to using the<code class="literal"> OpenLayers.Marker</code> and<code class="literal"> OpenLayers.Layer.Markers</code> classes.<a class="indexterm" id="id120"/>
</p><p>A marker can be understood as a point of interest (POI) where we place an icon to identify it and has some information associated with it: a monument, a parking area, a bridge, and so on.<a class="indexterm" id="id121"/>
</p><p>In this recipe, we will learn how to use these features with a point geometry type associated to create markers.</p><div class="mediaobject"><img alt="Using point features as markers" src="graphics/7843_03_04.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once you have created the right HTML file with OpenLayers dependencies, add a<code class="literal"> div</code> element to hold the map:<div class="informalexample"><pre class="programlisting">&lt;div id="ch3_feature_markers" style="width: 100%; 
height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Start initializing the map instance and add a base layer and control:<div class="informalexample"><pre class="programlisting">    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_feature_markers");    
    
    var layer = new 
        OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(layer);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Next, add a vector layer that will contain a set of random markers:<div class="informalexample"><pre class="programlisting">    var pointLayer = new 
        OpenLayers.Layer.Vector("Features", {
        projection: "EPSG:933913"
    });
    map.addLayer(pointLayer);
</pre></div></li><li class="listitem">Create some random points. To improve the performance we add all the points to an array and then to the vector layer all at once with the<code class="literal"> addFeatures</code> method:<a class="indexterm" id="id122"/><div class="informalexample"><pre class="programlisting">    // Create some random feature points
    var pointFeatures = [];
    for(var i=0; i&lt; 150; i++) {
        var px = Math.random() * 360 - 180;
        var py = Math.random() * 170 - 85;
    
        // Create a lonlat instance and transform it 
        // to the map projection.
        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new 
            OpenLayers.Projection("EPSG:4326"), 
            new OpenLayers.Projection("EPSG:900913"));
        
        var pointGeometry = new 
            OpenLayers.Geometry.Point
            (lonlat.lon, lonlat.lat);
        var pointFeature = new 
            OpenLayers.Feature.Vector(pointGeometry);

        pointFeatures.push(pointFeature);
    }
    // Add features to the layer
    pointLayer.addFeatures(pointFeatures); 
</pre></div></li><li class="listitem">Now, attach two event listeners to the vector layer for the<code class="literal"> featureselected</code> and<code class="literal"> featureunselected</code> events. The listener will be responsible for changing the feature style:<div class="informalexample"><pre class="programlisting">    // Event handler for feature selected
    pointLayer.events.register("featureselected", null, 
        function(event){
        var layer = event.feature.layer;
        event.feature.style = {
            fillColor: '#ff9900',
            fillOpacity: 0.7,
            strokeColor: '#aaa',
            pointRadius: 12
        };
        layer.drawFeature(event.feature);
    });
    // Event handler for feature unselected
    pointLayer.events.register("featureunselected", null, 
        function(event){
        var layer = event.feature.layer;
        event.feature.style = null;
        event.feature.renderIntent = null;
        layer.drawFeature(event.feature);
    });
</pre></div></li><li class="listitem">Finally, we need to attach a<code class="literal"> SelectFeature</code> control to the map, and reference the vector layer:<a class="indexterm" id="id123"/><div class="informalexample"><pre class="programlisting">    // Add select feature control required to trigger events on the vector layer.
    var selectControl = new OpenLayers.Control.SelectFeature(pointLayer);
    map.addControl(selectControl);
    selectControl.activate();
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec19"/>How it works...</h3></div></div></div><p>The idea is simple, add point features to the layer and listen for their selection event to change the style.</p><p>In a different way than working with the<code class="literal"> OpenLayers.Marker</code> instances, we need to attach listeners to the vector layer and not to the feature itself, using the following code:</p><div class="informalexample"><pre class="programlisting">    pointLayer.events.register("featureselected", null, 
        function(event){
        // Code here
    });
</pre></div><p>Within the listener function, we can access the selected feature or the vector layer it belongs to with the<code class="literal"> event</code> variable:</p><div class="informalexample"><pre class="programlisting">        var layer = event.feature.layer;
        event.feature.style = {
            fillColor: '#ff9900',
            fillOpacity: 0.7,
            strokeColor: '#aaa',
            pointRadius: 12
        };
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note32"/>Note</h3><p>In<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>,<span class="emphasis"><em> Styling Features</em></span>, we will learn more about styling features and improving its look using images, in a similar way to the<code class="literal"> OpenLayers.Marker</code> class.</p></div><p>Once the feature style is changed, we can call<code class="literal"> drawFeature()</code> on the vector layer to refresh the feature on the map:<a class="indexterm" id="id124"/>
</p><div class="informalexample"><pre class="programlisting">        layer.drawFeature(event.feature);
</pre></div><p>To allow the vector layer to trigger events, we need to attach a<code class="literal"> SelectFeature</code> control to the map, reference the vector layer, and activate it. Without it the listeners will never be invoked.</p><div class="informalexample"><pre class="programlisting">    var selectControl = new OpenLayers.Control.SelectFeature(pointLayer);
    map.addControl(selectControl);
    selectControl.activate();
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec20"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding markers to the map</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Working with popups</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Using the cluster strategy</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Working with popups"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec08"/>Working with popups</h1></div></div></div><p>A common charecteristic of web mapping applications is the ability to show information related to the features the map contains. By feature we mean any real phenomenon or aspect we can visually represent with points, lines, polygons, and so on.<a class="indexterm" id="id125"/>
<a class="indexterm" id="id126"/>
</p><p>Of course we can select a feature, retrieve its associated information and show it anywhere in our application layout, but the most common way to show it is by using popups.</p><div class="mediaobject"><img alt="Working with popups" src="graphics/7843_03_05.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file with OpenLayers dependencies. Then add the<code class="literal"> div</code> element to hold the map:<a class="indexterm" id="id127"/><div class="informalexample"><pre class="programlisting">&lt;div id="ch3_popups" style="width: 100%; height: 100%;"&gt;
&lt;/div&gt;
</pre></div></li><li class="listitem">Within the JavaScript section, initialize the map and add a base layer:<div class="informalexample"><pre class="programlisting">    var map = new OpenLayers.Map("ch3_popups");    
    var layer = new 
        OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(layer);
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Create a vector layer and add some features to it:<div class="informalexample"><pre class="programlisting">    var pointLayer = new 
        OpenLayers.Layer.Vector("Features", {
        projection: "EPSG:900913"
    });
    map.addLayer(pointLayer);
</pre></div></li><li class="listitem">Next, add some random features to the vector layer:<div class="informalexample"><pre class="programlisting">    var pointFeatures = [];
    for(var i=0; i&lt; 150; i++) {
        var icon = Math.floor(Math.random() * 
            icons.length);
        var px = Math.random() * 360 - 180;
        var py = Math.random() * 170 - 85;
    
        // Create a lonlat instance and transform it to 
        // the map projection.
        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new 
            OpenLayers.Projection("EPSG:4326"), new 
            OpenLayers.Projection("EPSG:900913"));
        
        var pointGeometry = new 
            OpenLayers.Geometry.Point(lonlat.lon, 
            lonlat.lat);
        var pointFeature = new 
            OpenLayers.Feature.Vector(pointGeometry, 
            null, {
            pointRadius: 16,
            fillOpacity: 0.7,
            externalGraphic: 
                'http://localhost:8080/
                openlayers-cookbook/recipes/data/
                icons/'+icons[icon]
        });

        pointFeatures.push(pointFeature);
    }
    // Add features to the layer
    pointLayer.addFeatures(pointFeatures); 
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title">Note</h3><p>You need to change the previous URL to the right address of your custom server.</p></div></li><li class="listitem">Finally, add the code responsible to manage the feature selection to show the popup:<div class="informalexample"><pre class="programlisting">// Add select feature control required to trigger events on the vector layer.    
    var selectControl = new 
        OpenLayers.Control.SelectFeature(pointLayer, {
        hover: true,
        onSelect: function(feature) {
            var layer = feature.layer;
            feature.style.fillOpacity = 1;
            feature.style.pointRadius = 20;
            layer.drawFeature(feature);
            
            var content = "&lt;div&gt;&lt;strong&gt;Feature:&lt;/strong&gt; 
                &lt;br/&gt;" + feature.id +
                "&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;Location:&lt;/strong&gt; 
                &lt;br/&gt;" + feature.geometry +"&lt;/div&gt;";
            
            var popup = new OpenLayers.Popup.FramedCloud(
            feature.id+"_popup", 
            feature.geometry.getBounds().
            getCenterLonLat(),
            new OpenLayers.Size(250, 100),
            content,
            null, 
            false, 
            null);
            feature.popup = popup;
            map.addPopup(popup);
        },
        onUnselect: function(feature) {
            var layer = feature.layer;
            feature.style.fillOpacity = 0.7;
            feature.style.pointRadius = 16;
            feature.renderIntent = null;
            layer.drawFeature(feature);
            
            map.removePopup(feature.popup);
        }
    });
    map.addControl(selectControl);
    selectControl.activate(); 
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec22"/>How it works...</h3></div></div></div><p>The first thing we did, after creating the vector layer, was the creation of some random point features.<a class="indexterm" id="id129"/>
</p><p>Because we are computing random latitude and longitude values in decimal degrees ("EPSG:4326" projection), we need to translate it to the projection used by the map. In this case, because<code class="literal"> OpenStreetMap</code> is the base layer, it applies an<code class="literal">"EPSG:900913"</code> projection as the map's projection.</p><div class="informalexample"><pre class="programlisting">        var lonlat = new OpenLayers.LonLat(px, py);
        lonlat.transform(new OpenLayers.Projection("EPSG:4326"), 
            new OpenLayers.Projection("EPSG:900913"));
        
        var pointGeometry = new 
            OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat);
        var pointFeature = new 
            OpenLayers.Feature.Vector(pointGeometry, null, {
            pointRadius: 16,
            fillOpacity: 0.7,
            externalGraphic: 'http://localhost:8080/
                openlayers-cookbook/recipes/
                data/icons/'+icons[icon]
        });
</pre></div><p>Here we are creating features with a custom style. The constructor of the<code class="literal"> OpenLayers.Feature.Vector</code> class accepts three parameters: a<span class="emphasis"><em> geometry</em></span> parameter, which is mandatory, and two optional parameters, the feature<span class="emphasis"><em> attributes</em></span> and the feature<span class="emphasis"><em> style</em></span>.</p><p>Our features have no special attributes so we have passed a<code class="literal"> null</code> value but, on the other hand, we have used a custom style to show an icon image instead of a simple point to represent them.<a class="indexterm" id="id130"/>
</p><p>Once we have the features we want, it is time to show a popup with some nice description when a feature is selected.</p><p>To achieve this, we have used the<code class="literal"> SelectFeature</code> control. Given a layer, this control allows the user to select features. We can customize the behavior of the control with the<code class="literal"> options</code> argument:</p><div class="informalexample"><pre class="programlisting">var selectControl = new 
    OpenLayers.Control.SelectFeature(pointLayer, {
    hover: true,
    onSelect: function(feature) { ... },
    onUnselect: function(feature) { ... }
});
</pre></div><p>In this recipe we have used the following three options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hover:</code> It indicates that the features must be selected or unselected without the need of clicking on it, and by simply moving the mouse over the button.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onSelect:</code> This function is executed when a feature is selected. It receives the selected feature as an argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onUnselect:</code> This function is executed when a feature is unselected. It receives the unselected feature as an argument.</li></ul></div><p>Now let's take a look at how to create the popups.</p><p>The important point to be noted here is that popups are added to the map. They are not added to a feature and nor to a layer. So to show or hide a popup, we simply need to add or remove it from the map with the methods<code class="literal"> addPopup()</code> or<code class="literal"> removePopup()</code>.</p><p>OpenLayers offers some classes to be used as popups, but all of them are inherited from the base class<code class="literal"> OpenLayers.Popup</code>.</p><p>We have chosen the<code class="literal"> OpenLayers.Popup.FramedCloud</code> subclass, which is a visually decent styled popup. The constructor requires the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id:</code> A string that identifies the popup among all the popups that can exist, which are attached to the map</li><li class="listitem" style="list-style-type: disc"><code class="literal">lonlat:</code> The location where the popup must appear</li><li class="listitem" style="list-style-type: disc"><code class="literal">contentSize:</code> The dimensions of the popup, as an instance of the<code class="literal"> OpenLayers.Size</code> class</li><li class="listitem" style="list-style-type: disc"><code class="literal">contentHTML:</code> The HTML string to be put as content</li><li class="listitem" style="list-style-type: disc"><code class="literal">anchor:</code> An object where the popup will be anchored</li><li class="listitem" style="list-style-type: disc"><code class="literal">closeBox:</code> Boolean indicating if the close buttons must be shown</li><li class="listitem" style="list-style-type: disc"><code class="literal">closeBoxCallback:</code> A function that will be executed when the user clicks on the close button<a class="indexterm" id="id131"/></li></ul></div><p>With all these parameters, our code to create a<code class="literal"> FramedCloud</code> popup looks as follows:</p><div class="informalexample"><pre class="programlisting">            var popup = new OpenLayers.Popup.FramedCloud(
            feature.id+"_popup", 
            feature.geometry.getBounds().getCenterLonLat(),
            new OpenLayers.Size(250, 100),
            content,
            null, 
            false, 
            null);
</pre></div><p>Once created, we add it to the map, which makes it visible automatically:</p><div class="informalexample"><pre class="programlisting">            feature.popup = popup;
            map.addPopup(popup);
</pre></div><p>We have also stored a reference of the popup within the feature. In this way, we can easily find a reference to the popup in the function that is executed when the feature is unselected and remove it from the map:</p><div class="informalexample"><pre class="programlisting">            map.removePopup(feature.popup);
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note33"/>Note</h3><p>As a note, the map's<code class="literal"> addPopup()</code> method has a second and optional parameter<code class="literal"> exclusive</code>, which if set, automatically removes all existing popups in the map when a new one is added.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec23"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding markers to the map</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Using point features as markers</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Adding features from a WFS server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec09"/>Adding features from a WFS server</h1></div></div></div><p>The<span class="strong"><strong> Web Feature Service (WFS)</strong></span> is an OGC standard, which provides independent platform calls to request geographical features to a server. In practice, it means a client makes a HTTP request to a server that implements the WFS standard and gets a set of features in the GML (Geographic Markup Language,<a class="ulink" href="http://en.wikipedia.org/wiki/Geography_Markup_Language)"> http://en.wikipedia.org/wiki/Geography_Markup_Language)</a> format.<a class="indexterm" id="id132"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note34"/>Note</h3><p>A nice introduction to WFS can be found in the tutorial about WFS available at<a class="ulink" href="http://https://www.e-education.psu.edu/geog585/book/export/html/1724"> https://www.e-education.psu.edu/geog585/book/export/html/1724</a>. If you want to learn more about this, there is a complete specification on the OGC site<a class="ulink" href="http://www.opengeospatial.org/standards/wfs"> http://www.opengeospatial.org/standards/wfs</a>.</p></div><p>From the OpenLayers point of view, the WFS is nothing more than another data source we can read to fill a vector layer.</p><p>Before continuing, there is an important point to take into account. Most of the requests made by OpenLayers when data is loaded, say GML, KML, or GeoRSS files, are made asynchronously through the helper class<code class="literal"> OpenLayers.Request</code>.</p><p>Any JavaScript call is limited by the security model imposed by the browser, which avoids cross domain requests. This means you can only make requests to the same server that the web page originally came from.</p><p>There are different ways to avoid this fact, but a simple one is the use of a proxy on the server side.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note35"/>Note</h3><p>You can read a clearer explanation at</p><p>
<a class="ulink" href="http://developer.yahoo.com/javascript/howto-proxy.html"> http://developer.yahoo.com/javascript/howto-proxy.html</a>.</p></div><p>The idea of a proxy is simple, instead of making a request directly to a cross domain we make a request to a script on the same domain, which is responsible for making the cross domain request and returning the results.</p><p>A script, say PHP, Python, or Java servlet, is not limited by the cross domain requests. It is only security imposed by the browser in the JavaScript calls.</p><p>OpenLayers offers a proxy implementation as a Python script that we can use in our application. It can be found in the<code class="literal"> examples/proxy.cgi</code> file in the source code bundle.</p><p>It is not the only possibility. For this recipe we will be using a PHP proxy file (see the<code class="literal"> utils/proxy.php</code> file in the book's source code) from the<code class="literal"> MapBuilder</code> project.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a HTML file, set the OpenLayers dependencies, and add a<code class="literal"> div</code> element to hold the map:<a class="indexterm" id="id133"/><div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt; 
&lt;div id="ch3_wfs" style="width: 100%; 
    height: 100%;"&gt;&lt;/div&gt; 
</pre></div></li><li class="listitem">Set the<code class="literal"> OpenLayers.ProxyHost</code> variable to our proxy URL:<div class="informalexample"><pre class="programlisting">&lt;!-- The magic comes here --&gt; 
&lt;script type="text/javascript"&gt; 
    OpenLayers.ProxyHost = "./utils/proxy.php?url="; 
</pre></div></li><li class="listitem">Initialize the map and add a base layer:<div class="informalexample"><pre class="programlisting">    // Create the map using the specified DOM element 
    var map = new OpenLayers.Map("ch3_wfs");    
    
    var baseLayer = new 
        OpenLayers.Layer.OSM("OpenStreetMap"); 
    map.addLayer(baseLayer); 
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher()); 
    map.setCenter(new OpenLayers.LonLat(0,0), 2); 
</pre></div></li><li class="listitem">Finally, create a vector layer that uses the WFS protocol to access the data source:<div class="informalexample"><pre class="programlisting">    var statesLayer = new 
        OpenLayers.Layer.Vector("States", { 
        protocol: new OpenLayers.Protocol.WFS({ 
            url: "http://demo.opengeo.org/geoserver/wfs", 
            featureType: "states", 
            featureNS: "http://www.openplans.org/topp" 
        }), 
        strategies: [new OpenLayers.Strategy.BBOX()] 
    }); 
    map.addLayer(statesLayer); 
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec25"/>How it works...</h3></div></div></div><p>The first important step is to set the<code class="literal"> OpenLayers.ProxyHost</code> variable:<a class="indexterm" id="id134"/>
</p><div class="informalexample"><pre class="programlisting">    OpenLayers.ProxyHost = "./utils/proxy.php?url="; 
</pre></div><p>Most of the JavaScript requests in OpenLayers are made through the helper class<code class="literal"> OpenLayers.Request</code>, which checks if the previous variable is set. If so, all requests are made using the proxy.</p><p>After that, the main action in this recipe is the creation of a vector layer filling its data from a WFS server:<a class="indexterm" id="id135"/>
</p><div class="informalexample"><pre class="programlisting">    var statesLayer = new OpenLayers.Layer.Vector("States", { 
        protocol: new OpenLayers.Protocol.WFS({ 
            url: "http://demo.opengeo.org/geoserver/wfs", 
            featureType: "states", 
            featureNS: "http://www.openplans.org/topp" 
        }), 
        strategies: [new OpenLayers.Strategy.BBOX()] 
    }); 
</pre></div><p>As you can see, the only thing to do is set the protocol to be used by the layer. In this case, we use an instance of the<code class="literal"> OpenLayers.Protocol.WFS</code> class.</p><p>The WFS protocol constructor has many parameters but the most important ones are as follows:<a class="indexterm" id="id136"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">url:</code> The URL to the WFS server</li><li class="listitem" style="list-style-type: disc"><code class="literal">featureType:</code> The feature to be queried</li><li class="listitem" style="list-style-type: disc"><code class="literal">featureNS:</code> The namespace of the feature</li></ul></div><p>Other important options and, more or less, the commonly used ones are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">geometryName:</code> Specifies the name of the attribute that stores the feature's geometry information. By default it is<code class="literal"> the_geom</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">srsName:</code> The spatial reference system used in the requests. By default it is<code class="literal">"EPSG:4326".</code></li></ul></div><p>Finally, the vector layer uses an<code class="literal"> OpenLayers.Strategy.BBOX</code> strategy, which is responsible to refresh the content of the layer every time the map's viewport changes.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec26"/>There's more...</h3></div></div></div><p>Many times the map server that supports WMS and WFS protocols, can serve the same information both in raster and vector formats.</p><p>Imagine a set of regions stored in PostgreSQL/PostGIS and a map server, such as GeoServer, with a layer of countries configured to be served both as raster images via WMS requests, or as vector GML format using WFS requests.</p><p>In these cases, if we have previously created an<code class="literal"> OpenLayers.Layer.WMS</code> layer, there is an easy way to create a new WFS protocol instance with the static method<code class="literal"> OpenLayers.Protocol.WFS.fromWMSLayer</code>.</p><p>Given a WMS layer and some options, the method initializes an<code class="literal"> OpenLayers.Protocol.WFS</code> instance, supposing the WFS<code class="literal"> url, srsName</code>, and other properties are the same as in the WMS instance.<a class="indexterm" id="id137"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec27"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Filtering features in WFS requests</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Working with popups</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Using point features as markers</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Reading features directly using Protocols</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Using the cluster strategy"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec10"/>Using the cluster strategy</h1></div></div></div><p>As we have seen in the chapter's introduction, the behavior of vector layers is determined by the strategies we attach to them.<a class="indexterm" id="id138"/>
</p><p>Imagine a scenario where we want to show all the museums in every city around the world. What will happen when the user navigates within the map and sets a zoom level to see the whole world? We simply see a cloud of points, all at the same place.<a class="indexterm" id="id139"/>
</p><p>The solution to this problem is to cluster the features on each zoom level.</p><div class="mediaobject"><img alt="Using the cluster strategy" src="graphics/7843_03_06.jpg"/></div><p>This recipe shows how easy it is to use the cluster strategy on a vector layer, which is responsible for clustering the features to avoid a situation similar to the one we just mentioned.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file and insert the following code in it:<a class="indexterm" id="id140"/><div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_cluster" style="width: 100%; 
    height: 100%;"&gt;&lt;/div&gt;

&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_cluster");    
    
    layer = new OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(layer);
    
    map.addControl(new 
       OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">As you can see the vector layer is using two strategies:<div class="informalexample"><pre class="programlisting">    // World Cities
    var citiesLayer = new OpenLayers.Layer.Vector("World 
        Cities (GeoJSON)", {
        protocol: new OpenLayers.Protocol.HTTP({
            url: "http://localhost:8080/
            openlayers-cookbook/recipes/
            data/world_cities.json",
            format: new OpenLayers.Format.GeoJSON()
        }),
        strategies: [
            new OpenLayers.Strategy.Fixed(), 
            new OpenLayers.Strategy.Cluster({distance: 
                15})
        ]
    });
    map.addLayer(citiesLayer);
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec29"/>How it works...</h3></div></div></div><p>A vector layer can have more than one strategy associated with it. In this recipe we have added the<code class="literal"> OpenLayers.Strategy.Fixed</code> strategy, which loads the layer content only once, and the<code class="literal"> OpenLayers.Strategy.Cluster</code> strategy, which automatically clusters the features to avoid an ugly cloud of features caused by overlapping:<a class="indexterm" id="id141"/>
</p><div class="informalexample"><pre class="programlisting">        strategies: [
            new OpenLayers.Strategy.Fixed(), 
            new OpenLayers.Strategy.Cluster({distance: 15})
        ]
</pre></div><p>Every time we change the zoom level, the cluster strategy computes the distance among all features and adds all the features that conform to some parameters of the same cluster.</p><p>The main parameters we can use to control the behavior of the cluster strategy are as follows:<a class="indexterm" id="id142"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">distance:</code> The distance in pixels between features to be considered that they are in the same cluster. By default it is set to 20 pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">threshold:</code> If the number of features in a cluster is less than the threshold, then they will be added directly to the layer instead of the cluster</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec30"/>There's more...</h3></div></div></div><p>OpenLayers has a set of basic but very common strategies that we can combine in vector layers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Box</em></span> strategy, to request features every time the map's viewport changes<a class="indexterm" id="id143"/></li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Refresh</em></span> strategy, to update the layer features periodically after some time<a class="indexterm" id="id144"/></li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Filter</em></span> strategy to limit the features the layer must request<a class="indexterm" id="id145"/></li></ul></div><p>We encourage those more advanced JavaScript readers, to take a close look at the OpenLayers source code and learn more about how strategies work.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec31"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating features programmatically</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding features from a WFS server</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Filtering features in WFS requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec11"/>Filtering features in WFS requests</h1></div></div></div><p>A key concept when working against a WFS server is the concept of filters.<a class="indexterm" id="id146"/>
</p><p>Among many other specifications, the OGC has defined a standard that defines the notation to be used for filtering, the<span class="emphasis"><em> Filter Encoding Specification</em></span>.</p><p>Filters are similar to the<code class="literal"> WHERE</code> clause in SQL and allow us to select features that meet some conditions.<a class="indexterm" id="id147"/>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note36"/>Note</h3><p>You can find the Filter Encoding Specification on the OGC website available at<a class="ulink" href="http://www.opengeospatial.org/standards/filter"> http://www.opengeospatial.org/standards/filter</a>.</p><p>As we will see in<a class="link" href="ch07.html" title="Chapter 7. Styling Features"> Chapter 7</a>,<span class="emphasis"><em> Styling Features</em></span>, filters are not only used to query features but are also used to define rules to style them.</p></div><p>OpenLayers offers a set of classes suited to work with the filters the specification defines: property filters <code class="literal">(PropertyIsEqualTo, PropertyIsLessThan</code>, and so on), logical filters, and spatial filters <code class="literal">(Intersects, Within</code>, and so on).<a class="indexterm" id="id148"/>
</p><div class="mediaobject"><img alt="Filtering features in WFS requests" src="graphics/7843_03_07.jpg"/></div><p>This recipe shows a basic usage of the filter classes to restrict the features queried on a WFS server.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Getting ready</h2></div></div></div><p>We are going to query a remote WFS server, so we will require a proxy script that was configured in our own server to make the real WFS request.<a class="indexterm" id="id149"/>
</p><p>See the<span class="emphasis"><em> Adding features from a WFS server</em></span> recipe in this chapter for more information about proxy scripts.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file and insert the following code:<div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_filtering" style="width: 100%; 
    height: 100%;"&gt;&lt;/div&gt;

&lt;!-- The magic comes here --&gt;
&lt;script type="text/javascript"&gt;
</pre></div></li><li class="listitem">The first step in the JavaScript code is to set the proxy script required to solve the cross domain request policy:<div class="informalexample"><pre class="programlisting">    OpenLayers.ProxyHost = "./utils/proxy.php?url=";

    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_filtering"); 
</pre></div></li><li class="listitem">Set OSM as the base layer:<div class="informalexample"><pre class="programlisting">    var baseLayer = new 
        OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(baseLayer);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
</pre></div></li><li class="listitem">To center the map's viewport in a concrete location we need to transform the desired location from latitude/longitude to the projection used by the base layer, that is, the projection used by the map:<div class="informalexample"><pre class="programlisting">    var center = new OpenLayers.LonLat(-100, 41);
    center.transform(new 
        OpenLayers.Projection("EPSG:4326"), 
        map.getProjectionObject());
    map.setCenter(center, 4);
</pre></div></li><li class="listitem">Add a vector layer, which requests some states:<div class="informalexample"><pre class="programlisting">    // Filter features with the query.
    var statesLayer = new 
        OpenLayers.Layer.Vector("States", {
        protocol: new OpenLayers.Protocol.WFS({
            url: "http://demo.opengeo.org/geoserver/wfs",
            featureType: "states",
            featureNS: "http://www.openplans.org/topp"
        }),
        strategies: [new OpenLayers.Strategy.BBOX()],
        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.
                        Comparison.GREATER_THAN,
                    property: "MALE",
                    value: "700000"
                }),
                new OpenLayers.Filter.Spatial({
                    type: 
                        OpenLayers.Filter.Spatial.WITHIN,
                    value: OpenLayers.Bounds.fromArray
                        ([-120, 10,-90,50])
                })
            ]
        })
    });

    map.addLayer(statesLayer);    
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec34"/>How it works...</h3></div></div></div><p>The main part of this recipe is the code involved in the instantiation of the vector layer. The constructor receives two parameters, the name and an options object. Within the options object we have set three properties:</p><div class="informalexample"><pre class="programlisting">    var statesLayer = new OpenLayers.Layer.Vector("States", {
        protocol: ...,
        strategies: ...,
        filter: ...
    });
</pre></div><p>Let's take a look at the protocol, strategies, and filter used in the layer. We are querying a WFS server, so we need to use an<code class="literal"> OpenLayers.Protocol.WFS</code> instance to talk to it:</p><div class="informalexample"><pre class="programlisting">OpenLayers.Protocol.WFS instance to talk to it:
        protocol: new OpenLayers.Protocol.WFS({
            url: "http://demo.opengeo.org/geoserver/wfs",
            featureType: "states",
            featureNS: "http://www.openplans.org/topp"
        })
</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;" title="Note"><h3 class="title"><a id="note37"/>Note</h3><p>In the same way as WMS, the WFS server has the<code class="literal"> GetCapabilities</code> action, which allows the client to know the capabilities it provides: kind of features, available operations, and so on.</p><p>Check the response obtained from the server used in the recipe:<a class="ulink" href="http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities"> http://demo.opengeo.org/geoserver/wfs?request=GetCapabilities</a>.</p></div><p>As a strategy, we want the layer to refresh the features every time the map's viewport is modified, so<code class="literal"> OpenLayers.Strategy.BBOX</code> is the right instance:<a class="indexterm" id="id151"/>
</p><div class="informalexample"><pre class="programlisting">        strategies: [new OpenLayers.Strategy.BBOX()],
</pre></div><p>Finally, there is a<code class="literal"> filter</code> property, which performs all the magic in this recipe. We have tried to use a more or less complete filter, which includes one logical filter, one comparison filter, and one spatial filter:</p><div class="informalexample"><pre class="programlisting">        filter: new OpenLayers.Filter.Logical({
            type: OpenLayers.Filter.Logical.AND,
            filters: [
                new OpenLayers.Filter.Comparison({
                    type: OpenLayers.Filter.
                        Comparison.GREATER_THAN,
                    property: "MALE",
                    value: "700000"
                }),
                new OpenLayers.Filter.Spatial({
                    type: OpenLayers.Filter.Spatial.WITHIN,
                    value: OpenLayers.Bounds.fromArray
                        ([-120, 10,-90,50])
                })
            ]
        })
</pre></div><p>Depending on the kind of filter, they can have different properties with different values allowed.</p><p>Our filter queries for all states in the WFS server, on the specified layer, that are within the bounding box defined by<code class="literal"> [-120, 10,-90,50]</code> and have a<code class="literal"> MALE</code> population greater than<code class="literal"> 700,000</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec35"/>There's more...</h3></div></div></div><p>The<code class="literal"> OpenLayers.Protocol</code> class has a<code class="literal"> defaultFilter</code> property, which allows us to set a default filter for the requests.</p><p>The filters specified in the vector layer, will be the logical AND operator, which is merged before making the request.<a class="indexterm" id="id152"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec36"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding features from a WFS server</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Reading features directly using Potocols</em></span> recipe</li></ul></div></div></div></div>
<div class="section" title="Reading features directly using Protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec12"/>Reading features directly using Protocols</h1></div></div></div><p>OpenLayers allows us to read data from different origins and sources. As we have described in the chapter's introduction, OpenLayers offers the helper classes: protocols and formats.<a class="indexterm" id="id153"/>
</p><p>Protocols are designed to simplify the task of retrieving data from different origins: via HTTP, from an WFS server, and so on.<a class="indexterm" id="id154"/>
</p><p>On the other hand, formats simplifies the task of reading from (or writing to) a given data format. It is very common to load data from different origins and know how to work directly with protocols that can incredibly simplify this task.</p><div class="mediaobject"><img alt="Reading features directly using Protocols" src="graphics/7843_03_08.jpg"/></div><p>As an example, this recipe shows how we can add features from different data sources in the same vector layer, by working directly with the protocol instances.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an HTML file and add the OpenLayers dependencies. Then create a<code class="literal"> DOM</code> element to hold the map:<a class="indexterm" id="id155"/><div class="informalexample"><pre class="programlisting">&lt;!-- Map DOM element --&gt;
&lt;div id="ch3_protocol" style="width: 100%; 
    height: 100%;"&gt;&lt;/div&gt;
</pre></div></li><li class="listitem">Next, initialize the map, add some base layer, and center the viewport:<div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    // Create the map using the specified DOM element
    var map = new OpenLayers.Map("ch3_protocol");    
    
    var baseLayer = new 
        OpenLayers.Layer.OSM("OpenStreetMap");
    map.addLayer(baseLayer);
    
    map.addControl(new 
        OpenLayers.Control.LayerSwitcher());
    map.setCenter(new OpenLayers.LonLat(0,0), 2);
</pre></div></li><li class="listitem">Now, create a vector layer:<div class="informalexample"><pre class="programlisting">    var vectorLayer = new 
        OpenLayers.Layer.Vector("Vector Layer");
    map.addLayer(vectorLayer);
</pre></div></li><li class="listitem">Create two protocols pointing to the desired remote files:<div class="informalexample"><pre class="programlisting">    // Create HTTP protocol to read GML file
    var gmlReq = new OpenLayers.Protocol.HTTP({
        url: "http://localhost:8080/
        openlayers-cookbook/recipes/data/
        world_cities.json",
        format: new OpenLayers.Format.GeoJSON(),
        callback: addFeaturesFromResponse
    });
    gmlReq.read();
    
    // Create HTTP protocol to read KML file
    var kmlReq = new OpenLayers.Protocol.HTTP({
        url: "http://localhost:8080/
        openlayers-cookbook/recipes/data/
        global_undersea.kml",
        format: new OpenLayers.Format.KML({
            extractStyles: true,
            extractAttributes: true
        }),
        callback: addFeaturesFromResponse
    });
    kmlReq.read();
</pre></div></li><li class="listitem">Finally, add the callback function to be executed when the protocol instances load data from remote files:<a class="indexterm" id="id156"/><div class="informalexample"><pre class="programlisting">    // Translate features from EPSG:4326 to OSM 
    // projection and add to the layer only 
    // the Point geometry features.
    function addFeaturesFromResponse(response) {
        for(var i=0; i&lt;response.features.length; ++i) {        
            if(response.features[i].
            geometry.CLASS_NAME == 
            "OpenLayers.Geometry.Point") {
                response.features[i].geometry.transform
                (vectorLayer.projection, 
                map.getProjectionObject());
                vectorLayer.addFeatures
                    ([response.features[i]]);
            }
        }
    }
&lt;/script&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec38"/>How it works...</h3></div></div></div><p>The goal of this recipe is to show how we can work directly with a protocol and load content from different data sources on the same vector layer.</p><p>Because of this we have created an empty vector layer, without specifying the protocol and strategy to use:</p><div class="informalexample"><pre class="programlisting">    var vectorLayer = new OpenLayers.Layer.Vector("Vector Layer");
</pre></div><p>After that, we have created an<code class="literal"> OpenLayers.Protocol.HTTP</code> instance that reads a remote<code class="literal"> GeoJSON</code> file:</p><div class="informalexample"><pre class="programlisting">    var gmlReq = new OpenLayers.Protocol.HTTP({
        url: "http://localhost:8080/
            openlayers-cookbook/recipes/data/world_cities.json",
        format: new OpenLayers.Format.GeoJSON(),
        callback: addFeaturesFromResponse
    });
</pre></div><p>Note how we can specify a callback function that will be called once the file is loaded and read it using the desired format. The function receives one parameter of type<code class="literal"> OpenLayers.Protocol.Response</code>, which among others, contains a<code class="literal"> features</code> array property with the set of features read from the file.<a class="indexterm" id="id157"/>
</p><p>To make the protocol start the reading process we simply need to call:</p><div class="informalexample"><pre class="programlisting">gmlReq.read();
</pre></div><p>Finally, let's take a look at the callback function. This function is called when both the protocols finish reading the data. We have implemented it to transform the features to the right projection and add to the vector layer only those of type<code class="literal"> OpenLayers.Geometry.Point:</code>
</p><div class="informalexample"><pre class="programlisting">    function addFeaturesFromResponse(response) {
        for(var i=0; i&lt;response.features.length; ++i) {        
            if(response.features[i].geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {
                response.features[i].geometry.transform(vectorLayer.projection, map.getProjectionObject());
                vectorLayer.addFeatures([response.features[i]]);
            }
        }
    }
</pre></div><p>As we can see, this is another way to filter the content we put in a vector layer, but take into account that the filtering is made on the client side and not on the server side. That means the entire data is transferred from the server to the client.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec39"/>There's more...</h3></div></div></div><p>We would like to mention that in this recipe we do not set the<code class="literal"> OpenLayers.ProxyHost</code> variable. This is because the files we are requesting via AJAX are in the same domain the HTML file is loaded from.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl2sec40"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding a GML layer</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Adding features from a WFS server</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Filtering features in WFS requests</em></span> recipe</li></ul></div></div></div></div></body></html>