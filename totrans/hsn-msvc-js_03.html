<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-42"><a id="_idTextAnchor042"/>3</h1>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>What Do You Need Before Getting Started?</h1>
			<p>The microservice approach does not inherently depend on any specific programming language. You can implement it using different programming languages. The concept of microservices supports using different languages for different services within a single application. This means the choice of programming language for each service can be based on its specific needs and functionalities. For example, you’re able to implement <em class="italic">microservice A</em> using C# but <em class="italic">microservice B</em> using JavaScript. That is the beauty of microservice development, which allows us to bypass programming language barriers.</p>
			<p>This book is about writing microservices in JavaScript. As in any programming language, before implementing the microservice approach, it is best to understand the basics of the given language, which will help us to build better and more effective microservices. The focus of this chapter is to provide the foundation, rather than a comprehensive guide, for the language, along with Node.js. There are a few topics, especially in JavaScript, that need to be reviewed before implementing any microservice applications using the language itself.</p>
			<p>In this chapter, we’re going to explore the following topics:</p>
			<ul>
				<li>JavaScript essentials</li>
				<li>Node.js essentials</li>
			</ul>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>For this chapter, you need the following:</p>
			<ul>
				<li>A browser (select your favorite one)</li>
				<li>Visual Studio Code (or you can use your OS’s default text editor): Simply go to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and install it</li>
				<li><strong class="bold">GitHub</strong>: Go to <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03</a><p class="list-inset">The next chapter will explain the required software installation processes in detail. For now, you can download the GitHub repository source code without using any GitHub commands and experiment with it.</p></li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>JavaScript essentials</h1>
			<p>JavaScript is a popular, single-threaded, synchronous programming language that helps us mostly to <a id="_idIndexMarker145"/>build interactive web applications. Its strength is its ability to mix different programming methods. This mix lets you write code in several ways: focusing on objects, using functions like building blocks, reacting to events, or giving step-by-step instructions, making your code clear and easier to handle. The JavaScript you use in the browser or in Node.js is not completely <em class="italic">native</em>. That is why we need to differentiate between the concepts of the <em class="italic">JavaScript engine</em> and the <em class="italic">JavaScript runtime</em>.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>JavaScript engine</h2>
			<p>A JavaScript engine is a special type of program that reads, parses, and translates our JavaScript code <a id="_idIndexMarker146"/>into computer-understandable language (machine instructions) – see <em class="italic">Figure 3</em><em class="italic">.1</em>. We don’t have one single JavaScript engine for all browsers. For instance, Google Chrome, Opera, and the latest Microsoft Edge browsers use the <em class="italic">V8 engine</em>, Firefox has <em class="italic">SpiderMonkey</em>, and Safari uses the <em class="italic">JavascriptCore engine</em>. Anyone with the ability to follow ECMAScript engine standards can create their own JavaScript engine.</p>
			<p>But how can we have compatible JavaScript across the browsers? How do we make sure that the JavaScript code will work for all browsers? That is why we need a standard that will tell us exactly what we need to do to make sure that JavaScript will work for all browsers. Thankfully, we have a combination of rules that allows us to ensure consistency <a id="_idIndexMarker147"/>across different web browsers. This essential rulebook for scripting is called <strong class="bold">ECMAScript</strong> (<strong class="bold">ES</strong>). Of course, ES isn’t just for JavaScript; it applies to other scripting languages as well, but JavaScript is the most well-known implementation of it.</p>
			<div><div><img alt="Figure 3.1: JavaScript translation process" src="img/B09148_03_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: JavaScript translation process</p>
			<p>Let’s look <a id="_idIndexMarker148"/>at the JavaScript engine in depth in the next few subsections.</p>
			<h3>Call stack and memory heap</h3>
			<p>JavaScript <a id="_idIndexMarker149"/>engine consists of multiple elements, and two of <a id="_idIndexMarker150"/>them are the <strong class="bold">call stack</strong> and the <strong class="bold">memory heap</strong> (<em class="italic">Figure 3</em><em class="italic">.2</em>).</p>
			<div><div><img alt="Figure 3.2: Call stack and memory heap" src="img/B09148_03_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Call stack and memory heap</p>
			<p>When we run our JavaScript application, code is executed in the call stack. Think of it as a series of steps that your code can walk through in a given order. On the other hand, the heap is about data storage. It is unstructured memory that stores the objects.</p>
			<h3>JavaScript translation process</h3>
			<p>The <strong class="bold">translator</strong> is a program that can translate human-readable source code into machine-readable <a id="_idIndexMarker151"/>instructions. It has two main parts. The first part is the <strong class="bold">compiler</strong>. In the <a id="_idIndexMarker152"/>compilation process, the program converts the entire code into machine code at once. The second part is the <strong class="bold">interpreter</strong>. In the <a id="_idIndexMarker153"/>interpretation process, the interpreter goes through <a id="_idIndexMarker154"/>the source code and runs it line by line, converting it into machine instructions. Several years ago, JavaScript used to be a purely interpreted language, but fortunately, some <a id="_idIndexMarker155"/>modern JavaScript engines work in a hybrid mode of translation. Modern JavaScript engines use a combination of interpretation and JIT compilation, where the interpreter runs code line by line, while the compiler converts frequently used code to machine code to optimize performance. The V8 engine, for instance, combines the compiler and interpreter, which is called the <strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) compilation process.</p>
			<p>Interpreters are fast in terms of getting up and running. There is no need to convert the source into another language, which means there is no compilation step. For options such as executing something right away, interpreters are a better option than compilers. The major problem here is that if you run the same code (say, the same JavaScript function) again and again, it can get really slow. Interpreters don’t apply any optimization to your code. That is when the compiler comes in. It takes a bit more time than interpreters because it converts your code into another language, but it is smart, and when it sees the same code again, it just optimizes it in order to not interpret it again.</p>
			<p>In terms of translation, JavaScript uses the advantages of interpreter and compiler together.</p>
			<p>A classical compilation means that the machine code is stored in a portable file and can be executed at any time, but for the JIT compiler, it is a bit different. The machine code should be executed as soon as possible before compilation ends.</p>
			<p>Let’s try to understand how JavaScript-specific JIT works over Google’s V8 engine. As a JavaScript runtime, Node.js also relies on the V8 engine, and understanding its internals will help us a lot from the Node.js perspective.</p>
			<p>When you execute your source code written in JavaScript, the JavaScript engine parses it. The <em class="italic">parser</em> is a sub-element of the JavaScript engine that takes your source code and outputs tokens. That is how the JavaScript engine understands whether there is an error. It acts as a <strong class="bold">lexical analyzer</strong> and the <a id="_idIndexMarker156"/>final output is called an <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>). To witness <a id="_idIndexMarker157"/>the beauty of the AST, you can <a id="_idIndexMarker158"/>just navigate to the AST explorer (<a href="https://astexplorer.net/">https://astexplorer.net/</a>), type any JavaScript code, and see the parsing process.</p>
			<p>An AST is <a id="_idIndexMarker159"/>an engine-specific data structure <a id="_idIndexMarker160"/>that is generated by splitting up each line of your JavaScript code into pieces that are understandable to the language. The engine uses it to generate machine code. The AST is then taken by the <em class="italic">interpreter </em>and converted to byte code.</p>
			<p><strong class="bold">Byte code</strong> is a special <a id="_idIndexMarker161"/>type of collection of instructions that is approximately similar to machine code but acts as a wrapper and abstracts us from the complexities of the <a id="_idIndexMarker162"/>machine code. The default interpreter in V8, called <strong class="bold">Ignition</strong>, outputs <a id="_idIndexMarker163"/>byte code; on the other hand, the compiler, <strong class="bold">Turbofan</strong>, optimizes this bytecode into efficient machine code</p>
			<p>Turbofan also acts as a JIT compiler. In the middle of the interpreter and compiler, there is a<em class="italic"> profiler</em> that profiles the interpretation process (Ignition) and forwards the code that needs to be optimized to the compiler (Turbofan). (See <em class="italic">Figure 3</em><em class="italic">.3</em>.)</p>
			<div><div><img alt="Figure 3.3: JavaScript engine internals" src="img/B09148_03_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: JavaScript engine internals</p>
			<p>Okay, but you might be asking yourself why we need to understand under-the-hood  operations in the JavaScript engine. Well, that actually will help you to write better, faster code with optimized microservices. That knowledge will help you to write optimization-friendly code. The JavaScript engine is not always able to apply optimization and, in some cases, it depends on your writing style. It is possible to write deoptimization <a id="_idIndexMarker164"/>code that might be difficult for your JavaScript <a id="_idIndexMarker165"/>engine to optimize. That is why it is better to always understand the internals. For instance, using the <code>delete</code>, <code>evals</code>, <code>arguments</code>, and <code>with</code> keywords and mechanisms such as <em class="italic">hidden classes </em>and<em class="italic"> inline caching</em> may slow down code optimization. These concepts are beyond our book, but you can learn about them by checking the open source JavaScript tutorials and documentation.</p>
			<p>The next thing we need to talk about is the single-threaded nature of JavaScript, and believe me, things get interesting when we dive into the threading details.</p>
			<h3>Threading in JavaScript</h3>
			<p>As we mentioned before, JavaScript is a single-threaded, blocking, synchronous programming <a id="_idIndexMarker166"/>language that has only one call stack. JavaScript is "single-threaded," but it's not necessarily "blocking." It is synchronous by default but can handle asynchronous code execution using callbacks, promises, and async/await. But what does this mean and why do we need to understand it? Well, most programming languages support multithreading out of the box. This means it is possible to run multiple independent operations at a given time. But when it comes to JavaScript, things are a bit different. It is possible to run only one set of instructions at a given time for JavaScript natively, and this is a big problem in the world of multithreading, especially for long-running tasks. Fortunately, when you deal with JavaScript, you’re not dealing with only a JavaScript engine but also something called a <strong class="bold">JavaScript runtime</strong>.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>JavaScript runtime</h2>
			<p>The browser, by its <a id="_idIndexMarker167"/>nature, is a wrapper and a runtime for the JavaScript engine. The responsibility of the runtime is to provide <em class="italic">additional</em> support to implement all the required functionalities for the given context. Here, in browsers, the context is a web-based interactive application. Node.js is also a runtime based on Google’s V8 engine. Engines help you to extend native JavaScript engine functionalities even more and <a id="_idIndexMarker168"/>add an async nature to them. These functionalities together in the browser are called <strong class="bold">web APIs</strong>. To see browser-based, important web APIs, just do the following steps:</p>
			<ol>
				<li>Open your favorite browser (in our case, it is Google Chrome).</li>
				<li> Right-click and select <strong class="bold">Inspect</strong>.</li>
				<li> Go to the <code>window</code>.</li>
				<li>Hit <em class="italic">Enter</em>.</li>
			</ol>
			<p>You can <a id="_idIndexMarker169"/>also see this in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
			<div><div><img alt="Figure 3.4: window global object" src="img/B09148_03_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: window global object</p>
			<p>The elements of the <code>window</code> object (its properties and methods) that you can see are in addition to your JavaScript engine, which is built into the browser you use. Browsers have web APIs that are approximately similar for all of them. Most core web APIs are designed to be standardized so that websites can function similarly across different browsers. However, there can be minor differences in implementation or features between browsers, and some APIs might be specific to a particular browser. Most popular API functions, such as <code>fetch</code>, <code>settimeout</code>, <code>setinterval</code>, and <code>document</code>, are part of this huge API called <code>window</code>. It means they are not native JavaScript functions but engine-based functions for us in the given context. Web APIs decorate our JavaScript code with async behaviors.</p>
			<p>When you write code that has these functions (<code>fetch</code>, <code>document</code>, etc.), the JavaScript engine will forward them to the web APIs. Web APIs are written in low-level languages (in most cases in C/C++) and after execution, your callback, which is provided in the given instruction, will be <a id="_idIndexMarker170"/>added to the <em class="italic">callback queue</em>. All native JavaScript functions will be executed directly in the call stack, but non-native instructions need to be executed first in the web API and the result of the execution, as a callback, will be added to the callback queue (<em class="italic">Figure 3</em><em class="italic">.5</em>).</p>
			<p>There is <a id="_idIndexMarker171"/>also the <em class="italic">event loop</em>. The responsibility of the event loop is just to check the call stack and to push callback queue elements there only if it is empty.</p>
			<p>To make sure <a id="_idIndexMarker172"/>all the terms we mentioned are understood well, let’s consider a simple example. Look at <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
			<div><div><img alt="Figure 3.5: JavaScript event loop with a callback queue" src="img/B09148_03_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: JavaScript event loop with a callback queue</p>
			<p>Open your favorite web browser, right-click on the page, select <code>event_loop.js</code> in the <code>Ch03</code><code>/js</code> folder of the book’s GitHub repository:</p>
			<pre class="source-code">
function print(message) {
    console.log(message);
}
setTimeout(() =&gt; {
print("Message from Timeout");
}, 0);
print("Message 1");
print("Message 2");</pre>			<p>Here in our code, you might expect to see <code>setTimeout</code>’s message first and then other messages in <a id="_idIndexMarker173"/>the given order. Because we have specified <code>0</code> for <code>setTimeout</code>, it should immediately execute our code. But the output is different, as we can see in <em class="italic">Figure 3</em><em class="italic">.6</em>.</p>
			<div><div><img alt="Figure 3.6: The call stack executes a queue item at the end" src="img/B09148_03_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: The call stack executes a queue item at the end</p>
			<p>As you might guess, if the executed function is non-native, which means it is a web-API-based function, then the JavaScript engine will forward it to the web API, and after execution, its callback will be added to the callback queue. Meanwhile, <code>setTimeout</code> is going to be a non-blocking, asynchronous operation, and that is why we see the result of <code>print</code> functions first.</p>
			<p>So, it doesn’t matter if you have set <code>0</code> or more as the second argument to <code>setTimeout</code>; it goes through the pipeline we explained anyway. The event loop will check whether the call stack is empty and when both <code>print</code> functions are done, it does become empty, so we’re able to see the result of <code>setTimeout</code> only after the event loop pushes it to the call stack.</p>
			<p>Now let’s talk about the asynchronous nature of JavaScript in more detail.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Callback-based asynchronous JavaScript</h2>
			<p><code>setTimeout</code> or <code>setInterval</code>, you usually rely on callbacks.</p>
			<p>Callbacks are indispensable, but sometimes their usage makes your code less understandable and less maintainable, especially from an asynchronous code perspective. To prove that, go to <code>callback_hell.html</code> and run it in any browser. (You can find <code>callback_hell.html</code> in the <code>Ch03</code> folder of the book’s GitHub repository. For the sake of simplicity, all the GitHub repository references will contain only the path, i.e., <code>Ch03</code><code>/callback_hell.html</code>.) </p>
			<p>The file contains callback-based multiple asynchronous actions that we call <em class="italic">callback hell</em>.</p>
			<pre class="source-code">
addScript("js/app.js", (script, error) =&gt; {
        if (error) {
          addErrorMessage("main", error.message);
        } else {
          setTimeout(() =&gt; {
            let message = execute();
            addSuccessMessage("main", message);
            setTimeout(() =&gt; {
              message = "operation completed successfully";
              addSuccessMessage("main", message);
              setTimeout(() =&gt; {
                message = "ready for another execution";
                addSuccessMessage("main", message);
              }, 2000);
            }, 3000);
          }, 4000);
        }
      });</pre>			<p>Here is <a id="_idIndexMarker176"/>what this script does:</p>
			<ol>
				<li>Dynamically adds the provided script to the head of the HTML file.</li>
				<li>Runs a function that belongs to that script (in our case, it is an <code>execute</code> function).</li>
				<li>Runs the <code>operation completed successfully</code> message after <code>three</code> seconds.</li>
				<li><code>Three</code> seconds after the preceding message runs, it outputs the <code>ready for another execution</code> message to the console. If the loaded file doesn’t exist, then the error message will be printed as an output.</li>
			</ol>
			<p>As you can see, the code is hard to read, understand, and maintain this code due to its nesting. In software development, <em class="italic">maintaining</em> refers to the ongoing process of keeping software functioning properly, secure, and up to date. It might be more complex if you have more operations to do.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>The way to promises</h2>
			<p>While callbacks are still a main part of JavaScript, promises are the preferred way to handle <a id="_idIndexMarker177"/>asynchronous operations in modern JavaScript development due to the benefits they offer in readability, error handling, and code maintainability.</p>
			<p><strong class="bold">Promises</strong> were added in <a id="_idIndexMarker178"/>JavaScript with the <strong class="bold">ECMAScript 6</strong> (<strong class="bold">ES6</strong>) specification, which was released in 2015. Before ES6, callback hell was a common way to handle asynchronous operations in JavaScript. Thanks to promises, now we have a clean and more manageable approach for asynchronous programming. We actively use promises in Node.js development, so it is crucial to understand and properly use them.</p>
			<p>To create a promise, we use a <code>Promise</code> object. It has a single callback argument, which is called <code>executor</code>. It runs automatically when the promise is constructed successfully. The executor consists of two callbacks:</p>
			<ul>
				<li><code>resolve</code>: We use this to inform a user about a successful operation</li>
				<li><code>reject</code>:  We use this to indicate that something went wrong</li>
			</ul>
			<p>When a promise is done, it should call one of the functions, either <code>resolve</code> (value) or <code>reject</code> (error).</p>
			<p>The promise is <a id="_idIndexMarker179"/>initially in a <code>pending</code> state. It will be moved to a <code>fulfilled</code> state if <code>resolve</code> happens; otherwise (if rejected), the state will be moved to <code>rejected</code>.</p>
			<p>The promise’s result is initially <code>undefined</code>. It will store <code>value</code> if <code>resolve</code> is executed; otherwise (if rejected), it will store <code>error</code>.</p>
			<div><div><img alt="Figure 3.7: Promise state and result" src="img/B09148_03_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Promise state and result</p>
			<p>It is completely okay to use only <code>resolve</code> or <code>reject</code> for <code>executor</code> if you want to provide only one path for your execution.</p>
			<p>Let’s try to implement the callback example in <em class="italic">Figure 3</em><em class="italic">.7</em> using promises.</p>
			<p>File: <code>Ch03</code><code>/js/promise_chaining.js</code></p>
			<pre class="source-code">
addPromisifiedScript ("js/app.js")
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = execute();
                addSuccessMessage("main", message);
                resolve();
              }, 4000);
            })
        )
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = "operation completed successfully";
                addSuccessMessage("main", message);
                resolve();
              }, 3000);
            })
        )
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = "ready for another execution";
                addSuccessMessage("main", message);
                resolve();
              }, 2000);
            })
        )
        .catch((error) =&gt; addErrorMessage("main", error.message));</pre>			<p>Now, instead of <a id="_idIndexMarker180"/>nested callbacks, we have promise chaining. So, why should you choose promises over callbacks? Consider the following benefits:</p>
			<ul>
				<li>Thanks to their linear syntax, promises help us to make code easier to follow</li>
				<li>We have <code>.catch()</code>, which provides a central way to handle errors</li>
				<li>Promises allow you to chain multiple asynchronous operations together in a more readable way</li>
				<li><code>a</code><code>sync</code>/<code>await</code> builds on top of promises and provides an even more synchronous looking way to write asynchronous code (we’ll learn about <code>async</code>/<code>await</code> in this chapter too)</li>
			</ul>
			<p>How about making the promise-based code more readable?</p>
			<p>File: <code>Ch03</code><code>/js/promise.js</code></p>
			<pre class="source-code">
function delay(ms) {
        return new Promise((resolve) =&gt; setTimeout(resolve, ms));
      }
      addPromisifiedScript("js/app.js")
        .then(() =&gt; delay(4000))
        .then(() =&gt; {
          let message = execute();
          addSuccessMessage("main", message);
        })
        .then(() =&gt; delay(3000))
        .then(() =&gt; {
          let message = "operation completed successfully";
          addSuccessMessage("main", message);
        })
        .then(() =&gt; delay(2000))
        .then(() =&gt; {
          let message = "ready for another execution";
          addSuccessMessage("main", message);
        })
        .catch((error) =&gt; addErrorMessage("main", error.message));</pre>			<p>As you can see, adding a simple delay function can make our code more readable, instead of having nested callbacks.</p>
			<p>A promise acts as a producer. If you want to handle the response of your promise, you need to register a consumer. This registration is mainly done by using a <code>.then</code> instruction. It is a <a id="_idIndexMarker181"/>continuation of a promise that gets the result of the previous promise. This instruction can handle both responses (success and failure).</p>
			<p>Check the code here to see how we can handle success and error cases. When the operation succeeds in <code>addPromisifiedScript</code>, the <code>resolve</code> part of the code will be triggered; otherwise, <code>reject</code> will be triggered:</p>
			<pre class="source-code">
addPromisifiedScript("js/app.js").then(
        (resolve) =&gt; {},//success continuation
        (reject) =&gt; {}//error handling
      );</pre>			<p>We often use <code>.then()</code> with only <code>resolve</code> mode. If you want to have one centralized way of handling errors, it is better to use <code>.catch()</code>, which is the equivalent of applying <code>.</code><code>then(null,reject=&gt; {})</code>.</p>
			<p>You can set up a promise to handle online book orders (an async operation). You might get a confirmation <a id="_idIndexMarker182"/>email for the order (a resolved promise) or encounter an error (a rejected promise), but either way, you’re still finished interacting with the bookstore’s website (the <code>finally</code> block). You can put code in the <code>finally</code> block to clean things up after the promise is done, win or lose. This could be things such as turning off a loading wheel on your screen, closing a connection you don’t need anymore, or anything else that needs to happen regardless of the outcome.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Promise API</h2>
			<p>Instantiating a <a id="_idIndexMarker183"/>promise object using a <code>new</code> keyword is not the only way of using it. The Promise API has several useful static methods that we can use in practice. Let’s take a look at them in the following subsections.</p>
			<h3>Promise.all()</h3>
			<p>If you have <a id="_idIndexMarker184"/>multiple promises that need to be executed in parallel, and you need to wait for all <a id="_idIndexMarker185"/>of them to be ready, then <code>Promise.all()</code> might be a good choice. It returns an array of results if all promises resolve successfully or rejects as soon as one of the promises fails.</p>
			<p>Open <code>github_avatars.html</code> in the GitHub chapter repository and run it by double-clicking on it:</p>
			<pre class="source-code">
const usernames = ["TuralSuleymani", "rasulhsn"];
      const url = "https://api.github.com/users/";
      let requests = usernames.map((name) =&gt; fetch(url.concat(name)));
      Promise.all(requests)
        .then((responses) =&gt; Promise.all(responses.map((r) =&gt; 
          r.json())))
        .then((gitusers) =&gt;
          gitusers.forEach((user) =&gt; createAvatar(user.avatar_url))
        );</pre>			<p><code>Promise.all()</code> waits for all promises to be executed in parallel and be ready and then returns multiple promises.</p>
			<p>In our example, we use it in two scenarios:</p>
			<ul>
				<li>Fetching data from GitHub in parallel (<em class="italic">line 25</em>)</li>
				<li>Getting data as JavaScriptON from all promises (<em class="italic">line 27</em>)</li>
			</ul>
			<p>For <code>Promise.all()</code>, we wait <a id="_idIndexMarker186"/>for all promises to be successfully executed. If even one promise fails (doesn’t work out), <code>Promise.all()</code> immediately stops and <a id="_idIndexMarker187"/>gives up entirely. It forgets about all the other promises in the list and completely ignores their results.</p>
			<p>The code we just looked at should render two Gi<a id="_idTextAnchor051"/>tHub users’ avatars as images in an <code>.</code><code>html</code> file.</p>
			<p>Imagine you have several tasks to run, such as fetching things from the internet. If one task fails, the others might still keep going. But <code>Promise.all()</code> won’t care about them anymore. They might finish eventually, but their results won’t be used. (<code>Ch03</code><code>/js/promiseAPI.js</code> contains all Promise API examples demonstrated.)</p>
			<p>The following sample code shows that <code>Promise.all</code> accepts multiple promises as an array:</p>
			<pre class="source-code">
Promise.all([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 1500))
  ])
  .then((success) =&gt; console.log(success))
  .catch(alert); // Error: Something went wrong!!</pre>			<p><code>Promise.all()</code> doesn’t try to stop the other tasks because there’s no way to cancel promises once they’ve started.</p>
			<h3>Promise.allSettled()</h3>
			<p>Unlike <code>Promise.all()</code>, <code>Promise.allSettled()</code> is more patient. Even if one promise fails, it waits for all the promises to finish before giving you the results.</p>
			<p>Imagine a <a id="_idIndexMarker188"/>similar scenario with the tasks. This time, <code>Promise.allSettled()</code> will wait for all the tasks to be completed, regardless of whether one fails.</p>
			<p>In the end, it will <a id="_idIndexMarker189"/>give you a report on all the tasks, telling you whether each one succeeded (<code>success resolve</code>) or failed (<code>Something </code><code>went wrong!!</code>):</p>
			<pre class="source-code">
Promise.allSettled([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 1500))
  ])
  .then(results =&gt; {
    // 'results' is an array containing information about each promise (resolved or rejected)
    console.log(results);
  });</pre>			<p>This way, you get a complete picture of what happened with all your tasks, even if some failed.</p>
			<h3>Promise.race()</h3>
			<p><code>Promise.race()</code> is like a race between promises. You provide it with a bunch of promises, and it waits for the very first one to either succeed or fail.</p>
			<p>Whichever <a id="_idIndexMarker190"/>promise finishes first (wins the race), its result (a success or error value) becomes the result of <code>Promise.race()</code>. The rest of the promises <a id="_idIndexMarker191"/>are completely ignored, regardless of whether they eventually succeed or fail:</p>
			<pre class="source-code">
Promise.race([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 2500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 3500))
  ])
  .then(result =&gt; {
    console.log(result);
  }).catch((err)=&gt;console.log('Error detected', err));</pre>			<p>You need to be careful when you use <code>Promise.race</code> for the following reasons:</p>
			<ul>
				<li>It’s useful when you only need the result from the fastest promise</li>
				<li>It stops listening to other promises as soon as one finishes</li>
				<li>It returns the result (success value or error) from the winning promise</li>
			</ul>
			<h3>Promise.any()</h3>
			<p><code>Promise.any()</code> waits for <a id="_idIndexMarker192"/>any of the promises to succeed, not <a id="_idIndexMarker193"/>necessarily the first one.</p>
			<p>As soon as one promise resolves successfully, <code>Promise.any</code> immediately stops waiting for the others and returns the success value.</p>
			<p>However, if all the promises in the list end up failing (rejected), <code>Promise.any</code> itself rejects with a special error called <code>AggregateError</code>. This error contains information about why all the individual promises failed:</p>
			<pre class="source-code">
Promise.any([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 2500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 3500))
  ])
  .then(result =&gt; {
    console.log(result);
  }).catch((err) =&gt; console.log('Error detected', err));//will not be executed</pre>			<p>We also <a id="_idIndexMarker194"/>have <code>Promise.resolve()</code> and <code>Promise.reject()</code>, but they <a id="_idIndexMarker195"/>are rarely used due to the <code>async</code>/<code>await</code> keyword.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Async/await in JavaScript</h2>
			<p>Promises are so popular that there is a special syntax to work with them. This combination <a id="_idIndexMarker196"/>is called <code>async</code>/<code>await</code> keyword in the <code>async_await.js</code> file in the chapter’s repository.</p>
			<p>You’re able <a id="_idIndexMarker197"/>to add an <code>async</code> keyword to any function, even just a simple function. But what is the value of using the <code>async</code> keyword before your functions? Well, the <code>async</code> keyword is a syntactical sugar that helps us to wrap our function to a promise. Check out this function:</p>
			<pre class="source-code">
async function sayHello() {
    return "hello user";
}</pre>			<p>It is exactly the same as this:</p>
			<pre class="source-code">
function sayHello() {
   return Promise.resolve("hello user");
}</pre>			<p>The async version <a id="_idIndexMarker198"/>of the function, behind the scenes, will generate a promise (<em class="italic">Figure 3</em><em class="italic">.7</em>). This means that using this syntax, you’re able to add continuations such as <code>.then()</code>, <code>.finally()</code>, and .<code>catch()</code> to that function. It is just a promise-based function.</p>
			<div><div><img alt="Figure 3.8: The async function is promise-based" src="img/B09148_03_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: The async function is promise-based</p>
			<p>So, the responsibility of async is to ensure that the functions always return a promise. But that is not all. There is another keyword in this pair that is called <code>await</code>. If you need to wait for your promise to be settled, then you’re able to use this keyword. Say we have a simple <code>delayedMessage()</code> function that returns exactly the same message as provided by the arguments but with some delays:</p>
			<pre class="source-code">
function delayedMessage(msg) {
    return new Promise((resolve)=&gt; {
        setTimeout(() =&gt; {
            resolve(msg);
        }, 3000);
    });
}</pre>			<p>Instead of getting data by chaining (using <code>.then</code> ), you can simply apply a synchronous programming technique. This means just waiting for functions to return data, get the data, and then continue:</p>
			<pre class="source-code">
let message = await delayedMessage("hello");//wait here for the Promise to be settled</pre>			<p>That is simple. So, instead of working with <code>then</code>, <code>catch</code>, and <code>finally</code>, you can interact with <a id="_idIndexMarker199"/>promise-based functions using just async-based syntax. Put simply, await is just a more elegant way of working with promises.</p>
			<p>Here is a simple example of fetching data from multiple URLs using promises:</p>
			<p>File: <code>Ch03</code><code>/js/getdata_promise.js</code></p>
			<pre class="source-code">
const url = "https://jsonplaceholder.typicode.com";
const paths = ["/posts","/comments"];
let promises = Promise.all(paths.map(path=&gt; fetch(url.concat(path))));
promises.then(responses=&gt; Promise.all(responses.map(t =&gt; t.json())))
.then(data=&gt; {
    data.forEach(element =&gt; {
        console.log(element);
    });
})</pre>			<p>In our preceding example, we fetch data from <code>/posts</code> and <code>/comments</code> of the JavaScript <code>onplaceholder</code> URL using promises.</p>
			<p>Using async/await, we’re able to simplify it, like this:</p>
			<p>File: <code>Ch03</code><code>/js/getdata_async.js</code></p>
			<pre class="source-code">
const url = "https://jsonplaceholder.typicode.com";
const paths = ["/posts","/comments"];
let getData = async function() {
    const responses = await Promise.all( paths.map(path=&gt;fetch(url
      .concat(path))));
    constJavaScriptons = await Promise.all( responses
      .map(response=&gt;response.json()));
   JavaScriptons.forEach(element =&gt; {
        console.log(element);
    });
}
getData();</pre>			<p>Instead of using <code>.then()</code> every time, we are now able to use synchronous-programming-based syntax.</p>
			<p>You might be wondering how to handle exceptions in this code? If we <a id="_idIndexMarker200"/>are free to not use <code>.catch()</code>, then how will we be able to catch exceptions? The answer here is also really simple: just use <code>try..catch</code>.</p>
			<p>We have talked enough about promises. It is time to see how JavaScript internally handles promises.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Microtask queue</h2>
			<p>We’ve talked <a id="_idIndexMarker201"/>about promises and async/await. It is now the exact time to talk about the related topic of the <code>PromiseJobs</code>) – see <em class="italic">Figure 3</em><em class="italic">.8</em>. To better manage asynchronous tasks in JavaScript, the ECMA standard added this internal queue. It has approximately the same behavior as a callback queue in terms of the call stack because the execution of these tasks is possible only when nothing else is running in the call stack.</p>
			<div><div><img alt="Figure 3.9: Microtask queue" src="img/B09148_03_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Microtask queue</p>
			<p>So, when a <a id="_idIndexMarker202"/>given promise is ready, the continuations, such as <code>then</code>/<code>catch</code>/<code>finally</code> handlers, are put into the queue. When the call stack is empty, the JavaScript engine <a id="_idIndexMarker203"/>will take these tasks in a <strong class="bold">First in, First out</strong> (<strong class="bold">FIFO</strong>) order and execute them.</p>
			<p>Here is a simple example (<code>Ch03</code><code>/js/microtasks.js</code>):</p>
			<pre class="source-code">
let promise = Promise.resolve();
promise.then(() =&gt; console.log("planning to see this message first"));
console.log("but this message will be seen first");</pre>			<p>The order of the output is seen in <em class="italic">Figure 3</em><em class="italic">.10</em>.</p>
			<div><div><img alt="Figure 3.10: The output of the preceding code" src="img/B09148_03_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: The output of the preceding code</p>
			<p>Because, when the JavaScript engine detects a promise, it moves its <code>.then()</code> to the microtask queue. It is an async operation, so we directly switch to the next line. It is possible to execute a promise only if the call stack is empty.</p>
			<p>Of course, the topics we discussed are not the whole list of topics you need to work with Node.js. We bypassed <a id="_idIndexMarker204"/>some simple and middle-level topics and covered only some important ones we think might help you when working with Node.js. JavaScript skills are essential, and you need to be aware of its syntax. Having better JavaScript skills will be a guide for you throughout the learning process of the book.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/>Node.js essentials</h1>
			<p>Node.js is not a separate programming language. It is a runtime over Google’s V8 engine. This simply means <a id="_idIndexMarker205"/>that the creator of Node.js just took the V8 engine out of the browser and put it into another runtime. Node.js is a wrapper over the V8 engine and extends it by adding networking, APIs for I/O, and other operations. A key aspect of Node.js is its non-blocking I/O model. This means Node.js can handle multiple requests simultaneously without being blocked by slow operations. The event loop and callback queue become even more important in this context.</p>
			<p>Node.js has different <a id="_idIndexMarker206"/>dependencies under the hood, but the most interesting one for us to discuss is <strong class="bold">Libuv</strong>. Libuv provides a thread pool for handling certain tasks, with four threads by default, but this can be configured based on the application’s requirements.This is the main magic that provides I/O-based non-blocking operations. It is written in C, and it provides an event-driven asynchronous I/O model. It is possible to perform blocking operations using a thread pool to distribute CPU loads. We have four threads to use in Libuv by default. For network-based async operations, Libuv relies on the OS itself, but for some other async functions, such as reading something from a file, Libuv relies on its thread pool. The concept of a thread pool allows us to do some important operations in a separate thread and not block others.</p>
			<p>Node.js primarily focuses on asynchronous I/O and aims to minimize blocking operations. The thread pool is mainly used for tasks that cannot be efficiently handled asynchronously by the OS, such as intensive calculations or filesystem operations requiring significant processing.</p>
			<p>Like in browsers, we have different queues to be used when it comes to the Node.js async nature. The general concept is the same. They both use an event-loop-based model, but for Node.js, we have some more queues.</p>
			<p>The event loop is a mechanism that continuously operates while your Node.js application is running. It’s responsible for handling different asynchronous events. The event loop utilizes queues to organize these events, ensuring they are processed in the proper order. The event loop consists of six different queues.</p>
			<p>The event loop <a id="_idIndexMarker207"/>utilizes several queues to manage different types of asynchronous operations (<em class="italic">Figure 3</em><em class="italic">.9</em>). These queues ensure tasks are processed in a specific order, as follows:</p>
			<ul>
				<li><code>setTimeout</code> and <code>setInterval</code> functions. These callbacks are executed after a specified delay or at regular intervals. (Technically, it’s a min-heap for efficient scheduling.)</li>
				<li><code>fs</code> and <code>http</code> modules. The event loop processes these callbacks when the I/O operation completes.</li>
				<li><code>setImmediate</code>. These callbacks are considered a high priority and are executed before other tasks in the next loop iteration.</li>
				<li><strong class="bold">Close queue</strong>: This <a id="_idIndexMarker211"/>queue contains functions meant to run when an asynchronous resource is closed, ensuring proper cleanup.</li>
				<li><code>process.nextTick</code>. These are also a high priority and get executed immediately after the current operation finishes.</li><li><strong class="bold">Promise queue</strong>: This <a id="_idIndexMarker215"/>queue contains <a id="_idIndexMarker216"/>callbacks associated with resolving or rejecting promises. These are processed whenever the event loop encounters a resolved or rejected promise during its execution.</li></ul></li>
			</ul>
			<p>It’s important to note that the first four queues (timers, I/O, check, and close callbacks) are managed by Libuv. The microtask queues (<code>nextTick</code> and <code>Promise</code>) are separate but still play a <a id="_idIndexMarker217"/>crucial role in determining the order of callback execution within the event loop.</p>
			<div><div><img alt="Figure 3.11: Node.js queues" src="img/B09148_03_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Node.js queues</p>
			<p>Let’s talk about the priority order of the queues. First things first, it is important to understand that user-written, synchronous JavaScript code has the highest priority over all of these queues. This simply means that these queue elements will be executed only if the call stack is empty. However, what about these six queue orders? We will discuss them in more detail now:</p>
			<ul>
				<li><code>nextTick</code> queue, executing those tasks first, followed by any callbacks in the promise queue.</li>
				<li><code>setTimeout</code> and <code>setInterval</code>.<p class="list-inset">After the timers queue, the event loop is going to check the microtask queue again. First, the <code>nextTick</code> queue will be executed, and then the <code>promise</code> queue will be executed.</p></li>
				<li><strong class="bold">I/O callbacks</strong>: Next, the <a id="_idIndexMarker220"/>event loop handles callbacks from the I/O queue. These represent asynchronous operations, such as file I/O or network requests, which have completed.</li>
				<li><strong class="bold">Microtask check (again)</strong>: The <a id="_idIndexMarker221"/>event loop checks for microtasks again after processing the I/O. This ensures that any microtasks created during those operations are executed immediately.</li>
				<li><code>setImmediate</code>): The event loop then executes callbacks from the check queue, which <a id="_idIndexMarker222"/>holds functions scheduled with <code>setImmediate</code>. These are considered high-priority tasks and run before other callbacks in the next loop iteration.<p class="list-inset">After the check queue, the event loop is going to check the microtask queue again. First, the <code>nextTick</code> queue will be executed, and then the <code>promise</code> queue will be executed.</p></li>
				<li><strong class="bold">Close callbacks</strong>: Finally, the <a id="_idIndexMarker223"/>event loop processes callbacks associated with closing asynchronous resources, ensuring proper cleanup.<p class="list-inset">Check the microtasks queue again and execute callbacks if they exist.</p></li>
				<li><strong class="bold">Microtasks throughout the loop</strong>: The event loop keeps the party going as long <a id="_idIndexMarker224"/>as there are callbacks waiting to be invited. Once everyone’s had their turn and there’s nothing left to do, it gracefully exits the stage.</li>
			</ul>
			<p>As you might notice, microtasks are checked multiple times within the event loop. This ensures that any microtasks created during the execution of other callbacks are handled immediately. This prioritizes tasks scheduled with <code>nextTick</code> and <code>promise</code> resolutions, keeping the event loop responsive.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/>Summary</h1>
			<p>This chapter was about JavaScript and Node.js internals.</p>
			<p>First, we started our discussion with JavaScript internals. The main point was to understand the JavaScript engine and the JavaScript runtime. JavaScript is a single-thread language, but it has an async nature and we’re able to use callbacks and promises to implement it. In async programming, callbacks are a bit old school nowadays thanks to promises. We also talked about the Promise API and learned a lot of interesting functions.</p>
			<p>The popularity of promises brings other interesting features to JavaScript: async/await. Using examples, we tried to demonstrate how they make our code more readable, understandable, and similar to sync code.</p>
			<p>For promises, we have a special queue in the JavaScript engine pipeline called the microtask queue.</p>
			<p>Then we started a discussion around Node.js and learned that it is also a runtime and uses the JavaScript engine to read and translate JavaScript code. It takesJavaScript to another level, and using Node.js, we can build real-time applications, microservices, web APIs, streaming applications, command-line tools, and more.</p>
			<p>Internally, Node.js heavily relies on Libuv and provides tons of functionalities that mostly can be categorized under asynchronous I/O and thread pooling. Libuv provides the core functionality for Node.js’s asynchronous programming model, making it efficient and scalable for handling numerous concurrent connections and I/O operations.</p>
			<p>The last discussion for this chapter was on Node.js queues and event loops. We have several queues in Node.js and they have special orders that we need to understand to build more effective applications.</p>
			<p>In our next chapter, we will talk about the stack development technologies that you need to know before writing any lines of code.</p>
		</div>
	</body></html>