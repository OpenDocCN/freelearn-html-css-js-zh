<html><head></head><body>
		<div id="_idContainer034">
			<h1 class="chapter-number" id="_idParaDest-42"><a id="_idTextAnchor042"/>3</h1>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>What Do You Need Before Getting Started?</h1>
			<p>The microservice approach does not inherently depend on any specific programming language. You can implement it using different programming languages. The concept of microservices supports using different languages for different services within a single application. This means the choice of programming language for each service can be based on its specific needs and functionalities. For example, you’re able to implement <em class="italic">microservice A</em> using C# but <em class="italic">microservice B</em> using JavaScript. That is the beauty of microservice development, which allows us to bypass programming <span class="No-Break">language barriers.</span></p>
			<p>This book is about writing microservices in JavaScript. As in any programming language, before implementing the microservice approach, it is best to understand the basics of the given language, which will help us to build better and more effective microservices. The focus of this chapter is to provide the foundation, rather than a comprehensive guide, for the language, along with Node.js. There are a few topics, especially in JavaScript, that need to be reviewed before implementing any microservice applications using the <span class="No-Break">language itself.</span></p>
			<p>In this chapter, we’re going to explore the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">JavaScript essentials</span></li>
				<li><span class="No-Break">Node.js essentials</span></li>
			</ul>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>For this chapter, you need <span class="No-Break">the following:</span></p>
			<ul>
				<li>A browser (select your <span class="No-Break">favorite one)</span></li>
				<li>Visual Studio Code (or you can use your OS’s default text editor): Simply go to <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> and <span class="No-Break">install it</span></li>
				<li><strong class="bold">GitHub</strong>: Go <span class="No-Break">to </span><a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03"><span class="No-Break">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript/tree/main/Ch03</span></a><p class="list-inset">The next chapter will explain the required software installation processes in detail. For now, you can download the GitHub repository source code without using any GitHub commands and experiment <span class="No-Break">with it.</span></p></li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>JavaScript essentials</h1>
			<p>JavaScript is a popular, single-threaded, synchronous programming language that helps us mostly to <a id="_idIndexMarker145"/>build interactive web applications. Its strength is its ability to mix different programming methods. This mix lets you write code in several ways: focusing on objects, using functions like building blocks, reacting to events, or giving step-by-step instructions, making your code clear and easier to handle. The JavaScript you use in the browser or in Node.js is not completely <em class="italic">native</em>. That is why we need to differentiate between the concepts of the <em class="italic">JavaScript engine</em> and the <span class="No-Break"><em class="italic">JavaScript runtime</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>JavaScript engine</h2>
			<p>A JavaScript engine is a special type of program that reads, parses, and translates our JavaScript code <a id="_idIndexMarker146"/>into computer-understandable language (machine instructions) – see <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em>. We don’t have one single JavaScript engine for all browsers. For instance, Google Chrome, Opera, and the latest Microsoft Edge browsers use the <em class="italic">V8 engine</em>, Firefox has <em class="italic">SpiderMonkey</em>, and Safari uses the <em class="italic">JavascriptCore engine</em>. Anyone with the ability to follow ECMAScript engine standards can create their own <span class="No-Break">JavaScript engine.</span></p>
			<p>But how can we have compatible JavaScript across the browsers? How do we make sure that the JavaScript code will work for all browsers? That is why we need a standard that will tell us exactly what we need to do to make sure that JavaScript will work for all browsers. Thankfully, we have a combination of rules that allows us to ensure consistency <a id="_idIndexMarker147"/>across different web browsers. This essential rulebook for scripting is called <strong class="bold">ECMAScript</strong> (<strong class="bold">ES</strong>). Of course, ES isn’t just for JavaScript; it applies to other scripting languages as well, but JavaScript is the most well-known implementation <span class="No-Break">of it.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 3.1: JavaScript translation process" src="image/B09148_03_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: JavaScript translation process</p>
			<p>Let’s look <a id="_idIndexMarker148"/>at the JavaScript engine in depth in the next <span class="No-Break">few subsections.</span></p>
			<h3>Call stack and memory heap</h3>
			<p>JavaScript <a id="_idIndexMarker149"/>engine consists of multiple elements, and two of <a id="_idIndexMarker150"/>them are the <strong class="bold">call stack</strong> and the <strong class="bold">memory heap</strong> (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 3.2: Call stack and memory heap" src="image/B09148_03_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Call stack and memory heap</p>
			<p>When we run our JavaScript application, code is executed in the call stack. Think of it as a series of steps that your code can walk through in a given order. On the other hand, the heap is about data storage. It is unstructured memory that stores <span class="No-Break">the objects.</span></p>
			<h3>JavaScript translation process</h3>
			<p>The <strong class="bold">translator</strong> is a program that can translate human-readable source code into machine-readable <a id="_idIndexMarker151"/>instructions. It has two main parts. The first part is the <strong class="bold">compiler</strong>. In the <a id="_idIndexMarker152"/>compilation process, the program converts the entire code into machine code at once. The second part is the <strong class="bold">interpreter</strong>. In the <a id="_idIndexMarker153"/>interpretation process, the interpreter goes through <a id="_idIndexMarker154"/>the source code and runs it line by line, converting it into machine instructions. Several years ago, JavaScript used to be a purely interpreted language, but fortunately, some <a id="_idIndexMarker155"/>modern JavaScript engines work in a hybrid mode of translation. Modern JavaScript engines use a combination of interpretation and JIT compilation, where the interpreter runs code line by line, while the compiler converts frequently used code to machine code to optimize performance. The V8 engine, for instance, combines the compiler and interpreter, which is called the <strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) <span class="No-Break">compilation process.</span></p>
			<p>Interpreters are fast in terms of getting up and running. There is no need to convert the source into another language, which means there is no compilation step. For options such as executing something right away, interpreters are a better option than compilers. The major problem here is that if you run the same code (say, the same JavaScript function) again and again, it can get really slow. Interpreters don’t apply any optimization to your code. That is when the compiler comes in. It takes a bit more time than interpreters because it converts your code into another language, but it is smart, and when it sees the same code again, it just optimizes it in order to not interpret <span class="No-Break">it again.</span></p>
			<p>In terms of translation, JavaScript uses the advantages of interpreter and <span class="No-Break">compiler together.</span></p>
			<p>A classical compilation means that the machine code is stored in a portable file and can be executed at any time, but for the JIT compiler, it is a bit different. The machine code should be executed as soon as possible before <span class="No-Break">compilation ends.</span></p>
			<p>Let’s try to understand how JavaScript-specific JIT works over Google’s V8 engine. As a JavaScript runtime, Node.js also relies on the V8 engine, and understanding its internals will help us a lot from the <span class="No-Break">Node.js perspective.</span></p>
			<p>When you execute your source code written in JavaScript, the JavaScript engine parses it. The <em class="italic">parser</em> is a sub-element of the JavaScript engine that takes your source code and outputs tokens. That is how the JavaScript engine understands whether there is an error. It acts as a <strong class="bold">lexical analyzer</strong> and the <a id="_idIndexMarker156"/>final output is called an <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>). To witness <a id="_idIndexMarker157"/>the beauty of the AST, you can <a id="_idIndexMarker158"/>just navigate to the AST explorer (<a href="https://astexplorer.net/">https://astexplorer.net/</a>), type any JavaScript code, and see the <span class="No-Break">parsing process.</span></p>
			<p>An AST is <a id="_idIndexMarker159"/>an engine-specific data structure <a id="_idIndexMarker160"/>that is generated by splitting up each line of your JavaScript code into pieces that are understandable to the language. The engine uses it to generate machine code. The AST is then taken by the <em class="italic">interpreter </em>and converted to <span class="No-Break">byte code.</span></p>
			<p><strong class="bold">Byte code</strong> is a special <a id="_idIndexMarker161"/>type of collection of instructions that is approximately similar to machine code but acts as a wrapper and abstracts us from the complexities of the <a id="_idIndexMarker162"/>machine code. The default interpreter in V8, called <strong class="bold">Ignition</strong>, outputs <a id="_idIndexMarker163"/>byte code; on the other hand, the compiler, <strong class="bold">Turbofan</strong>, optimizes this bytecode into efficient <span class="No-Break">machine code</span></p>
			<p>Turbofan also acts as a JIT compiler. In the middle of the interpreter and compiler, there is a<em class="italic"> profiler</em> that profiles the interpretation process (Ignition) and forwards the code that needs to be optimized to the compiler (Turbofan). (See <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.)</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 3.3: JavaScript engine internals" src="image/B09148_03_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: JavaScript engine internals</p>
			<p>Okay, but you might be asking yourself why we need to understand under-the-hood  operations in the JavaScript engine. Well, that actually will help you to write better, faster code with optimized microservices. That knowledge will help you to write optimization-friendly code. The JavaScript engine is not always able to apply optimization and, in some cases, it depends on your writing style. It is possible to write deoptimization <a id="_idIndexMarker164"/>code that might be difficult for your JavaScript <a id="_idIndexMarker165"/>engine to optimize. That is why it is better to always understand the internals. For instance, using the <strong class="source-inline">delete</strong>, <strong class="source-inline">evals</strong>, <strong class="source-inline">arguments</strong>, and <strong class="source-inline">with</strong> keywords and mechanisms such as <em class="italic">hidden classes </em>and<em class="italic"> inline caching</em> may slow down code optimization. These concepts are beyond our book, but you can learn about them by checking the open source JavaScript tutorials <span class="No-Break">and documentation.</span></p>
			<p>The next thing we need to talk about is the single-threaded nature of JavaScript, and believe me, things get interesting when we dive into the <span class="No-Break">threading details.</span></p>
			<h3>Threading in JavaScript</h3>
			<p>As we mentioned before, JavaScript is a single-threaded, blocking, synchronous programming <a id="_idIndexMarker166"/>language that has only one call stack. JavaScript is "single-threaded," but it's not necessarily "blocking." It is synchronous by default but can handle asynchronous code execution using callbacks, promises, and async/await. But what does this mean and why do we need to understand it? Well, most programming languages support multithreading out of the box. This means it is possible to run multiple independent operations at a given time. But when it comes to JavaScript, things are a bit different. It is possible to run only one set of instructions at a given time for JavaScript natively, and this is a big problem in the world of multithreading, especially for long-running tasks. Fortunately, when you deal with JavaScript, you’re not dealing with only a JavaScript engine but also something called a <span class="No-Break"><strong class="bold">JavaScript runtime</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>JavaScript runtime</h2>
			<p>The browser, by its <a id="_idIndexMarker167"/>nature, is a wrapper and a runtime for the JavaScript engine. The responsibility of the runtime is to provide <em class="italic">additional</em> support to implement all the required functionalities for the given context. Here, in browsers, the context is a web-based interactive application. Node.js is also a runtime based on Google’s V8 engine. Engines help you to extend native JavaScript engine functionalities even more and <a id="_idIndexMarker168"/>add an async nature to them. These functionalities together in the browser are called <strong class="bold">web APIs</strong>. To see browser-based, important web APIs, just do the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Open your favorite browser (in our case, it is <span class="No-Break">Google Chrome).</span></li>
				<li> Right-click and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Inspect</strong></span><span class="No-Break">.</span></li>
				<li> Go to the <strong class="bold">Console</strong> tab and <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">window</strong></span><span class="No-Break">.</span></li>
				<li><span class="No-Break">Hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>You can <a id="_idIndexMarker169"/>also see this in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 3.4: window global object" src="image/B09148_03_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: window global object</p>
			<p>The elements of the <strong class="source-inline">window</strong> object (its properties and methods) that you can see are in addition to your JavaScript engine, which is built into the browser you use. Browsers have web APIs that are approximately similar for all of them. Most core web APIs are designed to be standardized so that websites can function similarly across different browsers. However, there can be minor differences in implementation or features between browsers, and some APIs might be specific to a particular browser. Most popular API functions, such as <strong class="source-inline">fetch</strong>, <strong class="source-inline">settimeout</strong>, <strong class="source-inline">setinterval</strong>, and <strong class="source-inline">document</strong>, are part of this huge API called <strong class="source-inline">window</strong>. It means they are not native JavaScript functions but engine-based functions for us in the given context. Web APIs decorate our JavaScript code with <span class="No-Break">async behaviors.</span></p>
			<p>When you write code that has these functions (<strong class="source-inline">fetch</strong>, <strong class="source-inline">document</strong>, etc.), the JavaScript engine will forward them to the web APIs. Web APIs are written in low-level languages (in most cases in C/C++) and after execution, your callback, which is provided in the given instruction, will be <a id="_idIndexMarker170"/>added to the <em class="italic">callback queue</em>. All native JavaScript functions will be executed directly in the call stack, but non-native instructions need to be executed first in the web API and the result of the execution, as a callback, will be added to the callback queue (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></p>
			<p>There is <a id="_idIndexMarker171"/>also the <em class="italic">event loop</em>. The responsibility of the event loop is just to check the call stack and to push callback queue elements there only if it <span class="No-Break">is empty.</span></p>
			<p>To make sure <a id="_idIndexMarker172"/>all the terms we mentioned are understood well, let’s consider a simple example. Look at <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 3.5: JavaScript event loop with a callback queue" src="image/B09148_03_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: JavaScript event loop with a callback queue</p>
			<p>Open your favorite web browser, right-click on the page, select <strong class="bold">Inspect</strong>, select the <strong class="bold">Console</strong> tab, and paste the following code. You can find <strong class="source-inline">event_loop.js</strong> in the <strong class="source-inline">Ch03</strong><strong class="source-inline">/js</strong> folder of the book’s <span class="No-Break">GitHub repository:</span></p>
			<pre class="source-code">
function print(message) {
    console.log(message);
}
setTimeout(() =&gt; {
print("Message from Timeout");
}, 0);
print("Message 1");
print("Message 2");</pre>			<p>Here in our code, you might expect to see <strong class="source-inline">setTimeout</strong>’s message first and then other messages in <a id="_idIndexMarker173"/>the given order. Because we have specified <strong class="source-inline">0</strong> for <strong class="source-inline">setTimeout</strong>, it should immediately execute our code. But the output is different, as we can see in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 3.6: The call stack executes a queue item at the end" src="image/B09148_03_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: The call stack executes a queue item at the end</p>
			<p>As you might guess, if the executed function is non-native, which means it is a web-API-based function, then the JavaScript engine will forward it to the web API, and after execution, its callback will be added to the callback queue. Meanwhile, <strong class="source-inline">setTimeout</strong> is going to be a non-blocking, asynchronous operation, and that is why we see the result of <strong class="source-inline">print</strong> <span class="No-Break">functions first.</span></p>
			<p>So, it doesn’t matter if you have set <strong class="source-inline">0</strong> or more as the second argument to <strong class="source-inline">setTimeout</strong>; it goes through the pipeline we explained anyway. The event loop will check whether the call stack is empty and when both <strong class="source-inline">print</strong> functions are done, it does become empty, so we’re able to see the result of <strong class="source-inline">setTimeout</strong> only after the event loop pushes it to the <span class="No-Break">call stack.</span></p>
			<p>Now let’s talk about the asynchronous nature of JavaScript in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Callback-based asynchronous JavaScript</h2>
			<p><strong class="bold">Callback</strong> is a <a id="_idIndexMarker174"/>common term in programming that is used when you want to send a function as an argument to another function. A function can accept not only simple <a id="_idIndexMarker175"/>data but also an expression. Callbacks are actively used by a web API. When you add some event listeners, or start <strong class="source-inline">setTimeout</strong> or <strong class="source-inline">setInterval</strong>, you usually rely <span class="No-Break">on callbacks.</span></p>
			<p>Callbacks are indispensable, but sometimes their usage makes your code less understandable and less maintainable, especially from an asynchronous code perspective. To prove that, go to <strong class="source-inline">callback_hell.html</strong> and run it in any browser. (You can find <strong class="source-inline">callback_hell.html</strong> in the <strong class="source-inline">Ch03</strong> folder of the book’s GitHub repository. For the sake of simplicity, all the GitHub repository references will contain only the path, i.e., <strong class="source-inline">Ch03</strong><strong class="source-inline">/callback_hell.html</strong>.) </p>
			<p>The file contains callback-based multiple asynchronous actions that we call <span class="No-Break"><em class="italic">callback hell</em></span><span class="No-Break">.</span></p>
			<pre class="source-code">
addScript("js/app.js", (script, error) =&gt; {
        if (error) {
          addErrorMessage("main", error.message);
        } else {
          setTimeout(() =&gt; {
            let message = execute();
            addSuccessMessage("main", message);
            setTimeout(() =&gt; {
              message = "operation completed successfully";
              addSuccessMessage("main", message);
              setTimeout(() =&gt; {
                message = "ready for another execution";
                addSuccessMessage("main", message);
              }, 2000);
            }, 3000);
          }, 4000);
        }
      });</pre>			<p>Here is <a id="_idIndexMarker176"/>what this <span class="No-Break">script does:</span></p>
			<ol>
				<li>Dynamically adds the provided script to the head of the <span class="No-Break">HTML file.</span></li>
				<li>Runs a function that belongs to that script (in our case, it is an <span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break"> function).</span></li>
				<li>Runs the <strong class="source-inline">operation completed successfully</strong> message after <span class="No-Break"><strong class="source-inline">three</strong></span><span class="No-Break"> seconds.</span></li>
				<li><strong class="source-inline">Three</strong> seconds after the preceding message runs, it outputs the <strong class="source-inline">ready for another execution</strong> message to the console. If the loaded file doesn’t exist, then the error message will be printed as <span class="No-Break">an output.</span></li>
			</ol>
			<p>As you can see, the code is hard to read, understand, and maintain this code due to its nesting. In software development, <em class="italic">maintaining</em> refers to the ongoing process of keeping software functioning properly, secure, and up to date. It might be more complex if you have more operations <span class="No-Break">to do.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>The way to promises</h2>
			<p>While callbacks are still a main part of JavaScript, promises are the preferred way to handle <a id="_idIndexMarker177"/>asynchronous operations in modern JavaScript development due to the benefits they offer in readability, error handling, and <span class="No-Break">code maintainability.</span></p>
			<p><strong class="bold">Promises</strong> were added in <a id="_idIndexMarker178"/>JavaScript with the <strong class="bold">ECMAScript 6</strong> (<strong class="bold">ES6</strong>) specification, which was released in 2015. Before ES6, callback hell was a common way to handle asynchronous operations in JavaScript. Thanks to promises, now we have a clean and more manageable approach for asynchronous programming. We actively use promises in Node.js development, so it is crucial to understand and properly <span class="No-Break">use them.</span></p>
			<p>To create a promise, we use a <strong class="source-inline">Promise</strong> object. It has a single callback argument, which is called <strong class="source-inline">executor</strong>. It runs automatically when the promise is constructed successfully. The executor consists of <span class="No-Break">two callbacks:</span></p>
			<ul>
				<li><strong class="source-inline">resolve</strong>: We use this to inform a user about a <span class="No-Break">successful operation</span></li>
				<li><strong class="source-inline">reject</strong>:  We use this to indicate that something <span class="No-Break">went wrong</span></li>
			</ul>
			<p>When a promise is done, it should call one of the functions, either <strong class="source-inline">resolve</strong> (value) or <span class="No-Break"><strong class="source-inline">reject</strong></span><span class="No-Break"> (error).</span></p>
			<p>The promise is <a id="_idIndexMarker179"/>initially in a <strong class="source-inline">pending</strong> state. It will be moved to a <strong class="source-inline">fulfilled</strong> state if <strong class="source-inline">resolve</strong> happens; otherwise (if rejected), the state will be moved <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">rejected</strong></span><span class="No-Break">.</span></p>
			<p>The promise’s result is initially <strong class="source-inline">undefined</strong>. It will store <strong class="source-inline">value</strong> if <strong class="source-inline">resolve</strong> is executed; otherwise (if rejected), it will <span class="No-Break">store </span><span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 3.7: Promise state and result" src="image/B09148_03_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Promise state and result</p>
			<p>It is completely okay to use only <strong class="source-inline">resolve</strong> or <strong class="source-inline">reject</strong> for <strong class="source-inline">executor</strong> if you want to provide only one path for <span class="No-Break">your execution.</span></p>
			<p>Let’s try to implement the callback example in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em> <span class="No-Break">using promises.</span></p>
			<p><span class="No-Break">File: </span><span class="No-Break"><strong class="source-inline">Ch03</strong></span><span class="No-Break"><strong class="source-inline">/js/promise_chaining.js</strong></span></p>
			<pre class="source-code">
addPromisifiedScript ("js/app.js")
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = execute();
                addSuccessMessage("main", message);
                resolve();
              }, 4000);
            })
        )
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = "operation completed successfully";
                addSuccessMessage("main", message);
                resolve();
              }, 3000);
            })
        )
        .then(() =&gt;
            new Promise((resolve) =&gt; {
              setTimeout(() =&gt; {
                let message = "ready for another execution";
                addSuccessMessage("main", message);
                resolve();
              }, 2000);
            })
        )
        .catch((error) =&gt; addErrorMessage("main", error.message));</pre>			<p>Now, instead of <a id="_idIndexMarker180"/>nested callbacks, we have promise chaining. So, why should you choose promises over callbacks? Consider the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li>Thanks to their linear syntax, promises help us to make code easier <span class="No-Break">to follow</span></li>
				<li>We have <strong class="source-inline">.catch()</strong>, which provides a central way to <span class="No-Break">handle errors</span></li>
				<li>Promises allow you to chain multiple asynchronous operations together in a more <span class="No-Break">readable way</span></li>
				<li><strong class="source-inline">a</strong><strong class="source-inline">sync</strong>/<strong class="source-inline">await</strong> builds on top of promises and provides an even more synchronous looking way to write asynchronous code (we’ll learn about <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> in this <span class="No-Break">chapter too)</span></li>
			</ul>
			<p>How about making the promise-based code <span class="No-Break">more readable?</span></p>
			<p><span class="No-Break">File: </span><span class="No-Break"><strong class="source-inline">Ch03</strong></span><span class="No-Break"><strong class="source-inline">/js/promise.js</strong></span></p>
			<pre class="source-code">
function delay(ms) {
        return new Promise((resolve) =&gt; setTimeout(resolve, ms));
      }
      addPromisifiedScript("js/app.js")
        .then(() =&gt; delay(4000))
        .then(() =&gt; {
          let message = execute();
          addSuccessMessage("main", message);
        })
        .then(() =&gt; delay(3000))
        .then(() =&gt; {
          let message = "operation completed successfully";
          addSuccessMessage("main", message);
        })
        .then(() =&gt; delay(2000))
        .then(() =&gt; {
          let message = "ready for another execution";
          addSuccessMessage("main", message);
        })
        .catch((error) =&gt; addErrorMessage("main", error.message));</pre>			<p>As you can see, adding a simple delay function can make our code more readable, instead of having <span class="No-Break">nested callbacks.</span></p>
			<p>A promise acts as a producer. If you want to handle the response of your promise, you need to register a consumer. This registration is mainly done by using a <strong class="source-inline">.then</strong> instruction. It is a <a id="_idIndexMarker181"/>continuation of a promise that gets the result of the previous promise. This instruction can handle both responses (success <span class="No-Break">and failure).</span></p>
			<p>Check the code here to see how we can handle success and error cases. When the operation succeeds in <strong class="source-inline">addPromisifiedScript</strong>, the <strong class="source-inline">resolve</strong> part of the code will be triggered; otherwise, <strong class="source-inline">reject</strong> will <span class="No-Break">be triggered:</span></p>
			<pre class="source-code">
addPromisifiedScript("js/app.js").then(
        (resolve) =&gt; {},//success continuation
        (reject) =&gt; {}//error handling
      );</pre>			<p>We often use <strong class="source-inline">.then()</strong> with only <strong class="source-inline">resolve</strong> mode. If you want to have one centralized way of handling errors, it is better to use <strong class="source-inline">.catch()</strong>, which is the equivalent of applying <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">then(null,reject=&gt; {})</strong></span><span class="No-Break">.</span></p>
			<p>You can set up a promise to handle online book orders (an async operation). You might get a confirmation <a id="_idIndexMarker182"/>email for the order (a resolved promise) or encounter an error (a rejected promise), but either way, you’re still finished interacting with the bookstore’s website (the <strong class="source-inline">finally</strong> block). You can put code in the <strong class="source-inline">finally</strong> block to clean things up after the promise is done, win or lose. This could be things such as turning off a loading wheel on your screen, closing a connection you don’t need anymore, or anything else that needs to happen regardless of <span class="No-Break">the outcome.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Promise API</h2>
			<p>Instantiating a <a id="_idIndexMarker183"/>promise object using a <strong class="source-inline">new</strong> keyword is not the only way of using it. The Promise API has several useful static methods that we can use in practice. Let’s take a look at them in the <span class="No-Break">following subsections.</span></p>
			<h3>Promise.all()</h3>
			<p>If you have <a id="_idIndexMarker184"/>multiple promises that need to be executed in parallel, and you need to wait for all <a id="_idIndexMarker185"/>of them to be ready, then <strong class="source-inline">Promise.all()</strong> might be a good choice. It returns an array of results if all promises resolve successfully or rejects as soon as one of the <span class="No-Break">promises fails.</span></p>
			<p>Open <strong class="source-inline">github_avatars.html</strong> in the GitHub chapter repository and run it by double-clicking <span class="No-Break">on it:</span></p>
			<pre class="source-code">
const usernames = ["TuralSuleymani", "rasulhsn"];
      const url = "https://api.github.com/users/";
      let requests = usernames.map((name) =&gt; fetch(url.concat(name)));
      Promise.all(requests)
        .then((responses) =&gt; Promise.all(responses.map((r) =&gt; 
          r.json())))
        .then((gitusers) =&gt;
          gitusers.forEach((user) =&gt; createAvatar(user.avatar_url))
        );</pre>			<p><strong class="source-inline">Promise.all()</strong> waits for all promises to be executed in parallel and be ready and then returns <span class="No-Break">multiple promises.</span></p>
			<p>In our example, we use it in <span class="No-Break">two scenarios:</span></p>
			<ul>
				<li>Fetching data from GitHub in parallel (<span class="No-Break"><em class="italic">line 25</em></span><span class="No-Break">)</span></li>
				<li>Getting data as JavaScriptON from all promises (<span class="No-Break"><em class="italic">line 27</em></span><span class="No-Break">)</span></li>
			</ul>
			<p>For <strong class="source-inline">Promise.all()</strong>, we wait <a id="_idIndexMarker186"/>for all promises to be successfully executed. If even one promise fails (doesn’t work out), <strong class="source-inline">Promise.all()</strong> immediately stops and <a id="_idIndexMarker187"/>gives up entirely. It forgets about all the other promises in the list and completely ignores <span class="No-Break">their results.</span></p>
			<p>The code we just looked at should render two Gi<a id="_idTextAnchor051"/>tHub users’ avatars as images in an <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">html</strong></span><span class="No-Break"> file.</span></p>
			<p>Imagine you have several tasks to run, such as fetching things from the internet. If one task fails, the others might still keep going. But <strong class="source-inline">Promise.all()</strong> won’t care about them anymore. They might finish eventually, but their results won’t be used. (<strong class="source-inline">Ch03</strong><strong class="source-inline">/js/promiseAPI.js</strong> contains all Promise API <span class="No-Break">examples demonstrated.)</span></p>
			<p>The following sample code shows that <strong class="source-inline">Promise.all</strong> accepts multiple promises as <span class="No-Break">an array:</span></p>
			<pre class="source-code">
Promise.all([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 1500))
  ])
  .then((success) =&gt; console.log(success))
  .catch(alert); // Error: Something went wrong!!</pre>			<p><strong class="source-inline">Promise.all()</strong> doesn’t try to stop the other tasks because there’s no way to cancel promises once <span class="No-Break">they’ve started.</span></p>
			<h3>Promise.allSettled()</h3>
			<p>Unlike <strong class="source-inline">Promise.all()</strong>, <strong class="source-inline">Promise.allSettled()</strong> is more patient. Even if one promise fails, it waits for all the promises to finish before giving you <span class="No-Break">the results.</span></p>
			<p>Imagine a <a id="_idIndexMarker188"/>similar scenario with the tasks. This time, <strong class="source-inline">Promise.allSettled()</strong> will wait for all the tasks to be completed, regardless of whether <span class="No-Break">one fails.</span></p>
			<p>In the end, it will <a id="_idIndexMarker189"/>give you a report on all the tasks, telling you whether each one succeeded (<strong class="source-inline">success resolve</strong>) or failed (<strong class="source-inline">Something </strong><span class="No-Break"><strong class="source-inline">went wrong!!</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
Promise.allSettled([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 1500))
  ])
  .then(results =&gt; {
    // 'results' is an array containing information about each promise (resolved or rejected)
    console.log(results);
  });</pre>			<p>This way, you get a complete picture of what happened with all your tasks, even if <span class="No-Break">some failed.</span></p>
			<h3>Promise.race()</h3>
			<p><strong class="source-inline">Promise.race()</strong> is like a race between promises. You provide it with a bunch of promises, and it waits for the very first one to either succeed <span class="No-Break">or fail.</span></p>
			<p>Whichever <a id="_idIndexMarker190"/>promise finishes first (wins the race), its result (a success or error value) becomes the result of <strong class="source-inline">Promise.race()</strong>. The rest of the promises <a id="_idIndexMarker191"/>are completely ignored, regardless of whether they eventually succeed <span class="No-Break">or fail:</span></p>
			<pre class="source-code">
Promise.race([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 2500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 3500))
  ])
  .then(result =&gt; {
    console.log(result);
  }).catch((err)=&gt;console.log('Error detected', err));</pre>			<p>You need to be careful when you use <strong class="source-inline">Promise.race</strong> for the <span class="No-Break">following reasons:</span></p>
			<ul>
				<li>It’s useful when you only need the result from the <span class="No-Break">fastest promise</span></li>
				<li>It stops listening to other promises as soon as <span class="No-Break">one finishes</span></li>
				<li>It returns the result (success value or error) from the <span class="No-Break">winning promise</span></li>
			</ul>
			<h3>Promise.any()</h3>
			<p><strong class="source-inline">Promise.any()</strong> waits for <a id="_idIndexMarker192"/>any of the promises to succeed, not <a id="_idIndexMarker193"/>necessarily the <span class="No-Break">first one.</span></p>
			<p>As soon as one promise resolves successfully, <strong class="source-inline">Promise.any</strong> immediately stops waiting for the others and returns the <span class="No-Break">success value.</span></p>
			<p>However, if all the promises in the list end up failing (rejected), <strong class="source-inline">Promise.any</strong> itself rejects with a special error called <strong class="source-inline">AggregateError</strong>. This error contains information about why all the individual <span class="No-Break">promises failed:</span></p>
			<pre class="source-code">
Promise.any([
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("success 
      resolve"), 2500)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new 
      Error("Something went wrong!!")), 1000)),
    new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve("another 
      success resolve"), 3500))
  ])
  .then(result =&gt; {
    console.log(result);
  }).catch((err) =&gt; console.log('Error detected', err));//will not be executed</pre>			<p>We also <a id="_idIndexMarker194"/>have <strong class="source-inline">Promise.resolve()</strong> and <strong class="source-inline">Promise.reject()</strong>, but they <a id="_idIndexMarker195"/>are rarely used due to the <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> keyword.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Async/await in JavaScript</h2>
			<p>Promises are so popular that there is a special syntax to work with them. This combination <a id="_idIndexMarker196"/>is called <strong class="bold">async/await</strong>. You can find all examples related to the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> keyword in the <strong class="source-inline">async_await.js</strong> file in the <span class="No-Break">chapter’s repository.</span></p>
			<p>You’re able <a id="_idIndexMarker197"/>to add an <strong class="source-inline">async</strong> keyword to any function, even just a simple function. But what is the value of using the <strong class="source-inline">async</strong> keyword before your functions? Well, the <strong class="source-inline">async</strong> keyword is a syntactical sugar that helps us to wrap our function to a promise. Check out <span class="No-Break">this function:</span></p>
			<pre class="source-code">
async function sayHello() {
    return "hello user";
}</pre>			<p>It is exactly the same <span class="No-Break">as this:</span></p>
			<pre class="source-code">
function sayHello() {
   return Promise.resolve("hello user");
}</pre>			<p>The async version <a id="_idIndexMarker198"/>of the function, behind the scenes, will generate a promise (<span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em>). This means that using this syntax, you’re able to add continuations such as <strong class="source-inline">.then()</strong>, <strong class="source-inline">.finally()</strong>, and .<strong class="source-inline">catch()</strong> to that function. It is just a <span class="No-Break">promise-based function.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 3.8: The async function is promise-based" src="image/B09148_03_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: The async function is promise-based</p>
			<p>So, the responsibility of async is to ensure that the functions always return a promise. But that is not all. There is another keyword in this pair that is called <strong class="source-inline">await</strong>. If you need to wait for your promise to be settled, then you’re able to use this keyword. Say we have a simple <strong class="source-inline">delayedMessage()</strong> function that returns exactly the same message as provided by the arguments but with <span class="No-Break">some delays:</span></p>
			<pre class="source-code">
function delayedMessage(msg) {
    return new Promise((resolve)=&gt; {
        setTimeout(() =&gt; {
            resolve(msg);
        }, 3000);
    });
}</pre>			<p>Instead of getting data by chaining (using <strong class="source-inline">.then</strong> ), you can simply apply a synchronous programming technique. This means just waiting for functions to return data, get the data, and <span class="No-Break">then continue:</span></p>
			<pre class="source-code">
let message = await delayedMessage("hello");//wait here for the Promise to be settled</pre>			<p>That is simple. So, instead of working with <strong class="source-inline">then</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong>, you can interact with <a id="_idIndexMarker199"/>promise-based functions using just async-based syntax. Put simply, await is just a more elegant way of working <span class="No-Break">with promises.</span></p>
			<p>Here is a simple example of fetching data from multiple URLs <span class="No-Break">using promises:</span></p>
			<p><span class="No-Break">File: </span><span class="No-Break"><strong class="source-inline">Ch03</strong></span><span class="No-Break"><strong class="source-inline">/js/getdata_promise.js</strong></span></p>
			<pre class="source-code">
const url = "https://jsonplaceholder.typicode.com";
const paths = ["/posts","/comments"];
let promises = Promise.all(paths.map(path=&gt; fetch(url.concat(path))));
promises.then(responses=&gt; Promise.all(responses.map(t =&gt; t.json())))
.then(data=&gt; {
    data.forEach(element =&gt; {
        console.log(element);
    });
})</pre>			<p>In our preceding example, we fetch data from <strong class="source-inline">/posts</strong> and <strong class="source-inline">/comments</strong> of the JavaScript <strong class="source-inline">onplaceholder</strong> URL <span class="No-Break">using promises.</span></p>
			<p>Using async/await, we’re able to simplify it, <span class="No-Break">like this:</span></p>
			<p><span class="No-Break">File: </span><span class="No-Break"><strong class="source-inline">Ch03</strong></span><span class="No-Break"><strong class="source-inline">/js/getdata_async.js</strong></span></p>
			<pre class="source-code">
const url = "https://jsonplaceholder.typicode.com";
const paths = ["/posts","/comments"];
let getData = async function() {
    const responses = await Promise.all( paths.map(path=&gt;fetch(url
      .concat(path))));
    constJavaScriptons = await Promise.all( responses
      .map(response=&gt;response.json()));
   JavaScriptons.forEach(element =&gt; {
        console.log(element);
    });
}
getData();</pre>			<p>Instead of using <strong class="source-inline">.then()</strong> every time, we are now able to use <span class="No-Break">synchronous-programming-based syntax.</span></p>
			<p>You might be wondering how to handle exceptions in this code? If we <a id="_idIndexMarker200"/>are free to not use <strong class="source-inline">.catch()</strong>, then how will we be able to catch exceptions? The answer here is also really simple: just <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">try..catch</strong></span><span class="No-Break">.</span></p>
			<p>We have talked enough about promises. It is time to see how JavaScript internally <span class="No-Break">handles promises.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Microtask queue</h2>
			<p>We’ve talked <a id="_idIndexMarker201"/>about promises and async/await. It is now the exact time to talk about the related topic of the <strong class="bold">microtask queue</strong>. The callback queue is not the only queue used by the JavaScript runtime. There is another important queue that is used by Node.js and classical, browser-based JavaScript. This is called the microtask queue (also known as an event queue or <strong class="source-inline">PromiseJobs</strong>) – see <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.8</em>. To better manage asynchronous tasks in JavaScript, the ECMA standard added this internal queue. It has approximately the same behavior as a callback queue in terms of the call stack because the execution of these tasks is possible only when nothing else is running in the <span class="No-Break">call stack.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 3.9: Microtask queue" src="image/B09148_03_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Microtask queue</p>
			<p>So, when a <a id="_idIndexMarker202"/>given promise is ready, the continuations, such as <strong class="source-inline">then</strong>/<strong class="source-inline">catch</strong>/<strong class="source-inline">finally</strong> handlers, are put into the queue. When the call stack is empty, the JavaScript engine <a id="_idIndexMarker203"/>will take these tasks in a <strong class="bold">First in, First out</strong> (<strong class="bold">FIFO</strong>) order and <span class="No-Break">execute them.</span></p>
			<p>Here is a simple <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">Ch03</strong></span><span class="No-Break"><strong class="source-inline">/js/microtasks.js</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
let promise = Promise.resolve();
promise.then(() =&gt; console.log("planning to see this message first"));
console.log("but this message will be seen first");</pre>			<p>The order of the output is seen in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 3.10: The output of the preceding code" src="image/B09148_03_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: The output of the preceding code</p>
			<p>Because, when the JavaScript engine detects a promise, it moves its <strong class="source-inline">.then()</strong> to the microtask queue. It is an async operation, so we directly switch to the next line. It is possible to execute a promise only if the call stack <span class="No-Break">is empty.</span></p>
			<p>Of course, the topics we discussed are not the whole list of topics you need to work with Node.js. We bypassed <a id="_idIndexMarker204"/>some simple and middle-level topics and covered only some important ones we think might help you when working with Node.js. JavaScript skills are essential, and you need to be aware of its syntax. Having better JavaScript skills will be a guide for you throughout the learning process of <span class="No-Break">the book.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/>Node.js essentials</h1>
			<p>Node.js is not a separate programming language. It is a runtime over Google’s V8 engine. This simply means <a id="_idIndexMarker205"/>that the creator of Node.js just took the V8 engine out of the browser and put it into another runtime. Node.js is a wrapper over the V8 engine and extends it by adding networking, APIs for I/O, and other operations. A key aspect of Node.js is its non-blocking I/O model. This means Node.js can handle multiple requests simultaneously without being blocked by slow operations. The event loop and callback queue become even more important in <span class="No-Break">this context.</span></p>
			<p>Node.js has different <a id="_idIndexMarker206"/>dependencies under the hood, but the most interesting one for us to discuss is <strong class="bold">Libuv</strong>. Libuv provides a thread pool for handling certain tasks, with four threads by default, but this can be configured based on the application’s requirements.This is the main magic that provides I/O-based non-blocking operations. It is written in C, and it provides an event-driven asynchronous I/O model. It is possible to perform blocking operations using a thread pool to distribute CPU loads. We have four threads to use in Libuv by default. For network-based async operations, Libuv relies on the OS itself, but for some other async functions, such as reading something from a file, Libuv relies on its thread pool. The concept of a thread pool allows us to do some important operations in a separate thread and not <span class="No-Break">block others.</span></p>
			<p>Node.js primarily focuses on asynchronous I/O and aims to minimize blocking operations. The thread pool is mainly used for tasks that cannot be efficiently handled asynchronously by the OS, such as intensive calculations or filesystem operations requiring <span class="No-Break">significant processing.</span></p>
			<p>Like in browsers, we have different queues to be used when it comes to the Node.js async nature. The general concept is the same. They both use an event-loop-based model, but for Node.js, we have some <span class="No-Break">more queues.</span></p>
			<p>The event loop is a mechanism that continuously operates while your Node.js application is running. It’s responsible for handling different asynchronous events. The event loop utilizes queues to organize these events, ensuring they are processed in the proper order. The event loop consists of six <span class="No-Break">different queues.</span></p>
			<p>The event loop <a id="_idIndexMarker207"/>utilizes several queues to manage different types of asynchronous operations (<span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.9</em>). These queues ensure tasks are processed in a specific order, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Timer queue</strong>: This queue <a id="_idIndexMarker208"/>holds callbacks scheduled with <strong class="source-inline">setTimeout</strong> and <strong class="source-inline">setInterval</strong> functions. These callbacks are executed after a specified delay or at regular intervals. (Technically, it’s a min-heap for <span class="No-Break">efficient scheduling.)</span></li>
				<li><strong class="bold">I/O queue</strong>: This queue <a id="_idIndexMarker209"/>contains callbacks associated with asynchronous I/O operations like those found in <strong class="source-inline">fs</strong> and <strong class="source-inline">http</strong> modules. The event loop processes these callbacks when the I/O <span class="No-Break">operation completes.</span></li>
				<li><strong class="bold">Check queue</strong>: This <a id="_idIndexMarker210"/>queue holds callbacks scheduled with <strong class="source-inline">setImmediate</strong>. These callbacks are considered a high priority and are executed before other tasks in the next <span class="No-Break">loop iteration.</span></li>
				<li><strong class="bold">Close queue</strong>: This <a id="_idIndexMarker211"/>queue contains functions meant to run when an asynchronous resource is closed, ensuring <span class="No-Break">proper cleanup.</span></li>
				<li><strong class="bold">Microtasks queue</strong>: These <a id="_idIndexMarker212"/>are further divided into <span class="No-Break">two sub-queues:</span><ul><li><strong class="bold">nextTick queue</strong>: This <a id="_idIndexMarker213"/>queue holds callbacks <a id="_idIndexMarker214"/>scheduled with <strong class="source-inline">process.nextTick</strong>. These are also a high priority and get executed immediately after the current <span class="No-Break">operation finishes.</span></li><li><strong class="bold">Promise queue</strong>: This <a id="_idIndexMarker215"/>queue contains <a id="_idIndexMarker216"/>callbacks associated with resolving or rejecting promises. These are processed whenever the event loop encounters a resolved or rejected promise during <span class="No-Break">its execution.</span></li></ul></li>
			</ul>
			<p>It’s important to note that the first four queues (timers, I/O, check, and close callbacks) are managed by Libuv. The microtask queues (<strong class="source-inline">nextTick</strong> and <strong class="source-inline">Promise</strong>) are separate but still play a <a id="_idIndexMarker217"/>crucial role in determining the order of callback execution within the <span class="No-Break">event loop.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 3.11: Node.js queues" src="image/B09148_03_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Node.js queues</p>
			<p>Let’s talk about the priority order of the queues. First things first, it is important to understand that user-written, synchronous JavaScript code has the highest priority over all of these queues. This simply means that these queue elements will be executed only if the call stack is empty. However, what about these six queue orders? We will discuss them in more <span class="No-Break">detail now:</span></p>
			<ul>
				<li><strong class="bold">Microtask queue</strong>: The event loop first checks for any callbacks in the microtask <a id="_idIndexMarker218"/>queue. It prioritizes the <strong class="source-inline">nextTick</strong> queue, executing those tasks first, followed by any callbacks in the <span class="No-Break">promise queue.</span></li>
				<li><strong class="bold">Timers</strong>: After <a id="_idIndexMarker219"/>microtasks, the event loop processes callbacks from the timer queue. This includes functions scheduled with <strong class="source-inline">setTimeout</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">setInterval</strong></span><span class="No-Break">.</span><p class="list-inset">After the timers queue, the event loop is going to check the microtask queue again. First, the <strong class="source-inline">nextTick</strong> queue will be executed, and then the <strong class="source-inline">promise</strong> queue will <span class="No-Break">be executed.</span></p></li>
				<li><strong class="bold">I/O callbacks</strong>: Next, the <a id="_idIndexMarker220"/>event loop handles callbacks from the I/O queue. These represent asynchronous operations, such as file I/O or network requests, which <span class="No-Break">have completed.</span></li>
				<li><strong class="bold">Microtask check (again)</strong>: The <a id="_idIndexMarker221"/>event loop checks for microtasks again after processing the I/O. This ensures that any microtasks created during those operations are <span class="No-Break">executed immediately.</span></li>
				<li><strong class="bold">Check queue</strong> (<strong class="source-inline">setImmediate</strong>): The event loop then executes callbacks from the check queue, which <a id="_idIndexMarker222"/>holds functions scheduled with <strong class="source-inline">setImmediate</strong>. These are considered high-priority tasks and run before other callbacks in the next <span class="No-Break">loop iteration.</span><p class="list-inset">After the check queue, the event loop is going to check the microtask queue again. First, the <strong class="source-inline">nextTick</strong> queue will be executed, and then the <strong class="source-inline">promise</strong> queue will <span class="No-Break">be executed.</span></p></li>
				<li><strong class="bold">Close callbacks</strong>: Finally, the <a id="_idIndexMarker223"/>event loop processes callbacks associated with closing asynchronous resources, ensuring <span class="No-Break">proper cleanup.</span><p class="list-inset">Check the microtasks queue again and execute callbacks if <span class="No-Break">they exist.</span></p></li>
				<li><strong class="bold">Microtasks throughout the loop</strong>: The event loop keeps the party going as long <a id="_idIndexMarker224"/>as there are callbacks waiting to be invited. Once everyone’s had their turn and there’s nothing left to do, it gracefully exits <span class="No-Break">the stage.</span></li>
			</ul>
			<p>As you might notice, microtasks are checked multiple times within the event loop. This ensures that any microtasks created during the execution of other callbacks are handled immediately. This prioritizes tasks scheduled with <strong class="source-inline">nextTick</strong> and <strong class="source-inline">promise</strong> resolutions, keeping the event <span class="No-Break">loop responsive.</span></p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/>Summary</h1>
			<p>This chapter was about JavaScript and <span class="No-Break">Node.js internals.</span></p>
			<p>First, we started our discussion with JavaScript internals. The main point was to understand the JavaScript engine and the JavaScript runtime. JavaScript is a single-thread language, but it has an async nature and we’re able to use callbacks and promises to implement it. In async programming, callbacks are a bit old school nowadays thanks to promises. We also talked about the Promise API and learned a lot of <span class="No-Break">interesting functions.</span></p>
			<p>The popularity of promises brings other interesting features to JavaScript: async/await. Using examples, we tried to demonstrate how they make our code more readable, understandable, and similar to <span class="No-Break">sync code.</span></p>
			<p>For promises, we have a special queue in the JavaScript engine pipeline called the <span class="No-Break">microtask queue.</span></p>
			<p>Then we started a discussion around Node.js and learned that it is also a runtime and uses the JavaScript engine to read and translate JavaScript code. It takesJavaScript to another level, and using Node.js, we can build real-time applications, microservices, web APIs, streaming applications, command-line tools, <span class="No-Break">and more.</span></p>
			<p>Internally, Node.js heavily relies on Libuv and provides tons of functionalities that mostly can be categorized under asynchronous I/O and thread pooling. Libuv provides the core functionality for Node.js’s asynchronous programming model, making it efficient and scalable for handling numerous concurrent connections and <span class="No-Break">I/O operations.</span></p>
			<p>The last discussion for this chapter was on Node.js queues and event loops. We have several queues in Node.js and they have special orders that we need to understand to build more <span class="No-Break">effective applications.</span></p>
			<p>In our next chapter, we will talk about the stack development technologies that you need to know before writing any lines <span class="No-Break">of code.</span></p>
		</div>
	</body></html>