- en: Working with Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we learned some basic concepts about the TypeScript
    type system, including the basics about the type inference system and the optional
    static type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the main features of the TypeScript type
    system, including the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The line between TypeScript and JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of the type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union types, intersection types, and discriminated unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type aliases and local types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `typeof` and `keyof` operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow analysis and type guards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-nullable types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapped types, lookup types, and conditional types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript type system's characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about the main characteristics of the
    TypeScript type system, including concepts such as type inference, optional type
    annotation, and the differences between a nominal type system and a structural
    type system.
  prefs: []
  type: TYPE_NORMAL
- en: The line between TypeScript and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important things that you are going to need to master to become
    a good TypeScript programmer is to be able to understand where TypeScript ends
    and JavaScript begins. It is very important to be able to understand what happens
    with our TypeScript code at three important phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design time**: This takes place when we are writing our TypeScript code and
    designing our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compilation time**: This takes place when we compile our TypeScript into
    JavaScript code (some compilation errors may take place). Compilation time has
    subphases, such as parsing the TypeScript code, creating an abstract syntax tree
    (ATS), and emitting JavaScript code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution time** (also known as runtime): This takes place when we execute
    the output JavaScript code generated by the TypeScript compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript types are declared or inferred at design time and used during
    compilation time, but they are not available at execution time because they are
    not part of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about many of the TypeScript type system
    features. If you are familiar with JavaScript, you will notice the differences
    straight away but, if you are not familiar with JavaScript, I would recommend
    examining the generated JavaScript output after compiling the code samples included
    in this chapter. Over time, you will slowly earn the experience required to have
    a clear vision of the line between TypeScript and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding
    the Runtime*, to learn more about the execution time phase (JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript tries to find the types of the variables and objects in our application
    using what is known as **type inference**. When we declare a variable, TypeScript
    will try to observe the value assigned to the variables in the application to
    identify its type. Let''s examine some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The type of the variable `myVariable1` is inferred as a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The type of the variable `myVariable2` is inferred as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the variable `myVariable3` is inferred as the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The type any is assigned in the cases in which TypeScript is not able to identify
    the type of a variable. For example, given the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the function `add` is inferred as the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The type `any` is problematic because it prevents the TypeScript compiler from
    identifying many potential errors. Fortunately, TypeScript features optional type
    annotations that can be used to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Optional static type annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript allows us to use type annotations to overcome the scenarios in which
    the type inference system is not powerful enough to automatically detect the type
    of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the `add` function one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of the function `add` is inferred as the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding type is a problem because the usage of the `any` type effectively
    prevents the TypeScript compiler from detecting certain errors. For example, we
    might expect the `add` function to add two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we pass a string as input, we will encounter an unexpected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error can happen very easily if, for example, the arguments provided
    to the `add` function have been extracted from an HTML input and we forget to
    parse them as a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix the `add` function by adding optional type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add an optional type annotation by adding a colon (`:`) after the declaration
    of a variable followed by the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the case of functions, we can add annotations to the arguments of the function
    and its returned value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the type of the arguments of the `add` function are `number`, instead
    of `any`, the TypeScript compiler will be able to detect potential issues if we
    provide arguments of the `worn` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In general, we should try to leverage the type inference system and use optional
    static type annotations only when the type inference system is not powerful enough
    to automatically detect the type of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Structural type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the type system of a programming language, a type is an object with a name
    and a structure. Some types have very simple data structures (such as primitives)
    while others use complex structures (such as classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The type system can use two different strategies to validate that a given value
    matches the desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nominal type system**: In this type system, values are matched against a
    type by its name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural type system**: In this type system, values are matched against
    a type by its structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The TypeScript type system is a structural type system because the values are
    matched against a type by its structure, as the following code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we can observe how the first two calls to the
    `getFullName` function are successful because the structure (properties and types)
    of both the `Employer` instance and the object literal match the structure of
    the `Person` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet showcases how TypeScript would work if it used a
    nominal type system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `getFullName` works because the `Employer` class implements
    the `Person` interface, and the name of the type of the interface can then be
    matched against the name of the type of the function argument.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript team is currently investigating the possibility of potentially
    adding support for a nominal type system as well. You can learn more about the
    progress at [https://github.com/Microsoft/TypeScript/issues/202](https://github.com/Microsoft/TypeScript/issues/202)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Core features of the TypeScript type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about some of the core features of the
    TypeScript type system. This includes concepts such as union types, intersection
    guards, type guards, and type aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Union types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript allows you to declare union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have declared a variable named `path` that can
    contain a single path (string) or a collection of paths (array of strings). In
    the example, we have also set the value of the variable. We assigned a string
    and an array of strings without errors; however, when we attempted to assign a
    numeric value, we got a compilation error, because the union type didn't declare
    a number as one of the valid types of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Union types are used to declare a variable that can store a value of two or
    more types. Only the properties available in all the types present in the intersection
    type are considered valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b061ccf-0238-48be-acee-3f26eb3689d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can appreciate this behavior in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript allows us to declare type aliases by using the `type` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases are exactly the same as their original types; they are simply alternative
    names. Type aliases can help us to make our code more readable, but it can also
    lead to some problems.
  prefs: []
  type: TYPE_NORMAL
- en: If you work as part of a large team, the indiscriminate creation of aliases
    can lead to maintainability problems. The book *Maintainable JavaScript*, *Nicholas
    C. Zakas* recommends that you *"avoid modifying the objects you don't own"*. Nicholas
    was talking about adding, removing, or overriding methods in objects that have
    not been declared by you (DOM objects, BOM objects, primitive types, and third-party
    libraries), but we can apply this rule to the use of aliases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Intersection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Anders Hejlsberg added intersection types to TypeScript for the first
    time, he defined them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Intersection types are the logical complement of union types. A union type
    A | B represents an entity that has either type A or type B, whereas an intersection
    type A & B represents an entity that has both type A and type B."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares three interfaces named `A`, `B`, and `C`. Then
    it declares an object named `abc`, whose type is the intersection type of the
    interfaces `A`, `B`, and `C`. As a result, the `abc` object has properties named
    `a`, `b`, and `c`, but not `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Intersection types can also be applied to subproperties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be applied to functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties available in one or all the types present in the intersection
    type are considered valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39abf20c-3de5-49c2-9610-b46b9ac87d79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can appreciate this behavior in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Non-nullable types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript 2.0 introduced what are known as non-nullable types. TypeScript used
    to consider null and undefined to be valid values of every type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents the values that can be assigned to the type
    number when non-nullable types are disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26d29c5-8b7e-4eba-89dd-163e4605358d.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding diagram, `undefined` and `null` are allowed as
    values of the type number, together with the `NaN` value and all the possible
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: NaN, standing for not a number, is a numeric data type value representing an
    undefined or non-representable value, especially in floating-point calculations.
    Systematic use of NaNs was introduced by the IEEE 754 floating-point standard
    in 1985, along with the representation of other non-finite quantities such as
    infinities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how `undefined` and `null` are allowed
    as values of the type number when non-nullable types are disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be said about all other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When non-nullable types are enabled, the values `null` and `undefined` are
    considered independent types and stop being considered as valid values of the
    type number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a785a982-e504-42b5-b136-735465473c16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet demonstrates how `undefined` and `null` are not
    allowed as values of the type number when non-nullable types are enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be said about all other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can enable non-nullable types by using the `**--**strictNullChecks` compilation
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When non-nullable types are enabled, we can use union types to create nullable
    versions of a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The --strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript allows us to use the `--strict` compilation flag to enable all strict
    type checking options. Enabling `--strict` enables `--noImplicitAny`, `--noImplicitThis`,
    `--alwaysStrict`, `--strictPropertyInitialization`, and `--strictNullChecks`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `--strictNullChecks` compilation flag enables non-nullable types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--noImplicitAny` flag forces us to explicitly declare the type of a variable
    when the type inference system is not able to automatically infer the correct
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--alwaysStrict` flag forces the TypeScript parse to use the strict mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--noImplicitThis` flag forces us to explicitly declare the type of the
    this operator in functions when the type inference system is not able to automatically
    infer the correct type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--strictPropertyInitialization` flag forces class properties to be initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about the JavaScript use strict and the this operator in
    [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `--strict` compilation flag makes the TypeScript compiler much stricter.
    Enabling this option in existing large TypeScript projects can lead to the discovery
    of many errors that may require a significant effort to fix. For this reason,
    it is recommended to enable the `--strict` compilation flag in greenfield TypeScript
    projects and enable the individual flags (`--noImplicitAny`, `--noImplicitThis`,
    `--alwaysStrict`, and `--strictNullChecks`) progressively in existing TypeScript
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: The `--noImplicitReturns` compilation flag is not one of the flags enabled by
    the `--strict` flag. The flag throws an error when not all code paths in function
    return a value. It is also recommended that you enable this flag in greenfield
    TypeScript projects or when possible on existing projects.
  prefs: []
  type: TYPE_NORMAL
- en: The typeof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `typeof` operator can be used at runtime (JavaScript):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that it can also be used at design time (TypeScript)
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Type guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can examine the type of an expression at runtime by using the `typeof` or
    `instanceof` operators. The TypeScript language service looks for these operators
    and will narrow down the inferred type accordingly when used in an `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have declared a variable named `x` of type
    `any`. Later, we check the type of `x` at runtime by using the `typeof` operator.
    If the type of `x` results to be a string, we will try to invoke the method `splice`,
    which is supposed to be a member of the `x` variable. The TypeScript language
    service can understand the usage of `typeof` in a conditional statement. TypeScript
    will automatically assume that `x` must be a string and let us know that the `splice`
    method does not exist on the type string. This feature is known as **type guards**.
  prefs: []
  type: TYPE_NORMAL
- en: Custom type guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define custom type guards using by declaring a function with a special
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet declares two types (`Supplier` and `Customer`); it
    then declares a custom type guard function. The custom type guard returns a Boolean
    value. The function returns true when the provided value `person` has a property
    named `orderItems` and false when the property is missing.
  prefs: []
  type: TYPE_NORMAL
- en: The function is trying to identify the type at runtime by examining the properties
    of the value. This kind of type matching is known as **pattern matching**.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about pattern matching in [Chapter 7](72a4e9e7-a9ca-476d-bd54-f8dc5f76dafe.xhtml),
    *Functional Programming with TypeScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern matching is not the only technique that we can use to identify if a
    value matches a type. We can also use the `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another technique that we can use to identify if a value matches a type is
    to use the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet throws a compilation error within the `if` block
    because TypeScript knows that the variable `x` must be a string within the block.
    Another error is thrown outside of the `if` block, because TypeScript cannot guarantee
    that the type of the variable x is string at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since TypeScript 2.7, we can use the `in` operator as a type guard to narrow
    down a given type, as demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Control flow analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript includes a feature known as control flow analysis that is used to
    identify the type of a variable, based on the execution flow of a program. This
    feature allows TypeScript to have more precise type inference capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example defines a function that takes two arguments, and the
    type of one of them (named value) is the union type of number and array of number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Within the body of the function, we use an `if` statement to determine if the
    value variable is indeed an array of numbers or just a number. The type inference
    system will change the inferred type of the argument to match the correct type
    accordingly with the two paths of the `if...else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow analysis improves the type checker's understanding of variable
    assignments and control flow statements, thereby greatly reducing the need for
    type guards.
  prefs: []
  type: TYPE_NORMAL
- en: Literal types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Literal types allow us to declare the exact value that a string Boolean or
    number must have. When we declare a variable using the `let` keyword, its value
    will be inferred as a primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we use the `const` keyword, the type is inferred as the actual
    assigned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Literal types can be used in combination with union types, type guards, and
    type aliases with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Literal types can be used in combination with type guards and the power of control
    flow analysis to narrow union types using a technique known as discriminated unions.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A discriminated union (also known as tagged unions or algebraic data types)
    is an advanced pattern that combines string literal types, union types, type guards,
    and types aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated unions use a type guard to narrow union types based on tests of
    a discriminant property (a string literal type) and furthermore extend that capability
    to switch statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares three types that share a string literal
    property named `kind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare the union type of the three types declared in the preceding
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, the `switch` statement acts as a type guard. The
    type of shape is narrowed in each case clause, according to the value of the discriminant
    property, `kind`, thereby allowing the other properties of that variant to be
    accessed without a type assertion.
  prefs: []
  type: TYPE_NORMAL
- en: The never type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described in the TypeScript documentation, the `never` type has the following
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `never` type is a subtype of and assignable to every type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No type is a subtype of or assignable to `never` (except `never` itself).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a function expression or arrow function with no return type annotation, if
    the function has no `return` statements or only `return` statements with expressions
    of type `never` and, if the end point of the function is not reachable (as determined
    by control flow analysis), the inferred return type for the function is `never`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a function with an explicit never return type annotation, all `return` statements
    (if any) must have expressions of a type `never` and the end of the function must
    not be reachable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In JavaScript, when a function doesn''t explicitly return a value, it implicitly
    returns the value `undefined`. In TypeScript, the return type of such a function
    is inferred as void. When a function doesn''t complete its execution (it throws
    an error or never finishes running at all), its return type is inferred as `never`
    by TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also encounter the `never` type when we reach impossible matches in
    discriminated unions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the default case will never be executed; therefore,
    the return type is inferred as the never type.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations allow us to define a set of named constants. Since the TypeScript
    2.4 release, these named constant values can be string values. Originally, they
    could only be numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A common workaround to this limitation was the usage of union types of literal
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the TypeScript 2.4 release, enumerations with string values are also
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects can be initialized using new `Object()`, `Object.create()`, or using
    the object literal notation, also known as initializer notation. An object initializer
    is a comma-delimited list of zero or more pairs of property names and values of
    an object, enclosed in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The type inference system can automatically infer the type of object literals.
    The inferred type for the variable person declared in the preceding code snippet
    is `{ name: string, age: number }`. Alternatively, we can explicitly declare the
    type of an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to declare optional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to [Chapter 1](25c1bc9f-0f52-4708-853f-62dde27407b2.xhtml)*, Introducing
    TypeScript,* to learn more about the difference between the empty object type
    (`{}`), the Object (uppercase) type, and the object (lowercase) type.
  prefs: []
  type: TYPE_NORMAL
- en: Weak types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A weak type is an object literal type in which all properties are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript allows us to add a value with some or all the properties defined
    in the weak type, but it doesn''t allow us to assign properties that are not part
    of the weak type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The keyof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `keyof` operator can be used to generate a union type of the properties
    of an object as string literal types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyof` operator can be used in combination with other operators, such
    as the `typeof` operator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We will find out more about the `keyof` operator later in this chapter when
    we learn about lookup types.
  prefs: []
  type: TYPE_NORMAL
- en: Index signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, we can access the properties of an object using the name of
    the object followed by a dot and the name of the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also possible to access the properties of an object using the
    name of the object followed by the name of the property as a string wrapped by
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be declared using what is known as the index signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the index signature allows us to
    specify the type of the value returned when we access a property using the brackets
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: Local types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript type system allows us to declare types (such as type aliases,
    classes, and interfaces) within the declaration of functions and methods. In the
    early releases of TypeScript, this was not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Type casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The TypeScript type system allows us to cast a given type using two different
    syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that the TypeScript casting does not affect the
    runtime type of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Since Typescript 1.6, the default is `as`, because `<>` is ambiguous in `.tsx`
    files. We will learn more about `.tsx` files in [Chapter 11](b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml)*,
    Frontend Development with React and TypeScript.*
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is recommended to avoid using type castings and prefer generic
    types instead.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of the TypeScript type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn some advanced type system features such
    as generic types, mapped types, and lookup types.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic types can help us avoid using type casting and increase the reusability
    of our code by allowing us to declare (`T`) when a function, class, or method
    is consumed, as opposed to when it is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example declares a function named deserialize. The type returned
    by the function (T) is unknown at the point in which the function is declared.
    The function is then invoked on two occasions, and the type T becomes finally
    known (User and Rectangle).
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about generic types in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript.*
  prefs: []
  type: TYPE_NORMAL
- en: Generic constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we don't need the concrete type required by a function, class, or
    method, but we know that such type must adhere to a certain set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet declares a generic function named `isEquals`.
    However, this time the type `T` has a constraint (`T` extends `Comparable`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraint is used to ensure that all the types provided to `isEqual` as
    its generic type argument implement the `Comparable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Mapped types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mapped types are an advanced type feature that allows us to map the value of
    each of the properties of a type to a different type. For example, the following
    mapped type transforms the value of the properties of a given type to a string
    literal that matches the property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function takes an object and returns a new object in which all
    the properties have the same names, but their values are the names of the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Lookup types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lookup types are another advanced type system feature that allow us to combine
    the `keyof` operator with generic and object literals to create advanced type
    annotations. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes two generic type arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the type of the items in the array passed as the first argument of the
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`K` is the name of the properties of `T`. This requirement is enforced by a
    generic constraint (extends `keyof T`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function also expects two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: An array of entities of type `T`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value of type `T[K]`. The type `T[K]` represents the type of the value of
    the property `K` in the type `T`, and it is known as lookup type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding function can be used to filter the array of entities of type
    `T` by one of the properties of the type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Mapped type modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript 2.8 introduced a few operators that allow us to have a greater level
    of control over the definition of mapped types:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `readonly` modifier to flag a property as immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `?` operator to flag a property as optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `+` operator to apply a modifier, such as the `readonly` modifier,
    to a property in a type. We can also use the `+` operator with the `?` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `-` operator to apply a modifier, such as the `readonly` modifier
    to a property in a type. We can also use the `+` operator with the `?` operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now examine a few examples. The code snippet declares a mapped type
    that can be used to transform a type, `T`, into a new type that contains all the
    properties in `T` but is marked as both `readonly` and `optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following type declaration is identical to the one in the preceding code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following type can be used to remove the `readonly` modifier from all the
    properties in a given type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the `Mutable` type to the following interface to generate a new
    type. The `abc` property is no longer immutable, but the `def` property is still
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following code snippet declares a mapped type that can be used
    to remove the optional properties in a given type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Conditional types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional mapped types are an advanced feature introduced in TypeScript 2.8\.
    Previously in this chapter, we learned that we could use the `extends` keyword
    to declare generic constraints. When we declare a generic constraint, we are using
    the `extends` keyword as a kind of operator that allows us to check if a generic
    type (`T`) is a subtype of a given type. For example, the following code snippet
    declares two interfaces named `Animal` and `Dog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `extends` keyword as a conditional operator to generate a new
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Conditional types can be used to declare some complex types. For example, the
    `Flatten` function is a function that transforms a multi-dimensional array (`[][]`)
    into an array with only one dimension (`[]`). The type of the return of `Flatten`
    function is a conditional type, because it returns an array when a multidimensional
    array is provided and a number when an array with only one dimension is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The infer keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we have defined the `Flatten` type. However, this
    behavior was hardcoded to return a number when an array of one dimension is provided.
    This means that the `flatten` type only works as expected with arrays of numbers.
    Fortunately, since the TypeScript 2.8 release, we can use the `infer` keyword
    to overcome this limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `infer` keyword can be used in other scenarios. For example, we can use
    it to infer the return type of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Built-in conditional types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we have used the `ReturnType` type to extract the
    return type of a given function. The `ReturnType` type is included as a built-in
    type. TypeScript 2.8 includes many other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The polymorphic this type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, the value of the `this` operator is determined by the way a function
    or method is invoked. In a method, the `this` operator usually points to the class
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The polymorphic `this` type is an improved version of the original type inference
    for the `this` operator that introduced the following behavior as documented by
    Anders Hejlsberg:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of `this` in an expression within a nonstatic class or interface member
    is an instance of some class that derives from the containing class, as opposed
    to simply an instance of the containing class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` keyword can be used in a type position within a nonstatic class or
    interface member to reference the type of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a class or interface is referenced as a type, all occurrences of the `this`
    type within the class (including those inherited from base classes) are replaced
    with the type itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This feature makes patterns such as fluent interfaces ([https://en.wikipedia.org/wiki/Fluent_interface](https://en.wikipedia.org/wiki/Fluent_interface))
    much easier to express and implement, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A fluent interface allows us to invoke multiple methods in an object by connecting
    them with dots, without having to write the object name each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the class methods return the `this` type, we can invoke multiple methods
    without having to write the class name multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the class uses the `this` type, we can extend it and the new class can
    then provide a fluent interface that includes the base methods as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml), *Understanding the
    Runtime,* we will learn much more about the `this` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ambient declaration allows you to create a variable in your TypeScript
    code that will not be translated into JavaScript at compilation time. This feature
    was designed to make the integration with the existing JavaScript code and the
    **Document Object Model** (**DOM**) and **Browser Object Model** (**BOM**) easier.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to call the member log of an object named `customConsole`, TypeScript
    will let us know that the `customConsole` object has not been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a surprise. However, sometimes we want to invoke an object that
    has not been defined, for example, the `console` or `window` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: When we access the DOM or BOM objects, we don't get an error because these objects
    have already been declared in a special TypeScript file known as **declaration
    files**. You can use the `declare` operator to create an ambient declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will declare an interface that is implemented
    by the `customConsole` object. We then use the `declare` operator to add the `customConsole`
    object to the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces are explained in greater detail in [Chapter 4](841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml)*,
    Object-Oriented Programming with TypeScript.*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the `customConsole` object without compilation errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript includes, by default, a file named `lib.d.ts` that provides interface
    declarations for the built-in JavaScript library as well as the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration files use the file extension `.d.ts` and are used to increase the
    TypeScript compatibility with third-party libraries and runtime environments,
    such as Node.js or a browser.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to work with declaration files in [Chapter 5](90552e19-d0e2-4dc5-82fd-b580d76ec6e8.xhtml)*,
    Working with Dependencies.*
  prefs: []
  type: TYPE_NORMAL
- en: Type declarations – .d.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we will need to consume an existing JavaScript file, but we will
    not be able to migrate it to TypeScript. A common example of this scenario is
    when we consume a third-party JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: If the library is open source, we could contribute to it by migrating it to
    TypeScript. However, sometimes, using TypeScript might not align with the preferences
    of the library authors, or the migration may require a significant amount of work.
    TypeScript solves this problem by allowing us to create special kinds of files
    known as type declarations or type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned that, by default, TypeScript includes a 
    `lib.d.ts` file that provides interface declarations for the built-in JavaScript
    objects, as well as the DOM and BOM APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The type definition files contain the type declarations of third-party libraries.
    These files facilitate the integration between the existing JavaScript libraries
    and TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of all the TypeScript features while consuming a JavaScript
    library, we need to install the type definition file of such library. Fortunately,
    we don't need to create the type definition files by hand, because there is an
    open source project known as **DefinitelyTyped** that already contains some type
    definition files for many of the existing JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of TypeScript development, developers had to manually download
    and install the type definition files from the DefinitelyTyped project website,
    but those days are long gone and today we can use the node package manager (npm)
    to install and manage the type definition files required by our TypeScript application.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to work with declaration files in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml)*,
    Automating Your Development Workflow.*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about many of the features of the TypeScript type
    system. At this point, we should now have a good understanding of concepts such
    type inference, non-nullable types, structural typing, and control flow analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about the usage of functions in TypeScript.
  prefs: []
  type: TYPE_NORMAL
