- en: Chapter 4. Building a Calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to build a calendar in this chapter. You might think that's what
    we built in the last chapter, but this one is going to be different; it will be
    like a very boiled-down version of Google Calendar. We'll be able to view a month
    or a day at a time, and plan events that span a certain number of hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Better application component organization, with only one global variable for
    the whole application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting model functionality inside model methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using disposable models to encapsulate important information that we don't need
    to store on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a single model instance in multiple views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can begin with the project template, as we have done before. However, we'll
    be using precompiled templates as we did in the previous chapter, and we'll also
    be separating our code into `models.js`, `views.js`, and `router.js`. You may
    choose to copy the previous project and clear out the custom code instead, so
    that you'll have the `Gruntfile.js` file that we created last time.
  prefs: []
  type: TYPE_NORMAL
- en: Planning our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we'll begin by planning our application. Our primary model will
    be the `Event` model. It has the same name as the model we created in the last
    chapter, but it's a bit different. This one will have a title, date, and start
    time and end time. We'll allow multiple events in one day, but events cannot overlap
    (because we can't be at two events at one time). Then, we'll also create a `Calendar`
    collection class to hold our events.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will have two screens. The first will be a month view, in a
    standard, tabular, wall-calendar style. Then, a click on one of the days in that
    view will switch us to a day view, which will give the hour-by-hour breakdown
    of events for that day. This will also be the screen from which we can create
    new events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model and collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the `Event` model class, which will go in the `models.js`
    file of the `public` folder. Separating our code into multiple files is a good
    first step for organization, but we can go one step further. Previously, each
    of our classes has been referenced by its own global variable. You probably know
    that this isn''t a really wise technique. If we''re using other libraries, frameworks,
    or plugins, we don''t want two components to use the same variable name and mess
    up the works. In this application, we''re going to put all our classes safely
    inside a single global object. So, we start the `models.js` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line may seem a bit tricky; why not just use `var App = {};`? Well,
    the technique I've used here allows us to not worry about the order our files
    are loaded in the browser. This line first checks to see whether `window.App`
    exists. If it does, it assigns it to itself (basically, it does nothing). If it
    doesn't exist, we can be sure that this is the first of our files to load, and
    so we create it as a blank object. This technique will work as long as we begin
    all our custom JavaScript files in this application in that way.
  prefs: []
  type: TYPE_NORMAL
- en: The next line creates a `Models` property. Our model and collection classes
    will be properties of this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re ready to create our `Event` model class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We're going to start with a basic model, but we'll be coming back to add a lot
    of functionality to it. As I mentioned earlier, putting model functionality inside
    model methods is one of the most important action points discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have our collection class, which is this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new or unique here. Notice that we do need to refer to our model
    class by its full name as a property, because it's not a global variable anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s actually one more model that we need to create; however, this model
    isn''t one that we''re going to store instances of on the server, or allow our
    users to know about; it''s just a class that we''re going to use internally, to
    make some of our view code simpler. Remember, we''re making a calendar; this means
    that we''re going to need a lot of information about each month that we display:
    the name of the month, the number of days, and the day of the week that the month
    starts on, just to name a few things. So, we''re going to create a `Month` model
    class, and use this to keep track of all of this data. The following is the code
    for the `Month` model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I want to make it clear that we don't need to use a `Backbone` model class here.
    A simple JavaScript constructor function, with a few methods on the prototype,
    would be sufficient. However, since we're working with Backbone, we'll create
    a model class so we can see how to use a model that has a disposable data wrapper
    of sorts.
  prefs: []
  type: TYPE_NORMAL
- en: We've included the `defaults` property, not so much because we expect to need
    `defaults`, but as a simple way of documenting what properties we expect the `options`
    object we pass to the `Month` constructor to have. When we create a `Month` instance,
    we need to give it a year and a month, both as numbers. As you might expect, we're
    using the Moment library heavily in this application, because we're going to do
    a lot of the date math. Remember that the Moment library uses zero-indexed values
    for month numbers, so, January is 0, and December is 11.
  prefs: []
  type: TYPE_NORMAL
- en: In the `initialize` method, we start by calling the `moment` method, which you
    can see at the bottom of the class. This method simply returns a new `moment`
    object. The `moment` constructor can take an array with time values (year, month,
    date, hour, and so on). We only need `year` and `month`, so we're passing it only
    these two values. The rest of the values will default to their earliest possible
    values, so this `moment` object will be for midnight on the first day of our month.
    That's perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back in the `initialize` method, we call the `moment` method. Then, we
    set a few other properties that our `Month` object will need: the string name
    of the month, the number of days in the month, and the number of weeks in the
    month. The last property will be important when we render the month table; we''ll
    need to know how many table rows we need. We can find the number of weeks for
    the month by adding the number of days in the month to the day value from the
    `moment` object. This will be a numerical value for the day of the week that the
    first day of the month falls on. Handily, this is also the number of days from
    the previous month that we need to pad the beginning of the month with. We then
    divide this number by 7, and round up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these classes in place, we''re ready to start the router, so open the
    `router.js` file from the `public` directory. As in the `models.js` file, we''ll
    start with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll write the router class, which will initially render the page for
    the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As in our previous applications, our router constructor expects to receive a
    main element that our views will render in, and a collection object that we call
    `calendar`. We make these local in our `initialize` method. We also make a bound
    copy of the router's `navigate` method so that our views can change routes. This
    time, we do this by making it a class property of the `Router` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our routes. Things are a bit different this time, in that both
    routes will call the same method: `month`. The second one makes sense; any route
    of the pattern `/year/month` will show that month. However, we want the root route
    to show the current month; that''s why it calls the same method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `month` method takes the year and month parameters and passes them
    to a `clean` function to make sure they are usable. This will return an array
    with year and month values that we can use. What about the root route, which doesn''t
    have those parameters? The clean method will take care of that. After that, we
    can put a new `App.Views.Month` view into our main element. This view will take
    two properties: the `calendar` collection and a `Month` model. We create a `Month`
    instance, passing it the year and month from the cleaned array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `clean` method is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes three parameters: `year`, `month`, and `day`. These will
    be strings, because that''s how they come from the route. Each one will be parsed
    as an integer, but it is possible that one of these won''t parse to a number.
    If that''s the case, we''ll get the current year, month, or day from a `moment`
    object. Then, we''ll return an array with the numbers we need. These built-in
    defaults mean that the root route will get the current year and month. It also
    has an interesting side effect; the route `/what/4` will show April of the current
    year.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with the router in place, we can go over to the `index.ejs` file in the
    `views` folder. You''ll want to start by making sure all our scripts are in place.
    Don''t forget to get the Moment library, as we did in the previous chapter, and
    add `models.js`, `views.js`, and `router.js`. Finally, let''s instantiate the
    router, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when we create our Calendar, we put in an empty array. Normally,
    this is where we would get models from the server, but we''re going to do it a
    bit differently this time. Let''s hardcode some sample data right here. This way,
    we can focus on the frontend code for now. We''ll get the backend stuff soon enough.
    So, inside that array, add some models, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You'll probably want to change the dates to be current when you're reading this.
    This is because the calendar will default to showing the current month, so you'll
    be able to see these events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more thing to do in the `index.ejs` file; we can''t really get
    a nice-looking calendar without doing a bit of styling, so we''re going to do
    just that—add the following line in the head of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We'll add this style sheet file later. Now, we're ready to create our views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the month view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The month view will display the month as a table, just like a wall calendar.
    Events will show within the cell of the appropriate day. This will require several
    nested views, so let''s begin with the `Month` view. Here''s how we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll give this class a `JST.month` template and a `render` method. Before we
    discuss the `render` method, let's take a look at the template file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how we're not naming our views `MonthView` and `WeekRowView`, as we had
    before. Instead, they're just `Month` and `WeekRow`. We're doing this because
    we'll have to refer to them as `App.Views.Month` or `App.Views.MonthTable` anyway,
    so there's no need to say `View` twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can tell, the following code will go in the `month.html` file, in the
    `template` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's a heading at the top, which will have the name and year for the month
    we are displaying. There will also be buttons to move to the next and previous
    months. Underneath that, there will be a `<table>` element, which will display
    the month. Don't forget to run `grunt` to compile the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look back at the `render` method. We start by rendering our template,
    passing to it the data from the `Month` model. Then, we get the `weeks` property
    of the `month` model; this tells us how many rows our table needs (one row per
    week). Finally, we loop that many times, appending a new `WeekRow` view to the
    `<tbody>` element each time. A `WeekRow` instance takes three properties: the
    number of the week (0 for the first, 1 for the second, and so on), the `month`
    model, and the `calendar` collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step for this view is to make our next month and previous month buttons
    work. Add the following events property to the `Month` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These event listeners need the `prev` and `next` methods to work, so let''s
    add those methods to this class too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the `<span>` elements are clicked on, we'll call the `next` or `prev` methods,
    respectively. Both methods get the next or previous month by adding or subtracting
    one month to the `moment` instance of the `month` model. Then, we format it as
    necessary and trigger the route change.
  prefs: []
  type: TYPE_NORMAL
- en: Building the week row
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `WeekRow` view, which we''re about to create, is more complex than what
    we''ve done so far. Before we look at the code, think for a minute about a week
    row in the table. There are three cases. The first week of a month will probably
    need a few blank cells before the first day, the middle weeks will have seven
    days, and the last week will have only the days that are left. This will require
    a little extra code in the `render` method. Here''s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The element of each `WeekRow` view is `<tr>`. In the `initialize` method, we
    get the `week` option; as you know, the `model` and `collection` properties come
    automatically. In the `render` method, we start by creating a `month` variable,
    just as a shortcut to this model. Next, we look for our first special case: the
    first week. If we''re creating the row for the first week, we first need to find
    what day of the week the month starts on. We can do this with `month.moment().day()`.
    The `day` method returns the zero-based index of the day of the week. This is
    exactly what we need, because if the month starts on a Sunday, we''ll get a 0,
    which is the number of blank cells we''ll need, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the `firstDay` variable is the number of blank cells we need. We then loop,
    appending as many empty `<td>` elements as we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add the right number of `DayCell` views to the `WeekRow`
    view. This sounds simple; but it''s actually a little tricky, for two reasons.
    First, because the first week probably won''t have seven days, we''ll have to
    figure out how many it should have. The second reason is that we''ll need to do
    a bit of math to get the date number for that cell. To make the view code simpler
    here, we will create a method in our `App.Models.Month` class. The `weekDates`
    method will take a week number and return an array with the dates for that week.
    In the `models.js` file in the `Month` class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a few variables; the number of days in a week, an array
    of dates to return at the end, and the day of the week that this month starts
    on. Then, if we're working on the first week here, we subtract `start` from `day`,
    because the first week doesn't have seven days in it. Then, we set `start` to
    `0`, for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we do a bit of math to get `date`, the first date for this week. We multiply
    the week number by 7, and then add 1, so it isn't zero-indexed. Finally, we subtract
    `start` to correct for a week that doesn't start on Sunday. Lastly, we create
    the `end` variable, which we'll use to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we loop from `date` to `end` and push the incrementing `date` into the
    `dates` array. It's important that we compare `date` to the number of days this
    month should have and not push it into the array if `date` is greater than this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return the `dates` array.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look back at the `WeekRow` view's `render` method, things should
    make more sense. We get the array of dates for that week and loop over it with
    the native `forEach` method. For each `date` variable, we create an actual `moment`
    object. We get the month's `moment` object and mutate it by calling the `date`
    method, which sets the date (day of the month) on the object. We then pass that
    `date` variable and part of the calendar collection to a new `DayCell` view, which
    we render and append to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that I said "part of the calendar collection"; we''re calling the `onDate`
    method, which returns a new `Calendar` collection instance with only the events
    on the date we pass to the method. This `onDate` method goes in the `models.js`
    file in the `Calendar` collection. However, before we get there, we need to create
    another method; this is a method of the `Event` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Event` class's `start` method returns the new `moment` instance for the
    start time of the event. As you can see, we get this by concatenating the date
    and start time of the event, and then passing the resulting string to the `moment`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use this method in the `onDate` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This calls the collection's `filter` method, and it only returns models whose
    dates are the same as the one passed into the `onDate` method. Then, the array
    that `filter` returns is passed to a new `Calendar` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't need the start time of the event for this purpose, just the
    date on which the event occurs on is enough. However, we'll be using the `start`
    method in other places.
  prefs: []
  type: TYPE_NORMAL
- en: Building the day cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Things are coming together nicely! We''re now ready for that `DayCell` view
    class that we''re using within our `WeekRow` views. Let''s start with the template
    in the `dayCell.html` file, in the `templates` folder. The following is the code
    for this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We're doing something new in this template. We've got a bit of logic. Previously,
    we only used the double curly braces to delimit values to interpolate. However,
    we can use the `<%` and `%>` delimiters to run any JavaScript file we want. Of
    course, it isn't smart to do this for a lot of code, but we're just using it to
    loop over an array. Since every cell represents a day on the calendar, each could
    have several events. We'll pass this template an array of the titles for those
    events. Then, inside the template, we will loop over the titles and add a list
    item for each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the view class? It is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every instance will be a `<td>` element. When rendering, we'll pass the date
    number, which we get from the moment instance we passed in as the model. We'll
    also use the collection's `pluck` method to get a single property from every instance
    in the collection; here, we're plucking the `title` property from each `Event`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice the `events` object. We're listening for a click on the root element.
    When that happens, we'll use `App.Router.navigate` to get to the individual day
    view. We get the route by formatting the `moment` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Believe it or not, we now have enough in place to actually see something in
    the browser. Compile your templates, start up your server, and load up `http://localhost:3000/`
    in the browser. You should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the day cells](img/6997OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's all right, but not that pretty. We can fix that, however. Remember the
    link to the `style.css` file that we put in the `index.ejs` file? Create that
    file in the `public` directory now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set the font and margin for the whole page. Then, we move on to view-specific
    styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is for the `Month` view's header. It will shrink the next and previous
    buttons just a bit, and center the header on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give our table a border, we''ll add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These are for any table; so this styling will be used on the individual day
    page, where we will have another table. However, we need to do a few things specifically
    for the month table, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You'll recall that we added the `month` class to our month's `<table>` element.
    We're taking advantage of that here. If you aren't familiar with the `table-layout`
    attribute, it basically makes sure that all of our columns are of the same width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to style the individual cells. This is how that''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have to position the `<td>` elements relatively so that we can position the
    `<span>` elements with the `date` class absolutely inside them, for effect. This
    is an old trick that will let us position the `<span>` elements absolutely in
    their parent (a `<td>` element), instead of in the whole page. The rest of this
    is just for looks.
  prefs: []
  type: TYPE_NORMAL
- en: The user will click on these `<td>` elements to take them to the individual
    day pages, so let's give the user a little feedback when they hover over a cell,
    shall we?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last order of business is the unordered list of event titles that each
    cell will have. Here''s the styling for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `<ul>` element has `overflow: scroll`. This way, if a single
    day has many events, it won''t make extra table rows at all; it will just make
    the rows scroll.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this styling in place, you can refresh the page and see what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the day cells](img/6997OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Much better, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Creating the individual day screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, when we click on a cell in our table, our route will change, but
    nothing will change on the screen. This isn't because we aren't triggering a change
    with our route-swap; we are. We just haven't created that method in our router
    yet. So, that's our next stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `router.js` file, add the following line to the `Router` class''s `routes`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need the `day` method that we''re calling there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method renders the `App.Views.Day` view, the top-level view for the individual
    pages. It takes a Moment object for the date we're displaying and the collection
    of events. We get a `moment` object for the date by passing the clean-up properties
    to the `moment` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might expect us to limit this collection to only events for the specific
    date the user is looking at with our `onDate` method. However, we're passing in
    the whole collection, because this is the `Calendar` instance to which we want
    to add new event instances. This is because our month view uses the `this.calendar`
    collection, and we want to make sure any event we add in a day view will show
    up in the month view immediately, with no page refresh required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App.Views.Day` view is a wrapper view. It holds three main views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DayTable`: This provides the hour-by-hour breakdown of the day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Details`: This provides a closer look at whichever event the user is currently
    hovering over'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateEvent`: This provides a form used to create a new event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use CSS to split the screen in two vertically. On the left, we'll have
    the `DayTable` view; on the right, we'll have the `Details` view and the `CreateEvent`
    view. The job of the `Day` view class is to put these three views in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the template, by adding the following code in the `day.html`
    file, in the `templates` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We'll show the date at the top of the page, with a link to go back to the month
    view. Then, we have a `<div>` element with the `splitView` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We interrupt this code to give you the following CSS code for that `splitView`
    class. Put this code in the `style.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start the `Day` view class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's more, but we'll start with this. We set the template. In the `initialize`
    method, we get the `date` property. Then, we wire up an event. When the back button
    is clicked on, we'll call the `backToMonth` method, which will change the route
    back to the month screen in the same way we switched to the day screen.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the `render` method, we put together part of the solution. We get
    the `<div class='splitView'>` element and append a new `DayTable` view instance.
    This view takes the date for this page and the collection of events.
  prefs: []
  type: TYPE_NORMAL
- en: This `DayTable` view is probably the most unique view that we'll have created
    up to this point in the book. As you expect, it will be an HTML table, with each
    row representing an hour of the day. The left column will be the time, and the
    right column will show the title of the event, if one is occurring during that
    hour. The tricky part is that most events will probably span more than one hour,
    so we'll have to figure out where to start and stop events.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, how about the template for this view? Store the following code in the
    `dayTable.html` file in the `templates` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As with our other table-based views, the template is the core of a table. You
    can see the two columns: time and events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take this view class in parts. The `DayTable` view''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The element for this view will be a table with the `day` class. We're listening
    for two events on this view; any table row that has an event will have the `highlight`
    class, and every table cell in the second column will have the `event` class.
    When the user moves over or out of one of the cells with an event title in it,
    we'll call the `hover` method to highlight that event.
  prefs: []
  type: TYPE_NORMAL
- en: In the `initialize` method, we'll get the `date` option, and then listen to
    our collection for models being added or destroyed. It's important we know when
    this happens, so we can add or remove them from the table. We'll write the `addEvent`
    and `destroyEvent` methods to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we're creating an `hours` object, which we'll use to keep track of
    the `Hour` views, each of which will be a row in our table. We used this technique
    in the previous chapter, so we could easily sort the rows in our table. This time,
    we're doing it because when we want to add or remove an event from the day, we
    don't actually want to add or remove the `Hour` view; we just want to add or remove
    the event title from that view. You'll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these pieces in place, we can move on to the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This should make a lot of sense. We render our template first. Then, we loop
    24 times; each time, we create an `App.Views.Hour` view instance, store it in
    the `this.hours` property for later use, and then append it to the `<tbody>` element.
    We can get the time text by creating a `moment` object with our incrementing variable;
    since just `i` isn't an understood date format, we need to pass `"H"` as a second
    parameter, so it knows that this is just the hour. Then, we format it as a nice
    time string. We use this time string as the property name when storing the view
    instance in `this.hours`. At this point (if we had an `Hour` view class), we would
    have a complete table, with a row for each hour of the day. However, all rows
    would be empty; we haven't rendered any events yet. That's why we next filter
    `collection` for this day's events, and loop over them, calling the `addEvent`
    method for each one.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part, as I mentioned earlier, is that one `Event` model instance
    will probably need to span several `Hour` view instances. To write the `addEvent`
    method, we're first going to add an `hours` method to the `Event` model class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `App.Models.Event` class in the `models.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating the currently empty `hours` array, which we''ll eventually
    return. Then, we get the model''s `start` and `end` time. We''ve already created
    the `start` method, but we need to create the `end` method. It''s a little more
    complex than the `start` method. Add the following code to the same class that
    we''re working on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As in the `start` method, we create the `moment` object by concatenating `date`
    and `endTime`. However, there's one special case; if the event ends at midnight,
    it is technically ending on the next day. However, our `moment` object will be
    pointing to midnight of the event date, which is the first hour of the day. So,
    if the end time is midnight, we'll add one day to the `moment` object. Then, we
    return.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to the `hours` method. After getting the `start` and `end` times,
    we can loop when the `start` time is before the `end` time. We'll push a time
    string into the `hours` array; notice that we're formatting it as we did in the
    table. Then, we add an hour to the `start` object. Eventually, `start` will be
    the same as `end`, and the loop will stop. Then, we'll return that `hours` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, if we have an event that goes on from 1:00 P.M. to 4:00 P.M.,
    we''ll get the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You may think that we want 4:00 P.M. in there as well, but we don't. This is
    because each `Hour` view instance represents a full hour; so, the hour with the
    label `1:00 PM` refers to the hour from 1:00 P.M. to 2:00 P.M.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method in place, we can go back to `App.Views.DayTable` and write
    the `addEvent` method. Remember that we''re calling this method for each event
    that we need to display in the table. The following is the code for the `addEvent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `addEvent` and `destroyEvent` methods are very similar, so we're looking
    at them together. In both cases, we get the array of hours for the given event,
    and then loop over it with the native array's `forEach` method. For each hour,
    we get the view from `this.hours`. In the `addEvent` method, we call the view's
    `displayEvent` method, passing the event along to that method. In the `destroyEvent`
    method, we just call the view's `removeEvent` method; there is no need to pass
    the event along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the `Hour` view class, let''s write the last method of this
    class: `hover`. This method is called whenever we move the mouse over or out of
    one of the event titles in our table. Here''s the code for the `hover` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since this method is triggered by a DOM event, we'll get a DOM event object
    as our parameter (actually, since we're using jQuery, it will be a jQuery-wrapped
    DOM event object). The first order of business in this method is to figure out
    what `Event` model instance the row we're hovering over is a part of. We can do
    that by getting the ID of the `Event` instance. The `currentTarget` property of
    that DOM event object will be the element that caused the event to be triggered;
    later, when we render it, we'll give it the `data-id` property that we get here.
    Since we're listening for mouse events on the `<td class='event'>` element, that's
    what the `currentTarget` property will be.
  prefs: []
  type: TYPE_NORMAL
- en: Once we know what the ID is, we can call the collection's `get` method to find
    the model with that ID. Once we get that event model, we can get the hours for
    that event with `hours`. We then loop over those hours to find the `Hour` view
    instances that are displaying this event, and call their `hover` methods. Finally,
    we'll trigger a `hover` event on our collection, passing the event model as a
    parameter. This is something new; so far, we've only listened for built-in events
    (such as `add` and `destroy`) on our models and collections. However, we can also
    use the `trigger` method to create our own events. We can call our events whatever
    we want; we're calling this one `hover`. Elsewhere, we will listen for this event
    and perform an action when it happens.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that we should be listening for these mouse events in the `Hour`
    view, since that's the view that will be affected. However, that won't work in
    this case, because we need to change multiple `Hour` views when a single one is
    hovered over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re finally ready to create the `Hour` view. Its template is very simple.
    Put the following lines in the `hour.html` file of the `templates` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The template only expects the time; we'll fill in the event name (if one is
    required) from the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `views.js` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we know, this view will be a `<tr>` element. In the `initialize` method,
    we get the `time` property. The `render` method is extra simple in this case,
    because a lot of the action takes place in the `displayEvent` and `removeEvent`
    methods. As we saw, the `addEvent` method in the `App.Views.DayTable` view class
    will call this `displayEvent` method, passing it the `event` model that occurs
    at that hour. In the `displayEvent` method, we'll add the `highlight` class to
    that hour, add the `data-id` attribute, and put the title text into the `<td>`
    element with the `event` class. When removing an event, we do the opposite; remove
    the `highlight` class and the `data-id` attribute, and set the text to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there''s the `hover` method. This simply toggles the `hover` class
    on the `<tr>` element. Now, before checking this out in the browser, let''s add
    a little bit of styling, add this to the `style.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s nothing much; it just adds some color and spacing to the table. With
    all this in place, we can now load up our day view. You should see something like
    what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the individual day screen](img/6997OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not a bad look, eh? If you hover over either of the colored cells, you should
    see both of them switch to the yellow background.
  prefs: []
  type: TYPE_NORMAL
- en: That's the left half of our split view. Now, it's time to create the right-hand
    side. You'll recall that the right-hand side will have the `details` view and
    the creation form. Let's begin with the `details` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we''ll start with the template: `details.html` in the `templates`
    folder. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We're again using a bit of logic in the template. If the `start` value is not
    just an empty string, we'll render the two paragraphs. We'll show the `start`
    and `end` times for the event, as well as the duration. Finally, we'll have a
    **Delete Event** button, which will allow us to delete events.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we're using this bit of logic is because when the page is first loaded,
    the user won't be hovering over any event. In that case, we'll show a default
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `views.js` file, we''ll create the following view class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We'll do something a bit different in the `initialize` method this time. First,
    we'll create some default filler data, called `this.data`, for the view, which
    will be displayed before the user first hovers over an hour. Then, we'll call
    the `render` method right away in the `initialize` method. This isn't a pattern
    you see very often, but there's really no reason not to do it. In the `render`
    method, we take that data and render the template. The important method in this
    class is the `changeModel` method. It takes a model as a property and recreates
    the `data` property from that. We put the `start` and `end` times in variables,
    so we don't have to call those methods twice. Then, we re-render the view, by
    calling the `render` method again.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we assign `this.model` in the `changeModel` method. This
    is because we'll need it in the `delete` method. We need to get a reference to
    the currently displayed model, so we can destroy it when the delete button is
    clicked on (you can see that we're connecting to the `delete` method in the `events`
    property). Of course, for the destruction of the model to work, we'll need to
    write a server method; we'll get to that.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we want to render this view. To do this, go back to the `render`
    method in the `App.Views.Day` view class. So far, this method only creates a `DayTable`
    view (the left-hand side of the screen). Add the following code to that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create a `<div>` element on the right-hand side of the split view.
    Then, we create a `Details` view instance and append it to that `div` element.
    Notice that, since we call the `render` method internally, we don''t have to call
    it here. Also, we keep a reference to the `Details` view instance as `this.details`.
    This is because we need it in the `showDetails` method, which we''ll add as a
    new method in the `Day` view class. The `showDetails` method''s code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This just calls the `changeModel` method on the `Details` view. But where does
    this method get called? Remember that `hover` event that we triggered ourselves,
    when the user moves over a row? Go back up the `initialize` method of the `Day`
    view class, because we''re going to listen for that event there with this single
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! With all this in place, you can test it out by hovering over an event;
    the `details` view should look something like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the individual day screen](img/6997OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We only have one view left: the `CreateEvent` view. We''ll start with the `createEvent.html`
    template. Here''s its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's the insides of a form; the view element will be the `<form>`
    element itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the beginning of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You understand all this by now; even the `render` function is simple. In the
    `initialize` function, we're taking a `date` option, because we'll need to know
    on what date we're creating an event on. Where the fun starts is in the `createEvent`
    method. You can see that we're listening for a click on the button in our form
    and calling the `createEvent` method when it happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It's a biggie, I know. We start by preventing the default form submission. Then,
    we use the data from the form and `date` from the constructor to create a new
    model instance. When creating a model like this, it isn't saved to the server
    right away. We either have to call the `save` method on the model or pass it to
    a collection's `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re probably wondering why we''re making the `collection` object an attribute
    of this model instance. This is actually a bit of a hack. The first part of the
    explanation comes from the second part of the method. You can see that we''re
    calling the model''s `isValid` method. Backbone has the ability to do validation
    on our models. If our attributes don''t conform to given patterns, we can prevent
    them from saving. We''re doing it very explicitly here, by calling this method.
    If the model is valid, we''ll save the model to the server by passing it to the
    collection''s `create` method (we pass `{wait: true}` because our `DayTable` view
    is listening for additions to the collection, so it can add them to the table;
    this way, it won''t be added until we''re sure it has been saved). Then, we clear
    out the form elements, and remove any error from the error paragraph. That error
    would occur if the model didn''t validate. Instead of saving, we would have displayed
    the model''s `validationError` property in that paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we're calling the model's `isValid` method, but we haven't created
    any validation rules yet. Backbone's validation feature is barebones. In our `Event`
    model class, we'll create a method named `validate`. Whenever we try to save a
    model, this method will be called. As a parameter, the `validate` method will
    receive an object containing the attributes of the model. Inside the method, we
    write whatever code we want. If everything checks out, we don't return anything.
    However, if there's a problem, we can return an error message (it can be a simple
    string or something more complex). The error message will then be assigned to
    `model.validationError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s write the validation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the second part of the explanation for why we included the `collection`
    object in our model's attributes. What we need to validate is the `start` and
    `end` times. If the event we're trying to create overlaps with other events that
    are already in the calendar, we can't allow the new event to be created. However,
    from within the model's `validate` method, there's no way to access the collection.
    So, we pass it as an attribute of the model we're validating, using the `onDate`
    method to limit it to events on this date. Sure, it's a hack; but it works.
  prefs: []
  type: TYPE_NORMAL
- en: We start by making sure that our attributes include a `collection` attribute.
    If we have it, the first job is to figure out what hours of the day are already
    taken. We can find the hours for each event individually by calling the `hours`
    method we created. We can use the collection's `invoke` method to call that method
    on all its models; it will return an array of results. Since each result is an
    array, we have an array of arrays. Then, we can use Underscore's `flatten` method
    to turn that into a one-dimensional array. The result is an array with all the
    hours that are already taken.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we do a bit of functional-style programming. We start by calling `this.hours`
    to get the array of hours during which this event occurs. Then, we map that to
    the value of `takenHours.indexOf(x)`. This will loop over the hours of this event
    and get their index in the `takenHours` array. The important bit here is that
    if an hour isn't in `takenHours`, it will return `-1`. Next, we use the array's
    `filter` to filter it, only keeping the values that are greater than `-1`. Finally,
    we get the `length` value of the resulting array. Following this logic, the `hours`
    variable will be the number of values that overlap between the `takenHours` and
    `this.hours` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll remove the `collection` property with the `unset` method because
    we no longer need it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the overlapping hours count is greater than 0, we'll return an error;
    you already have an event at that time. With this method in place, you can look
    back at the `createEvent` method and understand exactly what we're doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step for the `CreateEvent` class is to put it on the screen. Go back
    to the `render` method of the `App.Views.Day` class and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re putting it in the `div` element that we created to the right-hand side
    of the split view. As required, we give it the `date` string and the `collection`
    object, and then render it. Now, our page should look like what is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the individual day screen](img/6997OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing the server code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server code is very simple for this application. First, we need to render
    the `index.ejs` template with the event models in the database. So, make sure
    our GET request catch-all looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `index.ejs` file of the `views` folder, in the router creation
    code, remove the dummy records that we put in and replace it with the template
    data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `server.js` file, we need the route that the POST request is sent
    to when we''re creating a new `Event` model. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We get the request body, and then create our record from its properties. Once
    we have saved the record, we'll send it back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need the route that is called when we destroy a model. This
    is a DELETE request, and this is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the ID of the record, find the related row, and return an empty response.
    That''s it for the server. With this code in place, you''re ready to give it a
    try. Go to an individual day page and add a few events. You should get something
    like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the server code](img/6997OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see all the components in play here; the table of hours, the hover effect,
    and the details view. You can even see the error message when we try to create
    an event that overlaps with another.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one last step; a nicety, really. If you go back to the month view,
    you will notice that the events in each day cell don''t appear in order of time.
    Instead, they appear in the order we created them. It would be nice if they appeared
    in order of occurrence, and this is very simple to do. In the `App.Models.Calendar`
    class (in the `models.js` file), we can write a `comparator` method to keep things
    in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can simply return the result of the `moment` object's `isAfter` method to
    see which should come first; Backbone takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've done a lot of new and interesting things in this chapter. The most difficult
    part was getting the hover effect. It required us to find all the views that represented
    a single model instance. Most of the time, in a Backbone application, you'll have
    a single view representing a model instance at a time. However, as you've seen
    here, while this is the norm, it certainly isn't the only way possible.
  prefs: []
  type: TYPE_NORMAL
- en: The other neat use of Backbone was the `Month` class that we created. We're
    really just using it as a handy wrapper; there's no reason we couldn't have written
    a simple function that returned an object literal. However, the way we've done
    it shows off the flexibility of Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: The last, but arguably most important, idea from this chapter is the idea of
    moving appropriate logic into the model class, instead of putting it in the view
    class. Good examples of this are the `App.Models.Calendar` class's `onDate` method
    or the `App.Models.Event` class's `hours` method. This is one of the big ideas
    of the Model-View-Controller pattern. Of course, Backbone isn't strictly MVC,
    but a lot of the principles still apply. As much as you can, make your model classes
    fat and your views and routers thin. This doesn't mean putting view or routing
    logic in the model. It means that any logic that isn't specifically about views
    or routing should probably be in a model class. For more on this topic, there's
    a lot of great MVC material online; you could start with [http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488](http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488).
    In the next chapter, we'll take things to a whole new level when we create a real-time,
    two-way chat application.
  prefs: []
  type: TYPE_NORMAL
