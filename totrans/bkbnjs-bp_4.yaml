- en: Chapter 4. Building a Calendar
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：构建日历
- en: We're going to build a calendar in this chapter. You might think that's what
    we built in the last chapter, but this one is going to be different; it will be
    like a very boiled-down version of Google Calendar. We'll be able to view a month
    or a day at a time, and plan events that span a certain number of hours.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建一个日历。你可能会认为这是我们上一章构建的，但这个将有所不同；它将类似于一个非常简化的Google Calendar。我们将能够一次查看一个月或一天，并计划跨越一定小时数的事件。
- en: 'In this chapter, we will discuss the following ideas:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下想法：
- en: Better application component organization, with only one global variable for
    the whole application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的应用程序组件组织，整个应用程序只有一个全局变量
- en: Putting model functionality inside model methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模型功能放在模型方法中
- en: Using disposable models to encapsulate important information that we don't need
    to store on the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可丢弃的模型来封装我们不需要在服务器上存储的重要信息
- en: Displaying a single model instance in multiple views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个视图中显示单个模型实例
- en: You can begin with the project template, as we have done before. However, we'll
    be using precompiled templates as we did in the previous chapter, and we'll also
    be separating our code into `models.js`, `views.js`, and `router.js`. You may
    choose to copy the previous project and clear out the custom code instead, so
    that you'll have the `Gruntfile.js` file that we created last time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从项目模板开始，就像我们之前做的那样。然而，我们将使用与上一章相同的预编译模板，并且我们还将把我们的代码分成`models.js`、`views.js`和`router.js`。你也可以选择复制上一个项目并清除自定义代码，这样你将会有我们上次创建的`Gruntfile.js`文件。
- en: Planning our application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的应用程序
- en: Once again, we'll begin by planning our application. Our primary model will
    be the `Event` model. It has the same name as the model we created in the last
    chapter, but it's a bit different. This one will have a title, date, and start
    time and end time. We'll allow multiple events in one day, but events cannot overlap
    (because we can't be at two events at one time). Then, we'll also create a `Calendar`
    collection class to hold our events.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将从规划我们的应用程序开始。我们的主要模型将是`Event`模型。它与我们在上一章中创建的模型同名，但略有不同。这个模型将包含标题、日期、开始时间和结束时间。我们将允许一天内有多个事件，但事件不能重叠（因为我们不能同时参加两个事件）。然后，我们还将创建一个`Calendar`集合类来存储我们的事件。
- en: Our application will have two screens. The first will be a month view, in a
    standard, tabular, wall-calendar style. Then, a click on one of the days in that
    view will switch us to a day view, which will give the hour-by-hour breakdown
    of events for that day. This will also be the screen from which we can create
    new events.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有两个屏幕。第一个将是一个月视图，以标准、表格、墙式日历风格。然后，点击该视图中的某一天将切换到日视图，这将显示该天的每小时事件分解。这也将是我们创建新事件的屏幕。
- en: Creating the model and collection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型和集合
- en: 'Let''s start with the `Event` model class, which will go in the `models.js`
    file of the `public` folder. Separating our code into multiple files is a good
    first step for organization, but we can go one step further. Previously, each
    of our classes has been referenced by its own global variable. You probably know
    that this isn''t a really wise technique. If we''re using other libraries, frameworks,
    or plugins, we don''t want two components to use the same variable name and mess
    up the works. In this application, we''re going to put all our classes safely
    inside a single global object. So, we start the `models.js` file with the following
    code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Event`模型类开始，它将放在`public`文件夹的`models.js`文件中。将我们的代码分成多个文件是组织的好第一步，但我们还可以更进一步。之前，我们的每个类都通过它自己的全局变量进行引用。你可能知道这不是一个特别明智的技术。如果我们使用其他库、框架或插件，我们不希望两个组件使用相同的变量名并搞乱工作。在这个应用程序中，我们将把所有的类安全地放在一个单独的全局对象中。因此，我们以以下代码开始`models.js`文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line may seem a bit tricky; why not just use `var App = {};`? Well,
    the technique I've used here allows us to not worry about the order our files
    are loaded in the browser. This line first checks to see whether `window.App`
    exists. If it does, it assigns it to itself (basically, it does nothing). If it
    doesn't exist, we can be sure that this is the first of our files to load, and
    so we create it as a blank object. This technique will work as long as we begin
    all our custom JavaScript files in this application in that way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行可能看起来有点棘手；为什么不直接使用 `var App = {};` 呢？嗯，我在这里使用的技巧允许我们不必担心文件在浏览器中加载的顺序。这一行首先检查
    `window.App` 是否存在。如果存在，它将其分配给自己（基本上，它什么都不做）。如果不存在，我们可以确信这是我们的第一个加载的文件，因此我们将其创建为一个空对象。只要我们以这种方式开始所有自定义JavaScript文件，这个技巧就会起作用。
- en: The next line creates a `Models` property. Our model and collection classes
    will be properties of this object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行创建了一个 `Models` 属性。我们的模型和集合类将是这个对象上的属性。
- en: 'Now, we''re ready to create our `Event` model class, like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建我们的 `Event` 模型类，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We're going to start with a basic model, but we'll be coming back to add a lot
    of functionality to it. As I mentioned earlier, putting model functionality inside
    model methods is one of the most important action points discussed in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个基本模型开始，但我们会回来添加很多功能。如我之前提到的，将模型功能放在模型方法中是本章讨论的最重要行动点之一。
- en: 'We also have our collection class, which is this code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个集合类，其代码如下：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's nothing new or unique here. Notice that we do need to refer to our model
    class by its full name as a property, because it's not a global variable anymore.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新或独特的地方。请注意，我们确实需要通过其全名作为属性来引用我们的模型类，因为它不再是全局变量了。
- en: 'There''s actually one more model that we need to create; however, this model
    isn''t one that we''re going to store instances of on the server, or allow our
    users to know about; it''s just a class that we''re going to use internally, to
    make some of our view code simpler. Remember, we''re making a calendar; this means
    that we''re going to need a lot of information about each month that we display:
    the name of the month, the number of days, and the day of the week that the month
    starts on, just to name a few things. So, we''re going to create a `Month` model
    class, and use this to keep track of all of this data. The following is the code
    for the `Month` model class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们还需要创建一个额外的模型；然而，这个模型不是我们要在服务器上存储实例或允许我们的用户了解的模型；它只是一个我们将内部使用的类，以使我们的视图代码更简单。记住，我们正在制作一个日历；这意味着我们需要关于我们显示的每个月的大量信息：月份的名称、天数以及该月开始的星期几，仅举几例。因此，我们将创建一个
    `Month` 模型类，并使用它来跟踪所有这些数据。以下是为 `Month` 模型类编写的代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I want to make it clear that we don't need to use a `Backbone` model class here.
    A simple JavaScript constructor function, with a few methods on the prototype,
    would be sufficient. However, since we're working with Backbone, we'll create
    a model class so we can see how to use a model that has a disposable data wrapper
    of sorts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我想明确指出，我们在这里不需要使用 `Backbone` 模型类。一个简单的JavaScript构造函数，在原型上添加一些方法，就足够了。然而，由于我们正在使用
    Backbone，我们将创建一个模型类，这样我们就可以看到如何使用具有某种可丢弃数据包装器的模型。
- en: We've included the `defaults` property, not so much because we expect to need
    `defaults`, but as a simple way of documenting what properties we expect the `options`
    object we pass to the `Month` constructor to have. When we create a `Month` instance,
    we need to give it a year and a month, both as numbers. As you might expect, we're
    using the Moment library heavily in this application, because we're going to do
    a lot of the date math. Remember that the Moment library uses zero-indexed values
    for month numbers, so, January is 0, and December is 11.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了 `defaults` 属性，并不是因为我们期望需要 `defaults`，而是一种简单的方式来记录我们期望传递给 `Month` 构造函数的
    `options` 对象应具有哪些属性。当我们创建 `Month` 实例时，我们需要给它一个年份和月份，两者都是数字。正如您可能预料的那样，我们在这个应用程序中大量使用
    Moment 库，因为我们将进行大量的日期计算。记住，Moment 库使用零索引值作为月份数字，所以，一月是 0，十二月是 11。
- en: In the `initialize` method, we start by calling the `moment` method, which you
    can see at the bottom of the class. This method simply returns a new `moment`
    object. The `moment` constructor can take an array with time values (year, month,
    date, hour, and so on). We only need `year` and `month`, so we're passing it only
    these two values. The rest of the values will default to their earliest possible
    values, so this `moment` object will be for midnight on the first day of our month.
    That's perfect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`方法中，我们首先调用`moment`方法，您可以在类的底部看到这个方法。这个方法简单地返回一个新的`moment`对象。`moment`构造函数可以接受一个包含时间值（年、月、日、小时等）的数组。我们只需要`年`和`月`，所以我们只传递这两个值。其余的值将默认为最早的可能值，因此这个`moment`对象将代表我们月份的第一天午夜。这很完美。
- en: 'So, back in the `initialize` method, we call the `moment` method. Then, we
    set a few other properties that our `Month` object will need: the string name
    of the month, the number of days in the month, and the number of weeks in the
    month. The last property will be important when we render the month table; we''ll
    need to know how many table rows we need. We can find the number of weeks for
    the month by adding the number of days in the month to the day value from the
    `moment` object. This will be a numerical value for the day of the week that the
    first day of the month falls on. Handily, this is also the number of days from
    the previous month that we need to pad the beginning of the month with. We then
    divide this number by 7, and round up.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到`initialize`方法中，我们调用`moment`方法。然后，我们设置一些其他属性，这些属性是我们`Month`对象所需要的：月份的字符串名称、月份中的天数和月份中的周数。最后一个属性在我们渲染月份表格时将非常重要；我们需要知道需要多少表格行。我们可以通过将月份中的天数加上`moment`对象中的日期值来找到月份的周数。这将是一个表示月份第一天是星期几的数值。方便的是，这也是我们需要在月份开始时填充的前一个月的天数。然后，我们将这个数字除以7，并向上取整。
- en: 'With these classes in place, we''re ready to start the router, so open the
    `router.js` file from the `public` directory. As in the `models.js` file, we''ll
    start with the following line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类设置好之后，我们就可以开始启动路由器了，所以请从`public`目录打开`router.js`文件。就像在`models.js`文件中一样，我们将从以下行开始：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we''ll write the router class, which will initially render the page for
    the user:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写路由器类，它最初将渲染用户的页面：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As in our previous applications, our router constructor expects to receive a
    main element that our views will render in, and a collection object that we call
    `calendar`. We make these local in our `initialize` method. We also make a bound
    copy of the router's `navigate` method so that our views can change routes. This
    time, we do this by making it a class property of the `Router` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的应用程序一样，我们的路由器构造函数期望接收一个主元素，我们的视图将在其中渲染，以及一个我们称之为`calendar`的集合对象。我们在`initialize`方法中将这些设置为局部变量。我们还创建了一个路由器`navigate`方法的绑定副本，以便我们的视图可以更改路由。这次，我们通过将其作为`Router`类的类属性来实现这一点。
- en: 'Next, we have our routes. Things are a bit different this time, in that both
    routes will call the same method: `month`. The second one makes sense; any route
    of the pattern `/year/month` will show that month. However, we want the root route
    to show the current month; that''s why it calls the same method.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的路由。这次的情况有些不同，因为两个路由都会调用同一个方法：`month`。第二个路由是有道理的；任何符合`/year/month`模式的路由都会显示那个月份。然而，我们希望根路由显示当前月份；这就是为什么它调用相同的方法。
- en: 'Then, the `month` method takes the year and month parameters and passes them
    to a `clean` function to make sure they are usable. This will return an array
    with year and month values that we can use. What about the root route, which doesn''t
    have those parameters? The clean method will take care of that. After that, we
    can put a new `App.Views.Month` view into our main element. This view will take
    two properties: the `calendar` collection and a `Month` model. We create a `Month`
    instance, passing it the year and month from the cleaned array.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`month`方法接受年和月参数，并将它们传递给一个`clean`函数以确保它们是可用的。这将返回一个包含年和月值的数组，我们可以使用它。那么，没有这些参数的根路由怎么办？`clean`方法将处理这个问题。之后，我们可以在主元素中放入一个新的`App.Views.Month`视图。这个视图将接受两个属性：`calendar`集合和一个`Month`模型。我们创建一个`Month`实例，传递给它从清理数组中获取的年和月。
- en: 'The `clean` method is pretty simple:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`方法相当简单：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function takes three parameters: `year`, `month`, and `day`. These will
    be strings, because that''s how they come from the route. Each one will be parsed
    as an integer, but it is possible that one of these won''t parse to a number.
    If that''s the case, we''ll get the current year, month, or day from a `moment`
    object. Then, we''ll return an array with the numbers we need. These built-in
    defaults mean that the root route will get the current year and month. It also
    has an interesting side effect; the route `/what/4` will show April of the current
    year.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受三个参数：`year`、`month` 和 `day`。它们将是字符串，因为它们就是这样从路由中来的。每个都会被解析为整数，但可能其中一个不会解析为数字。如果是这样，我们将从
    `moment` 对象中获取当前的年、月或日。然后，我们将返回一个包含所需数字的数组。这些内置默认值意味着根路由将获取当前的年月。它还有一个有趣的副作用；路由
    `/what/4` 将显示当前年份的四月。
- en: 'So, with the router in place, we can go over to the `index.ejs` file in the
    `views` folder. You''ll want to start by making sure all our scripts are in place.
    Don''t forget to get the Moment library, as we did in the previous chapter, and
    add `models.js`, `views.js`, and `router.js`. Finally, let''s instantiate the
    router, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了路由器，我们可以转到 `views` 文件夹中的 `index.ejs` 文件。你首先想要确保所有脚本都已就绪。别忘了获取 Moment 库，就像我们在上一章中做的那样，并添加
    `models.js`、`views.js` 和 `router.js`。最后，让我们实例化路由器，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that when we create our Calendar, we put in an empty array. Normally,
    this is where we would get models from the server, but we''re going to do it a
    bit differently this time. Let''s hardcode some sample data right here. This way,
    we can focus on the frontend code for now. We''ll get the backend stuff soon enough.
    So, inside that array, add some models, as shown in the following lines of code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们创建我们的日历时，我们放入了一个空数组。通常，这是我们从服务器获取模型的地方，但这次我们将有所不同。让我们在这里硬编码一些示例数据。这样，我们就可以现在专注于前端代码。我们很快就会得到后端的东西。所以，在这个数组中，添加一些模型，如下面的代码行所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You'll probably want to change the dates to be current when you're reading this.
    This is because the calendar will default to showing the current month, so you'll
    be able to see these events.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这段内容时，你可能想要更改日期为当前日期。这是因为日历默认会显示当前月份，这样你就可以看到这些事件了。
- en: 'There''s one more thing to do in the `index.ejs` file; we can''t really get
    a nice-looking calendar without doing a bit of styling, so we''re going to do
    just that—add the following line in the head of the file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.ejs` 文件中还有一件事要做；如果我们不做一些样式设计，我们真的无法得到一个好看的日历，所以我们将这样做——在文件的头部添加以下行：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll add this style sheet file later. Now, we're ready to create our views.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会添加这个样式表文件。现在，我们准备好创建我们的视图了。
- en: Creating the month view
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建月份视图
- en: 'The month view will display the month as a table, just like a wall calendar.
    Events will show within the cell of the appropriate day. This will require several
    nested views, so let''s begin with the `Month` view. Here''s how we start:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 月份视图将以表格的形式显示月份，就像墙上的日历一样。事件将在相应日期的单元格中显示。这需要几个嵌套视图，所以让我们从 `Month` 视图开始。这是我们的开始方式：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll give this class a `JST.month` template and a `render` method. Before we
    discuss the `render` method, let's take a look at the template file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个类提供一个 `JST.month` 模板和一个 `render` 方法。在我们讨论 `render` 方法之前，让我们先看看模板文件。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how we're not naming our views `MonthView` and `WeekRowView`, as we had
    before. Instead, they're just `Month` and `WeekRow`. We're doing this because
    we'll have to refer to them as `App.Views.Month` or `App.Views.MonthTable` anyway,
    so there's no need to say `View` twice.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们并没有像以前那样将视图命名为 `MonthView` 和 `WeekRowView`。相反，它们只是 `Month` 和 `WeekRow`。我们这样做是因为我们无论如何都要用
    `App.Views.Month` 或 `App.Views.MonthTable` 来引用它们，所以没有必要两次都说 `View`。
- en: 'As you can tell, the following code will go in the `month.html` file, in the
    `template` folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，以下代码将放在 `template` 文件夹中的 `month.html` 文件里：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's a heading at the top, which will have the name and year for the month
    we are displaying. There will also be buttons to move to the next and previous
    months. Underneath that, there will be a `<table>` element, which will display
    the month. Don't forget to run `grunt` to compile the template.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部有一个标题，它将显示我们正在显示的月份的名称和年份。还将有按钮可以切换到下一个月和上一个月。下面，将有一个 `<table>` 元素，用于显示月份。别忘了运行
    `grunt` 来编译模板。
- en: 'Now, look back at the `render` method. We start by rendering our template,
    passing to it the data from the `Month` model. Then, we get the `weeks` property
    of the `month` model; this tells us how many rows our table needs (one row per
    week). Finally, we loop that many times, appending a new `WeekRow` view to the
    `<tbody>` element each time. A `WeekRow` instance takes three properties: the
    number of the week (0 for the first, 1 for the second, and so on), the `month`
    model, and the `calendar` collection.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下 `render` 方法。我们首先渲染模板，传递给它来自 `Month` 模型的数据。然后，我们获取 `month` 模型的 `weeks`
    属性；这告诉我们表格需要多少行（每周一行）。最后，我们循环这么多次，每次循环都将一个新的 `WeekRow` 视图添加到 `<tbody>` 元素中。一个
    `WeekRow` 实例需要三个属性：周数（第一周为0，第二周为1，依此类推）、`month` 模型和 `calendar` 集合。
- en: 'The last step for this view is to make our next month and previous month buttons
    work. Add the following events property to the `Month` view:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种视图的最后一步是让我们的下个月和上个月按钮正常工作。将以下事件属性添加到 `Month` 视图中：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These event listeners need the `prev` and `next` methods to work, so let''s
    add those methods to this class too:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件监听器需要 `prev` 和 `next` 方法才能工作，所以让我们也把这个类中的这些方法添加上：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the `<span>` elements are clicked on, we'll call the `next` or `prev` methods,
    respectively. Both methods get the next or previous month by adding or subtracting
    one month to the `moment` instance of the `month` model. Then, we format it as
    necessary and trigger the route change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `<span>` 元素时，我们将分别调用 `next` 或 `prev` 方法。这两个方法通过向 `month` 模型的 `moment` 实例添加或减去一个月来获取下一个月或上一个月。然后，我们按需格式化它并触发路由更改。
- en: Building the week row
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建周行
- en: 'The `WeekRow` view, which we''re about to create, is more complex than what
    we''ve done so far. Before we look at the code, think for a minute about a week
    row in the table. There are three cases. The first week of a month will probably
    need a few blank cells before the first day, the middle weeks will have seven
    days, and the last week will have only the days that are left. This will require
    a little extra code in the `render` method. Here''s the class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建的 `WeekRow` 视图比我们之前所做的一切都要复杂。在我们查看代码之前，花一分钟时间思考一下表格中的周行。这里有三种情况。一个月的第一周可能需要在第一天之前有一些空白单元格，中间的周会有七天，而最后一周将只有剩余的天数。这将在
    `render` 方法中需要一点额外的代码。以下是这个类的代码：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The element of each `WeekRow` view is `<tr>`. In the `initialize` method, we
    get the `week` option; as you know, the `model` and `collection` properties come
    automatically. In the `render` method, we start by creating a `month` variable,
    just as a shortcut to this model. Next, we look for our first special case: the
    first week. If we''re creating the row for the first week, we first need to find
    what day of the week the month starts on. We can do this with `month.moment().day()`.
    The `day` method returns the zero-based index of the day of the week. This is
    exactly what we need, because if the month starts on a Sunday, we''ll get a 0,
    which is the number of blank cells we''ll need, and so on.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `WeekRow` 视图的元素是 `<tr>`。在 `initialize` 方法中，我们获取 `week` 选项；正如你所知，`model` 和
    `collection` 属性会自动获取。在 `render` 方法中，我们首先创建一个 `month` 变量，仅作为一个快捷方式来引用这个模型。接下来，我们寻找我们的第一个特殊情况：第一周。如果我们正在创建第一周的行，我们首先需要找到这个月是星期几开始。我们可以用
    `month.moment().day()` 来做这个。`day` 方法返回一周中天数的零基于索引。这正是我们需要的，因为如果这个月从星期日开始，我们会得到一个0，这就是我们需要空白单元格的数量，依此类推。
- en: So, the `firstDay` variable is the number of blank cells we need. We then loop,
    appending as many empty `<td>` elements as we need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`firstDay` 变量是我们需要的空白单元格的数量。然后我们循环，添加我们需要的那么多空 `<td>` 元素。
- en: 'The next step is to add the right number of `DayCell` views to the `WeekRow`
    view. This sounds simple; but it''s actually a little tricky, for two reasons.
    First, because the first week probably won''t have seven days, we''ll have to
    figure out how many it should have. The second reason is that we''ll need to do
    a bit of math to get the date number for that cell. To make the view code simpler
    here, we will create a method in our `App.Models.Month` class. The `weekDates`
    method will take a week number and return an array with the dates for that week.
    In the `models.js` file in the `Month` class, add the following method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为 `WeekRow` 视图添加正确数量的 `DayCell` 视图。这听起来很简单；但实际上有点棘手，有两个原因。首先，因为第一周可能不会有七天，我们得弄清楚它应该有多少天。第二个原因是我们需要做一些数学计算来得到那个单元格的日期数字。为了使视图代码更简单，我们将在
    `App.Models.Month` 类中创建一个方法。`weekDates` 方法将接受一个周数并返回一个包含该周日期的数组。在 `Month` 类的 `models.js`
    文件中，添加以下方法：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start by creating a few variables; the number of days in a week, an array
    of dates to return at the end, and the day of the week that this month starts
    on. Then, if we're working on the first week here, we subtract `start` from `day`,
    because the first week doesn't have seven days in it. Then, we set `start` to
    `0`, for later use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建几个变量；一周中的天数，一个返回的日期数组，以及这个月开始的那一周是星期几。然后，如果我们正在处理第一周，我们从`start`中减去`day`，因为第一周没有七天。然后，我们将`start`设置为`0`，以供以后使用。
- en: Next, we do a bit of math to get `date`, the first date for this week. We multiply
    the week number by 7, and then add 1, so it isn't zero-indexed. Finally, we subtract
    `start` to correct for a week that doesn't start on Sunday. Lastly, we create
    the `end` variable, which we'll use to stop the loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行一些数学运算以获取`date`，这是本周的第一个日期。我们将周数乘以7，然后加1，这样它就不是零索引了。最后，我们减去`start`以纠正不是从星期日开始的那一周。最后，我们创建一个`end`变量，我们将使用它来停止循环。
- en: Then, we loop from `date` to `end` and push the incrementing `date` into the
    `dates` array. It's important that we compare `date` to the number of days this
    month should have and not push it into the array if `date` is greater than this
    value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`date`循环到`end`，并将递增的`date`推入`dates`数组。重要的是我们将`date`与这个月应有的天数进行比较，如果`date`大于这个值，则不要将其推入数组。
- en: Finally, we return the `dates` array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`dates`数组。
- en: Now, if you look back at the `WeekRow` view's `render` method, things should
    make more sense. We get the array of dates for that week and loop over it with
    the native `forEach` method. For each `date` variable, we create an actual `moment`
    object. We get the month's `moment` object and mutate it by calling the `date`
    method, which sets the date (day of the month) on the object. We then pass that
    `date` variable and part of the calendar collection to a new `DayCell` view, which
    we render and append to the element.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你回顾一下`WeekRow`视图的`render`方法，事情应该会更有意义。我们获取那一周的日期数组，并使用原生的`forEach`方法遍历它。对于每个`date`变量，我们创建一个实际的`moment`对象。我们获取月份的`moment`对象，并通过调用`date`方法来修改它，该方法在对象上设置日期（月份中的天数）。然后，我们将那个`date`变量和日历集合的一部分传递给一个新的`DayCell`视图，我们渲染并附加到元素上。
- en: 'Notice that I said "part of the calendar collection"; we''re calling the `onDate`
    method, which returns a new `Calendar` collection instance with only the events
    on the date we pass to the method. This `onDate` method goes in the `models.js`
    file in the `Calendar` collection. However, before we get there, we need to create
    another method; this is a method of the `Event` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我说的是“日历集合的一部分”；我们正在调用`onDate`方法，该方法返回一个只包含我们传递给方法的日期的事件的新`Calendar`集合实例。这个`onDate`方法位于`Calendar`集合的`models.js`文件中。然而，在我们到达那里之前，我们需要创建另一个方法；这是`Event`类的一个方法：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Event` class's `start` method returns the new `moment` instance for the
    start time of the event. As you can see, we get this by concatenating the date
    and start time of the event, and then passing the resulting string to the `moment`
    function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类的`start`方法返回事件开始时间的新`moment`实例。正如你所见，我们通过连接事件的日期和开始时间，然后将结果字符串传递给`moment`函数来获取这个。'
- en: 'We''ll use this method in the `onDate` method, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`onDate`方法中使用这种方法，如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This calls the collection's `filter` method, and it only returns models whose
    dates are the same as the one passed into the `onDate` method. Then, the array
    that `filter` returns is passed to a new `Calendar` instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用集合的`filter`方法，并且它只返回与`onDate`方法传入的日期相同的模型。然后，`filter`返回的数组被传递给一个新的`Calendar`实例。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don't need the start time of the event for this purpose, just the
    date on which the event occurs on is enough. However, we'll be using the `start`
    method in other places.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要事件开始时间来完成这个目的，只需要事件发生的日期就足够了。然而，我们将在其他地方使用`start`方法。
- en: Building the day cells
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建日单元格
- en: 'Things are coming together nicely! We''re now ready for that `DayCell` view
    class that we''re using within our `WeekRow` views. Let''s start with the template
    in the `dayCell.html` file, in the `templates` folder. The following is the code
    for this template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事情正在顺利进行！我们现在准备好使用在`WeekRow`视图中使用的`DayCell`视图类。让我们从`templates`文件夹中的`dayCell.html`文件中的模板开始。以下是这个模板的代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We're doing something new in this template. We've got a bit of logic. Previously,
    we only used the double curly braces to delimit values to interpolate. However,
    we can use the `<%` and `%>` delimiters to run any JavaScript file we want. Of
    course, it isn't smart to do this for a lot of code, but we're just using it to
    loop over an array. Since every cell represents a day on the calendar, each could
    have several events. We'll pass this template an array of the titles for those
    events. Then, inside the template, we will loop over the titles and add a list
    item for each one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们做了一些新的尝试。我们加入了一些逻辑。之前，我们只使用双大括号来界定值以进行插值。然而，我们可以使用`<%`和`%>`界定符来运行我们想要的任何JavaScript文件。当然，对于大量代码来说这样做并不聪明，但我们只是用它来遍历一个数组。由于每个单元格代表日历上的一天，每个单元格可能有多个事件。我们将传递一个包含那些事件标题的数组给这个模板。然后，在模板内部，我们将遍历这些标题并为每个标题添加一个列表项。
- en: 'How about the view class? It is shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么视图类呢？它如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every instance will be a `<td>` element. When rendering, we'll pass the date
    number, which we get from the moment instance we passed in as the model. We'll
    also use the collection's `pluck` method to get a single property from every instance
    in the collection; here, we're plucking the `title` property from each `Event`
    instance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例都将是一个`<td>`元素。在渲染时，我们将传递日期数字，这是我们通过传递给模型作为模型的`moment`实例获得的。我们还将使用集合的`pluck`方法从集合中的每个实例获取一个属性；在这里，我们从每个`Event`实例中提取`title`属性。
- en: Also, notice the `events` object. We're listening for a click on the root element.
    When that happens, we'll use `App.Router.navigate` to get to the individual day
    view. We get the route by formatting the `moment` instance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`events`对象。我们在根元素上监听点击事件。当发生这种情况时，我们将使用`App.Router.navigate`来进入单个日视图。我们通过格式化`moment`实例来获取路由。
- en: 'Believe it or not, we now have enough in place to actually see something in
    the browser. Compile your templates, start up your server, and load up `http://localhost:3000/`
    in the browser. You should see something like the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们现在已经准备好在浏览器中看到一些东西了。编译你的模板，启动你的服务器，并在浏览器中加载`http://localhost:3000/`。你应该会看到以下截图类似的内容：
- en: '![Building the day cells](img/6997OS_04_01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![构建日单元格](img/6997OS_04_01.jpg)'
- en: It's all right, but not that pretty. We can fix that, however. Remember the
    link to the `style.css` file that we put in the `index.ejs` file? Create that
    file in the `public` directory now.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但并不那么漂亮。然而，我们可以修复这个问题。记得我们在`index.ejs`文件中放入的`style.css`文件的链接吗？现在在`public`目录中创建这个文件。
- en: 'We''ll start with the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下代码开始：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will set the font and margin for the whole page. Then, we move on to view-specific
    styling:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为整个页面设置字体和边距。然后，我们继续到视图特定的样式：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is for the `Month` view's header. It will shrink the next and previous
    buttons just a bit, and center the header on the screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Month`视图的头部。它将缩小下一个和上一个按钮，并将标题居中在屏幕上。
- en: 'To give our table a border, we''ll add the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的表格添加边框，我们将添加以下代码：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These are for any table; so this styling will be used on the individual day
    page, where we will have another table. However, we need to do a few things specifically
    for the month table, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是为任何表格的；所以这种样式将在单个日页面上使用，在那里我们将有另一个表格。但是，我们需要为月份表格做几件特别的事情，如下所示：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You'll recall that we added the `month` class to our month's `<table>` element.
    We're taking advantage of that here. If you aren't familiar with the `table-layout`
    attribute, it basically makes sure that all of our columns are of the same width.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们给月份的`<table>`元素添加了`month`类。我们在这里利用了这一点。如果你不熟悉`table-layout`属性，它基本上确保了所有列的宽度相同。
- en: 'Next, we want to style the individual cells. This is how that''s done:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要样式化单个单元格。这是如何做到的：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have to position the `<td>` elements relatively so that we can position the
    `<span>` elements with the `date` class absolutely inside them, for effect. This
    is an old trick that will let us position the `<span>` elements absolutely in
    their parent (a `<td>` element), instead of in the whole page. The rest of this
    is just for looks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将`<td>`元素相对定位，以便我们可以将具有`date`类的`<span>`元素绝对定位在其内部，以达到效果。这是一个老技巧，它将允许我们将`<span>`元素绝对定位在其父元素（一个`<td>`元素）中，而不是整个页面上。其余的只是为了外观。
- en: The user will click on these `<td>` elements to take them to the individual
    day pages, so let's give the user a little feedback when they hover over a cell,
    shall we?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将点击这些 `<td>` 元素来进入单个日历页面，所以当用户悬停在单元格上时，我们是否给用户一点反馈？
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last order of business is the unordered list of event titles that each
    cell will have. Here''s the styling for them:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是每个单元格将有的无序列表的事件标题。以下是它们的样式：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice that the `<ul>` element has `overflow: scroll`. This way, if a single
    day has many events, it won''t make extra table rows at all; it will just make
    the rows scroll.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到 `<ul>` 元素有 `overflow: scroll`。这样，如果某一天有很多事件，它根本不会创建额外的表格行；它只会使行滚动。'
- en: 'With all this styling in place, you can refresh the page and see what is shown
    in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些样式设置完成后，您可以刷新页面，查看以下截图所示的内容：
- en: '![Building the day cells](img/6997OS_04_02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![构建日历单元格](img/6997OS_04_02.jpg)'
- en: Much better, don't you think?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不是更好吗？
- en: Creating the individual day screen
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单个日历屏幕
- en: Right now, when we click on a cell in our table, our route will change, but
    nothing will change on the screen. This isn't because we aren't triggering a change
    with our route-swap; we are. We just haven't created that method in our router
    yet. So, that's our next stop.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们点击表格中的单元格时，我们的路由会改变，但屏幕上没有任何变化。这不是因为我们没有通过我们的路由交换触发更改；我们确实触发了。我们只是还没有在我们的路由器中创建那个方法。所以，那就是我们的下一个目的地。
- en: 'In the `router.js` file, add the following line to the `Router` class''s `routes`
    property:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `router.js` 文件中，向 `Router` 类的 `routes` 属性添加以下行：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need the `day` method that we''re calling there:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在那里调用的 `day` 方法：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method renders the `App.Views.Day` view, the top-level view for the individual
    pages. It takes a Moment object for the date we're displaying and the collection
    of events. We get a `moment` object for the date by passing the clean-up properties
    to the `moment` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法渲染 `App.Views.Day` 视图，这是单个页面的顶级视图。它需要一个表示显示日期的 Moment 对象和事件集合。我们通过将清理属性传递给
    `moment` 方法来获取日期的 `moment` 对象。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might expect us to limit this collection to only events for the specific
    date the user is looking at with our `onDate` method. However, we're passing in
    the whole collection, because this is the `Calendar` instance to which we want
    to add new event instances. This is because our month view uses the `this.calendar`
    collection, and we want to make sure any event we add in a day view will show
    up in the month view immediately, with no page refresh required.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望我们通过我们的 `onDate` 方法将此集合限制为仅包含用户查看的特定日期的事件。然而，我们传递了整个集合，因为我们想要向这个 `Calendar`
    实例添加新的事件实例。这是因为我们的月份视图使用 `this.calendar` 集合，我们想要确保在日历视图中添加的任何事件都会立即显示在月份视图中，无需刷新页面。
- en: 'The `App.Views.Day` view is a wrapper view. It holds three main views:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.Day` 视图是一个包装视图。它包含三个主要视图：'
- en: '`DayTable`: This provides the hour-by-hour breakdown of the day'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DayTable`：这提供了按小时分解的日历'
- en: '`Details`: This provides a closer look at whichever event the user is currently
    hovering over'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Details`：这提供了对用户当前悬停的任何事件的更详细查看'
- en: '`CreateEvent`: This provides a form used to create a new event'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateEvent`：这提供了一个用于创建新事件的表单'
- en: We'll use CSS to split the screen in two vertically. On the left, we'll have
    the `DayTable` view; on the right, we'll have the `Details` view and the `CreateEvent`
    view. The job of the `Day` view class is to put these three views in place.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 CSS 在垂直方向上分割屏幕。在左侧，我们将有 `DayTable` 视图；在右侧，我们将有 `Details` 视图和 `CreateEvent`
    视图。`Day` 视图类的任务是放置这三个视图。
- en: 'We''ll start with the template, by adding the following code in the `day.html`
    file, in the `templates` folder:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从模板开始，通过在 `templates` 文件夹中的 `day.html` 文件中添加以下代码：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We'll show the date at the top of the page, with a link to go back to the month
    view. Then, we have a `<div>` element with the `splitView` class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在页面顶部显示日期，并提供一个链接返回到月份视图。然后，我们有一个具有 `splitView` 类的 `<div>` 元素。
- en: 'We interrupt this code to give you the following CSS code for that `splitView`
    class. Put this code in the `style.css` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中断代码，为您提供以下针对该 `splitView` 类的 CSS 代码。将此代码放入 `style.css` 文件中：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s start the `Day` view class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始 `Day` 视图类的编写：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's more, but we'll start with this. We set the template. In the `initialize`
    method, we get the `date` property. Then, we wire up an event. When the back button
    is clicked on, we'll call the `backToMonth` method, which will change the route
    back to the month screen in the same way we switched to the day screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容，但我们将从这里开始。我们设置模板。在 `initialize` 方法中，我们获取 `date` 属性。然后，我们绑定一个事件。当点击后退按钮时，我们将调用
    `backToMonth` 方法，这将改变路由回到月份屏幕，就像我们切换到日屏幕一样。
- en: Then, inside the `render` method, we put together part of the solution. We get
    the `<div class='splitView'>` element and append a new `DayTable` view instance.
    This view takes the date for this page and the collection of events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `render` 方法内部，我们将解决方案的一部分组合起来。我们获取 `<div class='splitView'>` 元素，并附加一个新的
    `DayTable` 视图实例。这个视图接受本页的日期和事件集合。
- en: This `DayTable` view is probably the most unique view that we'll have created
    up to this point in the book. As you expect, it will be an HTML table, with each
    row representing an hour of the day. The left column will be the time, and the
    right column will show the title of the event, if one is occurring during that
    hour. The tricky part is that most events will probably span more than one hour,
    so we'll have to figure out where to start and stop events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `DayTable` 视图可能是我们在本书到目前为止创建的最独特的视图。正如你所期待的那样，它将是一个 HTML 表格，其中每一行代表一天中的一个小时。左列将是时间，右列将显示在该小时发生的事件的标题（如果有的话）。棘手的部分是，大多数事件可能跨越多个小时，因此我们需要确定事件的开始和结束位置。
- en: 'First, how about the template for this view? Store the following code in the
    `dayTable.html` file in the `templates` folder:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个视图的模板是什么样子？将以下代码存储在 `templates` 文件夹中的 `dayTable.html` 文件中：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As with our other table-based views, the template is the core of a table. You
    can see the two columns: time and events.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的其他基于表格的视图一样，模板是表格的核心。你可以看到两个列：时间和事件。
- en: 'We''ll take this view class in parts. The `DayTable` view''s code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分部分介绍这个视图类。`DayTable` 视图的代码如下：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The element for this view will be a table with the `day` class. We're listening
    for two events on this view; any table row that has an event will have the `highlight`
    class, and every table cell in the second column will have the `event` class.
    When the user moves over or out of one of the cells with an event title in it,
    we'll call the `hover` method to highlight that event.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的元素将是一个具有 `day` 类的表格。我们在该视图中监听两个事件；任何包含事件的表格行都将具有 `highlight` 类，而第二列中的每个表格单元格都将具有
    `event` 类。当用户将鼠标移至包含事件标题的单元格上或移出时，我们将调用 `hover` 方法来突出显示该事件。
- en: In the `initialize` method, we'll get the `date` option, and then listen to
    our collection for models being added or destroyed. It's important we know when
    this happens, so we can add or remove them from the table. We'll write the `addEvent`
    and `destroyEvent` methods to do this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize` 方法中，我们将获取 `date` 选项，然后监听我们的集合中模型被添加或销毁的情况。了解何时发生这些操作非常重要，这样我们就可以将它们添加或从表格中删除。我们将编写
    `addEvent` 和 `destroyEvent` 方法来完成这项工作。
- en: Finally, we're creating an `hours` object, which we'll use to keep track of
    the `Hour` views, each of which will be a row in our table. We used this technique
    in the previous chapter, so we could easily sort the rows in our table. This time,
    we're doing it because when we want to add or remove an event from the day, we
    don't actually want to add or remove the `Hour` view; we just want to add or remove
    the event title from that view. You'll see how this works soon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `hours` 对象，我们将使用它来跟踪 `Hour` 视图，每个视图将是我们表格中的一行。我们在上一章中使用了这种技术，因此我们可以轻松地对表格中的行进行排序。这次，我们这样做是因为当我们想要在一天中添加或删除事件时，我们实际上并不想添加或删除
    `Hour` 视图；我们只想添加或删除该视图中的事件标题。你很快就会看到这是如何工作的。
- en: 'With these pieces in place, we can move on to the `render` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些部分就绪后，我们可以继续到 `render` 方法：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This should make a lot of sense. We render our template first. Then, we loop
    24 times; each time, we create an `App.Views.Hour` view instance, store it in
    the `this.hours` property for later use, and then append it to the `<tbody>` element.
    We can get the time text by creating a `moment` object with our incrementing variable;
    since just `i` isn't an understood date format, we need to pass `"H"` as a second
    parameter, so it knows that this is just the hour. Then, we format it as a nice
    time string. We use this time string as the property name when storing the view
    instance in `this.hours`. At this point (if we had an `Hour` view class), we would
    have a complete table, with a row for each hour of the day. However, all rows
    would be empty; we haven't rendered any events yet. That's why we next filter
    `collection` for this day's events, and loop over them, calling the `addEvent`
    method for each one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易理解。我们首先渲染模板。然后，我们循环 24 次；每次，我们创建一个 `App.Views.Hour` 视图实例，将其存储在 `this.hours`
    属性中供以后使用，并将其附加到 `<tbody>` 元素。我们可以通过创建一个带有递增变量的 `moment` 对象来获取时间文本；由于 `i` 不是一个可理解的日期格式，我们需要传递
    `"H"` 作为第二个参数，这样它就知道这只是一个小时。然后，我们将其格式化为一个漂亮的时间字符串。我们使用这个时间字符串作为属性名，在将视图实例存储在 `this.hours`
    中时使用。此时（如果我们有一个 `Hour` 视图类），我们将有一个完整的表格，每天的小时都有一个行。然而，所有行都是空的；我们还没有渲染任何事件。这就是为什么我们接下来过滤
    `collection` 以获取这一天的活动，并对它们进行循环，为每个活动调用 `addEvent` 方法。
- en: The tricky part, as I mentioned earlier, is that one `Event` model instance
    will probably need to span several `Hour` view instances. To write the `addEvent`
    method, we're first going to add an `hours` method to the `Event` model class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，难点在于一个 `Event` 模型实例可能需要跨越几个 `Hour` 视图实例。为了编写 `addEvent` 方法，我们首先将一个
    `hours` 方法添加到 `Event` 模型类中。
- en: 'Add the following code to the `App.Models.Event` class in the `models.js` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `models.js` 文件中的 `App.Models.Event` 类：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We start by creating the currently empty `hours` array, which we''ll eventually
    return. Then, we get the model''s `start` and `end` time. We''ve already created
    the `start` method, but we need to create the `end` method. It''s a little more
    complex than the `start` method. Add the following code to the same class that
    we''re working on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个目前为空的 `hours` 数组，我们最终将返回它。然后，我们获取模型的 `start` 和 `end` 时间。我们已经创建了 `start`
    方法，但我们需要创建 `end` 方法。它比 `start` 方法稍微复杂一些。将以下代码添加到我们正在工作的同一个类中：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As in the `start` method, we create the `moment` object by concatenating `date`
    and `endTime`. However, there's one special case; if the event ends at midnight,
    it is technically ending on the next day. However, our `moment` object will be
    pointing to midnight of the event date, which is the first hour of the day. So,
    if the end time is midnight, we'll add one day to the `moment` object. Then, we
    return.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `start` 方法中，我们通过连接 `date` 和 `endTime` 创建 `moment` 对象。然而，有一个特殊情况；如果事件在午夜结束，技术上是在第二天结束。但是，我们的
    `moment` 对象将指向事件日期的午夜，这是当天的小时。所以，如果结束时间是午夜，我们将向 `moment` 对象添加一天。然后，我们返回。
- en: Let's get back to the `hours` method. After getting the `start` and `end` times,
    we can loop when the `start` time is before the `end` time. We'll push a time
    string into the `hours` array; notice that we're formatting it as we did in the
    table. Then, we add an hour to the `start` object. Eventually, `start` will be
    the same as `end`, and the loop will stop. Then, we'll return that `hours` array.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `hours` 方法。在获取 `start` 和 `end` 时间后，我们可以循环，当 `start` 时间在 `end` 时间之前时。我们将一个时间字符串推入
    `hours` 数组；注意我们是以我们在表格中做的方式格式化它的。然后，我们将一个小时添加到 `start` 对象。最终，`start` 将与 `end`
    相同，循环将停止。然后，我们将返回那个 `hours` 数组。
- en: 'With this method, if we have an event that goes on from 1:00 P.M. to 4:00 P.M.,
    we''ll get the following array:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，如果我们有一个从下午 1:00 到下午 4:00 举行的活动，我们将得到以下数组：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You may think that we want 4:00 P.M. in there as well, but we don't. This is
    because each `Hour` view instance represents a full hour; so, the hour with the
    label `1:00 PM` refers to the hour from 1:00 P.M. to 2:00 P.M.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为我们还想在那里包含下午 4:00，但我们不需要。这是因为每个 `Hour` 视图实例代表一个完整的小时；所以，带有标签 `1:00 PM` 的小时指的是从下午
    1:00 到下午 2:00 的小时。
- en: 'With this method in place, we can go back to `App.Views.DayTable` and write
    the `addEvent` method. Remember that we''re calling this method for each event
    that we need to display in the table. The following is the code for the `addEvent`
    method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法后，我们可以回到 `App.Views.DayTable` 并编写 `addEvent` 方法。记住，我们为需要在表中显示的每个事件调用此方法。以下是为
    `addEvent` 方法编写的代码：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `addEvent` and `destroyEvent` methods are very similar, so we're looking
    at them together. In both cases, we get the array of hours for the given event,
    and then loop over it with the native array's `forEach` method. For each hour,
    we get the view from `this.hours`. In the `addEvent` method, we call the view's
    `displayEvent` method, passing the event along to that method. In the `destroyEvent`
    method, we just call the view's `removeEvent` method; there is no need to pass
    the event along.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEvent` 和 `destroyEvent` 方法非常相似，所以我们一起来看它们。在两种情况下，我们都会获取给定事件的时数组，然后使用原生数组的
    `forEach` 方法遍历它。对于每个小时，我们从 `this.hours` 获取视图。在 `addEvent` 方法中，我们调用视图的 `displayEvent`
    方法，并将事件传递给该方法。在 `destroyEvent` 方法中，我们只是调用视图的 `removeEvent` 方法；没有必要传递事件。'
- en: 'Before we get to the `Hour` view class, let''s write the last method of this
    class: `hover`. This method is called whenever we move the mouse over or out of
    one of the event titles in our table. Here''s the code for the `hover` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到达 `Hour` 视图类之前，让我们写下这个类的最后一个方法：`hover`。这个方法在我们将鼠标移到或移出我们表格中的事件标题上时被调用。以下是
    `hover` 方法的代码：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since this method is triggered by a DOM event, we'll get a DOM event object
    as our parameter (actually, since we're using jQuery, it will be a jQuery-wrapped
    DOM event object). The first order of business in this method is to figure out
    what `Event` model instance the row we're hovering over is a part of. We can do
    that by getting the ID of the `Event` instance. The `currentTarget` property of
    that DOM event object will be the element that caused the event to be triggered;
    later, when we render it, we'll give it the `data-id` property that we get here.
    Since we're listening for mouse events on the `<td class='event'>` element, that's
    what the `currentTarget` property will be.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法是由 DOM 事件触发的，我们将获得一个 DOM 事件对象作为我们的参数（实际上，由于我们使用 jQuery，它将是一个 jQuery 包装的
    DOM 事件对象）。在这个方法中的首要任务是确定我们悬停的行是哪个 `Event` 模型实例的一部分。我们可以通过获取 `Event` 实例的 ID 来做到这一点。该
    DOM 事件对象的 `currentTarget` 属性将是触发事件的元素；稍后，当我们渲染它时，我们将给它我们在这里得到的 `data-id` 属性。由于我们在
    `<td class='event'>` 元素上监听鼠标事件，所以 `currentTarget` 属性将是这个。
- en: Once we know what the ID is, we can call the collection's `get` method to find
    the model with that ID. Once we get that event model, we can get the hours for
    that event with `hours`. We then loop over those hours to find the `Hour` view
    instances that are displaying this event, and call their `hover` methods. Finally,
    we'll trigger a `hover` event on our collection, passing the event model as a
    parameter. This is something new; so far, we've only listened for built-in events
    (such as `add` and `destroy`) on our models and collections. However, we can also
    use the `trigger` method to create our own events. We can call our events whatever
    we want; we're calling this one `hover`. Elsewhere, we will listen for this event
    and perform an action when it happens.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道 ID 是什么，我们就可以调用集合的 `get` 方法来找到具有该 ID 的模型。一旦我们得到该事件模型，我们可以使用 `hours` 获取该事件的时数。然后我们遍历这些时数，找到显示此事件的
    `Hour` 视图实例，并调用它们的 `hover` 方法。最后，我们将在我们的集合上触发一个 `hover` 事件，并将事件模型作为参数传递。这是件新鲜事；到目前为止，我们只在我们的模型和集合上监听内置事件（如
    `add` 和 `destroy`）。然而，我们也可以使用 `trigger` 方法来创建我们自己的事件。我们可以命名我们的事件为任何我们想要的；我们称这个事件为
    `hover`。在其他地方，我们将监听此事件，并在事件发生时执行操作。
- en: You might think that we should be listening for these mouse events in the `Hour`
    view, since that's the view that will be affected. However, that won't work in
    this case, because we need to change multiple `Hour` views when a single one is
    hovered over.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我们应该在 `Hour` 视图中监听这些鼠标事件，因为那将是受影响的视图。然而，在这种情况下，这不会起作用，因为我们需要在单个视图被悬停时更改多个
    `Hour` 视图。
- en: 'We''re finally ready to create the `Hour` view. Its template is very simple.
    Put the following lines in the `hour.html` file of the `templates` folder:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好创建 `Hour` 视图了。它的模板非常简单。将以下行放入 `templates` 文件夹中的 `hour.html` 文件：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The template only expects the time; we'll fill in the event name (if one is
    required) from the JavaScript file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模板只期望时间；我们将从 JavaScript 文件中填写（如果需要）事件名称。
- en: 'Now, in our `views.js` file, add the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `views.js` 文件中，添加以下代码：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we know, this view will be a `<tr>` element. In the `initialize` method,
    we get the `time` property. The `render` method is extra simple in this case,
    because a lot of the action takes place in the `displayEvent` and `removeEvent`
    methods. As we saw, the `addEvent` method in the `App.Views.DayTable` view class
    will call this `displayEvent` method, passing it the `event` model that occurs
    at that hour. In the `displayEvent` method, we'll add the `highlight` class to
    that hour, add the `data-id` attribute, and put the title text into the `<td>`
    element with the `event` class. When removing an event, we do the opposite; remove
    the `highlight` class and the `data-id` attribute, and set the text to nothing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，这个视图将是一个`<tr>`元素。在`initialize`方法中，我们获取`time`属性。在这个情况下，`render`方法非常简单，因为大部分动作都在`displayEvent`和`removeEvent`方法中发生。正如我们所见，`App.Views.DayTable`视图类中的`addEvent`方法将调用这个`displayEvent`方法，并传递那个小时发生的`event`模型。在`displayEvent`方法中，我们将`highlight`类添加到那个小时，添加`data-id`属性，并将标题文本放入具有`event`类的`<td>`元素中。在删除事件时，我们做相反的操作；移除`highlight`类和`data-id`属性，并将文本设置为空。
- en: 'Finally, there''s the `hover` method. This simply toggles the `hover` class
    on the `<tr>` element. Now, before checking this out in the browser, let''s add
    a little bit of styling, add this to the `style.css` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是`hover`方法。这个方法只是切换`<tr>`元素上的`hover`类。现在，在我们检查浏览器中的效果之前，让我们添加一些样式，将其添加到`style.css`文件中：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It''s nothing much; it just adds some color and spacing to the table. With
    all this in place, we can now load up our day view. You should see something like
    what is shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有什么特别的；它只是为表格添加了一些颜色和间距。有了所有这些，我们现在可以加载我们的日视图。你应该能看到以下截图所示的内容：
- en: '![Creating the individual day screen](img/6997OS_04_03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![创建单个日屏幕](img/6997OS_04_03.jpg)'
- en: Not a bad look, eh? If you hover over either of the colored cells, you should
    see both of them switch to the yellow background.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来还不错，不是吗？如果你悬停在任一彩色单元格上，你应该看到它们都切换到黄色背景。
- en: That's the left half of our split view. Now, it's time to create the right-hand
    side. You'll recall that the right-hand side will have the `details` view and
    the creation form. Let's begin with the `details` view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们分割视图的左侧部分。现在，是时候创建右侧部分了。你应该记得，右侧将包含`details`视图和创建表单。让我们从`details`视图开始。
- en: 'Once again, we''ll start with the template: `details.html` in the `templates`
    folder. Its code is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从模板开始：`templates`文件夹中的`details.html`。其代码如下：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We're again using a bit of logic in the template. If the `start` value is not
    just an empty string, we'll render the two paragraphs. We'll show the `start`
    and `end` times for the event, as well as the duration. Finally, we'll have a
    **Delete Event** button, which will allow us to delete events.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模板中再次使用了一点点逻辑。如果`start`值不是一个空字符串，我们将渲染两个段落。我们将显示事件的`start`和`end`时间，以及持续时间。最后，我们将有一个**删除事件**按钮，这将允许我们删除事件。
- en: The reason we're using this bit of logic is because when the page is first loaded,
    the user won't be hovering over any event. In that case, we'll show a default
    instruction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这段逻辑的原因是因为当页面首次加载时，用户不会悬停在任何事件上。在这种情况下，我们将显示默认说明。
- en: 'Back in the `views.js` file, we''ll create the following view class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.js`文件中，我们将创建以下视图类：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We'll do something a bit different in the `initialize` method this time. First,
    we'll create some default filler data, called `this.data`, for the view, which
    will be displayed before the user first hovers over an hour. Then, we'll call
    the `render` method right away in the `initialize` method. This isn't a pattern
    you see very often, but there's really no reason not to do it. In the `render`
    method, we take that data and render the template. The important method in this
    class is the `changeModel` method. It takes a model as a property and recreates
    the `data` property from that. We put the `start` and `end` times in variables,
    so we don't have to call those methods twice. Then, we re-render the view, by
    calling the `render` method again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这次在`initialize`方法中会做一些不同的事情。首先，我们将为视图创建一些默认填充数据，称为`this.data`，在用户第一次悬停在小时之前显示。然后，我们立即在`initialize`方法中调用`render`方法。这不是你经常看到的一种模式，但真的没有不这样做的原因。在`render`方法中，我们处理这些数据并渲染模板。这个类中的重要方法是`changeModel`方法。它接受一个模型作为属性，并从该模型重新创建`data`属性。我们将`start`和`end`时间放入变量中，这样我们就不必调用这些方法两次。然后，我们通过再次调用`render`方法来重新渲染视图。
- en: You might wonder why we assign `this.model` in the `changeModel` method. This
    is because we'll need it in the `delete` method. We need to get a reference to
    the currently displayed model, so we can destroy it when the delete button is
    clicked on (you can see that we're connecting to the `delete` method in the `events`
    property). Of course, for the destruction of the model to work, we'll need to
    write a server method; we'll get to that.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们在`changeModel`方法中分配`this.model`。这是因为我们将在`delete`方法中使用它。我们需要获取当前显示的模型的引用，以便在点击删除按钮时将其销毁（你可以在`events`属性中看到我们正在连接到`delete`方法）。当然，为了使模型的销毁工作，我们需要编写一个服务器方法；我们很快就会做到这一点。
- en: 'But first, we want to render this view. To do this, go back to the `render`
    method in the `App.Views.Day` view class. So far, this method only creates a `DayTable`
    view (the left-hand side of the screen). Add the following code to that method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们想要渲染这个视图。为此，回到`App.Views.Day`视图类中的`render`方法。到目前为止，这个方法只创建了一个`DayTable`视图（屏幕的左侧）。向该方法添加以下代码：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, we create a `<div>` element on the right-hand side of the split view.
    Then, we create a `Details` view instance and append it to that `div` element.
    Notice that, since we call the `render` method internally, we don''t have to call
    it here. Also, we keep a reference to the `Details` view instance as `this.details`.
    This is because we need it in the `showDetails` method, which we''ll add as a
    new method in the `Day` view class. The `showDetails` method''s code is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在分割视图的右侧创建一个`<div>`元素。然后，我们创建一个`Details`视图实例并将其附加到那个`div`元素上。注意，由于我们在内部调用了`render`方法，所以我们在这里不需要调用它。此外，我们保留了对`Details`视图实例的引用，将其作为`this.details`。这是因为我们需要在`showDetails`方法中使用它，我们将在`Day`视图类中添加一个新的方法。`showDetails`方法的代码如下：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This just calls the `changeModel` method on the `Details` view. But where does
    this method get called? Remember that `hover` event that we triggered ourselves,
    when the user moves over a row? Go back up the `initialize` method of the `Day`
    view class, because we''re going to listen for that event there with this single
    line of code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调用了`Details`视图上的`changeModel`方法。但这个方法是在哪里被调用的呢？记得我们手动触发的那次`hover`事件，当用户将鼠标移到行上时？回到`Day`视图类的`initialize`方法，因为我们将用这一行代码来监听那个事件：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Great! With all this in place, you can test it out by hovering over an event;
    the `details` view should look something like what is shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！所有这些都准备好了，你可以通过悬停在事件上测试它；`details`视图应该看起来像下面截图所示：
- en: '![Creating the individual day screen](img/6997OS_04_04.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![创建单个日视图](img/6997OS_04_04.jpg)'
- en: 'We only have one view left: the `CreateEvent` view. We''ll start with the `createEvent.html`
    template. Here''s its code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一个视图：`CreateEvent`视图。我们将从`createEvent.html`模板开始。以下是它的代码：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, it's the insides of a form; the view element will be the `<form>`
    element itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个表单的内部结构；视图元素将是`<form>`元素本身。
- en: 'Here''s the beginning of the class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是类开始的代码：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You understand all this by now; even the `render` function is simple. In the
    `initialize` function, we're taking a `date` option, because we'll need to know
    on what date we're creating an event on. Where the fun starts is in the `createEvent`
    method. You can see that we're listening for a click on the button in our form
    and calling the `createEvent` method when it happens.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经理解了所有这些；即使是`render`函数也很简单。在`initialize`函数中，我们接受一个`date`选项，因为我们需要知道我们将在哪一天创建事件。有趣的部分开始于`createEvent`方法。你可以看到我们在表单中的按钮上监听点击事件，并在事件发生时调用`createEvent`方法。
- en: 'Here''s that method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是那个方法：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's a biggie, I know. We start by preventing the default form submission. Then,
    we use the data from the form and `date` from the constructor to create a new
    model instance. When creating a model like this, it isn't saved to the server
    right away. We either have to call the `save` method on the model or pass it to
    a collection's `create` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大项目，我知道。我们首先阻止默认的表单提交。然后，我们使用表单的数据和构造函数中的`date`来创建一个新的模型实例。创建这样的模型时，它不会立即保存到服务器。我们要么在模型上调用`save`方法，要么将其传递给集合的`create`方法。
- en: 'You''re probably wondering why we''re making the `collection` object an attribute
    of this model instance. This is actually a bit of a hack. The first part of the
    explanation comes from the second part of the method. You can see that we''re
    calling the model''s `isValid` method. Backbone has the ability to do validation
    on our models. If our attributes don''t conform to given patterns, we can prevent
    them from saving. We''re doing it very explicitly here, by calling this method.
    If the model is valid, we''ll save the model to the server by passing it to the
    collection''s `create` method (we pass `{wait: true}` because our `DayTable` view
    is listening for additions to the collection, so it can add them to the table;
    this way, it won''t be added until we''re sure it has been saved). Then, we clear
    out the form elements, and remove any error from the error paragraph. That error
    would occur if the model didn''t validate. Instead of saving, we would have displayed
    the model''s `validationError` property in that paragraph.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能想知道为什么我们把`collection`对象做成这个模型实例的属性。这实际上是一种小窍门。解释的第一部分来自于方法的第二部分。你可以看到我们正在调用模型的`isValid`方法。Backbone有在模型上执行验证的能力。如果我们的属性不符合给定的模式，我们可以阻止它们保存。我们在这里非常明确地这样做，通过调用这个方法。如果模型有效，我们将通过将其传递给集合的`create`方法将模型保存到服务器（我们传递`{wait:
    true}`是因为我们的`DayTable`视图正在监听集合的增加，以便将其添加到表格中；这样，它将在我们确定它已被保存之后才会被添加）。然后，我们清除表单元素，并从错误段落中删除任何错误。如果模型没有验证，这个错误就会发生。而不是保存，我们会在那个段落中显示模型的`validationError`属性。'
- en: Right now, we're calling the model's `isValid` method, but we haven't created
    any validation rules yet. Backbone's validation feature is barebones. In our `Event`
    model class, we'll create a method named `validate`. Whenever we try to save a
    model, this method will be called. As a parameter, the `validate` method will
    receive an object containing the attributes of the model. Inside the method, we
    write whatever code we want. If everything checks out, we don't return anything.
    However, if there's a problem, we can return an error message (it can be a simple
    string or something more complex). The error message will then be assigned to
    `model.validationError`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在调用模型的`isValid`方法，但我们还没有创建任何验证规则。Backbone的验证功能是基础版的。在我们的`Event`模型类中，我们将创建一个名为`validate`的方法。每次我们尝试保存模型时，这个方法都会被调用。作为参数，`validate`方法将接收一个包含模型属性的对象。在方法内部，我们编写我们想要的任何代码。如果一切检查无误，我们不返回任何内容。然而，如果有问题，我们可以返回一个错误消息（它可以是简单的字符串或更复杂的东西）。然后，错误消息将被分配给`model.validationError`。
- en: 'So, let''s write the validation method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们编写验证方法：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the second part of the explanation for why we included the `collection`
    object in our model's attributes. What we need to validate is the `start` and
    `end` times. If the event we're trying to create overlaps with other events that
    are already in the calendar, we can't allow the new event to be created. However,
    from within the model's `validate` method, there's no way to access the collection.
    So, we pass it as an attribute of the model we're validating, using the `onDate`
    method to limit it to events on this date. Sure, it's a hack; but it works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么我们把`collection`对象包含在我们的模型属性中的解释的第二部分。我们需要验证的是`start`和`end`时间。如果我们正在尝试创建的事件与日历中已经存在的事件冲突，我们不允许创建新的事件。然而，在模型的`validate`方法内部，我们无法访问集合。因此，我们通过使用`onDate`方法将其限制为这个日期的事件，将其作为我们正在验证的模型的一个属性传递。当然，这是一个小窍门；但它有效。
- en: We start by making sure that our attributes include a `collection` attribute.
    If we have it, the first job is to figure out what hours of the day are already
    taken. We can find the hours for each event individually by calling the `hours`
    method we created. We can use the collection's `invoke` method to call that method
    on all its models; it will return an array of results. Since each result is an
    array, we have an array of arrays. Then, we can use Underscore's `flatten` method
    to turn that into a one-dimensional array. The result is an array with all the
    hours that are already taken.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保我们的属性中包含一个`collection`属性。如果我们已经有了，第一项任务是找出一天中已经被占用的时段。我们可以通过调用我们创建的`hours`方法来单独找到每个事件的时段。我们可以使用集合的`invoke`方法来调用其所有模型上的该方法；它将返回一个结果数组。由于每个结果都是一个数组，所以我们有一个数组的数组。然后，我们可以使用Underscore的`flatten`方法将其转换为一维数组。结果是包含所有已被占用的时段的数组。
- en: Next, we do a bit of functional-style programming. We start by calling `this.hours`
    to get the array of hours during which this event occurs. Then, we map that to
    the value of `takenHours.indexOf(x)`. This will loop over the hours of this event
    and get their index in the `takenHours` array. The important bit here is that
    if an hour isn't in `takenHours`, it will return `-1`. Next, we use the array's
    `filter` to filter it, only keeping the values that are greater than `-1`. Finally,
    we get the `length` value of the resulting array. Following this logic, the `hours`
    variable will be the number of values that overlap between the `takenHours` and
    `this.hours` arrays.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进行一些函数式编程。我们首先调用`this.hours`来获取这个事件发生的时段数组。然后，我们将它映射到`takenHours.indexOf(x)`的值。这将遍历这个事件的小时，并获取它们在`takenHours`数组中的索引。这里的关键点是，如果一个小时不在`takenHours`中，它将返回`-1`。接下来，我们使用数组的`filter`进行过滤，只保留大于`-1`的值。最后，我们获取结果数组的`length`值。按照这个逻辑，`hours`变量将是`takenHours`和`this.hours`数组之间重叠的值的数量。
- en: Then, we'll remove the `collection` property with the `unset` method because
    we no longer need it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`unset`方法移除`collection`属性，因为我们不再需要它。
- en: Finally, if the overlapping hours count is greater than 0, we'll return an error;
    you already have an event at that time. With this method in place, you can look
    back at the `createEvent` method and understand exactly what we're doing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果重叠的小时数大于0，我们将返回一个错误；你已经在那个时间有了事件。有了这个方法，你可以回顾`createEvent`方法，并确切地了解我们在做什么。
- en: 'The last step for the `CreateEvent` class is to put it on the screen. Go back
    to the `render` method of the `App.Views.Day` class and add the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateEvent`类的最后一步是将它显示在屏幕上。回到`App.Views.Day`类的`render`方法，并添加以下代码：'
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''re putting it in the `div` element that we created to the right-hand side
    of the split view. As required, we give it the `date` string and the `collection`
    object, and then render it. Now, our page should look like what is shown in the
    following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其放入我们为分割视图右侧创建的`div`元素中。按照要求，我们给它提供`date`字符串和`collection`对象，然后进行渲染。现在，我们的页面应该看起来像以下截图所示：
- en: '![Creating the individual day screen](img/6997OS_04_05.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![创建单个日历屏幕](img/6997OS_04_05.jpg)'
- en: Writing the server code
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写服务器代码
- en: 'The server code is very simple for this application. First, we need to render
    the `index.ejs` template with the event models in the database. So, make sure
    our GET request catch-all looks like the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，服务器代码非常简单。首先，我们需要使用数据库中的事件模型渲染`index.ejs`模板。所以，确保我们的GET请求通配符看起来像以下代码：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, in the `index.ejs` file of the `views` folder, in the router creation
    code, remove the dummy records that we put in and replace it with the template
    data, like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`views`文件夹中的`index.ejs`文件中，在创建路由的代码中，移除我们放入的虚拟记录，并用模板数据替换它，如下所示：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Back in the `server.js` file, we need the route that the POST request is sent
    to when we''re creating a new `Event` model. Its code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`server.js`文件，当我们创建一个新的`Event`模型时，需要POST请求发送到的路由。其代码如下：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We get the request body, and then create our record from its properties. Once
    we have saved the record, we'll send it back to the server.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取请求体，然后根据其属性创建我们的记录。一旦我们保存了记录，我们就会将其发送回服务器。
- en: 'Finally, we''ll need the route that is called when we destroy a model. This
    is a DELETE request, and this is what it looks like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在销毁模型时调用的路由。这是一个DELETE请求，其外观如下：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We get the ID of the record, find the related row, and return an empty response.
    That''s it for the server. With this code in place, you''re ready to give it a
    try. Go to an individual day page and add a few events. You should get something
    like what is shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取记录的ID，找到相关的行，并返回一个空响应。这就是服务器的全部内容。有了这段代码，你就可以尝试使用了。前往一个单独的日历页面并添加一些事件。你应该会得到以下截图所示的内容：
- en: '![Writing the server code](img/6997OS_04_06.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![编写服务器代码](img/6997OS_04_06.jpg)'
- en: You can see all the components in play here; the table of hours, the hover effect,
    and the details view. You can even see the error message when we try to create
    an event that overlaps with another.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到所有组件的运行情况；小时表、悬停效果和详情视图。你甚至可以看到当我们尝试创建一个与其他事件重叠的事件时出现的错误信息。
- en: 'There''s one last step; a nicety, really. If you go back to the month view,
    you will notice that the events in each day cell don''t appear in order of time.
    Instead, they appear in the order we created them. It would be nice if they appeared
    in order of occurrence, and this is very simple to do. In the `App.Models.Calendar`
    class (in the `models.js` file), we can write a `comparator` method to keep things
    in order:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一步；实际上是一个小细节。如果你回到月份视图，你会注意到每一天单元格中的事件并不是按照时间顺序出现的。相反，它们是按照我们创建它们的顺序出现的。如果它们能按照发生顺序出现那就更好了，而这非常简单。在
    `App.Models.Calendar` 类（在 `models.js` 文件中），我们可以写一个 `comparator` 方法来保持顺序：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can simply return the result of the `moment` object's `isAfter` method to
    see which should come first; Backbone takes care of the rest.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地返回 `moment` 对象的 `isAfter` 方法的结果，以确定哪个应该先出现；Backbone 会处理其余的部分。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've done a lot of new and interesting things in this chapter. The most difficult
    part was getting the hover effect. It required us to find all the views that represented
    a single model instance. Most of the time, in a Backbone application, you'll have
    a single view representing a model instance at a time. However, as you've seen
    here, while this is the norm, it certainly isn't the only way possible.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了许多新颖有趣的事情。最困难的部分是获取悬停效果。这需要我们找到表示单个模型实例的所有视图。在 Backbone 应用程序中，大多数时候你只会有一个视图来表示一个模型实例。然而，正如你所看到的，虽然这是规范，但这绝对不是唯一可能的方式。
- en: The other neat use of Backbone was the `Month` class that we created. We're
    really just using it as a handy wrapper; there's no reason we couldn't have written
    a simple function that returned an object literal. However, the way we've done
    it shows off the flexibility of Backbone.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 的另一个巧妙用法是我们创建的 `Month` 类。我们实际上只是用它作为一个方便的包装器；我们没有理由不能写一个简单的函数来返回一个对象字面量。然而，我们这样做的方式展示了
    Backbone 的灵活性。
- en: The last, but arguably most important, idea from this chapter is the idea of
    moving appropriate logic into the model class, instead of putting it in the view
    class. Good examples of this are the `App.Models.Calendar` class's `onDate` method
    or the `App.Models.Event` class's `hours` method. This is one of the big ideas
    of the Model-View-Controller pattern. Of course, Backbone isn't strictly MVC,
    but a lot of the principles still apply. As much as you can, make your model classes
    fat and your views and routers thin. This doesn't mean putting view or routing
    logic in the model. It means that any logic that isn't specifically about views
    or routing should probably be in a model class. For more on this topic, there's
    a lot of great MVC material online; you could start with [http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488](http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488).
    In the next chapter, we'll take things to a whole new level when we create a real-time,
    two-way chat application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后一个，但可能是最重要的想法是将适当的逻辑移动到模型类中，而不是将其放在视图类中。这个想法的例子包括 `App.Models.Calendar`
    类的 `onDate` 方法或 `App.Models.Event` 类的 `hours` 方法。这是模型-视图-控制器模式的一个大思想。当然，Backbone
    并不是严格遵循 MVC，但许多原则仍然适用。尽可能让你的模型类更丰富，让你的视图和路由器更精简。这并不意味着将视图或路由逻辑放入模型中。这意味着任何不是专门关于视图或路由的逻辑可能都应该在一个模型类中。关于这个话题，网上有很多优秀的
    MVC 资料可供参考；你可以从 [http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488](http://dev.tutsplus.com/tutorials/mvc-for-noobs--net-10488)
    开始。在下一章中，当我们创建一个实时双向聊天应用程序时，我们将把事情提升到一个全新的水平。
