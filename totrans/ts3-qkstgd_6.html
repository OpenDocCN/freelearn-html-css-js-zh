<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Reusing Code Through Generic</h1>
                </header>
            
            <article>
                
<p>This chapter is built from notions introduced by the previous chapters. The chapter built on top of notions by enhancing type by making them generic. Basic topics such as defining a generic class and interface are covered. Through the chapter, we move into more advanced topics such as generic constraints are part of the content. The goal of this chapter is to make your code more generic to increase the reusability of your classes, functions, and structures, to reduce the burden of duplicating code.</p>
<p>The content in this chapter covers the following:</p>
<ul>
<li class="h1">How generic can make your code reusable</li>
<li class="h1">Accepted kinds of data structure for generic type</li>
<li class="h1">How to constrain the generic type</li>
<li class="h1">Generic and intersection</li>
<li class="h1">Default generic</li>
<li class="h1">Generic optional type</li>
<li class="h1">Generic constraints with a union type</li>
<li class="h1">Restricting string choices with <kbd>keyof</kbd></li>
<li class="h1">Limiting the access to members of a generic type</li>
<li class="h1">Reducing your type creation with a mapped type</li>
<li class="h1">Generic type in TSX file</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic code to increase reusability</h1>
                </header>
            
            <article>
                
<p>Generic is available in almost all typed language. It allows transforming your code in a reusable fashion without having to rely on unsafe casting to retrieve the value stored in an object. Without generic, there are different ways to achieve reusability. For example, you can have an interface with an <kbd>any</kbd> typ<span>e</span>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>That would make the field open to receive any kind of object, hence being reusable for many scenarios:</p>
<pre>interface ReusableInterface1 {<br/>    entity: any;<br/>}</pre>
<p>A slightly better way would be to specify whether we want to accept primitives or only objects:</p>
<pre>interface ReusableInterface2 {<br/>   entity: object;<br/>}<br/><br/>const ri2a: ReusableInterface2 = { entity: 1 }; // Does not compile<br/>const ri2b: ReusableInterface2 = { entity: { test: "" } };</pre>
<p>In both cases, the problem comes when we want to use the reusable field. The same result occurs with <kbd>any</kbd> or <kbd>object</kbd>, which is that we do not have access to the original variable's member because we do not have a way to know what was the original type:</p>
<pre>const value = ri2b.entity; // value -&gt; "object"</pre>
<p>In this code, it is impossible to use <kbd>.test</kbd> of the entity without casting back to the entity. In that particular type, it is an anonymous type but still possible:</p>
<pre>const valueCasted = value as { test: string };<br/>console.log(valueCasted.test);</pre>
<p>However, generic can remove this hinder to access the original type by bringing the type of the object into the definition of the type without tampering the type to be isolated with a single type. To create a generic function, interface, or class, you need to use the smaller or bigger sign, <kbd>&lt; &gt;</kbd>:</p>
<pre>interface MyCustomTypeA {<br/>   test: string;<br/>}<br/><br/>interface MyCustomTypeB {<br/>   anything: boolean;<br/>}<br/><br/>interface ReusableInterface3&lt;T&gt; {<br/>   entity: T;<br/>}</pre>
<p class="mce-root"/>
<p>The name between the brackets does not matter. In the following code, we are using the entity with two custom interfaces and use them as type <kbd>T</kbd>. We are also using a number directly. We can use all the possible types because we do not have a generic constraint, yet, in place:</p>
<pre>const ri3a: ReusableInterface3&lt;MyCustomTypeA&gt; = { entity: { test: "yes" } };<br/>const ri3b: ReusableInterface3&lt;MyCustomTypeB&gt; = { entity: { anything: true } };<br/>const ri3c: ReusableInterface3&lt;number&gt; = { entity: 1 };</pre>
<p>The biggest advantage is that if we access the object, the field entity is of a <kbd>T</kbd> type, which changes depending on how the object was created:</p>
<pre>console.log(ri3a.entity.test); // "yes" -&gt; string<br/>console.log(ri3b.entity.anything); // true -&gt; boolean<br/>console.log(ri3c.entity); // 1 -&gt; number</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accepted kinds of data structure for generic type</h1>
                </header>
            
            <article>
                
<p>The concept of generic spreads beyond just interfaces. Generic is available for types but also with classes, and it can transform a function as well. The disposition of the brackets that define the generic type goes right after the interface name, type, or the class name. We will see later that it must also go after the name of a function. Generic can be used to have a generic field, generic parameter, generic return type, and generic variable:</p>
<pre>type MyTypeA&lt;T&gt; = T | string; // Type<br/><br/>interface MyInterface&lt;TField, YField&gt; { // Interface wiht two types<br/>  entity1: TField;<br/>  myFunction(): YField;<br/>}<br/><br/>class MyClass&lt;T&gt;{ // Class<br/> list: T[] = [];<br/> public displayFirst(): void {<br/>   const first: T = this.list[0]; // Variable<br/>   console.log(first);<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>A generic type can have many generics at the same time, allowing multiple fields or function parameters to have a different kind of type:</p>
<pre>function extractFirstElement&lt;T, R&gt;(list: T[], param2: R): T {<br/>  console.log(param2);<br/>  return list[0];<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constaining a generic type</h1>
                </header>
            
            <article>
                
<p>In a previous code example in this chapter, we used the type object to make sure no primitives were passed in an interface. The problem with the use of an object is that you do not get back the initial type when you get back the entity. The following code illustrates the problem:</p>
<pre>interface ReusableInterface2 {<br/>  entity: object;<br/>}<br/><br/>const a = {<br/>  what: "ever"<br/>};<br/><br/>const c: ReusableInterface2 = { entity: a };<br/>console.log(c.entity.what); // Does not compile because "what" is not of object</pre>
<p>It is possible to keep the original type and have a constraint to not allow a primitive with the keyword <kbd>extends</kbd>:</p>
<pre>interface AnyKindOfObject {<br/>  what: string;<br/>}<br/><br/>interface ReusableInterface3&lt;T extends object&gt; {<br/>  entity: T;<br/>}<br/><br/>const d: ReusableInterface3&lt;AnyKindOfObject&gt; = { entity: a };<br/>console.log(d.entity.what); // Compile</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>extends</kbd> keyword allows specifying the minimum structure that must be present in the object passed to the generic type. In that case, we were passing an object. However, we could extend any minimum structure, interface, or type:</p>
<pre>interface ObjectWithId {<br/> id: number;<br/> what: string;<br/>}<br/><br/>interface ReusableInterface4&lt;T extends { id: number }&gt; {<br/> entity: T;<br/>}<br/><br/>const e: ReusableInterface4&lt;AnyKindOfObject&gt; = { entity: a }; // Doesn't compile<br/>const f: ReusableInterface4&lt;ObjectWithId&gt; = { entity: { id: 1, what: "1" } }; // Compile<br/>const g: ReusableInterface4&lt;string&gt; = { entity: "test" }; // Doesn't compile</pre>
<p>The previous code example has two variables that do not compile. The first one, the variable is set to a wrong object. The third variable is set to a string, but the generic constraint cannot be fulfilled by the string because it doesn't have the id:number field. The second variable compiles because of the entity respect the constraint. Finally, here is an example of having a generic with a constraint that is an interface:</p>
<pre>interface ReusableInterface5&lt;T extends ObjectWithId&gt; {<br/>   entity: T;<br/>}</pre>
<p>Other than having access back to the full original type, generic with constraint allows accessing the constrain field from the class or function that implements the generic. The first code example, with <kbd>function</kbd>, has the constraint directly at the function signature. It allows accessing only the field from the constraint:</p>
<pre>function funct1&lt;T extends ObjectWithId&gt;(p: T): void {<br/>   console.log(`Access to ${p.what} and ${p.id}`);<br/>}</pre>
<p>Similarly, a class lets you use inside any of its functions, the field from the generic constraint. In the following code, the function loops the generic list of <kbd>T</kbd>. Since <kbd>T</kbd> is extending <kbd>ObjectWithId</kbd> that has <kbd>what</kbd> property and <kbd>id</kbd>; both are accessible:</p>
<pre>class ReusableClass&lt;T extends ObjectWithId&gt;{<br/> public list: T[] = [];<br/> public funct1(): void {<br/>   this.list.forEach((p) =&gt; {<br/>    console.log(`Access to ${p.what} and ${p.id}`);<br/>    });<br/> }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic and intersection</h1>
                </header>
            
            <article>
                
<p>Generic and intersection work well together. It allows the use of an undetermined type and creates a second one with the combination of a known type or another generic. In the following code, there is a generic function that takes a type <kbd>T</kbd> that must respect to a minimum the structure of the <kbd>User</kbd><span> object</span>. The return type of the function is the generic type passed by a parameter intersected by a new <kbd>WithId</kbd> structure. It means that whatever the type passed will be enhanced with the new structure. In the code, the <kbd>Developer</kbd> <span>type </span>is passed to the function and the function returns <kbd>Developer+WithId</kbd>. It is a new type, not defined anywhere, but is still strongly typed:</p>
<pre>interface WithId {<br/> id: number;<br/>}<br/><br/>interface User {<br/> name: string;<br/>}<br/><br/>interface Developer extends User {<br/> favoriteLanguage: string;<br/>}<br/><br/>function identifyUser&lt;T extends User&gt;(user: T): T &amp; WithId {<br/> const newUser = (&lt;any&gt;Object).assign({}, user, { id: 1 });<br/> return newUser;<br/>}<br/><br/>const user: Developer = { name: "Patrick", favoriteLanguage: "TypeScript" };<br/>const userWithId = identifyUser(user);<br/>console.log(`${userWithId.name} (${userWithId.id}) favorite language<br/> is ${userWithId.favoriteLanguage}`);</pre>
<p>The code shows that we can use the return type and have all three members available.</p>
<p>It is possible to intersect many generic types together, for example:</p>
<pre>function merge&lt;T, U&gt;(obj1: T, obj2: U): T &amp; U {<br/>   return Object.assign({}, obj1, obj2);<br/>}</pre>
<p>The <kbd>merge</kbd> function takes two different types and merges them using the JavaScript <kbd>assign</kbd> function. The function returns the intersection of both types. If we dig into the definition of the <kbd>Object.assign</kbd> function, we realize that this one is also leveraging the intersection with generic. Here is the definition file of <kbd>Object.assign</kbd> for ES2015:</p>
<pre>assign&lt;T, U, V&gt;(target: T, source1: U, source2: V): T &amp; U &amp; V;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default generic</h1>
                </header>
            
            <article>
                
<p>The more you work with generic, the more you may find that for a particular case in your system you are using always the same type. It could almost not be generic but be of a specific type. In that case, it is interesting to use a default type for your generic. A default generic type allows avoids having to specify a type. A default generic is also known as an optional type.</p>
<p>TypeScript uses the type specified in the generic signature after the equals sign:</p>
<pre>interface BaseType&lt;T = string&gt; {<br/> id: T;<br/>}<br/>let entity1: BaseType;<br/>let entity2: BaseType&lt;string&gt;;<br/>let entity3: BaseType&lt;number&gt;;</pre>
<p>Three variables are declared. The first and second ones are exactly the same: they expect an object with an <kbd>id</kbd> of a <kbd>string</kbd> type. The last is a number. The reason the first and second are exactly the same is that the first declaration relies on the default type. The default type is specified in the generic definition of the interface after the name of the type, <kbd>T</kbd>. The use of the equals signs allows the assignation.</p>
<p>In the case of multiple defaults, only optional typing can be used if no type is optional afterward. The following code shows the same interface, the first one does not compile because it has the optional generic type before a required type:</p>
<pre>interface User&lt;T = string, U&gt; { // Does not compile<br/>  id: T;<br/>  name: U;<br/>}<br/><br/>interface User&lt;U, T = string&gt; {<br/>  id: T;<br/>  name: U;<br/>}</pre>
<p>Default generic can have constraints and it deems to respect constraint with its default type. The following code does not work because the default type is set to be a number. However, the constraint mentions that the structure must have an id of type <kbd>number</kbd>:</p>
<pre>interface WithId {<br/> id: number;<br/>}<br/><br/>interface UserWithDefault&lt;T extends WithId = number&gt; { } // Does not compile</pre>
<p>However, if we change the default type to be <kbd>User&lt;number&gt;</kbd> it compiles. The reason is that user interface has an <kbd>id</kbd> field of type <kbd>T</kbd>. The default type is not compatible with the constraint extended, which requires an <kbd>id</kbd> of a<span> <kbd>number</kbd></span> type. This means that without explicitly mentioning the generic type of <kbd>User</kbd> in the default signature, the code does not compile:</p>
<pre>interface User&lt;T = string&gt; {<br/> id: T;<br/>}<br/><br/>interface WithId {<br/> id: number;<br/>}<br/><br/>interface UserWithDefault&lt;T extends WithId = User&lt;number&gt;&gt; { }<br/>// Does not compile because User&lt;string&gt;<br/>interface UserWithDefault&lt;T extends WithId = User { }</pre>
<p>A default type is used when a type is not explicit or when TypeScript cannot infer the type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic optional type</h1>
                </header>
            
            <article>
                
<p>A generic type can be optional in a function or a class. When optional and generic, the type becomes an empty object or undefined:</p>
<pre>function shows&lt;T&gt;(p1?: T): void {<br/> console.log(p1);<br/>}<br/><br/>shows(); // p1 is {} | undefined<br/>shows("123");<br/>shows(123);</pre>
<p>Providing a default value to an optional type changes the parameter from an empty object to the default type:</p>
<pre>function shows&lt;T = number&gt;(p1?: T): void {<br/> console.log(p1);<br/>}<br/>shows(); // p1 is number | undefined</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic constraints with a union type</h1>
                </header>
            
            <article>
                
<p>There is some room for using a union in the <kbd>extends</kbd> clause of a generic definition. While you cannot use <kbd>discriminator</kbd>, you can compare against an array. The following object allows a type and an array of the same type. You can narrow down to any of the two types using <kbd>instanceOf</kbd> and manipulate the parameter value:</p>
<pre>interface ObjectWithAge {<br/> kind: "ObjectWithAge";<br/> age: number;<br/>}<br/><br/>function funct2&lt;T extends ObjectWithAge | ObjectWithAge[]&gt;(p: T): T {<br/> if (p instanceof Array) {<br/>   return p[0];<br/> }<br/> return p;<br/>}</pre>
<p>Trying to extend two different objects with a discriminator does not work at the moment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Restricting string choices with keyof</h1>
                </header>
            
            <article>
                
<p>The use of string in JavaScript is omnipresent. One pattern is to access a member of an object dynamically with the square bracket:</p>
<pre>interface Human {<br/> name: string;<br/> birthdate: Date;<br/> isHappy: boolean;<br/>}<br/><br/>const me: Human = {<br/> name: "Patrick",<br/> birthdate: new Date(1912, 0, 1),<br/> isHappy: true<br/>}<br/><br/>console.log(me["name"]);</pre>
<p>The problem with the code is that <kbd>name</kbd> is a string and could be anything. We could set between brackets<kbd> firstname</kbd>, and the code would compile. At runtime, the console would show <kbd>undefined</kbd>. To avoid falling into the pitfall of selecting a member that does not exist, we can use <kbd>keyof</kbd>, which will return a union of all members of an object. The union is a <kbd>string literal</kbd> of all members' names.</p>
<p>Before going with <kbd>keyof</kbd>, create a <kbd>function</kbd> that tries to access a property by a string fail, without defining an index signature (see <em>Index signature</em> in this book):</p>
<pre>function showMe1(obj: Human, field: string): void {<br/>  console.log(obj[field]); // Does not compile<br/>}</pre>
<p>However, the same function with <kbd>keyof</kbd> will work without an index signature. The reason is that TypeScript knows that you do not try to access a field that might not exist. The goal of accessing with the square bracket is to access members that exist:</p>
<pre>function showMe2(obj: Human, field: keyof Human): void {<br/>  console.log(obj[field]);<br/>}</pre>
<p>The <kbd>keyof</kbd> allows specifying in a string format the only field from the type after the <kbd>keyof</kbd> <span>keyword</span>. In the code example before, only the string <kbd>name</kbd>, <kbd>birthdate</kbd> and <kbd>isHappy</kbd> can be entered without having the compiler show an error:</p>
<pre>showMe2(me, "name"); // Compile<br/>showMe2(me, "NOname"); // Does not compile</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting the access to members of a generic type</h1>
                </header>
            
            <article>
                
<p>It is possible to use generic with <kbd>keyof</kbd> in a constraint to only specify in a string format member name from the generic object.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the following code, we are passing an object in the first parameter, and in the second accepting only the member name of the first parameter object. The constraint syntax is the same using <kbd>extends</kbd> followed by <kbd>keyof</kbd> and the first generic type. The return type is the return type of the selected member, which is accessible by using the first generic with the index signature of the second generic:</p>
<pre>function prop&lt;TObject, TMember extends keyof TObject&gt;(<br/> obj: TObject,<br/> key: TMember<br/>): TObject[TMember] {<br/> return obj[key];<br/>}<br/><br/>interface ObjectWithName {<br/> name: string;<br/> age: number;<br/>}<br/><br/>const obj1: ObjectWithName = { name: "Patrick", age: 212 };<br/>const result1: string = prop(obj1, "name");<br/>const result2: number = prop(obj1, "age");</pre>
<p>The syntax provides a good type safety, in terms of specifying members of an object that can be from a variety of potential types, and also provides safety in terms of the return type. If <kbd>name</kbd> changes from <kbd>string</kbd> to a rich object (with many members), the code consuming the return of this function will break at compilation time. It's the same if the name changes, the refactoring tool will change it. However, if the change is done without using any refactoring tool, the compiler will catch that the name is not a valid one.</p>
<p>The following code shows how <kbd>keyof</kbd> can be used to make sure a function returns the name of the desired member. The first time the function is called, it returns <kbd>name</kbd>; however, the second invocation does not compile because the name of the member does not exist in the generic type:</p>
<pre>function nameof&lt;T&gt;(instance: T, key: keyof T): keyof T {<br/>   return key;<br/>}<br/><br/>const name1 = nameof(obj1, "name");<br/>const name2 = nameof(obj1, "nasme"); // Does not compile<br/>console.log(name1); // "name"</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reducing your type creation with mapped type</h1>
                </header>
            
            <article>
                
<p>When you start typing all your objects, you may fall into the situation where you need to have almost the same type but with some minor differences. You may want the exact same property but all readable, when the main type has a few read-only types. You may want to have all field optionals to allow partial object updates or you may want to seal an object by making all its properties read-only. You might even want to have all your properties to be a string because your form handle string values only, but later has the real interface or type with the good type. TypeScript allows creating dynamic type from an existing one. This transformation of the type is named <em>mapped type</em>. Mapped type allows reducing the burden of duplicating an object just to change a property on the type, while keeping the same structure of your definition.</p>
<p>TypeScript comes with many mapped types that you can use without having to build your own mapped type. Here are two common ones:</p>
<pre>type Readonly&lt;T&gt; = {<br/> readonly [P in keyof T]: T[P];<br/>}<br/><br/>type Partial&lt;T&gt; = {<br/> [P in keyof T]?: T[P];<br/>}</pre>
<p>The first one, <kbd>Readonly</kbd>, takes a generic type and loops all its members and adds <kbd>readonly</kbd>. It also returns the same type with <kbd>T[P]</kbd>. The second one, <kbd>Partial</kbd>, adds the <em>?</em> character after the name, which means that every field becomes optional:</p>
<pre class="mce-root">interface MyEntity {<br/> readonly id: number;<br/> name: string;<br/>}<br/><br/>const e1: MyEntity = { id: 1, name: "Name1" };</pre>
<p>If we want to have the variable to be sealed and completely not editable, we can use <kbd>Readonly</kbd>:</p>
<pre>const e1: MyEntity = { id: 1, name: "Name1" };<br/>const e2: Readonly&lt;MyEntity&gt; = e1;<br/>e1.name = "I can change";<br/>e2.name = "I cannot change"; // Does not compile</pre>
<p>If you want to allow someone to modify only a part of your entity and then merge the result, you can use <kbd>Partial</kbd>:</p>
<pre>function edit&lt;T&gt;(original: T, obj: Partial&lt;T&gt;): T {<br/> const returnObject: T = Object.assign({}, original, obj);<br/> return returnObject;<br/>}<br/><br/>edit(e1, { name: "Super" }); // The returned object is: {id: 1, name: "Super"}<br/>edit(e1, { memberNoExist: "Super" }); // Does not compile</pre>
<p>You can create your own mapped type by using the type keyword and creating a name with an <em>in</em> operator to loop the member and defining the transformation. It is important to notice that we do not manipulate the data, only the type. It means that if you are changing the type that you still need to manipulate the object to have the expected shape that will fulfil the mapped type. Here are two examples of the custom type. The first one returns a string for all members. The second removes the <kbd>Readonly</kbd>. You can see the minus sign before the property, which indicates to TypeScript that the modifier of the member is taken away:</p>
<pre>type Stringify&lt;T&gt; = { [P in keyof T]: string; };<br/>type UnReadonly&lt;T&gt; = { -readonly [P in keyof T]: T[P]; };</pre>
<p>Mapped type can be stacked to create a final type that combines all mapped types. In the following example, we stack two mapped types:</p>
<pre>const e3: UnReadonly&lt;Stringify&lt;MyEntity&gt;&gt; = e1;</pre>
<p>The code is legit but does not work. The reason is that TypeScript figures out that the <kbd>e1.id</kbd> is of type number and something tries to cast it into a string that does not occur automatically. As mentioned, a mapped type is only good as a cast and requires you to have the proper code.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here is a quick and small function that does the trick. Do not use this code in production, since it does not cover the transformation into a string property (especially with <kbd>object</kbd> and <kbd>array</kbd>), but it illustrates the required transformation:</p>
<pre>function castAllFieldToString&lt;T&gt;(obj: T): Stringify&lt;T&gt; {<br/> let returnValue: any = {};<br/> for (var property in obj) {<br/>   if (obj.hasOwnProperty(property)) {<br/>     returnValue[property] = obj[property].toString();<br/>   }<br/> }<br/> return returnValue as Stringify&lt;T&gt;;<br/>}<br/><br/>const e3: UnReadonly&lt;Stringify&lt;MyEntity&gt;&gt; = castAllFieldToString(e1);<br/>e3.id = "123";</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generic type in TSX File</h1>
                </header>
            
            <article>
                
<p>TSX is the equivalent of JSX, the JavaScript XML extension language. For a long period of time, TypeScript was supporting TSX but wasn't friendly with generic. The main reason is that TSX and the generic syntax share the angle brackets, which was causing the compiler to misinterpret the generic type when in a TSX file. However, the situation has changed, and TypeScript distinguishes when the square brackets are to explicitly define the type of a generic component. In the following snippet, you can see the <kbd>CallGenericComponent</kbd> that tries to render a generic component. The return is using an initial opening angle bracket to initialize the TSX component. The following and second opening angle bracket is to define the type:</p>
<pre>interface MyTsxProps&lt;T&gt; {<br/> item: T;<br/>}<br/><br/>class CallGenericComponent extends React.Component&lt;{}&gt;{<br/>  public render(): JSX.Element {<br/>    return &lt;MyTsxComponent&lt;string&gt; item={"123"} /&gt;<br/>  }<br/>}<br/><br/>class MyTsxComponent&lt;T&gt; extends React.Component&lt;MyTsxProps&lt;T&gt;&gt;{<br/>  // ...<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The use of the angle brackets allows to avoids defining the component as a variable and having to instantiate it, which was not only required multiple lines but also to cast with any. Furthermore, the readability was compromised and the intention was unclear to an external pair of eyes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw how to transform your code by using generic. TypeScript provides constraints to limit what can be passed into generic, and we saw how to leverage the constraint to guide the user as to what can be passed. We also saw how powerful the use of <kbd>keyof</kbd> is, allowing us to dynamically get members from a type. We saw how to manipulate type in a generic way, with mapped type.</p>


            </article>

            
        </section>
    </body></html>