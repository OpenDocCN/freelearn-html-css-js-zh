<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Communicating between Client and Server</h1></div></div></div><p>An important difference between Opa and most other web development languages is that other technologies typically require the use of multiple languages in order to write client-side and server-side code, <a id="id195" class="indexterm"/>whereas in Opa we can do both using a single language. This gives us the ability to invoke a remote procedure just like a local function. We do not need to send Ajax requests and parse response data ourselves. In this chapter, we will first talk about how to slice server and client code using Opa and what we can do to help the slicer when automatic slicing is not enough. Then, we will introduce three primitives for communication between clients and the server: session, cell, and network.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Client and server slicing</h1></div></div></div><p>Opa allows<a id="id196" class="indexterm"/> developers to write the server and client code both in the <a id="id197" class="indexterm"/>same language within the same module. And even better, the <a id="id198" class="indexterm"/>Opa slicer automates the calls between the client and the server. No more manually written Ajax calls or value serialization is needed!</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>A simple example</h2></div></div></div><p>Let's get started <a id="id199" class="indexterm"/>with a simple example. Suppose we want to send our name to the server and request the server to respond with the words "Say hello to [name] from server":</p><div><img src="img/3749OS_05_01.jpg" alt="A simple example"/></div><p>This is quite simple and can be accomplished with almost any language that we are familiar with. Typically, you would send an Ajax request to the server with name as request data, and the server will respond with a JSON object containing the string we want. The following code fragment demonstrates how we can do this using jQuery for the client-side code and ASP as server-side code:</p><div><pre class="programlisting">//code fragment on server side: ajax.aspx
Response.ContentType = "application/json";
Response.Write("{result: 'Say hello to " 
+ Request["Name"] + "from server.'}");

//request code fragment on client side
$.post( "ajax.aspx",             //request url
{Name:"Li"},                     //request data
function (data, textStatus){},   //call back
"json");                         //data type</pre></div><p>With Opa, things become even easier. We can skip the step of sending an Ajax request, and we also don't <a id="id200" class="indexterm"/>need to parse the JSON response data ourselves. We only need to write a normal function with a server tag and invoke the function from the client. Here is the complete code:</p><div><pre class="programlisting">server function sayhello(name){
  "Say hello to " + name + " from server."
}
function page(){
  &lt;input id=#name type="text"/&gt;
  &lt;input type="button" value="hello" onclick={function(_){
    #text = sayhello(Dom.get_value(#name))
  }}/&gt;
  &lt;h3 id=#text&gt;&lt;/h3&gt;
}
Server.start(Server.http,{title:"Opa Packt",~page})</pre></div><p>In the preceding code, we add a <code class="literal">server</code> tag before the <code class="literal">sayhello</code> function to indicate that it is a function on the server side, and we invoke this function on the client as a normal client-side function. If the <code class="literal">server</code> tag is removed, the <code class="literal">sayhello</code> function<a id="id201" class="indexterm"/> will be a client-side function in this example, and there will be no communication between the client and the server.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Slicing annotations</h2></div></div></div><p>The <code class="literal">server</code> tag tells the <a id="id202" class="indexterm"/>Opa complier to put the <code class="literal">sayhello</code> function <a id="id203" class="indexterm"/>on the server side. Opa is a language that can be executed both on a client and a server, but at some point during the compilation process, it must be decided on which side does the code actually end up, and whether there are any remote calls.</p><p>If the developer does not provide the slicing information by adding the slicing annotations (server, client, and both) before a function or a module, then Opa will perform the slicing <a id="id204" class="indexterm"/>job automatically. The rules for slicing that Opa follows by default are quite simple. Opa will implement the function on both the server as well as the client if possible. If it is not possible to implement the function both on the server and the client, then Opa will implement the function either on the server or on the client, depending on where it is possible to implement the function. For instance, if we remove the <code class="literal">server</code> tag from the <code class="literal">sayhello</code> function in the previous example, then Opa's slicer will implement the function twice, once on the server and once on the client. As a result, the invocation is no longer a remote call but a local call.</p><p>When automatic slicing is not enough, for example, if we want a function to only be available on the server side or client side, we can add slicing annotations before the function keyword to tell the slicer where a declaration should end up. There are three slicing annotations: <strong>server</strong>, <strong>client</strong> and <strong>both</strong>.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>server</strong>: Opa will <a id="id205" class="indexterm"/>implement the function on the server (but it does not mean that it will not be visible for the code running on the client)</li><li class="listitem" style="list-style-type: disc"><strong>client</strong>: Opa <a id="id206" class="indexterm"/>will implement the code on the client (but it does not mean that it will not be visible for the code running on the server)</li><li class="listitem" style="list-style-type: disc"><strong>both</strong>: The <a id="id207" class="indexterm"/>function is implemented both on the server as well as the client</li></ul></div><p>It is easy to understand what the <strong>server</strong> and <strong>client</strong> mean, but the <strong>both</strong> keyword is less intuitive. The problem is that a definition can have arbitrary side effects.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<strong>Side effect</strong>: In <a id="id208" class="indexterm"/>computer science, a function or expression is said to have a side effect if, in addition to returning a value, it also modifies some state or has an observable interaction with calling functions or the outside world.</p></div></div><p>Therefore, there are two possible meanings: either the side effect is executed on both sides or the side <a id="id209" class="indexterm"/>effect is executed once on the server and the resulting value is shared between the two sides. By default, the slicer duplicates some side effects such as printing and avoids duplicating the allocation of mutable structures.</p><p>Consider the following example:</p><div><pre class="programlisting">println("Hello Opa!")
counter = Mutable.make(0)
function page(){ &lt;h1&gt;...&lt;/h1&gt; }
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div><p>If we compile and run the preceding code, it will print "Hello Opa!" on the server and the client both, but will create only one unique mutable variable called <code class="literal">counter</code> that is shared between the client and the server.</p><p>But, we sometimes do want to duplicate the declaration on both sides. In that case, we can use the<a id="id210" class="indexterm"/> <code class="literal">@both_implem</code> directive. For example:</p><div><pre class="programlisting">@both_implem counter = Mutable.make(100)</pre></div><p>This will create a mutable variable <code class="literal">counter</code> at the startup of the server and in each client.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Module slicing</h2></div></div></div><p>When a <a id="id211" class="indexterm"/>slicing annotation refers to a module, it becomes the <a id="id212" class="indexterm"/>default slicing annotation for its components, but can be overridden by annotating the component with another annotation. Consider the following example:</p><div><pre class="programlisting">server module Logic{
  function f1() { println("function 1") }
  client function f2(){ println("function 2") }
}
function page(){
  &lt;div onready={function(_){ Logic.f1(); Logic.f2() }}&gt;&lt;/div&gt;
}
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div><p>Because we put<a id="id213" class="indexterm"/> <code class="literal">server</code> before the <code class="literal">Logic</code> module, function <code class="literal">f1</code> will end up on the server side. But we override the<a id="id214" class="indexterm"/> slicing annotation of function <code class="literal">f2</code> with <code class="literal">client</code>, so function <code class="literal">f2</code> will be on the client side. We invoke both <code class="literal">f1</code> and <code class="literal">f2</code> when the page is ready, <code class="literal">f1</code> will print <strong>function1</strong> on the server side while <code class="literal">f2</code> will print <strong>function2</strong> on the client side. The following screenshot shows the result as expected:</p><div><img src="img/3749OS_05_02.jpg" alt="Module slicing"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Expression slicing</h2></div></div></div><p>Sometimes,<a id="id215" class="indexterm"/> we want to have a different behavior on<a id="id216" class="indexterm"/> the server and on the client. We can use the <code class="literal">@sliced_expr</code> directive to do this. Consider the following example:</p><div><pre class="programlisting">side = @sliced_expr({server: "server", client:"client"}) 
println(side) //will print "server" on server side and "client"
             // on client side.
function page(){ &lt;h1&gt;Test Page&lt;/h1&gt; }
Server.start(Server.http, {title:"Opa Packt", ~page});</pre></div><p>The preceding code will print "server" on the server side and "client" on the client side.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Client and server communication</h1></div></div></div><p>Opa provides<a id="id217" class="indexterm"/> three primitives for communicating between clients and the server: session, cell, and network. We can use these three primitives to exchange messages between clients and servers.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Session</h2></div></div></div><p>A session<a id="id218" class="indexterm"/> is a one-way asynchronous communication <a id="id219" class="indexterm"/>between the client and the server. A session can be created on a server or on a client, and can be shared between several servers.</p><p>To create a <a id="id220" class="indexterm"/>session, use either <code class="literal">Session.make</code> or <code class="literal">Session.NonBlocking.make</code>. The <code class="literal">Session.make</code> function<a id="id221" class="indexterm"/> creates a session that handles all messages in the background, but only one message at a time. This ensures absolute consistency on the state of the session, but may not be appropriate for all applications.</p><p>In contrast, the <code class="literal">Session.NonBlocking.make</code> function <a id="id222" class="indexterm"/>creates a session that can handle any number <a id="id223" class="indexterm"/>of messages simultaneously. This ensures maximal responsiveness, but the message handler cannot be certain that it is holding the latest value of the state. Let's have a look at how <code class="literal">Session.make</code> is declared:</p><div><pre class="programlisting">channel(`message) make(`state state, 
(`state, `message -&gt; Session.instruction(`state) on_message)</pre></div><p>The first parameter <code class="literal">state</code> is the initial state of the session. The second parameter is a message handler for this session. The message handler will be invoked when messages are sent to this session. The return value of this function is a channel, which we can use to send messages to the session by using the <a id="id224" class="indexterm"/>
<code class="literal">Session.send</code> function.</p><p>Consider the following example: suppose we want to send a string to the server through a session such that if the state of this session is an odd number, then whatever we send to the server is printed in uppercase. In contrast, if the state of this session is even then we print in lowercase. The code is as follows:</p><div><pre class="programlisting">channel(string) s = Session.make(0,function(state,msg){
  if(mod(state,2) == 0) println(String.to_upper(msg)) 
  else                  println(String.to_lower(msg))
  {set:state+1}         //update the state of this session
})
function page(){
  &lt;input type="text" id=#text/&gt;
  &lt;input type="button" value="send" onclick={function(_){
         Session.send(s, Dom.get_value(#text))
  }}/&gt;
}
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div><p>If we compile and run the preceding code, then we will see the following result on the server:</p><div><img src="img/3749OS_05_03.jpg" alt="Session"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Cell</h2></div></div></div><p>A cell is <a id="id225" class="indexterm"/>a session<a id="id226" class="indexterm"/> in which sending messages produces return values. It's a two-way synchronous communication between the client and the server. We can create a cell with <code class="literal">Cell.make</code>
<a id="id227" class="indexterm"/> and call it with <code class="literal">Cell.call</code><a id="id228" class="indexterm"/>. In the following example, the cell does almost the same thing as we had described in the previous example, but it returns the string to the client instead of printing it on the server. Here is the code fragment:</p><div><pre class="programlisting">s = Cell.make(0,function(state,msg){
   text =  if(mod(state,2) == 0)   String.to_upper(msg) 
           else                    String.to_lower(msg)
    {return: text, instruction: {set: state+1}}
});
function page(){
    &lt;input type="text" id=#text/&gt;
    &lt;input type="button" value="send" onclick={function(_){
         #result = Cell.call(s, Dom.get_value(#text))
    }}/&gt;
    &lt;h2 id=#result&gt;&lt;/h2&gt;
}
Server.start(Server.http, {title:"Opa Packt", ~page})</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Network</h2></div></div></div><p>A network is <a id="id229" class="indexterm"/>an infrastructure <a id="id230" class="indexterm"/>for broadcasting information to observers. Observers may be sessions or functions located on the same machine or on any client or server.</p><p>We can create a network with the <code class="literal">Network.empty()</code> function<a id="id231" class="indexterm"/> or construct a network that is automatically shared between servers with the <code class="literal">Network.cloud(key)</code> function.</p><p>We can observe a network with the <code class="literal">Network.observe(cb,network)</code> function<a id="id232" class="indexterm"/>, where <code class="literal">cb</code> is a callback function that is executed when a message is received on the network. To send a message to all observers of a network, use <code class="literal">Network.broadcast(msg,network)</code>.<a id="id233" class="indexterm"/>
</p><p>The following example is a very simple chat application; the client will observe the network when its page is ready, and it will broadcast a message when the send button is triggered. We will learn to build a more sophisticated web chat application in <a class="link" href="ch09.html" title="Chapter 9. Building a Chat Application">Chapter 9</a>, <em>Building a Chat Application</em>.</p><div><pre class="programlisting">Network.network(string) n = Network.empty();
function ready(_){
    _ = Network.observe(function(msg){ println("{msg}") },n)
    void
}
function page(){
    &lt;div onready={ready}&gt;
        &lt;input type="text" id=#text/&gt;
        &lt;input type="button" value="send" onclick={function(_){
            Network.broadcast(Dom.get_value(#text),n)
        }}/&gt;
    &lt;/div&gt;
}
Server.start(Server.http,{title:"Opa Packt", ~page})</pre></div><p>Compile and <a id="id234" class="indexterm"/>run the preceding code, then open the <a id="id235" class="indexterm"/>web application in several browsers. We can communicate between browsers by sending the messages that we input. Here is a screenshot:</p><div><img src="img/3749OS_05_04.jpg" alt="Network"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we first talked about the Opa slicer. If we do not provide slicing information, the slicer will try to put the code on both sides whenever it is possible and will put the code on only one side when there is no way to put the code on both sides. When this automatic slicing is not enough, we can add slicing annotations (server, client, and both) before functions and modules to tell the slicer on which side we want our code to end. Then, we talked about the three primitives for communicating between clients and servers. Session is a one-way asynchronous communication, cell is a two-way synchronous communication, and network is for broadcasting messages to any number of observers.</p></div></body></html>