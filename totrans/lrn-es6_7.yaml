- en: Chapter 7. Walking You Through Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 introduced classes that provide a much simpler and clearer syntax to creating
    constructors and dealing with inheritance. JavaScript never had the concept of
    classes, although it''s an object-oriented programming language. Programmers from
    the other programming language background often found it difficult to understand
    JavaScript''s object-oriented model and inheritance due to lack of classes. In
    this chapter, we will learn about the object-oriented JavaScript using the ES6
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects the classical way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructors of the primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are classes in ES6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects using classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inheritance in classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Object-oriented JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with the ES6 classes, let's refresh our knowledge on the JavaScript
    data types, constructors, and inheritance. While learning classes, we will be
    comparing the syntax of the constructors and prototype-based inheritance with
    the syntax of the classes. Therefore, it is important to have a good grip on these
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript variables hold (or store) data (or value). The type of data
    variables that they hold is called as the **data type**. In JavaScript, there
    are seven different data types: **number**, **string**, **Boolean**, **null**,
    **undefined**, **symbol**, and **object**.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to holding objects, variables hold the object reference (that
    is, the memory address) instead of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: All the other data types other than object are called as **primitive data types**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arrays and functions are actually the JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of creating an object in JavaScript, that is, using the object
    literal, or using a constructor. The object literal is used when we want to create
    fixed objects, whereas constructor is used when we want to create the objects
    dynamically on runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a case where we may need to use the constructors instead of
    the object literal. Here is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a `student` object using the object literal, that is, the `{}`
    notation. This works well when you just want to create a single `student` object.
  prefs: []
  type: TYPE_NORMAL
- en: But the problem arises when you want to create multiple `student` objects. Obviously,
    you don't want to write the previous code multiple times to create multiple `student`
    objects. This is where constructors come into use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function acts like a constructor when invoked using the `new` keyword. A
    constructor creates and returns an object. The `this` keyword, inside a function,
    when invoked as a constructor, points to the new object instance, and once the
    constructor execution is finished, the new object is automatically returned. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, to create multiple student objects, we invoked the constructor multiple
    times instead of creating multiple student objects using the object literals.
  prefs: []
  type: TYPE_NORMAL
- en: To add methods to the instances of the constructor, we didn't use the `this`
    keyword, instead we used the `prototype` property of constructor. We will learn
    more on why we did it this way, and what the `prototype` property is, in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, every object must belong to a constructor. Every object has an inherited
    property named `constructor`, pointing to the object''s constructor. When we create
    objects using the object literal, the `constructor` property points to the global
    `Object` constructor. Consider this example to understand this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Understanding inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each JavaScript object has an internal `[[prototype]]` property pointing to
    another object called as its prototype. This prototype object has a prototype
    of its own, and so on until an object is reached with `null` as its prototype.
    `null` has no prototype, and it acts as a final link in the prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: When trying to access a property of an object, and if the property is not found
    in the object, then the property is searched in the object's prototype. If still
    not found, then it's searched in the prototype of the prototype object. It keeps
    on going until `null` is encountered in the prototype chain. This is how inheritance
    works in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: As a JavaScript object can have only one prototype, JavaScript supports only
    a single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating objects using the object literal, we can use the special `__proto__`
    property or the `Object.setPrototypeOf()` method to assign a prototype of an object.
    JavaScript also provides an `Object.create()` method, with which we can create
    a new object with a specified prototype as the `__proto__` lacked browser support,
    and the `Object.setPrototypeOf()` method seemed a little odd. Here is code example
    that demonstrates different ways to set the prototype of an object while creating,
    using the object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `{age:24}` object is referred as **base object**, **superobject**,
    or **parent object** as its being inherited. And the `{name:"Eden"}` object is
    referred as the **derived object**, **subobject**, or the **child object**, as
    it inherits another object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t assign a prototype to an object while creating it using the object
    literal, then the prototype points to the `Object.prototype` property. The prototype
    of `Object.prototype` is `null` therefore, leading to the end of the prototype
    chain. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While creating objects using a constructor, the prototype of the new objects
    always points to a property named `prototype` of the function object. By default,
    the `prototype` property is an object with one property named as `constructor`.
    The `constructor` property points to the function itself. Consider this example
    to understand this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To add new methods to the instances of a constructor, we should add them to
    the `prototype` property of the constructor, as we did earlier. We shouldn''t
    add methods using the `this` keyword in a constructor body, because every instance
    of the constructor will have a copy of the methods, and this isn''t very memory
    efficient. By attaching methods to the `prototype` property of a constructor,
    there is only one copy of each function that all the instances share. To understand
    this, consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` and `s2` share the same `printName` function that reduces the use
    of memory, whereas `s3` and `s4` contain two different functions with the name
    as `printName` that makes the program use more memory. This is unnecessary, as
    both the functions do the same thing. Therefore, we add methods for the instances
    to the `prototype` property of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the inheritance hierarchy in the constructors is not as straightforward
    as we did for object literals. Because the child constructor needs to invoke the
    parent constructor for the parent constructor's initialization logic to take place
    and we need to add the methods of the `prototype` property of the parent constructor
    to the `prototype` property of the child constructor, so that we can use them
    with the objects of child constructor. There is no predefined way to do all this.
    The developers and JavaScript libraries have their own ways of doing this. I will
    show you the most common way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to implement the inheritance while creating
    the objects using the constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we invoked the parent constructor using the `call` method of the function
    object. To inherit the methods, we created an instance of the parent constructor,
    and assigned it to the child constructor's `prototype` property.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a foolproof way of implementing inheritance in the constructors,
    as there are lots of potential problems. For example—in case the parent constructor
    does something else other than just initializing properties, such as DOM manipulation,
    then while assigning a new instance of the parent constructor, to the `prototype`
    property, of the child constructor, can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the ES6 classes provide a better and easier way to inherit the existing
    constructors and classes. We will see more on this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The constructors of primitive data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primitive data, types such as boolean, string, and number, have their constructor
    counterparts. These counterpart constructors behave like wrappers for these primitive
    types. For example, the `String` constructor is used to create a string object
    that contains an internal `[[PrimitiveValue]]` property that holds the actual
    primitive value.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, wherever necessary, the primitive values are wrapped with their
    constructor counterparts, and also the counterpart objects are treated as primitive
    values, so that the code works as expected. Consider this example code to understand
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s1` is a primitive type, and `s2` is an object although applying the
    `==` operator on them gives us a `true` result. `s1` is a primitive type but still
    we are able to access the length property however primitive types shouldn't have
    any properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this is happening because the previous code was converted into this on
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how the primitive value was wrapped with its constructor counterpart,
    and how the object counterpart was treated as primitive value when necessary.
    Therefore, the code works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The primitive types introduced from ES6 onwards won't allow their counterpart
    functions to be invoked as constructors, that is, we can't explicitly wrap them
    using their object counterparts. We saw this behavior while learning symbols.
  prefs: []
  type: TYPE_NORMAL
- en: The `null` and `undefined` primitive types don't have any counterpart constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that JavaScript's object-oriented model is based on the constructors
    and prototype-based inheritance. Well, the ES6 classes are just new a syntax for
    the existing model. Classes do not introduce a new object-oriented model to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The ES6 classes aim to provide a much simpler and clearer syntax for dealing
    with the constructors and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, classes are functions. Classes are just a new syntax for creating functions
    that are used as constructors. Creating functions using the classes that aren't
    used as constructors doesn't make any sense, and offer no benefits. Rather, it
    makes your code difficult to read, as it becomes confusing. Therefore, use classes
    only if you want to use it for constructing objects. Let's have a look at classes
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as there are two ways of defining functions, function declaration and
    function expression, there are two ways to define a class: using the class declaration
    and the class expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The class declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For defining a class using the class declaration, you need to use the `class`
    keyword, and a name for the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to define a class using the class
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a class named `Student`. Then, we defined a `constructor` method
    in it. Finally, we created a new instance of the class—an object, and logged the
    `name` property of the object.
  prefs: []
  type: TYPE_NORMAL
- en: The body of a class is in the curly brackets, that is, `{}`. This is where we
    need to define methods. Methods are defined without the `function` keyword, and
    a comma is not used in between the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are treated as functions, and internally the class name is treated as
    the function name, and the body of the `constructor` method is treated as the
    body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one `constructor` method in a class. Defining more than one
    constructor will throw the `SyntaxError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: All the code inside a class body is executed in the `strict` mode, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To prove that a class is a function, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that a class is a function. It's just a new syntax for creating
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: The class expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class expression has a similar syntax to a class declaration. However, with
    class expressions, you are able to omit the class name. Class body and behavior
    remains the same in both the ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to define a class using a class expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we stored a reference of the class in a variable, and used it to construct
    the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The prototype methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the methods in the body of the class are added to the `prototype` property
    of the class. The `prototype` property is the prototype of the objects created
    using class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to add methods to the `prototype` property
    of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `printProfile` method was added to the `prototype`
    property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The get and set methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ES5, to add accessor properties to the objects, we had to use the `Object.defineProperty()`
    method. ES6 introduced the `get` and `set` prefixes for methods. These methods
    can be added to the object literals and classes for defining the `get` and `set`
    attributes of the accessor properties.
  prefs: []
  type: TYPE_NORMAL
- en: When `get` and `set` methods are used in a class body, they are added to the
    `prototype` property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define the `get` and `set` methods
    in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created an accessor property to encapsulate the `_name_` property.
    We also logged some other information to prove that `name` is an accessor property,
    which is added to the `prototype` property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The generator method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To treat a concise method of an object literal as the generator method, or to
    treat a method of a class as the generator method, we can simply prefix it with
    the `*` character.
  prefs: []
  type: TYPE_NORMAL
- en: The generator method of a class is added to the `prototype` property of the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define a generator method in class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The static methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The methods that are added to the body of the class with the `static` prefix
    are called as static methods. Static methods are the own methods of the class,
    that is, they are not added to the `prototype` property of the class, rather they
    are added to the class itself. For example, the `String.fromCharCode()` method
    is a static method of the `String` constructor, that is, `fromCharCode` is the
    own property of the `String` function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are often used to create utility functions for an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to define and use a static method in
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, `findName` is a static method of the `Student` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is the same as this code when written using function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implementing inheritance in classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw how difficult it was to implement inheritance
    hierarchy in functions. Therefore, ES6 aims to make it easy by introducing the
    `extends` clause, and the `super` keyword for classes.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `extends` clause, a class can inherit static and non-static properties
    of another constructor (which may or may not be defined using a class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `super` keyword is used in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It's used in a class `constructor` method to call the parent constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used inside methods of a class, it references the static and non-static
    methods of the parent constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to implement the inheritance hierarchy
    in the constructors using the `extends` clause, and the `super` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, `A` is a function constructor; `B` is a class that inherits `A`; `C` is
    a class that inherits `B;` and as `B` inherits `A,` therefore `C` also inherits
    `A`.
  prefs: []
  type: TYPE_NORMAL
- en: As a class can inherit a function constructor, we can also inherit the prebuilt
    function constructors, such as `String` and `Array`, and also the custom function
    constructors using the classes instead of other *hacky* ways that we used to use.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example also shows how and where to use the `super` keyword. Remember
    that inside the `constructor` method, you need to use `super` before using the
    `this` keyword. Otherwise, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a child class doesn't have a `constructor` method, then the default behavior
    will invoke the `constructor` method of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: The computed method names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also decide the name of the static and non-static methods of a class
    and concise methods of a object literal on runtime, that is, you can define the
    name of methods via expressions. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The computed property names also allow you to use symbols as keys for the methods.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The attributes of properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using class, the attributes of the static and non-static properties of
    constructor are different than when declared using function:'
  prefs: []
  type: TYPE_NORMAL
- en: The static methods are writable and configurable, but not enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prototype` property and the `prototype.constructor` property of class is
    not writable, numerable, or configurable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties of the `prototype` property are writable and configurable, but
    not enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are not hoisted!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can call a function before its defined, that is, function calls can be made
    above the function definition. But in case of class, you cannot use a class before
    its defined. Trying to do so in classes will throw the `ReferenceError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the result of the constructor method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `constructor` method, by default, returns the new instance if there is no
    `return` statement in it. If there is a `return` statement, then whatever is the
    value in the `return` statement is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The "Symbol.species" static accessor property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@@species` static accessor property is optionally added to a child constructor,
    in order to signal the methods of the parent constructor, about what the constructor
    should use if the parent constructor's methods are returning new instances. If
    the `@@species` static accessor property is not defined on a child constructor,
    then the methods of the parent constructor can use the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this example to understand the use of `@@species`—the `map()` method
    of the array objects returns a new `Array` instance. If we call the `map()` method
    of an object that inherits an array object, then the `map()` method returns a
    new instance of the child constructor instead of the `Array` constructor, which
    is not what we always want. Therefore, ES6 introduced the `@@species` property,
    which provides a way to signal such kind of functions, to use a different constructor
    instead of the default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to demonstrate how to use the `@@species` static accessor
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended that if you are creating a JavaScript library, then the methods
    of the constructors in your library should always look for the `@@species` property
    while returning new instances. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In case you don't want to define a default `@@species` property in parent constructors,
    then you can use the `if…else` conditional to check whether the `@@species` property
    is defined or not. But the previous pattern is preferred. The built-in `map()`
    method also uses the previous pattern.
  prefs: []
  type: TYPE_NORMAL
- en: All the built-in methods of the JavaScript constructors in ES6 look for a `@@species`
    property if they return a new instance. For example, the methods of `Array`, `Map`,
    `ArrayBuffer`, `Promise`, and other such constructors look for the `@@species`
    property if they return new instances.
  prefs: []
  type: TYPE_NORMAL
- en: The "new.target" implicit parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 adds a parameter named `new.target` to all the functions. The dot in between
    is a part of the parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of `new.target` is `undefined`. But when a function is invoked
    as a constructor, the value of the `new.target` parameter depends on the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If a constructor is invoked using a `new` operator, then `new.target` points
    to this constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a constructor is invoked via `super` keyword, then the value of `new.target`
    in it is the same as the value of `new.target` of the constructor that is called
    `super`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside an arrow function, the value of `new.target` is the same as the value
    of `new.target` of the surrounding non-arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using "super" in the object literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `super` keyword can also be used in the concise methods of the object literals.
    The `super` keyword in concise methods of the object literals, has the same value
    as the `[[prototype]]` property of the object defined by the object literal.
  prefs: []
  type: TYPE_NORMAL
- en: In the object literals, `super` is used to access the over-ridden properties
    by the child object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to use `super` in object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first learned the basics of the object-oriented programming
    using ES5\. Then, we jumped into ES6 classes, and learned how it makes easy for
    us to read and write the object-oriented JavaScript code. We also learned miscellaneous
    features, such as the `new.target` and accessor methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create and use the ES6 modules.
  prefs: []
  type: TYPE_NORMAL
