- en: Chapter 7. Walking You Through Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ES6 introduced classes that provide a much simpler and clearer syntax to creating
    constructors and dealing with inheritance. JavaScript never had the concept of
    classes, although it''s an object-oriented programming language. Programmers from
    the other programming language background often found it difficult to understand
    JavaScript''s object-oriented model and inheritance due to lack of classes. In
    this chapter, we will learn about the object-oriented JavaScript using the ES6
    classes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript data types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects the classical way
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructors of the primitive types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are classes in ES6
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects using classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inheritance in classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Object-oriented JavaScript
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed with the ES6 classes, let's refresh our knowledge on the JavaScript
    data types, constructors, and inheritance. While learning classes, we will be
    comparing the syntax of the constructors and prototype-based inheritance with
    the syntax of the classes. Therefore, it is important to have a good grip on these
    topics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript data types
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript variables hold (or store) data (or value). The type of data
    variables that they hold is called as the **data type**. In JavaScript, there
    are seven different data types: **number**, **string**, **Boolean**, **null**,
    **undefined**, **symbol**, and **object**.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to holding objects, variables hold the object reference (that
    is, the memory address) instead of the object itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: All the other data types other than object are called as **primitive data types**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The arrays and functions are actually the JavaScript objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways of creating an object in JavaScript, that is, using the object
    literal, or using a constructor. The object literal is used when we want to create
    fixed objects, whereas constructor is used when we want to create the objects
    dynamically on runtime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a case where we may need to use the constructors instead of
    the object literal. Here is a code example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we created a `student` object using the object literal, that is, the `{}`
    notation. This works well when you just want to create a single `student` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: But the problem arises when you want to create multiple `student` objects. Obviously,
    you don't want to write the previous code multiple times to create multiple `student`
    objects. This is where constructors come into use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'A function acts like a constructor when invoked using the `new` keyword. A
    constructor creates and returns an object. The `this` keyword, inside a function,
    when invoked as a constructor, points to the new object instance, and once the
    constructor execution is finished, the new object is automatically returned. Consider
    this example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, to create multiple student objects, we invoked the constructor multiple
    times instead of creating multiple student objects using the object literals.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: To add methods to the instances of the constructor, we didn't use the `this`
    keyword, instead we used the `prototype` property of constructor. We will learn
    more on why we did it this way, and what the `prototype` property is, in the next
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要向构造函数的实例添加方法，我们没有使用`this`关键字，而是使用了构造函数的`prototype`属性。我们将在下一节中了解更多关于为什么这样做以及`prototype`属性是什么。
- en: 'Actually, every object must belong to a constructor. Every object has an inherited
    property named `constructor`, pointing to the object''s constructor. When we create
    objects using the object literal, the `constructor` property points to the global
    `Object` constructor. Consider this example to understand this behavior:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个对象都必须属于一个构造函数。每个对象都有一个名为`constructor`的继承属性，指向该对象的构造函数。当我们使用对象字面量创建对象时，`constructor`属性指向全局的`Object`构造函数。考虑以下示例来理解这种行为：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding inheritance
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解继承
- en: Each JavaScript object has an internal `[[prototype]]` property pointing to
    another object called as its prototype. This prototype object has a prototype
    of its own, and so on until an object is reached with `null` as its prototype.
    `null` has no prototype, and it acts as a final link in the prototype chain.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JavaScript对象都有一个内部名为`[[prototype]]`的属性，它指向另一个称为其原型的对象。这个原型对象有自己的原型，以此类推，直到找到一个其原型为`null`的对象。`null`没有原型，它作为原型链中的最后一个链接。
- en: When trying to access a property of an object, and if the property is not found
    in the object, then the property is searched in the object's prototype. If still
    not found, then it's searched in the prototype of the prototype object. It keeps
    on going until `null` is encountered in the prototype chain. This is how inheritance
    works in JavaScript.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问一个对象的属性时，如果该属性在对象中找不到，那么该属性将在对象的原型中搜索。如果仍然找不到，那么将在原型对象的原型中搜索。这个过程会一直持续到原型链中遇到`null`。这就是JavaScript中继承的工作方式。
- en: As a JavaScript object can have only one prototype, JavaScript supports only
    a single inheritance.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript对象只能有一个原型，JavaScript只支持单继承。
- en: 'While creating objects using the object literal, we can use the special `__proto__`
    property or the `Object.setPrototypeOf()` method to assign a prototype of an object.
    JavaScript also provides an `Object.create()` method, with which we can create
    a new object with a specified prototype as the `__proto__` lacked browser support,
    and the `Object.setPrototypeOf()` method seemed a little odd. Here is code example
    that demonstrates different ways to set the prototype of an object while creating,
    using the object literal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用对象字面量创建对象时，我们可以使用特殊的`__proto__`属性或`Object.setPrototypeOf()`方法来指定对象的原型。JavaScript还提供了一个`Object.create()`方法，我们可以用它来创建一个新的对象，其`__proto__`被指定为原型。由于浏览器不支持`__proto__`，而`Object.setPrototypeOf()`方法看起来有些奇怪。以下是一个代码示例，展示了在创建对象时使用对象字面量设置对象原型的不同方法：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `{age:24}` object is referred as **base object**, **superobject**,
    or **parent object** as its being inherited. And the `{name:"Eden"}` object is
    referred as the **derived object**, **subobject**, or the **child object**, as
    it inherits another object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{age:24}`对象被称为**基对象**、**超对象**或**父对象**，因为它正在继承。而`{name:"Eden"}`对象被称为**派生对象**、**子对象**或**子对象**，因为它继承了另一个对象。
- en: 'If you don''t assign a prototype to an object while creating it using the object
    literal, then the prototype points to the `Object.prototype` property. The prototype
    of `Object.prototype` is `null` therefore, leading to the end of the prototype
    chain. Here is an example to demonstrate this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用对象字面量创建对象时没有为其指定原型，那么原型将指向`Object.prototype`属性。由于`Object.prototype`的原型是`null`，因此导致原型链的结束。以下是一个示例来演示这一点：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While creating objects using a constructor, the prototype of the new objects
    always points to a property named `prototype` of the function object. By default,
    the `prototype` property is an object with one property named as `constructor`.
    The `constructor` property points to the function itself. Consider this example
    to understand this model:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用构造函数创建对象时，新对象的原型始终指向函数对象的`prototype`属性。默认情况下，`prototype`属性是一个具有一个名为`constructor`的属性的对象。`constructor`属性指向函数本身。考虑以下示例来理解这个模型：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To add new methods to the instances of a constructor, we should add them to
    the `prototype` property of the constructor, as we did earlier. We shouldn''t
    add methods using the `this` keyword in a constructor body, because every instance
    of the constructor will have a copy of the methods, and this isn''t very memory
    efficient. By attaching methods to the `prototype` property of a constructor,
    there is only one copy of each function that all the instances share. To understand
    this, consider this example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要向构造函数的实例添加新方法，我们应该将它们添加到构造函数的 `prototype` 属性中，就像我们之前做的那样。我们不应该在构造函数体中使用 `this`
    关键字来添加方法，因为构造函数的每个实例都将有一个方法副本，这并不非常内存高效。通过将方法附加到构造函数的 `prototype` 属性，每个函数只有一个副本，所有实例共享。为了理解这一点，考虑以下示例：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `s1` and `s2` share the same `printName` function that reduces the use
    of memory, whereas `s3` and `s4` contain two different functions with the name
    as `printName` that makes the program use more memory. This is unnecessary, as
    both the functions do the same thing. Therefore, we add methods for the instances
    to the `prototype` property of the constructor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1` 和 `s2` 共享相同的 `printName` 函数，这减少了内存的使用，而 `s3` 和 `s4` 包含两个不同的名为 `printName`
    的函数，这使程序使用更多的内存。这是不必要的，因为这两个函数执行相同的事情。因此，我们将实例的方法添加到构造函数的 `prototype` 属性中。
- en: Implementing the inheritance hierarchy in the constructors is not as straightforward
    as we did for object literals. Because the child constructor needs to invoke the
    parent constructor for the parent constructor's initialization logic to take place
    and we need to add the methods of the `prototype` property of the parent constructor
    to the `prototype` property of the child constructor, so that we can use them
    with the objects of child constructor. There is no predefined way to do all this.
    The developers and JavaScript libraries have their own ways of doing this. I will
    show you the most common way of doing it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中实现继承层次结构并不像我们对对象字面量所做的那样直接。因为子构造函数需要调用父构造函数以执行父构造函数的初始化逻辑，并且我们需要将父构造函数的
    `prototype` 属性的方法添加到子构造函数的 `prototype` 属性中，以便我们可以使用它们与子构造函数的对象一起使用。没有预定义的方式来完成所有这些。开发人员和
    JavaScript 库有自己的实现方式。我将向您展示最常见的方法。
- en: 'Here is an example to demonstrate how to implement the inheritance while creating
    the objects using the constructors:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，演示如何在创建对象时使用构造函数实现继承：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we invoked the parent constructor using the `call` method of the function
    object. To inherit the methods, we created an instance of the parent constructor,
    and assigned it to the child constructor's `prototype` property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数对象的 `call` 方法调用了父构造函数。为了继承方法，我们创建了一个父构造函数的实例，并将其分配给子构造函数的 `prototype`
    属性。
- en: This is not a foolproof way of implementing inheritance in the constructors,
    as there are lots of potential problems. For example—in case the parent constructor
    does something else other than just initializing properties, such as DOM manipulation,
    then while assigning a new instance of the parent constructor, to the `prototype`
    property, of the child constructor, can cause problems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是在构造函数中实现继承的万无一失的方法，因为存在许多潜在问题。例如——如果父构造函数执行的操作不仅仅是初始化属性，例如 DOM 操作，那么将父构造函数的新实例分配给子构造函数的
    `prototype` 属性可能会引起问题。
- en: Therefore, the ES6 classes provide a better and easier way to inherit the existing
    constructors and classes. We will see more on this later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ES6 类提供了更好的、更简单的方式来继承现有的构造函数和类。我们将在本章后面进一步了解这一点。
- en: The constructors of primitive data types
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始数据类型的构造函数
- en: The primitive data, types such as boolean, string, and number, have their constructor
    counterparts. These counterpart constructors behave like wrappers for these primitive
    types. For example, the `String` constructor is used to create a string object
    that contains an internal `[[PrimitiveValue]]` property that holds the actual
    primitive value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型，如布尔值、字符串和数字，都有它们的构造函数对应物。这些对应构造函数的行为类似于这些原始类型的包装器。例如，`String` 构造函数用于创建包含内部
    `[[PrimitiveValue]]` 属性的字符串对象，该属性持有实际的原始值。
- en: 'At runtime, wherever necessary, the primitive values are wrapped with their
    constructor counterparts, and also the counterpart objects are treated as primitive
    values, so that the code works as expected. Consider this example code to understand
    how it works:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，在必要时，原始值会被它们的构造函数对应物包装，同时对应对象也会被当作原始值处理，这样代码才能按预期工作。考虑以下示例代码来理解它是如何工作的：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `s1` is a primitive type, and `s2` is an object although applying the
    `==` operator on them gives us a `true` result. `s1` is a primitive type but still
    we are able to access the length property however primitive types shouldn't have
    any properties.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s1`是一个原始类型，而`s2`是一个对象，尽管对它们应用`==`运算符会得到`true`的结果。`s1`是一个原始类型，但我们仍然能够访问长度属性，然而原始类型不应该有任何属性。
- en: 'All this is happening because the previous code was converted into this on
    runtime:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是在运行时将之前的代码转换成以下形式发生的：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we can see how the primitive value was wrapped with its constructor counterpart,
    and how the object counterpart was treated as primitive value when necessary.
    Therefore, the code works as expected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到原始值是如何被其构造函数对应物包装的，以及当需要时对象对应物是如何被当作原始值处理的。因此，代码按预期工作。
- en: The primitive types introduced from ES6 onwards won't allow their counterpart
    functions to be invoked as constructors, that is, we can't explicitly wrap them
    using their object counterparts. We saw this behavior while learning symbols.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始引入的原始类型不会允许它们的对应函数作为构造函数被调用，也就是说，我们不能显式地使用它们的对象对应物来包装它们。我们在学习符号时看到了这种行为。
- en: The `null` and `undefined` primitive types don't have any counterpart constructors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型`null`和`undefined`没有对应的构造函数。
- en: Using classes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类
- en: We saw that JavaScript's object-oriented model is based on the constructors
    and prototype-based inheritance. Well, the ES6 classes are just new a syntax for
    the existing model. Classes do not introduce a new object-oriented model to JavaScript.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到JavaScript的面向对象模型基于构造函数和基于原型的继承。嗯，ES6类只是现有模型的新语法。类并没有为JavaScript引入新的面向对象模型。
- en: The ES6 classes aim to provide a much simpler and clearer syntax for dealing
    with the constructors and inheritance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ES6类的目的是为了提供一个更简单、更清晰的语法来处理构造函数和继承。
- en: In fact, classes are functions. Classes are just a new syntax for creating functions
    that are used as constructors. Creating functions using the classes that aren't
    used as constructors doesn't make any sense, and offer no benefits. Rather, it
    makes your code difficult to read, as it becomes confusing. Therefore, use classes
    only if you want to use it for constructing objects. Let's have a look at classes
    in detail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，类是函数。类只是创建用作构造函数的函数的新语法。使用类创建不作为构造函数使用的函数没有任何意义，也不会带来任何好处。相反，它会使得你的代码难以阅读，因为它变得混乱。因此，只有当你想用它来构造对象时才使用类。让我们详细看看类。
- en: Defining a class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Just as there are two ways of defining functions, function declaration and
    function expression, there are two ways to define a class: using the class declaration
    and the class expression.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如定义函数有两种方式，函数声明和函数表达式，定义类也有两种方式：使用类声明和类表达式。
- en: The class declaration
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类声明
- en: For defining a class using the class declaration, you need to use the `class`
    keyword, and a name for the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用类声明来定义一个类，你需要使用`class`关键字和类的名称。
- en: 'Here is a code example to demonstrate how to define a class using the class
    declaration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用类声明来定义一个类：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we created a class named `Student`. Then, we defined a `constructor` method
    in it. Finally, we created a new instance of the class—an object, and logged the
    `name` property of the object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`Student`的类。然后，我们在其中定义了一个`constructor`方法。最后，我们创建了该类的一个新实例——一个对象，并记录了该对象的`name`属性。
- en: The body of a class is in the curly brackets, that is, `{}`. This is where we
    need to define methods. Methods are defined without the `function` keyword, and
    a comma is not used in between the methods.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主体位于花括号内，即`{}`。这是我们定义方法的地方。方法定义时不使用`function`关键字，并且在方法之间不使用逗号。
- en: Classes are treated as functions, and internally the class name is treated as
    the function name, and the body of the `constructor` method is treated as the
    body of the function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类被当作函数处理，并且内部类名被当作函数名，`constructor`方法的主体被当作函数的主体。
- en: There can only be one `constructor` method in a class. Defining more than one
    constructor will throw the `SyntaxError` exception.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类中只能有一个`构造函数`方法。定义多个构造函数将抛出`SyntaxError`异常。
- en: All the code inside a class body is executed in the `strict` mode, by default.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类体内的所有代码都在`strict`模式下执行。
- en: 'The previous code is the same as this code when written using function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数编写时，前面的代码与这段代码相同：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To prove that a class is a function, consider this code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明类是一个函数，请考虑以下代码：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we can see that a class is a function. It's just a new syntax for creating
    a function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到类是一个函数。它只是创建函数的新语法。
- en: The class expression
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类表达式
- en: A class expression has a similar syntax to a class declaration. However, with
    class expressions, you are able to omit the class name. Class body and behavior
    remains the same in both the ways.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类表达式与类声明的语法类似。然而，使用类表达式时，您可以省略类名。类体和行为在这两种方式中保持相同。
- en: 'Here is a code example to demonstrate how to define a class using a class expression:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用类表达式定义类的代码示例：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we stored a reference of the class in a variable, and used it to construct
    the objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将类的引用存储在一个变量中，并使用它来构造对象。
- en: 'The previous code is the same as this code when written using function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数编写时，前面的代码与这段代码相同：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The prototype methods
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型方法
- en: All the methods in the body of the class are added to the `prototype` property
    of the class. The `prototype` property is the prototype of the objects created
    using class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类体中的所有方法都被添加到类的`prototype`属性中。`prototype`属性是使用类创建的对象的原型。
- en: 'Here is an example that shows how to add methods to the `prototype` property
    of a class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示如何向类的`prototype`属性中添加方法：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can see that the `printProfile` method was added to the `prototype`
    property of the class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到`printProfile`方法被添加到了类的`prototype`属性中。
- en: 'The previous code is the same as this code when written using function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数编写时，前面的代码与这段代码相同：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The get and set methods
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和设置方法
- en: In ES5, to add accessor properties to the objects, we had to use the `Object.defineProperty()`
    method. ES6 introduced the `get` and `set` prefixes for methods. These methods
    can be added to the object literals and classes for defining the `get` and `set`
    attributes of the accessor properties.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，为了向对象添加访问器属性，我们必须使用`Object.defineProperty()`方法。ES6引入了方法的`get`和`set`前缀。这些方法可以添加到对象字面量和类中，以定义访问器属性的`get`和`set`属性。
- en: When `get` and `set` methods are used in a class body, they are added to the
    `prototype` property of the class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当在类体中使用`get`和`set`方法时，它们被添加到类的`prototype`属性中。
- en: 'Here is an example to demonstrate how to define the `get` and `set` methods
    in a class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在类中定义`get`和`set`方法：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we created an accessor property to encapsulate the `_name_` property.
    We also logged some other information to prove that `name` is an accessor property,
    which is added to the `prototype` property of the class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个访问器属性来封装`_name_`属性。我们还记录了一些其他信息来证明`name`是一个访问器属性，它被添加到了类的`prototype`属性中。
- en: The generator method
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器方法
- en: To treat a concise method of an object literal as the generator method, or to
    treat a method of a class as the generator method, we can simply prefix it with
    the `*` character.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对象字面量的简洁方法视为生成器方法，或将类的方法视为生成器方法，我们只需在它前面加上`*`字符。
- en: The generator method of a class is added to the `prototype` property of the
    class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类的生成器方法被添加到类的`prototype`属性中。
- en: 'Here is an example to demonstrate how to define a generator method in class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何在类中定义一个生成器方法：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The static methods
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: The methods that are added to the body of the class with the `static` prefix
    are called as static methods. Static methods are the own methods of the class,
    that is, they are not added to the `prototype` property of the class, rather they
    are added to the class itself. For example, the `String.fromCharCode()` method
    is a static method of the `String` constructor, that is, `fromCharCode` is the
    own property of the `String` function itself.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`前缀添加到类体中的方法被称为静态方法。静态方法是类的自有方法，也就是说，它们不是添加到类的`prototype`属性中，而是直接添加到类本身。例如，`String.fromCharCode()`方法是`String`构造函数的静态方法，即`fromCharCode`是`String`函数本身的自有属性。
- en: Static methods are often used to create utility functions for an application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法通常用于为应用程序创建实用函数。
- en: 'Here is an example to demonstrate how to define and use a static method in
    class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来展示如何在类中定义和使用静态方法：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `findName` is a static method of the `Student` class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`findName`是`Student`类的静态方法。
- en: 'The previous code is the same as this code when written using function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与以下使用函数编写的代码相同：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing inheritance in classes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类中实现继承
- en: Earlier in this chapter, we saw how difficult it was to implement inheritance
    hierarchy in functions. Therefore, ES6 aims to make it easy by introducing the
    `extends` clause, and the `super` keyword for classes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们看到了在函数中实现继承层次结构的难度。因此，ES6通过引入`extends`子句和类的`super`关键字来简化这一过程。
- en: By using the `extends` clause, a class can inherit static and non-static properties
    of another constructor (which may or may not be defined using a class).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`extends`子句，一个类可以继承另一个构造函数的静态和非静态属性（这些属性可能或可能不是使用类定义的）。
- en: 'The `super` keyword is used in two ways:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`关键字有两种用法：'
- en: It's used in a class `constructor` method to call the parent constructor
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在类`constructor`方法中用于调用父构造函数
- en: When used inside methods of a class, it references the static and non-static
    methods of the parent constructor
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在类的内部方法中使用时，它引用父构造函数的静态和非静态方法
- en: 'Here is an example to demonstrate how to implement the inheritance hierarchy
    in the constructors using the `extends` clause, and the `super` keyword:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示如何使用`extends`子句和`super`关键字在构造函数中实现继承层次结构：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, `A` is a function constructor; `B` is a class that inherits `A`; `C` is
    a class that inherits `B;` and as `B` inherits `A,` therefore `C` also inherits
    `A`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`A`是一个函数构造函数；`B`是一个继承自`A`的类；`C`是一个继承自`B`的类；由于`B`继承了`A`，因此`C`也继承了`A`。
- en: As a class can inherit a function constructor, we can also inherit the prebuilt
    function constructors, such as `String` and `Array`, and also the custom function
    constructors using the classes instead of other *hacky* ways that we used to use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类可以继承函数构造函数，我们也可以继承预构建的函数构造函数，例如`String`和`Array`，以及使用类而不是我们以前使用的其他*笨拙*方法来自定义函数构造函数。
- en: The previous example also shows how and where to use the `super` keyword. Remember
    that inside the `constructor` method, you need to use `super` before using the
    `this` keyword. Otherwise, an exception is thrown.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例也展示了如何以及在哪里使用`super`关键字。记住，在`constructor`方法内部，在使用`this`关键字之前需要使用`super`。否则，会抛出异常。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a child class doesn't have a `constructor` method, then the default behavior
    will invoke the `constructor` method of the parent class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类没有`constructor`方法，则默认行为将调用父类的`constructor`方法。
- en: The computed method names
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算方法名
- en: 'You can also decide the name of the static and non-static methods of a class
    and concise methods of a object literal on runtime, that is, you can define the
    name of methods via expressions. Here is an example to demonstrate this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在运行时决定类的静态和非静态方法以及对象字面量的简洁方法的名字，也就是说，你可以通过表达式定义方法的名字。以下是一个示例来展示这一点：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The computed property names also allow you to use symbols as keys for the methods.
    Here is an example to demonstrate this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性名还允许你使用符号作为方法的键。以下是一个示例来展示这一点：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The attributes of properties
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性的属性
- en: 'When using class, the attributes of the static and non-static properties of
    constructor are different than when declared using function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类时，构造函数的静态和非静态属性的属性与使用函数声明时不同：
- en: The static methods are writable and configurable, but not enumerable
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法是可写和可配置的，但不是可枚举的
- en: The `prototype` property and the `prototype.constructor` property of class is
    not writable, numerable, or configurable
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的 `prototype` 属性和 `prototype.constructor` 属性是不可写、不可枚举或不可配置的
- en: The properties of the `prototype` property are writable and configurable, but
    not enumerable
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “prototype” 属性的属性是可写和可配置的，但不是可枚举的
- en: Classes are not hoisted!
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类不会被提升！
- en: You can call a function before its defined, that is, function calls can be made
    above the function definition. But in case of class, you cannot use a class before
    its defined. Trying to do so in classes will throw the `ReferenceError` exception.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在定义函数之前调用它，也就是说，函数调用可以在函数定义之上进行。但在类的情况下，你不能在定义之前使用类。在类中尝试这样做将会抛出 `ReferenceError`
    异常。
- en: 'Here is an example to demonstrate this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的示例：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Overriding the result of the constructor method
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖构造函数方法的返回结果
- en: The `constructor` method, by default, returns the new instance if there is no
    `return` statement in it. If there is a `return` statement, then whatever is the
    value in the `return` statement is returned.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`constructor` 方法如果没有 `return` 语句，则返回新实例。如果有 `return` 语句，则返回 `return` 语句中的值。
- en: 'Here is an example to demonstrate this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的示例：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The "Symbol.species" static accessor property
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “Symbol.species” 静态访问器属性
- en: The `@@species` static accessor property is optionally added to a child constructor,
    in order to signal the methods of the parent constructor, about what the constructor
    should use if the parent constructor's methods are returning new instances. If
    the `@@species` static accessor property is not defined on a child constructor,
    then the methods of the parent constructor can use the default constructor.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`@@species` 静态访问器属性可选地添加到子构造函数中，以便向父构造函数的方法发出信号，告知构造函数在父构造函数的方法返回新实例时应使用什么。如果子构造函数上没有定义
    `@@species` 静态访问器属性，则父构造函数的方法可以使用默认构造函数。'
- en: Consider this example to understand the use of `@@species`—the `map()` method
    of the array objects returns a new `Array` instance. If we call the `map()` method
    of an object that inherits an array object, then the `map()` method returns a
    new instance of the child constructor instead of the `Array` constructor, which
    is not what we always want. Therefore, ES6 introduced the `@@species` property,
    which provides a way to signal such kind of functions, to use a different constructor
    instead of the default constructor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例以了解 `@@species` 的用法——数组对象的 `map()` 方法返回一个新的 `Array` 实例。如果我们调用继承数组对象的对象的
    `map()` 方法，那么 `map()` 方法将返回子构造函数的新实例而不是 `Array` 构造函数，这通常不是我们想要的。因此，ES6 引入了 `@@species`
    属性，它提供了一种向此类函数发出信号的方式，使其使用不同的构造函数而不是默认构造函数。
- en: 'Here is a code example to demonstrate how to use the `@@species` static accessor
    property:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，演示如何使用 `@@species` 静态访问器属性：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It is recommended that if you are creating a JavaScript library, then the methods
    of the constructors in your library should always look for the `@@species` property
    while returning new instances. Here is an example to demonstrate this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建一个 JavaScript 库，建议你的库中的构造函数方法在返回新实例时始终查找 `@@species` 属性。以下是一个演示此点的示例：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In case you don't want to define a default `@@species` property in parent constructors,
    then you can use the `if…else` conditional to check whether the `@@species` property
    is defined or not. But the previous pattern is preferred. The built-in `map()`
    method also uses the previous pattern.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望在父构造函数中定义默认的 `@@species` 属性，那么你可以使用 `if…else` 条件语句来检查 `@@species` 属性是否已定义。但首选的做法是使用之前的模式。内置的
    `map()` 方法也使用之前的模式。
- en: All the built-in methods of the JavaScript constructors in ES6 look for a `@@species`
    property if they return a new instance. For example, the methods of `Array`, `Map`,
    `ArrayBuffer`, `Promise`, and other such constructors look for the `@@species`
    property if they return new instances.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中 JavaScript 构造函数的所有内置方法在返回新实例时都会查找 `@@species` 属性。例如，`Array`、`Map`、`ArrayBuffer`、`Promise`
    等构造函数的方法在返回新实例时会查找 `@@species` 属性。
- en: The "new.target" implicit parameter
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “new.target” 隐式参数
- en: ES6 adds a parameter named `new.target` to all the functions. The dot in between
    is a part of the parameter name.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 为所有函数添加了一个名为 `new.target` 的参数。参数名中的点号是参数名的一部分。
- en: 'The default value of `new.target` is `undefined`. But when a function is invoked
    as a constructor, the value of the `new.target` parameter depends on the following
    conditions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.target` 的默认值是 `undefined`。但当函数被作为构造函数调用时，`new.target` 参数的值取决于以下条件：'
- en: If a constructor is invoked using a `new` operator, then `new.target` points
    to this constructor
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用 `new` 操作符调用构造函数，则 `new.target` 指向此构造函数
- en: If a constructor is invoked via `super` keyword, then the value of `new.target`
    in it is the same as the value of `new.target` of the constructor that is called
    `super`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通过 `super` 关键字调用构造函数，则其中的 `new.target` 的值与被调用 `super` 的构造函数的 `new.target`
    的值相同。
- en: Inside an arrow function, the value of `new.target` is the same as the value
    of `new.target` of the surrounding non-arrow function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数内部，`new.target` 的值与周围的非箭头函数的 `new.target` 的值相同。
- en: 'Here is an example code to demonstrate this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例代码来演示这一点：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using "super" in the object literals
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象字面量中使用 "super"
- en: The `super` keyword can also be used in the concise methods of the object literals.
    The `super` keyword in concise methods of the object literals, has the same value
    as the `[[prototype]]` property of the object defined by the object literal.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`super` 关键字也可以用于对象字面量的简洁方法。对象字面量简洁方法中的 `super` 关键字，其值与由对象字面量定义的对象的 `[[prototype]]`
    属性相同。'
- en: In the object literals, `super` is used to access the over-ridden properties
    by the child object.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中，`super` 用于通过子对象访问被覆盖的属性。
- en: 'Here is an example to demonstrate how to use `super` in object literals:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来展示如何在对象字面量中使用 `super`：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned the basics of the object-oriented programming
    using ES5\. Then, we jumped into ES6 classes, and learned how it makes easy for
    us to read and write the object-oriented JavaScript code. We also learned miscellaneous
    features, such as the `new.target` and accessor methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先使用 ES5 学习了面向对象编程的基础。然后，我们跳入了 ES6 类，并学习了它如何使我们更容易阅读和编写面向对象的 JavaScript
    代码。我们还学习了其他特性，例如 `new.target` 和存取器方法。
- en: In the next chapter, we will learn how to create and use the ES6 modules.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建和使用 ES6 模块。
