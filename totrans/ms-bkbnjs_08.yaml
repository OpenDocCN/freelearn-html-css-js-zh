- en: Chapter 8. Testing Backbone Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It does not matter if you are an experienced programmer, it's very normal that
    you will commit mistakes in your code at some point in time. Nobody is perfect
    and errors happen all the time in software development. Your work as a developer
    is to minimize the number of defects that are in your software.
  prefs: []
  type: TYPE_NORMAL
- en: Errors can occur from different sources; an unexpected input, an error that
    is not handled properly, a change in a third-party plugin, a memory issue, and
    so on. Your code should be prepared to deal with these kind of things.
  prefs: []
  type: TYPE_NORMAL
- en: In the software industry, the rule of thumb is to always test your code. When
    you test your applications, the final product has a better quality as many defects
    have been detected and corrected before the users notice it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests are not just undertaken to prevent bugs in the software. The following
    is a list of benefits that you get when you do the testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Improves end-product quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes you confident with your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows you to refactor pieces of code safely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserves functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulates errors and improves your error handling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improves your code, forcing you to make testable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have never tested your software, now you have good reasons to start doing
    it. `Make` testing can slow down your development process at the start; however,
    you will see the benefits in the mid time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which tools are available to test frontend applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What and how to test Backbone applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply best practices for application testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run your tests automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A testing tool can be a library or framework that helps you to write tests
    for your applications and evaluate the results. Under testing tools, you can find
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing libraries**: This gives you a hook and functions to describe tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertion libraries**: This gives you functions to make expectations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test runners**: This discovers and runs your tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test coverage**: This tells you which parts of your code are tested and which
    are not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test reports**: This makes reports in different formats such as HTML and
    JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocking, stubbing, faking tools**: These give you ways to make fake objects
    with predictable behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Module mocking**: This replaces a required module with a fake module and
    is useful to isolate modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress tools**: This makes many requests to the applications in order to
    see how it behaves in high demand circumstances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser testing**: This emulates a user making inputs in the application
    as a whole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining and showing how all these tools work is out of scope of this book.
    In this chapter, you will work with testing libraries, asserting libraries, testing
    runners, and mocking.
  prefs: []
  type: TYPE_NORMAL
- en: 'For JavaScript, there are many testing libraries available for you; however,
    two of them are more popular at the moment of writing this book: `Jasmine` and
    `Mocha`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mocha` is a small library that allows you to write tests harness, it does
    not have any assertion functions by itself. What it means is that you should integrate
    `Mocha` with an assertion library of your choice; a very popular choice is to
    use a combination of Mocha and Chai.js.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Jasmine` is more like a framework, it provides an API that is very similar
    to Mocha; however, it includes assertion functions. Therefore, it is simpler to
    use as you do not need to create an extra step.'
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will use Jasmine as it is the most popular testing tool and
    is easier to start working with. In the same way as Mocha, you can use Jasmine
    as a test runner and select different types of reports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write tests, you should create two things: test suites and specs. A spec
    (short for specification) is a piece of functionality that you are testing from
    your code; for example, if your code is calculating tax of 5% for $100.00, you
    would expect it to be $5\. A test suite is a set of expectations that are grouped
    under a topic. In the preceding example, the test suite can be "Invoice totals
    calculation".'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with Jasmine, you should install it from npm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can start writing your tests. With Jasmine, you have two functions:
    `describe()` to create test suites and `it()` to make specs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines a test suite for a hypothetical set of math functions.
    Notice how in the `describe()` function, you should write a text that tells the
    people what is the context of the tests; while in the `it()` function, the text
    should tells what are you testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build the `math` functions for the test suite, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `math` object has the necessary functions to pass the test suite; however,
    to actually test the `math` object, you will need to make a set of expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Expectations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expectations are functions that compare the output of a function with an expected
    output. In the following example, we call the `sum()` function with an input of
    `2` and `2`. We are expecting that the result should be `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toEqual()`expectation function compares whether the output of the function
    and the expected value are equal; if both are the same, the test will pass, otherwise,
    it will fail. The following table shows the most common expectations in Jasmine,
    consult the documentation for a complete set of available expectation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expectation function | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `toEqual` | The values should be exactly equal | `expect(''hello'')``.toEqual(''hello'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toMatch` | The value will be RegEx matched | `expect(''Hello'')``.toMatch(/[Hh]ello/)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeTruthy` | The value should be a truth value | `expect(true)``.toBeTruthy();``expect(100)``.toBeTruthy();`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeFalsy` | The value should be a false value | `expect(false)``.toBeFalsy();``expect(null)``.toBeFalsy();`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toThrowError` | This verifies that the function that is called throws an
    error | `expect(function() {``math.divide(1, 0);``}).toThrowError();` |'
  prefs: []
  type: TYPE_TB
- en: 'After adding all the expectations to the example test suite that we have, the
    code should be something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the test suite, you should first configure the Jasmine test runner.
    To do this, you should create a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Jasmine will look for tests under the `spec/`directory, it will look for all
    those files that end with `spec.js` or `Spec.js`. As our test file is named `mathSpec.js`,
    the Jasmine test runner will load and run it, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see what happens if the test fails; for example, you change the sum
    test to `5` instead of `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you make a mistake, Jasmine will tell you what''s wrong. Notice how
    Jasmine will inform you about the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Basic mathematic functions should result 4 the sum of 2 + 2"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then, it tells you that it was expecting `5` and instead received `4`. Please
    note that it is very important what messages you put in the `describe()` and `it()`
    functions as they will help you to quickly diagnose what's wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to test a code that is asynchronous like an Ajax call, you will
    need to make an extra step. When you write the `it()` function, you should pass
    a `done` argument and Jasmine will put a callback function there, which you should
    call when the test is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s simulate an asynchronous task that sum two numbers,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the JavaScript standard, the `syncSum()` function receives a third
    argument, which is the callback function that will be called when the sum is ready.
    In the following example, the callback function will be called after 1,500 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a test with this function, we should pass a `done` callback to the
    `it()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Karma test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Karma is a popular test runner for JavaScript, it works with many other testing
    libraries and frameworks such as Jasmine and Mocha. The Node test runner that
    comes with Jasmine is fine; however, Karma adds superpowers to the equation.
  prefs: []
  type: TYPE_NORMAL
- en: With Karma, you can run your tests on real web browsers such as Google Chrome,
    Firefox, Opera, and so on. Once Karma is set and running, it will take care of
    lookup for the files to test, run it, and then give you a report.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install Karma before starting to work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can configure Karma with a script named `karma.conf.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `files` field tells to Karma which files will be tested in the `glob` format.
    The `preprocessors` field tells to Karma whether the files selected from the `files`
    field should be preprocessed before running the tests. As we are using Browserify
    to manage the dependencies, we should preprocess the files with Browserify in
    order to create a test bundle.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose how you want Karma to report the test status to you. The `reporters`
    field makes this possible, you can search for more reporters available; however,
    the `spec` reporter is one of the most used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Karma is configured, you can run the tests that we have with Karma instead
    of the Jasmine test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can automatize how you run Karma with Gulp, after all that''s its job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What and how to test Backbone applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone library has different components, each one with its own intentions
    and responsibilities, that's why you have to test them differently. Keep it in
    mind that you should only test your code and not the Backbone built-in functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, you will see what are the parts of your Backbone applications
    and how to test them; we will start from simple things and then go for more complex
    ones. Then, you will learn how to isolate modules to only test one module at time.
  prefs: []
  type: TYPE_NORMAL
- en: Testing models and collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic test is to ensure that models and collections have the right
    properties set in order to prevent accidental changes in its properties. In the
    case of models, you can test the default values when a new contact is created
    and verify that the `url` attribute is right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For collections, you can verify that the `url` is right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Views manage the relationship between data (such as, models or collections)
    and the user interactions (DOM). In the case of views, you should test for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering: Given a model or collection, you should verify that the output HTML
    is the right one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Events: This verifies that the DOM events are handled correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Model changes: If the model changes something, the view should be in sync'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this example, we are going to test the `ContactForm` view; the responsibility
    of this view is to show a form to the user and then get the user input to update
    a model.
  prefs: []
  type: TYPE_NORMAL
- en: When making test on views, it is recommended to use a fake model and not the
    original `Contact` model. The main reason for this is to isolate the `ContactView`
    object so that if a test fails, you will know that the error is isolated in the
    view and does not depend on the `Contact` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start testing whether the rendered HTML is right, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how in the test, we are looking in the output HTML if contains a specific
    text on it. You can use specific selectors instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is not recommended to do this in unstable applications as the design
    can quickly change and the tests will fail even if the name is on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing views](img/B01962_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 Jasmine testing functions
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 illustrates the relationship between the `beforeEach()`, `afterEach()`,
    and `it()` functions. When you define one or more `beforeEach()` functions in
    `describe()`, then all the `beforeEach()` functions will always be executed before
    the `it()` functions. This feature is very useful as you can ensure the same initial
    conditions for each test.
  prefs: []
  type: TYPE_NORMAL
- en: In the example test suite for the `ContactForm` object, we are ensuring that
    `fakeContact` always has the same attributes; if you change something in the model
    under an `it()` function, the next function will always get a clean `fakeContact`
    model to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ContactForm` object has a **Save** button that triggers a `form:save`
    event when it is clicked; to test this, you can listen for the event on a Jasmine
    **spy function**. A spy function is a function that does nothing but record when
    and how it is called. Then, you can use it to make expectation in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `createSpy()` method of Jasmine creates a spy function that will be used
    as the event handler for the `from:save` event. Then, it emulates a click event
    on the save button and tests whether the `callback` function was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go a step forward and check whether the function is called with the
    model as argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now is time to test when the user makes the input in the form and then click
    the **Save** button; what we are expecting from it is that the model changes with
    the input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we are changing the values in the input fields and then clicking
    the save button in the form. The `callback` spy function records how the `form:save`
    event is triggered and extracts the argument passed to it. We can use this argument
    to test whether the model was updated as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers are more complex than test as they have more dependencies than the
    models, collections, and views. If you explore the code on these objects, you
    will see that the only dependencies that they have are Backbone and Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the controllers with all its dependencies, which means that while
    testing the `ContactEditor` controller, you will be testing all the views and
    models attached to it as the module requires these objects.
  prefs: []
  type: TYPE_NORMAL
- en: That's not good for unit testing as you will end up with integration tests instead.
    If the `Contact` model has a defect, then `ContactEditor` will fail, even if it
    does not have any error in it.
  prefs: []
  type: TYPE_NORMAL
- en: You need to isolate the modules from the mess of other modules. Keep in mind
    that you should trust your libraries as they will already have their test suites.
    We need a mechanism to fake the dependencies of a module.
  prefs: []
  type: TYPE_NORMAL
- en: With dependency injection, you can overwrite the `require()` function, instead
    of loading the script that points, in order to use a fake object. This will guarantee
    that the code that is being tested is isolated and its behavior is predictable
    for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main choices to mock dependencies in Node: `rewire` and `proxyquireify`;
    with these libraries, you can overwrite the original dependencies of a module
    in order to use a fake version instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Browserify, you should have `proxyquireify`. Install it with npm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the library is installed, we need to add a proper configuration in the
    Karma configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should initialize `proxyquireify` before using it. As `proxyquireify` overwrites
    the original `require()` function, it should be initialized before being used.
    The initialization function returns a function object that is similar to the original
    `require()` function; however, with the the extra functionality of fake dependencies,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `proxyquire` object can be used to load modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load a module with `proxyquireify`, you can use a second argument
    to overwrite the original dependencies. It is an object where the keys are the
    name of the dependencies and the values are the object that will substitute the
    original dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will replace the `ContactView` object with an empty `Backbone.View`
    object so that when testing the `ContactViewer` object, the module will not load
    the original `ContactView` module.
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fake object is a simple object that has the same functions as an original
    one; however, with a predictable behavior so that you can use fake objects to
    isolate the module under test. For example, all our controllers depend on the
    `App` object to work; however, it is not a good idea to use the real `App` object
    for the purpose of testing. If the `App` object has an error, then the controller
    test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fake for the `App` object is as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simple object can simulate to be the real `App` object, as you can see
    the object does nothing; however, it will be useful in the next section for testing
    the `ContactEditor` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regions can also be faked in order to remove all the overheads of the original
    region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is very simple, just to render the view that is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing ContactEditor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ContactEditor` controller's responsibility is to render the necessary views
    in order to allow the user to update or create new contacts. It is closely related
    to many views and the `Contact` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use `proxyquireify` to isolate the `ContactEditor` controller
    and instead of using the real objects, we will fake most of them. The first test
    is to check whether the subapplication is rendered in the right region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are faking almost all the views of the `ContactEditor` controller, we don''t
    need the real views as we are not testing the output HTML, that''s a job for view
    testing. The only view that is not faked is the `FormLayout` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the fake, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ContactEditor` controller, we are listening for `avatar:selected` of
    the `ContactPreview` view, we should ensure that the event is handled correctly.
    However, we have a problem, we cannot access the view instance. To make the controller
    testable, it is a common practice to put the views as attributes of the controller,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, we can make the proper test, it verifies that the `avatarSelected`
    property is set when the `contactPreview` view selects an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The core functionality of the `ContactEditor` controller is to save the contact
    properly when the user clicks on the **Save** button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this test case, the controller will call the `save()` method in the model
    to save the contact and Backbone will make an Ajax call to the server. When you
    are testing, you should not make real server connections as that will make your
    tests slow and prone to failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `jasmine-ajax` plugin, you can fake the Ajax calls so that you will
    have a total control of how the test behaves. You will need to install the package
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the configuration of Karma to include the plugin, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The plugin overwrites the original `XMLHttpRequest` object, therefore, it's
    important to initialize the Ajax plugin before starting your test and restore
    the original object once your test is done.
  prefs: []
  type: TYPE_NORMAL
- en: In the `beforeEach()` function, we will initialize the plugin by calling `jasmine.Ajax.install()`
    and restore the original `XMLHttpRequest` object with `jasmine.Ajax.uninstall()`
    in `afterEach()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your application makes an Ajax call, the plugin will catch the request
    and you can then inspect the request or fake the response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we saved the contact and faked an HTTP `200` response.
    When this happens, the application will show a success message and redirect the
    application to the contact list.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server responds with an error, then the application will show an error
    message and not make a redirection to the contact list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing that the `saveContact()` method does is to set the `phones` and
    `emails` attributes in the contact model. The test will ensure that the attributes
    are sent to the server correctly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We are setting a list of `phones` and `emails` and then test whether the server
    receives the right request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the contact is not valid, then the controller will not send anything to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContactEditor` object should upload the avatar image only if the model
    is new. If the model not is new, then the avatar is uploaded immediately when
    the user selects the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Testing the subapplication Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The subapplication façade''s responsibility is to create the model or collect
    objects and create the appropriate subapplication controller to render the fetched
    data. To show the contact editor, the Façade should fetch the contact by its ID
    and then run the `ContactEditor` subapplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The setup for this test suite is very similar to the controller. We should
    fake the `Ajax` calls and create a Façade object that is to be used on the specs.
    Our first test will be to verify that it is fetching the correct data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The Façade should trigger `loading: start` when fetching the data from the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it should stop when the request is fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it should show the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to build robust applications with minimum defects, you should test
    your code. Even if you are very good at coding, sometimes you may forget a validation
    or break a dependency and won't know about it until the final user of your application
    finds the bug.
  prefs: []
  type: TYPE_NORMAL
- en: As a professional developer, you should make sure that your code is always ready
    for production; one way to successfully do it is to run tests in your development
    workflow. Another benefit of testing applications is that you will gain confidence
    in your code, which means that you can improve your code without the fear of breaking
    something accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: In Backbone, testing depends on the responsibility of the object that you are
    testing. Models, views, controllers, and facades are tested in their own way.
    However, it doesn't matter what the object is, Jasmine does a great work in order
    to help you to make a good test battery.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to deploy your Backbone application
    to a server for production and how to build a production environment for your
    applications. You will setup a Heroku instance if you don't want to mess with
    the server configuration internals or want to see how all the parts are connected
    in deep. I will show you how to configure an Ubuntu server in order to make your
    deployments.
  prefs: []
  type: TYPE_NORMAL
