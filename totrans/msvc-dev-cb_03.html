<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Inter-service Communication</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li style="font-weight: 400">Service-to-service communication</li>
<li>Making concurrent asynchronous requests</li>
<li style="font-weight: 400">Finding services using service discovery</li>
<li style="font-weight: 400">Server-side load balancing</li>
<li style="font-weight: 400">Client-side load balancing</li>
<li style="font-weight: 400">Building event-driven microservices</li>
<li style="font-weight: 400">Evolving APIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we've covered how to begin breaking a monolithic codebase into microservices, as well as best practices for exposing your microservices to the public internet. So far, we've assumed that all of our microservices are standalone applications that have no dependencies. These simple microservices receive requests, retrieve data or write to a database, and return a response to clients. This kind of linear workflow is rare in real-world systems. In a real-world microservice architecture, services will frequently need to invoke other services in order to fulfill a user's request. A typical user request will commonly create dozens of requests to services in your system.</p>
<p>Managing the communication between services presents a number of challenges. Before a service can speak to another service, it will need to locate it through some kind of service-discovery mechanism. When generating requests to a downstream service, we also need a way to distribute traffic across the various instances of the service that minimizes latency and distributes the load evenly without compromising data integrity. We’ll need to consider how to handle service failures and prevent them from cascading throughout our system.</p>
<p>Sometimes a service will need to communicate with other services asynchronously, in these cases, we can use event-driven architectural patterns to create reactive workflows. Breaking our system up into multiple services also means that different services will evolve their APIs independently, so we'll need ways to handle changes that won't break upstream services.</p>
<p>In this chapter, we'll discuss recipes designed to address each of these challenges. By the end of this chapter, you'll be able to confidently handle the various kinds of interactions we're bound to require in a microservice architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service-to-service communication</h1>
                </header>
            
            <article>
                
<p>In large-scale systems, problems arise less often in services themselves and more often in the communication between services. For this reason, we need to carefully consider all of the various challenges in service-to-service communication. When discussing service-to-service communication, it's useful to visualize the flow of information in our system. Data flows in both directions<span>–</span>from the client (upstream) to the database, or event bus (downstream) in the form of requests, and back again in the form of responses. When we refer to upstream services, we are describing components of the system that are closer to the user in the flow of information. When we refer to downstream services, we are describing components of the system that are further away from the user<span>–</span>in other words, the user makes a request that is routed to a service that then makes requests to other, downstream services, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e9d1a309-4a6c-40b9-b1f9-fb29a57213ea.png" style="width:33.50em;height:17.67em;"/></p>
<p>In the preceding diagram, the originating <strong>User</strong> is upstream from the <strong>edge-proxy-service</strong>, which is upstream from the <strong>auth-service</strong>, <strong>attachment-service</strong>, and <strong>user-service</strong>.</p>
<p>In order to demonstrate the service-to-service communication, we’ll create a simple service that calls another service synchronously using the Spring Boot Java framework. Keeping with the example of our fictional messaging application, we’ll create a message service that is responsible for sending messages. The message service has to invoke the social graph service in order to determine whether the sender and recipient of a message are friends before allowing a message to be sent. The following simplified diagram illustrates the relationship between services:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f59246e5-43de-47fb-a0ec-04597a6befe0.png" style="width:51.92em;height:8.67em;"/></div>
<p>As you can see, a <strong>POST</strong> request comes in from the user to the <strong>/message</strong> endpoint, which is routed to <strong>message-service</strong>. The <strong>message-service</strong> service then makes an HTTP <strong>GET</strong> request to the <strong>social-service</strong> service using the <strong>/friendships/:id</strong> endpoint. The <strong>social-service</strong> service returns a JSON representation of friendships for a user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new Java/Gradle project called <kbd>message-service</kbd> and add the following content to the <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Create a new package called <kbd>com.packtpub.microservices.ch03.message</kbd> and a new class called <kbd>Application</kbd>. This will be our service's entry point:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.message;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@SpringBootApplication<br/>public class Application {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li>Create the model. Create a package called <kbd>com.packtpub.microservices.ch03.message.models</kbd> and a class called <kbd>Message</kbd>. This is the internal representation of the message. There's a lot missing here. We're not actually persisting the message in this code, as it's best to keep this example simple:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.message.models;<br/><br/>public class Message {<br/><br/>    private String toUser;<br/>    private String fromUser;<br/>    private String body;<br/><br/>    public Message() {}<br/><br/>    public Message(String toUser, String fromUser, String body) {<br/>        this.toUser = toUser;<br/>        this.fromUser = fromUser;<br/>        this.body = body;<br/>    }<br/><br/>    public String getToUser() {<br/>        return toUser;<br/>    }<br/><br/>    public String getFromUser() {<br/>        return fromUser;<br/>    }<br/><br/>    public String getBody() {<br/>        return body;<br/>    }<br/>}</pre>
<ol start="4">
<li>Create a new package called <kbd>com.packtpub.microservices.ch03.message.controllers</kbd> and a new class called <kbd>MessageController</kbd>. At the moment, our controller doesn't do much except accept the request, parse the JSON, and return the message instance, as you can see from this code:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.message.controllers;<br/><br/>import com.packtpub.microservices.models.Message;<br/>import org.springframework.web.bind.annotation.*;<br/><br/>@RestController<br/>public class MessageController {<br/><br/>    @RequestMapping(<br/>            path="/messages",<br/>            method=RequestMethod.POST,<br/>            produces="application/json")<br/>    public Message create(@RequestBody Message message) {<br/>        return message;<br/>    }<br/>}</pre>
<ol start="5">
<li>Test this basic service by running it and trying to send a simple request:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ./gradlew bootRun</strong><br/><strong>Starting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details</strong><br/><br/><strong>&gt; Task :bootRun</strong><br/><br/><strong>  . ____ _ __ _ _</strong><br/><strong> /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \</strong><br/><strong>( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</strong><br/><strong> \\/ ___)| |_)| | | | | || (_| | ) ) ) )</strong><br/><strong>  ' |____| .__|_| |_|_| |_\__, | / / / /</strong><br/><strong> =========|_|==============|___/=/_/_/_/</strong><br/><strong> :: Spring Boot :: (v1.5.9.RELEASE)</strong><br/><br/><strong>...</strong></pre>
<p style="padding-left: 90px">Take a look at the following command line:</p>
<pre style="padding-left: 60px"><strong>$ curl -H "Content-Type: application/json" -X POST http://localhost:8080/messages -d'{"toUser": "reader", "fromUser": "paulosman", "body": "Hello, World"}'</strong><br/><br/><strong>{"toUser":"reader","fromUser":"paulosman","body":"Hello, World"}</strong></pre>
<p style="padding-left: 60px">Now we have a basic service working, but it's pretty dumb and not doing much. We won't go into persistence in this chapter, but let's add some intelligence by checking with the social service to verify that our two users have a friendship before allowing the message to be sent. For the purposes of our example, imagine we have a working social service that allows us to check for relationships between users with requests, like so:</p>
<pre style="color: black;padding-left: 60px">GET /friendships?username=paulosman&amp;filter=reader<br/><br/>{<br/>  "username": "paulosman",<br/>  "friendships": [<br/>    "reader"<br/>  ]<br/>}</pre>
<ol start="6">
<li>Before we can consume this service, let's create a model to store its response. In the <kbd>com.packtpub.microservices.ch03.message.models</kbd> package, create a class called <kbd>UserFriendships</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.message.models;<br/><br/>import com.fasterxml.jackson.annotation.JsonIgnoreProperties;<br/><br/>import java.util.List;<br/><br/>@JsonIgnoreProperties(ignoreUnknown = true)<br/>public class UserFriendships {<br/>    private String username;<br/>    private List&lt;String&gt; friendships;<br/><br/>    public UserFriendships() {}<br/><br/>    public String getUsername() {<br/>        return username;<br/>    }<br/><br/>    public void setUsername(String username) {<br/>        this.username = username;<br/>    }<br/><br/>    public List&lt;String&gt; getFriendships() {<br/>        return friendships;<br/>    }<br/><br/>    public void setFriendships(List&lt;String&gt; friendships) {<br/>        this.friendships = friendships;<br/>    }<br/>}</pre>
<ol start="7">
<li>Modify <kbd>MessageController</kbd>, adding a method to get a list of friendships for a user, optionally filtering by a username. Note that we're hardcoding the URL in this example, which is a bad practice. We'll discuss alternatives to this in the next recipe. Take a look at the following code:</li>
</ol>
<pre style="color: black;padding-left: 60px">private List&lt;String&gt; getFriendsForUser(String username, String filter) {<br/>    String url = "http://localhost:4567/friendships?username=" + username + "&amp;filter=" + filter;<br/>    RestTemplate template = new RestTemplate();</pre>
<pre style="color: black;padding-left: 60px">    UserFriendships friendships = template.getForObject(url, UserFriendships.class);<br/>    return friendships.getFriendships();<br/>}</pre>
<ol start="8">
<li>Modify the <kbd>create</kbd> method we wrote earlier. If the users are friends, we'll continue and return the message as before; if the users are not friends, the service will respond with a <kbd>403</kbd> indicating that the request is forbidden:</li>
</ol>
<pre style="color: black;padding-left: 60px">@RequestMapping(<br/>            path="/messages",<br/>            method=RequestMethod.POST,<br/>            produces="application/json")<br/>    public ResponseEntity&lt;Message&gt; create(@RequestBody Message message) {<br/>        List&lt;String&gt; friendships = getFriendsForUser(message.getFromUser(), message.getToUser());<br/><br/>        if (friendships.isEmpty())<br/>            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();<br/><br/>        URI location = ServletUriComponentsBuilder<br/>                .fromCurrentRequest().path("/{id}")<br/>                .buildAndExpand(message.getFromUser()).toUri();<br/>        <br/>        return ResponseEntity.created(location).build();<br/>    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous requests</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we were making a single service invocation per request, from the message service to the social service. This has the benefit of being incredibly simple to implement and, when using single-threaded languages, such as Python, Ruby, or JavaScript, is often the only choice. Performing a network call synchronously in this manner is acceptable when you're only doing it once per request<span>–</span>it doesn't matter that the call blocks the thread since you can't respond to the user until the invocation is complete anyway. When you're making multiple requests, however, blocking network calls will severely impact the performance and scalability of your application. <span>What we need is an easy way to make use of Java's concurrency features.</span></p>
<p><span>If you're writing your microservices in Scala, you can take advantage of the <kbd>Future</kbd> type, which is used to represent an asynchronous computation. The <strong>Finagle</strong> RPC framework even uses futures as one of its base abstractions for modeling dependent RPCs. Java also has futures and the Spring Boot framework has some useful utilities that make it easy to wrap network calls, making them asynchronous and therefore non-blocking.</span></p>
<p><span>In this recipe, we'll retool the message service we introduced in the previous recipe. Instead of checking to see whether the sender and recipient of a message are friends, we'll now imagine that our app uses an asymmetric following model. For a user to message another user, the two users will have to follow each other. This requires the message service to make two network calls to the social service, checking that the sender follows the recipient and simultaneously checking that the recipient follows the sender. The following simplified diagram represents the relationship between services:<br/></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06522d1b-7cc6-456f-a624-cfcaef00e7c4.png"/></p>
<p>Spring Boot has useful tools that we can use to make methods asynchronous using Java's <kbd>CompletableFuture</kbd> type. We'll modify our previous message service to make two concurrent calls to the search service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the <kbd>MessageController</kbd> file and insert the following content:</li>
</ol>
<pre style="padding-left: 60px"><span>package </span>com.packtpub.microservices.ch03.message.controllers;<br/><br/><span>import </span>com.packtpub.microservices.models.Message;<br/><span>import </span>com.packtpub.microservices.models.UserFriendships;<br/><span>import </span>org.springframework.http.HttpStatus;<br/><span>import </span>org.springframework.http.ResponseEntity;<br/><span>import </span>org.springframework.web.bind.annotation.*;<br/><span>import </span>org.springframework.web.client.RestTemplate;<br/><span>import </span>org.springframework.web.servlet.support.ServletUriComponentsBuilder;<br/><br/><span>import </span>java.net.URI;<br/><span>import </span>java.util.List;<br/><br/><span>@RestController<br/></span><span>public class </span>MessageController {<br/><br/>    <span>@RequestMapping</span>(<br/>            path=<span>"/messages"</span>,<br/>            method=RequestMethod.<span>POST</span>,<br/>            produces=<span>"application/json"</span>)<br/>    <span>public </span>ResponseEntity&lt;Message&gt; create(<span>@RequestBody </span>Message message) {<br/>        List&lt;String&gt; friendships = getFriendsForUser(message.getFromUser(), message.getToUser());<br/><br/>        <span>if </span>(friendships.isEmpty())<br/>            <span>return </span>ResponseEntity.<span>status</span>(HttpStatus.<span>FORBIDDEN</span>).build();<br/><br/>        URI location = ServletUriComponentsBuilder<br/>                .<span>fromCurrentRequest</span>().path(<span>"/{id}"</span>)<br/>                .buildAndExpand(message.getFromUser()).toUri();<br/><br/>        <span>return </span>ResponseEntity.<span>created</span>(location).build();<br/>    }<br/><br/>    <span>private </span>List&lt;String&gt; getFriendsForUser(String username, String filter) {<br/>        String url = <span>"http://localhost:4567/friendships?username=" </span>+ username + <span>"&amp;filter=" </span>+ filter;<br/>        RestTemplate template = <span>new </span>RestTemplate();<br/>        UserFriendships friendships = template.getForObject(url, UserFriendships.<span>class</span>);<br/>        <span>return </span>friendships.getFriendships();<br/>    }<br/>}</pre>
<ol start="2">
<li>Replace the <kbd>getFriendsForUser</kbd> method with a new method, called <kbd>isFollowing</kbd>. We give the new method an <kbd>@Async</kbd> annotation, which tells Spring Boot that this method will be run in a different thread:</li>
</ol>
<pre style="padding-left: 60px">import org.springframework.scheduling.annotation.Async;<br/>import java.util.concurrent.CompletableFuture;<br/><br/>...<br/><br/>@Async<br/>public CompletableFuture&lt;Boolean&gt; isFollowing(String fromUser, String toUser) {<br/><br/>    String url = String.format(<br/>      "http://localhost:4567/followings?user=%s&amp;filter=%s",<br/>      fromUser, toUser);<br/><br/>    RestTemplate template = new RestTemplate();<br/>    UserFollowings followings = template.forObject(url, UserFollowings.class);<br/><br/>    return CompletableFuture.completedFuture(<br/>        followings.getFollowings().isEmpty()<br/>    );<br/>}</pre>
<ol start="3">
<li>Modify the <kbd>create</kbd> method to make the two service invocations. We'll need to wait until they are both done before deciding how to proceed, but the two service calls will be made concurrently:</li>
</ol>
<pre style="padding-left: 60px"><span>@RequestMapping</span>(<br/>            path=<span>"/messages"</span>,<br/>            method=RequestMethod.<span>POST</span>,<br/>            produces=<span>"application/json"</span>)<br/>    <span>public </span>ResponseEntity&lt;Message&gt; create(<span>@RequestBody </span>Message message) {<br/><br/>    CompletableFuture&lt;Boolean&gt; result1 = isFollowing(message.getFromUser(), message.getToUser());<br/>    CompletableFuture&lt;Boolean&gt; result2 = isFollowing(message.getToUser(), message.getFromUser());<br/><br/>    CompletableFuture.allOf(result1, result2).join();<br/><br/>    // if both are not true, respond with a 403<br/>    if (!(result1.get() &amp;&amp; result2.get()))<br/>        ResponseEntity.status(HttpStatus.FORBIDDEN).build();<br/><br/>    ... // proceed<br/><br/>}</pre>
<ol start="4">
<li>For the <kbd>@Async</kbd> annotation to schedule methods on separate threads, we need to configure an <kbd>Executor</kbd>. This is done in our <kbd>Application</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">package com.packtpub.microservices;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.scheduling.annotation.EnableAsync;<br/>import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;<br/><br/>import java.util.concurrent.Executor;<br/><br/>@SpringBootApplication<br/>@EnableAsync<br/>public class Application {<br/><br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args).close();<br/>    }<br/><br/>    @Bean<br/>    public Executor asyncExecutor() {<br/>        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br/>        executor.setCorePoolSize(2);<br/>        executor.setMaxPoolSize(2);<br/>        executor.setQueueCapacity(500);<br/>        executor.setThreadNamePrefix("SocialServiceCall-");<br/>        executor.initialize();<br/>        return executor;<br/>    }<br/><br/><br/>}</pre>
<p style="padding-left: 60px">Our service now makes concurrent asynchronous calls to the social service in order to ensure that the sender and recipient of a message follow each other. We customize our <kbd>Async</kbd> scheduler with <kbd>Executor</kbd> defined as part of our application's configuration. We've configured our <kbd>ThreadPoolTaskExecutor</kbd> class to limit the number of threads to <kbd>2</kbd> and the queue size to <kbd>500</kbd>. There are many factors to consider when configuring <kbd>Executor</kbd>, such as the amount of traffic you expect your service to receive and the average amount of time it takes for your service to serve a request. In this example, we'll leave it with these values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service discovery</h1>
                </header>
            
            <article>
                
<p>Before services can invoke each other, they need to be able to find each other using some kind of service discovery mechanism. This means being able to translate a service name into a network location (IP address and port). Traditional applications maintained the network locations of services to send requests to, probably in a configuration file (or worse, hardcoded in the application code). This approach assumes that network locations are relatively static, which isn't going to be the case in modern, cloud-native applications. The topologies of microservice architectures are constantly changing. Nodes are being added and removed through auto-scaling, and we have to assume that some nodes will fail either completely or by serving requests with unacceptably high latency. As a microservice architecture grows, you'll need to consider a more feature-rich service-discovery mechanism.</p>
<p>When choosing a service-discovery mechanism, the datastore used to back your service registry is extremely important. You want a well-tested, battle-worn system. Apache <strong>ZooKeeper</strong> is an open source hierarchical key-value store commonly used for distributed locking, service discovery, maintaining configuration information, and other distributed coordination tasks. The development of ZooKeeper was in part motivated by a paper published by Google in 2006 that described <strong>Chubby</strong>, an internally-developed system for distributed lock storage. In this recipe, we'll use ZooKeeper to build a service-discovery mechanism.</p>
<p>Spring Cloud ZooKeeper is a project that provides easy ZooKeeper integration in Spring Boot applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p class="mce-root">For this recipe, there are two sets of steps, as shown in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering with the service registry</h1>
                </header>
            
            <article>
                
<p>This recipe requires a running ZooKeeper cluster. At a minimum, you will need a single ZooKeeper node running locally on your development machine. For instructions on installing and running ZooKeeper, please visit the excellent ZooKeeper documentation. Take a look at the following steps:</p>
<ol>
<li>For this example, we'll create a service to handle the creation and retrieval of user accounts. Create a new Gradle Java application called <kbd>users-service</kbd> with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'io.spring.gradle', name: 'dependency-management-plugin', version: '0.5.6.RELEASE'<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/>apply plugin: "io.spring.dependency-management"<br/><br/>sourceCompatibility = 1.8<br/><br/>dependencyManagement {<br/>    imports {<br/>        mavenBom 'org.springframework.cloud:spring-cloud-zookeeper-dependencies:1.1.1.RELEASE'<br/>    }<br/>}<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'io.reactivex', name: 'rxjava', version: '1.1.5'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-zookeeper-discovery', version: '1.1.1.RELEASE'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Because we've declared <kbd>spring-boot-starter-zookeeper-discovery</kbd> as a dependency, we have access to the necessary annotations to tell our application to register itself with a ZooKeeper service registry on startup. Create a new class called <kbd>Application</kbd>, which will serve as our service's entry point:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">package com.packtpub.microservices.ch03.servicediscovery;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br/><br/>@EnableDiscoveryClient<br/>@SpringBootApplication<br/>public class Application {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>
<ol start="3">
<li>The application now attempts to connect to a ZooKeeper node, by default running on port 2181 on localhost. This default will work for local development, but will need to be changed in a production environment anyway. Add a file <kbd>src/resources/application.yml</kbd> with the following contents:</li>
</ol>
<pre style="padding-left: 60px">spring:<br/>  cloud:<br/>    zookeeper:<br/>      connect-string: localhost:2181</pre>
<ol start="4">
<li>To give your service a meaningful name in the service registry, modify the <kbd>application.yml</kbd> file and add the following content:</li>
</ol>
<pre style="color: black;padding-left: 60px">spring:<br/>  cloud:<br/>    zookeeper:<br/>      connect-string: localhost:2181<br/>  application:<br/>    name: users-service</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding services</h1>
                </header>
            
            <article>
                
<p>Now that we have a service being registered with the service registry, we'll create another service to demonstrate using the Spring ZooKeeper <kbd>DiscoveryClient</kbd> to find a running instance of that service:</p>
<ol>
<li>Open our previously created message-service client. Add the following lines to <kbd>build.gradle</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        <strong>classpath group: 'io.spring.gradle', name: 'dependency-management-plugin', version: '0.5.6.RELEASE'<br/></strong>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/><strong>apply plugin: '</strong><strong>io.spring.dependency-management'</strong><br/><br/>sourceCompatibility = 1.8<br/><br/><strong>dependencyManagement {</strong><br/><strong>    imports {</strong><br/><strong>        mavenBom 'org.springframework.cloud:spring-cloud-zookeeper-dependencies:1.1.1.RELEASE'<br/>    }</strong><br/><strong>}</strong><br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/><strong>    compile </strong><strong>'io.reactivex:rxjava:1.3.4'</strong><br/><strong>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-zookeeper-discovery', version: '1.1.1.RELEASE'<br/>    compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-feign', version: '1.2.5.RELEASE'<br/>    compile group: 'org.springframework.kafka', name: 'spring-kafka', version: '2.1.1.RELEASE'<br/></strong>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>We're using an HTTP client developed by Netflix, called <strong>Feign</strong>. Feign allows you to declaratively build HTTP clients and supports service discovery by default. Create a new file called <kbd>UsersClient.java</kbd> with the following content:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.servicediscovery.clients;<br/><br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br/>import org.springframework.cloud.netflix.feign.EnableFeignClients;<br/>import org.springframework.cloud.netflix.feign.FeignClient;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.web.bind.annotation.PathVariable;<br/>import org.springframework.web.bind.annotation.RequestMapping;<br/>import org.springframework.web.bind.annotation.RequestMethod;<br/>import org.springframework.web.bind.annotation.ResponseBody;<br/><br/>import java.util.List;<br/><br/>@Configuration<br/>@EnableFeignClients<br/>@EnableDiscoveryClient<br/>public class UsersClient {<br/><br/>    @Autowired<br/>    private Client client;<br/><br/>    @FeignClient("users-service")<br/>    interface Client {<br/>        @RequestMapping(path = "/followings/{userId}", method = RequestMethod.GET)<br/>        @ResponseBody<br/>        List&lt;String&gt; getFollowings(@PathVariable("userId") String userId);<br/>    }<br/><br/>    public List&lt;String&gt; getFollowings(String userId) {<br/>        return client.getFollowings(userId);<br/>    }<br/>}</pre>
<ol start="3">
<li>Open the <kbd>MessageController.java</kbd> file, and add an instance of <kbd>UsersClient</kbd> as a field:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices;<br/>...<br/>@RestController<br/>public class MessagesController {<br/>    ...<br/>    @Autowired<br/>    private UsersClient usersClient;<br/>    ...<br/>}</pre>
<ol start="4">
<li>Instead of manually building the URL in the <kbd>isFollowing</kbd> method, we can use the Feign client to automatically get a list of friendships for a user, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span>@Async<br/></span><span>public </span>CompletableFuture&lt;Boolean&gt; <span>isFollowing</span>(String fromUser<span>, </span>String toUser) {<br/>    <br/>    List&lt;String&gt; friends = <span>usersClient</span>.getFollowings(fromUser)<br/>            .stream()<br/>            .filter(toUser::equals)<br/>            .collect(Collectors.<span>toList</span>())<span>;<br/></span><span><br/></span><span>    return </span>CompletableFuture.<span>completedFuture</span>(friends.isEmpty())<span>;<br/></span>}</pre>
<p>Because we're using a service registry, we no longer have to worry about clunky configs holding onto hostname values that can change. Furthermore, we're in a position to start deciding how we want to distribute the load among available instances of a service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side load balancing</h1>
                </header>
            
            <article>
                
<p>When thinking about distributing load across a cluster of servers running instances of an application, it's interesting to consider a brief (and incomplete) history of web application architectures. Some of the earliest web applications were static HTML pages hosted by a web server, such as Apache or similar web server daemon software. Gradually, applications became more dynamic, using technologies such as server-side scripts executed through CGI. Even dynamic applications were still files hosted and served directly by a web server daemon. This simple architecture worked for a long time. Eventually, however, as the amount of traffic an application received grew, a way to distribute load among identical stateless instances of an application was needed.</p>
<p>There are a number of techniques for load balancing, including round-robin DNS or DNS geolocation. The simplest and most common form of load balancing for microservices is to use a software program that forwards requests to one of a cluster of backend servers. There are a number of different ways load can be distributed, based on the specific load-balancing algorithm used by the load balancer we choose. Simple load-balancing algorithms include round-robin and random choice. More often, in real-world production applications, we'll opt for a load-balancing algorithm that takes reported metrics, such as load or the number of active connections, into account when choosing a node in a cluster to forward a request to.</p>
<p>There are a number of popular open source applications that can perform effective load balancing for microservices. <strong>HAProxy</strong> is a popular open source load balancer that can do TCP and HTTP load balancing. NGINX is a popular open source web server that can be effectively used as a reverse proxy, application server, load balancer, or even HTTP cache. Nowadays, more organizations are in positions to develop microservices that are deployed on cloud platforms, such as Amazon Web Services or Google Cloud Platform, which each have solutions for server-side load balancing.</p>
<p>AWS provides a load-balancing solution called <strong>Elastic Load Balancing</strong> (<strong>ELB</strong>). ELB can be configured to forward traffic to a member of an <strong>Auto Scaling Groups</strong>. Auto Scaling Groups are collections of EC2 instances that are treated as a logical group. ELB use health checks (TCP or HTTP) that help the load balancer determine whether to forward traffic to a particular EC2 instance.</p>
<p>In this recipe, we'll use the AWS CLI tool to create an Auto Scaling Groups and attach an ELB to it. We won't cover configuration management or deployment in this recipe, so imagine that you have a microservice running on each of the EC2 instances in the Auto Scaling Groups.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>We'll be using the AWS CLI in this recipe, a command-line utility written in Python, that makes interacting with the AWS API easy. We'll assume you have an AWS account and have installed and configured the AWS CLI application. Consult the AWS documentation (<a href="https://docs.aws.amazon.com/cli/latest/index.html#">https://docs.aws.amazon.com/cli/latest/index.html#</a>) for installation instructions.</li>
<li>Create a launch configuration. Launch configurations are templates that our Auto Scaling Groups will use for creating new EC2 instances. They contain information such as the instance type and size that we want to use when creating new instances. Give your launch configuration a unique name<span>–</span>in our case, we'll simply call it <kbd>users-service-launch-configuration</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ aws create-launch-configuration --launch-configuration-name users-service-launch-configuration \</strong><br/><strong>  --image-id ami-05355a6c --security-groups sg-8422d1eb \</strong><br/><strong>  --instance-type m3.medium</strong></pre>
<ol start="3">
<li>Create an Auto Scaling Groups that uses our new launch configuration:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ aws create-auto-scaling-group --auto-scaling-group-name users-service-asg \</strong><br/><strong>  --launch-configuration-name users-service-launch-configuration \</strong><br/><strong>  --min-size 2 \</strong><br/><strong>  --max-size 10</strong></pre>
<ol start="4">
<li>Create an ELB, as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ aws create-load-balancer --load-balancer-name users-service-elb \</strong><br/><strong>  --listeners "Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=8080"</strong></pre>
<ol start="5">
<li>Attach the ASG to our load balancer by running the following command line:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>$ aws autoscaling attach-load-balancers --auto-scaling-group-name users-service-asg --load-balancer-names users-service-elb</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side load balancing</h1>
                </header>
            
            <article>
                
<p>Server-side load balancing is a well-established and battle-tested way to distribute load to an application. It has drawbacks, however, in that there is an upper limit to the amount of incoming connections that a single load balancer can handle. This can be at least partially solved with round-robin DNS, which would distribute load to a number of load balancers, but this configuration can quickly become cumbersome and costly. Load balancer applications can also become points of failure in an already-complex microservices architecture.</p>
<p>An increasingly popular alternative to server-side load balancing is client-side load balancing. In this convention, clients are responsible for distributing requests evenly to running instances of a service. Clients can keep track of latency and failure rates from nodes and opt to reduce the amount of traffic to nodes that are experiencing high latency or high failure rates. This method of load balancing can be extremely effective and simple, especially in large-scale applications.</p>
<p>Ribbon is an open source library developed by Netflix that, among other features, provides support for client-side load balancing. In this recipe, we'll modify our message service to use <kbd>ribbon</kbd> for client-side load balancing. Instead of sending our requests for a user's friendships to a single instance of the users service, we'll distribute load to a number of available instances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the <kbd>message-service</kbd> project and add the following lines to <kbd>build.gradle</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">...<br/>dependencies {<br/>  ...<br/>  compile group: 'org.springframework.cloud', name: 'spring-cloud-starter-ribbon', version: '1.4.2.RELEASE'<br/>}<br/>...</pre>
<ol start="2">
<li>Navigate to <kbd>src/main/resources/application.yml</kbd> and add the following configuration for <kbd>users-service</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">users-service:<br/>  ribbon:<br/>    eureka:<br/>      enabled: false<br/>    listOfServers: localhost:8090,localhost:9092,localhost:9999<br/>    ServerListRefreshInterval: 15000</pre>
<ol start="3">
<li>Create a new Java class called <kbd>UsersServiceConfiguration</kbd>. This class will configure the specific rules we want <kbd>ribbon</kbd> to follow when deciding how to distribute load:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.clientsideloadbalancing;<br/><br/>import org.springframework.beans.factory.annotation.Autowired;<br/>import org.springframework.context.annotation.Bean;<br/><br/>import com.netflix.client.config.IClientConfig;<br/>import com.netflix.loadbalancer.IPing;<br/>import com.netflix.loadbalancer.IRule;<br/>import com.netflix.loadbalancer.PingUrl;<br/>import com.netflix.loadbalancer.AvailabilityFilteringRule;<br/><br/>public class UsersServiceConfiguration {<br/><br/>  @Autowired<br/>  IClientConfig ribbonClientConfig;<br/><br/>  @Bean<br/>  public IPing ribbonPing(IClientConfig config) {<br/>    return new PingUrl();<br/>  }<br/><br/>  @Bean<br/>  public IRule ribbonRule(IClientConfig config) {<br/>    return new AvailabilityFilteringRule();<br/>  }<br/><br/>}</pre>
<ol start="4">
<li>Open <kbd>MessageController</kbd> and add the following annotation to the <kbd>MessageController</kbd> class:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>@RibbonClient(name = "users-service", configuration = UsersServiceConfiguration.class)</strong><br/>@RestClient<br/>public class MessageController {<br/><br/>}</pre>
<ol start="5">
<li>Annotate the <kbd>RestTemplate</kbd> class to indicate that we want it to use <kbd>ribbon</kbd> load-balancing support, and modify our URL to use the service name, not the hostname we had hardcoded previously:</li>
</ol>
<pre style="color: black;padding-left: 60px">@RibbonClient(name = "users-service", configuration = UsersServiceConfiguration.class)<br/>@RestClient<br/>public class MessageController {<br/>    ...<br/>    @LoadBalanced<br/>    @Bean<br/>    RestTemplate restTemplate(){<br/>      return new RestTemplate();<br/>    }<br/>    ...<br/><br/>    @Async<br/>    public CompletableFuture&lt;Boolean&gt; isFollowing(String fromUser, String toUser) {<br/><br/>        String url = String.format(<br/>                "http://localhost:4567/followings?user=%s&amp;filter=%s",<br/>                fromUser, toUser);<br/><br/>        RestTemplate template = new RestTemplate();<br/>        UserFriendships followings = template.getForObject(url, UserFriendships.class);<br/><br/>        return CompletableFuture.completedFuture(<br/>                followings.getFriendships().isEmpty()<br/>        );<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building event-driven microservices</h1>
                </header>
            
            <article>
                
<p>So far, all of our service-to-service communication recipes have involved having one service call one or more other services directly. This is necessary when the response from the downstream service is required to fulfill the user's request. This isn't always required however. In cases when you want to react to an event in the system, for example, when you want to send an email or notification or when you want to update an analytics store, using an event-driven architecture is preferable. In this design, one service produces a message to a broker and another application consumes that message and performs an action. This has the benefit of decoupling the publisher from the consumer (so your message service doesn't have to worry about sending email notifications, for instance) and also removing potentially expensive operations off the critical path of the user's request. The event-driven architecture also provide some level of fault tolerance as consumers can fail, and messages can be replayed to retry any failed operations.</p>
<p><strong>Apache Kafka</strong> is an open source stream-processing platform. At its core, it is an event broker architected as a distributed transaction log. A full description of Apache Kafka is worthy of an entire book in itself—for a great introduction, I highly recommend reading the LinkedIn blog post that introduces Kafka (<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying</a>). The minimum you need to know to follow this recipe is that Kafka is a distributed event store that lets you publish messages to categories called <strong>topics</strong>. Another process can then consume messages from a topic and react to them.</p>
<p>Going back to our fictional messaging application, when a user sends a message to another user, we want to be able to notify the recipient in a number of ways. Depending on the recipient's preferences, we'll probably send an email or a push notification or both. In this recipe, we'll modify our message service from previous recipes to publish an event to a Kafka topic called <strong>messages</strong>. We'll then build a consumer application that listens for events in the message's topic and can react by sending the recipient notifications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Spring for Apache Kafka (<kbd>spring-kafka</kbd>) is a project that makes it easy to integrate Spring applications with Apache Kafka. It provides useful abstractions for sending and receiving messages.</p>
<p>Note that to follow the steps in this recipe, you will need to have a version of Kafka and ZooKeeper running and accessible. Installing and configuring these two pieces of software is beyond the scope of this recipe, so please visit the respective project websites and follow their wonderfully written guides on getting started. In this recipe, we'll assume that you have Kafka running a single broker on port <kbd>9092</kbd> and a single instance of ZooKeeper running on port <kbd>2181</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message producer</h1>
                </header>
            
            <article>
                
<ol>
<li>Open the <kbd>message-service</kbd> project from previous recipes. Modify the <kbd>build.gradle</kbd> file and add the <kbd>spring-kafka</kbd> project to the list of dependencies:</li>
</ol>
<pre style="color: black;padding-left: 60px">dependencies {<br/>    compile group: 'org.springframework.kafka', name: 'spring-kafka', version: '2.1.1.RELEASE'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter-web'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>The <kbd>spring-kafka</kbd> project provides a template for sending messages to a Kafka broker. To use the template in our project, we'll need to create a <kbd>ProducerFactory</kbd> interface and provide it to the constructor of the template.</li>
<li>Open the <kbd>Application.java</kbd> file and add the following content. Note that we're hardcoding the network location of the Kafka broker here—in a real application, you'd at least place this value in some kind of configuration (preferably respecting 12 factor conventions):</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.message;<br/><br/>import org.apache.kafka.clients.producer.ProducerConfig;<br/>import org.apache.kafka.common.serialization.StringSerializer;<br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.kafka.core.DefaultKafkaProducerFactory;<br/>import org.springframework.kafka.core.KafkaTemplate;<br/>import org.springframework.kafka.core.ProducerFactory;<br/><br/>import java.util.HashMap;<br/>import java.util.Map;<br/><br/>@SpringBootApplication<br/>@EnableAsync<br/>public class Application {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/><br/>    @Bean<br/>    public Map&lt;String, Object&gt; producerConfigs() {<br/>        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();<br/>        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");<br/>        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);<br/>        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);<br/>        return props;<br/>    }<br/><br/>    @Bean<br/>    public ProducerFactory&lt;Integer, String&gt; producerFactory() {<br/>        return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());<br/>    }<br/><br/>    @Bean<br/>    public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() {<br/>        return new KafkaTemplate&lt;Integer, String&gt;(producerFactory());<br/>    }<br/>}</pre>
<ol start="4">
<li>Now that we can use <kbd>KafkaTemplate</kbd> in our application, add one to the <kbd>MessageController</kbd> class. Also, use the Jackson <kbd>ObjectMapper</kbd> class to convert our <kbd>Message</kbd> instance into a JSON string that we'll publish to the Kafka topic. Open the <kbd>MessageController</kbd> class and add following fields:</li>
</ol>
<pre style="color: black;padding-left: 60px">...<br/>import org.springframework.kafka.core.KafkaTemplate;<br/>import com.fasterxml.jackson.databind.ObjectMapper;<br/>...<br/><br/><br/>@RestController<br/>public class MessageController {<br/><br/>    @Autowired<br/>    private KafkaTemplate kafkaTemplate;<br/><br/>    @Autowired<br/>    private ObjectMapper objectMapper;<br/><br/>    ...<br/>}</pre>
<ol start="5">
<li>Now that we have access to the Jackson <kbd>ObjectMapper</kbd> and the <kbd>KafkaTemplate</kbd> classes, create a method for publishing events. In this example, we're printing out to standard error and standard output. In a real application, you'd configure a logger, such as log4j, and use the appropriate log levels:</li>
</ol>
<pre style="color: black;padding-left: 60px">@RestController<br/>public class MessageController {<br/><br/>    ...<br/><br/>    private void publishMessageEvent(Message message) {<br/>        try {<br/>            String data = objectMapper.writeValueAsString(message);<br/>            ListenableFuture&lt;SendResult&gt; result = kafkaTemplate.send("messages", data);<br/>            result.addCallback(new ListenableFutureCallback&lt;SendResult&gt;() {<br/>                @Override<br/>                public void onFailure(Throwable ex) {<br/>                    System.err.println("Failed to emit message event: " + ex.getMessage());<br/>                }<br/><br/>                @Override<br/>                public void onSuccess(SendResult result) {<br/>                    System.out.println("Successfully published message event");<br/>                }<br/>            });<br/>        } catch (JsonProcessingException e) {<br/>            System.err.println("Error processing json: " + e.getMessage());<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>Add the following line to the <kbd>create</kbd> method, calling the previously created the <kbd>publishMessageEvent</kbd> method:</li>
</ol>
<pre style="color: black;padding-left: 60px">@RequestMapping(<br/>            path="/messages",<br/>            method=RequestMethod.POST,<br/>            produces="application/json")<br/>public ResponseEntity&lt;Message&gt; create(@RequestBody Message message) {<br/><br/>    ...<br/><br/>    publishMessageEvent(message);<br/>    return ResponseEntity.created(location).build();<br/>}</pre>
<ol start="7">
<li>To test this example, create a message topic using the <kbd>kafka-topics.sh</kbd> Kafka utility (packaged with the Kafka binary distribution), as follows:</li>
</ol>
<pre style="color: black;padding-left: 60px"><strong>bin/kafka-topics.sh --create \</strong><br/><strong>  --zookeeper localhost:2181 \</strong><br/><strong>  --replication-factor 1 --partitions 1 \</strong><br/><strong>  --topic messages</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message consumer</h1>
                </header>
            
            <article>
                
<p>Now that we're publishing message-send events, the next step is to build a small consumer application that can react to these events in our system. We'll discuss the scaffolding as it relates to Kafka in this recipe; implementing email and push notification functionality is left as an exercise for the reader:</p>
<ol>
<li>Create a new Gradle Java project called <kbd>message-notifier</kbd> with the following <kbd>build.gradle</kbd> file:</li>
</ol>
<pre style="color: black;padding-left: 60px">group 'com.packtpub.microservices'<br/>version '1.0-SNAPSHOT'<br/><br/>buildscript {<br/>    repositories {<br/>        mavenCentral()<br/>    }<br/>    dependencies {<br/>        classpath group: 'org.springframework.boot', name: 'spring-boot-gradle-plugin', version: '1.5.9.RELEASE'<br/>    }<br/>}<br/><br/>apply plugin: 'java'<br/>apply plugin: 'org.springframework.boot'<br/><br/>sourceCompatibility = 1.8<br/><br/>repositories {<br/>    mavenCentral()<br/>}<br/><br/>dependencies {<br/>    compile group: 'org.springframework.kafka', name: 'spring-kafka', version: '2.1.1.RELEASE'<br/>    compile group: 'org.springframework.boot', name: 'spring-boot-starter'<br/>    testCompile group: 'junit', name: 'junit', version: '4.12'<br/>}</pre>
<ol start="2">
<li>Create a new Java class called <kbd>Application</kbd> with the Spring Boot application boilerplate:</li>
</ol>
<pre style="color: black;padding-left: 60px">package com.packtpub.microservices.ch03.consumer;<br/><br/>import org.springframework.boot.SpringApplication;<br/>import org.springframework.boot.autoconfigure.SpringBootApplication;<br/><br/>@SpringBootApplication<br/>public class Application {<br/>    public static void main(String[] args) {<br/>        SpringApplication.run(Application.class, args);<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evolving APIs</h1>
                </header>
            
            <article>
                
<p>APIs are contracts between clients and servers. Backward-incompatible changes to APIs can cause unexpected errors for clients of the service. In a microservices architecture, precautions have to be taken to ensure that changes to a service's API do not unintentionally cause cascading problems throughout the system.</p>
<p>A popular approach is to version your API, either through the URL or via content negotiation in request headers. Because they're generally easier to work with, and often easier to cache, URL prefixes or query strings tend to be more common—in this case, the API endpoint is either prefixed with a version string (that is, <kbd>/v1/users</kbd>) or called with a query string parameter specifying a version or even a date (that is, <kbd>/v1/users?version=1.0 or /v1/users?version=20180122</kbd>).</p>
<p>With edge proxies or service mesh configurations, it's even possible to run multiple versions of software in an environment and route requests based on the URL to older or newer versions of a service. This changes the traditional life cycle of a service<span>–</span>you can safely decommission a version when it is no longer receiving any traffic. This can be useful, especially in the case of a public API where you have little control over clients.</p>
<p>Microservices are different than public APIs. The contract between clients and the server in a public API is much more long-lived. In a microservices architecture, it's easier to track down clients who are using your service and convince them to upgrade their code! Nevertheless, API versioning is sometimes necessary. Because being able to respond successfully to multiple versions of an API is a maintenance burden, we'd like to avoid it for as long as possible. To do this, there are a few practices that can be used to avoid making backward-incompatible changes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Using our example application, <kbd>pichat</kbd>, let's imagine that we want to change the name of the message body from <kbd>body</kbd> to <kbd>message_text</kbd>. This presents a problem because our message service is designed to accept the following requests:</li>
</ol>
<pre style="padding-left: 60px">GET /messages?user_id=123<br/>GET /messages/123<br/>POST /messages<br/>DELETE /messages/123</pre>
<ol start="2">
<li>In the case of the <kbd>GET</kbd> requests, the client will expect a JSON object with a field called <kbd>body</kbd> in the response. In the case of the <kbd>POST</kbd> request, clients will be sending payloads as the JSON objects with a field called <kbd>body</kbd>. We can't simply remove body because that would break existing clients, thus necessitating a change to the API version. Instead, we'll simply add the new field in addition to the old one, as follows:</li>
</ol>
<pre style="padding-left: 60px">{<br/>  "message": {<br/>    "from_user": "sender",<br/>    "to_user": "recipient",<br/>    "body": "Hello, there",<br/>    "message_text": "Hello, there"<br/>  }<br/>}</pre>
<ol start="3">
<li>Now you can gradually track down clients using these responses; once they've all been upgraded, you can safely remove the deprecated field from the JSON response.</li>
</ol>


            </article>

            
        </section>
    </body></html>