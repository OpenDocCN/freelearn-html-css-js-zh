["```js\nexport class Server { \n    // ... \n} \n\nexport class Client { \n    // ... \n} \n\n```", "```js\nexport * from './server'; \nexport * from './client'; \n\n```", "```js\nimport { Server, Client } from '../'; \n\n```", "```js\nexport interface DataStore { \n  timestamp: number; \n  data: string; \n} \n\n```", "```js\nclass Server { \n  store: DataStore = { \n    timestamp: 0, \n    data: '' \n  }; \n\n  getData(clientTimestamp: number): DataStore { \n    if (clientTimestamp < this.store.timestamp) { \n      return this.store; \n    } else { \n      return undefined; \n    } \n  } \n} \n\n```", "```js\nimport { Server, DataStore } from './'; \n\nexport class Client { \n  store: DataStore = { \n    timestamp: 0, \n    data: undefined \n  }; \n\n  constructor( \n    public server: Server \n  ) { } \n} \n\n```", "```js\nsynchronize(): void { \n  let updatedStore = this.server.getData(this.store.timestamp); \n\n  if (updatedStore) { \n    this.store = updatedStore; \n  } \n} \n\n```", "```js\nupdate(data: string): void { \n  this.store.data = data; \n  this.store.timestamp = Date.now(); \n} \n\n```", "```js\nsynchronize(clientDataStore: DataStore): DataStore { \n  if (clientDataStore.timestamp > this.store.timestamp) { \n      this.store = clientDataStore; \n      return undefined; \n  } else if (clientDataStore.timestamp < this.store.timestamp) { \n      return this.store; \n  } else { \n      return undefined; \n  } \n} \n\n```", "```js\ninterface DataStore { \n  timestamp: number; \n  data: string; \n} \n\ninterface DataSyncingInfo { \n  timestamp: number; \n  data: string; \n} \n\n```", "```js\nreturn { \n  timestamp: this.store.timestamp, \n  data: this.store.data \n}; \n\n```", "```js\nexport interface ServerDataItem { \n  id: string; \n  timestamp: number; \n  value: string; \n} \n\nexport interface ServerDataStore { \n  items: { \n    [id: string]: ServerDataItem; \n  }; \n} \n\n```", "```js\nexport interface ClientDataItem { \n  id: string; \n  value: string; \n} \n\nexport interface ClientDataStore { \n  timestamp: number; \n  items: { \n    [id: string]: ClientDataItem; \n  }; \n} \n\n```", "```js\nexport interface SyncingRequest { \n  timestamp: number; \n} \n\n```", "```js\nexport interface SyncingResponse { \n  timestamp: number; \n    changes: { \n      [id: string]: string; \n    }; \n} \n\n```", "```js\nsynchronize(request: SyncingRequest): SyncingResponse { \n  let lastTimestamp = request.timestamp; \n  let now = Date.now(); \n\n  let serverChanges: ServerChangeMap = Object.create(null); \n\n  return { \n    timestamp: now, \n    changes: serverChanges \n  }; \n} \n\n```", "```js\nlet items = this.store.items; \n\nfor (let id of Object.keys(items)) { \n  let item = items[id]; \n\n  if (item.timestamp > lastTimestamp) { \n    serverChanges[id] = item.value; \n  } \n} \n\n```", "```js\nstore: ClientDataStore = { \n  timestamp: 0, \n  items: Object.create(null) \n}; \n\n```", "```js\nsynchronize(): void { \n  let store = this.store; \n\n  let response = this.server.synchronize({ \n    timestamp: store.timestamp \n  }); \n} \n\n```", "```js\nlet clientItems = store.items;  \nlet serverChanges = response.changes; \n\nfor (let id of Object.keys(serverChanges)) { \n  clientItems[id] = { \n    id, \n    value: serverChanges[id] \n  }; \n} \n\n```", "```js\nclientStore.timestamp = response.timestamp; \n\n```", "```js\nexport interface ClientDataStore { \n  timestamp: number; \n  items: { \n    [id: string]: ClientDataItem; \n  }; \n  changed: { \n    [id: string]: number; \n  }; \n} \n\n```", "```js\nupdate(id: string, value: string): void { \n  let store = this.store; \n\n  store.items[id] = { \n    id, \n    value \n  }; \n\n  store.changed[id] = Date.now(); \n} \n\n```", "```js\nexport interface ClientChange { \n  lastModifiedTime: number; \n  value: string; \n} \n\nexport interface SyncingRequest { \n  timestamp: number; \n  changes: { \n    [id: string]: ClientChange; \n  }; \n} \n\n```", "```js\n          let clientItems = store.items; \n          let clientChanges: ClientChangeMap = Object.create(null); \n\n          let changedTimes = store.changed; \n\n          for (let id of Object.keys(changedTimes)) { \n            clientChanges[id] = { \n              lastModifiedTime: changedTimes[id], \n              value: clientItems[id].value \n            }; \n          } \n\n    ```", "```js\n          let response = this.server.synchronize({ \n            timestamp: store.timestamp, \n            clientTime: Date.now(), \n            changes: clientChanges \n          }); \n\n    ```", "```js\n          store.changed = Object.create(null); \n\n    ```", "```js\nexport interface ServerDataItem { \n    id: string; \n    timestamp: number; \n    lastModifiedTime: number; \n    value: string; \n} \n\n```", "```js\nlet clientChanges = request.changes; \nlet now = Date.now(); \n\nfor (let id of Object.keys(clientChanges)) { \n  let clientChange = clientChanges[id]; \n\n  if ( \n    hasOwnProperty.call(items, id) &&  \n    items[id].lastModifiedTime > clientChange.lastModifiedTime \n  ) { \n    continue; \n  } \n\n  items[id] = { \n    id, \n    timestamp: now, \n    lastModifiedTime, \n    value: clientChange.value \n  }; \n} \n\n```", "```js\nlet clientTimeOffset = now - request.clientTime; \n\n```", "```js\nlet lastModifiedTime = Math.min( \n  clientChange.lastModifiedTime + clientTimeOffset, \n  now \n); \n\nif ( \n  hasOwnProperty.call(items, id) &&  \n  items[id].lastModifiedTime > lastModifiedTime \n) { \n  continue; \n} \n\n```", "```js\nfor (let id of Object.keys(items)) { \n  let item = items[id]; \n\n  if ( \n    item.timestamp > lastTimestamp && \n    item.timestamp !== now \n  ) { \n    serverChanges[id] = item.value; \n  } \n} \n\n```", "```js\nexport interface ClientDataItem { \n  id: string; \n  value: any; \n} \n\n```", "```js\nexport interface ClientStringDataItem extends ClientDataItem { \n  value: string; \n} \n\nexport interface ClientNumberDataItem extends ClientDataItem { \n  value: number; \n} \n\n```", "```js\nexport interface ClientDataItem<T> { \n  id: string; \n  value: T; \n} \n\n```", "```js\nexport interface ClientDataStore { \n  items: { \n    [id: string]: ClientDataItem<number | string>; \n  }; \n} \n\n```", "```js\nconst enum ClientChangeIndex { \n  lastModifiedType, \n  value \n} \n\ntype ClientChange<T> = [number, T]; \n\nlet change: ClientChange<string> = [0, 'foo']; \nlet value = change[ClientChangeIndex.value]; \n\n```", "```js\ntype DataType = 'value' | 'increment'; \n\ninterface ClientChange { \n  type: DataType; \n} \n\ninterface ClientValueChange<T> extends ClientChange { \n  type: 'value'; \n  lastModifiedTime: number; \n  value: T; \n} \n\ninterface ClientIncrementChange extends ClientChange { \n  type: 'increment'; \n  uid: string; \n  increment: number; \n} \n\n```", "```js\nupdate(id: string, type: 'increment', increment: number): void; \nupdate<T>(id: string, type: 'value', value: T): void; \nupdate<T>(id: string, type: DataType, value: T): void; \nupdate<T>(id: string, type: DataType, value: T): void { \n  let store = this.store; \n\n  let items = store.items; \n  let storedChanges = store.changes; \n\n  if (type === 'value') { \n    // ... \n  } else if (type === 'increment') { \n    // ... \n  } else { \n    throw new TypeError('Invalid data type'); \n  } \n} \n\n```", "```js\nlet change: ClientValueChange<T> = { \n  type: 'value', \n  lastModifiedTime: Date.now(), \n  value \n}; \n\nstoredChanges[id] = change; \n\nif (hasOwnProperty.call(items, id)) { \n  items[id].value = value; \n} else { \n  items[id] = { \n    id, \n    type, \n    value \n  }; \n} \n\n```", "```js\nlet storedChange = storedChanges[id] as ClientIncrementChange; \n\nif (storedChange) { \n  storedChange.increment += <any>value as number; \n} else { \n  storedChange = { \n    type: 'increment', \n    uid: Date.now().toString(), \n    increment: <any>value as number \n  }; \n\n  storedChanges[id] = storedChange; \n} \n\n```", "```js\nif (hasOwnProperty.call(items, id)) { \n  items[id].value += value; \n} else { \n  items[id] = { \n    id, \n    type, \n    value \n  }; \n} \n\n```", "```js\ninterface ClientChangeList<T extends ClientChange> { \n  type: DataType; \n  changes: T[]; \n} \n\ninterface SyncingRequest { \n  timestamp: number; \n  changeLists: { \n    [id: string]: ClientChangeList<ClientChange>; \n  }; \n} \n\ninterface ClientIncrementChange extends ClientChange { \n  type: 'increment'; \n  synced: boolean; \n  uid: string; \n  increment: number; \n} \n\n```", "```js\nlet changeList = storedChangeLists[id]; \nlet changes = changeList.changes; \nlet lastChange = \n  changes[changes.length - 1] as ClientIncrementChange; \n\nif (lastChange.synced) { \n  changes.push({ \n    synced: false, \n    uid: Date.now().toString(), \n    increment: <any>value as number \n  } as ClientIncrementChange); \n} else { \n  lastChange.increment += <any>value as number; \n} \n\n```", "```js\nlet changeList = { \n  type: 'increment', \n  changes: [ \n    { \n      synced: false, \n      uid: Date.now().toString(), \n      increment: <any>value as number \n    } as ClientIncrementChange \n  ] \n}; \n\nstore.changeLists[id] = changeList; \n\n```", "```js\nfor (let id of Object.keys(clientChangeLists)) { \n  let clientChangeList = clientChangeLists[id]; \n\n  let type = clientChangeList.type; \n  let clientChanges = clientChangeList.changes; \n\n  if (type === 'value') { \n    // ... \n  } else if (type === 'increment') { \n    // ... \n  } else { \n    throw new TypeError('Invalid data type'); \n  } \n} \n\n```", "```js\nlet clientChange = changes[0] as ClientValueChange<any>; \n\n```", "```js\nlet item = items[id]; \n\nfor ( \n  let clientChange \n  of clientChanges as ClientIncrementChange[] \n) { \n  let { \n    uid, \n    increment \n  } = clientChange; \n\n  if (item.uids.indexOf(uid) < 0) { \n    item.value += increment; \n    item.uids.push(uid); \n  } \n} \n\n```", "```js\nlet item: ServerDataItem<any>; \n\nif (hasOwnProperty.call(items, id)) { \n  item = items[id]; \n  item.timestamp = now; \n} else { \n  item = items[id] = { \n    id, \n    type, \n    timestamp: now, \n    uids: [], \n    value: 0 \n  }; \n} \n\n```", "```js\nif ( \n  item.timestamp > lastTimestamp && \n  !hasOwnProperty.call(clientChangeLists, id) \n) { \n  serverChanges[id] = item.value; \n} \n\n```", "```js\nenum SetOperation { \n  add, \n  remove \n} \n\ninterface ClientSetChange extends ClientChange { \n  element: number; \n  time: number; \n  operation: SetOperation; \n} \n\n```", "```js\ninterface ServerSetElementOperationInfo { \n  operation: SetOperation; \n  time: number; \n} \n\n```", "```js\nupdate( \n  id: string, \n  type: 'set', \n  element: number, \n  operation: SetOperation \n): void; \nupdate<T>( \n  id: string, \n  type: DataType, \n  value: T, \n  operation?: SetOperation \n): void; \n\n```", "```js\nelse if (type === 'set') { \n  let element = <any>value as number; \n\n  if (hasOwnProperty.call(storedChangeLists, id)) { \n    // ... \n  } else { \n    // ... \n  } \n} \n\n```", "```js\nlet changeList = storedChangeLists[id]; \nlet changes = changeList.changes as ClientSetChange[]; \n\nfor (let i = 0; i < changes.length; i++) { \n  let change = changes[i]; \n\n  if (change.element === element) { \n    changes.splice(i, 1); \n    break; \n  } \n} \n\nchanges.push({ \n  element, \n  time: Date.now(), \n  operation \n}); \n\n```", "```js\nlet changeList: ClientChangeList<ClientSetChange> = { \n  type: 'set', \n  changes: [ \n    { \n      element, \n      time: Date.now(), \n      operation \n    } \n  ] \n}; \n\nstoredChangeLists[id] = changeList; \n\n```", "```js\nelse if (type === 'set') { \n  let item: ServerDataItem<{ \n    [element: string]: ServerSetElementOperationInfo; \n  }>; \n\n  delete clientChangeLists[id]; \n} \n\n```", "```js\nif (item.type === 'set') { \n  let operationInfos: { \n    [element: string]: ServerSetElementOperationInfo; \n  } = item.value; \n\n  serverChanges[id] = Object \n    .keys(operationInfos) \n    .filter(element => \n      operationInfos[element].operation === \n        SetOperation.add \n    ) \n    .map(element => Number(element)); \n} else { \n  serverChanges[id] = item.value; \n} \n\n```", "```js\ninterface ClientChangeStrategy<T extends ClientChange> { \n  append(list: ClientChangeList<T>, change: T): void; \n  apply(item: ClientDataItem<any>, change: T): void; \n} \n\n```", "```js\nlet strategy: ClientChangeStrategy<ClientValueChange<any>> = {  \n  append(list, change) { \n    list.changes = [change]; \n  }, \n  apply(item, change) { \n    item.value = change.value; \n  } \n}; \n\n```", "```js\nlet changes = list.changes; \nlet lastChange = changes[changes.length]; \n\nif (!lastChange || lastChange.synced) { \n  changes.push(change); \n} else { \n  lastChange.increment += change.increment; \n} \n\n```", "```js\nif (item.value === undefined) { \n  item.value = change.increment; \n} else { \n  item.value += change.increment; \n} \n\n```", "```js\nexport class ServerStore { \n  private items: { \n    [id: string]: ServerDataItem<any>; \n  } = Object.create(null); \n} \n\nexport class Server { \n  constructor( \n    public store: ServerStore \n  ) { } \n} \n\n```", "```js\nget<T, TExtra extends ServerDataItemExtra>(id: string): \n  ServerDataItem<T> & TExtra { \n  return hasOwnProperty.call(this.items, id) ? \n    this.items[id] as ServerDataItem<T> & TExtra : undefined; \n} \n\nset<T, TExtra extends ServerDataItemExtra>( \n  id: string, \n  item: ServerDataItem<T> & Textra \n): void { \n  this.items[id] = item; \n} \n\ngetAll<T, TExtra extends ServerDataItemExtra>(): \n  (ServerDataItem<T> & TExtra)[] { \n  let items = this.items; \n  return Object \n    .keys(items) \n    .map(id => items[id] as ServerDataItem<T> & TExtra); \n} \n\n```"]