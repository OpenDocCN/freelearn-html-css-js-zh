- en: Appendix B. Precompiling Templates on the Server Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 服务器端预编译模板
- en: In [Chapter 2](ch02.html "Chapter 2. Working with Views"), *Working with Views*,
    we learned the advantages of using precompiled templates in your application.
    In addition, we saw a number of options to store your templates as inline in the
    `index.html` file or as separate template files. We also saw how we can use a
    template manager to precompile and cache templates to avoid compilation overhead
    every time. However, this precompilation process will run anyway when you start
    your application, which will surely take a certain period of time. Wait! Aren't
    these templates static resources? Then the compiled versions of the templates
    without data will also be static resources. Right? Then why not keep a separate
    file with all of the precompiled templates ready and use it as soon as your application
    starts? If you get a file with all of your templates already precompiled and minified,
    it will certainly boost your application's performance. This is what we will try
    here—we will develop a script to precompile the templates on the server side,
    which will traverse all of the template files and create a single template manager
    file. We use Node.js here, but you can use any server-side technology to get the
    same result. The complete working code is given in our code samples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html "第二章. 使用视图")中，我们学习了在应用程序中使用预编译模板的优势。此外，我们还看到了将模板存储在`index.html`文件中作为内联或作为单独的模板文件的一些选项。我们还看到了如何使用模板管理器预编译和缓存模板以避免每次编译的开销。然而，这个预编译过程仍然会在你启动应用程序时运行，这肯定会占用一定的时间。等等！这些模板不是静态资源吗？那么没有数据的模板编译版本也将是静态资源。对吧？那么为什么不保留一个包含所有预编译模板的单独文件，并在应用程序启动时立即使用它呢？如果你得到一个包含所有模板已经预编译和压缩的文件，它肯定会提高你的应用程序性能。这正是我们在这里要尝试的——我们将开发一个脚本在服务器端预编译模板，它将遍历所有模板文件并创建一个单独的模板管理器文件。在这里我们使用Node.js，但你也可以使用任何服务器端技术来得到相同的结果。完整的代码示例在代码样本中给出。
- en: 'To precompile, we need a template engine with precompilation support. We will
    use Underscore.js here, but you are free to use your desired template engine to
    achieve the result. The following Node.js example shows you how to achieve this
    functionality:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预编译，我们需要一个支持预编译的模板引擎。在这里我们将使用Underscore.js，但你也可以自由选择你想要的模板引擎来实现相同的结果。以下Node.js示例展示了如何实现这个功能：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is pretty self-explanatory. We created a complete JavaScript
    snippet as a string that will be returned to the frontend. Here are the steps
    to do so:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当直观。我们创建了一个完整的JavaScript代码片段作为字符串，并将其返回到前端。以下是完成此操作的步骤：
- en: First, we browse through each template file in the `templates` directory and
    retrieve their contents.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们浏览`templates`目录中的每个模板文件并检索其内容。
- en: We already have an object `Templates.cachedTemplates` defined and we need to
    store each template file's contents in this object with the template filename
    as a property and the template string as its value.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了一个对象`Templates.cachedTemplates`，我们需要将每个模板文件的 内容存储在这个对象中，以模板文件名作为属性，模板字符串作为其值。
- en: 'Underscore''s `_.template()` method, in general, returns a function. It also
    provides a property called `source` that gives the textual representation of that
    particular function. The following line will give you the function source code:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Underscore的`_.template()`方法通常返回一个函数。它还提供了一个名为`source`的属性，它提供了该特定函数的文本表示。以下行将给出函数的源代码：
- en: '[PRE1]'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We place all of the function strings inside `Templates.cachedTemplates` one
    by one, and once the loop is over, we write the entire contents to another JavaScript
    file.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有的函数字符串逐个放入`Templates.cachedTemplates`中，一旦循环结束，我们就将整个内容写入另一个JavaScript文件。
- en: 'Now assume that the client side is asking for the `templates.js` file that
    contains the complete template content of the project. On the server side, we
    can write the following code that will send the `compiled.js` file content to
    the browser:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设客户端请求包含项目完整模板内容的`templates.js`文件。在服务器端，我们可以编写以下代码，将`compiled.js`文件的内容发送到浏览器：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, a request to the `template.js` file on the client side will display content
    similar to the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端对`template.js`文件的请求将显示类似于以下代码的内容：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final output is the `TemplateManager` object with the template's filename
    as its property and the compiled version of the template as the value of that
    property. This way, all of your template files will get added to the `TemplateManager`
    object. However, for this piece of code, you need to make sure that each template's
    filename is different. Otherwise, the template of the files with the same name
    will get overwritten by another.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最终输出是一个`TemplateManager`对象，其属性为模板的文件名，属性值为模板的编译版本。这样，你所有的模板文件都将被添加到`TemplateManager`对象中。然而，对于这段代码，你需要确保每个模板的文件名是不同的。否则，同名文件的模板将被另一个模板覆盖。
- en: 'You do not need to understand this compiled template function definition, as
    this will be used internally by the library. Be assured that once you call this
    function with the data object, you will get the proper HTML output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要理解这个编译后的模板函数定义，因为这个函数将在库内部使用。请放心，一旦你用数据对象调用这个函数，你将得到正确的HTML输出：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This solution for precompiling JavaScript templates is very effective and you
    can use the same concept freely in your projects. We have used this concept in
    multiple projects successfully.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种预编译JavaScript模板的解决方案非常有效，你可以在你的项目中自由地使用这个概念。我们已经成功地在多个项目中使用了这个概念。
