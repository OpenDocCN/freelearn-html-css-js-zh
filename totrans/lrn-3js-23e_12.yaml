- en: Chapter 12. Adding Physics and Sounds to Your Scene
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章：向场景添加物理和声音
- en: In this final chapter, we'll look at Physijs, another library you can use to
    extend the basic functionality of Three.js. Physijs is a library that allows you
    to introduce physics into your 3D scene. By physics, we mean that your objects
    are subject to gravity, they can collide with each other, can be moved by applying
    impulse, and can be constrained in their movement through hinges and sliders.
    This library internally makes use of another well-known physics engine called
    **ammo.js**. Besides physics, we'll also look at how Three.js can help you with
    adding spatial sounds to your scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将探讨Physijs，这是另一个可以用来扩展Three.js基本功能的库。Physijs是一个允许你将物理引入3D场景的库。通过物理，我们指的是你的物体受到重力作用，可以相互碰撞，可以通过施加冲量移动，并且可以通过铰链和滑块限制其运动。这个库内部使用了一个名为**ammo.js**的知名物理引擎。除了物理之外，我们还将探讨Three.js如何帮助你向场景添加空间声音。
- en: 'In this chapter, we''ll discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Creating a Physijs scene where your objects are subject to gravity and can collide
    with each other
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Physijs场景，其中你的物体受到重力作用并且可以相互碰撞
- en: Showing how to change the friction and restitution (bounciness) of the objects
    in the scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何更改场景中物体的摩擦力和恢复（弹性）系数
- en: Explaining the various shapes supported by Physijs and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Physijs支持的形状及其使用方法
- en: Showing how to create compound shapes by combining simple shapes together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何通过组合简单形状来创建复合形状
- en: Showing how a height field allows you to simulate a complex shape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示高度场如何允许你模拟复杂形状
- en: Limiting the movement of an object by applying a point, hinge, slider, and cone
    twist, and the 'degree of freedom' constraint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用点、铰链、滑块和圆锥扭曲以及“自由度”约束来限制物体的运动
- en: Adding sound sources to your scene whose sound volume and direction is based
    on their distance to the camera.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加声音源，其声音大小和方向基于它们与摄像机的距离。
- en: The first thing we will do is create a Three.js scene that can be used with
    Physijs. We'll do that in our first example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是创建一个可以与Physijs一起使用的Three.js场景。我们将在第一个示例中完成这个任务。
- en: Creating a basic Three.js scene
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的Three.js场景
- en: 'Setting up a Three.js scene for Physijs is very simple and only takes a couple
    of steps. The first thing we need to do is include the correct JavaScript file,
    which you can get from the GitHub repository at [http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/).
    Add the Physijs library to your HTML page like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Physijs的Three.js场景非常简单，只需几个步骤。我们首先需要做的是包含正确的JavaScript文件，你可以从GitHub仓库[http://chandlerprall.github.io/Physijs/](http://chandlerprall.github.io/Physijs/)获取。将Physijs库添加到你的HTML页面中，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simulating a scene is rather processor intensive. If we run all the simulation
    computations on the render thread (since JavaScript is single threaded in nature),
    it will seriously affect the frame rate of our scene. To compensate for that,
    Physijs does its calculations in a background thread. This background thread is
    provided through the "web workers" specification that is implemented by most modern
    browsers. With this specification, you can run CPU-intensive tasks in a separate
    thread, thus not affecting the rendering. More information on web workers can
    be found at [http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟场景相对处理器来说比较密集。如果我们把所有的模拟计算都在渲染线程上运行（因为JavaScript本质上是单线程的），这将严重影响我们场景的帧率。为了补偿这一点，Physijs在其后台线程中进行计算。这个后台线程是通过大多数现代浏览器实现的“web
    workers”规范提供的。通过这个规范，你可以在单独的线程中运行CPU密集型任务，从而不会影响渲染。有关web workers的更多信息，可以在[http://www.w3.org/TR/workers/](http://www.w3.org/TR/workers/)找到。
- en: For Physijs, this means we have to configure the JavaScript file that contains
    this worker task and also tell Physijs where it can find the ammo.js file needed
    to simulate our scene. The reason we need to include the ammo.js file is that
    Physijs is a wrapper around ammo.js to make it easy to use. Ammo.js (which you
    can find at [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/))
    is the library that implements the physics engine; Physijs just provides an easy-to-use
    interface to this physics library. Since Physijs is just a wrapper, we can also
    use other physics engines together with Physijs. On the Physijs repository, you
    can also find a branch that uses Cannon.js, a different physics engine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Physijs 来说，这意味着我们必须配置包含此工作任务的 JavaScript 文件，并告诉 Physijs 它可以在哪里找到用于模拟场景所需的
    ammo.js 文件。我们需要包含 ammo.js 文件的原因是 Physijs 是围绕 ammo.js 的包装器，以便更容易使用。Ammo.js（你可以在
    [https://github.com/kripken/ammo.js/](https://github.com/kripken/ammo.js/) 找到）是实现物理引擎的库；Physijs
    只提供了对这个物理库的易于使用的接口。由于 Physijs 只是一个包装器，我们也可以将其他物理引擎与 Physijs 一起使用。在 Physijs 仓库中，你还可以找到一个使用
    Cannon.js（一个不同的物理引擎）的分支。
- en: 'To configure Physijs, we have to set the following two properties:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Physijs，我们必须设置以下两个属性：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first property points to the worker tasks we want to execute, and the second
    property points to the ammo.js library that is used internally. The next step
    we need to perform is create a scene. Physijs provides a wrapper around the Three.js
    normal scene, so in your code, you do the following to create a scene:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性指向我们想要执行的工作任务，第二个属性指向内部使用的 ammo.js 库。我们需要执行的下一步是创建一个场景。Physijs 提供了围绕 Three.js
    正常场景的包装器，因此在你的代码中，你将执行以下操作来创建一个场景：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a new scene where physics is applied, and we set the gravity. In
    this case, we set the gravity on the *y* axis to be `-10`. In other words, objects
    fall straight down. You can set, or change at runtime, the gravity for the various
    axes to any value you see fit, and the scene will respond accordingly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的场景，其中应用了物理效果，并且我们设置了重力。在这种情况下，我们将 *y* 轴的重力设置为 `-10`。换句话说，物体会直接向下落。你可以设置或更改运行时的重力，使其适用于各个轴的任何值，场景将相应地做出反应。
- en: 'Before we can start simulating the physics in the scene, we need to add some
    objects. For this, we can use the normal way Three.js specifies objects, but we
    have to wrap them inside a specific Physijs object so that they can be managed
    by the Physijs library, as you can see in the following code fragment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始模拟场景中的物理效果之前，我们需要添加一些物体。为此，我们可以使用 Three.js 指定物体的常规方式，但我们必须将它们包裹在一个特定的 Physijs
    物体中，以便它们可以被 Physijs 库管理，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we create a simple `THREE.BoxGeometry` object. Instead of creating
    `THREE.Mesh`, we create `Physijs.BoxMesh`, which tells Physijs to treat the shape
    of the geometry as a box when simulating physics and detecting collisions. Physijs
    provides a number of meshes you can use for the various shapes. More information
    on the available shapes can be found later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个简单的 `THREE.BoxGeometry` 对象。我们不是创建 `THREE.Mesh`，而是创建 `Physijs.BoxMesh`，这告诉
    Physijs 在模拟物理和检测碰撞时将几何形状视为一个盒子。Physijs 提供了多种网格，你可以用于各种形状。有关可用形状的更多信息，请参阅本章后面的内容。
- en: 'Now that `THREE.BoxMesh` has been added to the scene, we have all the ingredients
    for the first Physijs scene. All that is left to do is tell Physijs to simulate
    the physics and update the position and rotation of the objects in our scene.
    We can do this by calling the simulate method on the scene we just created. So,
    for this, we change our basic render loop to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`THREE.BoxMesh` 已经被添加到场景中，我们拥有了创建第一个 Physijs 场景的所有要素。剩下的唯一要做的事情就是告诉 Physijs
    模拟物理效果并更新场景中物体的位置和旋转。我们可以通过在刚刚创建的场景上调用 simulate 方法来实现这一点。因此，为了这个目的，我们将基本的渲染循环更改为以下内容：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And with that final step, by calling `scene.simulate()`, we have our basic setup
    for a Physijs scene. If we would run this example, though, we wouldn't see much.
    We would just see a single cube in the middle of the screen, which starts falling
    down as soon as the scene renders. So, let's look at a more complex example, where
    we'll simulate dominos falling down.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行最后的步骤，通过调用 `scene.simulate()`，我们为 Physijs 场景设置了基本设置。如果我们运行这个示例，尽管如此，我们也不会看到太多。我们只会看到一个位于屏幕中央的单个立方体，一旦场景渲染，它就会立即开始下落。所以，让我们看看一个更复杂的示例，我们将模拟多米诺骨牌的下落。
- en: 'For this example, we''re going to create the following scene:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将创建以下场景：
- en: '![Creating a basic Three.js scene](img/2215OS_12_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本的 Three.js 场景](img/2215OS_12_01.jpg)'
- en: 'If you open the `01-basic-scene.html` example in your browser, you''ll see
    a set of domino stones that start falling down as soon as the scene is loaded.
    The first one will tip over the second one, and so on. The complete physics of
    this scene is managed by Physijs. The only thing we did to start this animation
    is tip over the first domino. Creating this scene is actually very easy and only
    takes a few steps, which are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开`01-basic-scene.html`示例，您将看到一组多米诺骨牌，一旦场景加载，它们就会开始倒下。第一个会翻倒第二个，以此类推。这个场景的完整物理效果由Physijs管理。我们为了启动这个动画所做的唯一一件事就是翻倒第一个多米诺骨牌。实际上创建这个场景非常简单，只需几个步骤，如下所示：
- en: Define a Physijs scene.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Physijs场景。
- en: Define the ground area that holds the stones.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义放置石头的地面区域。
- en: Place the stones.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置石头。
- en: Tip over the first stone.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻倒第一块石头。
- en: 'Let''s skip this first step since we''ve already seen how to do this and go
    directly to the second step, where we define the sandbox that contains all the
    stones. This sandbox is constructed out of a couple of boxes that are grouped
    together. The following is the code required to accomplish this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过这个第一步，因为我们已经看到了如何做，直接进入第二步，即定义包含所有石头的沙盒。这个沙盒是由几个组合在一起的盒子构成的。以下是需要完成此任务的代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code isn't very complicated. First, we create a simple box that serves
    as the ground plane, and next we add a couple of borders to prevent objects falling
    off this ground plane. We add these borders to the ground object to create a compound
    object. This is an object that is treated by Physijs as a single object. There
    are a couple of other new things in this code that we'll explain in more depth
    in the following sections. The first one is `ground_material`, which we create.
    We use the `Physijs.createMaterial` function to create this material. This function
    wraps a standard Three.js material but allows us to set `friction` and `restitution`
    (bounciness) of the material. More on this can be found in the next section. Another
    new aspect is the final parameter we add to the `Physijs.BoxMesh` constructor.
    For all the `BoxMesh` objects we create in this section, we add `0` as the final
    parameter. With this parameter, we set the weight of the object. We do this to
    prevent the ground from being subject to the gravity in the scene so that it doesn't
    fall down.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不复杂。首先，我们创建一个简单的盒子，作为地面平面，然后我们添加一些边界，以防止物体从这个地面平面上掉落。我们将这些边界添加到地面对象中，以创建一个复合对象。这是一个Physijs将其视为单个对象的对象。在这段代码中还有一些其他的新内容，我们将在接下来的章节中深入解释。第一个是新创建的`ground_material`，我们使用`Physijs.createMaterial`函数创建这个材质。这个函数包装了一个标准的Three.js材质，但允许我们设置材质的`friction`和`restitution`（弹性）。更多关于这一点的内容将在下一节中介绍。另一个新方面是我们添加到`Physijs.BoxMesh`构造函数的最后一个参数。在本节中我们创建的所有`BoxMesh`对象中，我们添加`0`作为最后一个参数。使用这个参数，我们设置物体的重量。我们这样做是为了防止地面受到场景中的重力影响，以免它掉落。
- en: 'Now that we have the ground, we can place the dominos. For this, we create
    simple `Three.BoxGeometry` instances that we wrap inside `BoxMesh` and place them
    at a specific position on top of the ground mesh, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了地面，我们可以放置多米诺骨牌。为此，我们创建简单的`Three.BoxGeometry`实例，并将它们包装在`BoxMesh`中，放置在地面网格的特定位置，如下所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We don't show the code where the position of each domino is calculated (see
    the `getPoints()` function in the source code of the example for this); this code
    just shows how the dominos are positioned. What you can see here is that we once
    again create `BoxMesh`, which wraps `THREE.BoxGeometry`. To make sure the dominos
    are aligned correctly, we use the `lookAt` function to set their correct rotation.
    If we don't do this, they'll all face the same way and won't fall down. We have
    to make sure that after we manually update the rotation (or the position) of a
    Physijs wrapped object, we tell Physijs that something has changed so that Physijs
    can update it's own internal representation of all the objects in the scene. For
    the rotation, we can do this with the internal `__dirtyRotation` property, and
    for the position, we set `__dirtyPosition` to `true`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有展示计算每个多米诺骨牌位置的代码（请参阅示例源代码中的`getPoints()`函数以了解此内容）；此代码仅显示多米诺骨牌是如何定位的。您在这里可以看到的是，我们再次创建了`BoxMesh`，它包装了`THREE.BoxGeometry`。为了确保多米诺骨牌正确对齐，我们使用`lookAt`函数来设置它们的正确旋转。如果我们不这样做，它们都会朝同一个方向，并且不会倒下。我们必须确保在手动更新Physijs包装对象的旋转（或位置）之后，我们告诉Physijs某些内容已更改，以便Physijs可以更新场景中所有对象的内部表示。对于旋转，我们可以使用内部的`__dirtyRotation`属性，而对于位置，我们将`__dirtyPosition`设置为`true`。
- en: 'Now all that is left to do is tip the first domino. We do this by just setting
    the rotation on the *x* axis to 0.2, which tips it slightly. The gravity in the
    scene will do the rest and completely tip over the first domino. Here''s how we
    tip the first domino:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是推动第一张多米诺骨牌。我们通过将*x*轴的旋转设置为0.2来实现这一点，这会使它略微倾斜。场景中的重力将完成剩下的工作，并将第一张多米诺骨牌完全倒下。以下是推动第一张多米诺骨牌的方法：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This completes the first example, which already shows a lot of features from
    Physijs. If you want to play around with the gravity, you can change it through
    the menu in the top-right corner. The change to the gravity is applied when you
    push the **resetScene** button:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了第一个示例，它已经展示了Physijs的许多功能。如果你想玩转重力，你可以通过右上角的菜单来改变它。当你按下**resetScene**按钮时，重力改变将被应用：
- en: '![Creating a basic Three.js scene](img/2215OS_12_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建基本的Three.js场景](img/2215OS_12_02.jpg)'
- en: In the next section, we'll have a closer look at how the Physijs material properties
    affect the objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地探讨Physijs材料属性如何影响物体。
- en: Material properties
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料属性
- en: 'Let''s begin with an explanation of the example. When you open up the `02-material-properties.html`
    example, you''ll see an empty box somewhat similar to the previous example. This
    box is rotating up and down around its *x* axis. In the menu in the top-right
    corner, you have several sliders that can be used to change some of the material
    properties of Physijs. These properties apply to the cubes and spheres you can
    add with the **addCubes** and **addSpheres** buttons. When you press the **addSpheres**
    button, five spheres will be added to the scene, and when you press the **addCubes**
    button, five cubes will be added. The following is an example demonstrating friction
    and restitution:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对示例的解释开始。当你打开`02-material-properties.html`示例时，你会看到一个空箱子，它有点类似于之前的示例。这个箱子正在围绕其*x*轴上下旋转。在右上角的菜单中，有几个滑块可以用来改变Physijs的一些材料属性。这些属性适用于你可以通过**addCubes**和**addSpheres**按钮添加的立方体和球体。当你按下**addSpheres**按钮时，场景中会添加五个球体，当你按下**addCubes**按钮时，会添加五个立方体。以下是一个演示摩擦和弹性的示例：
- en: '![Material properties](img/2215OS_12_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![材料属性](img/2215OS_12_03.jpg)'
- en: 'This example allows you to play around with the `restitution` (bounciness)
    and `friction` properties that you can set when you create a Physijs material.
    If, for example, you set **cubeFriction** all the way to `1` and add some cubes,
    you''ll see that, even though the ground is moving, the cubes barely move. If
    you set **cubeFriction** to **0**, you''ll notice the cubes sliding around as
    soon as the ground stops being level. The following screenshot shows that high
    friction allows cubes to resist gravity:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例允许你玩转在创建Physijs材料时可以设置的`restitution`（弹性）和`friction`（摩擦）属性。例如，如果你将**cubeFriction**设置为最大值`1`并添加一些立方体，你会发现，即使地面在移动，立方体几乎不动。如果你将**cubeFriction**设置为**0**，你会发现立方体在地面停止水平时立即滑动。以下截图显示了高摩擦力允许立方体抵抗重力：
- en: '![Material properties](img/2215OS_12_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![材料属性](img/2215OS_12_04.jpg)'
- en: The other property you can set in this example is the `restitution` property.
    The `restitution` property defines how much of the energy that an object possesses
    is restituted when it collides. In other words, high restitution creates a bouncy
    object, and low restitution results in an object that stops immediately when it
    hits another object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以设置的另一个属性是`restitution`属性。`restitution`属性定义了物体在碰撞时有多少能量被恢复。换句话说，高恢复力创建了一个弹跳物体，而低恢复力会导致物体在撞击另一个物体时立即停止。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When you use a physics engine, you normally don't have to worry about detecting
    collisions. The engine will take care of that. It is, however, sometimes very
    useful to be informed when a collision between two objects occurs. For instance,
    you might want to create a sound effect, or when creating a game, deduct a life.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用物理引擎时，你通常不需要担心检测碰撞。引擎会处理这个问题。然而，有时在两个物体发生碰撞时得到通知是非常有用的。例如，你可能想创建一个声音效果，或者当创建游戏时扣除生命值。
- en: 'With Physijs, you can add an event listener to a Physijs mesh, as shown in
    the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Physijs，你可以给一个Physijs网格添加事件监听器，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, you'll be informed whenever this mesh collides with another of the
    meshes handled by Physijs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当这个网格与Physijs处理的另一个网格发生碰撞时，你都会得到通知。
- en: A good way to demonstrate this is using spheres, setting the restitution to
    `1`, and clicking on the **addSpheres** button a couple of times. This will create
    a number of spheres that bounce everywhere.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个演示这个功能的好方法是使用球体，将恢复系数设置为`1`，然后点击几次**addSpheres**按钮。这将创建多个球体，它们会在各个地方弹跳。
- en: 'Before we move on to the next section, let''s look at a bit of code used in
    this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们看看在这个示例中使用的部分代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the code that gets executed when we add spheres to the scene. This
    time, we use a different Physijs mesh: `Physijs.SphereMesh`. We''re creating `THREE.SphereGeometry,`
    and the best match from the set of meshes provided is, logically, `Physijs.SphereMesh`
    (more on this in the next section). When we create `Physijs.SphereMesh`, we pass
    in our geometry and use `Physijs.createMaterial` to create a Physijs-specific
    material. We do this so that we can set `friction` and `restitution` for this
    object.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们向场景中添加球体时执行的代码。这次，我们使用了一个不同的Physijs网格：`Physijs.SphereMesh`。我们创建`THREE.SphereGeometry`，从提供的网格集中，逻辑上最佳匹配的是`Physijs.SphereMesh`（关于这一点将在下一节中详细介绍）。当我们创建`Physijs.SphereMesh`时，我们传递我们的几何形状并使用`Physijs.createMaterial`创建一个Physijs特定的材质。我们这样做是为了能够设置此对象的`friction`和`restitution`。
- en: Until now, we've seen `BoxMesh` and `SphereMesh`. In the next section, we'll
    explain and show the different types of meshes provided by Physijs that you can
    use to wrap your geometries.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了`BoxMesh`和`SphereMesh`。在下一节中，我们将解释并展示Physijs提供的不同类型的网格，您可以使用这些网格来包裹您的几何形状。
- en: Basic supported shapes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本支持的形状
- en: Physijs provides a number of shapes you can use to wrap your geometries. In
    this section, we'll walk you through all the available Physijs meshes and demonstrate
    these meshes through an example. Remember that all you have to do to use these
    meshes is replace the `THREE.Mesh` constructor with one of these meshes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Physijs提供了一些形状，您可以使用这些形状来包裹您的几何形状。在本节中，我们将带您了解所有可用的Physijs网格，并通过示例演示这些网格。请记住，您要使用这些网格，只需将`THREE.Mesh`构造函数替换为这些网格之一即可。
- en: 'The following table provides an overview of the meshes that are available in
    Physijs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了Physijs中可用的网格概览：
- en: '| Name | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Physijs.PlaneMesh` | This mesh can be used to create a zero-thickness plane.
    You could also use `BoxMesh` for this together with `THREE.BoxGeometry` with low
    height. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.PlaneMesh` | 此网格可用于创建零厚度的平面。您也可以使用`BoxMesh`与`THREE.BoxGeometry`配合，并使用低高度来实现这一点。|'
- en: '| `Physijs.BoxMesh` | If you have geometries that look like cubes, use this
    mesh. For instance, this is a good match for `THREE.BoxGeometry`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.BoxMesh` | 如果您有看起来像立方体的几何形状，请使用此网格。例如，这对于`THREE.BoxGeometry`来说是一个很好的匹配。|'
- en: '| `Physijs.SphereMesh` | For sphere shapes, use this geometry. This geometry
    is a good match for `THREE.SphereGeometry`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.SphereMesh` | 对于球体形状，使用此几何形状。此几何形状与`THREE.SphereGeometry`相匹配。|'
- en: '| `Physijs.CylinderMesh` | With `THREE.Cylinder`, you can create various cylinder-like
    shapes. Physijs provides multiple meshes depending on the shape of the cylinder.
    `Physijs.CylinderMesh` should be used for a normal cylinder with the same top
    radius and bottom radius. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.CylinderMesh` | 使用`THREE.Cylinder`，您可以创建各种类似圆柱体的形状。Physijs根据圆柱体的形状提供多个网格。对于具有相同顶部半径和底部半径的普通圆柱体，应使用`Physijs.CylinderMesh`。|'
- en: '| `Physijs.ConeMesh` | If you specify the top radius as `0` and use a positive
    value for the bottom radius, you can use `THREE.Cylinder` to create a cone. If
    you want to apply physics to such an object, the best fit from Physijs is `ConeMesh`.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.ConeMesh` | 如果您将顶部半径指定为`0`并使用正值的底部半径，您可以使用`THREE.Cylinder`来创建一个圆锥体。如果您想将物理效果应用于此类对象，Physijs的最佳选择是`ConeMesh`。|'
- en: '| `Physijs.CapsuleMesh` | A capsule is just like `THREE.Cylinder`, but with
    a rounded top and a rounded bottom. We''ll show you how to create a capsule in
    Three.js later on in this section. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.CapsuleMesh` | 胶囊就像`THREE.Cylinder`，但顶部和底部都是圆形的。我们将在本节的稍后部分向您展示如何在Three.js中创建胶囊。|'
- en: '| `Physijs.ConvexMesh` | `hysijs.ConvexMesh` is a rough shape you can use for
    more complex objects. It creates a convex (just like `THREE.ConvexGeometry`) to
    approximate the shape of complex objects. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.ConvexMesh` | `Physijs.ConvexMesh`是一个可以用于更复杂对象的粗糙形状。它创建一个凸形（就像`THREE.ConvexGeometry`），以近似复杂对象的形状。|'
- en: '| `Physijs.ConcaveMesh` | While `ConvexMesh` is a rough shape, `ConcaveMesh`
    is a more detailed representation of your complex geometry. Note that the performance
    penalty of using `ConcaveMesh` is very high. Usually, it is better to either create
    separate geometries with their own specific Physijs meshes or group them together
    (as we do with the floors shown in the previous examples). |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.ConcaveMesh` | 虽然 `ConvexMesh` 是一个粗略的形状，但 `ConcaveMesh` 是你复杂几何体的更详细表示。请注意，使用
    `ConcaveMesh` 的性能惩罚非常高。通常，最好是创建具有自己特定 Physijs 网格的单独几何体，或者将它们组合在一起（就像我们在前面的示例中处理地板那样）。'
- en: '| `Physijs.HeightfieldMesh` | This mesh is a very specialized one. With this
    mesh, you can create a height field from `THREE.PlaneGeometry`. Look at the `03-shapes.html`
    example for this mesh. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `Physijs.HeightfieldMesh` | 这个网格是一个非常专业的网格。使用这个网格，你可以从 `THREE.PlaneGeometry`
    创建一个高度场。查看 `03-shapes.html` 示例以了解此网格。'
- en: We'll quickly walk you through these shapes using `03-shapes.html` as a reference.
    We won't explain `Physijs.ConcaveMesh` any further since its usage is very limited.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速使用 `03-shapes.html` 作为参考，向您介绍这些形状。由于它的使用非常有限，我们不会进一步解释 `Physijs.ConcaveMesh`。
- en: 'Before we look at the example, we''ll first have a quick look at `Physijs.PlaneMesh`.
    This mesh creates a simple plane based on `THREE.PlaneGeometry`, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看示例之前，我们先快速了解一下 `Physijs.PlaneMesh`。这个网格基于 `THREE.PlaneGeometry` 创建了一个简单的平面，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this function, you can see that we just pass in a simple `THREE.PlaneGeometry`
    to create this mesh. If you add this to the scene, you''ll notice something strange.
    The mesh you just created doesn''t respond to gravity. The reason is that `Physijs.PlaneMesh`
    has a fixed weight of `0`, so it won''t respond to gravity or be moved by collisions
    with other objects. Besides this mesh, all the other meshes respond to gravity
    and collisions, as you''d expect. The following screenshot shows a height field
    on which the various supported shapes can be dropped:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你可以看到我们只是传入一个简单的 `THREE.PlaneGeometry` 来创建这个网格。如果你将它添加到场景中，你会注意到一些奇怪的现象。你刚刚创建的网格不会对重力做出反应。原因是
    `Physijs.PlaneMesh` 有一个固定的重量为 `0`，所以它不会对重力做出反应，也不会被其他物体的碰撞所移动。除了这个网格之外，所有其他的网格都会对重力做出反应，并发生碰撞，正如你所期望的那样。以下截图显示了可以放置各种支持形状的高度场：
- en: '![Basic supported shapes](img/2215OS_12_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](img/2215OS_12_05.jpg)'
- en: The previous image shows the `03-shapes.html` example. In this example, we've
    created a random height field (more on that later) and have a menu in the top-right
    corner that you can use to drop objects of various shapes. If you play around
    with this example, you'll see how different shapes respond differently to the
    height map and in collisions with other objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了 `03-shapes.html` 示例。在这个示例中，我们创建了一个随机的高度场（关于这一点稍后会有更多介绍），并在右上角有一个菜单，你可以使用它来放置各种形状的对象。如果你玩这个示例，你会看到不同的形状如何对高度图和与其他物体的碰撞做出不同的反应。
- en: 'Let''s look at the construction of some of these shapes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些形状的构建过程：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There''s nothing special here; we create a geometry and use the best matching
    mesh from Physijs to create the object we add to the scene. However, what if we
    want to use `Physijs.CapsuleMesh`? Three.js doesn''t contain a capsule-like geometry,
    so we have to create one ourselves. Here''s the code for this purpose:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的地方；我们创建一个几何体，并使用 Physijs 中最佳匹配的网格来创建我们添加到场景中的对象。然而，如果我们想使用 `Physijs.CapsuleMesh`
    呢？Three.js 不包含类似胶囊的几何体，所以我们必须自己创建一个。以下是实现此目的的代码：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Physijs.CapsuleMesh` looks like a cylinder but has a rounded top and bottom.
    We can easily recreate this in Three.js by creating a cylinder (`cyl`) and two
    spheres (`top` and `bot`) and merging them together using the `merge()` function.
    The following screenshot shows a number of capsules rolling down the height map:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Physijs.CapsuleMesh` 看起来像一个圆柱体，但顶部和底部是圆滑的。我们可以通过创建一个圆柱体（`cyl`）和两个球体（`top`
    和 `bot`）并使用 `merge()` 函数将它们合并在一起来轻松地在 Three.js 中重新创建这个形状。以下截图显示了几个胶囊沿着高度场滚动：'
- en: '![Basic supported shapes](img/2215OS_12_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](img/2215OS_12_06.jpg)'
- en: 'Before we look at the height map, let''s look at the last of the shapes you
    can add to this example, `Physijs.ConvexMesh`. A convex is the minimal shape that
    wraps all the vertices of a geometry. The resulting shape will only have angles
    smaller than 180 degrees. You would use this mesh for complex shapes such as torus
    knots, as shown in the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看高度图之前，让我们看看这个示例中可以添加的最后一个形状，`Physijs.ConvexMesh`。凸形是包裹一个几何体所有顶点的最小形状。生成的形状将只有小于
    180 度的角度。你会使用这个网格来创建复杂的形状，如以下代码中所示的环面结：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, for physics simulation and collisions, the convex of the torus
    knot will be used. This is a very good way to apply physics and detect collisions
    for complex objects, while still minimizing the performance impact.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，对于物理模拟和碰撞，我们将使用环面结的凸面。这是一种非常好的方法来应用物理和检测复杂对象的碰撞，同时最大限度地减少性能影响。
- en: 'The last mesh from Physijs to discuss is `Physijs.HeightMap`. The following
    screenshot shows a height map created with Physijs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要讨论的Physijs网格是`Physijs.HeightMap`。以下截图显示了使用Physijs创建的高度图：
- en: '![Basic supported shapes](img/2215OS_12_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![基本支持的形状](img/2215OS_12_07.jpg)'
- en: 'With a height map, you can very easily create a terrain that contains bumps
    and shallows. Using `Physijs.Heightmap`, we make sure all the objects respond
    correctly to the height differences of this terrain. Let''s look at the code required
    to accomplish this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高度图，你可以非常容易地创建包含凹凸和浅滩的地形。使用`Physijs.Heightmap`，我们确保所有物体都正确地响应这个地形的起伏差异。让我们看看完成这个任务所需的代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code fragment, we take a couple of steps to create the height map you
    can see in the example. First off, we create the Physijs material and a simple
    `PlaneGeometry` object. To create a bumpy terrain from `PlaneGeometry`, we walk
    through each of the vertices of this geometry and randomly set the `z` property.
    For this, we use a Perlin noise generator to create a bump map just as we used
    in the *Using the canvas as a bump map* section of [Chapter 10](ch10.html "Chapter 10. Loading
    and Working with Textures"), *Loading and Working with Textures*. We need to call
    `computeFaceNormals` and `computeVertexNormals` to make sure the texture, lighting,
    and shadows are rendered correctly. At this point, we have `PlaneGeometry`, which
    contains the correct height information. With `PlaneGeometry`, we can create `Physijs.HeightFieldMesh`.
    The last two parameters for the constructor take the number of horizontal and
    vertical segments of `PlaneGeometry` and should match the last two properties
    used to construct `PlaneGeometry`. Finally, we rotate `HeightFieldMesh` to the
    position we want and add it to the scene. All other Physijs objects will now interact
    correctly with this height map.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们采取了一些步骤来创建示例中可以看到的高度图。首先，我们创建了Physijs材质和一个简单的`PlaneGeometry`对象。为了从`PlaneGeometry`创建凹凸地形，我们遍历这个几何体的每个顶点并随机设置`z`属性。为此，我们使用Perlin噪声生成器创建一个凹凸图，就像我们在第10章的“使用画布作为凹凸图”部分中使用的凹凸图一样，[第10章](ch10.html
    "第10章。加载和使用纹理")，*加载和使用纹理*。我们需要调用`computeFaceNormals`和`computeVertexNormals`来确保纹理、光照和阴影被正确渲染。此时，我们有了包含正确高度信息`PlaneGeometry`。使用`PlaneGeometry`，我们可以创建`Physijs.HeightFieldMesh`。构造函数的最后两个参数接受`PlaneGeometry`的水平段和垂直段数，应该与构建`PlaneGeometry`时使用的最后两个属性匹配。最后，我们将`HeightFieldMesh`旋转到我们想要的位置并将其添加到场景中。现在，所有其他Physijs对象都将正确地与这个高度图交互。
- en: Using constraints to limit movement of objects
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用约束限制物体的运动
- en: 'Until now, we''ve seen some basic physics in action. We''ve seen how the various
    shapes respond to gravity, friction, and restitution and how they affect collisions.
    Physijs also provides advanced constructs that allow you to limit the movement
    of your objects. In Physijs, these objects are called constraints. The following
    table gives an overview of the constraints that are available in Physijs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些基本的物理效果。我们看到了各种形状如何响应重力、摩擦和恢复力，以及它们如何影响碰撞。Physijs还提供了高级结构，允许你限制你物体的运动。在Physijs中，这些对象被称为约束。以下表格概述了Physijs中可用的约束：
- en: '| Constraint | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 约束 | 描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PointConstraint` | This allows you to fix the position of one object to
    the position of another object. If one object moves, the other will move with
    it, keeping the distance and orientation between them the same. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `PointConstraint` | 这允许你将一个物体的位置固定到另一个物体的位置。如果一个物体移动，另一个物体也会随之移动，保持它们之间的距离和方向不变。
    |'
- en: '| `HingeConstraint` | `HingeConstraint` allows you to limit the movement of
    an object as if it were on a hinge, such as a door. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `HingeConstraint` | `HingeConstraint`允许你限制一个物体的运动，就像它在一个铰链上一样，例如一扇门。 |'
- en: '| `SliderConstraint` | This constraint, as the name implies, allows you to
    limit the movement of an object to a single axis, for instance, a sliding door.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `SliderConstraint` | 正如名称所暗示的，这个约束允许你将一个物体的运动限制到一个单一轴上，例如滑动门。 |'
- en: '| `ConeTwistConstraint` | With this constraint, you can limit the rotation
    and the movement of one object to another. This constraint functions like a ball-and-socket
    joint, for instance, the way your arm moves in your shoulder socket. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ConeTwistConstraint` | 使用这个约束，你可以限制一个对象相对于另一个对象的旋转和移动。这个约束的作用类似于球窝关节，例如，你的手臂在肩窝中的移动方式。|'
- en: '| `DOFConstraint` | `DOFConstraint` allows you to specify the limit of movement
    around any of the three axes, and it allows you to set the minimum and maximum
    angle that is allowed. This is the most versatile of the constraints available.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `DOFConstraint` | `DOFConstraint`允许你指定围绕三个轴中的任何一个轴的移动限制，并允许你设置允许的最小和最大角度。这是所有约束中最灵活的。|'
- en: 'The easiest way to understand these constraints is to see them in action and
    play around with them. For this, we''ve provided an example where all these constraints
    are used together, `04-physijs-constraints.js`. The following screenshot shows
    this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些约束的最简单方法是通过观察它们在实际中的表现并与之互动。为此，我们提供了一个示例，其中使用了所有这些约束，`04-physijs-constraints.js`。以下截图显示了此示例：
- en: '![Using constraints to limit movement of objects](img/2215OS_12_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用约束限制对象的移动](img/2215OS_12_08.jpg)'
- en: Based on this example, we'll walk you through four of these five constraints.
    For `DOFConstraint`, we've created a separate example. The first one we look at
    is `PointConstraint`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个示例，我们将向您介绍这五个约束中的四个。对于`DOFConstraint`，我们创建了一个单独的示例。我们首先查看的是`PointConstraint`。
- en: Using PointConstraint to limit movement between two points
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PointConstraint限制两点之间的移动
- en: If you open the example, you'll see two red spheres. These two spheres are connected
    to each other using `PointConstraint`. With the menu in the top-left corner, you
    can move the green sliders around. As soon as one of the sliders hits one of the
    red spheres, you'll see that both of them move in the same manner, and they keep
    the distance between them the same, while still complying with weight, gravity,
    friction, and other aspects of physics.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开示例，你会看到两个红色的球体。这两个球体通过`PointConstraint`连接在一起。通过左上角的菜单，你可以移动绿色的滑块。一旦其中一个滑块接触到其中一个红色球体，你就会看到它们以相同的方式移动，并且保持它们之间的距离不变，同时仍然遵守重量、重力、摩擦和其他物理方面的规则。
- en: '`PointConstraint` in this example was created as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`PointConstraint`的创建方式如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, you can see that we create objects using a Physijs-specific mesh (`SphereMesh`
    in this case) and add them to the scene. We use the `Physijs.PointConstraint`
    constructor to create the constraint. This constraint takes three parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用Physijs特定的网格（在本例中为`SphereMesh`）创建对象并将它们添加到场景中。我们使用`Physijs.PointConstraint`构造函数来创建约束。这个约束需要三个参数：
- en: The first two arguments define which objects you want to connect to each other.
    In this case, we connect the two spheres to one another.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个参数定义了你想要连接到彼此的对象。在这种情况下，我们将两个球体连接在一起。
- en: The third argument defines to what position the constraint is bound. For instance,
    if you bind the first object to a very large object, you can set this position,
    for instance, to the right-hand side of that object. Usually, if you just want
    to connect two objects together, a good choice is to just set it to the position
    of the second object.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数定义了约束绑定到的位置。例如，如果你将第一个对象绑定到一个非常大的对象上，你可以设置这个位置，例如，设置到该对象的右侧。通常，如果你只是想将两个对象连接在一起，一个好的选择就是将其设置为第二个对象的位置。
- en: If you don't want to fix an object to another one, but to a static position
    in the scene, you can omit the second parameter. In that case, the first object
    keeps the same distance to the position you specified, while complying with gravity
    and other aspects of physics, of course.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想将一个对象固定到另一个对象上，而是将其固定到场景中的静态位置，你可以省略第二个参数。在这种情况下，第一个对象将保持与您指定的位置的相同距离，同时当然遵守重力和其他物理方面的规则。
- en: Once the constraint is created, we can enable it by adding it to the scene with
    the `addConstraint` function. As you start experimenting with constraints, you'll
    likely run into some strange issues. To make debugging easier, you can pass in
    `true` to the `addConstraint` function. If you do this, the constraint point and
    orientation is shown in the scene. This can help you get the rotation and position
    of your constraint correctly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了约束，我们可以通过使用`addConstraint`函数将其添加到场景中来启用它。当你开始尝试使用约束时，你可能会遇到一些奇怪的问题。为了使调试更容易，你可以将`true`传递给`addConstraint`函数。如果你这样做，约束点和方向将在场景中显示出来。这可以帮助你正确地获取约束的旋转和位置。
- en: Creating door-like constraints with HingeConstraint
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HingeConstraint创建门状约束
- en: '`HingeConstraint`, as the name implies, allows you to create an object that
    behaves like a hinge. It rotates around a specific axis, limiting the movement
    to a specified angle. In our example, `HingeConstraint` is shown with two white
    flippers at the center of the scene. These flippers are constrained to the small,
    brown cubes and can rotate around them. If you want to play around with these
    hinges, you can enable them by checking the `enableMotor` box in the **hinge**
    menu. This will accelerate the flippers to the velocity specified in the **general**
    menu. A negative velocity will move the hinges down, and a positive velocity will
    move them up. The following screenshot shows the hinges in the up position and
    in the down position:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`HingeConstraint`，正如其名所示，允许你创建一个像铰链一样行为的对象。它围绕一个特定的轴旋转，限制运动到指定的角度。在我们的例子中，`HingeConstraint`显示了场景中心的两个白色翻板。这些翻板被约束到小而棕色的立方体上，并且可以围绕它们旋转。如果你想玩这些铰链，你可以通过在**铰链**菜单中勾选`enableMotor`框来启用它们。这将加速翻板到**通用**菜单中指定的速度。负速度会使铰链向下移动，而正速度会使它们向上移动。以下截图显示了铰链在上位和下位的位置：'
- en: '![Creating door-like constraints with HingeConstraint](img/2215OS_12_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用HingeConstraint创建门状约束](img/2215OS_12_09.jpg)'
- en: 'Let''s take a closer look at how we created one of these flippers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们是如何创建这些翻板之一：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This constraint takes four parameters. Let''s look at each one in a bit more
    detail:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束接受四个参数。让我们更详细地看看每个参数：
- en: '| Parameter | Description |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the white cube that serves
    as the flipper. This is the object that is constrained in its movements. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_a` | 函数中传入的第一个对象是要被约束的对象。在这个例子中，第一个对象是作为翻板的白色立方体。这是在运动中受到约束的对象。 |'
- en: '| `mesh_b` | The second object defines to which object `mesh_a` is constrained.
    In this example, `mesh_a` is constrained to the small, brown cube. If we move
    this mesh around, `mesh_a` would follow it around, still keeping `HingeConstraint`
    in place. You''ll see that all constraints have this option. You could, for instance,
    use this if you''ve created a car that moves around and want to create a constraint
    for opening a door. If this second parameter is omitted, the hinge will be constrained
    to the scene (and never be able to move around). |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_b` | 第二个对象定义了`mesh_a`被约束到的对象。在这个例子中，`mesh_a`被约束到那个小而棕色的立方体上。如果我们移动这个网格，`mesh_a`会跟随它移动，同时保持`HingeConstraint`的位置不变。你会看到所有约束都有这个选项。例如，如果你创建了一辆可以移动的汽车，并想为打开车门创建一个约束，你可以使用这个选项。如果省略了第二个参数，铰链将被约束到场景中（并且永远无法移动）。
    |'
- en: '| `position` | This is the point where the constraint is applied. In this case,
    it''s the hinge point around which `mesh_a` rotates. If you''ve specified `mesh_b`,
    this hinge point will move around with the position and rotation of `mesh_b`.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是应用约束的点。在这种情况下，它是`mesh_a`旋转的铰链点。如果你指定了`mesh_b`，这个铰链点将与`mesh_b`的位置和旋转一起移动。
    |'
- en: '| `axis` | This is the axis around which the hinge should rotate. In this example,
    we''ve set the hinge horizontally (0,1,0). |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 这是铰链应该旋转的轴。在这个例子中，我们已将铰链设置为水平（0,1,0）。 |'
- en: Adding `HingeConstraint` to the scene works in the same way as we've seen with
    `PointConstraint`. You use the `addConstraint` method, specify the constraint
    to add, and optionally add `true` to show the exact location and orientation of
    the constraint for debugging purposes. For `HingeConstraint`, however, we also
    need to define the range of movement that is allowed. We do this with the `setLimits`
    function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HingeConstraint`添加到场景中的方式与我们在`PointConstraint`中看到的方式相同。你使用`addConstraint`方法，指定要添加的约束，并可选地添加`true`以显示约束的确切位置和方向，用于调试目的。然而，对于`HingeConstraint`，我们还需要定义允许的运动范围。我们通过`setLimits`函数来完成这个操作。
- en: 'This function takes the following four parameters:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受以下四个参数：
- en: '| Parameter | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `low` | This is the minimum angle, in radians, of motion. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `low` | 这是运动的最小角度，以弧度为单位。 |'
- en: '| `high` | This is the maximum angle, in radians, of motion. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `high` | 这是运动的最大角度，以弧度为单位。 |'
- en: '| `bias_factor` | This property defines the rate with which the constraint
    corrects itself after an error in position. For instance, when the hinge is pushed
    out of its constraints by a different object, it will move itself to its correct
    position. The higher this value, the faster it will correct its position. It is
    best to keep it below `0.5`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `bias_factor` | 这个属性定义了约束在位置错误后自我校正的速度。例如，当铰链被另一个对象推出其约束时，它会移动到其正确的位置。这个值越高，它校正位置的速度就越快。最好将其保持在`0.5`以下。|'
- en: '| `relaxation_factor` | This defines the rate at which the velocity is changed
    by the constraint. If this is set to a high value, the object will bounce when
    it reaches its minimum or maximum angle of motion. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `relaxation_factor` | 这定义了约束改变速度的速度。如果这个值设置得较高，当物体达到其最小或最大运动角度时，它将弹跳。|'
- en: 'You can change these properties at runtime if you want. If you add `HingeConstraint`
    with these properties, you won''t see much movement. The mesh will only move when
    hit by another object or based on gravity. This constraint, as with many others,
    however, can also be moved by an internal motor. This is what you see when you
    check the `enableMotor` box in the **hinge** submenu from our example. The following
    code is used to enable this motor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想，您可以在运行时更改这些属性。如果您使用具有这些属性的`HingeConstraint`，您不会看到太多的运动。网格只有在被另一个对象撞击或基于重力的情况下才会移动。然而，这个约束，就像许多其他约束一样，也可以被内部电机移动。这就是您在从我们的例子中检查**铰链**子菜单中的`enableMotor`框时看到的情况。以下代码用于启用此电机：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will speed up the mesh (in our case, the flipper) to the specified velocity
    using the acceleration provided. If we want to move the flipper the other way,
    we just specify a negative velocity. If we didn''t have any limits, this would
    cause our flipper to rotate as long as our motor kept running. To disable a motor,
    we can just call the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过提供的加速度将网格（在我们的例子中是翻板）加速到指定的速度。如果我们想将翻板移动到另一边，我们只需指定一个负速度。如果没有限制，这将导致我们的翻板在电机持续运行的情况下旋转。要禁用电机，我们可以调用以下代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the mesh will slow down based on friction, collisions, gravity, and other
    aspects of physics.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网格将根据摩擦、碰撞、重力和其他物理方面的因素减速。
- en: Limiting movement to a single axis with SliderConstraint
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SliderConstraint限制单轴运动
- en: 'The next constraint is `SliderConstraint`. With this constraint, you can limit
    the movement of an object to any one of its axes. The green sliders in the `04-constraints.html`
    example can be controlled from the **sliders** submenu. The following screenshot
    shows this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个约束是`SliderConstraint`。使用这个约束，你可以将一个对象的运动限制在其任意一个轴上。在`04-constraints.html`示例中的绿色滑块可以通过**滑块**子菜单进行控制。以下截图显示了此示例：
- en: '![Limiting movement to a single axis with SliderConstraint](img/2215OS_12_10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用SliderConstraint限制单轴运动](img/2215OS_12_10.jpg)'
- en: 'With the **SlidersLeft** button, the sliders will move to the left-hand side
    (their lower limit), and with the **SlidersRight** button, they will move to the
    right-hand side (their upper limit). Creating these constraints from code is very
    easy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**SlidersLeft**按钮，滑块将移动到左侧（它们的下限），而使用**SlidersRight**按钮，它们将移动到右侧（它们的上限）。从代码中创建这些约束非常简单：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the code, this constraint takes three arguments (or four
    if you want to constrain an object to another object). The following table explains
    the arguments for this constraint:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中看到的，这个约束需要三个参数（如果您想将一个对象约束到另一个对象，则需要四个参数）。以下表格解释了这个约束的参数：
- en: '| Parameter | Description |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mesh_a` | The first object passed into the function is the object that is
    to be constrained. In this example, the first object is the green cube that serves
    as the slider. This is the object that will be constrained in its movements. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_a` | 函数接收的第一个对象是要被约束的对象。在这个例子中，第一个对象是作为滑块的绿色立方体。这是将要被限制其运动的对象。|'
- en: '| `mesh_b` | This is the second object, which defines to which object `mesh_a`
    is constrained. This is an optional argument and omitted in this example. If omitted,
    the mesh will be constrained to the scene. If it is specified, the slider will
    move around when this mesh moves around or when its orientation changes. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `mesh_b` | 这是第二个对象，它定义了`mesh_a`被约束到哪个对象。这是一个可选参数，在这个例子中被省略。如果省略，网格将被约束到场景中。如果指定，当这个网格移动或其方向改变时，滑块将移动。|'
- en: '| `position` | This is the point where the constraint is applied. This is especially
    important when you constrain `mesh_a` to `mesh_b`. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `position` | 这是应用约束的点。当将`mesh_a`约束到`mesh_b`时，这一点尤为重要。 |'
- en: '| `axis` | This is the axis on which `mesh_a` will slide. Note that this is
    relative to the orientation of `mesh_b` if it is specified. In the current version
    of Physijs, there seems to be a strange offset to this axis when using a linear
    motor with linear limits. The following works for this version if you want to
    slide along:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '| `axis` | 这是`mesh_a`将滑动的轴。注意，如果指定了，这相对于`mesh_b`的方向。在Physijs的当前版本中，使用具有线性限制的线性电机时，似乎存在一个奇怪的偏移到这个轴。如果你想要滑动，以下适用于这个版本：'
- en: 'The *x* axis: `new` `THREE.Vector3(0,1,0)`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* 轴：`new` `THREE.Vector3(0,1,0)`'
- en: 'The *y* axis: `new` `THREE.Vector3(0,0,Math.PI/2)`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y* 轴：`new` `THREE.Vector3(0,0,Math.PI/2)`'
- en: 'The *z* axis: `new` `THREE.Vector3(Math.PI/2,0,0)`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*z* 轴：`new` `THREE.Vector3(Math.PI/2,0,0)`'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'After you''ve created the constraint and added it to the scene using `scene.addConstraint`,
    you can set the `constraint.setLimits(-10,` `10,` `0,` `0)` limits for this constraint
    to specify how far the slider may slide. You can set the following limits on `SliderConstraint`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建约束并将其使用`scene.addConstraint`添加到场景后，你可以设置`constraint.setLimits(-10,` `10,`
    `0,` `0)`限制，以指定滑块可以滑动的距离。你可以在`SliderConstraint`上设置以下限制：
- en: '| Parameter | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `linear_lower` | This is the lower linear limit of the object |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `linear_lower` | 这是对象的线性下限 |'
- en: '| `linear_upper` | This is the upper linear limit of the object |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `linear_upper` | 这是对象的线性上限 |'
- en: '| `angular_lower` | This is the lower angular limit of the object |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `angular_lower` | 这是对象的角下限 |'
- en: '| `angular_higher` | This is the upper angular limit of the object |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `angular_higher` | 这是对象的角上限 |'
- en: Finally, you can set the restitution (the bounce) that'll occur when you hit
    one of these limits. You do this with `constraint.setRestitution(res_linear,`
    `res_angular)`, where the first parameter sets the amount of bounce when you hit
    the linear limit and the second one sets the amount of bounce when you hit the
    angular limit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以设置当撞击这些限制时发生的恢复（反弹）。你可以通过`constraint.setRestitution(res_linear,` `res_angular)`来完成此操作，其中第一个参数设置撞击线性限制时的反弹量，第二个参数设置撞击角限制时的反弹量。
- en: 'Now, the complete constraint has been configured, and we can wait until collisions
    occur that slide the object around or use a motor. For `SlideConstraint`, we have
    two options: we can use an angular motor to accelerate along the axis we specified,
    complying with the angular limits we set, or use a linear motor to accelerate
    along the axis we specified, complying with the linear limits. In this example,
    we used a linear motor. For using an angular motor, take a look at `DOFConstraint`,
    which is explained later on in this chapter.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完整的约束已经配置完成，我们可以等待发生碰撞，使对象在周围滑动或使用电机。对于`SlideConstraint`，我们有两种选择：我们可以使用角电机沿着我们指定的轴加速，遵守我们设置的角限制，或者使用线性电机沿着我们指定的轴加速，遵守线性限制。在这个例子中，我们使用了线性电机。对于使用角电机，请查看`DOFConstraint`，它将在本章后面解释。
- en: Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ConeTwistConstraint创建类似球窝关节的约束
- en: 'With `ConeTwistConstraint`, it is possible to create a constraint where the
    movement is limited to a set of angles. We can specify what the minimum and maximum
    angle is from one object to the other for the *x*, *y*, and *z* axes. The following
    screenshot shows that `ConeTwistConstraint` allows you to move an object around
    a reference at certain angles:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ConeTwistConstraint`，可以创建一个运动限制在一系列角度的约束。我们可以指定从一个对象到另一个对象在*x*、*y*和*z*轴上的最小和最大角度。以下截图显示`ConeTwistConstraint`允许你在特定角度周围移动对象：
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](img/2215OS_12_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用ConeTwistConstraint创建类似球窝关节的约束](img/2215OS_12_11.jpg)'
- en: 'The easiest way to understand `ConeTwistConstraint` is by looking at the code
    required to create one. The code required to accomplish this is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`ConeTwistConstraint`的最简单方法是通过查看创建一个所需的代码。完成此操作所需的代码如下：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this piece of JavaScript, you''ll probably already recognize a number of
    concepts we discussed earlier. We start with creating the objects that we connect
    to each other with the constraint: `objectOne` (a sphere) and `objectTwo` (a box).
    We position these objects so that `objectTwo` hangs below `objectOne`. Now we
    can create `ConeTwistConstraint`. The arguments this constraint takes aren''t
    anything new if you''ve already looked at the other constraints. The first parameter
    is the object to constrain, the second parameter is the object to which the first
    object is constrained, and the last parameter is the location where the constraint
    is constructed (in this case, it''s the point around which `objectOne` rotates).
    After adding the constraint to the scene, we can set its limits with the `setLimit`
    function. This function takes three radian values that specify the maximum angle
    for each of the axes.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段JavaScript代码中，您可能已经认识到了我们之前讨论的许多概念。我们首先创建连接到彼此的约束对象：`objectOne`（一个球体）和`objectTwo`（一个盒子）。我们将这些对象定位，使`objectTwo`悬挂在`objectOne`下方。现在我们可以创建`ConeTwistConstraint`。如果您已经看过其他约束，那么这个约束所接受的参数不会是什么新东西。第一个参数是要约束的对象，第二个参数是第一个对象要约束的对象，最后一个参数是约束构建的位置（在这种情况下，它是`objectOne`旋转的点）。在将约束添加到场景后，我们可以使用`setLimit`函数设置其限制。这个函数接受三个弧度值，指定每个轴的最大角度。
- en: 'Just as with most of the other constraints, we can move `objectOne` using the
    motor provided by the constraint. For `ConeTwistConstraint`, we set `MaxMotorImpulse`
    (how much force the motor can apply), and we set the target angles the motor should
    move `objectOne` to. In this example, we move it to its resting position directly
    below the sphere. You can play around with this example, as shown in the following
    screenshot, by setting this target value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数其他约束一样，我们可以使用约束提供的电机来移动`objectOne`。对于`ConeTwistConstraint`，我们设置`MaxMotorImpulse`（电机可以施加的力的大小），并设置电机应将`objectOne`移动到的目标角度。在这个例子中，我们将其直接移动到球体下方的静止位置。您可以像以下截图所示，通过设置此目标值来尝试这个示例：
- en: '![Creating a ball-and-socket-joint-like constraint with ConeTwistConstraint](img/2215OS_12_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用ConeTwistConstraint创建类似球窝关节的约束](img/2215OS_12_12.jpg)'
- en: The last constraint we'll look at is also the most versatile—`DOFConstraint`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种约束也是最通用的——`DOFConstraint`。
- en: Creating detailed control with DOFConstraint
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DOFConstraint创建详细控制
- en: '`DOFConstraint`, also called the degree of freedom constraint, allows you to
    exactly control an object''s linear and angular movement. We''ll show how to use
    this constraint by creating an example where you can drive around a simple, car-like
    shape. This shape consists of a single rectangle that serves as the body and four
    spheres that serve as the wheels. Let''s start by creating the wheels:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOFConstraint`，也称为自由度约束，允许您精确控制对象的线性运动和角运动。我们将通过创建一个示例来展示如何使用这种约束，在这个示例中，您可以驾驶一个类似汽车的简单形状。这个形状由一个矩形组成，作为车身，四个球体作为车轮。让我们先从创建车轮开始：'
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this piece of code, we just created a simple `CylinderGeometry` and `CylinderMesh`
    object, which can be used as the wheels for our car. The following screenshot
    depicts the result of the preceding code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只创建了一个简单的`CylinderGeometry`和`CylinderMesh`对象，可以用作我们汽车的车轮。以下截图显示了上述代码的结果：
- en: '![Creating detailed control with DOFConstraint](img/2215OS_12_13.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![使用DOFConstraint创建详细控制](img/2215OS_12_13.jpg)'
- en: 'Next, we need to create the body of the car and add everything to the scene:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建汽车的车身，并将所有内容添加到场景中：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Until now, we just created the separate components that will have to make up
    our car. To tie everything together, we''re going to create constraints. Each
    wheel will be constrained to `body`. The constraints are created as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是创建了将组成我们汽车的各个独立组件。为了将所有这些组件结合起来，我们将创建约束。每个车轮都将被约束到`body`上。约束的创建方式如下：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each wheel (the first argument) has it''s own constraint, and the position
    where it is attached to the car (the second argument) is specified with the last
    argument. If we ran with this configuration, we''d see that the four wheels hold
    up the body of the car. We need to do two more things to get the car moving: we
    need to set up the constraints for the wheels (along which axis they can move),
    and we need to configure the correct motors. First, we set up the constraints
    for the two front wheels; what we want for these front wheels is just to be able
    to rotate along the *z* axis so that they can power the car, and they shouldn''t
    be allowed to move along the other axes.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轮子（第一个参数）都有自己的约束，并且轮子连接到汽车上的位置（第二个参数）由最后一个参数指定。如果我们以这种配置运行，我们会看到四个轮子支撑着汽车的车身。为了使汽车移动，我们还需要做两件事：我们需要设置轮子的约束（它们可以沿哪个轴移动），并且我们需要配置正确的电机。首先，我们设置两个前轮的约束；我们希望这些前轮能够沿着*z*轴旋转，以便为汽车提供动力，并且不允许它们沿其他轴移动。
- en: 'The code required to accomplish this is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作所需的代码如下：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At first glance, this might seem weird. By setting the lower and upper limits
    to the same value, we make sure that no rotation is possible in the specified
    direction. This would also mean that the wheels can't rotate around their *z*
    axis. The reason we specify it like this is that when you enable a motor for a
    specific axis, these limits are ignored. So setting limits on the *z* axis at
    this point doesn't have any effect on our front wheels.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能会觉得奇怪。通过将上下限设置为相同的值，我们确保在指定方向上不可能发生旋转。这也意味着车轮不能围绕其*z*轴旋转。我们这样指定的原因是，当你为特定轴启用电机时，这些限制将被忽略。因此，此时在*z*轴上设置限制对我们的前轮没有任何影响。
- en: 'We''re going to steer with our rear wheels, and to make sure they don''t fall
    over, we need to fix the *x* axis. With the following code, we fix the *x* axis
    (set upper and lower limits to `0`), fix the *y* axis so that these wheels are
    already initially turned, and disable any limit on the *z* axis:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用后轮来转向，为了确保它们不会翻倒，我们需要固定*x*轴。以下代码中，我们固定了*x*轴（将上下限设置为`0`），固定*y*轴以便这些轮子已经初始转向，并禁用*z*轴上的任何限制：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, to disable the limits, we have to set the lower limit of that
    specific axis higher than the upper limit. This will allow free rotation around
    that axis. If we don't set this for the *z* axis, these two wheels will just be
    dragged along. In this case, they'll turn together with the other wheels because
    of the friction with the ground.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了禁用限制，我们必须将特定轴的下限设置得高于上限。这将允许在该轴周围自由旋转。如果我们不对*z*轴进行此设置，这两个轮子将只是被拖动。在这种情况下，由于与地面的摩擦，它们将与其他轮子一起转动。
- en: 'All that is left to do is set up the motors for the front wheels, which can
    be done as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是设置前轮的电机，这可以按照以下方式完成：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since there are three axes we can create a motor for, we need to specify the
    axis the motor works on: 0 is the *x* axis, 1 is the *y* axis, and 2 is the *z*
    axis. The second and third arguments define the angular limits for the motor.
    Here, we once again set the lower limit (`0.1`) higher than the upper limit (`0`)
    to allow free rotation. The third argument specifies the velocity we want to reach,
    and the last argument specifies the force this motor can apply. If this last one
    is too little, the car won''t move; if it''s too high, the rear wheels will lift
    off from the ground.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以为三个轴创建电机，因此我们需要指定电机工作的轴：0是*x*轴，1是*y*轴，2是*z*轴。第二个和第三个参数定义了电机的角度限制。在这里，我们再次将下限(`0.1`)设置得高于上限(`0`)，以允许自由旋转。第三个参数指定了我们想要达到的速度，最后一个参数指定了该电机可以施加的力。如果这个值太小，汽车将无法移动；如果太高，后轮将离开地面。
- en: 'Enable them with the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码启用它们：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you open up the `05-dof-constraint.html` example, you can play around with
    the various constraints and motors and drive the car around. The following screenshot
    shows this example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`05-dof-constraint.html`示例，你可以玩转各种约束和电机，并在场景中驾驶汽车。以下截图显示了此示例：
- en: '![Creating detailed control with DOFConstraint](img/2215OS_12_14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![使用DOFConstraint创建详细控制](img/2215OS_12_14.jpg)'
- en: In the next section, we'll look at the last subject we'll discuss in this book,
    and that is how to add sounds to your Three.js scene.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨本书将要讨论的最后一个主题，即如何向你的Three.js场景添加声音。
- en: Add sound sources to your scene
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加声音源
- en: 'With the subjects discussed until now, we have a lot of the ingredients in
    place to create beautiful scenes, games, and other 3D visualizations. What we
    haven''t shown, however, is how to add sounds to your Three.js scene. In this
    section, we''ll look at two Three.js objects that allow you to add sources of
    sound to your scene. This is especially interesting since these sound sources
    respond to the position of the camera:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了创建美丽场景、游戏和其他3D可视化的许多成分。然而，我们还没有展示如何将声音添加到你的Three.js场景中。在本节中，我们将探讨两个Three.js对象，允许你将声音源添加到场景中。这特别有趣，因为这些声音源会响应相机的位置：
- en: The distance between the sound source and the camera determines the volume of
    the sound source.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音源和相机之间的距离决定了声音源的音量。
- en: The positions to the left-hand side and the right-hand side of the camera determine
    the sound volume of the left-hand side speaker and the right-hand side speaker,
    respectively.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机左侧和右侧的位置分别决定了左侧扬声器和右侧扬声器的音量。
- en: 'The best way to explain this is to see this in action. Open up the `06-audio.html`
    example in your browser, and you''ll see three cubes with pictures of animals.
    The following screenshot shows this example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解释方式就是看到这个动作。在你的浏览器中打开`06-audio.html`示例，你会看到三个带有动物图片的立方体。以下截图显示了此示例：
- en: '![Add sound sources to your scene](img/2215OS_12_15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![将声音源添加到场景中](img/2215OS_12_15.jpg)'
- en: This example uses the first-person controls we saw in [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*,
    so you can use the arrow keys in combination with the mouse to move around the
    scene. What you'll see is that the closer you move to a specific cube, the louder
    that specific animal will sound. If you position the camera between the dog and
    the cow, you'll hear the cow from the right-hand side and the dog from the left-hand
    side.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了我们在[第9章](ch09.html "第9章。动画和移动相机")中看到的第一个视角控制，*动画和移动相机*，因此你可以使用箭头键与鼠标结合来在场景中移动。你会看到，当你靠近一个特定的立方体时，那个特定的动物声音会变得更响。如果你将相机置于狗和牛之间，你会从右侧听到牛的声音，从左侧听到狗的声音。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In this example, we used a specific helper, `THREE.GridHelper`, from Three.js
    to create the grid beneath the cubes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了Three.js中的一个特定助手`THREE.GridHelper`来创建立方体下面的网格：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To create a grid, you need to specify the size of the grid (500 in this case)
    and the size of the individual grid elements (we used 10 here). If you want, you
    can also set the colors of the horizontal lines by specifying the `color1` and
    `color2` properties.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个网格，你需要指定网格的大小（本例中为500）以及单个网格元素的大小（我们这里使用的是10）。如果你想的话，你也可以通过指定`color1`和`color2`属性来设置水平线的颜色。
- en: 'Accomplishing this only takes a small amount of code. The first thing we need
    to do is define `THREE.AudioListener` and add it to `THREE.PerspectiveCamera`,
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个功能只需要很少的代码。我们首先需要做的是定义`THREE.AudioListener`并将其添加到`THREE.PerspectiveCamera`中，如下所示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to create `THREE.Mesh` and add a `THREE.Audio` object to that
    mesh, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`THREE.Mesh`并添加一个`THREE.Audio`对象到该网格中，如下所示：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see from this code snippet, we first create a standard `THREE.Mesh`
    instance. Next, we create a `THREE.Audio` object, which we connect to the `THREE.AudioListener`
    object we created earlier. Finally, we add the `THREE.Audio` object to the mesh
    we created and we're done.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如从这个代码片段中可以看到，我们首先创建了一个标准的`THREE.Mesh`实例。接下来，我们创建了一个`THREE.Audio`对象，并将其连接到我们之前创建的`THREE.AudioListener`对象。最后，我们将`THREE.Audio`对象添加到我们创建的网格中，这样就完成了。
- en: 'There are a couple of properties we can set on the `THREE.Audio` object to
    configure its behavior:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`THREE.Audio`对象上设置一些属性来配置其行为：
- en: '`load`: This allows us to load an audio file to be played.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`: 这允许我们加载一个音频文件进行播放。'
- en: '`setRefDistance`: This determines the distance from the object from where the
    sound will be reduced in volume.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRefDistance`: 这决定了从哪个距离开始，声音的音量会降低。'
- en: '`setLoop`: By default, a sound is played once. By setting this property to
    `true`, the sound is looped.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLoop`: 默认情况下，声音只播放一次。通过将此属性设置为`true`，声音将循环播放。'
- en: '`setRolloffFactor`: This determines how quickly the volume decreases as you
    move away from the sound source.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setRolloffFactor`: 这决定了当你远离声音源时，音量下降的速度。'
- en: Internally, Three.js uses the Web Audio API ([http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/))
    to play the sound and determine the correct volume. Not all browsers support this
    specification. The best support currently is from Chrome and Firefox.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Three.js使用Web Audio API（[http://webaudio.github.io/web-audio-api/](http://webaudio.github.io/web-audio-api/））来播放声音并确定正确的音量。并非所有浏览器都支持这个规范。目前最好的支持来自Chrome和Firefox。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter, we explored how you can extend the basic 3D functionality
    from Three.js by adding physics. For this, we used the Physijs library, which
    allows you to add gravity, collisions, constraints, and much more. We also showed
    how you can add positional sound to your scene using the `THREE.Audio` and `THREE.AudioListener`
    objects. With those subjects, we've reached the end of this book on Three.js.
    In these chapters, we covered a lot of different subjects and explored pretty
    much everything Three.js has to offer. In the first couple of chapters, we explained
    the core concepts and ideas behind Three.js; after that, we looked at the available
    lights and how materials affect how an object is rendered. After the basics, we
    explored the various geometries Three.js has to offer and how you can combine
    geometries to create new ones.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们探讨了如何通过添加物理来扩展Three.js的基本3D功能。为此，我们使用了Physijs库，它允许你添加重力、碰撞、约束等等。我们还展示了如何使用`THREE.Audio`和`THREE.AudioListener`对象将位置声音添加到你的场景中。通过这些主题，我们到达了Three.js这本书的结尾。在这些章节中，我们涵盖了众多不同的主题，几乎探索了Three.js所能提供的一切。在前几章中，我们解释了Three.js背后的核心概念和理念；之后，我们探讨了可用的光源以及材质如何影响对象的渲染。在基础知识之后，我们探索了Three.js提供的各种几何体以及如何组合几何体来创建新的几何体。
- en: In the second part of the book, we looked at a few more advanced subjects. You
    learned how to create particle systems, how to load models from external sources,
    and how to create animations. Finally, in these last couple of chapters, we looked
    at the advanced textures you can use in skinning and the postprocessing effects
    that can be applied after the scene is rendered. We end the book with this chapter
    on physics, which, besides explaining how you can add physics to your Three.js
    scene, also shows the active community of projects surrounding Three.js that you
    can use to add even more functionality to an already great library.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第二部分，我们探讨了几个更高级的主题。你学习了如何创建粒子系统，如何从外部源加载模型，以及如何创建动画。最后，在这最后几章中，我们探讨了在场景渲染后可以使用的先进纹理以及后处理效果。我们以这一章关于物理学的讨论结束本书，除了解释如何将物理添加到你的Three.js场景中，还展示了围绕Three.js的活跃社区项目，你可以使用这些项目为这个已经非常出色的库添加更多功能。
- en: I hope you've enjoyed reading this book and playing around with the examples
    as much as I have writing it!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢阅读这本书，就像我写作时一样喜欢尝试这些示例！
