- en: Chapter 3. CoffeeScript and jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。CoffeeScript 和 jQuery
- en: '**jQuery** is a cross-browser compatible library designed to simplify the life
    of an HTML application developer. It was first released by John Resig in 2006
    and has since become the most popular JavaScript library in the world, and is
    used in millions of websites.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery** 是一个跨浏览器兼容的库，旨在简化 HTML 应用程序开发者的生活。它最初由 John Resig 在 2006 年发布，并从此成为世界上最受欢迎的
    JavaScript 库，被数百万个网站使用。'
- en: Why did it become so popular? Well, jQuery has a couple of nice features like
    easy DOM manipulation and querying, event handling, and animation, as well as
    AJAX support. All these combined together makes programming against the DOM and
    programming in JavaScript much better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它会变得如此流行？嗯，jQuery 有一些很好的特性，如简单的 DOM 操作和查询、事件处理和动画，以及 AJAX 支持。所有这些结合在一起，使得针对
    DOM 的编程和在 JavaScript 中的编程变得更好。
- en: The library has also been highly optimized in terms of cross-browser compatibility
    and speed and thus using jQuery's DOM traversal and manipulation functions not
    only save you from writing tedious code, but it's also usually much faster than
    the code that you could write yourself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该库在跨浏览器兼容性和速度方面也进行了高度优化，因此使用 jQuery 的 DOM 遍历和操作函数不仅可以让你免于编写繁琐的代码，而且通常比你自己编写的代码要快得多。
- en: As it turns out, jQuery and CoffeeScript go very well together, and when combined,
    provides a powerful toolset to write web applications in a succinct and expressive
    manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，jQuery 和 CoffeeScript 一起使用得很好，并且当结合使用时，提供了一套强大的工具集，可以以简洁和表达性的方式编写网络应用程序。
- en: 'In this chapter, we''ll do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Explore some of the high level features of jQuery and talk about what it gives
    you
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 jQuery 的一些高级功能，并讨论它为你提供了什么
- en: Learn how to use CoffeeScript and jQuery in the browser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在浏览器中使用 CoffeeScript 和 jQuery
- en: Build a simple to-do list app using jQuery and CoffeeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jQuery 和 CoffeeScript 构建一个简单的待办事项列表应用
- en: Let's start by discussing the jQuery library in more detail, and discover what
    makes it so useful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先详细讨论 jQuery 库，并了解它为什么如此有用。
- en: Finding and changing elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和更改元素
- en: In web browsers, the DOM, or Document Object Model, is the representation of
    the elements in an HTML document used to interact with programmatically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络浏览器中，DOM（文档对象模型）是用于程序化交互的 HTML 文档中元素的表示。
- en: In JavaScript, you'll find yourself doing a lot of DOM traversal to find elements
    that you're interested in and then manipulate them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你会发现你需要进行大量的 DOM 遍历来找到你感兴趣的元素，然后对其进行操作。
- en: To accomplish this using just the standard JavaScript libraries, you'll usually
    need to use a combination of the `document.getElementsByName`, `document.getElementById`,
    and `document.getElementsById` methods. As soon as your HTML structure starts
    getting complex, this usually means that you would have to combine these methods
    in an awkward and cumbersome iteration code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅使用标准的 JavaScript 库来完成这项任务，你通常需要结合使用 `document.getElementsByName`、`document.getElementById`
    和 `document.getElementsById` 方法。一旦你的 HTML 结构开始变得复杂，这通常意味着你不得不将这些方法组合在一个尴尬且繁琐的迭代代码中。
- en: Code written in this fashion usually makes a lot of assumptions about the structure
    of your HTML, which means that it will usually break if the HTML changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写的代码通常对 HTML 的结构有很多假设，这意味着如果 HTML 发生变化，它通常会出问题。
- en: The $ function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$` 函数'
- en: With jQuery, a lot of this imperative style code becomes much simpler with the
    `$` function—jQuery's factory method (a method that creates instances of jQuery
    classes) and the entry point into most of the library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jQuery，许多这种命令式风格的代码通过 `$` 函数——jQuery 的工厂方法（一个创建 jQuery 类实例的方法）和进入库的主要入口点——变得更加简单。
- en: This function usually takes a CSS selector string as an argument, which can
    be used to select one or multiple elements according to their element name, ID,
    class attribute, or other attribute values. This method will return a jQuery object
    that contains one or more elements that matches the selector.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通常需要一个 CSS 选择器字符串作为参数，它可以用来根据元素名称、ID、类属性或其他属性值选择一个或多个元素。此方法将返回一个包含一个或多个与选择器匹配的元素的
    jQuery 对象。
- en: 'Here, we''ll select all the `input` tags in a document with a class of `address`,
    using the `$` function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `$` 函数选择具有 `address` 类的文档中的所有 `input` 标签：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then manipulate or interrogate these elements using a multitude of
    functions, often called **commands**. The following are just a few of the common
    jQuery commands and what they are used for:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用众多函数来操作或查询这些元素，这些函数通常被称为**命令**。以下是一些常见的jQuery命令及其用途：
- en: '`addClass`: This adds a CSS class to an element'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addClass`: 这给元素添加一个CSS类'
- en: '`removeClass`: This removes a CSS class from an element'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeClass`: 这将从元素中移除一个CSS类'
- en: '`attr`: This gets a attribute from an element'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr`: 这从元素中获取一个属性'
- en: '`hasClass`: This checks for the existence of a CSS class on an element'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasClass`: 这检查元素上是否存在CSS类'
- en: '`html`: This gets or sets the HTML text of an element'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html`: 这获取或设置元素的HTML文本'
- en: '`val`: This gets or sets the element value'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`: 这获取或设置元素值'
- en: '`show`: This displays an element'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`: 这将显示一个元素'
- en: '`hide`: This hides an element'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide`: 这将隐藏一个元素'
- en: '`parent`: This gets the parent of an element'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`: 这获取元素的父亲'
- en: '`appendTo`: This appends a child element'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendTo`: 这将子元素附加到父元素'
- en: '`fadeIn`: This fades in an element'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeIn`: 这使元素淡入'
- en: '`fadeout`: This fades out an element'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fadeout`: 这使元素淡出'
- en: Most of the commands return a jQuery object that can be used to chain other
    commands onto them. By chaining commands, you can use the output of one command
    as the input of the next. This powerful technique lets you write very short and
    succinct transformations on parts of the HTML document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令都会返回一个jQuery对象，可以用来将其他命令链式附加到它上面。通过链式命令，您可以使用一个命令的输出作为下一个命令的输入。这种强大的技术让您可以对HTML文档的部分进行非常简短和简洁的转换。
- en: 'Let''s say that we want to highlight and enable all the `address` inputs in
    an HTML form; jQuery allows us to do something similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要突出显示并启用HTML表单中的所有`address`输入；jQuery允许我们执行类似以下操作：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we once again select all the `input` tags with an `address` class. We
    add the `highlighted` class to each using the `addClass` command, and then remove
    the `disabled` attribute by chaining a call to the `removeAttr` command.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次选择所有具有`address`类的`input`标签。我们使用`addClass`命令给每个标签添加`highlighted`类，然后通过链式调用`removeAttr`命令来移除`disabled`属性。
- en: Utility functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具函数
- en: 'jQuery also comes with a host of utility functions that generally improves
    your day-to-day JavaScript programming experience. These are all in the form of
    methods on the global jQuery object like this: `$.methodName`. For instance, one
    of the most widely used utilities is the `each` method, that can be used to iterate
    over arrays or objects, and would be called as follows (in CoffeeScript):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery还附带了一系列工具函数，这些函数通常可以改善您的日常JavaScript编程体验。这些函数都是以全局jQuery对象上的方法的形式存在的，例如：`$.methodName`。例如，最广泛使用的工具之一是`each`方法，它可以用来遍历数组或对象，如下所示（在CoffeeScript中）：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: jQuery's utility methods range from array and collection helper methods, time
    and string manipulation, as well as a host of other useful JavaScript and browser
    related functions. A lot of these functions stem from the everyday needs of a
    lot of JavaScript programmers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的工具方法包括数组集合辅助方法、时间字符串操作，以及许多其他有用的JavaScript和浏览器相关函数。许多这些函数都源于许多JavaScript程序员的日常需求。
- en: Often, you'll find a function that applies to a common problem or pattern you
    face yourself when writing JavaScript or CoffeeScript. You can find a detailed
    list of the functions at [http://api.jquery.com/category/utilities/](http://api.jquery.com/category/utilities/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现一个函数适用于您在编写JavaScript或CoffeeScript时遇到的一个常见问题或模式。您可以在[http://api.jquery.com/category/utilities/](http://api.jquery.com/category/utilities/)找到函数的详细列表。
- en: Ajax methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax方法
- en: jQuery provides the `$.ajax` method to perform Ajax requests that work across
    browsers. Traditionally, this has been a pain to do, since browsers all implemented
    different interfaces for handling Ajax. jQuery takes care of all of that and provides
    a simpler, callback-based way of constructing and executing Ajax requests. This
    means that you can declaratively specify how the Ajax call should be made and
    then provide functions that jQuery will call back when the request succeeds or
    fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery提供了`$.ajax`方法来执行跨浏览器的Ajax请求。传统上，这一直是一个痛点，因为浏览器都实现了不同的接口来处理Ajax。jQuery负责所有这些，并提供了一种更简单、基于回调的方式来构建和执行Ajax请求。这意味着你可以声明性地指定Ajax调用应该如何进行，然后提供jQuery在请求成功或失败时调用的函数。
- en: Using jQuery
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery
- en: Using jQuery in the browser is very simple; you just need to include the jQuery
    library in your HTML file. You can either download the latest version of jQuery
    from their site ([http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery))
    and reference that, or you can directly link to a **Content Delivery Network**
    (**CDN**) version of the library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用 jQuery 非常简单；你只需要在 HTML 文件中包含 jQuery 库。你可以从他们的网站上下载 jQuery 的最新版本（[http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery)）并引用它，或者你可以直接链接到库的
    **内容分发网络**（**CDN**）版本。
- en: Following is an example of how you might do it. This snippet comes from the
    excellent HTML5 Boilerplate project ([http://html5boilerplate.com/](http://html5boilerplate.com/)).
    Here we include the latest minified jQuery from a Google CDN, but we will also
    include a local version if including from the CDN fails.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明你可能如何做到这一点。这个片段来自优秀的 HTML5 Boilerplate 项目（[http://html5boilerplate.com/](http://html5boilerplate.com/)）。这里我们包括来自
    Google CDN 的最新压缩版 jQuery，但如果从 CDN 包含失败，我们也会包括本地版本。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using CoffeeScript and jQuery in the browser
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中使用 CoffeeScript 和 jQuery
- en: Before we can start playing with jQuery and CoffeeScript, let's talk about how
    you go about writing CoffeeScript code that runs in the browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用 jQuery 和 CoffeeScript 玩耍之前，让我们谈谈如何编写在浏览器中运行的 CoffeeScript 代码。
- en: Compiling CoffeeScript
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译 CoffeeScript
- en: The most common way of compiling CoffeeScript for a web application is to run
    the `coffee` command to watch one or more CoffeeScript files for changes and then
    to compile them to JavaScript. The output will then be included in your web application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 CoffeeScript 用于 Web 应用的最常见方法是运行 `coffee` 命令来监视一个或多个 CoffeeScript 文件的变化，然后将它们编译成
    JavaScript。然后，输出将包含在你的 Web 应用程序中。
- en: 'As an example, we''ll organize our project folder structure to look something
    like the following folder structure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将组织我们的项目文件夹结构，使其看起来类似于以下文件夹结构：
- en: '![Compiling CoffeeScript](img/9588_03_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![编译 CoffeeScript](img/9588_03_01.jpg)'
- en: ''''
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ''''
- en: The **src** folder is where your CoffeeScript files would go. We could then
    start a CoffeeScript compiler to watch that folder and compile the JavaScript
    to our **public/js** folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**src** 文件夹是放置你的 CoffeeScript 文件的地方。然后我们可以启动一个 CoffeeScript 编译器来监视该文件夹，并将 JavaScript
    编译到我们的 **public/js** 文件夹。'
- en: 'This is what the CoffeeScript command would look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 CoffeeScript 命令的样子：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep this command running in the background in its own terminal window and it
    will recompile your CoffeeScript files when you save them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让这个命令在单独的终端窗口中后台运行，当你保存 CoffeeScript 文件时，它将重新编译你的 CoffeeScript 文件。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**CoffeeScript tags**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**CoffeeScript 标签**'
- en: Another way of running CoffeeScript in the browser is to include CoffeeScript
    inline in the document enclosed in the `<script type="text/coffeescript">` tag
    and then to include the minified CoffeeScript compiler script (`coffee-script.js`)
    in your document. This will compile, and then run all the inline CoffeeScript
    in the page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行 CoffeeScript 的另一种方法是，在 `<script type="text/coffeescript">` 标签中包含 CoffeeScript
    代码，然后在你的文档中包含压缩的 CoffeeScript 编译器脚本（`coffee-script.js`）。这将编译并运行页面中的所有内联 CoffeeScript
    代码。
- en: This isn't meant for serious use, since you will pay a serious performance penalty
    for the compiling step each time the page is loaded. However, it can be quite
    useful from time to time to just quickly play around with some CoffeeScript in
    the browser without setting up a complete compiler chain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是为了严肃使用，因为每次页面加载时，你将为编译步骤付出严重的性能代价。然而，有时只是快速在浏览器中玩一些 CoffeeScript 而不设置完整的编译链，这可以相当有用。
- en: jQuery and CoffeeScript
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery 和 CoffeeScript
- en: 'Let''s put something in our CoffeeScript file to see if we can successfully
    hook it up with jQuery. In the `src` folder, create a file named `app.coffee`
    and include the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 CoffeeScript 文件中添加一些内容，看看我们是否能够成功将其与 jQuery 连接起来。在 `src` 文件夹中，创建一个名为 `app.coffee`
    的文件，并包含以下代码：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sets up the jQuery's `$(document).ready()` function that will be called
    when the application is initialized. Here we are using the shorthand syntax for
    it, by just passing an anonymous function to the `$` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了 jQuery 的 `$(document).ready()` 函数，当应用程序初始化时将被调用。这里我们使用它的简写语法，只需将匿名函数传递给
    `$` 函数即可。
- en: 'You should now have an `app.js` file in the `public/js` folder with content
    similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该在 `public/js` 文件夹中有一个 `app.js` 文件，其内容类似于以下内容：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we need to include this file as well as the jQuery in our application''s
    HTML file. In the `public/index.html` file, add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在我们的应用程序的 HTML 文件中包含此文件以及 jQuery。在 `public/index.html` 文件中，添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code creates our HTML skeleton, and includes jQuery (using the
    Google CDN) as well as our application code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了我们 HTML 的骨架，并包含了 jQuery（使用 Google CDN）以及我们的应用程序代码。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/](http://www.PacktPub.com/)
    support and register to have the files e-mailed directly to you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载示例代码文件，网址为 [http://www.PacktPub.com](http://www.PacktPub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.PacktPub.com/](http://www.PacktPub.com/) 支持并注册，以便将文件直接通过电子邮件发送给你。
- en: Testing it all
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试所有内容
- en: 'We should now be able to run our application by opening our `index.html` file
    in a browser. If all went well, we should see our alert pop-up window, as shown
    in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够通过在浏览器中打开我们的 `index.html` 文件来运行我们的应用程序。如果一切顺利，我们应该会看到如下截图所示的弹出窗口：
- en: '![Testing it all](img/9588_03_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![测试所有内容](img/9588_03_02.jpg)'
- en: Running a local web server
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行本地网络服务器
- en: While we can easily test our web application from the disk for now, we might
    want to host it on a local web server soon, especially if we wanted to start doing
    Ajax. Since we already have Node.js installed, it should be really easy to run
    a web server, for which we only need to serve static content for now. Luckily,
    there is an npm package that will do just that for us; it is named **http-server**
    and can be found at [https://github.com/nodeapps/http-server](https://github.com/nodeapps/http-server).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在可以从磁盘轻松测试我们的网络应用程序，但我们可能很快就会想要在本地网络服务器上托管它，特别是如果我们想要开始做 Ajax。由于我们已经安装了
    Node.js，运行网络服务器应该非常简单，我们目前只需要提供静态内容。幸运的是，有一个 npm 包可以为我们做到这一点；它被称为 **http-server**，可以在
    [https://github.com/nodeapps/http-server](https://github.com/nodeapps/http-server)
    找到。
- en: 'To install it, just run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，只需运行以下命令：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then, we execute it by navigating to our application folder and entering
    this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过导航到我们的应用程序文件夹并输入以下内容来执行它：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will host all the files in the public folder on port **8080**. We should
    now be able to navigate to our hosted site by using the URL `http://localhost:8080/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口 **8080** 上托管公共文件夹中的所有文件。现在，我们应该能够通过使用 URL `http://localhost:8080/` 导航到我们的托管站点。
- en: Our application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的应用程序
- en: In the rest of this chapter, we will be building a jQuery application using
    CoffeeScript. The application is a to-do list app, which can be used to keep track
    of your daily tasks and how you completed them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将使用 CoffeeScript 构建一个 jQuery 应用程序。该应用程序是一个待办事项列表应用程序，可以用来跟踪你的日常任务以及你如何完成它们。
- en: TodoMVC
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TodoMVC
- en: I have modeled a lot of the application on some of the TodoMVC project's source
    code, which is in the public domain. This project is a showcase of different JavaScript
    MVC frameworks all used to build the same application, and can be very useful
    when evaluating frameworks. If you wanted to check it out, it can be found at
    [http://addyosmani.github.com/todomvc/](http://addyosmani.github.com/todomvc/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将应用程序的大部分模型建立在一些 TodoMVC 项目的源代码上，这些源代码属于公共领域。该项目展示了不同的 JavaScript MVC 框架，它们都用于构建相同的应用程序，当评估框架时非常有用。如果你想查看它，可以在
    [http://addyosmani.github.com/todomvc/](http://addyosmani.github.com/todomvc/)
    找到。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**MVC** , or Model–view–controller, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types. We''ll talk about MVC a bit more later
    on in the book.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**（模型-视图-控制器）是一种广泛使用的应用程序架构模式，旨在通过将应用程序关注点拆分为三个领域对象类型来简化代码并减少耦合。我们将在本书的后面部分更多地讨论
    MVC。'
- en: We will mostly base our application on the TodoMVC project to get the awesome-looking
    stylesheets that come with it as well as a well-designed HTML5 structure. However,
    most of the client-side JavaScript will be rewritten in CoffeeScript and it will
    be simplified and modified quite a lot for illustration purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要基于 TodoMVC 项目构建我们的应用程序，以获取它附带的一些出色的样式表以及精心设计的 HTML5 结构。然而，大部分客户端 JavaScript
    将用 CoffeeScript 重新编写，并且为了说明目的，它将被简化并修改很多。
- en: So without further ado, let's get to it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无需多言，让我们开始吧！
- en: Our initial HTML
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们最初的 HTML
- en: 'First, we''ll add some HTML that will allow us to enter to-do items and view
    a list of existing items. In `index.html`, add the following code to the `body`
    tag, right before the included `script` tags:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一些 HTML，这将允许我们输入待办事项并查看现有条目的列表。在 `index.html` 中，在包含的 `script` 标签之前，向
    `body` 标签添加以下代码：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's briefly walk through the structure of the preceding markup. First, we
    have a section with the `todoapp` ID, that will serve as the main part of the
    app. It consists of a `header` tag, which will house our input for creating new
    items, a `main` section, which will list all our to-do items, and a `footer` section
    that will have the **Clear completed** button. Before we open this page in the
    browser, let's remove the previous alert line from our `app.coffee` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览一下前面标记的结构的结构。首先，我们有一个带有 `todoapp` ID 的部分，它将作为应用程序的主要部分。它由一个 `header`
    标签组成，该标签将包含我们创建新条目的输入，一个 `main` 部分，其中将列出所有待办事项，以及一个 `footer` 部分，其中将包含 **清除已完成**
    按钮。在我们打开浏览器中的此页面之前，让我们从我们的 `app.coffee` 文件中删除之前的警告行。
- en: When you navigate to this page, it won't look like much. That is because our
    HTML hasn't been styled at all. Download the `styles.css` file for this chapter
    and copy it to the `public/css` folder. It should now look much better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到这个页面时，它看起来不会太多。这是因为我们的 HTML 丝毫没有样式。下载本章的 `styles.css` 文件并将其复制到 `public/css`
    文件夹。现在它应该看起来好多了。
- en: Initializing our app
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化我们的应用程序
- en: Most jQuery apps, including ours, follow a similar pattern. We create a `$(document).ready`
    handler which in turn performs page initialization, usually including hooking
    up event handlers for user actions. Let's do this in our `app.coffee` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 jQuery 应用程序，包括我们的，遵循类似的模式。我们创建一个 `$(document).ready` 处理程序，它反过来执行页面初始化，通常包括为用户操作设置事件处理程序。让我们在我们的
    `app.coffee` 文件中这样做。
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, in the previous code snippet, we create a class called `TodoApp` that
    will represent our application. It has a constructor that calls the `bindEvents`
    method, which for now just displays an alert message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在前面的代码片段中，我们创建了一个名为 `TodoApp` 的类，它将代表我们的应用程序。它有一个构造函数，该构造函数调用 `bindEvents`
    方法，目前只是显示一个警告消息。
- en: We set up jQuery's `$(document).ready` event handler to create an instance of
    our `TodoApp`. When you reload the page, you should see the **binding events**
    alert pop-up window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了 jQuery 的 `$(document).ready` 事件处理程序来创建我们的 `TodoApp` 实例。当你重新加载页面时，你应该看到
    **绑定事件** 的弹出窗口。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Not seeing the expected output?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有看到预期的输出？**'
- en: Remember to keep an eye on the output of the coffee compiler running in the
    background. If you have made any syntax errors, then the compiler will spit out
    an error message. Once you have fixed it, the compiler should recompile your new
    JavaScript file. Remember that CoffeeScript is whitespace sensitive. If you come
    across any errors that you don't understand, check your indentation carefully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记得关注在后台运行的咖啡编译器的输出。如果你有任何语法错误，编译器将输出错误消息。一旦你修复了它，编译器应该重新编译你的新 JavaScript 文件。记住，CoffeeScript
    对空白字符敏感。如果你遇到任何你不理解的错误，请仔细检查你的缩进。
- en: Adding a to-do item
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加待办事项
- en: 'Now we can add the event handling to actually add a to-do item to the list.
    In our `bindEvents` function, we''ll select the `new-todo` input and handle its
    `keyup` event. We bind that to call the `create` method on our class, which we''ll
    also go and define; this is shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加事件处理程序，实际上将待办事项添加到列表中。在我们的 `bindEvents` 函数中，我们将选择 `new-todo` 输入并处理其
    `keyup` 事件。我们将此绑定到调用我们的类上的 `create` 方法，我们也将定义它；这将在以下代码片段中显示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `$('#new-todo')` function uses the jQuery CSS selector syntax to get the
    input with the `new-todo` ID, the `on` method binds the `create` method to its
    `'keyup'` event, which fires whenever a key is pressed while the input has focus.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(''#new-todo'')` 函数使用 jQuery CSS 选择器语法获取具有 `new-todo` ID 的输入，`on` 方法将 `create`
    方法绑定到其 `''keyup''` 事件，该事件在输入具有焦点时按下任何键时触发。'
- en: In the `create` function, we can get a reference to the input by using the `$(this)`
    function, which will always return the element that generated the event. We assign
    this to the `$input` variable. Using variable names that are prefixed with `$`
    is a common convention when assigning jQuery variables. We can then get the value
    of the input using the `val()` function and assign it a local `val` variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create` 函数中，我们可以通过使用 `$(this)` 函数来获取输入的引用，该函数将始终返回生成事件的元素。我们将此分配给 `$input`
    变量。使用以 `$` 为前缀的变量名是在分配 jQuery 变量时的常见约定。然后我们可以使用 `val()` 函数获取输入的值并将其分配给一个本地的 `val`
    变量。
- en: We can see if the *Enter* key was pressed by checking if the `which` property
    of the `keyup` event is equal to `13`. If so, and if the `val` variable is not
    `null`, we can go ahead and create the to-do item. For now, we'll just output
    its value using an alert message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`keyup`事件的`which`属性是否等于`13`来查看是否按下了*Enter*键。如果是这样，并且`val`变量不是`null`，我们就可以继续创建待办事项。目前，我们只是通过一个警告消息输出其值。
- en: Once we create the item, where shall we put it? In lots of traditional web apps,
    this data will typically be stored on the server using an Ajax request. We would
    like to keep this app simple for now and just keep these items around on the client
    side for now. The HTML5 specification defines a mechanism for us called **localStorage**,
    to do just that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了项目，我们应该将其放在哪里？在许多传统的Web应用中，这些数据通常会通过Ajax请求存储在服务器上。我们希望现在保持这个应用简单，所以暂时只将这些项目保留在客户端。HTML5规范定义了一个名为**localStorage**的机制，正是为了实现这一点。
- en: Using localStorage
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用localStorage
- en: '`localStorage` is part of the new HTML5 specification and allows you to store
    and retrieve objects in a local database that lives in the browser. The interface
    is quite simple; in supported browsers a global variable named `localStorage`
    will be present. This variable has the following three important methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`是新的HTML5规范的一部分，允许你在浏览器中的本地数据库中存储和检索对象。接口相当简单；在支持的浏览器中，将存在一个名为`localStorage`的全局变量。这个变量有以下三个重要的方法：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both the `key` and `value` parameters are strings. Strings stored in the `localStorage`
    variable hang around even when the page is refreshed. You can store up to 5 MB
    in the `localStorage` variable in most browsers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`和`value`参数都是字符串。存储在`localStorage`变量中的字符串即使在页面刷新后也会保留。在大多数浏览器中，你可以在`localStorage`变量中存储多达5MB的数据。'
- en: 'Because we want to store the to-do items as a complex object rather than a
    string, we use the commonly used technique of converting to and from a JSON object
    when setting and getting items from `localStorage`. To do so, we''ll add two methods
    to the prototype of the `Storage` class, which will then be available on the global
    `localStorage` object. Add the following code snippet to the top of our `app.coffee`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望将待办事项存储为一个复杂对象而不是字符串，所以在设置和从`localStorage`获取项目时，我们使用将对象转换为JSON对象以及从JSON对象转换的常用技术。为此，我们将向`Storage`类的原型添加两个方法，这样它们就会在全局的`localStorage`对象上可用。将以下代码片段添加到我们的`app.coffee`文件顶部：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use the `::` operator to add the `setObj` and `getObj` methods to the
    `Storage` class. These functions wrap the `localStorage` object's `getItem` and
    `setItem` methods by converting the object to and from JSON.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`::`运算符将`setObj`和`getObj`方法添加到`Storage`类。这些函数通过将对象转换为JSON以及从JSON转换来包装`localStorage`对象的`getItem`和`setItem`方法。
- en: We are now finally ready to create our to-do item and store it in `localStorage`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好创建待办事项并将其存储在`localStorage`中了。
- en: 'Here is the rest of our `create` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的`create`方法的其余部分：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In order for us to uniquely identify tasks, we'll use the simplest thing we
    can, and just generate a big random number to use as an ID. This is not the most
    sophisticated way of identifying documents and you should probably not use this
    in a production setting. However, it's quite simple to implement, and serves our
    purposes well for now.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够唯一地识别任务，我们将使用最简单的方法，即生成一个大的随机数作为ID。这不是识别文档最复杂的方法，你很可能不应该在生产环境中使用这种方法。然而，它实现起来相当简单，目前对我们的目的来说效果很好。
- en: After generating the ID, we can now put the to-do item in our local database
    using our `setObj` method. We pass in a title that we got from the `input` tag
    value, and default the item to not completed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成ID之后，我们现在可以使用`setObj`方法将待办事项放入我们的本地数据库。我们传递一个从`input`标签值中获取的标题，并将项目默认设置为未完成。
- en: Lastly, we clear the value of `$input` to give the user visual input that `create`
    was successful.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清除`$input`的值，以便用户能够看到`create`操作成功。
- en: 'We should now be able to test our little app and see if the to-do items do
    get stored into `localStorage`. The Google Chrome Developer Tools will allow you
    to inspect `localStorage` in the **Resources** tab. After adding a couple of tasks,
    you should be able to see them here, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够测试我们的小程序，看看待办事项是否被存储到`localStorage`中。Google Chrome开发者工具允许你在**资源**选项卡中检查`localStorage`。添加几个任务后，你应该能够在这里看到它们，如下面的截图所示：
- en: '![Using localStorage](img/9588_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用localStorage](img/9588_03_03.jpg)'
- en: Displaying the to-do items
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示待办事项
- en: Now that we can store a list of to-do items, it would be nice if we could see
    them on screen. To do so, we will add a `displayItems` method. This will iterate
    through the local list of to-do items and display them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够存储待办事项列表，如果在屏幕上看到它们会很好。为此，我们将添加一个`displayItems`方法。这将遍历本地的待办事项列表并将它们显示出来。
- en: 'Add the following code to our `TodoApp`, after the `create` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们的`TodoApp`中，在`create`方法之后：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we should be able to call this method from the `create` method, as highlighted
    in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够从`create`方法中调用此方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s run this code to see what happens. When we do, we get the following
    error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这段代码看看会发生什么。当我们这样做时，我们得到以下错误：
- en: '**Uncaught TypeError: Object #<HTMLInputElement> has no method ''displayItems''**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**未捕获的类型错误：对象#<HTMLInputElement>没有方法''displayItems''**'
- en: So what's happening here? It seems that the call to `@displayItems()` is trying
    to call the method on an instance of `HTMLInputElement` instead of `TodoApp`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？看起来`@displayItems()`的调用试图在一个`HTMLInputElement`的实例上调用方法，而不是在`TodoApp`实例上。
- en: This happens because jQuery will set the value of `this` to reference the element
    that raised the event. When we bind a class method as an event handler, jQuery
    will in essence "highjack" `this` to not point to the class itself. It is an important
    caveat that you should know of when working with jQuery and classes in CoffeeScript.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为jQuery会将`this`的值设置为引用触发事件的元素。当我们将类方法绑定到事件处理器时，jQuery实际上会“劫持”`this`，使其不指向类本身。这是当你使用jQuery和CoffeeScript中的类时应该知道的一个重要注意事项。
- en: 'To fix it, we can use the CoffeeScript fat arrow when we set up the `keyup`
    event handler, which will ensure that the value of `this` remains intact. Let''s
    modify our `bindEvents` method to look similar to the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复它，我们可以在设置`keyup`事件处理器时使用CoffeeScript的胖箭头，这将确保`this`的值保持不变。让我们修改我们的`bindEvents`方法，使其看起来类似于以下代码：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is just one more thing though; in our `createItem` method, we used `$(this)`
    to get the value of the `input` element that raised the event. Since switching
    to the fat arrow, this will now be pointing to our `TodoApp` instance. Luckily,
    the event argument that gets passed in has a target property that also points
    to our input. Change the first line of the `create` method similar to the following
    code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有一件事；在我们的`createItem`方法中，我们使用了`$(this)`来获取触发事件的`input`元素的价值。自从切换到胖箭头后，现在它将指向我们的`TodoApp`实例。幸运的是，传入的事件参数有一个目标属性，它也指向我们的输入。将`create`方法的第1行修改得类似于以下代码片段：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now when we create an item, we should see the "displaying items" alert, meaning
    the `displayItems` method has been hooked up correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个项目时，我们应该看到“显示项目”的提示，这意味着`displayItems`方法已经正确连接。
- en: We can do one better. Since the `$input` tag will need to be looked up every
    time the `create` method is fired, we can just store it in a class variable so
    that it can be re-used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好。由于每次`create`方法被触发时都需要查找`$input`标签，我们可以将其存储在类变量中，以便可以重用。
- en: 'The best place for this would be right when the app starts up. Let''s create
    a `cacheElements` method that does just that, and gets called in the constructor—this
    is highlighted in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳位置应该是在应用程序启动时。让我们创建一个`cacheElements`方法，它正好做这件事，并在构造函数中被调用——如下面的代码所示：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `cacheElements` call assigns a class variable called `@$input` , which is
    then used throughout our class. This `@$` syntax might look strange at first,
    but it does convey a lot of information in a few keystrokes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheElements`调用分配了一个名为`@$input`的类变量，然后在整个类中使用。这种`@$`语法一开始可能看起来很奇怪，但它确实在几键中传达了大量的信息。'
- en: Showing the to-do items
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示待办事项
- en: 'We should now be able to show the items. In the `displayItems` method, we''ll
    iterate through all the `localStorage` keys and use them to get each corresponding
    to-do item. For each item we''ll add a `li` child element to the `ul` element
    with the `todo-list` ID. Before we start working with the `$(''#todo-list'')`
    element, let''s cache its value like we did with `@$input`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够显示项目。在`displayItems`方法中，我们将遍历所有的`localStorage`键，并使用它们来获取每个相应的待办事项。对于每个项目，我们将在具有`todo-list`
    ID的`ul`元素中添加一个`li`子元素。在我们开始使用`$('#todo-list')`元素之前，让我们像对`@$input`所做的那样缓存其值：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have modified the `displayItems` method a bit. First, we remove any
    existing child list items from `$@todoList`, then we loop through each key in
    `localStorage`, get the object with that key, and send that item to the `addItem`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对 `displayItems` 方法进行了一些修改。首先，我们从 `$@todoList` 中删除任何现有的子列表项，然后我们遍历 `localStorage`
    中的每个键，获取具有该键的对象，并将其发送到 `addItem` 方法。
- en: The `addItem` method builds an HTML string representation of a to-do item and
    then uses jQuery's `append` function to append a child element to `$@todoList`
    . Together with a label for the title, we also create a checkbox to set the task
    as completed and a button to remove the task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`addItem` 方法构建一个待办事项的 HTML 字符串表示形式，然后使用 jQuery 的 `append` 函数将子元素附加到 `$@todoList`
    上。同时，我们还创建了一个用于设置任务为完成的复选框和一个用于删除任务的按钮。'
- en: Notice the `data-id` attribute on the `li` element. This is an HTML5 data attribute,
    which lets you add arbitrary data attributes to any element. We will use this
    to link each `li` to its to-do item in the `localStorage` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `li` 元素上的 `data-id` 属性。这是一个HTML5数据属性，它允许你向任何元素添加任意数据属性。我们将使用它将每个 `li` 与 `localStorage`
    对象中的待办事项相关联。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although CoffeeScript can make building HTML strings like these a bit easier,
    it can quickly become cumbersome to define markup within your client-side code.
    We have done so here mostly for illustration purposes; it's probably better to
    use a JavaScript templating library, such as Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CoffeeScript可以使构建此类HTML字符串变得容易一些，但定义客户端代码中的标记可能会很快变得繁琐。我们在这里主要为了说明目的这样做；可能更好的做法是使用JavaScript模板库，例如Handlebars
    ([http://handlebarsjs.com/](http://handlebarsjs.com/))。
- en: These types of libraries allow you define templates within your markup and then
    compile them with a specific context, which then gives you a nicely formatted
    HTML that you can then append to the elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这类库允许你在标记中定义模板，然后使用特定上下文编译它们，这会给你一个格式良好的HTML，你可以将其附加到元素上。
- en: 'One last thing, now that we can display items after one is created, let''s
    add the `displayItems` call to the constructor, so that we can display existing
    to-do items; this call is highlighted in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，现在我们可以在创建后显示项目，让我们将 `displayItems` 调用添加到构造函数中，这样我们就可以显示现有的待办事项；下面的代码中突出显示了此调用：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Removing and completing items
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除和完成项目
- en: 'Let''s hook up the remove task button. We add an event handler for it follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接删除任务按钮。我们为其添加了一个事件处理程序，如下所示：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we handle click events on any child element on `@$todoList` with a `.destroy`
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理 `@$todoList` 上任何具有 `.destroy` 类的子元素的点击事件。
- en: We once again create the handler with the fat arrow, calling a `@destroy` method
    and passing in the target, which should be the **destroy** button that was clicked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用箭头函数创建处理程序，调用 `@destroy` 方法并传入目标，该目标应该是被点击的 **删除** 按钮。
- en: 'We now need to create the `@destroy` method using the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建 `@destroy` 方法，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `closest` function will find the `li` element that is defined nearest to
    the button itself. We use jQuery's `data` function to retrieve its `data-id` attribute,
    which we can then use to remove the to-do item from `localStorage`. One more call
    is made to `@displayItems` to refresh the view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`closest` 函数将找到定义在按钮本身最近的 `li` 元素。我们使用 jQuery 的 `data` 函数检索其 `data-id` 属性，然后我们可以使用它从
    `localStorage` 中删除待办事项。还调用了一次 `@displayItems` 来刷新视图。'
- en: 'Completing an item will follow a very similar pattern; that is, we add an event
    handler, which is highlighted in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一项任务将遵循一个非常相似的模式；也就是说，我们添加一个事件处理程序，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This time we handle the `''change''` event, which will fire whenever a completed
    checkbox is checked or unchecked. This in turn will call the `@toggle` method,
    which is coded as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们处理 `'change'` 事件，该事件将在完成的复选框被勾选或取消勾选时触发。这反过来会调用 `@toggle` 方法，其代码如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method also uses the `closest` function to get the ID of the to-do item.
    It loads up the object from `localStorage`, toggles the value of `completed`,
    and then saves it back to `localStorage` using the `setObj` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也使用 `closest` 函数获取待办事项的ID。它从 `localStorage` 中加载对象，切换 `completed` 的值，然后使用
    `setObj` 方法将其保存回 `localStorage`。
- en: Now, it's your turn!
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在，轮到你了！
- en: As a final exercise for you, I will ask you to make the **Clear completed**
    button work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的练习，我会要求你使 **清除已完成** 按钮生效。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what jQuery is, and what its strengths and benefits
    are. We also learned how to combine the powerful features of jQuery with CoffeeScript
    to write complex web applications with much less effort and complexity. jQuery
    is a very large library and we have just scratched the surface of what it has
    to offer. I urge you to spend some more time learning the library itself, and
    to do so using CoffeeScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 jQuery 是什么，以及它的优势和好处。我们还学习了如何将 jQuery 的强大功能与 CoffeeScript 结合起来，以更少的努力和复杂性编写复杂的网络应用程序。jQuery
    是一个非常庞大的库，我们只是刚刚触及了它所能提供的表面。我敦促你花更多的时间学习这个库本身，并且使用 CoffeeScript 来学习。
- en: Next up, we'll start by having a look at how you would start interacting with
    sever-side code using CoffeeScript and Rails.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首先看看如何使用 CoffeeScript 和 Rails 与服务器端代码进行交互。
