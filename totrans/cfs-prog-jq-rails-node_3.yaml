- en: Chapter 3. CoffeeScript and jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**jQuery** is a cross-browser compatible library designed to simplify the life
    of an HTML application developer. It was first released by John Resig in 2006
    and has since become the most popular JavaScript library in the world, and is
    used in millions of websites.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Why did it become so popular? Well, jQuery has a couple of nice features like
    easy DOM manipulation and querying, event handling, and animation, as well as
    AJAX support. All these combined together makes programming against the DOM and
    programming in JavaScript much better.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The library has also been highly optimized in terms of cross-browser compatibility
    and speed and thus using jQuery's DOM traversal and manipulation functions not
    only save you from writing tedious code, but it's also usually much faster than
    the code that you could write yourself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, jQuery and CoffeeScript go very well together, and when combined,
    provides a powerful toolset to write web applications in a succinct and expressive
    manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Explore some of the high level features of jQuery and talk about what it gives
    you
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use CoffeeScript and jQuery in the browser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a simple to-do list app using jQuery and CoffeeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by discussing the jQuery library in more detail, and discover what
    makes it so useful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Finding and changing elements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web browsers, the DOM, or Document Object Model, is the representation of
    the elements in an HTML document used to interact with programmatically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, you'll find yourself doing a lot of DOM traversal to find elements
    that you're interested in and then manipulate them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this using just the standard JavaScript libraries, you'll usually
    need to use a combination of the `document.getElementsByName`, `document.getElementById`,
    and `document.getElementsById` methods. As soon as your HTML structure starts
    getting complex, this usually means that you would have to combine these methods
    in an awkward and cumbersome iteration code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Code written in this fashion usually makes a lot of assumptions about the structure
    of your HTML, which means that it will usually break if the HTML changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The $ function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With jQuery, a lot of this imperative style code becomes much simpler with the
    `$` function—jQuery's factory method (a method that creates instances of jQuery
    classes) and the entry point into most of the library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: This function usually takes a CSS selector string as an argument, which can
    be used to select one or multiple elements according to their element name, ID,
    class attribute, or other attribute values. This method will return a jQuery object
    that contains one or more elements that matches the selector.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll select all the `input` tags in a document with a class of `address`,
    using the `$` function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then manipulate or interrogate these elements using a multitude of
    functions, often called **commands**. The following are just a few of the common
    jQuery commands and what they are used for:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`addClass`: This adds a CSS class to an element'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeClass`: This removes a CSS class from an element'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attr`: This gets a attribute from an element'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasClass`: This checks for the existence of a CSS class on an element'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html`: This gets or sets the HTML text of an element'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val`: This gets or sets the element value'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: This displays an element'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide`: This hides an element'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent`: This gets the parent of an element'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appendTo`: This appends a child element'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeIn`: This fades in an element'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fadeout`: This fades out an element'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the commands return a jQuery object that can be used to chain other
    commands onto them. By chaining commands, you can use the output of one command
    as the input of the next. This powerful technique lets you write very short and
    succinct transformations on parts of the HTML document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to highlight and enable all the `address` inputs in
    an HTML form; jQuery allows us to do something similar to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we once again select all the `input` tags with an `address` class. We
    add the `highlighted` class to each using the `addClass` command, and then remove
    the `disabled` attribute by chaining a call to the `removeAttr` command.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Utility functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jQuery also comes with a host of utility functions that generally improves
    your day-to-day JavaScript programming experience. These are all in the form of
    methods on the global jQuery object like this: `$.methodName`. For instance, one
    of the most widely used utilities is the `each` method, that can be used to iterate
    over arrays or objects, and would be called as follows (in CoffeeScript):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: jQuery's utility methods range from array and collection helper methods, time
    and string manipulation, as well as a host of other useful JavaScript and browser
    related functions. A lot of these functions stem from the everyday needs of a
    lot of JavaScript programmers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Often, you'll find a function that applies to a common problem or pattern you
    face yourself when writing JavaScript or CoffeeScript. You can find a detailed
    list of the functions at [http://api.jquery.com/category/utilities/](http://api.jquery.com/category/utilities/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Ajax methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: jQuery provides the `$.ajax` method to perform Ajax requests that work across
    browsers. Traditionally, this has been a pain to do, since browsers all implemented
    different interfaces for handling Ajax. jQuery takes care of all of that and provides
    a simpler, callback-based way of constructing and executing Ajax requests. This
    means that you can declaratively specify how the Ajax call should be made and
    then provide functions that jQuery will call back when the request succeeds or
    fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using jQuery in the browser is very simple; you just need to include the jQuery
    library in your HTML file. You can either download the latest version of jQuery
    from their site ([http://docs.jquery.com/Downloading_jQuery](http://docs.jquery.com/Downloading_jQuery))
    and reference that, or you can directly link to a **Content Delivery Network**
    (**CDN**) version of the library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Following is an example of how you might do it. This snippet comes from the
    excellent HTML5 Boilerplate project ([http://html5boilerplate.com/](http://html5boilerplate.com/)).
    Here we include the latest minified jQuery from a Google CDN, but we will also
    include a local version if including from the CDN fails.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using CoffeeScript and jQuery in the browser
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start playing with jQuery and CoffeeScript, let's talk about how
    you go about writing CoffeeScript code that runs in the browser.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Compiling CoffeeScript
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way of compiling CoffeeScript for a web application is to run
    the `coffee` command to watch one or more CoffeeScript files for changes and then
    to compile them to JavaScript. The output will then be included in your web application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll organize our project folder structure to look something
    like the following folder structure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling CoffeeScript](img/9588_03_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: ''''
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The **src** folder is where your CoffeeScript files would go. We could then
    start a CoffeeScript compiler to watch that folder and compile the JavaScript
    to our **public/js** folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the CoffeeScript command would look like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep this command running in the background in its own terminal window and it
    will recompile your CoffeeScript files when you save them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CoffeeScript tags**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Another way of running CoffeeScript in the browser is to include CoffeeScript
    inline in the document enclosed in the `<script type="text/coffeescript">` tag
    and then to include the minified CoffeeScript compiler script (`coffee-script.js`)
    in your document. This will compile, and then run all the inline CoffeeScript
    in the page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: This isn't meant for serious use, since you will pay a serious performance penalty
    for the compiling step each time the page is loaded. However, it can be quite
    useful from time to time to just quickly play around with some CoffeeScript in
    the browser without setting up a complete compiler chain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: jQuery and CoffeeScript
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s put something in our CoffeeScript file to see if we can successfully
    hook it up with jQuery. In the `src` folder, create a file named `app.coffee`
    and include the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sets up the jQuery's `$(document).ready()` function that will be called
    when the application is initialized. Here we are using the shorthand syntax for
    it, by just passing an anonymous function to the `$` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have an `app.js` file in the `public/js` folder with content
    similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we need to include this file as well as the jQuery in our application''s
    HTML file. In the `public/index.html` file, add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code creates our HTML skeleton, and includes jQuery (using the
    Google CDN) as well as our application code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/](http://www.PacktPub.com/)
    support and register to have the files e-mailed directly to you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Testing it all
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should now be able to run our application by opening our `index.html` file
    in a browser. If all went well, we should see our alert pop-up window, as shown
    in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing it all](img/9588_03_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Running a local web server
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we can easily test our web application from the disk for now, we might
    want to host it on a local web server soon, especially if we wanted to start doing
    Ajax. Since we already have Node.js installed, it should be really easy to run
    a web server, for which we only need to serve static content for now. Luckily,
    there is an npm package that will do just that for us; it is named **http-server**
    and can be found at [https://github.com/nodeapps/http-server](https://github.com/nodeapps/http-server).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, just run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then, we execute it by navigating to our application folder and entering
    this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will host all the files in the public folder on port **8080**. We should
    now be able to navigate to our hosted site by using the URL `http://localhost:8080/`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Our application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will be building a jQuery application using
    CoffeeScript. The application is a to-do list app, which can be used to keep track
    of your daily tasks and how you completed them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: TodoMVC
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have modeled a lot of the application on some of the TodoMVC project's source
    code, which is in the public domain. This project is a showcase of different JavaScript
    MVC frameworks all used to build the same application, and can be very useful
    when evaluating frameworks. If you wanted to check it out, it can be found at
    [http://addyosmani.github.com/todomvc/](http://addyosmani.github.com/todomvc/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**MVC** , or Model–view–controller, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types. We''ll talk about MVC a bit more later
    on in the book.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We will mostly base our application on the TodoMVC project to get the awesome-looking
    stylesheets that come with it as well as a well-designed HTML5 structure. However,
    most of the client-side JavaScript will be rewritten in CoffeeScript and it will
    be simplified and modified quite a lot for illustration purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: So without further ado, let's get to it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Our initial HTML
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll add some HTML that will allow us to enter to-do items and view
    a list of existing items. In `index.html`, add the following code to the `body`
    tag, right before the included `script` tags:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's briefly walk through the structure of the preceding markup. First, we
    have a section with the `todoapp` ID, that will serve as the main part of the
    app. It consists of a `header` tag, which will house our input for creating new
    items, a `main` section, which will list all our to-do items, and a `footer` section
    that will have the **Clear completed** button. Before we open this page in the
    browser, let's remove the previous alert line from our `app.coffee` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: When you navigate to this page, it won't look like much. That is because our
    HTML hasn't been styled at all. Download the `styles.css` file for this chapter
    and copy it to the `public/css` folder. It should now look much better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our app
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most jQuery apps, including ours, follow a similar pattern. We create a `$(document).ready`
    handler which in turn performs page initialization, usually including hooking
    up event handlers for user actions. Let's do this in our `app.coffee` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, in the previous code snippet, we create a class called `TodoApp` that
    will represent our application. It has a constructor that calls the `bindEvents`
    method, which for now just displays an alert message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We set up jQuery's `$(document).ready` event handler to create an instance of
    our `TodoApp`. When you reload the page, you should see the **binding events**
    alert pop-up window.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Not seeing the expected output?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Remember to keep an eye on the output of the coffee compiler running in the
    background. If you have made any syntax errors, then the compiler will spit out
    an error message. Once you have fixed it, the compiler should recompile your new
    JavaScript file. Remember that CoffeeScript is whitespace sensitive. If you come
    across any errors that you don't understand, check your indentation carefully.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Adding a to-do item
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can add the event handling to actually add a to-do item to the list.
    In our `bindEvents` function, we''ll select the `new-todo` input and handle its
    `keyup` event. We bind that to call the `create` method on our class, which we''ll
    also go and define; this is shown in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `$('#new-todo')` function uses the jQuery CSS selector syntax to get the
    input with the `new-todo` ID, the `on` method binds the `create` method to its
    `'keyup'` event, which fires whenever a key is pressed while the input has focus.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In the `create` function, we can get a reference to the input by using the `$(this)`
    function, which will always return the element that generated the event. We assign
    this to the `$input` variable. Using variable names that are prefixed with `$`
    is a common convention when assigning jQuery variables. We can then get the value
    of the input using the `val()` function and assign it a local `val` variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We can see if the *Enter* key was pressed by checking if the `which` property
    of the `keyup` event is equal to `13`. If so, and if the `val` variable is not
    `null`, we can go ahead and create the to-do item. For now, we'll just output
    its value using an alert message.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Once we create the item, where shall we put it? In lots of traditional web apps,
    this data will typically be stored on the server using an Ajax request. We would
    like to keep this app simple for now and just keep these items around on the client
    side for now. The HTML5 specification defines a mechanism for us called **localStorage**,
    to do just that.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Using localStorage
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`localStorage` is part of the new HTML5 specification and allows you to store
    and retrieve objects in a local database that lives in the browser. The interface
    is quite simple; in supported browsers a global variable named `localStorage`
    will be present. This variable has the following three important methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both the `key` and `value` parameters are strings. Strings stored in the `localStorage`
    variable hang around even when the page is refreshed. You can store up to 5 MB
    in the `localStorage` variable in most browsers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to store the to-do items as a complex object rather than a
    string, we use the commonly used technique of converting to and from a JSON object
    when setting and getting items from `localStorage`. To do so, we''ll add two methods
    to the prototype of the `Storage` class, which will then be available on the global
    `localStorage` object. Add the following code snippet to the top of our `app.coffee`
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use the `::` operator to add the `setObj` and `getObj` methods to the
    `Storage` class. These functions wrap the `localStorage` object's `getItem` and
    `setItem` methods by converting the object to and from JSON.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: We are now finally ready to create our to-do item and store it in `localStorage`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rest of our `create` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In order for us to uniquely identify tasks, we'll use the simplest thing we
    can, and just generate a big random number to use as an ID. This is not the most
    sophisticated way of identifying documents and you should probably not use this
    in a production setting. However, it's quite simple to implement, and serves our
    purposes well for now.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: After generating the ID, we can now put the to-do item in our local database
    using our `setObj` method. We pass in a title that we got from the `input` tag
    value, and default the item to not completed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we clear the value of `$input` to give the user visual input that `create`
    was successful.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now be able to test our little app and see if the to-do items do
    get stored into `localStorage`. The Google Chrome Developer Tools will allow you
    to inspect `localStorage` in the **Resources** tab. After adding a couple of tasks,
    you should be able to see them here, as shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Using localStorage](img/9588_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Displaying the to-do items
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can store a list of to-do items, it would be nice if we could see
    them on screen. To do so, we will add a `displayItems` method. This will iterate
    through the local list of to-do items and display them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to our `TodoApp`, after the `create` method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we should be able to call this method from the `create` method, as highlighted
    in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s run this code to see what happens. When we do, we get the following
    error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Uncaught TypeError: Object #<HTMLInputElement> has no method ''displayItems''**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: So what's happening here? It seems that the call to `@displayItems()` is trying
    to call the method on an instance of `HTMLInputElement` instead of `TodoApp`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This happens because jQuery will set the value of `this` to reference the element
    that raised the event. When we bind a class method as an event handler, jQuery
    will in essence "highjack" `this` to not point to the class itself. It is an important
    caveat that you should know of when working with jQuery and classes in CoffeeScript.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix it, we can use the CoffeeScript fat arrow when we set up the `keyup`
    event handler, which will ensure that the value of `this` remains intact. Let''s
    modify our `bindEvents` method to look similar to the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is just one more thing though; in our `createItem` method, we used `$(this)`
    to get the value of the `input` element that raised the event. Since switching
    to the fat arrow, this will now be pointing to our `TodoApp` instance. Luckily,
    the event argument that gets passed in has a target property that also points
    to our input. Change the first line of the `create` method similar to the following
    code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now when we create an item, we should see the "displaying items" alert, meaning
    the `displayItems` method has been hooked up correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We can do one better. Since the `$input` tag will need to be looked up every
    time the `create` method is fired, we can just store it in a class variable so
    that it can be re-used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place for this would be right when the app starts up. Let''s create
    a `cacheElements` method that does just that, and gets called in the constructor—this
    is highlighted in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `cacheElements` call assigns a class variable called `@$input` , which is
    then used throughout our class. This `@$` syntax might look strange at first,
    but it does convey a lot of information in a few keystrokes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Showing the to-do items
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should now be able to show the items. In the `displayItems` method, we''ll
    iterate through all the `localStorage` keys and use them to get each corresponding
    to-do item. For each item we''ll add a `li` child element to the `ul` element
    with the `todo-list` ID. Before we start working with the `$(''#todo-list'')`
    element, let''s cache its value like we did with `@$input`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have modified the `displayItems` method a bit. First, we remove any
    existing child list items from `$@todoList`, then we loop through each key in
    `localStorage`, get the object with that key, and send that item to the `addItem`
    method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The `addItem` method builds an HTML string representation of a to-do item and
    then uses jQuery's `append` function to append a child element to `$@todoList`
    . Together with a label for the title, we also create a checkbox to set the task
    as completed and a button to remove the task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `data-id` attribute on the `li` element. This is an HTML5 data attribute,
    which lets you add arbitrary data attributes to any element. We will use this
    to link each `li` to its to-do item in the `localStorage` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although CoffeeScript can make building HTML strings like these a bit easier,
    it can quickly become cumbersome to define markup within your client-side code.
    We have done so here mostly for illustration purposes; it's probably better to
    use a JavaScript templating library, such as Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: These types of libraries allow you define templates within your markup and then
    compile them with a specific context, which then gives you a nicely formatted
    HTML that you can then append to the elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing, now that we can display items after one is created, let''s
    add the `displayItems` call to the constructor, so that we can display existing
    to-do items; this call is highlighted in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Removing and completing items
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s hook up the remove task button. We add an event handler for it follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we handle click events on any child element on `@$todoList` with a `.destroy`
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We once again create the handler with the fat arrow, calling a `@destroy` method
    and passing in the target, which should be the **destroy** button that was clicked.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create the `@destroy` method using the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `closest` function will find the `li` element that is defined nearest to
    the button itself. We use jQuery's `data` function to retrieve its `data-id` attribute,
    which we can then use to remove the to-do item from `localStorage`. One more call
    is made to `@displayItems` to refresh the view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Completing an item will follow a very similar pattern; that is, we add an event
    handler, which is highlighted in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This time we handle the `''change''` event, which will fire whenever a completed
    checkbox is checked or unchecked. This in turn will call the `@toggle` method,
    which is coded as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method also uses the `closest` function to get the ID of the to-do item.
    It loads up the object from `localStorage`, toggles the value of `completed`,
    and then saves it back to `localStorage` using the `setObj` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's your turn!
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final exercise for you, I will ask you to make the **Clear completed**
    button work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what jQuery is, and what its strengths and benefits
    are. We also learned how to combine the powerful features of jQuery with CoffeeScript
    to write complex web applications with much less effort and complexity. jQuery
    is a very large library and we have just scratched the surface of what it has
    to offer. I urge you to spend some more time learning the library itself, and
    to do so using CoffeeScript.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 jQuery 是什么，以及它的优势和好处。我们还学习了如何将 jQuery 的强大功能与 CoffeeScript 结合起来，以更少的努力和复杂性编写复杂的网络应用程序。jQuery
    是一个非常庞大的库，我们只是刚刚触及了它所能提供的表面。我敦促你花更多的时间学习这个库本身，并且使用 CoffeeScript 来学习。
- en: Next up, we'll start by having a look at how you would start interacting with
    sever-side code using CoffeeScript and Rails.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首先看看如何使用 CoffeeScript 和 Rails 与服务器端代码进行交互。
