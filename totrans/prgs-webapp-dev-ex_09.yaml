- en: Optimizing for Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performance is one of the key aspects of user experience. In fact, many experts
    argue that web performance creates a good user experience. There are different
    aspects of web performance that you should consider when you are delivering an
    online experience, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to first byte** (**TTFB**) and server-side latencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the primary attributes of a **Progressive Web App** (**PWA**) is speed.
    That's because people like pages to load fast and respond to actions or input
    even faster. Making fast, interactive websites is as much of an art as it is a
    science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into making fast PWAs, I want to define what this chapter is
    designed to help with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goals**: Defining key performance indicators to measure performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guidelines**: Defining ways for you to achieve these goals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Demonstrate**: Applying these guidelines to the PWA ticket app so that you
    have a reference code and workflow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will go deep into how the browser loads and renders pages. You
    will also learn details of how TCP works and how you can take advantage of this
    knowledge to create pages that load within 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn different intermediate and advanced **web performance optimization**
    (**WPO**) techniques and how they relate to PWA design. These techniques are woven
    into the natural fabric of the PWA ticket application. As this chapter evolves,
    you will learn techniques which rely partially on an automated build script. This
    automation will be carried over to the following chapter, where I will be reviewing
    different tools to help you build PWAs.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of WPO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DoubleClick and others websites have shown that 3 seconds is all you have. If
    the perceived page hasn't loaded within 3 seconds, 53% of mobile visitors abandon
    the page ([https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/](https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/)).
    Additionally, DoubleClick reported that sites loading within 5 seconds enjoyed
    70% longer sessions, 35% lower bounce rates, and 25% higher advertisement viewability.
  prefs: []
  type: TYPE_NORMAL
- en: Those examples are just a small sampling of the numerous case studies and reports
    available, demonstrating how important page load and interaction are for a website's
    success. You can find many more statistics at [https://wpostats.com](https://wpostats.com).
    This is one of the reasons web performance is continually emphasized by Google
    as a key ranking signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Human psychology is an important aspect of performance. We know how the brain
    perceives performance and can correlate the science to our web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 to 16 ms**: Users perceive animations as smooth, so long as 60 new frames
    are rendered every second or 16 ms per frame. This leaves about 10 ms to produce
    a frame after considering browser overheads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0 to 100 ms**: Users feel like the response to an action is immediate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**100 to 300 ms**: Slight perceptible delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**300 to 1000 ms**: Things feel part of a natural and continuous progression
    of tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**>= 1000 ms**: (1 second), users loses focus on the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put a mental pin in those numbers because they serve as a primary benchmark
    for this chapter. The goal of this chapter is to modify the PWA ticket application
    to load within 1 second over an average 3G connection.
  prefs: []
  type: TYPE_NORMAL
- en: Loading fast gives you a competitive advantage because the average web page
    takes 15 seconds ([https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)
    ) to load on mobile devices, a 7 second improvement over the 2017 standard. Not
    only has this improved the user's engagement, but also stats that were commonly
    reported when site performance is optimized. Such sites enjoy higher search rankings.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of web traffic comes from mobile devices. Some businesses see as
    much as 95% of their traffic coming from smartphones. This is why Google is switching
    their primary search index from desktop to mobile by June 2018.
  prefs: []
  type: TYPE_NORMAL
- en: The Google search team has stated on multiple occasions that speed is a key
    ranking factor. They know that we want fast sites and that fast sites provide
    better user experience, which makes customers happy. Their goal is to provide
    the best resource to answer the user's question, which means that you need to
    provide a fast experience.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most troubling stats is the growing size of web pages. In 2015, the
    average web page passed the 2.5 MB mark, which is larger than the original installation
    disks for the game DOOM. Consequently, website performance has suffered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google research found the following, disturbing stats about the average web
    page''s size:'
  prefs: []
  type: TYPE_NORMAL
- en: 79% > 1 MB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 53% > 2 MB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 23% > 4 MB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is important because it takes about 5 seconds just to download a megabyte
    over a good 3G connection. That is not the end of the overhead, all the resources
    still need to be processed and the page has to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: If you consider the numbers reported by Google, this means that 79% of web pages
    don't even start the rendering cycle until 5 seconds after the initial request
    is made! At that point, the probability the user has bounced is 90%.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing image payload size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many point to images as being the root cause and to a certain degree they are,
    but images do not block rendering. Images can and should be optimized, which reduces
    the overall page size.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing image file sizes can reduce the overall payload size by an average
    of 25%. If the page is 1 MB, 25% equals a 250 KB payload reduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsive images should also be used. This is where you use the `srcset` image
    and sizes attributes, or the picture element to reference images that are sized
    appropriately for the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Client device viewports vary widely. Instead of trying to be exact on every
    device, I recommend focusing on four viewport classes: phones, mini-tablets, tablets,
    and desktops. I will borrow the breakpoints from the Twitter bootstrap project
    that correspond to these viewports.'
  prefs: []
  type: TYPE_NORMAL
- en: Any images above the different viewport width thresholds should be an array
    of images maintaining their aspect ratios at smaller widths.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of CSS and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real culprit behind delaying page load time is the overuse of CSS and JavaScript.
    Both are rendering blocking, which means that when they are being processed, nothing
    else happens.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from the chapters on service workers, the browser uses a single thread
    to manage all the rendering tasks, including processing CSS and JavaScript. While
    this thread is doing that processing, no rendering can take place.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are often naïve about the impact CSS and JavaScript has on their
    pages loading. Often, this comes down to forgetting what devices real users load
    web pages with, that is, mobile phones.
  prefs: []
  type: TYPE_NORMAL
- en: Developers generally work on high end workstations and laptops. They also load
    their work on those devices while developing. Therefore, they perceive their pages
    as loading instantly.
  prefs: []
  type: TYPE_NORMAL
- en: The discrepancy is a combination of no network latency, high speed processors,
    and ample memory. This is not the case in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Most consumers use cheaper phones, typically a $200 handset, not a $1,000 iPhone
    or a workstation. This means lower powered devices with constrained and limited
    network conditions do not load and render pages as fast as desktops.
  prefs: []
  type: TYPE_NORMAL
- en: To compound these limitations, when mobile devices are using battery power,
    they often slow down processors and even turn off cores to reduce power consumption.
    This means the time to process JavaScript and CSS takes much longer.
  prefs: []
  type: TYPE_NORMAL
- en: Numerous reports have demonstrated how much JavaScript affects how well a page
    loads. *Addy Osmani* published a canonical study ([https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e](https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e))
    showing how JavaScript gets in the way of a page loading.
  prefs: []
  type: TYPE_NORMAL
- en: A common misconception is that the primary performance impact is loading a script
    or style sheet over the network. This has some affect, but the bigger impact is
    once the file is loaded. This is where the browser must load the script in memory,
    parse the script, evaluate, and then execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: '"Byte-for-byte, JavaScript is more expensive for the browser to process than
    the equivalently sized image or Web Font"'
  prefs: []
  type: TYPE_NORMAL
- en: — Tom Dale
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use browser profiling tools, you can identify this phase of JavaScript
    by the presence of a yellow or a golden red color. The Chrome team calls *this
    a giant yellow slug*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In recent years, **single-page applications** (**SPAs**) have become very popular.
    This has given rise to large frameworks that abstract the native APIs and provide
    an architecture developers and teams can follow.
  prefs: []
  type: TYPE_NORMAL
- en: You should determine if a SPA is the right solution for your needs. The primary
    reason SPAs have enjoyed so much popularity is that they enable seamless page
    transitions, similar to a native app experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a service worker and utilize service worker caching, you can achieve
    the desired instant load and smooth page transitions SPAs offer. As a bonus, you
    won't need to load as much client-side JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: You can also learn the native APIs instead of framework abstractions, such as
    jQuery. For example, `document.querySelector` and `document.querySelectorAll`
    return references to DOM elements much faster than jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other native APIs I leverage, replacing most of what I used jQuery for, include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addEventListener`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setAttribute` and `getAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have tried to give you simple architectures which you can follow with the
    Podstr and PWA tickets applications. The benefit of not being a SPAis that you
    can reduce the amount of JavaScript needed to run a page.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket application relies on very little JavaScript. localForage and
    Mustache accounts are used for most of the JavaScript. The application and individual
    pages lean on next to no script. After applying gzip compression, the typical
    page needs less than 14 KB of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Proper test devices and emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I do recommend having realistic test devices. This does not mean buying an
    iPhone X, a Pixel 2, or Samsung 9\. You should have an average phone, which can
    mean different things for different areas. A baseline recommendation is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'North America and Europe: Motorola G4:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Regular 3G* in Devtools Network Throttling'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'India and Indonesia: Xiaomi Redmi 3s'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Good 2G* in Devtools Network Throttling'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The general rule is that with network constrained devices, those with slow and
    poor cellular connections, payload is important. Lower power, CPU, and memory
    constrained devices have more problems parsing and evaluating scripts and style
    sheets.
  prefs: []
  type: TYPE_NORMAL
- en: This is amplified when a lower powered device is using a constrained network.
    This is why you should architect your site as if all users have this bad combination.
    When you do, your site will always load quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we have numerous tools available to measure our pages' performance
    profiles and improve them. Different browser developer tools provide device emulation
    that provides a reasonable simulation of network and device constraints. WebPageTest
    is an example of a free online resource that can test real devices and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Key areas to focus on are server-side factors and how your pages load in the
    browser. The most important goal is to make your pages render as fast as possible
    and respond quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at different key performance indicators and how
    you can apply techniques and patterns to ensure that you provide a great user
    experience. We will also look at how these techniques relate to progressive web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing poor conditions using developer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The good news about testing for poor connectivity and average user devices is
    that it can be emulated. The Chrome, Edge, and FireFox developer tools all include
    some capacity to simulate slower connections and even lower powered devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome has the best developed conditional testing tools. In the Developer Tools,
    you need to toggle the device toolbar. The keyboard shortcut is *Ctrl* + *Shift*
    + *M* and the button is located in the top left corner. It looks like a phone
    overlaying a tablet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This changes the browser tab to render the page in a frame. The frame simulates
    the viewport of a target device. It also renders the device toolbar above the
    content frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The device toolbar consists of different drop-downs, allowing you to configure
    what device and connection scenario you want to emulate. The left most drop-down
    is a list of pre-configured devices. It contains some of the more popular devices
    and can be customized.
  prefs: []
  type: TYPE_NORMAL
- en: When you select a device, the width and height values are adjusted to match
    the device's viewport. I love this because it allows me to have a close proximity
    to the real device, without needing the real device.
  prefs: []
  type: TYPE_NORMAL
- en: I do recommend having a few real handsets to test your sites, but that can get
    expensive real fast. Personally, I have a couple of Androids, one high end and
    one low end, and an iPhone. Right now, I have an iPhone 6\. I recommend buying
    either refurbished hardware or cheap, pre-paid phones, which are available at
    most retailers for about $50 US.
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome device emulator does a fair enough approximation of real devices
    to allow me to complete my responsive design work. You should note that you are
    still using desktop Chrome, which is not exactly Android Chrome and certainly
    not iOS Safari.
  prefs: []
  type: TYPE_NORMAL
- en: The device emulator also has several popular Android tablets and iPads configured.
    Plus, you can also create your own viewports.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also adjust the zoom. This can be helpful if the content is too small
    for you to fine tune:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.gif)'
  prefs: []
  type: TYPE_IMG
- en: The last option is bandwidth. This is the far right drop-down. It includes options
    to simulate offline, middle-tier, and lower-tier connections. They try not to
    label these speeds by common cellular connections because that opens them up to
    issues of not being an exact match.
  prefs: []
  type: TYPE_NORMAL
- en: 3G, 4G, and LTE all vary by location, even in the same country. Labeling these
    speeds by cellular speed could be very misleading.
  prefs: []
  type: TYPE_NORMAL
- en: Since the vast majority of development occurs on high powered computers on a
    localhost site, developers often forget that their pages are loaded on cellular
    connections on phones. This leads us to assume that our pages are much faster
    than they actually are. Instead, you should always try to experience your site
    as close to real world scenarios as possible.
  prefs: []
  type: TYPE_NORMAL
- en: A big reason I encourage developers to not use JavaScript frameworks is after
    experiencing a mobile first application on 3G days before launching. It took about
    30 seconds for each page to load. I found not only was the poor 3G connectivity
    to be a problem, but the amount of JavaScript to be the bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: If I had not started using our application on my 3G handset, I would not have
    known how poor the user experience was. Back then, browser developer tools did
    not have these simulation features, which made the real device mandatory. So,
    be thankful that these tools exist, which can save you hours of time rearchitecting
    your sites.
  prefs: []
  type: TYPE_NORMAL
- en: I utilize these emulation features to develop my sites, especially for responsive
    design work. The speed emulation helps me feel issues my customers may experience,
    which allows me to have more empathy for them.
  prefs: []
  type: TYPE_NORMAL
- en: Performing performance and PWA testing with Lighthouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chrome includes a powerful tool to test how well your site performs and meets
    progressive web application criteria. This tool is called **Lighthouse**. The
    tool is integrated into the developer tools Audit tab and is available as a node
    module and command-line utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I will focus on using Lighthouse in the developer tool here and follow up with
    command line usage in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To perform an audit, press the Perform an audit... button, as seen in the preceding
    screenshot. You will then see a dialog that gives you high level configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five areas Lighthouse audits:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PWAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can run tests in all of these areas or only execute tests in selected areas.
    Lighthouse runs the audit and produces a scorecard and report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The report highlights specific areas where you can improve the page. In the
    preceding screenshot, I ran just a performance audit and you can see some of the
    specific areas to improve, including the perceptual speed index. I also had the
    tool take screenshots as the page loaded, so you can see how the page renders
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: The developer tools make it easy to run Lighthouse audits on a single page.
    You can run them from any Chrome instance, but I recommend opening an incognito
    instance. When you do this, you load the page in a clean browser, with no cache,
    cookies, or extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Because Chrome extensions run in the same process as the browser tab, they often
    interfere with pages and tools, such as Lighthouse. I found a page that normally
    loads fast and scores well suffers when extensions are included. They delay page
    loads and often execute well after the page completes loading.
  prefs: []
  type: TYPE_NORMAL
- en: It takes between 30-90 seconds to run a full audit. It depends on how many tests
    are being executed and the response time of your site.
  prefs: []
  type: TYPE_NORMAL
- en: The battery of performance audits that are run are very thorough, covering not
    only a desktop and high speed connection, but use emulation to simulate low powered
    phones over 3G connections. It is these conditions that expose your weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the report to pinpoint specific areas to correct, many of which
    are discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Each test has online documentation to explain what the test is and the actions
    you can take: [https://developers.google.com/web/tools/Lighthouse/audits/consistently-interactive](https://developers.google.com/web/tools/lighthouse/audits/consistently-interactive).
  prefs: []
  type: TYPE_NORMAL
- en: Because the PWA ticket application is fairly optimized, there are not many areas
    to address. This test was run on the home page, after the user was authenticated.
    The one area that presents a delay is the perceptual speed index.
  prefs: []
  type: TYPE_NORMAL
- en: This measures how long the page content takes to load. In this example, we scored
    47, which is very low. This is because the UI thread is unresponsive while making
    the API call and rendering the markup for the upcoming events and the user's tickets.
  prefs: []
  type: TYPE_NORMAL
- en: We can improve this score by passing the API call and rendering to the service
    worker or even a web worker. This would take the work out of the UI thread and
    place it in a background thread. This will require a shift in page and site architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Another recommendation is to use next generation image formats such as WebP
    and JPEG 2000\. While these image formats are more efficient, they are not broadly
    supported. This is partially due to their young age and partially due to licensing
    concerns by different user agents. So, for now, I tend to ignore these recommendations
    and hold out hope that these formats will be commonly supported in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: You could leverage a complex solution using the `PICTURE` element, but I find
    that it requires more management and responsibility than the payoff warrants.
  prefs: []
  type: TYPE_NORMAL
- en: It was announced at the recent Google I/O that Lighthouse version 3 will be
    available soon. They previewed an updated UI and a few new tests. You can read
    more about those announcements on the Google Developer's site: [https://developers.google.com/web/tools/Lighthouse/v3/scoring](https://developers.google.com/web/tools/lighthouse/v3/scoring).
  prefs: []
  type: TYPE_NORMAL
- en: As a word of caution, Lighthouse is an opinionated tool. This means that it
    looks for things Google and the Chrome team think are important. It is not a test
    running tool you can add custom tests or rules to based on your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: At the 2017 Microsoft Edge Web Summit, they announced a similar tool called
    Sonar ([https://sonarwhal.com](https://sonarwhal.com)). It is also a node module
    and command-line tool that exercises tests against a supplied URL. The difference
    with Lighthouse is the ability to expand the test suite as you want. Not only
    can you add publicly available tests or rules, you can author your own.
  prefs: []
  type: TYPE_NORMAL
- en: Sonar can perform and does use the same test suites as Lighthouse, but allows
    you to add more. At the time of writing this book, it is not available in the
    Edge developer tools like Lighthouse. They do offer an online instance where you
    can test public URLs and of course run it locally as part of your test suite.
  prefs: []
  type: TYPE_NORMAL
- en: You should make Lighthouse and Sonar part of your routine developer work flow.
    You can quickly spot not only performance issues, but missing progressive web
    application requirements, best practices, basic SEO issues, and bad server configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebPageTest to benchmark performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**WebPageTest** ([https://webpagetest.org/](https://webpagetest.org/)) is a
    free tool you can use to give you web performance details. It works much like
    developer tools, but adds even more value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Not only does it provide a detailed waterfall, it provides testing from different
    locations, varying speeds, and devices. Sometimes, the truths it reveals can be
    hard to swallow, but it provides you with targeted areas so that you can improve
    your performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To perform a test, visit [https://webpagetest.org](https://webpagetest.org).
    If your site has a public URL, enter it in the form and select a location, device/browser,
    and a speed to test. Once you submit the request, your site is evaluated using
    real hardware. After a minute or two, assuming it is not added to a queue to be
    processed, you receive a report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like the browser developer tools provide a network waterfall, WebPageTest
    can too, but with even more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A key metric I always check is the speed index. This is a performance indicator
    created by Patrick Meenan, the mind behind WebPageTest, that measures how visually
    complete a page is over its load time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It measures how much white space is visible compared to the final render. The
    goal is to minimize the time to a complete render. Speed Index is a way to measure
    the time to the first interaction or perceived rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good number to target is 1,000 or less. This indicates that it took 1 second
    or less to render the page. For reference, most pages I evaluate score well over
    10,000, indicating that it takes at least 10 seconds to render. These poor scores
    are over a broadband connection, so the value is much worse for cellular connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.gif)'
  prefs: []
  type: TYPE_IMG
- en: There are many advanced features and settings that can be used to execute WebPageTest,
    including custom scripts. You can even stand up your own virtual machine either
    locally or in Amazon AWS. This is helpful when you have an enterprise application
    that's hidden behind a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Key performance indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to creating a fast site or improving an existing site is to use
    tools to measure your performance and knowing what to measure. You should create
    a performance baseline and make iterative changes to improve your performance
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will review different metrics you should measure, why you
    need to track them, and how to improve them.
  prefs: []
  type: TYPE_NORMAL
- en: Time to first byte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The time it takes to retrieve the first response byte is the time to first byte.
    This moment starts the response download. The most important network request is
    for the document. Once downloaded, the rest of the network resources (images,
    scripts, style sheets, and so on) can be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can break down the time to first byte process into different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Time to create a connection between the browser and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time it takes to retrieve and possibly render the file on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time it takes to send the bytes to the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest way to measure time to first byte is by opening the browser developer
    tools by pressing *F12* or *Ctrl* + *Shift* + *I*. Each browser's developer tools
    have a network tab. Here, you can see a page's waterfall. You may need to refresh
    the page to generate the report.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend performing both a primed and unprimed request. The difference is
    when loading the page as if this is the first time you have visited the site,
    which is called unprimed. In this state, there is nothing being persisted in the
    browser cache. You should also clear or bypass your service worker.
  prefs: []
  type: TYPE_NORMAL
- en: You can trigger an unprimed request by doing a hard reload, *Ctrl* + *F5*.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the following waterfall example, you will notice that the first
    request, the one for the document or HTML, completes first. The browser then parses
    the markup, identifying additional assets to load. This is when those requests
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be able to notice this pattern for all pages, even when assets are
    locally cached. This is why there is a slight time gap between the initial document
    request and the supporting resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A primed request assumes that you have visited the site or page before, and
    the browser and possibly the service worker cache contain valid responses. This
    means those requests are made locally, with no network activity. In theory, the
    page should load faster thanks to the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The waterfall is composed of each file request required to compose the page.
    You should be able to select an individual request (double click the request in
    the waterfall) to see how much time each step took:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome, FireFox, and Edge let you visualize the time to first byte. Each have
    a Timings panel that breaks apart the different parts of the request and the time
    allocated. It refines the parts a little more, showing you time to perform DNS
    resolution, creating the connection to the server, and the time it took the server
    to send the bytes to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Before a network request is made, it is added to a browser queue. This queue
    is a collection of requests the browser needs to make. Each browser determines
    how this queue is processed, which depends on available resources, HTTP/2 versus
    HTTP/1 support, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if needed, the browser triggers a DNS resolution. If the device has a
    cache domain resolution or IP address, this step is skipped. You can speed this
    up by using the `dns-prefetch`, which I will cover a little later.
  prefs: []
  type: TYPE_NORMAL
- en: The browser then makes the network request. At that point, it is up to the server
    to send a response. If the server has any bottlenecks, you should address those
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget TLS negotiation. There is a slight performance hit for HTTPS, but
    when using HTTP/2, this hit is typically washed out by additional performance
    enhancements offered by HTTP/2.
  prefs: []
  type: TYPE_NORMAL
- en: You can reduce your time to first byte by optimizing your server configuration.
    You should look for opportunities to reduce disk I/O by caching responses in memory.
    In ASP.NET, this is done by implementing the Output cache. Other web platforms
    provide similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Database queries are another common bottleneck. If you can eliminate them, you
    should. Evaluate the page's data and find the data that could be retrieved ahead
    of time. I like to create JSON data files or objects in memory to avoid these
    expensive queries.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main reason no-SQL, document databases such as MongoDB and ElasticSearch,
    and cloud services such as DynamoDB have grown in popularity. These databases
    as designed to have pre-selected and formatted data ready to go on demand. These
    solutions have helped popular online sites such as Twitter, Facebook, and so on
    grow and scale very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Another tactic is to avoid on-demand rendering as much as possible. Most websites
    are rendered by a server process such as ASP.NET, PHP, Ruby, Node, and so on.
    These all add overhead to the request process. By pre-rendering markup where possible,
    you reduce the opportunities for these processes to slow down the response.
  prefs: []
  type: TYPE_NORMAL
- en: I try to use a static website solution when possible because they offer the
    fastest response pipeline. Static sites have the advantage over runtime rendering
    because the rendering cycle is removed. You can create your own engine to pre-render
    content or use a tool like Varnish to manage the task. You don't have to abandon
    your existing processor, but instead add a static engine on top to maintain the
    static files so that your pages load faster.
  prefs: []
  type: TYPE_NORMAL
- en: The only remaining point of friction is the speed of the networks. Unfortunately,
    these are typically out of your control. Routers, proxies, and cell towers can
    all cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the response bytes start streaming into the browser for processing.
    The larger the file, the longer, typically, the delay.
  prefs: []
  type: TYPE_NORMAL
- en: The PRPL pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at both the time to first byte and runtime performance issues.
    The best way to make sure that your site is performing its best is by implementing
    architecture best practices. The PRPL pattern was created to help modern web applications
    achieve top performance values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Google Polymer team developed PRPL as a guideline to follow to help websites
    perform better. It should be considered an architecture you can implement, but
    it is not all about technical specifics. To quote the PRPL documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"PRPL is more about a mindset and a long-term vision for improving the performance
    of the mobile web than it is about specific technologies or techniques."'
  prefs: []
  type: TYPE_NORMAL
- en: PRPL goes back to the principle of putting performance as a first-class feature
    of any website.
  prefs: []
  type: TYPE_NORMAL
- en: 'PRPL stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P**ush critical resources for the initial URL route using `<link preload>`
    and HTTP/2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R**ender initial route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**P**re-cache remaining routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**azy-load and create remaining routes on demand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though PRPL was created with modern single page apps in mind, progressive
    web applications can benefit from following the PRPL pattern. Service workers
    are a valuable tool for implementing the PRPL pattern because you can leverage
    the Cache API to implement the pattern. You just have to adjust how the different
    principles are applied to improve your apps' performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary goals of the PRPL pattern are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimum time-to-interactive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially on first use (regardless of entry point)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially on real-world mobile devices
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum caching efficiency, especially over time as updates are released
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplicity of development and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing push with browser hints and the service worker cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first concept of push relies on implementing the HTTP/2 server-side push.
    I have found this to be difficult to configure as most servers have not yet implemented
    HTTP/2 push.
  prefs: []
  type: TYPE_NORMAL
- en: This is where service workers can offer a solution I feel is even better. We
    looked at how to implement pre-caching, an excellent alternative to using HTTP/2
    Push. By using pre-caching, you are effectively pushing those critical assets
    to the browser before they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the resources you pre-cache should be critical and common application
    assets. These assets should mirror what you might want to configure HTTP/2 push
    to send.
  prefs: []
  type: TYPE_NORMAL
- en: Combining service worker caching with the preload resource hint can recreate
    most of what HTTP/2 push does. Browsers use preload hint to initialize resource
    requests before they are encountered in the code. When paired with pre-cached
    assets, the loading process is lightning fast.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, resource hints like preload may not seem to provide much advantage.
    But as a page's composition grows complex, these hints can improve page load and
    rendering time significantly.
  prefs: []
  type: TYPE_NORMAL
- en: The browser does not initiate a request until it is parsed from the HTML or
    initiated from a script or style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom font files are a perfect example. Their downloads are not initiated
    until the browser parses the style sheet and finds the font reference. If the
    files are included as a preload resource hint, the browser has already loaded
    or at least started the request, making the file available sooner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the resource content type allows the browser to:'
  prefs: []
  type: TYPE_NORMAL
- en: Prioritize resource loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match future requests and reusing the same resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the resource's content security policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the resource's correct Accept request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also add the resource MIME type. When you do this, the browser can
    determine if it supports the resource type before it attempts to download the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to make the page or application's assets available before the DOM
    parsing triggers a request. Since these assets are available in the service worker
    cache, they are already stored locally and can be loaded instantly.
  prefs: []
  type: TYPE_NORMAL
- en: You can notice the difference in the waterfall where `preload` hints are used.
    Do you remember that I pointed out a slight time gap between the initial markup
    being loaded and the assets in earlier waterfalls?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the following waterfall, you will notice that the dependencies
    are initiated before the markup has finished loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is due to the browser identifying these assets with the preload hint applied.
    It starts downloading the resource as soon as the item is parsed from the markup,
    not after the entire document is completely parsed.
  prefs: []
  type: TYPE_NORMAL
- en: You should also note how fast these resources are loaded. This is due to them
    being cached using service worker caching. This eliminates the network bottleneck,
    which in some cases means that the files are loaded even before the markup is
    completely parsed.
  prefs: []
  type: TYPE_NORMAL
- en: It's a slight page load advantage, not a major improvement. Every little bit
    helps as milliseconds quickly add up.
  prefs: []
  type: TYPE_NORMAL
- en: Using the app shell model and service worker to render the initial route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the PRPL pattern was designed from a SPA first perspective, the language
    speaks to that architecture. But as you have seen in the previous chapters, app
    shells are useful for progressive web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Even when you don't have a page cached, you should have at least your application's
    markup shell cached locally. This can serve as your initial render, giving the
    user a sense of response. Meanwhile, you can retrieve any assets from the network
    to complete the page.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA tickets app uses the service worker to render pages using Mustache templates
    and JSON data retrieved from the API. This is an example of how you can return
    the app shell as a valid response to a request and then update the content once
    it is available.
  prefs: []
  type: TYPE_NORMAL
- en: My rule is to give the user everything I have at the moment and fill in the
    blanks as I have more to give. This could be a combination of supplying the app
    shell and replacing it later or injecting the page-specific markup once it is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker pre-caching important routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in this book, it should be obvious how a good service worker pre-caching
    strategy applies to the PRPL pre-caching point, but it never hurts to review the
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: The second P in PRPL stands for pre-caching common routes. This includes the
    HTML and their supporting files such as styles, images, and scripts. This is exactly
    how your service worker's pre-cache strategy should be designed.
  prefs: []
  type: TYPE_NORMAL
- en: Important assets are commonly visited pages, but can also be the markup templates
    required to render the pages in the service worker. The common styles, scripts,
    images, and other support assets should be pre-cached.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy-loading non-critical and dynamic routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not every page in every website can or should be cached ahead of time. As you
    saw in  [Chapter 5](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d), *The
    Service Worker Life Cycle*, you should also have cache invalidation logic in place
    to ensure that you supply the freshest content.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic content, like the available ticket events or even an updated list of
    podcast episodes, is difficult to cache long-term. But you can provide a better
    experience than just waiting to download all of the page's resources.
  prefs: []
  type: TYPE_NORMAL
- en: This is where employing one or more of the common caching strategies is helpful.
    You can also combine your rendering strategy with the app shell concept and build
    the page as assets are loaded or updated.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pre-cache and update common support assets as needed. This is one
    of the underestimated powers of the web, dynamically updating what is rendered
    and how it is rendered. You can update not just the markup in a page, but change
    style sheets and scripts on the fly too.
  prefs: []
  type: TYPE_NORMAL
- en: As you have also learned, you can cache assets in the service worker without
    affecting the UI thread. This can be used to pre-cache non-critical assets and
    update previously cached content.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, service worker caching makes implementing the PRPL pattern very
    natural. Its ability to cache resources makes all four PRPL principles easy to
    implement. If you have followed the examples and guidelines in the previous chapters,
    then you have seen how to design PRPL compliant progressive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think the number one PRPL principle is to cache as much of your application''s
    assets in the client as possible. This makes the network nice to have and not
    a potential source of delay and uncertainty. This is exactly what service worker
    caching was designed to do: make your assets close to the user''s glass.'
  prefs: []
  type: TYPE_NORMAL
- en: The RAIL pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RAIL pattern is an acronym used by the Google Chrome team to define one
    of the many WPO patterns you should try to follow. Its goal is to ensure your
    user experience is responsive:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response**: How quickly there is a response when there is any input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation**: Includes visual animation, scrolling, and dragging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idle**: Background work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load**: How quickly a page can achieve the first meaningful paint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the PRPL pattern is concerned with resource loading, RAIL is about the
    runtime user experience or what happens once the resources are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is designed to be user centric, focusing on performance first. The
    four aspects that make up the acronym are distinct areas of a web application
    and page's life cycle, or what happens once the bytes are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the different areas where performance is important: loading, rendering
    and responding to actions. There is more than just the page load phase. Page load
    is how fast the browser can load the assets, but many forget it still needs to
    process those assets and render the content. Then, once rendered, you can respond
    to user interactions.'
  prefs: []
  type: TYPE_NORMAL
- en: You also need to consider how quickly the page response is to a click or tap.
    Is scrolling smooth? Are notifications prompt? What about any background activities,
    are they efficient?
  prefs: []
  type: TYPE_NORMAL
- en: The first critical factor to the average user is how long it takes for a page
    to become interactive, not how long it takes to download the files.
  prefs: []
  type: TYPE_NORMAL
- en: At the recent Google I/O, the team announced new metrics that Lighthouse will
    report, specifically **First Contentful Paint** (**FCP**). This is the point at
    which the browser renders the first pixel of a new page's DOM. The measurement
    starts from the time of navigation to the point that the first pixel is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is a key performance indicator is that this is the first visual
    queue to the user where their requested action or navigation is being handled.
    I like to translate that into saying that this is the point where the user knows
    the page is coming and was not lost in the ether, causing them to try and reload
    the page or give up.
  prefs: []
  type: TYPE_NORMAL
- en: The FCP is available from the Paint Timing API ([https://w3c.github.io/paint-timing/](https://w3c.github.io/paint-timing/)),
    one of the modern performance APIs available in modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The next KPI you should focus on is **Time to Interactive** (**TTI**). This
    is the point where the page is fully rendered and capable of responding to user
    input. Often, even though the page appears to be rendered, it cannot respond to
    the user due to background processing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the page is still processing JavaScript, which locks the UI thread
    and the page cannot be scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: RAIL focuses on the user; the goal is not to necessarily make the site perform
    fast on a specific device, but to make your user happy. Any time a user interacts
    with your content, you should have a response within 100 ms. Any sort of animation
    or scrolling should also respond within 10 ms.
  prefs: []
  type: TYPE_NORMAL
- en: Because modern web pages tend to do a lot of background processing, you should
    maximize idle time to perform these tasks, not blocking interaction and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to perform any non-UI processing, such as data transformations,
    service workers or web workers provide a channel for you to offload those processes
    to background threads. This frees the UI thread to focus on UI tasks, like layout
    and painting. It also frees the UI to immediately respond to user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Focus on delivering interactive content within one second. This can be very
    difficult to achieve over cellular networks and average mobile devices, but not
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, server load time is not the majority of your web performance
    profile, it's the resource processing that creates the bigger bottlenecks. That's
    because scripts and style sheets block the critical rendering path, leaving your
    page partially rendered or appearing to be hung.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have never heard of the critical rendering path, it is the workflow
    that browsers use to compose and render a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document Object Model** (**DOM**)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CSS object model **(**CSSOM**)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render Tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paint
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To compose the DOM, the browser must complete these substeps:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert bytes to characters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify tokens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert tokens to nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the DOM Tree
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to building the DOM, the browser follows a similar series of steps
    to compose the CSSOM or process styles:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert bytes to characters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify tokens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert tokens to nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build CSSOM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The important takeaway for CSS is just like JavaScript: it is rendering blocking.
    The browser must process the page''s styles before it can be rendered. Multiple
    large CSS files cause the CSSOM process to repeat. The larger the style sheet,
    the longer this step takes.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the DOM and CSSOM are created, the browser then combines the two to compose
    the render tree. This is followed by the layout step, where all the size and color
    attributes are calculated for all the page elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the pixels are painted to the screen. This is not always 'instant',
    as different styles and style combinations take different amounts of processing
    to render.
  prefs: []
  type: TYPE_NORMAL
- en: How JavaScript clogs the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOM and CSSOM processes work together to produce what is rendered on the
    screen, but there is a third part of the rendering cycle, that is, processing
    JavaScript. Not only is JavaScript a render blocker, it is also a parser blocking
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the primary reason we add script references at the end of the HTML.
    By doing so, the browser has a chance to parse the HTML and CSS before attempting
    to load scripts, which blocks the parsing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.gif)'
  prefs: []
  type: TYPE_IMG
- en: When the browser encounters a script, it stops the DOM and CSS parsers to load,
    parse, and evaluate the JavaScript. This is one reason I make intentional efforts
    to minimize my JavaScript size.
  prefs: []
  type: TYPE_NORMAL
- en: There are some tricks you can employ to minimize this behavior. The first is
    to mark any script you can as async. This causes the browser to casually load
    the script file.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds great at first, but most of the time, I have found this to be a
    more optimistic than practical. There always seems to be at least one critical
    script that requires execution as the page is being rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can mark all your scripts as asynchronous and see if there are any issues
    when running your application. Just be thorough with your testing to flesh out
    any edge cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another solution is to minify your scripts and then inline them in your markup.
    This can also help your rendering cycle. One of the main benefits is not waiting
    on an additional file to download.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are using HTTP/2, the multiplexing capabilities will probably
    offer more benefits. With HTTP/2, you are often better off using small files that
    can be individually cached than large file bundles.
  prefs: []
  type: TYPE_NORMAL
- en: When you inline scripts, the size of your HTML grows, which can delay its processing.
    However, as you are about to learn, inlining CSS is highly beneficial. It is a
    matter of testing to see what works best for your page and application.
  prefs: []
  type: TYPE_NORMAL
- en: Why 14 KB is the magic number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an effort to control network traffic, TCP implements a pattern called slow
    start. It does this to keep the network from being overwhelmed with requests.
    The details are specified in RFC 5681 ([https://tools.ietf.org/html/rfc5681](https://tools.ietf.org/html/rfc5681)).
  prefs: []
  type: TYPE_NORMAL
- en: The protocol works where the sender or initiator sends an initial, small packet.
    When it receives a response, it then doubles the packet size. This volley is repeated
    until the sender receives a congested response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial packet size is 14 KB. This back and forth is a series of round
    trips. If you can fit an entire page or response within 14 KB, it only needs one
    round trip to be completely downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the response is 10.5 KB, so only 1 round trip is required.
    You should note that this example is not compressed, which would reduce the size
    significantly. This is another point I want you to remember as we apply resource
    inlining a little later.
  prefs: []
  type: TYPE_NORMAL
- en: The initial TCP data packet is actually 16 KB, but the first 2 KB are reserved
    for request header data. The remaining 14 KB are where your content or data are
    transferred. If the content is more than 14 KB, then a second round trip is initiated,
    and this time the packet size is doubled to 32 KB. This repeats until there is
    a network congestion message.
  prefs: []
  type: TYPE_NORMAL
- en: By limiting the request to a single round trip, you are able to load the entire
    response almost instantly. The more round trips, the longer the data takes to
    load.
  prefs: []
  type: TYPE_NORMAL
- en: Inline critical CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you inline CSS, you eliminate the required round trips to retrieve the
    styles, and they are immediately available to the browser as it parses the DOM.
    This makes these two critical steps much faster.
  prefs: []
  type: TYPE_NORMAL
- en: To refresh, when the browser encounters external style sheets, it blocks any
    rendering until the style sheets are fully loaded.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, you want to limit the size of a page's CSS to just the
    CSS required to render the page. By limiting the styles to just those used by
    the page, you can typically reduce the amount of CSS to a handful of kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: Because the amount of real CSS is minimal, you can inline those styles in the
    document's `head` element. Now, the browser has no external file to download and
    a minimal amount of CSS to load. Plus, you have the critical styles required to
    render the app shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PWA ticket app has a very standard app shell: `header`, `body`, and `footer`.
    Each individual page requires a minimal amount of custom CSS to render its content.'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that there are tools available to help you identify the CSS
    each page requires. There are multiple node modules available, but I have focused
    on the UnCSS module ([https://www.npmjs.com/package/uncss](https://www.npmjs.com/package/uncss)).
    It was one of the first modules created to identify the required CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Because these are node modules, you can include them in a build script. The
    PWA ticket application has a build script in the project's `utils` folder called
    `render-public.js`. I won't go into all of the script's details, but it runs over
    the site's source to produce the site's pages and support files.
  prefs: []
  type: TYPE_NORMAL
- en: The `extractCSS` function handles extracting a page's styles, minimizing them,
    and injecting them into the `head` element.
  prefs: []
  type: TYPE_NORMAL
- en: There are additional node modules being used to help. Cheerio loads HTML and
    creates an object with the jQuery API, just like you were using jQuery in the
    browser. This makes manipulating the markup much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second module is CleanCSS. This module minifies styles, removing unnecessary
    white space, thus making the code take up less space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: UnCSS has a long list of configuration options you can use to control how the
    module executes. I have supplied the most common settings I use, like media query
    breakpoints and eliminating banner comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, I find that I still need to include a list of selectors that should
    not be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I have also found that removing any script references from the markup will help
    the module. When the module finds a script, it does try to load it and execute
    it. This is because UnCSS exercises the page in a headless browser, which loads
    the page just as if it were a normal browser.
  prefs: []
  type: TYPE_NORMAL
- en: UnCSS can either process raw HTML, which is how I use it, or load a page via
    a URL or local path. It utilizes the standard node callback pattern, so you should
    write your code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing I try to do is inject potential content templates in the HTML
    to be processed. This should help UnCSS isolate all the styles needed, even when
    they are dynamically rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Like UnCSS, CleanCSS also uses the callback pattern. You can supply the filtered
    CSS and it will return a minified version.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can inject the minified styles into the HTML `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have the page's HTML with all its required CSS, inline in
    the markup HEAD. For the PWA ticket application, the typical page is around 30
    KB, which does not meet the 14 KB goal.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we are not done.
  prefs: []
  type: TYPE_NORMAL
- en: Static resources, like HTML, should be compressed. You can use gzip or deflate
    compression. Brotli is another option, but is not universally supported by all
    browsers. Once you compress these files, they typically reduce to around 8 KB,
    well within our 14 KB goal!
  prefs: []
  type: TYPE_NORMAL
- en: 'Most web servers can be configured to compress text files on demand. But as
    you can imagine, I like to do this as part of my deploy process. This can be done
    with a node, but you should check with your devops team to make sure that this
    is being done for your site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Make sure any compressed files are served with the Content-Encoding header set
    to gzip or deflate so that the browser knows to decompress the response.
  prefs: []
  type: TYPE_NORMAL
- en: Minifying scripts with uglify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like CSS, you should also minimize JavaScript files. Just like we used
    Clean-CSS to minify CSS, you can use uglify to do the same for your JavaScript.
    Instead of inlining the script, I like to keep it in individual files.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, I would have also bundled multiple script files together. HTTP/2
    utilizes request multiplexing to optimize content delivery. By keeping each script
    in individual files, you can take advantage of long term caching and make small
    changes without requiring a complete download.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to minimizing the scripts, I am also going to show you how to create
    unique file names using an MD5 hash on the content. This will allow you to apply
    a very long caching time without worrying about browser caches retaining stale
    copies. This technique is advanced and does require some planning and, of course,
    an intelligent build or rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple uglifier node modules. I chose `uglify-js` for the PWA ticket
    application. The way I tend to pick modules like this is to look at popularity,
    but also what popular task runners such as Grunt, Gulp, and WebPack plugins rely
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: As a word of warning, `uglify-js` does not handle ES6 syntax, like `let` and
    `const`, and will throw errors when encountered. But I warn against using ES6
    syntax in the browser since there are still many browsers that do not support
    it, such as Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the build script, I chose to create a simple uglify module to reference
    in the overall build script. It references `uglify-js` and creates an `uglify`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The class `constructor` and `transformSrc` methods are used to set up before
    minification. They are set up to allow you to pass either a single script reference
    or an array of scripts to uglify and concatenate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like UnCSS, uglify allows you to customize the process. This is where
    the options allow you to configure the module. For this, I chose some simple settings
    I like to use to optimize the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The render script not only uglifies each script; it also creates a unique hash
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The file is calculated by passing the script's contents to the nodejs crypto
    object. The crypto object makes calculating hashes simple. In this case, I want
    an md5 hash value, so when the `createHash` method is called, you supply the `'md5'`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with md5 hashes, they are a cryptographic way of generating
    a checksum to verify data integrity. They are not good for cryptography, but provide
    a unique value based on the data. That unique value is helpful for creating a
    unique file name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The uniqueness is good enough to have faith that the script file name won't
    be duplicated within your application. The build script needs to not only generate
    unique hash values, but save the file with the hash name. It could also just rename
    the source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even after you create the file with the unique file name, you still need to
    integrate it into the HTML files. The render script takes care of that task. The
    product looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I also added `.min` to each one of the files because the scripts have been minimized.
    This is done out of convention rather than a requirement. The benefit is for tools,
    like browser developer tools, that understand that the script is minimized. Edge
    allows you to choose to bypass the script when you are debugging because `.min`
    is appended to the file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because each page also sets a preloaded hint for the script files, those references
    must also be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, why did I add this complicated renaming step to the build and render processes?
    To enable long cache time frames. This tells the browser to attempt to cache the
    response locally in the built-in browser cache, not the service worker cache.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended time to live is at least a year. Most scripts can and will be
    updated in that time frame and the hash name technique gives you a guaranteed
    cache busting technique. Other techniques, like appending a unique `QueryString`
    parameter, may not always work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the long time to live by setting the `cache-control` header. This
    needs to be done in your web server, so that it will be part of your devops workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: I won't dive into the art of configuring Cache-Control headers, but you can
    use the preceding example as a reference. Files such as scripts, style sheets,
    and even images are candidates for the hash naming trick. Just be sure to update
    any references to the files to the new name.
  prefs: []
  type: TYPE_NORMAL
- en: Using feature detection to conditionally load JavaScript polyfils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PWA ticket application uses many modern APIs, but some are not supported
    by older browsers. There are two browser scenarios you should be most concerned
    with: Internet Explorer and older Android phones. UC Browser is another popular
    browser that does not support all newer features yet.'
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer is the now deprecated Microsoft Browser. The only supported
    version is IE 11, and right now only lives on Windows 7 and in enterprises. Enterprises
    use many line of business applications, and many were created against old and
    obsolete web standards. Often, it is expensive for them to update or replace these
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer provides a legacy browser channel for them to continue running
    these applications. However, when they upgrade to Windows 10, they should configure
    these line of business applications to trigger Internet Explorer from Edge as
    needed and not as a default browser.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the default behavior you should expect is Edge, not Internet
    Explorer on Windows 10\. However, human nature and habits often override recommended
    practice, which means IE is still a very popular browser.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, most of the modern APIs PWA tickets use can be polyfiled. This
    is where a script can be loaded, on demand, to implement the new API. Other APIs
    can be safely used behind a feature detection gate, like we do before registering
    a service worker, or be trusted to be gracefully ignored. The latter is how modern
    CSS properties are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a feature polyfil can be done as needed using feature detection and
    a simple technique I call toggling a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PWA tickets application uses 4 polyfils:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.Assign`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fetch API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntersectionObserver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The trick relies on these script references applying a type attribute other
    than script. This tells the browser that even though it is a script element, the
    src is not a script. Of course, the src files are scripts, but by setting the
    type to something else, the browser does not download the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toggleScript` method takes a supplied ID to reference the polyfil''s `script`
    element. It then toggle''s the script''s type from `script-polyfil` to text/JavaScript.
    When this toggle happens, the browser downloads and processes the polyfil script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All this depends on the polyfil being needed. Each API or feature support can
    be detected with a simple test. If the test fails, the feature is not supported,
    and the toggleScript method is called to load the polyfil.
  prefs: []
  type: TYPE_NORMAL
- en: You should put this code before you load any of the application-specific code
    or any code that might depend on these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading polyfils is important because it means you will use the
    native APIs when present and avoid loading these expensive files when the native
    API is present.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you need to load these polyfils, the page load suffers. however, I
    think that this is a reasonable trade off because these older browsers will run
    slower in the first place and the user may not have the same expectations as someone
    using a modern browser.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images can delay your overall page load experience due to image numbers and
    their size. There are different strategies for optimizing image delivery. The
    first one you should consider is lazy loading images below the fold.
  prefs: []
  type: TYPE_NORMAL
- en: This could be a very tricky technique to execute. Modern APIs can help you,
    the `IntersectionObserver` ([https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API))
    API in particular gives you the ability to detect when elements are entering the
    viewport. You can designate the distance and time estimated threshold for an element
    to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IntersectionObserver` API will trigger an event to let you know when an
    element is about to be displayed. At this point, you can initiate an image download
    if necessary. This means that your pages images will not be loaded in the initial
    render process, but be loaded as needed. This can conserve valuable bandwidth
    and network connections in that initial page load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the images `src` attribute, you can designate the image source
    as a data attribute (`data-src`). You should also do the same thing for the `srcset`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showImage` function handles toggling the `data-src` and `data-srcset`
    values to the corresponding `src` and `srcset` values. This causes the browser
    to load the images just before they come into view, or on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re worried about legacy browsers supporting `IntersectionObserver`,
    don''t worry: there is a polyfil ([https://github.com/w3c/IntersectionObserver/tree/master/polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill)).
    Right now, Chrome, Firefox, and Edge have native `IntersectionObserver` support.
    The polyfil allows you to use this technique in other browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: You should use feature detection to determine if you need to load the polyfil
    and the polyfil technique that was described previously.
  prefs: []
  type: TYPE_NORMAL
- en: The PWA ticket application uses the `IntersectionObserver` pattern to lazy-load
    images. I also want to point out a key aspect of this technique, which is specifying
    the images' render size as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has focused on improving your progressive web app's performance.
    You have learned about key performance indicators you can measure as well as tools
    to measure your application.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have identified items to improve, you can attack them to improve your
    page load time and response times.
  prefs: []
  type: TYPE_NORMAL
- en: You have also been given some techniques and been exposed to code to help you
    build your pages to provide a better user experience. You have seen how to minimize
    the amount of code each page needs, improve caching, and reduce the initial page
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how to automate your progressive web application
    workflow to ensure that you have a consistently performing and qualifying PWA.
  prefs: []
  type: TYPE_NORMAL
