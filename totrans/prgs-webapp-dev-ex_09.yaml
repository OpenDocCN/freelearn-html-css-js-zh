- en: Optimizing for Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performance is one of the key aspects of user experience. In fact, many experts
    argue that web performance creates a good user experience. There are different
    aspects of web performance that you should consider when you are delivering an
    online experience, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to first byte** (**TTFB**) and server-side latencies'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering processes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the primary attributes of a **Progressive Web App** (**PWA**) is speed.
    That's because people like pages to load fast and respond to actions or input
    even faster. Making fast, interactive websites is as much of an art as it is a
    science.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into making fast PWAs, I want to define what this chapter is
    designed to help with:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Goals**: Defining key performance indicators to measure performance'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guidelines**: Defining ways for you to achieve these goals'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Demonstrate**: Applying these guidelines to the PWA ticket app so that you
    have a reference code and workflow'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will go deep into how the browser loads and renders pages. You
    will also learn details of how TCP works and how you can take advantage of this
    knowledge to create pages that load within 1 second.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: You will learn different intermediate and advanced **web performance optimization**
    (**WPO**) techniques and how they relate to PWA design. These techniques are woven
    into the natural fabric of the PWA ticket application. As this chapter evolves,
    you will learn techniques which rely partially on an automated build script. This
    automation will be carried over to the following chapter, where I will be reviewing
    different tools to help you build PWAs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The importance of WPO
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DoubleClick and others websites have shown that 3 seconds is all you have. If
    the perceived page hasn't loaded within 3 seconds, 53% of mobile visitors abandon
    the page ([https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/](https://www.doubleclickbygoogle.com/articles/mobile-speed-matters/)).
    Additionally, DoubleClick reported that sites loading within 5 seconds enjoyed
    70% longer sessions, 35% lower bounce rates, and 25% higher advertisement viewability.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Those examples are just a small sampling of the numerous case studies and reports
    available, demonstrating how important page load and interaction are for a website's
    success. You can find many more statistics at [https://wpostats.com](https://wpostats.com).
    This is one of the reasons web performance is continually emphasized by Google
    as a key ranking signal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Human psychology is an important aspect of performance. We know how the brain
    perceives performance and can correlate the science to our web pages:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**0 to 16 ms**: Users perceive animations as smooth, so long as 60 new frames
    are rendered every second or 16 ms per frame. This leaves about 10 ms to produce
    a frame after considering browser overheads.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0 to 100 ms**: Users feel like the response to an action is immediate.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**100 to 300 ms**: Slight perceptible delay.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**300 to 1000 ms**: Things feel part of a natural and continuous progression
    of tasks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**300到1000 ms**：感觉像是任务自然和连续进展的一部分。'
- en: '**>= 1000 ms**: (1 second), users loses focus on the task.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**>= 1000 ms**：用户会失去对任务的注意力。'
- en: Put a mental pin in those numbers because they serve as a primary benchmark
    for this chapter. The goal of this chapter is to modify the PWA ticket application
    to load within 1 second over an average 3G connection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数字记在心里，因为它们是这个章节的主要基准。本章的目标是将PWA票务应用程序修改为在平均3G连接下1秒内加载完成。
- en: Loading fast gives you a competitive advantage because the average web page
    takes 15 seconds ([https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)
    ) to load on mobile devices, a 7 second improvement over the 2017 standard. Not
    only has this improved the user's engagement, but also stats that were commonly
    reported when site performance is optimized. Such sites enjoy higher search rankings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 快速加载给你带来竞争优势，因为平均网页在移动设备上加载需要15秒（[https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/](https://www.thinkwithgoogle.com/marketing-resources/data-measurement/mobile-page-speed-new-industry-benchmarks/)），比2017年的标准快了7秒。这不仅提高了用户的参与度，还改善了当网站性能优化时通常报告的统计数据。这样的网站享有更高的搜索排名。
- en: The majority of web traffic comes from mobile devices. Some businesses see as
    much as 95% of their traffic coming from smartphones. This is why Google is switching
    their primary search index from desktop to mobile by June 2018.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络流量来自移动设备。一些企业发现高达95%的流量来自智能手机。这就是为什么谷歌将他们的主要搜索索引从桌面切换到移动，截止到2018年6月。
- en: The Google search team has stated on multiple occasions that speed is a key
    ranking factor. They know that we want fast sites and that fast sites provide
    better user experience, which makes customers happy. Their goal is to provide
    the best resource to answer the user's question, which means that you need to
    provide a fast experience.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌搜索团队多次表示，速度是一个关键排名因素。他们知道我们想要快速网站，而快速网站提供更好的用户体验，这会让客户满意。他们的目标是提供最佳资源来回答用户的问题，这意味着你需要提供一个快速体验。
- en: One of the most troubling stats is the growing size of web pages. In 2015, the
    average web page passed the 2.5 MB mark, which is larger than the original installation
    disks for the game DOOM. Consequently, website performance has suffered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人不安的统计数据之一是网页大小的增长。到2015年，平均网页超过了2.5 MB的标记，这比游戏DOOM的原始安装盘还要大。因此，网站性能受到了影响。
- en: 'Google research found the following, disturbing stats about the average web
    page''s size:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的研究发现，关于平均网页大小的以下令人不安的统计数据：
- en: 79% > 1 MB
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 79% > 1 MB
- en: 53% > 2 MB
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 53% > 2 MB
- en: 23% > 4 MB
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 23% > 4 MB
- en: This is important because it takes about 5 seconds just to download a megabyte
    over a good 3G connection. That is not the end of the overhead, all the resources
    still need to be processed and the page has to be rendered.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为在良好的3G连接下，仅下载1兆字节就需要大约5秒。这还不是开销的终点，所有资源仍需要被处理，页面也需要被渲染。
- en: If you consider the numbers reported by Google, this means that 79% of web pages
    don't even start the rendering cycle until 5 seconds after the initial request
    is made! At that point, the probability the user has bounced is 90%.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑谷歌报告的数字，这意味着79%的网页甚至在初始请求后5秒才开始渲染周期！到那时，用户已经跳出的概率是90%。
- en: Reducing image payload size
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少图片负载大小
- en: Many point to images as being the root cause and to a certain degree they are,
    but images do not block rendering. Images can and should be optimized, which reduces
    the overall page size.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将图片视为根本原因，并在一定程度上是如此，但图片并不会阻止渲染。图片可以也应该被优化，这会减少整个页面的尺寸。
- en: Optimizing image file sizes can reduce the overall payload size by an average
    of 25%. If the page is 1 MB, 25% equals a 250 KB payload reduction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 优化图像文件大小可以将整体负载大小平均减少25%。如果页面是1 MB，那么25%等于250 KB的负载减少。
- en: 'Responsive images should also be used. This is where you use the `srcset` image
    and sizes attributes, or the picture element to reference images that are sized
    appropriately for the display:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应该也使用响应式图片。这是你使用`srcset`图片和尺寸属性，或者使用`picture`元素来引用适合显示的图片的地方：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Client device viewports vary widely. Instead of trying to be exact on every
    device, I recommend focusing on four viewport classes: phones, mini-tablets, tablets,
    and desktops. I will borrow the breakpoints from the Twitter bootstrap project
    that correspond to these viewports.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Any images above the different viewport width thresholds should be an array
    of images maintaining their aspect ratios at smaller widths.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The cost of CSS and JavaScript
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The real culprit behind delaying page load time is the overuse of CSS and JavaScript.
    Both are rendering blocking, which means that when they are being processed, nothing
    else happens.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Remember from the chapters on service workers, the browser uses a single thread
    to manage all the rendering tasks, including processing CSS and JavaScript. While
    this thread is doing that processing, no rendering can take place.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Developers are often naïve about the impact CSS and JavaScript has on their
    pages loading. Often, this comes down to forgetting what devices real users load
    web pages with, that is, mobile phones.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Developers generally work on high end workstations and laptops. They also load
    their work on those devices while developing. Therefore, they perceive their pages
    as loading instantly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The discrepancy is a combination of no network latency, high speed processors,
    and ample memory. This is not the case in the real world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Most consumers use cheaper phones, typically a $200 handset, not a $1,000 iPhone
    or a workstation. This means lower powered devices with constrained and limited
    network conditions do not load and render pages as fast as desktops.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: To compound these limitations, when mobile devices are using battery power,
    they often slow down processors and even turn off cores to reduce power consumption.
    This means the time to process JavaScript and CSS takes much longer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Numerous reports have demonstrated how much JavaScript affects how well a page
    loads. *Addy Osmani* published a canonical study ([https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e](https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e))
    showing how JavaScript gets in the way of a page loading.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: A common misconception is that the primary performance impact is loading a script
    or style sheet over the network. This has some affect, but the bigger impact is
    once the file is loaded. This is where the browser must load the script in memory,
    parse the script, evaluate, and then execute the script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '"Byte-for-byte, JavaScript is more expensive for the browser to process than
    the equivalently sized image or Web Font"'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: — Tom Dale
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use browser profiling tools, you can identify this phase of JavaScript
    by the presence of a yellow or a golden red color. The Chrome team calls *this
    a giant yellow slug*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: In recent years, **single-page applications** (**SPAs**) have become very popular.
    This has given rise to large frameworks that abstract the native APIs and provide
    an architecture developers and teams can follow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，**单页应用程序**（**SPAs**）变得非常流行。这导致了大型框架的出现，这些框架抽象了原生API，并为开发者和团队提供了一个可以遵循的架构。
- en: You should determine if a SPA is the right solution for your needs. The primary
    reason SPAs have enjoyed so much popularity is that they enable seamless page
    transitions, similar to a native app experience.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该确定SPA是否是满足您需求的正确解决方案。SPA如此受欢迎的主要原因是可以实现无缝的页面转换，类似于原生应用体验。
- en: If you have a service worker and utilize service worker caching, you can achieve
    the desired instant load and smooth page transitions SPAs offer. As a bonus, you
    won't need to load as much client-side JavaScript.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有服务工作者并利用服务工作者缓存，您可以实现SPA提供的所需即时加载和流畅的页面转换。作为额外的好处，您不需要加载那么多客户端JavaScript。
- en: You can also learn the native APIs instead of framework abstractions, such as
    jQuery. For example, `document.querySelector` and `document.querySelectorAll`
    return references to DOM elements much faster than jQuery.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以学习原生API而不是框架抽象，例如jQuery。例如，`document.querySelector` 和 `document.querySelectorAll`
    返回对DOM元素的引用，比jQuery快得多。
- en: 'Other native APIs I leverage, replacing most of what I used jQuery for, include:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我利用的其他原生API，包括替换了我大部分使用jQuery的部分：
- en: '`addEventListener`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addEventListener`'
- en: '`classList`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classList`'
- en: '`setAttribute` and `getAttribute`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setAttribute` 和 `getAttribute`'
- en: I have tried to give you simple architectures which you can follow with the
    Podstr and PWA tickets applications. The benefit of not being a SPAis that you
    can reduce the amount of JavaScript needed to run a page.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经尝试提供一些简单的架构，您可以根据Podstr和PWA票据应用程序来遵循。不是SPA的好处是您可以减少运行页面所需的JavaScript数量。
- en: The PWA ticket application relies on very little JavaScript. localForage and
    Mustache accounts are used for most of the JavaScript. The application and individual
    pages lean on next to no script. After applying gzip compression, the typical
    page needs less than 14 KB of JavaScript.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用程序几乎不依赖JavaScript。localForage和Mustache账户用于大部分JavaScript。应用程序和单个页面几乎不依赖脚本。在应用gzip压缩后，典型页面所需的JavaScript小于14
    KB。
- en: Proper test devices and emulation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确的测试设备和仿真
- en: 'I do recommend having realistic test devices. This does not mean buying an
    iPhone X, a Pixel 2, or Samsung 9\. You should have an average phone, which can
    mean different things for different areas. A baseline recommendation is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实建议拥有现实测试设备。这并不意味着购买iPhone X、Pixel 2或三星9。您应该有一部平均的手机，这在不同地区可能意味着不同的事情。一个基本建议是：
- en: 'North America and Europe: Motorola G4:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 北美和欧洲：摩托罗拉G4：
- en: '*Regular 3G* in Devtools Network Throttling'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常规3G* 在Devtools网络限速中'
- en: 'India and Indonesia: Xiaomi Redmi 3s'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 印度和印尼：小米Redmi 3s
- en: '*Good 2G* in Devtools Network Throttling'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*良好2G* 在Devtools网络限速中'
- en: The general rule is that with network constrained devices, those with slow and
    poor cellular connections, payload is important. Lower power, CPU, and memory
    constrained devices have more problems parsing and evaluating scripts and style
    sheets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对于网络受限的设备，那些拥有缓慢和差的蜂窝连接的设备，负载很重要。功耗、CPU和内存受限的设备在解析和评估脚本和样式表时会有更多问题。
- en: This is amplified when a lower powered device is using a constrained network.
    This is why you should architect your site as if all users have this bad combination.
    When you do, your site will always load quickly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当低功耗设备使用受限网络时，这种情况会加剧。这就是为什么您应该将网站架构得好像所有用户都有这种糟糕的组合一样。当您这样做时，您的网站将始终快速加载。
- en: Fortunately, we have numerous tools available to measure our pages' performance
    profiles and improve them. Different browser developer tools provide device emulation
    that provides a reasonable simulation of network and device constraints. WebPageTest
    is an example of a free online resource that can test real devices and conditions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有众多工具可用于测量我们页面性能配置文件并改进它们。不同的浏览器开发者工具提供了设备仿真，可以提供对网络和设备限制的合理模拟。WebPageTest是一个免费在线资源，可以测试真实设备和条件。
- en: Key areas to focus on are server-side factors and how your pages load in the
    browser. The most important goal is to make your pages render as fast as possible
    and respond quickly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的重点领域包括服务器端因素以及您的页面如何在浏览器中加载。最重要的目标是使您的页面尽可能快地渲染并快速响应。
- en: In this chapter, we will look at different key performance indicators and how
    you can apply techniques and patterns to ensure that you provide a great user
    experience. We will also look at how these techniques relate to progressive web
    applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的关键性能指标以及您如何应用技术和模式来确保您提供出色的用户体验。我们还将探讨这些技术与渐进式Web应用的关系。
- en: Testing poor conditions using developer tools
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发者工具测试较差的条件
- en: The good news about testing for poor connectivity and average user devices is
    that it can be emulated. The Chrome, Edge, and FireFox developer tools all include
    some capacity to simulate slower connections and even lower powered devices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试较差的连接和普通用户设备的喜讯是，这可以被模拟。Chrome、Edge和Firefox的开发者工具都包括一些模拟较慢连接甚至低功耗设备的容量。
- en: 'Chrome has the best developed conditional testing tools. In the Developer Tools,
    you need to toggle the device toolbar. The keyboard shortcut is *Ctrl* + *Shift*
    + *M* and the button is located in the top left corner. It looks like a phone
    overlaying a tablet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome拥有最完善的条件测试工具。在开发者工具中，您需要切换设备工具栏。快捷键是*Ctrl* + *Shift* + *M*，按钮位于左上角。它看起来像一部手机覆盖在平板上：
- en: '![](img/00104.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'This changes the browser tab to render the page in a frame. The frame simulates
    the viewport of a target device. It also renders the device toolbar above the
    content frame:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将浏览器标签页改为在框架中渲染页面。框架模拟目标设备的视口。它还在内容框架上方渲染设备工具栏：
- en: '![](img/00105.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: The device toolbar consists of different drop-downs, allowing you to configure
    what device and connection scenario you want to emulate. The left most drop-down
    is a list of pre-configured devices. It contains some of the more popular devices
    and can be customized.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设备工具栏由不同的下拉菜单组成，允许您配置想要模拟的设备和连接场景。最左侧的下拉菜单是预配置设备的列表。它包含了一些更受欢迎的设备，并且可以进行自定义。
- en: When you select a device, the width and height values are adjusted to match
    the device's viewport. I love this because it allows me to have a close proximity
    to the real device, without needing the real device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择一个设备时，宽度和高度值会调整以匹配设备的视口。我喜欢这一点，因为它让我可以接近真实设备，而无需使用真实设备。
- en: I do recommend having a few real handsets to test your sites, but that can get
    expensive real fast. Personally, I have a couple of Androids, one high end and
    one low end, and an iPhone. Right now, I have an iPhone 6\. I recommend buying
    either refurbished hardware or cheap, pre-paid phones, which are available at
    most retailers for about $50 US.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实建议您准备几部真机来测试您的网站，但这会很快变得昂贵。我个人有几部安卓手机，一部高端的，一部低端的，还有一部iPhone。目前，我有一部iPhone
    6。我建议购买翻新的硬件或便宜的预付费手机，这些手机在大多数零售商那里大约售价50美元。
- en: The Chrome device emulator does a fair enough approximation of real devices
    to allow me to complete my responsive design work. You should note that you are
    still using desktop Chrome, which is not exactly Android Chrome and certainly
    not iOS Safari.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome设备模拟器对真实设备的近似足够好，使我能够完成我的响应式设计工作。您应该注意，您仍在使用桌面Chrome，这并不完全是Android Chrome，当然也不是iOS
    Safari。
- en: The device emulator also has several popular Android tablets and iPads configured.
    Plus, you can also create your own viewports.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 设备模拟器还配置了几个流行的安卓平板和iPad。此外，您还可以创建自己的视口。
- en: 'You can also adjust the zoom. This can be helpful if the content is too small
    for you to fine tune:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调整缩放。如果内容对于您来说太小，难以微调，这可能会很有帮助：
- en: '![](img/00106.gif)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.gif)'
- en: The last option is bandwidth. This is the far right drop-down. It includes options
    to simulate offline, middle-tier, and lower-tier connections. They try not to
    label these speeds by common cellular connections because that opens them up to
    issues of not being an exact match.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是带宽。这是最右侧的下拉菜单。它包括模拟离线、中间层和低层连接的选项。他们尽量避免用常见的蜂窝连接来标记这些速度，因为这会使它们面临不精确匹配的问题。
- en: 3G, 4G, and LTE all vary by location, even in the same country. Labeling these
    speeds by cellular speed could be very misleading.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 3G、4G和LTE的速度因地区而异，即使在同一国家也是如此。用蜂窝速度来标记这些速度可能会非常误导。
- en: Since the vast majority of development occurs on high powered computers on a
    localhost site, developers often forget that their pages are loaded on cellular
    connections on phones. This leads us to assume that our pages are much faster
    than they actually are. Instead, you should always try to experience your site
    as close to real world scenarios as possible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绝大多数开发都是在功能强大的本地主机网站上进行的，开发者往往忘记他们的页面是在手机的蜂窝连接上加载的。这导致我们假设我们的页面比实际要快得多。相反，你应该始终尽可能真实地体验你的网站。
- en: A big reason I encourage developers to not use JavaScript frameworks is after
    experiencing a mobile first application on 3G days before launching. It took about
    30 seconds for each page to load. I found not only was the poor 3G connectivity
    to be a problem, but the amount of JavaScript to be the bottleneck.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励开发者不要使用 JavaScript 框架的一个主要原因是，在发布前几天体验了 3G 上的移动优先应用程序。每个页面加载大约需要 30 秒。我发现不仅
    3G 连接差是一个问题，而且 JavaScript 的数量是瓶颈。
- en: If I had not started using our application on my 3G handset, I would not have
    known how poor the user experience was. Back then, browser developer tools did
    not have these simulation features, which made the real device mandatory. So,
    be thankful that these tools exist, which can save you hours of time rearchitecting
    your sites.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有在我的 3G 手机上开始使用我们的应用程序，我就不会知道用户体验有多差。当时，浏览器开发者工具没有这些模拟功能，这使得真实设备变得必不可少。所以，感谢这些工具的存在，它们可以为你节省数小时的时间来重新设计你的网站。
- en: I utilize these emulation features to develop my sites, especially for responsive
    design work. The speed emulation helps me feel issues my customers may experience,
    which allows me to have more empathy for them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我利用这些模拟功能来开发我的网站，特别是对于响应式设计工作。速度模拟帮助我感受到客户可能遇到的问题，这使我能够对他们有更多的同理心。
- en: Performing performance and PWA testing with Lighthouse
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lighthouse 进行性能和 PWA 测试
- en: 'Chrome includes a powerful tool to test how well your site performs and meets
    progressive web application criteria. This tool is called **Lighthouse**. The
    tool is integrated into the developer tools Audit tab and is available as a node
    module and command-line utility:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 包含一个强大的工具来测试你的网站性能以及是否符合渐进式Web应用标准。这个工具被称为 **Lighthouse**。该工具集成到开发者工具的“审计”标签页中，并且可以作为节点模块和命令行实用程序使用：
- en: '![](img/00107.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00107.jpeg)'
- en: I will focus on using Lighthouse in the developer tool here and follow up with
    command line usage in the following chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里重点介绍如何在开发者工具中使用 Lighthouse，并在下一章中介绍命令行使用。
- en: To perform an audit, press the Perform an audit... button, as seen in the preceding
    screenshot. You will then see a dialog that gives you high level configuration
    options.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行审计，请按“执行审计...”按钮，如前一个屏幕截图所示。然后你会看到一个对话框，提供了高级配置选项。
- en: 'There are five areas Lighthouse audits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Lighthouse 审计有五个区域：
- en: Performance
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: PWAs
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWAs
- en: Best practices
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Accessibility
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无障碍性
- en: SEO
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEO
- en: 'You can run tests in all of these areas or only execute tests in selected areas.
    Lighthouse runs the audit and produces a scorecard and report:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在所有这些区域运行测试，或者只执行选定区域的测试。Lighthouse 会运行审计并生成一个评分卡和报告：
- en: '![](img/00108.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00108.jpeg)'
- en: The report highlights specific areas where you can improve the page. In the
    preceding screenshot, I ran just a performance audit and you can see some of the
    specific areas to improve, including the perceptual speed index. I also had the
    tool take screenshots as the page loaded, so you can see how the page renders
    over time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 报告突出了你可以改进页面的具体区域。在先前的屏幕截图中，我只运行了性能审计，你可以看到一些需要改进的具体区域，包括感知速度指数。我还让工具在页面加载时截图，这样你可以看到页面随时间如何渲染。
- en: The developer tools make it easy to run Lighthouse audits on a single page.
    You can run them from any Chrome instance, but I recommend opening an incognito
    instance. When you do this, you load the page in a clean browser, with no cache,
    cookies, or extensions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具使得在单个页面上运行 Lighthouse 审计变得容易。你可以从任何 Chrome 实例运行它们，但我建议打开一个隐身实例。当你这样做时，你会在一个干净的浏览器中加载页面，没有任何缓存、cookies
    或扩展程序。
- en: Because Chrome extensions run in the same process as the browser tab, they often
    interfere with pages and tools, such as Lighthouse. I found a page that normally
    loads fast and scores well suffers when extensions are included. They delay page
    loads and often execute well after the page completes loading.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Chrome 扩展程序与浏览器标签页在同一个进程中运行，它们经常会干扰页面和工具，例如 Lighthouse。我发现一个通常加载速度快且评分高的页面，在包含扩展程序时会受到影响。它们会延迟页面加载，并且通常在页面完成加载后才执行。
- en: It takes between 30-90 seconds to run a full audit. It depends on how many tests
    are being executed and the response time of your site.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一次全面审计需要30-90秒。这取决于正在执行多少测试以及你网站的响应时间。
- en: The battery of performance audits that are run are very thorough, covering not
    only a desktop and high speed connection, but use emulation to simulate low powered
    phones over 3G connections. It is these conditions that expose your weaknesses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的性能审计电池非常彻底，不仅涵盖了桌面和高速连接，还使用模拟在3G连接上模拟低功耗手机。正是这些条件暴露了你的弱点。
- en: You can use the report to pinpoint specific areas to correct, many of which
    are discussed in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用报告来定位需要纠正的具体区域，其中许多在本章中都有讨论。
- en: Each test has online documentation to explain what the test is and the actions
    you can take: [https://developers.google.com/web/tools/Lighthouse/audits/consistently-interactive](https://developers.google.com/web/tools/lighthouse/audits/consistently-interactive).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都有在线文档来解释测试的内容以及你可以采取的行动：[https://developers.google.com/web/tools/Lighthouse/audits/consistently-interactive](https://developers.google.com/web/tools/Lighthouse/audits/consistently-interactive)。
- en: Because the PWA ticket application is fairly optimized, there are not many areas
    to address. This test was run on the home page, after the user was authenticated.
    The one area that presents a delay is the perceptual speed index.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PWA票务应用程序相当优化，没有太多需要解决的问题。这个测试是在用户认证后的主页上运行的。唯一一个导致延迟的区域是感知速度指数。
- en: This measures how long the page content takes to load. In this example, we scored
    47, which is very low. This is because the UI thread is unresponsive while making
    the API call and rendering the markup for the upcoming events and the user's tickets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这衡量了页面内容加载所需的时间。在这个例子中，我们得到了47分，这非常低。这是因为UI线程在调用API和渲染即将发生的事件和用户的票证时无响应。
- en: We can improve this score by passing the API call and rendering to the service
    worker or even a web worker. This would take the work out of the UI thread and
    place it in a background thread. This will require a shift in page and site architecture.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将API调用和渲染传递给服务工作者或甚至网络工作者来提高这个分数。这将把工作从UI线程移到后台线程。这将需要对页面和网站架构进行调整。
- en: Another recommendation is to use next generation image formats such as WebP
    and JPEG 2000\. While these image formats are more efficient, they are not broadly
    supported. This is partially due to their young age and partially due to licensing
    concerns by different user agents. So, for now, I tend to ignore these recommendations
    and hold out hope that these formats will be commonly supported in the near future.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个建议是使用下一代图像格式，如WebP和JPEG 2000。虽然这些图像格式更高效，但它们并不被广泛支持。这部分是由于它们还很年轻，部分是由于不同用户代理的许可问题。因此，目前我倾向于忽略这些建议，并抱有希望这些格式将在不久的将来得到普遍支持。
- en: You could leverage a complex solution using the `PICTURE` element, but I find
    that it requires more management and responsibility than the payoff warrants.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用复杂的解决方案，例如使用`PICTURE`元素，但我发现这需要比回报所值得的更多管理和责任。
- en: It was announced at the recent Google I/O that Lighthouse version 3 will be
    available soon. They previewed an updated UI and a few new tests. You can read
    more about those announcements on the Google Developer's site: [https://developers.google.com/web/tools/Lighthouse/v3/scoring](https://developers.google.com/web/tools/lighthouse/v3/scoring).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的Google I/O上宣布，Lighthouse版本3将很快推出。他们预览了更新的UI和一些新的测试。你可以在Google开发者网站上了解更多关于这些公告的信息：[https://developers.google.com/web/tools/Lighthouse/v3/scoring](https://developers.google.com/web/tools/Lighthouse/v3/scoring)。
- en: As a word of caution, Lighthouse is an opinionated tool. This means that it
    looks for things Google and the Chrome team think are important. It is not a test
    running tool you can add custom tests or rules to based on your specific requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一句忠告，Lighthouse是一个有偏见的工具。这意味着它会寻找谷歌和Chrome团队认为重要的东西。它不是一个你可以根据特定要求添加自定义测试或规则的测试运行工具。
- en: At the 2017 Microsoft Edge Web Summit, they announced a similar tool called
    Sonar ([https://sonarwhal.com](https://sonarwhal.com)). It is also a node module
    and command-line tool that exercises tests against a supplied URL. The difference
    with Lighthouse is the ability to expand the test suite as you want. Not only
    can you add publicly available tests or rules, you can author your own.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年微软Edge Web峰会（Microsoft Edge Web Summit）上，他们宣布了一个名为Sonar（[https://sonarwhal.com](https://sonarwhal.com)）的类似工具。它也是一个节点模块和命令行工具，可以对提供的URL进行测试。与Lighthouse的不同之处在于可以按需扩展测试套件。你不仅可以添加公开可用的测试或规则，还可以编写自己的。
- en: Sonar can perform and does use the same test suites as Lighthouse, but allows
    you to add more. At the time of writing this book, it is not available in the
    Edge developer tools like Lighthouse. They do offer an online instance where you
    can test public URLs and of course run it locally as part of your test suite.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Sonar可以执行并确实使用了与Lighthouse相同的测试套件，但它允许你添加更多。在撰写本书时，它不像Lighthouse那样在Edge开发者工具中可用。他们确实提供了一个在线实例，你可以测试公共URL，当然也可以作为测试套件的一部分本地运行它：
- en: You should make Lighthouse and Sonar part of your routine developer work flow.
    You can quickly spot not only performance issues, but missing progressive web
    application requirements, best practices, basic SEO issues, and bad server configurations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将Lighthouse和Sonar纳入你的常规开发者工作流程。你可以快速发现不仅性能问题，还包括缺失的渐进式Web应用程序要求、最佳实践、基本SEO问题和糟糕的服务器配置。
- en: Using WebPageTest to benchmark performance
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebPageTest进行性能基准测试
- en: '**WebPageTest** ([https://webpagetest.org/](https://webpagetest.org/)) is a
    free tool you can use to give you web performance details. It works much like
    developer tools, but adds even more value:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebPageTest** ([https://webpagetest.org/](https://webpagetest.org/)) 是一个免费的工具，你可以用它来获取网页性能细节。它的工作方式与开发者工具类似，但增加了更多的价值：'
- en: '![](img/00109.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.jpeg)'
- en: 'Not only does it provide a detailed waterfall, it provides testing from different
    locations, varying speeds, and devices. Sometimes, the truths it reveals can be
    hard to swallow, but it provides you with targeted areas so that you can improve
    your performance:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它不仅提供了详细的水落石出，还提供了来自不同位置、不同速度和设备的测试。有时，它揭示的真相可能难以接受，但它为你提供了目标区域，以便你可以提高性能：
- en: '![](img/00110.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.jpeg)'
- en: 'To perform a test, visit [https://webpagetest.org](https://webpagetest.org).
    If your site has a public URL, enter it in the form and select a location, device/browser,
    and a speed to test. Once you submit the request, your site is evaluated using
    real hardware. After a minute or two, assuming it is not added to a queue to be
    processed, you receive a report:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，请访问 [https://webpagetest.org](https://webpagetest.org)。如果你的网站有一个公共URL，请在表单中输入它，并选择一个位置、设备/浏览器以及要测试的速度。一旦提交请求，你的网站将使用真实硬件进行评估。一两分钟后，假设它没有被添加到待处理队列中，你将收到一份报告：
- en: '![](img/00111.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: 'Just like the browser developer tools provide a network waterfall, WebPageTest
    can too, but with even more details:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像浏览器开发者工具提供了网络瀑布图一样，WebPageTest也可以，但提供了更多细节：
- en: '![](img/00112.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: 'A key metric I always check is the speed index. This is a performance indicator
    created by Patrick Meenan, the mind behind WebPageTest, that measures how visually
    complete a page is over its load time:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是检查的一个关键指标是速度指数。这是由WebPageTest背后的思想者帕特里克·米南（Patrick Meenan）创建的性能指标，它衡量页面在加载时间内的视觉完整性：
- en: '![](img/00113.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: It measures how much white space is visible compared to the final render. The
    goal is to minimize the time to a complete render. Speed Index is a way to measure
    the time to the first interaction or perceived rendering.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它衡量与最终渲染相比可见的空白区域有多少。目标是尽量减少到完整渲染的时间。速度指数是衡量到第一次交互或感知渲染的时间的一种方法。
- en: 'A good number to target is 1,000 or less. This indicates that it took 1 second
    or less to render the page. For reference, most pages I evaluate score well over
    10,000, indicating that it takes at least 10 seconds to render. These poor scores
    are over a broadband connection, so the value is much worse for cellular connections:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得追求的数字是1,000或更少。这表明渲染页面花费了1秒或更少的时间。为了参考，我评估的大多数页面得分都超过10,000，这意味着至少需要10秒来渲染。这些较差的分数是在宽带连接上，所以对于蜂窝连接来说，这个值要差得多：
- en: '![](img/00114.gif)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00114.gif)'
- en: There are many advanced features and settings that can be used to execute WebPageTest,
    including custom scripts. You can even stand up your own virtual machine either
    locally or in Amazon AWS. This is helpful when you have an enterprise application
    that's hidden behind a firewall.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多高级功能和设置来执行WebPageTest，包括自定义脚本。您甚至可以在本地或Amazon AWS上建立自己的虚拟机。当您有一个隐藏在防火墙后面的企业应用程序时，这非常有用。
- en: Key performance indicators
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键性能指标
- en: The first step to creating a fast site or improving an existing site is to use
    tools to measure your performance and knowing what to measure. You should create
    a performance baseline and make iterative changes to improve your performance
    profile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建快速网站或改进现有网站的第一步是使用工具来衡量您的性能，并了解您需要测量什么。您应该创建一个性能基线，并逐步改进以提升您的性能概况。
- en: In this section, I will review different metrics you should measure, why you
    need to track them, and how to improve them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将回顾您应该测量的不同指标，为什么需要跟踪它们，以及如何改进它们。
- en: Time to first byte
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次字节时间
- en: The time it takes to retrieve the first response byte is the time to first byte.
    This moment starts the response download. The most important network request is
    for the document. Once downloaded, the rest of the network resources (images,
    scripts, style sheets, and so on) can be downloaded.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第一个响应字节的所需时间是首次字节时间。这一刻标志着响应下载的开始。最重要的网络请求是文档请求。一旦下载完成，其余的网络资源（如图片、脚本、样式表等）就可以下载。
- en: 'You can break down the time to first byte process into different steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将首次字节时间过程分解为不同的步骤：
- en: Time to create a connection between the browser and server
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器和服务器之间建立连接所需的时间
- en: The time it takes to retrieve and possibly render the file on the server
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上检索和可能渲染文件所需的时间
- en: The time it takes to send the bytes to the browser
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节发送到浏览器所需的时间
- en: The easiest way to measure time to first byte is by opening the browser developer
    tools by pressing *F12* or *Ctrl* + *Shift* + *I*. Each browser's developer tools
    have a network tab. Here, you can see a page's waterfall. You may need to refresh
    the page to generate the report.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测量首次字节时间最简单的方法是通过按*F12*或*Ctrl* + *Shift* + *I*打开浏览器开发者工具。每个浏览器的开发者工具都有一个网络标签。在这里，您可以查看页面的水落图。您可能需要刷新页面以生成报告。
- en: I recommend performing both a primed and unprimed request. The difference is
    when loading the page as if this is the first time you have visited the site,
    which is called unprimed. In this state, there is nothing being persisted in the
    browser cache. You should also clear or bypass your service worker.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议执行带前置符号和无前置符号的请求。区别在于以这是您第一次访问网站的方式加载页面，这被称为无前置符号。在这种情况下，浏览器缓存中没有持久化任何内容。您还应该清除或绕过您的服务工作者。
- en: You can trigger an unprimed request by doing a hard reload, *Ctrl* + *F5*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过进行硬重载来触发无前置符号请求，即*Ctrl* + *F5*。
- en: If you look at the following waterfall example, you will notice that the first
    request, the one for the document or HTML, completes first. The browser then parses
    the markup, identifying additional assets to load. This is when those requests
    begin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看以下水落图示例，您会注意到第一个请求，即文档或HTML的请求，首先完成。然后浏览器解析标记，识别需要加载的附加资源。这就是那些请求开始的时候。
- en: 'You should be able to notice this pattern for all pages, even when assets are
    locally cached. This is why there is a slight time gap between the initial document
    request and the supporting resources:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在所有页面上注意到这种模式，即使资产是本地缓存的。这就是为什么初始文档请求和辅助资源之间存在轻微的时间间隔：
- en: '![](img/00115.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00115.jpeg)'
- en: A primed request assumes that you have visited the site or page before, and
    the browser and possibly the service worker cache contain valid responses. This
    means those requests are made locally, with no network activity. In theory, the
    page should load faster thanks to the cache.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 带有前置符号的请求假设您之前已经访问过该网站或页面，并且浏览器和可能的服务工作者缓存包含有效的响应。这意味着这些请求是在本地进行的，没有网络活动。理论上，由于缓存的存在，页面应该加载得更快。
- en: 'The waterfall is composed of each file request required to compose the page.
    You should be able to select an individual request (double click the request in
    the waterfall) to see how much time each step took:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 水落图由组成页面的每个文件请求组成。您应该能够选择单个请求（在水落图中双击请求）以查看每个步骤花费了多少时间：
- en: '![](img/00116.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00116.jpeg)'
- en: Chrome, FireFox, and Edge let you visualize the time to first byte. Each have
    a Timings panel that breaks apart the different parts of the request and the time
    allocated. It refines the parts a little more, showing you time to perform DNS
    resolution, creating the connection to the server, and the time it took the server
    to send the bytes to the browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome、Firefox和Edge允许你可视化首次字节时间。每个浏览器都有一个计时面板，它将请求的不同部分和时间分配分解开来。它进一步细化这些部分，显示执行DNS解析、建立与服务器连接以及服务器发送字节到浏览器所需的时间。
- en: Before a network request is made, it is added to a browser queue. This queue
    is a collection of requests the browser needs to make. Each browser determines
    how this queue is processed, which depends on available resources, HTTP/2 versus
    HTTP/1 support, and so on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在发起网络请求之前，它会被添加到浏览器队列中。这个队列是浏览器需要发起的请求集合。每个浏览器都决定如何处理这个队列，这取决于可用资源、HTTP/2与HTTP/1支持等因素。
- en: Next, if needed, the browser triggers a DNS resolution. If the device has a
    cache domain resolution or IP address, this step is skipped. You can speed this
    up by using the `dns-prefetch`, which I will cover a little later.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果需要，浏览器将触发DNS解析。如果设备有缓存域名解析或IP地址，则跳过此步骤。你可以通过使用`dns-prefetch`来加快这一步骤，我将在稍后进行介绍。
- en: The browser then makes the network request. At that point, it is up to the server
    to send a response. If the server has any bottlenecks, you should address those
    issues.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器随后发起网络请求。此时，服务器负责发送响应。如果服务器存在任何瓶颈，你应该解决这些问题。
- en: Don't forget TLS negotiation. There is a slight performance hit for HTTPS, but
    when using HTTP/2, this hit is typically washed out by additional performance
    enhancements offered by HTTP/2.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记TLS协商。HTTPS会有轻微的性能损失，但使用HTTP/2时，这种损失通常会被HTTP/2提供的额外性能提升所抵消。
- en: You can reduce your time to first byte by optimizing your server configuration.
    You should look for opportunities to reduce disk I/O by caching responses in memory.
    In ASP.NET, this is done by implementing the Output cache. Other web platforms
    provide similar capabilities.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过优化服务器配置来减少首次字节时间。你应该寻找机会通过在内存中缓存响应来减少磁盘I/O。在ASP.NET中，这是通过实现输出缓存来完成的。其他Web平台提供类似的功能。
- en: Database queries are another common bottleneck. If you can eliminate them, you
    should. Evaluate the page's data and find the data that could be retrieved ahead
    of time. I like to create JSON data files or objects in memory to avoid these
    expensive queries.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询是另一个常见的瓶颈。如果你可以消除它们，你应该。评估页面数据，找出可以提前检索的数据。我喜欢创建JSON数据文件或在内存中的对象来避免这些昂贵的查询。
- en: This is the main reason no-SQL, document databases such as MongoDB and ElasticSearch,
    and cloud services such as DynamoDB have grown in popularity. These databases
    as designed to have pre-selected and formatted data ready to go on demand. These
    solutions have helped popular online sites such as Twitter, Facebook, and so on
    grow and scale very quickly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是NoSQL、文档数据库如MongoDB和ElasticSearch，以及云服务如DynamoDB越来越受欢迎的主要原因。这些数据库设计为预先选择和格式化数据，以便按需使用。这些解决方案帮助Twitter、Facebook等热门在线网站快速成长和扩展。
- en: Another tactic is to avoid on-demand rendering as much as possible. Most websites
    are rendered by a server process such as ASP.NET, PHP, Ruby, Node, and so on.
    These all add overhead to the request process. By pre-rendering markup where possible,
    you reduce the opportunities for these processes to slow down the response.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是尽可能避免按需渲染。大多数网站都是由ASP.NET、PHP、Ruby、Node等服务器进程渲染的。这些都增加了请求过程的负担。通过尽可能预先渲染标记，你减少了这些进程减慢响应的机会。
- en: I try to use a static website solution when possible because they offer the
    fastest response pipeline. Static sites have the advantage over runtime rendering
    because the rendering cycle is removed. You can create your own engine to pre-render
    content or use a tool like Varnish to manage the task. You don't have to abandon
    your existing processor, but instead add a static engine on top to maintain the
    static files so that your pages load faster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量在可能的情况下使用静态网站解决方案，因为它们提供最快的响应管道。静态网站的优势在于运行时渲染，因为渲染周期被移除了。你可以创建自己的引擎来预渲染内容，或者使用Varnish等工具来管理任务。你不必放弃现有的处理器，而是添加一个静态引擎在顶部来维护静态文件，以便你的页面加载更快。
- en: The only remaining point of friction is the speed of the networks. Unfortunately,
    these are typically out of your control. Routers, proxies, and cell towers can
    all cause issues.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一摩擦点是网络的速率。不幸的是，这些通常超出了你的控制。路由器、代理和蜂窝塔都可能引起问题。
- en: At this point, the response bytes start streaming into the browser for processing.
    The larger the file, the longer, typically, the delay.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，响应字节开始流入浏览器进行处理。文件越大，通常延迟越长。
- en: The PRPL pattern
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PRPL模式
- en: We have looked at both the time to first byte and runtime performance issues.
    The best way to make sure that your site is performing its best is by implementing
    architecture best practices. The PRPL pattern was created to help modern web applications
    achieve top performance values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了首次字节时间和运行时性能问题。确保你的网站表现最佳的最佳方式是实施架构最佳实践。PRPL模式是为了帮助现代Web应用程序实现最佳性能值而创建的。
- en: 'The Google Polymer team developed PRPL as a guideline to follow to help websites
    perform better. It should be considered an architecture you can implement, but
    it is not all about technical specifics. To quote the PRPL documentation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Google Polymer团队开发了PRPL作为遵循的指南，以帮助网站性能更好。应将其视为可以实现的架构，但它不仅仅是关于技术细节。引用PRPL文档：
- en: '"PRPL is more about a mindset and a long-term vision for improving the performance
    of the mobile web than it is about specific technologies or techniques."'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: “PRPL更多地关乎一种心态和改善移动网络性能的长期愿景，而不是关于特定的技术或技术。”
- en: PRPL goes back to the principle of putting performance as a first-class feature
    of any website.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL回归到将性能作为任何网站的一等特性的原则。
- en: 'PRPL stands for:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL代表：
- en: '**P**ush critical resources for the initial URL route using `<link preload>`
    and HTTP/2'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送初始URL路由的关键资源**使用`<link preload>`和HTTP/2'
- en: '**R**ender initial route'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染初始路由**'
- en: '**P**re-cache remaining routes'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预缓存剩余路由**'
- en: '**L**azy-load and create remaining routes on demand'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需懒加载并创建剩余路由**'
- en: Even though PRPL was created with modern single page apps in mind, progressive
    web applications can benefit from following the PRPL pattern. Service workers
    are a valuable tool for implementing the PRPL pattern because you can leverage
    the Cache API to implement the pattern. You just have to adjust how the different
    principles are applied to improve your apps' performance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PRPL是为现代单页应用程序而设计的，但渐进式Web应用程序可以从遵循PRPL模式中受益。服务工作者是实现PRPL模式的有价值工具，因为你可以利用缓存API来实现该模式。你只需要调整如何应用不同的原则来提高你应用程序的性能。
- en: 'The primary goals of the PRPL pattern are:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL模式的主要目标是：
- en: 'Minimum time-to-interactive:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短的可交互时间：
- en: Especially on first use (regardless of entry point)
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其是在首次使用时（无论入口点）
- en: Especially on real-world mobile devices
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其是在现实世界的移动设备上
- en: Maximum caching efficiency, especially over time as updates are released
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的缓存效率，尤其是在更新发布后的时间上
- en: Simplicity of development and deployment
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和部署的简单性
- en: Implementing push with browser hints and the service worker cache
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用浏览器提示和服务工作者缓存实现推送
- en: The first concept of push relies on implementing the HTTP/2 server-side push.
    I have found this to be difficult to configure as most servers have not yet implemented
    HTTP/2 push.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 推送的第一个概念依赖于实现HTTP/2服务器端推送。我发现这很难配置，因为大多数服务器还没有实现HTTP/2推送。
- en: This is where service workers can offer a solution I feel is even better. We
    looked at how to implement pre-caching, an excellent alternative to using HTTP/2
    Push. By using pre-caching, you are effectively pushing those critical assets
    to the browser before they are needed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务工作者可以提供一种我认为更好的解决方案的地方。我们研究了如何实现预缓存，这是使用HTTP/2推送的绝佳替代方案。通过使用预缓存，你实际上是在需要之前将这些关键资产推送到浏览器。
- en: Remember that the resources you pre-cache should be critical and common application
    assets. These assets should mirror what you might want to configure HTTP/2 push
    to send.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你预缓存的资源应该是关键和常见的应用程序资产。这些资产应该反映你可能想要配置HTTP/2推送发送的内容。
- en: Combining service worker caching with the preload resource hint can recreate
    most of what HTTP/2 push does. Browsers use preload hint to initialize resource
    requests before they are encountered in the code. When paired with pre-cached
    assets, the loading process is lightning fast.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务工作者缓存与预加载资源提示结合可以重现HTTP/2推送的大部分功能。浏览器使用预加载提示在代码中遇到资源请求之前初始化资源请求。当与预缓存资源一起使用时，加载过程非常快。
- en: On the surface, resource hints like preload may not seem to provide much advantage.
    But as a page's composition grows complex, these hints can improve page load and
    rendering time significantly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The browser does not initiate a request until it is parsed from the HTML or
    initiated from a script or style sheet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom font files are a perfect example. Their downloads are not initiated
    until the browser parses the style sheet and finds the font reference. If the
    files are included as a preload resource hint, the browser has already loaded
    or at least started the request, making the file available sooner:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Specifying the resource content type allows the browser to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Prioritize resource loading
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match future requests and reusing the same resource
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the resource's content security policy
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the resource's correct Accept request headers
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also add the resource MIME type. When you do this, the browser can
    determine if it supports the resource type before it attempts to download the
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The idea is to make the page or application's assets available before the DOM
    parsing triggers a request. Since these assets are available in the service worker
    cache, they are already stored locally and can be loaded instantly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: You can notice the difference in the waterfall where `preload` hints are used.
    Do you remember that I pointed out a slight time gap between the initial markup
    being loaded and the assets in earlier waterfalls?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the following waterfall, you will notice that the dependencies
    are initiated before the markup has finished loading:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: This is due to the browser identifying these assets with the preload hint applied.
    It starts downloading the resource as soon as the item is parsed from the markup,
    not after the entire document is completely parsed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You should also note how fast these resources are loaded. This is due to them
    being cached using service worker caching. This eliminates the network bottleneck,
    which in some cases means that the files are loaded even before the markup is
    completely parsed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: It's a slight page load advantage, not a major improvement. Every little bit
    helps as milliseconds quickly add up.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Using the app shell model and service worker to render the initial route
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the PRPL pattern was designed from a SPA first perspective, the language
    speaks to that architecture. But as you have seen in the previous chapters, app
    shells are useful for progressive web apps.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Even when you don't have a page cached, you should have at least your application's
    markup shell cached locally. This can serve as your initial render, giving the
    user a sense of response. Meanwhile, you can retrieve any assets from the network
    to complete the page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The PWA tickets app uses the service worker to render pages using Mustache templates
    and JSON data retrieved from the API. This is an example of how you can return
    the app shell as a valid response to a request and then update the content once
    it is available.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: My rule is to give the user everything I have at the moment and fill in the
    blanks as I have more to give. This could be a combination of supplying the app
    shell and replacing it later or injecting the page-specific markup once it is
    available.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我的规则是提供我此刻拥有的所有内容，并在有更多内容提供时填补空白。这可能包括提供应用程序外壳并在之后替换它，或者一旦可用就注入页面特定的标记。
- en: Service worker pre-caching important routes
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务工作者预先缓存重要路由
- en: At this point in this book, it should be obvious how a good service worker pre-caching
    strategy applies to the PRPL pre-caching point, but it never hurts to review the
    concept.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这个阶段，应该很明显，一个好的服务工作者预先缓存策略如何适用于PRPL预先缓存点，但回顾这个概念永远不会有害。
- en: The second P in PRPL stands for pre-caching common routes. This includes the
    HTML and their supporting files such as styles, images, and scripts. This is exactly
    how your service worker's pre-cache strategy should be designed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: PRPL中的第二个P代表预先缓存常见路由。这包括HTML及其支持文件，如样式、图像和脚本。这正是您服务工作者预先缓存策略应该设计的方式。
- en: Important assets are commonly visited pages, but can also be the markup templates
    required to render the pages in the service worker. The common styles, scripts,
    images, and other support assets should be pre-cached.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要资源通常是常访问的页面，但也可以是服务工作者中渲染页面所需的标记模板。常见的样式、脚本、图像和其他支持资源应该预先缓存。
- en: Lazy-loading non-critical and dynamic routes
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载非关键和动态路由
- en: Not every page in every website can or should be cached ahead of time. As you
    saw in  [Chapter 5](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d), *The
    Service Worker Life Cycle*, you should also have cache invalidation logic in place
    to ensure that you supply the freshest content.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个网站上的每个页面都可以或应该预先缓存。正如您在[第5章](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d)“服务工作者生命周期”中看到的，您还应该有缓存失效逻辑，以确保您提供最新内容。
- en: Dynamic content, like the available ticket events or even an updated list of
    podcast episodes, is difficult to cache long-term. But you can provide a better
    experience than just waiting to download all of the page's resources.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内容，如可用的票务事件或甚至更新的播客剧集列表，长期缓存是困难的。但您可以为仅等待下载页面所有资源提供更好的体验。
- en: This is where employing one or more of the common caching strategies is helpful.
    You can also combine your rendering strategy with the app shell concept and build
    the page as assets are loaded or updated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是采用一个或多个常见缓存策略有帮助的地方。您还可以将您的渲染策略与应用程序外壳概念结合起来，在资源加载或更新时构建页面。
- en: You can also pre-cache and update common support assets as needed. This is one
    of the underestimated powers of the web, dynamically updating what is rendered
    and how it is rendered. You can update not just the markup in a page, but change
    style sheets and scripts on the fly too.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据需要预先缓存和更新常见的支持资源。这是网络低估的力量之一，动态更新渲染的内容及其渲染方式。您不仅可以更新页面中的标记，还可以动态更改样式表和脚本。
- en: As you have also learned, you can cache assets in the service worker without
    affecting the UI thread. This can be used to pre-cache non-critical assets and
    update previously cached content.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您也已经学到的，您可以在服务工作者中缓存资源而不会影响UI线程。这可以用来预先缓存非关键资源并更新之前缓存的资源。
- en: As you can see, service worker caching makes implementing the PRPL pattern very
    natural. Its ability to cache resources makes all four PRPL principles easy to
    implement. If you have followed the examples and guidelines in the previous chapters,
    then you have seen how to design PRPL compliant progressive web applications.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，服务工作者缓存使得实现PRPL模式非常自然。它缓存资源的能力使得所有四个PRPL原则都很容易实现。如果您已经遵循了前几章中的示例和指南，那么您已经看到了如何设计符合PRPL的渐进式网络应用程序。
- en: 'I think the number one PRPL principle is to cache as much of your application''s
    assets in the client as possible. This makes the network nice to have and not
    a potential source of delay and uncertainty. This is exactly what service worker
    caching was designed to do: make your assets close to the user''s glass.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为PRPL的首要原则是尽可能在客户端缓存您应用程序的资源。这使得网络变得可用，而不是潜在的延迟和不确定性的来源。这正是服务工作者缓存设计的目的：使您的资源接近用户的玻璃。
- en: The RAIL pattern
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAIL模式
- en: 'The RAIL pattern is an acronym used by the Google Chrome team to define one
    of the many WPO patterns you should try to follow. Its goal is to ensure your
    user experience is responsive:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: RAIL模式是Google Chrome团队用来定义您应该尝试遵循的许多WPO模式之一的缩写。其目标是确保您的用户体验是响应式的：
- en: '**Response**: How quickly there is a response when there is any input'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：任何输入时响应的速度'
- en: '**Animation**: Includes visual animation, scrolling, and dragging'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：包括视觉动画、滚动和拖动'
- en: '**Idle**: Background work'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲**：后台工作'
- en: '**Load**: How quickly a page can achieve the first meaningful paint'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载**：页面达到首次有意义的绘制所需的速度'
- en: Where the PRPL pattern is concerned with resource loading, RAIL is about the
    runtime user experience or what happens once the resources are loaded.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在PRPL模式关注资源加载时，RAIL关注的是运行时用户体验或资源加载后会发生什么。
- en: The pattern is designed to be user centric, focusing on performance first. The
    four aspects that make up the acronym are distinct areas of a web application
    and page's life cycle, or what happens once the bytes are loaded.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式旨在以用户为中心，首先关注性能。构成该缩写的四个方面是Web应用程序和页面生命周期的不同区域，或者一旦字节加载后会发生什么。
- en: 'Consider the different areas where performance is important: loading, rendering
    and responding to actions. There is more than just the page load phase. Page load
    is how fast the browser can load the assets, but many forget it still needs to
    process those assets and render the content. Then, once rendered, you can respond
    to user interactions.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到性能重要性的不同区域：加载、渲染和对动作的响应。不仅仅是页面加载阶段。页面加载是浏览器加载资源有多快，但许多人忘记了它仍然需要处理这些资源并渲染内容。然后，一旦渲染，你可以响应用户交互。
- en: You also need to consider how quickly the page response is to a click or tap.
    Is scrolling smooth? Are notifications prompt? What about any background activities,
    are they efficient?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要考虑页面响应点击或触摸的速度有多快。滚动是否平滑？通知是否及时？任何后台活动是否高效？
- en: The first critical factor to the average user is how long it takes for a page
    to become interactive, not how long it takes to download the files.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对普通用户来说，第一个关键因素是页面变得可交互所需的时间，而不是下载文件所需的时间。
- en: At the recent Google I/O, the team announced new metrics that Lighthouse will
    report, specifically **First Contentful Paint** (**FCP**). This is the point at
    which the browser renders the first pixel of a new page's DOM. The measurement
    starts from the time of navigation to the point that the first pixel is rendered.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的Google I/O大会上，团队宣布了Lighthouse将报告的新指标，特别是**首次内容绘制**（**FCP**）。这是浏览器渲染新页面DOM的第一个像素的点。测量从导航开始，到第一个像素渲染的点。
- en: The reason this is a key performance indicator is that this is the first visual
    queue to the user where their requested action or navigation is being handled.
    I like to translate that into saying that this is the point where the user knows
    the page is coming and was not lost in the ether, causing them to try and reload
    the page or give up.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以是关键性能指标，是因为这是用户第一次视觉提示，表明他们的请求操作或导航正在被处理。我喜欢将其翻译为说，这是用户知道页面正在到来，并没有迷失在虚空中，导致他们尝试重新加载页面或放弃。
- en: The FCP is available from the Paint Timing API ([https://w3c.github.io/paint-timing/](https://w3c.github.io/paint-timing/)),
    one of the modern performance APIs available in modern browsers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: FCP可以从Paint Timing API（[https://w3c.github.io/paint-timing/](https://w3c.github.io/paint-timing/））获得，这是现代浏览器中可用的现代性能API之一。
- en: The next KPI you should focus on is **Time to Interactive** (**TTI**). This
    is the point where the page is fully rendered and capable of responding to user
    input. Often, even though the page appears to be rendered, it cannot respond to
    the user due to background processing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注的下一个关键绩效指标是**交互时间**（**TTI**）。这是页面完全渲染并能够响应用户输入的点。通常，尽管页面看起来已经渲染，但由于后台处理，它无法响应用户。
- en: For example, the page is still processing JavaScript, which locks the UI thread
    and the page cannot be scrolled.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，页面仍在处理JavaScript，这会锁定UI线程，导致页面无法滚动。
- en: RAIL focuses on the user; the goal is not to necessarily make the site perform
    fast on a specific device, but to make your user happy. Any time a user interacts
    with your content, you should have a response within 100 ms. Any sort of animation
    or scrolling should also respond within 10 ms.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: RAIL关注用户；目标不是在特定设备上使网站性能尽可能快，而是让用户感到满意。任何用户与你的内容互动时，你应该在100毫秒内给出响应。任何类型的动画或滚动也应该在10毫秒内响应。
- en: Because modern web pages tend to do a lot of background processing, you should
    maximize idle time to perform these tasks, not blocking interaction and rendering.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代网页往往需要进行大量的后台处理，你应该最大化空闲时间来执行这些任务，而不是阻塞交互和渲染。
- en: If you need to perform any non-UI processing, such as data transformations,
    service workers or web workers provide a channel for you to offload those processes
    to background threads. This frees the UI thread to focus on UI tasks, like layout
    and painting. It also frees the UI to immediately respond to user interaction.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要执行任何非UI处理，例如数据转换、服务工作者或Web工作者提供了一条通道，让您可以将这些过程卸载到后台线程。这使UI线程能够专注于UI任务，如布局和绘制。这也使UI能够立即响应用户交互。
- en: Focus on delivering interactive content within one second. This can be very
    difficult to achieve over cellular networks and average mobile devices, but not
    impossible.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于在一秒内交付交互式内容。在蜂窝网络和平均移动设备上实现这一点可能非常困难，但并非不可能。
- en: As I mentioned before, server load time is not the majority of your web performance
    profile, it's the resource processing that creates the bigger bottlenecks. That's
    because scripts and style sheets block the critical rendering path, leaving your
    page partially rendered or appearing to be hung.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，服务器加载时间并不是您网络性能配置的主要部分，而是创建更大瓶颈的资源处理。这是因为脚本和样式表阻塞了关键渲染路径，导致您的页面部分渲染或看起来像是挂起了。
- en: 'If you have never heard of the critical rendering path, it is the workflow
    that browsers use to compose and render a page:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从未听说过关键渲染路径，它是浏览器用来构建和渲染页面的工作流程：
- en: '![](img/00118.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00118.jpeg)'
- en: 'These are the main steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要步骤：
- en: '**Document Object Model** (**DOM**)'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）'
- en: '**CSS object model **(**CSSOM**)'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CSS对象模型**（**CSSOM**）'
- en: Render Tree
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染树
- en: Layout
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局
- en: Paint
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制
- en: 'To compose the DOM, the browser must complete these substeps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建DOM，浏览器必须完成以下子步骤：
- en: Convert bytes to characters
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节转换为字符
- en: Identify tokens
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别标记
- en: Convert tokens to nodes
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标记转换为节点
- en: Build the DOM Tree
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建DOM树
- en: 'Similar to building the DOM, the browser follows a similar series of steps
    to compose the CSSOM or process styles:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建DOM类似，浏览器遵循一系列类似的步骤来构建CSSOM或处理样式：
- en: Convert bytes to characters
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字节转换为字符
- en: Identify tokens
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别标记
- en: Convert tokens to nodes
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标记转换为节点
- en: Build CSSOM
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 CSSOM
- en: 'The important takeaway for CSS is just like JavaScript: it is rendering blocking.
    The browser must process the page''s styles before it can be rendered. Multiple
    large CSS files cause the CSSOM process to repeat. The larger the style sheet,
    the longer this step takes.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CSS来说，重要的结论就像JavaScript一样：它是渲染阻塞的。浏览器必须在渲染之前处理页面的样式。多个大型CSS文件会导致CSSOM过程重复。样式表越大，这一步骤所需的时间就越长。
- en: Once the DOM and CSSOM are created, the browser then combines the two to compose
    the render tree. This is followed by the layout step, where all the size and color
    attributes are calculated for all the page elements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦DOM和CSSOM被创建，浏览器然后将这两个组合起来构建渲染树。接下来是布局步骤，为所有页面元素计算所有大小和颜色属性。
- en: Finally, the pixels are painted to the screen. This is not always 'instant',
    as different styles and style combinations take different amounts of processing
    to render.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像素被绘制到屏幕上。这并不总是“瞬间”的，因为不同的样式和样式组合需要不同数量的处理来渲染。
- en: How JavaScript clogs the pipeline
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何JavaScript阻塞管道
- en: The DOM and CSSOM processes work together to produce what is rendered on the
    screen, but there is a third part of the rendering cycle, that is, processing
    JavaScript. Not only is JavaScript a render blocker, it is also a parser blocking
    process.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: DOM和CSSOM过程协同工作，以产生屏幕上显示的内容，但渲染周期中还有第三部分，即处理JavaScript。JavaScript不仅是一个渲染阻塞器，还是一个解析阻塞过程。
- en: 'This is the primary reason we add script references at the end of the HTML.
    By doing so, the browser has a chance to parse the HTML and CSS before attempting
    to load scripts, which blocks the parsing process:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将脚本引用添加到HTML末尾的主要原因。通过这样做，浏览器有机会在尝试加载脚本之前解析HTML和CSS，这会阻塞解析过程：
- en: '![](img/00119.gif)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00119.gif)'
- en: When the browser encounters a script, it stops the DOM and CSS parsers to load,
    parse, and evaluate the JavaScript. This is one reason I make intentional efforts
    to minimize my JavaScript size.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器遇到脚本时，它会停止DOM和CSS解析器以加载、解析和评估JavaScript。这也是我努力最小化JavaScript大小的原因之一。
- en: There are some tricks you can employ to minimize this behavior. The first is
    to mark any script you can as async. This causes the browser to casually load
    the script file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采用一些技巧来最小化这种行为。第一个是将您能标记为异步的任何脚本。这会导致浏览器随意加载脚本文件。
- en: This sounds great at first, but most of the time, I have found this to be a
    more optimistic than practical. There always seems to be at least one critical
    script that requires execution as the page is being rendered.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这听起来很棒，但我发现这通常比实际更乐观。似乎总有一段关键脚本需要在页面渲染时执行。
- en: 'You can mark all your scripts as asynchronous and see if there are any issues
    when running your application. Just be thorough with your testing to flesh out
    any edge cases:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将所有脚本标记为异步，并在运行你的应用程序时查看是否有任何问题。只需彻底测试，以排除任何边缘情况：
- en: '[PRE3]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another solution is to minify your scripts and then inline them in your markup.
    This can also help your rendering cycle. One of the main benefits is not waiting
    on an additional file to download.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将你的脚本压缩后内联到你的标记中。这也可以帮助你的渲染周期。其中一个主要的好处是不需要等待额外的文件下载。
- en: However, if you are using HTTP/2, the multiplexing capabilities will probably
    offer more benefits. With HTTP/2, you are often better off using small files that
    can be individually cached than large file bundles.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用HTTP/2，多路复用功能可能会提供更多好处。使用HTTP/2时，通常使用可以单独缓存的较小文件比大型文件包更好。
- en: When you inline scripts, the size of your HTML grows, which can delay its processing.
    However, as you are about to learn, inlining CSS is highly beneficial. It is a
    matter of testing to see what works best for your page and application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你内联脚本时，你的HTML大小会增加，这可能会延迟其处理。然而，正如你即将学习的，内联CSS非常有用。这是一个测试的问题，看看什么最适合你的页面和应用。
- en: Why 14 KB is the magic number
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么14 KB是神奇数字
- en: In an effort to control network traffic, TCP implements a pattern called slow
    start. It does this to keep the network from being overwhelmed with requests.
    The details are specified in RFC 5681 ([https://tools.ietf.org/html/rfc5681](https://tools.ietf.org/html/rfc5681)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制网络流量，TCP实现了一种称为慢启动的模式。它这样做是为了防止网络被请求淹没。详细信息在RFC 5681中指定（[https://tools.ietf.org/html/rfc5681](https://tools.ietf.org/html/rfc5681)）。
- en: The protocol works where the sender or initiator sends an initial, small packet.
    When it receives a response, it then doubles the packet size. This volley is repeated
    until the sender receives a congested response.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的工作原理是发送方或发起者发送一个初始的小数据包。当它收到响应后，它会将数据包大小加倍。这种往返会重复进行，直到发送方收到拥塞响应。
- en: 'The initial packet size is 14 KB. This back and forth is a series of round
    trips. If you can fit an entire page or response within 14 KB, it only needs one
    round trip to be completely downloaded:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据包大小为14 KB。这种往返是一系列往返。如果你可以将整个页面或响应放入14 KB中，那么只需要一个往返就可以完全下载：
- en: '![](img/00120.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00120.jpeg)'
- en: In this example, the response is 10.5 KB, so only 1 round trip is required.
    You should note that this example is not compressed, which would reduce the size
    significantly. This is another point I want you to remember as we apply resource
    inlining a little later.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，响应大小为10.5 KB，因此只需要1次往返。你应该注意，这个例子没有压缩，这会显著减小大小。这是我们稍后应用资源内联时想要你记住的另一点。
- en: The initial TCP data packet is actually 16 KB, but the first 2 KB are reserved
    for request header data. The remaining 14 KB are where your content or data are
    transferred. If the content is more than 14 KB, then a second round trip is initiated,
    and this time the packet size is doubled to 32 KB. This repeats until there is
    a network congestion message.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 初始TCP数据包实际上是16 KB，但前2 KB被保留用于请求头数据。剩余的14 KB是内容或数据传输的地方。如果内容超过14 KB，则启动第二次往返，这次数据包大小加倍至32
    KB。这会一直重复，直到出现网络拥塞消息。
- en: By limiting the request to a single round trip, you are able to load the entire
    response almost instantly. The more round trips, the longer the data takes to
    load.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将请求限制为单个往返，你可以几乎瞬间加载整个响应。往返次数越多，数据加载所需的时间越长。
- en: Inline critical CSS
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联关键CSS
- en: When you inline CSS, you eliminate the required round trips to retrieve the
    styles, and they are immediately available to the browser as it parses the DOM.
    This makes these two critical steps much faster.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你内联CSS时，你消除了检索样式的所需往返，并且它们在解析DOM时立即对浏览器可用。这使得这两个关键步骤变得更快。
- en: To refresh, when the browser encounters external style sheets, it blocks any
    rendering until the style sheets are fully loaded.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了刷新，当浏览器遇到外部样式表时，它会阻止任何渲染，直到样式表完全加载。
- en: As I mentioned earlier, you want to limit the size of a page's CSS to just the
    CSS required to render the page. By limiting the styles to just those used by
    the page, you can typically reduce the amount of CSS to a handful of kilobytes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，你希望将页面 CSS 的大小限制仅为渲染页面所需的 CSS。通过仅将样式限制在页面使用的那些，你通常可以将 CSS 的数量减少到几个千字节。
- en: Because the amount of real CSS is minimal, you can inline those styles in the
    document's `head` element. Now, the browser has no external file to download and
    a minimal amount of CSS to load. Plus, you have the critical styles required to
    render the app shell.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际 CSS 的数量很少，你可以在文档的 `head` 元素中内联这些样式。现在，浏览器没有外部文件需要下载，只需加载最小量的 CSS。此外，你还有渲染应用外壳所需的临界样式。
- en: 'The PWA ticket app has a very standard app shell: `header`, `body`, and `footer`.
    Each individual page requires a minimal amount of custom CSS to render its content.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 票务应用程序有一个非常标准的应用外壳：`header`、`body` 和 `footer`。每个单独的页面都需要最小量的自定义 CSS 来渲染其内容。
- en: The good news is that there are tools available to help you identify the CSS
    each page requires. There are multiple node modules available, but I have focused
    on the UnCSS module ([https://www.npmjs.com/package/uncss](https://www.npmjs.com/package/uncss)).
    It was one of the first modules created to identify the required CSS.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，有工具可以帮助你识别每个页面所需的 CSS。有多个节点模块可用，但我专注于 UnCSS 模块 ([https://www.npmjs.com/package/uncss](https://www.npmjs.com/package/uncss))。它是第一个创建来识别所需
    CSS 的模块之一。
- en: Because these are node modules, you can include them in a build script. The
    PWA ticket application has a build script in the project's `utils` folder called
    `render-public.js`. I won't go into all of the script's details, but it runs over
    the site's source to produce the site's pages and support files.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是节点模块，你可以将它们包含在构建脚本中。PWA 票务应用程序在项目的 `utils` 文件夹中有一个名为 `render-public.js`
    的构建脚本。我不会详细介绍脚本的所有细节，但它会在网站的源代码上运行，以生成网站的页面和支持文件。
- en: The `extractCSS` function handles extracting a page's styles, minimizing them,
    and injecting them into the `head` element.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractCSS` 函数负责提取页面的样式，最小化它们，并将它们注入到 `head` 元素中。'
- en: There are additional node modules being used to help. Cheerio loads HTML and
    creates an object with the jQuery API, just like you were using jQuery in the
    browser. This makes manipulating the markup much easier.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有额外的节点模块被用来帮助。Cheerio 加载 HTML 并创建一个具有 jQuery API 的对象，就像你在浏览器中使用 jQuery 一样。这使得操作标记更容易。
- en: 'The second module is CleanCSS. This module minifies styles, removing unnecessary
    white space, thus making the code take up less space:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块是 CleanCSS。此模块最小化样式，删除不必要的空白，从而使得代码占用更少的空间：
- en: '[PRE4]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: UnCSS has a long list of configuration options you can use to control how the
    module executes. I have supplied the most common settings I use, like media query
    breakpoints and eliminating banner comments.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: UnCSS 有一个很长的配置选项列表，你可以使用这些选项来控制模块的执行方式。我提供了我最常用的设置，例如媒体查询断点和消除横幅注释。
- en: 'Sometimes, I find that I still need to include a list of selectors that should
    not be removed:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我发现我仍然需要包含一个不应删除的选择器列表：
- en: '[PRE5]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I have also found that removing any script references from the markup will help
    the module. When the module finds a script, it does try to load it and execute
    it. This is because UnCSS exercises the page in a headless browser, which loads
    the page just as if it were a normal browser.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我还发现，从标记中删除任何脚本引用将有助于该模块。当模块找到脚本时，它会尝试加载并执行它。这是因为 UnCSS 在无头浏览器中执行页面，就像它是一个正常浏览器一样。
- en: UnCSS can either process raw HTML, which is how I use it, or load a page via
    a URL or local path. It utilizes the standard node callback pattern, so you should
    write your code accordingly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: UnCSS 可以处理原始 HTML，这就是我使用它的方式，或者通过 URL 或本地路径加载页面。它使用标准的节点回调模式，因此你应该相应地编写代码。
- en: Another thing I try to do is inject potential content templates in the HTML
    to be processed. This should help UnCSS isolate all the styles needed, even when
    they are dynamically rendered.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我尝试做的事情是在要处理的 HTML 中注入潜在的内容模板。这应该有助于 UnCSS 确定所需的全部样式，即使它们是动态渲染的。
- en: Like UnCSS, CleanCSS also uses the callback pattern. You can supply the filtered
    CSS and it will return a minified version.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UnCSS 一样，CleanCSS 也使用回调模式。你可以提供过滤后的 CSS，它将返回一个最小化版本。
- en: 'At this point, you can inject the minified styles into the HTML `head`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以将最小化的样式注入到 HTML 的 `head`：
- en: '[PRE6]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, you have the page's HTML with all its required CSS, inline in
    the markup HEAD. For the PWA ticket application, the typical page is around 30
    KB, which does not meet the 14 KB goal.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，页面的 HTML 已经包含所有必需的 CSS，内联在标记的 HEAD 中。对于 PWA 技术票据应用程序，典型的页面大小约为 30 KB，这不符合
    14 KB 的目标。
- en: Fortunately, we are not done.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们还没有完成。
- en: Static resources, like HTML, should be compressed. You can use gzip or deflate
    compression. Brotli is another option, but is not universally supported by all
    browsers. Once you compress these files, they typically reduce to around 8 KB,
    well within our 14 KB goal!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 静态资源，如 HTML，应该被压缩。你可以使用 gzip 或 deflate 压缩。Brotli 是另一个选项，但并非所有浏览器都支持它。一旦压缩这些文件，它们通常可以减少到大约
    8 KB，远远在我们的 14 KB 目标之内！
- en: 'Most web servers can be configured to compress text files on demand. But as
    you can imagine, I like to do this as part of my deploy process. This can be done
    with a node, but you should check with your devops team to make sure that this
    is being done for your site:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Web 服务器都可以配置为按需压缩文本文件。但正如你可以想象的那样，我喜欢将其作为我的部署过程的一部分。这可以通过节点完成，但你应该与你的 DevOps
    团队确认，确保这是为你的网站执行的：
- en: '[PRE7]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure any compressed files are served with the Content-Encoding header set
    to gzip or deflate so that the browser knows to decompress the response.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 确保任何压缩文件都通过设置 Content-Encoding 标头为 gzip 或 deflate 来提供，这样浏览器就知道要解压缩响应。
- en: Minifying scripts with uglify
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 uglify 压缩脚本
- en: Just like CSS, you should also minimize JavaScript files. Just like we used
    Clean-CSS to minify CSS, you can use uglify to do the same for your JavaScript.
    Instead of inlining the script, I like to keep it in individual files.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 CSS 一样，你也应该最小化 JavaScript 文件。就像我们使用 Clean-CSS 来压缩 CSS 一样，你可以使用 uglify 来对你的
    JavaScript 执行相同的操作。我更喜欢将其保留在单独的文件中。
- en: In the past, I would have also bundled multiple script files together. HTTP/2
    utilizes request multiplexing to optimize content delivery. By keeping each script
    in individual files, you can take advantage of long term caching and make small
    changes without requiring a complete download.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我还会将多个脚本文件捆绑在一起。HTTP/2 利用请求多路复用来优化内容交付。通过保持每个脚本为单独的文件，你可以利用长期缓存，并在不需要完整下载的情况下进行小幅度修改。
- en: In addition to minimizing the scripts, I am also going to show you how to create
    unique file names using an MD5 hash on the content. This will allow you to apply
    a very long caching time without worrying about browser caches retaining stale
    copies. This technique is advanced and does require some planning and, of course,
    an intelligent build or rendering process.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最小化脚本外，我还会向你展示如何使用内容上的 MD5 哈希创建唯一的文件名。这将允许你应用非常长的缓存时间，而不用担心浏览器缓存保留过时的副本。这项技术是高级的，确实需要一些规划，当然，还需要一个智能的构建或渲染过程。
- en: There are multiple uglifier node modules. I chose `uglify-js` for the PWA ticket
    application. The way I tend to pick modules like this is to look at popularity,
    but also what popular task runners such as Grunt, Gulp, and WebPack plugins rely
    upon.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个 uglifier 节点模块。我选择了 `uglify-js` 用于 PWA 技术票据应用程序。我挑选这类模块的方式是查看其流行度，同时也会考虑流行的任务运行器，如
    Grunt、Gulp 和 WebPack 插件所依赖的。
- en: As a word of warning, `uglify-js` does not handle ES6 syntax, like `let` and
    `const`, and will throw errors when encountered. But I warn against using ES6
    syntax in the browser since there are still many browsers that do not support
    it, such as Internet Explorer.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一句警告，`uglify-js` 不处理 ES6 语法，如 `let` 和 `const`，在遇到时会抛出错误。但我警告不要在浏览器中使用 ES6
    语法，因为仍然有许多浏览器不支持它，例如 Internet Explorer。
- en: 'For the build script, I chose to create a simple uglify module to reference
    in the overall build script. It references `uglify-js` and creates an `uglify`
    class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建脚本，我选择创建一个简单的 uglify 模块，以便在整体构建脚本中引用。它引用 `uglify-js` 并创建一个 `uglify` 类：
- en: '[PRE8]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The class `constructor` and `transformSrc` methods are used to set up before
    minification. They are set up to allow you to pass either a single script reference
    or an array of scripts to uglify and concatenate.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `constructor` 和 `transformSrc` 方法用于在压缩前设置。它们被设置为允许你传递单个脚本引用或脚本数组以供 uglify
    和连接。
- en: 'Just like UnCSS, uglify allows you to customize the process. This is where
    the options allow you to configure the module. For this, I chose some simple settings
    I like to use to optimize the process:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 UnCSS 一样，uglifier 允许你自定义过程。这就是选项允许你配置模块的地方。为此，我选择了我喜欢的一些简单设置来优化过程：
- en: '[PRE9]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The render script not only uglifies each script; it also creates a unique hash
    name:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染脚本不仅会压缩每个脚本；它还会创建一个唯一的哈希名称：
- en: '[PRE10]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The file is calculated by passing the script's contents to the nodejs crypto
    object. The crypto object makes calculating hashes simple. In this case, I want
    an md5 hash value, so when the `createHash` method is called, you supply the `'md5'`
    value.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件是通过将脚本内容传递给nodejs crypto对象来计算的。crypto对象使得计算哈希变得简单。在这种情况下，我想要一个md5哈希值，所以当调用`createHash`方法时，你提供`'md5'`值。
- en: 'If you are not familiar with md5 hashes, they are a cryptographic way of generating
    a checksum to verify data integrity. They are not good for cryptography, but provide
    a unique value based on the data. That unique value is helpful for creating a
    unique file name:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉md5哈希，它们是一种生成校验和的加密方法，用于验证数据完整性。它们不适合加密，但基于数据提供唯一值。这个唯一值对于创建唯一的文件名很有帮助：
- en: '[PRE11]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The uniqueness is good enough to have faith that the script file name won't
    be duplicated within your application. The build script needs to not only generate
    unique hash values, but save the file with the hash name. It could also just rename
    the source file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一性足够好，可以相信脚本文件名不会在应用程序内部重复。构建脚本不仅需要生成唯一的哈希值，还需要将文件以哈希名称保存。它也可以只是重命名源文件。
- en: 'Even after you create the file with the unique file name, you still need to
    integrate it into the HTML files. The render script takes care of that task. The
    product looks something like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你创建了具有唯一文件名的文件，你仍然需要将其集成到HTML文件中。渲染脚本负责这项任务。产品看起来可能像这样：
- en: '[PRE12]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I also added `.min` to each one of the files because the scripts have been minimized.
    This is done out of convention rather than a requirement. The benefit is for tools,
    like browser developer tools, that understand that the script is minimized. Edge
    allows you to choose to bypass the script when you are debugging because `.min`
    is appended to the file name.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向每个文件添加了`.min`，因为脚本已经被压缩。这是出于惯例而不是要求。好处是对于像浏览器开发者工具这样的工具，它们理解脚本已经被压缩。Edge允许你在调试时选择绕过脚本，因为`.min`被附加到文件名上。
- en: 'Because each page also sets a preloaded hint for the script files, those references
    must also be updated:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个页面也会为脚本文件设置一个预加载提示，所以这些引用也必须更新：
- en: '[PRE13]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, why did I add this complicated renaming step to the build and render processes?
    To enable long cache time frames. This tells the browser to attempt to cache the
    response locally in the built-in browser cache, not the service worker cache.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我要在构建和渲染过程中添加这个复杂的重命名步骤呢？是为了启用较长的缓存时间。这告诉浏览器尝试在内置的浏览器缓存中而不是在服务工作者缓存中本地缓存响应。
- en: The recommended time to live is at least a year. Most scripts can and will be
    updated in that time frame and the hash name technique gives you a guaranteed
    cache busting technique. Other techniques, like appending a unique `QueryString`
    parameter, may not always work.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的存活时间至少为一年。大多数脚本可以在那个时间范围内更新，并且哈希名称技术为你提供了一个保证的缓存失效技术。其他技术，如附加唯一的`QueryString`参数，可能并不总是有效。
- en: 'You can set the long time to live by setting the `cache-control` header. This
    needs to be done in your web server, so that it will be part of your devops workflow:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置`cache-control`头来设置长时间存活。这需要在你的web服务器上完成，这样它就会成为你的devops工作流程的一部分：
- en: '[PRE14]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I won't dive into the art of configuring Cache-Control headers, but you can
    use the preceding example as a reference. Files such as scripts, style sheets,
    and even images are candidates for the hash naming trick. Just be sure to update
    any references to the files to the new name.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨配置Cache-Control头部的艺术，但你可以将前面的示例作为参考。脚本、样式表甚至图像等文件都适合使用哈希命名技巧。只需确保更新任何对文件的引用到新名称即可。
- en: Using feature detection to conditionally load JavaScript polyfils
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用功能检测条件性地加载JavaScript polyfills
- en: 'The PWA ticket application uses many modern APIs, but some are not supported
    by older browsers. There are two browser scenarios you should be most concerned
    with: Internet Explorer and older Android phones. UC Browser is another popular
    browser that does not support all newer features yet.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用程序使用了许多现代API，但其中一些在旧浏览器中不受支持。你应该最关注两种浏览器场景：Internet Explorer和较老的Android手机。UC浏览器是另一个流行的浏览器，它还没有支持所有新功能。
- en: Internet Explorer is the now deprecated Microsoft Browser. The only supported
    version is IE 11, and right now only lives on Windows 7 and in enterprises. Enterprises
    use many line of business applications, and many were created against old and
    obsolete web standards. Often, it is expensive for them to update or replace these
    applications.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer是现在已弃用的微软浏览器。唯一支持的是IE 11，目前仅存在于Windows 7和企业中。企业使用许多业务线应用程序，许多都是针对旧的和过时的网络标准创建的。通常，对于他们来说更新或替换这些应用程序是昂贵的。
- en: Internet Explorer provides a legacy browser channel for them to continue running
    these applications. However, when they upgrade to Windows 10, they should configure
    these line of business applications to trigger Internet Explorer from Edge as
    needed and not as a default browser.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer为它们提供了一个遗留浏览器通道，以便它们可以继续运行这些应用程序。然而，当它们升级到Windows 10时，它们应该配置这些业务线应用程序，以便在需要时从Edge触发Internet
    Explorer，而不是作为默认浏览器。
- en: This means that the default behavior you should expect is Edge, not Internet
    Explorer on Windows 10\. However, human nature and habits often override recommended
    practice, which means IE is still a very popular browser.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你应该期望的默认行为是Edge，而不是Windows 10上的Internet Explorer。然而，人的本性和习惯往往超过推荐的做法，这意味着IE仍然是一个非常流行的浏览器。
- en: Fortunately, most of the modern APIs PWA tickets use can be polyfiled. This
    is where a script can be loaded, on demand, to implement the new API. Other APIs
    can be safely used behind a feature detection gate, like we do before registering
    a service worker, or be trusted to be gracefully ignored. The latter is how modern
    CSS properties are handled.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大多数现代API PWA票据都可以使用polyfills。这就是脚本可以按需加载以实现新API的地方。其他API可以在功能检测门后面安全使用，就像我们在注册服务工作者之前所做的那样，或者可以信任它们被优雅地忽略。后者是现代CSS属性的处理方式。
- en: Loading a feature polyfil can be done as needed using feature detection and
    a simple technique I call toggling a script.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用功能检测和一种我称之为切换脚本的简单技术按需加载功能polyfills。
- en: 'The PWA tickets application uses 4 polyfils:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用程序使用了4个polyfills：
- en: '`Object.Assign`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.Assign`'
- en: Promises
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises
- en: The Fetch API
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fetch API
- en: '`IntersectionObserver`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntersectionObserver`'
- en: The trick relies on these script references applying a type attribute other
    than script. This tells the browser that even though it is a script element, the
    src is not a script. Of course, the src files are scripts, but by setting the
    type to something else, the browser does not download the scripts.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧依赖于这些脚本引用应用了一个除了script之外的其他类型属性。这告诉浏览器，尽管它是一个脚本元素，但src不是脚本。当然，src文件是脚本，但通过将类型设置为其他内容，浏览器不会下载脚本。
- en: 'The `toggleScript` method takes a supplied ID to reference the polyfil''s `script`
    element. It then toggle''s the script''s type from `script-polyfil` to text/JavaScript.
    When this toggle happens, the browser downloads and processes the polyfil script:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleScript`方法接受一个ID来引用polyfills的`script`元素。然后它将脚本的类型从`script-polyfil`切换到text/JavaScript。当这个切换发生时，浏览器会下载并处理polyfills脚本：'
- en: '[PRE15]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All this depends on the polyfil being needed. Each API or feature support can
    be detected with a simple test. If the test fails, the feature is not supported,
    and the toggleScript method is called to load the polyfil.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都取决于是否需要polyfills。每个API或功能支持都可以通过简单的测试来检测。如果测试失败，则该功能不受支持，并调用toggleScript方法来加载polyfills。
- en: You should put this code before you load any of the application-specific code
    or any code that might depend on these APIs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在加载任何应用程序特定的代码或可能依赖于这些API的任何代码之前放置此代码。
- en: Dynamically loading polyfils is important because it means you will use the
    native APIs when present and avoid loading these expensive files when the native
    API is present.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 动态加载polyfills非常重要，因为这意味着当原生API可用时，你会使用它，并且当原生API存在时避免加载这些昂贵的文件。
- en: Any time you need to load these polyfils, the page load suffers. however, I
    think that this is a reasonable trade off because these older browsers will run
    slower in the first place and the user may not have the same expectations as someone
    using a modern browser.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要加载这些polyfills的时候，页面加载都会受到影响。然而，我认为这是一个合理的权衡，因为这些旧浏览器一开始运行就会慢，用户可能不会有像使用现代浏览器的人那样的期望。
- en: Lazy loading images
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载图片
- en: Images can delay your overall page load experience due to image numbers and
    their size. There are different strategies for optimizing image delivery. The
    first one you should consider is lazy loading images below the fold.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图片数量和大小，图片可能会延迟你的整体页面加载体验。有不同策略用于优化图片传输。你应该考虑的第一个策略是在页面可滚动部分以下懒加载图片。
- en: This could be a very tricky technique to execute. Modern APIs can help you,
    the `IntersectionObserver` ([https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API))
    API in particular gives you the ability to detect when elements are entering the
    viewport. You can designate the distance and time estimated threshold for an element
    to appear.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个非常棘手的技巧来执行。现代API可以帮助您，特别是`IntersectionObserver` ([https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API))
    API，它让您能够检测元素何时进入视口。您可以指定元素出现时估计的距离和时间阈值。
- en: 'The `IntersectionObserver` API will trigger an event to let you know when an
    element is about to be displayed. At this point, you can initiate an image download
    if necessary. This means that your pages images will not be loaded in the initial
    render process, but be loaded as needed. This can conserve valuable bandwidth
    and network connections in that initial page load:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntersectionObserver` API将触发一个事件，让您知道当元素即将被显示时。在这个时候，如果需要，您可以启动图像下载。这意味着您的页面图像不会在初始渲染过程中加载，而是按需加载。这可以在初始页面加载过程中节省宝贵的带宽和网络连接：'
- en: '[PRE16]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of using the images `src` attribute, you can designate the image source
    as a data attribute (`data-src`). You should also do the same thing for the `srcset`
    attribute:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 代替使用图像的`src`属性，您可以将图像源指定为数据属性（`data-src`）。您也应该对`srcset`属性做同样的事情：
- en: '[PRE17]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `showImage` function handles toggling the `data-src` and `data-srcset`
    values to the corresponding `src` and `srcset` values. This causes the browser
    to load the images just before they come into view, or on demand:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`showImage`函数处理切换`data-src`和`data-srcset`值到相应的`src`和`srcset`值。这会导致浏览器在图像即将进入视图之前或按需加载图像：'
- en: '[PRE18]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you''re worried about legacy browsers supporting `IntersectionObserver`,
    don''t worry: there is a polyfil ([https://github.com/w3c/IntersectionObserver/tree/master/polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill)).
    Right now, Chrome, Firefox, and Edge have native `IntersectionObserver` support.
    The polyfil allows you to use this technique in other browsers.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您担心旧版浏览器支持`IntersectionObserver`，请不要担心：有一个polyfil ([https://github.com/w3c/IntersectionObserver/tree/master/polyfill](https://github.com/w3c/IntersectionObserver/tree/master/polyfill))。目前，Chrome、Firefox和Edge都原生支持`IntersectionObserver`。这个polyfil允许您在其他浏览器中使用这项技术。
- en: You should use feature detection to determine if you need to load the polyfil
    and the polyfil technique that was described previously.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用功能检测来确定是否需要加载polyfil以及之前描述的polyfil技术。
- en: The PWA ticket application uses the `IntersectionObserver` pattern to lazy-load
    images. I also want to point out a key aspect of this technique, which is specifying
    the images' render size as a placeholder.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: PWA票据应用使用`IntersectionObserver`模式来懒加载图像。我还想指出这项技术的关键方面，即指定图像的渲染大小作为占位符。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has focused on improving your progressive web app's performance.
    You have learned about key performance indicators you can measure as well as tools
    to measure your application.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了提高您的渐进式Web应用性能。您已经了解了您可以衡量的关键性能指标以及测量您应用程序的工具。
- en: Once you have identified items to improve, you can attack them to improve your
    page load time and response times.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经确定了需要改进的项目，您就可以着手改进它们，以缩短页面加载时间和响应时间。
- en: You have also been given some techniques and been exposed to code to help you
    build your pages to provide a better user experience. You have seen how to minimize
    the amount of code each page needs, improve caching, and reduce the initial page
    payload.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经获得了一些技巧，并接触到了代码，以帮助您构建页面，提供更好的用户体验。您已经看到了如何最小化每个页面所需的代码量，提高缓存，并减少初始页面负载。
- en: In the next chapter, you will see how to automate your progressive web application
    workflow to ensure that you have a consistently performing and qualifying PWA.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到如何自动化您的渐进式Web应用工作流程，以确保您有一个持续表现良好且合格的PWA。
