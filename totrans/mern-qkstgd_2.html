<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a Web server with ExpressJS</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Routing in ExpressJS</li>
<li>Modular route handlers</li>
<li>Writing middleware functions</li>
<li>Writing configurable middleware functions</li>
<li>Writing router-level middleware functions</li>
<li>Writing error-handler middleware functions</li>
<li>Using ExpressJS' built-in middleware function to serve static assets</li>
<li>Parsing the HTTP request body</li>
<li>Compressing HTTP responses</li>
<li>Using an HTTP request logger</li>
<li>Managing and creating virtual domains</li>
<li>Securing an ExpressJS web application with helmet</li>
<li>Using template engines</li>
<li>Debugging your ExpressJS web application</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB. You will also need to install Git, in order use the Git repository of this book. </span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter02">https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter02</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/xXhqWK">https://goo.gl/xXhqWK</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>ExpressJS is the preferred de facto Node.js web application framework for building robust web applications and APIs.</p>
<p>In this chapter, the recipes will focus on building a fully functional web server and understanding the core fundamentals.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Routing in ExpressJS</h1>
                </header>
            
            <article>
                
<p>Routing refers to how an application responds or acts when a resource is requested via an HTTP verb or HTTP method.</p>
<p><strong>HTTP</strong> stands for <strong>Hypertext Transfer Protocol</strong> and it's the basis of data communication for the <strong>World Wide Web</strong> (<strong>WWW</strong>). All documents and data in the WWW are identified by a <strong>Uniform Resource Locator</strong> (<strong>URL</strong>).</p>
<p>HTTP verbs or HTTP methods are a <em>client-server</em> model. Typically, a web browser serves as a <em>client</em>, and in our case ExpressJS is the framework that allows us to create a <em>server</em> capable of understanding these requests. Every request expects a response to be sent to the client to recognize the status of the resource that it is requesting.</p>
<p>Request methods can be:</p>
<ul>
<li><strong>Safe</strong>: An HTTP verb that performs read-only operations on the server. In other words, it does not alter the server state. For example: <kbd>GET</kbd>.</li>
<li><strong>Idempotent</strong>: An HTTP verb that has the same effect on the server when identical requests are made. For instance, sending a <kbd>PUT</kbd> request to modify a user's first name should have the same effect on the server if implemented correctly when multiple identical requests are sent. All <em>safe</em> methods are also idempotent. For example, the <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> methods are idempotent.</li>
<li><strong>Cacheable</strong>: An HTTP response that can be cached. Not all methods or HTTP verbs can be cached. A response is cacheable only if the <em>status code</em> of the response and the method used to make the request are both cacheable. For example, the GET method is cacheable and the following status codes: <kbd>200</kbd> (Request succeeded), <kbd>204</kbd> (No content), <kbd>206</kbd> (Partial content), <kbd>301</kbd> (Moved permanently), <kbd>404</kbd> (Not found), <kbd>405</kbd> (Method not allowed), <kbd>410</kbd> (Gone or Content permanently removed from server), and <kbd>414</kbd> (URI too long).</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Understanding routing is one of the most important core aspects in building robust RESTful APIs.</p>
<p>In this recipe, we will see how ExpressJS handles or interprets HTTP requests. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre>    <strong>npm install</strong>
  </pre>
<p>ExpressJS does the whole job of understanding a client's request. The request may come from a browser, for instance. Once the request has been interpreted, ExpressJS saves all the information in two objects:</p>
<ul>
<li><strong>Request</strong>: This contains all the data and information about the client's request. For instance, ExpressJS parses the URI and makes its parameters available on request.query.</li>
<li><strong>Response</strong>: This contains data and information that will be sent to the client. The response's headers can be modified as well before sending the information to the client. The <kbd>response</kbd> object has several methods available for sending the status code and data to the client. For instance: <kbd>response.status(200).send('Some Data!')</kbd>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><kbd>Request</kbd> and <kbd>Response</kbd> objects are passed as arguments to the <em>route handlers</em> defined inside a <kbd>route</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Route methods</h1>
                </header>
            
            <article>
                
<p>These are derived from HTTP verbs or HTTP methods. A route method is used to define the response that an application will have for a specific HTTP verb.</p>
<p>ExpressJS route methods have equivalent names to HTTP verbs. For instance: <kbd>app.get()</kbd> for the <kbd>GET</kbd> HTTP verb or <kbd>app.delete()</kbd> for the <kbd>DELETE</kbd> HTTP verb.</p>
<p>A very basic route can be written as the following:</p>
<ol>
<li>Create a new file named <kbd>1-basic-route.js</kbd></li>
<li>Include the ExpressJS library first and initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Add a new route method to handle requests for the path <kbd>"/"</kbd>. The first argument specifies the path or URL, the next argument is the route handler. Inside the route handler, let's use the <kbd>response</kbd> object to send a status code <kbd>200 (OK)</kbd> and text to the client:</li>
</ol>
<pre>      app.get('/', (request, response, nextHandler) =&gt; { 
          response.status(200).send('Hello from ExpressJS') 
      }) </pre>
<ol start="4">
<li>Finally, use the <kbd>listen</kbd> method to accept new connections on port <kbd>1337</kbd>:</li>
</ol>
<pre>      app.listen( 
         1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="5">
<li>Save the file</li>
<li>Open a Terminal and run the following command:</li>
</ol>
<pre><strong>     node 1-basic-route.js</strong> </pre>
<ol start="7">
<li>Open a new tab on your browser and visit <kbd>localhost</kbd> on port <kbd>1337</kbd> in your web browser to see the results:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/</span></pre>
<div class="packt_infobox">For more information about which HTTP methods are supported by ExpressJS, visit the official ExpressJS website at <a href="https://expressjs.com/en/guide/routing.html#route-methods"><span class="URLPACKT">https://expressjs.com/en/guide/routing.html#route-methods</span></a>.<a href="https://expressjs.com/en/guide/routing.html#route-methods"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Route handlers</h1>
                </header>
            
            <article>
                
<p>Route handlers are callback functions that accept three arguments. The first one is the <kbd>request</kbd> object, the second one is the <kbd>response</kbd> object, and the last one is a <kbd>callback,</kbd> which passes the handler to the next request handler in the chain. Multiple <kbd>callback</kbd> functions can be used inside a route method as well.</p>
<p>Let's see a working example of how we could write route handlers inside route methods:</p>
<ol>
<li>Create a new file named <kbd>2-route-handlers.js</kbd></li>
<li>Include the ExpressJS library, then initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Add two route methods to handle a request in the same path <kbd>"/one"</kbd>. Use the <kbd>type</kbd> method of the <kbd>response</kbd> object to set the content type of the response sent to the client to <kbd>text/plain</kbd>. Using the <kbd>write</kbd> method send partial data to the client. To finalize sending data, use the <kbd>end</kbd> method of the response object. Calling <kbd>nextHandler</kbd> will pass the handler to the second handler in the chain:</li>
</ol>
<pre>      app.get('/one', (request, response, nextHandler) =&gt; { 
          response.type('text/plain') 
          response.write('Hello ') 
          nextHandler() 
      }) 
      app.get('/one', (request, response, nextHandler) =&gt; { 
         response.status(200).end('World!') 
      }) </pre>
<ol start="4">
<li>Add a <kbd>route</kbd> method to handle a request in the path <kbd>"/two"</kbd>. Two route handlers are defined inside the <kbd>route</kbd> method to handle the same request:</li>
</ol>
<pre>      app.get('/two', 
          (request, response, nextHandler) =&gt; { 
             response.type('text/plain') 
             response.write('Hello ') 
             nextHandler() 
         }, 
          (request, response, nextHandler) =&gt; { 
             response.status(200).end('Moon!') 
         } 
      ) </pre>
<ol start="5">
<li>Use the <kbd>listen</kbd> method to accept new connections on port <kbd>1337</kbd>:</li>
</ol>
<pre>      app.listen( 
         1337, 
         () =&gt; console.log('Web Server running on port 1337'), 
     ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre>    <strong>node 2-route-handlers.js</strong>  </pre>
<ol start="8">
<li>To see the result, open a new tab in your web browser and visit:</li>
</ol>
<pre><strong><span class="URLPACKT">      http://localhost:1337/one</span>
</strong><strong><span class="URLPACKT">      http://localhost:1337/two</span></strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Chainable route methods</h1>
                </header>
            
            <article>
                
<p>Route methods can be chainable using <kbd>app.route(path)</kbd> because the <kbd>path</kbd> is specified for a single location. This is probably the best approach when dealing with multiple route methods because, besides making the code more readable and less prone to typos and redundancy, it allows to work with multiple route methods at the same time.</p>
<ol>
<li>Create a new file named <kbd>3-chainable-routes.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Chain three route methods using the <kbd>route</kbd> method:</li>
</ol>
<pre>      app 
      .route('/home') 
      .get((request, response, nextHandler) =&gt; { 
          response.type('text/html') 
          response.write('&lt;!DOCTYPE html&gt;') 
          nextHandler() 
      }) 
      .get((request, response, nextHandler) =&gt; { 
          response.end(` 
          &lt;html lang="en"&gt; 
              &lt;head&gt; 
              &lt;meta charset="utf-8"&gt; 
              &lt;title&gt;WebApp powered by ExpressJS&lt;/title&gt; 
              &lt;/head&gt; 
              &lt;body role="application"&gt; 
                  &lt;form method="post" action="/home"&gt; 
                      &lt;input type="text" /&gt; 
                      &lt;button type="submit"&gt;Send&lt;/button&gt; 
                  &lt;/form&gt; 
              &lt;/body&gt; 
          &lt;/html&gt; 
          `) 
      }) 
      .post((request, response, nextHandler) =&gt; { 
          response.send('Got it!') 
      }) </pre>
<ol start="4">
<li>Use the <kbd>listen</kbd> method to accept new connections on port <kbd>1337</kbd>:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="5">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node 3-chainable-routes.js</strong></pre>
<ol start="7">
<li>To see the result, open a new tab in your web browser and visit:</li>
</ol>
<pre>      <span class="URLPACKT">http://localhost:1337/home</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Route paths can be strings or regular expressions. Route paths are internally turned into regular expressions using the <kbd>path-to-regexp</kbd> NPM package <a href="https://www.npmjs.com/package/path-to-regexp"><span class="URLPACKT">https://www.npmjs.com/package/path-to-regexp</span></a><span class="URLPACKT">.</span><a href="https://www.npmjs.com/package/path-to-regexp"/></p>
<p><kbd>path-to-regexp</kbd>, in a way, helps you write path regular expressions in a more human-readable way. For example, consider the following code:</p>
<pre>app.get(/([a-z]+)-([0-9]+)$/, (request, response, nextHandler) =&gt; { 
    response.send(request.params) 
}) 
// Output: {"0":"abc","1":"12345"} for path /abc-12345 </pre>
<p>This could be written as follows:</p>
<pre>app.get('/:0-:1', (request, response, nextHandler) =&gt; { 
    response.send(request.params) 
}) 
// Outputs: {"0":"abc","1":"12345"} for /abc-12345 </pre>
<p>Or better:</p>
<pre>app.get('/:id-:tag', (request, response, nextHandler) =&gt; { 
    response.send(request.params) 
}) 
// Outputs: {"id":"abc","tag":"12345"} for /abc-12345 </pre>
<p>Take a look at this expression: <kbd>/([a-z]+)-([0-9]+)$/</kbd>. The parentheses in the regular expression are called <strong>capturing parentheses</strong>; and when they find a match, they remember it. In the preceding example, for <kbd>abc-12345</kbd>, two strings are remembered, <kbd>{"0":"abc","1":"12345"}</kbd>. This is the way that ExpressJS finds a match, remembers its value, and associates it to a key:</p>
<pre>app.get('/:userId/:action-:where', (request, response, nextHandler) =&gt; { 
    response.send(request.params) 
}) 
// Route path: /123/edit-profile 
// Outputs: {"userId":"123","action":"edit","where":"profile"} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modular route handlers</h1>
                </header>
            
            <article>
                
<p>ExpressJS has a built-in class called <strong>router</strong>. A router is just a class that allows developers to write mountable and modular route handlers.</p>
<p>A <strong>Router</strong> is an instance of ExpressJS' core routing system. That means, all routing methods from an ExpressJS application are available:</p>
<pre>const router = express.Router() 
router.get('/', (request, response, next) =&gt; { 
  response.send('Hello there!') 
}) 
router.post('/', (request, response, next) =&gt; { 
  response.send('I got your data!') 
}) </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to use a router to make a modular application. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>    <strong>npm install</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Suppose that you want to write a modular mini-application within your ExpressJS main application that can be mounted to any URI. You want to be able to choose the path where to mount it, or you just want to mount the same route methods and handlers to several others paths or a URI.</p>
<ol>
<li>Create a new file named <kbd>modular-router.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Define a router for your mini-application and add a request method to handle requests for path <kbd>"/home"</kbd>:</li>
</ol>
<pre>      const miniapp = express.Router() 
      miniapp.get('/home', (request, response, next) =&gt; { 
          const url = request.originalUrl 
          response 
              .status(200) 
              .send(`You are visiting /home from ${url}`) 
      }) </pre>
<ol start="4">
<li>Mount your modular mini-application to <kbd>"/first"</kbd> path, and to <kbd>"/second"</kbd> path:</li>
</ol>
<pre>      app.use('/first', miniapp) 
      app.use('/second', miniapp) </pre>
<ol start="5">
<li>Listen for new connections on port <kbd>1337</kbd>:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a Terminal and run the following command:</li>
</ol>
<pre><strong>      node modular-router.js</strong></pre>
<ol start="8">
<li>To see the results, navigate in your web browser to:</li>
</ol>
<pre style="color: black"><span class="URLPACKT">      http://localhost:1337/first/home<br/></span><span class="URLPACKT">      http://localhost:1337/second/home</span></pre>
<p>You will see two different outputs:</p>
<pre>You are visting /home from /first/home 
You are visting /home from /second/home </pre>
<p>As can be seen, a <em>router</em> was mounted to two different mount points. Routers are usually referred to as mini-applications because they can be mounted to an ExpressJS application's specific routes and not only once but also several times to different mount points, paths, or URIs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing middleware functions</h1>
                </header>
            
            <article>
                
<p>Middleware functions are mainly used to make changes in the <kbd>request</kbd> and <kbd>response</kbd> object. They are executed in sequence, one after another, but if a middleware functions does not pass control to the next one, the request is left hanging.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Middleware functions have the following signature:</p>
<pre>app.use((request, response, next) =&gt; { 
    next() 
}) </pre>
<p>The signature is very similar to writing route handlers. In fact, a middleware function can be written for a specific HTTP method and a specific path route, and will look like this, for example:</p>
<pre>app.get('/', (request, response, next) =&gt; { 
    next() 
}) </pre>
<p>So, if you are wondering what the difference is between route handlers, and middleware functions, the answer is simple: their purpose.</p>
<p>If you are writing route handlers, and the <kbd>request</kbd> objects and/or the <kbd>response</kbd> object is modified, then you are writing middleware functions.</p>
<p>In this recipe, you will see how to use a middleware function to restrict access to certain paths or routes that depend on a certain condition. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>    <strong>npm install</strong> </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will write a middleware function that allows access to the root path <kbd>"/"</kbd> only when the query parameter <kbd>allowme</kbd> is present:</p>
<ol>
<li>Create a new file named <kbd>middleware-functions.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Write a middleware function that will add a property <kbd>allowed</kbd> to the <kbd>request</kbd> object:</li>
</ol>
<pre>      app.use((request, response, next) =&gt; { 
          request.allowed = Reflect.has(request.query, 'allowme') 
          next() 
      }) </pre>
<ol start="4">
<li>Add a request method to handle requests for path <kbd>"/"</kbd>:</li>
</ol>
<pre>      app.get('/', (request, response, next) =&gt; { 
          if (request.allowed) { 
              response.send('Hello secret world!') 
          } else { 
              response.send('You are not allowed to enter') 
          } 
      }) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node middleware-functions.js</strong>
  </pre>
<ol start="8">
<li>To see the results, in your web browser, navigate to:</li>
</ol>
<pre><strong><span class="URLPACKT">      </span></strong>http://localhost:1337/<br/>      http://localhost:1337/?allowme</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Just like with route handlers, middleware functions need to pass control to the next handler; otherwise, our application will have been hanging because no data was sent to the client, and the connection was not closed either.</p>
<p>If new properties are added to the <kbd>request</kbd> or <kbd>response</kbd> objects inside a middleware function, the next handler will have access to those new properties. As in our previously written code, the <kbd>allowed property</kbd> in the <kbd>request</kbd> object is available to the next handler.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing configurable middleware functions</h1>
                </header>
            
            <article>
                
<p>A common pattern for writing middleware functions is to wrap the middleware function inside another function. The result of doing so is a configurable middleware function. They are also <em>higher-order functions</em>, that is, a function that returns another function.</p>
<pre>const fn = (options) =&gt; (response, request, next) =&gt; {  
    next()  
} </pre>
<p>Usually an object is used as an <kbd>options</kbd> parameters. However, there is nothing stopping you from doing it in your own way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will write a configurable logger middleware function. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>    <strong>npm install</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>What your configurable middleware function will do is simple: it will print the status code and the URL when a request is made.</p>
<ol>
<li>Create a new file named <kbd>middleware-logger.js</kbd></li>
</ol>
<ol start="2">
<li>Export a function that accepts an object as the first argument. The function expects the object to have a property <kbd>enable</kbd>, which can be either <kbd>true</kbd> or <kbd>false</kbd>:</li>
</ol>
<pre>      const logger = (options) =&gt; (request, response, next) =&gt; { 
          if (typeof options === 'object' 
              &amp;&amp; options !== null 
              &amp;&amp; options.enable) { 
              console.log( 
                  'Status Code:', response.statusCode, 
                  'URL:', request.originalUrl, 
              ) 
          } 
          next() 
      } 
      module.exports = logger </pre>
<ol start="3">
<li>Save the file</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>Our configurable middleware function is not useful on its own. Create a simple ExpressJS application to see our middleware actually working:</p>
<ol>
<li>Create a new file named <kbd>configurable-middleware-test.js</kbd></li>
<li>Include our <kbd>middleware-logger.js</kbd> module and initialize a new ExpressJS application:</li>
</ol>
<pre>       const express = require('express') 
       const loggerMiddleware = require('./middleware-logger') 
       const app = express() </pre>
<ol start="3">
<li>Use the <kbd>use</kbd> method to include our configurable middleware function. When the <kbd>enable</kbd> property is set to <kbd>true</kbd>, your logger will work and log every request's status code and URL to the terminal:</li>
</ol>
<pre>      app.use(loggerMiddleware({ 
         enable: true, 
      })) </pre>
<ol start="4">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
           1337, 
           () =&gt; console.log('Web Server running on port 1337'), 
         ) </pre>
<ol start="5">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node middleware-logger-test.js</strong></pre>
<ol start="7">
<li>In your browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/hello?world</span><strong><br/></strong></pre>
<ol start="8">
<li>The Terminal should display:</li>
</ol>
<pre><strong>      Status Code: 200 URL: /hello?world</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you want to experiment, start your configurable middleware test application with the <kbd>enable</kbd> property set to <kbd>false</kbd>. No logs should be displayed.</p>
<p>Usually, you would want to disable logging in production, since this operation could hit performance.</p>
<p>An alternative to disabling all logging is to use other libraries to do this task instead of using <kbd>console</kbd>. There are libraries that allow you to set different levels of logging as well, for instance:</p>
<ul>
<li><strong>Debug module</strong>: <a href="https://www.npmjs.com/package/debug"><span class="URLPACKT">https://www.npmjs.com/package/debug</span></a></li>
<li><strong>Winston</strong>: <a href="https://www.npmjs.com/package/winston"><span class="URLPACKT">https://www.npmjs.com/package/winston</span></a></li>
</ul>
<p>Logging is useful for several reasons. The main reasons are:</p>
<ul>
<li>It checks whether your services are running properly, for example, checking whether your application is connected to MongoDB.</li>
<li>It discovers errors and bugs.</li>
<li>It helps you to understand better how your application is working. For instance, if you have a modular application, you can see how it integrates when included in other applications.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing router-level middleware functions</h1>
                </header>
            
            <article>
                
<p>Router-level middleware functions are only executed inside a router. They are usually used when applying a middleware to a mount point only or to a specific path.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will create a small logger router-level middleware function that will only log requests to paths mounted or located in the router's mounted path. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new file named <kbd>router-level.js</kbd></li>
<li>Initialize a new ExpressJS application and define a router:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() 
      const router = express.Router() </pre>
<ol start="3">
<li>Define our logger middleware function:</li>
</ol>
<pre>      router.use((request, response, next) =&gt; { 
          console.log('URL:', request.originalUrl) 
          next() 
      }) </pre>
<ol start="4">
<li>Mount the Router to the path <kbd>"/router"</kbd></li>
</ol>
<pre>      app.use('/router', router) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>     app.listen( 
         1337, 
       () =&gt; console.log('Web Server running on port 1337'), 
    ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node router-level.js</strong></pre>
<ol start="8">
<li>In your web browser navigate to:</li>
</ol>
<pre><strong><span class="URLPACKT">      http://localhost:1337/router/example</span><br/></strong></pre>
<ol start="9">
<li>The Terminal should display:</li>
</ol>
<pre><strong>      URL: /router/example</strong></pre>
<ol start="10">
<li>After, in your web browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/example</span><strong><br/></strong></pre>
<ol start="11">
<li>No logs should be displayed in terminal</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is possible to pass control back to the next middleware function or route method outside of a router by calling <kbd>next('router')</kbd>.</p>
<pre>router.use((request, response, next) =&gt; { 
  next('route') 
}) </pre>
<p>For example, by creating a router that expects to receive a user ID as a query parameter. The <kbd>next('router')</kbd> function can be used to get out of the router or pass control to the next middleware function outside of the router when a user ID is not provided. The next middleware function out of the router can be used to display other information when the router passes control to it. For example:</p>
<ol>
<li>Create a new file named <kbd>router-level-control.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Define a new router:</li>
</ol>
<pre>      const router = express.Router() </pre>
<ol start="4">
<li>Define our logger middleware function inside the router:</li>
</ol>
<pre>      router.use((request, response, next) =&gt; { 
         if (!request.query.id) { 
             next('router') // Next, out of Router 
          } else { 
            next() // Next, in Router 
          } 
      }) </pre>
<ol start="5">
<li>Add a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> which will be executed only if the middleware function passes control to it:</li>
</ol>
<pre>       router.get('/', (request, response, next) =&gt; { 
         const id = request.query.id 
         response.send(`You specified a user ID =&gt; ${id}`) 
      }) </pre>
<ol start="6">
<li>Add a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> outside of the router. However, include the router as a route handler as the second argument, and another route handler to handle the same request only if the router passes control to it:</li>
</ol>
<pre>      app.get('/', router, (request, response, next) =&gt; { 
          response 
            .status(400) 
            .send('A user ID needs to be specified') 
    }) </pre>
<ol start="7">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="8">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node router-level-control.js</strong></pre>
<ol start="10">
<li>To see the result, in your browser, navigate to:</li>
</ol>
<pre><strong><span class="URLPACKT">     </span></strong> http://localhost:1337/
      http://localhost:1337/?id=7331<strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When navigating to the first URL (<kbd><span class="URLPACKT">http://localhost:1337/</span></kbd>), the following message is shown:</p>
<pre> A user ID needs to be specified </pre>
<p>This is because the middleware function in the router checks if the <kbd>id</kbd> was provided in the query, and because it is not, it passes control to the next handler outside of the router with <kbd>next('router')</kbd>.</p>
<p>On the other hand, when navigating to the second URL (<a href="http://localhost:1337/?id=7331"><span class="URLPACKT">http://localhost:1337/?id=7331</span></a>), the following message is shown:</p>
<pre>You specified a user ID =&gt; 7331 </pre>
<p>That happens because, as an <kbd>id</kbd> was provided in the query, the middleware function in the router will pass control to the next handler inside the router with <kbd>next()</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing error-handler middleware functions</h1>
                </header>
            
            <article>
                
<p>ExpressJS already includes by default a built-in error handler which gets executed at the end of all middleware and route handlers.</p>
<p>There are ways that the built-in error handler can be triggered. One is implicit when an error occurs inside a route handler. For example:</p>
<pre>app.get('/', (request, response, next) =&gt; { 
    throw new Error('Oh no!, something went wrong!') 
}) </pre>
<p>And another way of triggering the built-in error handler is explicit when passing an <kbd>error</kbd> as an argument to <kbd>next(error)</kbd>. For instance:</p>
<pre>app.get('/', (request, response, next) =&gt; { 
    try { 
        throw new Error('Oh no!, something went wrong!') 
    } catch (error) { 
        next(error) 
    } 
}) </pre>
<div class="packt_infobox">The stack trace is displayed on the client side. If <kbd>NODE_ENV</kbd> is set to production, then the stack trace is not included.</div>
<p>A custom error handler middleware function can be written as well and it looks pretty much the same as route handlers do with the exception that an error handler function middleware expects to receive four arguments:</p>
<pre>app.use((error, request, response, next) =&gt; { 
    next(error) 
}) </pre>
<p>Take into account that <kbd>next(error)</kbd>is optional. That means, if specified, <kbd>next(error)</kbd> will pass control over to the next error handler. If no other error handler was defined, then the control will pass to the built-in error handler.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to create a custom error handler. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>    <strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>You will build a custom error handler that sends to the client the error message.</p>
<ol>
<li>Create a new file named <kbd>custom-error-handler.js</kbd></li>
<li>Include the ExpressJS library, then initialize a new ExpressJS application:</li>
</ol>
<pre>     const express = require('express') 
     const app = express() </pre>
<ol start="3">
<li>Define a new Route Method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> and throw an error every time:</li>
</ol>
<pre>      app.get('/', (request, response, next) =&gt; { 
          try { 
             throw new Error('Oh no!, something went wrong!') 
          } catch (err) { 
             next(err) 
           } 
      }) </pre>
<ol start="4">
<li>Define a custom error handler middleware function to send the error message back to the client's browser:</li>
</ol>
<pre>      app.use((error, request, response, next) =&gt; { 
          response.end(error.message) 
      }) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node custom-error-handler.js</strong></pre>
<ol start="8">
<li>To see the result, in your web browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/</span><strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using ExpressJS' built-in middleware function for serving static assets</h1>
                </header>
            
            <article>
                
<p>Prior to the 4.x version of ExpressJS, it has depended on ConnectJS which is an HTTP server framework <a href="https://github.com/senchalabs/connect"><span class="URLPACKT">https://github.com/senchalabs/connect</span></a>. In fact, most middleware written for ConnectJS is also supported in ExpressJS.</p>
<p>As from the 4.x version of ExpressJS, it no longer depends on ConnectJS, and all previously built-in middleware functions were moved to separate modules <a href="https://expressjs.com/en/resources/middleware.html"><span class="URLPACKT">https://expressjs.com/en/resources/middleware.html</span></a><span class="URLPACKT">.</span></p>
<p>ExpressJS 4.x and newer versions include only two built-in middleware functions. The first one has already been seen: the built-in error handler middleware function. The second one is the <kbd>express.static</kbd> middleware function that is responsible for serving static assets.</p>
<p>The <kbd>express.static</kbd> middleware function is based on <kbd>serve-static</kbd> module <a href="https://expressjs.com/en/resources/middleware/serve-static.html"><span class="URLPACKT">https://expressjs.com/en/resources/middleware/serve-static.html</span></a><span class="URLPACKT">.</span></p>
<p>The main difference between <kbd>express.static</kbd> and <kbd>serve-static</kbd> is that the second one can be used outside of ExpressJS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will see how to build a web application that will serve static assets in a certain path. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new directory named <kbd>public</kbd></li>
<li>Move into the new <kbd>public</kbd> directory</li>
<li>Create a new file named <kbd>index.html</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="utf-8"&gt; 
          &lt;title&gt;Simple Web Application&lt;/title&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;section role="application"&gt; 
        &lt;h1&gt;Welcome Home!&lt;/h1&gt; 
          &lt;/section&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="5">
<li>Save the file</li>
<li>Navigate back out of the <kbd>public</kbd> directory</li>
<li>Create a new file named <kbd>serve-static-assets.js</kbd></li>
</ol>
<ol start="8">
<li>Add the following code. Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() </pre>
<ol start="9">
<li>Include the <kbd>express.static</kbd> configurable middleware function and Pass the path of the <kbd>/public</kbd> directory where <kbd>index.html</kbd> file is located:</li>
</ol>
<pre>      const publicDir = path.join(__dirname, './public') 
      app.use('/', express.static(publicDir)) </pre>
<ol start="10">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="11">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node serve-static-assets.js</strong></pre>
<ol start="13">
<li>To see the result, in your browser, navigate to:</li>
</ol>
<pre>      <span class="URLPACKT">http://localhost:1337/index.html</span><strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Our <kbd>index.html</kbd> file will be shown because we specified <kbd>"/"</kbd> as the root directory where to look for assets.</p>
<p>Try changing the path from <kbd>"/"</kbd> to <kbd>"/public"</kbd>. Then, you will be able to see that the <kbd>index.html</kbd> file, and other files that you want to include in the <kbd>/public</kbd> directory, will be accessible under <kbd>http://localhost:1337/public/[fileName]</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Let's pretend that you have a big project that serves dozens of static files, including images, font files, and PDF documents (those about privacy and legal stuff) among others. You decided that you want to keep them in separate files, but you do not want to change the mount path or URI. They can be served under <kbd>/public</kbd>, for example, but they will exist in separate directories in your project directory:</p>
<p>First, let's create the first <kbd>public</kbd> directory that will contain a single file named <kbd>index.html</kbd>:</p>
<ol>
<li>Create a new directory named <kbd>public</kbd> if you didn't create it in the previous recipe</li>
<li>Move into the new <kbd>public</kbd> directory</li>
<li>Create a new file named <kbd>index.html</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="utf-8"&gt; 
          &lt;title&gt;Simple Web Application&lt;/title&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
           &lt;section role="application"&gt; 
           &lt;h1&gt;Welcome Home!&lt;/h1&gt; 
           &lt;/section&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="5">
<li>Save the file</li>
</ol>
<p>Now, let's create a second public directory that will contain another file named <kbd>second.html</kbd>:</p>
<ol start="6">
<li>Move back out of the <kbd>public</kbd> directory</li>
<li>Create a new directory named <kbd>another-public</kbd></li>
<li>Move into the new <kbd>another-public</kbd> directory</li>
<li>Create a new empty file named <kbd>second.html</kbd></li>
</ol>
<ol start="10">
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="utf-8"&gt; 
          &lt;title&gt;Simple Web Application&lt;/title&gt; 
      &lt;/head&gt; 
     &lt;body&gt; 
          &lt;section role="application"&gt; 
           Welcome to Second Page! 
          &lt;/section&gt; 
     &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="11">
<li>Save the file</li>
</ol>
<p>As you can see, both files exist in different directories. To serve those files under one mount point:</p>
<ol>
<li>Move back out of the <kbd>another-public</kbd> directory</li>
<li>Create a new file named <kbd>router-serve-static.js</kbd></li>
<li>Include the ExpressJS and path libraries. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() </pre>
<ol start="4">
<li>Define a router:</li>
</ol>
<pre>      const staticRouter = express.Router() </pre>
<ol start="5">
<li>Use the <kbd>express.static</kbd> configurable middleware function to include both directories, <kbd>public</kbd> and <kbd>another-public</kbd>:</li>
</ol>
<pre>      const assets = { 
           first: path.join(__dirname, './public'), 
          second: path.join(__dirname, './another-public') 
      } 
       staticRouter 
          .use(express.static(assets.first)) 
          .use(express.static(assets.second)) </pre>
<ol start="6">
<li>Mount the Router to the <kbd>"/"</kbd> path:</li>
</ol>
<pre>       app.use('/', staticRouter) </pre>
<ol start="7">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
           () =&gt; console.log('Web Server running on port 1337'), 
       ) </pre>
<ol start="8">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node router-serve-static.js</strong></pre>
<ol start="10">
<li>To see the result, in the browser, navigate to:</li>
</ol>
<pre><strong><span class="URLPACKT">     </span></strong> http://localhost:1337/index.html
      http://localhost:1337/second.html<strong><br/></strong></pre>
<ol start="11">
<li>Two different files in different locations were served under one path</li>
</ol>
<div class="packt_infobox">If two or more files with the same name exist under different directories, only the first one found will be displayed on the client-side.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parsing the HTTP request body</h1>
                </header>
            
            <article>
                
<p><kbd>body-parser</kbd> is a middleware function that parses the incoming request body and makes it available in the <kbd>request</kbd> object as <kbd>request.body</kbd> <a href="https://expressjs.com/en/resources/middleware/body-parser.html"><span class="URLPACKT">https://expressjs.com/en/resources/middleware/body-parser.html</span></a><span class="URLPACKT">.</span></p>
<p>This module allows an application to parse the incoming request as:</p>
<ul>
<li>JSON</li>
<li>Text</li>
<li>Raw (buffer original incoming data)</li>
<li>URL encoded form</li>
</ul>
<p>The module supports automatic decompression of gzip and deflates encodings when the incoming request is compressed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will see how to use the <kbd>body-parser</kbd> NPM module to parse the content body sent from two different forms encoded in two different ways. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "body-parser": "1.18.2", 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Two forms will be displayed to the user, both of them will send data to our web server application encoded in two different ways. The first one is a URL encoded form while the other one will encode its body as plain text.</p>
<ol>
<li>Create a file named <kbd>parse-form.js</kbd></li>
<li>Include the <kbd>body-parser</kbd> NPM module. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const bodyParser = require('body-parser') 
      const app = express() </pre>
<ol start="3">
<li>Include the <kbd>body-parser</kbd> middleware functions to handle URL encoded requests and text plain requests:</li>
</ol>
<pre>       app.use(bodyParser.urlencoded({ extended: true })) 
       app.use(bodyParser.text()) </pre>
<ol start="4">
<li>Add a new route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd>. Serve HTML content with two forms that submit data using different encodings:</li>
</ol>
<pre>      app.get('/', (request, response, next) =&gt; { 
            response.send(` 
            &lt;!DOCTYPE html&gt; 
            &lt;html lang="en"&gt; 
            &lt;head&gt; 
              &lt;meta charset="utf-8"&gt; 
              &lt;title&gt;WebApp powered by ExpressJS&lt;/title&gt; 
           &lt;/head&gt; 
         &lt;body&gt; 
            &lt;div role="application"&gt; 
                &lt;form method="post" action="/setdata"&gt; 
                    &lt;input name="urlencoded" type="text" /&gt; 
                    &lt;button type="submit"&gt;Send&lt;/button&gt; 
                &lt;/form&gt; 
               &lt;form method="post" action="/setdata" <br/>                 enctype="text/plain"&gt; 
                  &lt;input name="txtencoded" type="text" /&gt; 
                  &lt;button type="submit"&gt;Send&lt;/button&gt; 
               &lt;/form&gt; 
           &lt;/div&gt; 
        &lt;/body&gt; 
        &lt;/html&gt; 
       `) 
     }) </pre>
<ol start="5">
<li>Add a new route method to handle <kbd>POST</kbd> requests for path <kbd>"/setdata"</kbd>. Display on terminal the content of <kbd>request.body</kbd>:</li>
</ol>
<pre>      app.post('/setdata', (request, response, next) =&gt; { 
          console.log(request.body) 
          response.end() 
      }) </pre>
<ol start="6">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="7">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>      node parse-form.js</strong></pre>
<ol start="9">
<li>In your web browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/</span><strong><br/></strong></pre>
<ol start="10">
<li>Fill the first input box with any data and submit the form:</li>
<li>In your web browser, navigate back to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/</span><strong><br/></strong></pre>
<ol start="12">
<li>Fill the second input box with any data and submit the form:</li>
<li>Check the output in the terminal</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Terminal outputs something like:</p>
<pre>{ 'urlencoded': 'Example' } 
txtencoded=Example </pre>
<p>Two parsers are used above:</p>
<ol>
<li>The first one <kbd>bodyParser.urlencoded()</kbd> parses incoming requests for <kbd>multipart/form-data</kbd> encoding type. The result is available as an <strong>Object</strong> in <kbd>request.body</kbd></li>
<li>The second one <kbd>bodyParser.text()</kbd> parses incoming requests for <kbd>text/plain</kbd> encoding type. The result is available as a <strong>String</strong> in <kbd>request.body</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compressing HTTP responses</h1>
                </header>
            
            <article>
                
<p><strong>compression</strong> is a middleware function that compresses the response body that will be send to the client. This module uses the <kbd>zlib</kbd> module <a href="https://nodejs.org/api/zlib.html"><span class="URLPACKT">https://nodejs.org/api/zlib.html</span></a> that supports the following content-encoding mechanisms:</p>
<ul>
<li>gzip</li>
<li>deflate</li>
</ul>
<p>The <kbd>Accept-Encoding</kbd> HTTP header is used to determine which content-encoding mechanism is supported on the client-side (for example web browser) while the <kbd>Content-Encoding</kbd> HTTP header is used to tell the client which content encoding mechanism was applied to the response body.</p>
<p><kbd>compression</kbd> is a configurable middleware function. It accepts an <kbd>options</kbd> object as the first argument to define a specific behavior for the middleware and also to pass <kbd>zlib</kbd> options as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see how to configure and use the <kbd>compression</kbd> NPM module to compress the request body sent to the client. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "compression": "1.7.2", 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>    <strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new file named <kbd>compress-site.js</kbd></li>
<li>Include the <kbd>compression</kbd> NPM module. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const compression = require('compression') 
      const app = express() </pre>
<ol start="3">
<li>Include the <kbd>compression</kbd> middleware function. Specify the <kbd>level</kbd> of compression to <kbd>9</kbd> (best compression) and <kbd>threshold</kbd>, or minimum size in bytes that the response should have to consider compressing the response body, to <kbd>0</kbd> bytes:</li>
</ol>
<pre>      app.use(compression({ level: 9, threshold: 0 })) </pre>
<ol start="4">
<li>Define a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> which will serve a sample HTML content that we expect to be compressed and will print the encodings that the client accepts:</li>
</ol>
<pre>      app.get('/', (request, response, next) =&gt; { 
          response.send(` 
          &lt;!DOCTYPE html&gt; 
          &lt;html lang="en"&gt; 
          &lt;head&gt; 
              &lt;meta charset="utf-8"&gt; 
              &lt;title&gt;WebApp powered by ExpressJS&lt;/title&gt; 
          &lt;/head&gt; 
          &lt;body&gt; 
              &lt;section role="application"&gt; 
                  &lt;h1&gt;Hello! this page is compressed!&lt;/h1&gt; 
              &lt;/section&gt; 
          &lt;/body&gt; 
         &lt;/html&gt; 
          `) 
          console.log(request.acceptsEncodings()) 
     }) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre class="mce-root"><strong>      node compress-site.js</strong> </pre>
<ol start="8">
<li class="mce-root">In your browser, navigate to:</li>
</ol>
<pre style="color: black"><span class="URLPACKT">      http://localhost:1337/</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The output of the Terminal will show the content encoding mechanism that the client (for example web browser) supports. It may look something like this:</p>
<pre><strong>      [ 'gzip', 'deflate', 'sdch', 'br', 'identity' ]</strong>
  </pre>
<p>The content encoding mechanism sent by the client is used by <kbd>compression</kbd> internally to know if compression is supported. If compression is not supported, then the response body is not compressed.</p>
<p>If opening Chrome Dev Tools or similar and analyzing the request made, the <kbd>Content-Encoding</kbd> header that was sent by the server indicates the kind of content encoding mechanism used by <kbd>compression</kbd>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/50e0019b-c8b1-4cfb-86f8-aaa8200854f8.png" style="width:25.67em;height:5.50em;" width="265" height="57"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Chrome Dev Tools | Network Tab displaying Response Headers</div>
<p>The <kbd>compression</kbd> library sets the <kbd>Content-Encoding</kbd> header to the encoding mechanism used for compressing the response body.</p>
<div class="packt_infobox">The <kbd>threshold</kbd> option is set by default to 1 KB which means that if the response size is below the number of bytes specified, then it is not compressed. Set it to 0 or <kbd>false</kbd> to compress the response even when the size is below 1 KB</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using an HTTP request logger</h1>
                </header>
            
            <article>
                
<p>As previously seen, writing a request logger is simple. However, writing our own could take precious time. Luckily, there are several other alternatives out there. For example, a very popular HTTP request logger widely used is morgan <a href="https://expressjs.com/en/resources/middleware/morgan.html"><span class="URLPACKT">https://expressjs.com/en/resources/middleware/morgan.html</span></a><span class="URLPACKT">.</span><a href="https://expressjs.com/en/resources/middleware/morgan.html"/></p>
<p><strong>morgan</strong> is a configurable middleware function that takes two arguments <kbd>format</kbd> and <kbd>options</kbd> which are used to specify the format in which the logs are displayed and what kind of information needs to be displayed.</p>
<p>There are several predefined formats:</p>
<ul>
<li><kbd>tiny</kbd>: Minimal output</li>
<li><kbd>short</kbd>: Same as tiny, including remote IP address</li>
<li><kbd>common</kbd>: Standard Apache log output</li>
<li><kbd>combined</kbd>: Standard Apache combined log output</li>
<li><kbd>dev</kbd>: Displays the same information as the tiny format does. However, the response statuses are colored.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "morgan": "1.9.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's build a working example. We will include the <strong>morgan</strong> configurable middleware function with the <kbd>dev</kbd> format to display information of every request.</p>
<ol>
<li>Create a new file named <kbd>morgan-logger.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const morgan = require('morgan') 
      const app = express() </pre>
<ol start="3">
<li>Include the <kbd>morgan</kbd> configurable middleware. Pass <kbd>'dev'</kbd> as the format we will use as the first argument to the middleware function:</li>
</ol>
<pre>      app.use(morgan('dev')) </pre>
<ol start="4">
<li>Define a route method to handle all <kbd>GET</kbd> requests:</li>
</ol>
<pre>      app.get('*', (request, response, next) =&gt; { 
          response.send('Hello Morgan!') 
      }) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
     ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre><strong>       node morgan-logger.js</strong></pre>
<ol start="8">
<li>To see the result in your terminal, in your web browser, navigate to:</li>
</ol>
<pre>        <span class="URLPACKT">http://localhost:1337/</span>
        <span class="URLPACKT">http://localhost:1337/example</span><strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing and creating virtual domains</h1>
                </header>
            
            <article>
                
<p>Managing virtual domains is really easy with ExpressJS. Imagine that you have two or more subdomains, and you want to serve two different web applications. However, you do not want to create a different web server application for each subdomain. In this kind of situation, ExpressJS allows developers to manage virtual domains within a single web server application using <strong>vhost</strong> <span class="URLPACKT"><a href="https://expressjs.com/en/resources/middleware/vhost.html">https://expressjs.com/en/resources/middleware/vhost.html</a></span>.</p>
<p><strong>vhost</strong> is a configurable middleware function that accepts two arguments. The first one is the <kbd>hostname</kbd>. The second argument is the request handler which will be called when the <kbd>hostname</kbd> matches.</p>
<p>The <kbd>hostname</kbd> follows the same rules as route paths do. They can be either a string or a regular expression.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "vhost": "3.0.2" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Build two mini applications using <strong>Router</strong> that will be served in two different sub-domains:</p>
<ol>
<li>Create a new file named <kbd>virtual-domains.js</kbd></li>
<li>Include <kbd>vhost</kbd> NPM module. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const vhost = require('vhost') 
      const app = express() </pre>
<ol start="3">
<li>Define two routers that we will use to build two mini-applications:</li>
</ol>
<pre>      const app1 = express.Router() 
      const app2 = express.Router() </pre>
<ol start="4">
<li>Add a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> in the first router:</li>
</ol>
<pre>      app1.get('/', (request, response, next) =&gt; { 
        response.send('This is the main application.') 
      }) </pre>
<ol start="5">
<li>Add a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> in the second router:</li>
</ol>
<pre>      app2.get('/', (request, response, next) =&gt; { 
         response.send('This is a second application.') 
     }) </pre>
<ol start="6">
<li>Mount our routers to our ExpressJS application. Serve the first application under <kbd>localhost</kbd> and the second under <kbd>second.localhost</kbd>:</li>
</ol>
<pre>      app.use(vhost('localhost', app1)) 
      app.use(vhost('second.localhost', app2)) </pre>
<ol start="7">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
         1337, 
         () =&gt; console.log('Web Server running on port 1337'), 
     ) </pre>
<ol start="8">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre>      node virtual-domains.js </pre>
<ol start="10">
<li>To see the result, in your web browser navigate to:</li>
</ol>
<pre>        <span class="URLPACKT">http://localhost:1337/</span>
        <span class="URLPACKT">http://second.localhost:1337/</span><strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p><kbd>vhost</kbd> adds a <kbd>vhost object</kbd> to the <kbd>request</kbd> object, which contains the complete hostname (displaying the hostname and port), hostname (without the port), and matching strings. These give you more control in how to handle virtual domains.</p>
<p>For example, we could write an application that allows users to have their own sub-domain with their name:</p>
<ol>
<li>Create a new file named <kbd>user-subdomains.js</kbd></li>
<li>Include the <kbd>vhost</kbd> NPM module. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const vhost = require('vhost') 
      const app = express() </pre>
<ol start="3">
<li>Define a new router. Then, add a route method to handle <kbd>GET</kbd> requests on path <kbd>"/"</kbd>. Use the <kbd>vhost</kbd> object to access the array of subdomains:</li>
</ol>
<pre>       const users = express.Router() 
       users.get('/', (request, response, next) =&gt; { 
        const username = request 
            .vhost[0] 
            .split('-') 
            .map(name =&gt; ( 
                name[0].toUpperCase() + 
                name.slice(1) 
             )) 
            .join(' ') 
        response.send(`Hello, ${username}`) 
     }) </pre>
<ol start="4">
<li>Mount the router:</li>
</ol>
<pre>       app.use(vhost('*.localhost', users)) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
           1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre>      node user-subdomains.js </pre>
<ol start="8">
<li>To see the result, in your web browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">        http://john-smith.localhost:1337/</span>
        <span class="URLPACKT">http://jx-huang.localhost:1337/</span>
        <span class="URLPACKT">http://batman.localhost:1337/</span><strong><br/></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing an ExpressJS web application with Helmet</h1>
                </header>
            
            <article>
                
<p><strong>Helmet</strong> allows to protect web server applications against common attacks, such as <strong>cross-site scripting (XSS)</strong>, insecure requests, and clickjacking.</p>
<p>Helmet is a collection of 12 middleware functions that allow you to set specific HTTP headers:</p>
<ol>
<li><kbd>Content Security Policy (CSP)</kbd>: This is an effective way to whitelist what kind of external resources are allowed in your web application, such as JavaScript, CSS, and images, for instance.</li>
<li><kbd>Certificate Transparency</kbd>: This is a way of providing more transparency for certificates issued for a specific domain or specific domains <a href="https://sites.google.com/a/chromium.org/dev/Home/chromium-security/certificate-transparency"><span class="URLPACKT">https://sites.google.com/a/chromium.org/dev/Home/chromium-security/certificate-transparency</span></a><span class="URLPACKT">.</span></li>
<li><kbd>DNS Prefetch Control</kbd>: This tells the browser if it should perform domain name resolution (DNS) on resources that are not yet loaded, such as links.</li>
<li><kbd>Frameguard</kbd>: This helps to prevent <strong>clickjacking</strong> by telling the browser not to allow your web application to be put inside an <kbd>iframe.</kbd></li>
<li><kbd>Hide Powered-By</kbd>: This simply hides the <kbd>X-Powered-By</kbd> header indicates not to display what technology powers the server. ExpressJS sets this header to <kbd>"Express"</kbd> by default.</li>
<li><kbd>HTTP Public Key Pinning</kbd>: This helps to prevent <strong>man-in-the-middle-attacks</strong> by pinning your web application's public keys to the <kbd>Public-Key-Pins</kbd>header.</li>
<li><kbd>HTTP Strict Transport Security</kbd>: This tells the browser to strictly stick to the HTTPs version of your web application.</li>
<li><kbd>IE No Open</kbd>: This prevents Internet Explorer from executing untrusted downloads, or HTML files, on the context of your site, thus preventing the injection of malicious scripts.</li>
<li><kbd>No Cache</kbd>: This tells the browser to disable browser caching.</li>
<li><kbd>Don't Sniff Mimetype</kbd>: This forces the browser to disable mime sniffing or guessing the content type of a served file.</li>
</ol>
<ol start="11">
<li><kbd>Referrer Policy</kbd>: The referrer headers provide the server with data regarding where the request was originated. It allows developers to disable it, or set a stricter policy for setting a <kbd>referrer</kbd> header.</li>
<li><kbd>XSS Filter</kbd>: This prevents reflected cross-site scripting (XSS) attacks by setting the <kbd>X-XSS-Protection</kbd> header.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will use most of the middleware functions provided by Helmet to secure our ExpressJS web application against common attacks. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "body-parser": "1.18.2", 
        "express": "4.16.3", 
        "helmet": "3.12.0", 
        "uuid": "3.2.1" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new file named <kbd>secure-helmet.js</kbd></li>
<li>Include the ExpressJS, helmet, and body NPM modules:</li>
</ol>
<pre>      const express = require('express') 
      const helmet = require('helmet') 
      const bodyParser = require('body-parser') 
      const uuid = require('uuid/v1') 
      const app = express() </pre>
<ol start="3">
<li>Generate a random ID which will be used for <kbd>nonce</kbd> which is an HTML attribute used for whitelist which scripts or styles are allowed to be executed inline in the HTML code:</li>
</ol>
<pre>      const suid = uuid() </pre>
<ol start="4">
<li>Use body parser to parse JSON request body for <kbd>json</kbd> and <kbd>application/csp-report</kbd> content types. <kbd>application/csp-report</kbd> is a content type that contains a JSON request body of type <kbd>json</kbd> which is sent by the browser when one or several CSP rules are violated:</li>
</ol>
<pre>      app.use(bodyParser.json({ 
          type: ['json', 'application/csp-report'], 
      })) </pre>
<ol start="5">
<li>Use the <kbd>Content Security Policy</kbd> middleware function to define directives. <kbd>defaultSrc</kbd> specifies where resources can be loaded from. The <kbd>self</kbd> option specifies to load resources only from your own domain. We will use <kbd>none</kbd> instead, which means that no resources will be loaded. However, because we are whitelisting <kbd>scriptSrc</kbd>, we will be able to load Javascript scripts but only the ones that have the <kbd>nonce</kbd> that we will specify. The <kbd>reportUri</kbd> is used to tell the browser where to send violation reports of our <kbd>Content Security Policy</kbd>:</li>
</ol>
<pre>      app.use(helmet.contentSecurityPolicy({ 
          directives: { 
              // By default do not allow unless whitelisted 
              defaultSrc: [`'none'`], 
               // Only allow scripts with this nonce 
              scriptSrc: [`'nonce-${suid}'`], 
              reportUri: '/csp-violation', 
          } 
      })) </pre>
<ol start="6">
<li>Add a route method to handle <kbd>POST</kbd> request for path <kbd>"/csp-violation"</kbd> to receive violation reports from the client:</li>
</ol>
<pre>      app.post('/csp-violation', (request, response, next) =&gt; { 
          const { body } = request 
          if (body) { 
             console.log('CSP Report Violation:') 
             console.dir(body, { colors: true, depth: 5 }) 
         } 
         response.status(204).send() 
      }) </pre>
<ol start="7">
<li>Use the <kbd>DNS Prefetch Control</kbd> middleware to disable prefetch of resources:</li>
</ol>
<pre>      app.use(helmet.dnsPrefetchControl({ allow: false })) </pre>
<ol start="8">
<li>Use the <kbd>Frameguard</kbd> middleware function to disable your application from being loaded inside a <kbd>iframe</kbd>:</li>
</ol>
<pre>      app.use(helmet.frameguard({ action: 'deny' })) </pre>
<ol start="9">
<li>Use the <kbd>hidePoweredBy</kbd> middleware function to replace the <kbd>X-Powered-By</kbd> header and set a fake one:</li>
</ol>
<pre>      app.use(helmet.hidePoweredBy({ 
          setTo: 'Django/1.2.1 SVN-13336', 
      })) </pre>
<ol start="10">
<li>Use the <kbd>ieNoOpen</kbd> middleware function to disable IE untrusted executions:</li>
</ol>
<pre>       app.use(helmet.ieNoOpen()) </pre>
<ol start="11">
<li>Use the <kbd>noSniff</kbd> middleware function to disable mime-type guessing:</li>
</ol>
<pre>      app.use(helmet.noSniff()) </pre>
<ol start="12">
<li>Use the <kbd>referrerPolicy</kbd> middleware function to make the header available only for our domain:</li>
</ol>
<pre>       app.use(helmet.referrerPolicy({ policy: 'same-origin' })) </pre>
<ol start="13">
<li>Use the <kbd>xssFilter</kbd> middleware function to prevent Reflected XSS attacks:</li>
</ol>
<pre>      app.use(helmet.xssFilter()) </pre>
<ol start="14">
<li>Add a route method to handle <kbd>GET</kbd> requests on path <kbd>"/"</kbd> and serve a sample HTML content that will try to load an image from an external source, try to execute an inline script, and try to load an external script without a <kbd>nonce</kbd> specified. We will add a valid script as well that is allowed to be executed because a <kbd>nonce</kbd> attribute will be specified:</li>
</ol>
<pre>      app.get('/', (request, response, next) =&gt; { 
         response.send(` 
         &lt;!DOCTYPE html&gt; 
         &lt;html lang="en"&gt; 
         &lt;head&gt; 
             &lt;meta charset="utf-8"&gt; 
             &lt;title&gt;Web App&lt;/title&gt; 
         &lt;/head&gt; 
          &lt;body&gt; 
             &lt;span id="txtlog"&gt;&lt;/span&gt; 
              &lt;img alt="Evil Picture" src="http://evil.com/pic.jpg"&gt; 
             &lt;script&gt; 
                  alert('This does not get executed!') 
              &lt;/script&gt; 
              &lt;script src="http://evil.com/evilstuff.js"&gt;&lt;/script&gt; 
              &lt;script nonce="${suid}"&gt; 
                  document.getElementById('txtlog') 
                    .innerText = 'Hello World!' 
              &lt;/script&gt; 
           &lt;/body&gt; 
         &lt;/html&gt; 
       `) 
     }) </pre>
<ol start="15">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>     app.listen( 
          1337, 
         () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="16">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre>      node secure-helmet.js </pre>
<ol start="18">
<li>To see the results, in your web browser, navigate to:</li>
</ol>
<pre>        http://localhost:1337/</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>How everything works is pretty straight forward with <kbd>Helmet</kbd>. You specify the security measures you want to implement by choosing and applying a specific <kbd>Helmet</kbd> middleware function and <kbd>Helmet</kbd> will do the work of setting the right headers that will be sent to the client.</p>
<p>In the client side (web browser), everything just works by its own. The web browser is in charge of interpreting the headers sent by the server and applying the security policies. This also means that old browsers cannot support or understand all these headers. Saying that, there are not many good reasons why you would want to support old web browsers if you have security in mind for your application.</p>
<p>If you are using Chrome, for instance, you should be able to see something similar to this in the console:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/e75f8ade-149b-4074-971f-489e190d69ca.png" style="width:42.92em;height:19.17em;" width="457" height="204"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Chrome Dev Tools | Console displaying CSP violation</div>
<ol>
<li>In the Terminal, you should be able to see similar output to the following that is sent by the browser:</li>
</ol>
<pre>      CSP Report Violation: { 
          "csp-report": { 
               "document-uri": "http://localhost:1337/", 
              "referrer": "", 
              "violated-directive": "img-src", 
              "effective-directive": "img-src", 
              "original-policy": "default-src 'none'; script-src              <br/>         '[nonce]'; report-uri /csp-violation", 
              "disposition": "enforce", 
              "blocked-uri": "http://evil.com/pic.jpg", 
              "line-number": 9, 
              "source-file": "http://localhost:1337/", 
              "status-code": 200 
          } 
      }  
      CSP Report Violation: { 
          "csp-report": { 
              "document-uri": "http://localhost:1337/", 
              "referrer": "", 
              "violated-directive": "script-src", 
              "effective-directive": "script-src", 
              "original-policy": "default-src 'none'; script-src        <br/>       '[nonce]'; report-uri /csp-violation", 
              "disposition": "enforce", 
              "blocked-uri": "inline", 
              "line-number": 9, 
              "status-code": 200 
          } 
      }  
      CSP Report Violation: { 
          "csp-report": { 
              "document-uri": "http://localhost:1337/", 
              "referrer": "", 
              "violated-directive": "script-src", 
              "effective-directive": "script-src", 
              "original-policy": "default-src 'none'; script-src <br/>      '[nonce]'; report-uri /csp-violation", 
              "disposition": "enforce", 
              "blocked-uri": "http://evil.com/evilstuff.js", 
              "status-code": 200 
          } 
      } </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using template engines</h1>
                </header>
            
            <article>
                
<p>Template engines allow you to generate HTML code in a more convenient way. Templates or views can be written in any format, interpreted by a template engine that will replace variables with other values, and finally transform to HTML.</p>
<p>A big list of template engines that work out of the box with ExpressJS, is available in the official website at <a href="https://github.com/expressjs/express/wiki#template-engines"><span class="URLPACKT">https://github.com/expressjs/express/wiki#template-engines</span></a>.<a href="https://github.com/expressjs/express/wiki#template-engines"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will build your own template engine. To develop and use your own template engine, you will first need to register it, then define the path where the views are located, and finally tell ExpressJS which template engine to use.</p>
<pre>      app.engine('...', (path, options, callback) =&gt; { ... }); 
      app.set('views', './'); 
      app.set('view engine', '...'); </pre>
<p>Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>      { 
          "dependencies": { 
              "express": "4.16.3" 
          } 
      } </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre>       <strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First create a <kbd>views</kbd> directory which will contain a simple template:</p>
<ol>
<li>Create a new directory named <kbd>views</kbd></li>
<li>Create a new file named <kbd>home.tpl</kbd> inside our <kbd>views</kbd> directory</li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
       &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="utf-8"&gt; 
          &lt;title&gt;Using Template Engines&lt;/title&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;section role="application"&gt; 
              &lt;h1&gt;%title%&lt;/h1&gt; 
              &lt;p&gt;%description%&lt;/p&gt; 
          &lt;/section&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="4">
<li>Save the file</li>
</ol>
<p>Now, create a new template engine that will transform the previous template into HTML and replace <kbd>%[var]%</kbd> with the options provided:</p>
<ol>
<li>Move out of the <kbd>views</kbd> directory</li>
<li>Create a new file named <kbd>my-template-engine.js</kbd></li>
</ol>
<ol start="3">
<li>Include the ExpressJS and fs (file system) libraries. Then, initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const fs = require('fs') 
      const app = express() </pre>
<ol start="4">
<li>Use the <kbd>engine</kbd> method to register a new template engine named <kbd>tpl</kbd>. We will read the file's content and replace <kbd>%[var]%</kbd> with the one specified in the <kbd>options</kbd> object:</li>
</ol>
<pre>       app.engine('tpl', (filepath, options, callback) =&gt; { 
           fs.readFile(filepath, (err, data) =&gt; { 
              if (err) { 
                 return callback(err) 
             } 
             const content = data 
                 .toString() 
                 .replace(/%[a-z]+%/gi, (match) =&gt; { 
                     const variable = match.replace(/%/g, '') 
                    if (Reflect.has(options, variable)) { 
                        return options[variable] 
                     } 
                    return match 
                }) 
              return callback(null, content) 
          }) 
     }) </pre>
<ol start="5">
<li>Define the path where the views are located. Our template is located in the <kbd>views</kbd> directory:</li>
</ol>
<pre>       app.set('views', './views') </pre>
<ol start="6">
<li>Tell ExpressJS to use our template engine:</li>
</ol>
<pre>      app.set('view engine', 'tpl') </pre>
<ol start="7">
<li>Add a route method to handle <kbd>GET</kbd> requests for path <kbd>"/"</kbd> and render our home template. Provide the <kbd>title</kbd> and <kbd>description</kbd> options which will replace <kbd>%title%</kbd> and <kbd>%description%</kbd> in our template:</li>
</ol>
<pre>     app.get('/', (request, response, next) =&gt; { 
          response.render('home', { 
              title: 'Hello', 
               description: 'World!', 
         }) 
      }) </pre>
<ol start="8">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="9">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre>    <strong>node my-template-engine.js</strong></pre>
<ol start="11">
<li>In your browser, navigate to:</li>
</ol>
<pre><span class="URLPACKT">      http://localhost:1337/</span><strong><br/></strong></pre>
<div class="packt_infobox">The template engine we just have wrote doesn't escape HTML characters. That means, you should be careful if replacing those properties with data gotten from the client because it may be vulnerable to XSS attacks. You may want to use a template engine from the official ExpressJS website that is safer.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Debugging your ExpressJS web application</h1>
                </header>
            
            <article>
                
<p>Debugging information on ExpressJS about all of the cycle of a web application is something simple. ExpressJS uses the <strong>debug</strong> NPM module internally to log information. Unlike <kbd>console.log</kbd>, <strong>debug</strong> logs can easily be disabled on production mode.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will see how to debug your ExpressJS web application. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "debug": "3.1.0", 
        "express": "4.16.3" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new file named <kbd>debugging.js</kbd></li>
<li>Initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>Add a route method to handle <kbd>GET</kbd> requests for any path:</li>
</ol>
<pre>      app.get('*', (request, response, next) =&gt; { 
          response.send('Hello there!') 
      }) </pre>
<ol start="4">
<li>Listen on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="5">
<li>Save the file</li>
<li>Open a terminal and run:</li>
<li>On Windows:</li>
</ol>
<pre><strong>      set DEBUG=express:* node debugging.js</strong></pre>
<ol start="8">
<li>On Linux or MacOS:</li>
</ol>
<pre class="mce-root"><strong>      DEBUG=express:* node debugging.js</strong> <span><br/></span></pre>
<ol start="9">
<li class="mce-root">In your web browser, navigate to:</li>
</ol>
<pre style="color: black"><span class="URLPACKT">      http://localhost:1337/</span></pre>
<ol start="10">
<li>Observe your terminal's output for logs</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>DEBUG</kbd> environment variable is used to tell the <strong>debug</strong> module which parts of the ExpressJS application to debug. In our previously written code, <kbd>express:*</kbd> tells the debug module to log everything related to the express application.</p>
<p>We could use <kbd>DEBUG=express:router</kbd> to displays logs related to the Router or routing of ExpressJS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>You can use the debug NPM module in your own projects. For example:</p>
<ol>
<li>Create a new file named <kbd>myapp.js</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() 
      const debug = require('debug')('myapp') 
      app.get('*', (request, response, next) =&gt; { 
          debug('Request:', request.originalUrl) 
          response.send('Hello there!') 
      }) 
      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="3">
<li>Save the file</li>
<li>Open a terminal and run:</li>
<li>On Windows:</li>
</ol>
<pre>    <strong>set DEBUG=myapp node myapp.js</strong></pre>
<ol start="6">
<li>On Linux and MacOS:</li>
</ol>
<pre><strong>      DEBUG=myapp node myapp.js</strong></pre>
<ol start="7">
<li>In your web browser, navigate to:</li>
<li>Observe your Terminal's output. It would display something like:</li>
</ol>
<pre>      Web Server running on port 1337 
        myapp Request: / +0ms </pre>
<p>You can use the <kbd>DEBUG</kbd> environment variable to tell the <kbd>debug</kbd> module to displays logs not only for <kbd>myapp</kbd> but also for ExpressJS like so:</p>
<p>On Windows:</p>
<pre><strong>set DEBUG=myapp,express:* node myapp.js</strong> </pre>
<p>On Linux and MacOS:</p>
<pre><strong>DEBUG=myapp,express:* node myapp.js</strong></pre>


            </article>

            
        </section>
    </div>



  </body></html>