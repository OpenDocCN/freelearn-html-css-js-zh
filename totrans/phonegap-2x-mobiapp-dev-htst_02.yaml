- en: Chapter 2. Let's Get Social!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social networking has changed the way we share information in our world. Where
    it used to be an e-mail to a friend (or even a letter!), now it's a Twitter or
    a Facebook post, often for the world to see. What's even more amazing is how relatively
    young the various social networks are and how quickly they have changed the way
    we communicate and consume information. Because of this transformation, our apps
    need to support sharing to social networks, lest our app appears dated.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will build an app that illustrates both sides of the social
    network equation. The first is that of consuming the information from various
    sources; we'll be using Twitter streams for this. The second is that of sharing
    information; we'll be using each platform's native sharing capabilities for this,
    except for iOS where we'll be using a project called ShareKit to implement sharing.
    (Note that iOS 5 supports Twitter sharing and iOS 6 expands that to Facebook.
    Sooner or later a plugin is bound to appear that supports these functions, but
    ShareKit provides more targets.)
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our app, called Socializer, will display the Twitter streams from five pre-set
    Twitter accounts. The user can then read these streams, and should they find an
    interesting tweet, they can tap on it to do more with it. For example, they may
    wish to view a link embedded in the tweet. More importantly, the end user may
    wish to share the information using their own social network of choice, and the
    app will offer a Share button to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we'll be working with Twitter's JSON API, a natural fit
    for an app already written largely in JavaScript. The only downside is that Twitter
    has a pretty low cap for rate-limiting API requests, so we'll also have to build
    some basic support for when this occurs. (To be honest, this is far more likely
    to occur to us as a developer than the user because we often reload the app to
    test a new feature, which incurs new API requests far faster than an end user
    would typically incur them.)
  prefs: []
  type: TYPE_NORMAL
- en: We'll also introduce the concept of PhoneGap plugins, as sharing functionality
    is not present in the typical PhoneGap install by default. A plugin is essentially
    a bridge between some amount of native code (such as Java, Objective C, or C#)
    and our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we'll be using two plugins for each platform we support. One,
    `ChildBrowser` , is supported across most platforms, which makes it far easier
    to write code that uses it. The second is based upon the platform's sharing capabilities
    and what plugins are available for the platform and PhoneGap. Since this varies,
    we'll have to deal with separate code paths for each platform, but the idea will
    be the same—to share content.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project is a great introduction to handling APIs using JSON, including
    Twitter's API. While we're using a very small subset of Twitter's API, the lessons
    learned in this project can be expanded to deal with the rest of the APIs. Furthermore,
    JSON APIs are frequently used by many web platforms, and learning how to deal
    with Twitter's API is a great way to learn how to deal with any JSON API.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be dealing with how to share content. While Android provides a shared
    mechanism between all apps that provide a nice list of sharing apps, iOS does
    not. So we'll also have to write code that is platform specific to handle the
    differences in how each platform (and the corresponding plugin) supports sharing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be working with PhoneGap plugins, something many apps will eventually
    require in one way or another. For example, our app should be able to handle links
    to external websites; the best way to do this is to have the `ChildBrowser` plugin
    handle it. This lets the user stay inside our app and easily return to our app
    when they are done. Without it, we'd be taking the user out of the app and into
    the default browser.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do this, we''re going to break down the creation of our app into several
    different parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app – UI/interaction design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the app – the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the social view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the tweet view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like in the previous project, we'll focus on the design of the app before
    we handle the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll need to go ahead and create your project, just like we did in the last
    project. You can, to some degree, copy the previous project and replace the necessary
    files and settings as well. There is one additional iOS setting that should be
    modified, but it''s really a matter of taste (whether or not you like your status
    bars black or grey):'
  prefs: []
  type: TYPE_NORMAL
- en: Open `Socializer-info.plist`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `Status Bar style` and set it to `UIStatusBarStyleOpaqueBlack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll also be using the same directory structure as the previous project,
    with two exceptions: we''ll be adding a `www/childbrowser` directory and a `www/plugins`
    directory. Underneath the `www/plugins` directory, we''ll have a directory for
    each platform: namely, `/www/plugins/Android` and `/www/plugins/iOS`. We''ll fill
    these directories later, but go ahead and create them now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the same framework, so be sure to copy the framework files.
    We won''t worry about localizing the content, but even so, we''ll use all the
    localization functions so that it would be easy to do so. We''ll also use a script
    to deal with scrolling in `www/framework` called `scroller.js`. You''ll need to
    add this to your index files in order to use it correctly, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll also need to download the PhoneGap plugins repository available at [http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins).
    This will ensure you have all the necessary plugins we'll need as well as any
    plugins you might be interested in working with on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for iOS, we'll need to get the ShareKit 2.0 plugin available at [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit).
    Due to the way it is distributed, you'll need to install Git and make sure you
    enable Git for the project. (Alternatively, you can use the `/Submodules` directory
    in the download files).
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app – UI/interaction design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to design our user interface and the interaction between
    the various widgets and views. Like in the previous task, we will have three views:
    the start view, the social view, and the tweet view.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll begin with the start view. As in the last project, this will be a very
    simple view and is entirely optional in this app. All we'll be doing is explaining
    the app and providing a way to move to the main view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, following is our screenshot for the start view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, we have a **Start** button (1) that will push the social
    view on to the view stack. We also have some explanatory text (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next view is the social view, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The social view is essentially a list of tweets, one after the other. We'll
    display several tweets at a time, and, as such, we'll have to deal with scrolling
    at some point. While you can use various libraries to accomplish this, we'll be
    using our own minimalist scrolling library.
  prefs: []
  type: TYPE_NORMAL
- en: Each tweet will consist of a profile image (1), the screen name and real name
    (if available) (2), and the text of the tweet (3). When the user taps a tweet,
    we'll transition to the tweet view.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the view (4), we have a series of profile images for five different
    Twitter accounts. The images will be retrieved from Twitter itself; we won't be
    storing the images ourselves. When an image is tapped, we'll load the respective
    Twitter stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tweet view looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, note that our tweet view repeats the tweet (1) that the user tapped
    on in the stream view. The same information is repeated, but we also list out
    the various web links (2) that the tweet might have, any hashtags (3), and any
    user mentions (4). Items (2) to (4) are intended to be tappable: that is, if a
    user taps on (2), they should be taken to the particular website. If they tap
    on (3), they should be taken back to the social view with a stream of tweets referencing
    the hashtag. The same should happen if they tap on (4), except that it would be
    that particular user''s stream.'
  prefs: []
  type: TYPE_NORMAL
- en: We also have a **Back** button in our navigation bar to take the user back to
    the previous view, and a **Share** button (5) in our toolbar. This button, when
    tapped, should display a list (6) of various social network services. What this
    list will look like will depend upon the platform the app is on, and what social
    networks are installed on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created our mockup, we need to define some of the resources we'll
    need. Let's open up our editing program and get busy designing our app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is a pretty good representation of how our final product
    will look. A lot of it can be accomplished with CSS . The background of the Twitter
    stream and the navigation bar are the only two components that will be difficult,
    so we should save those out to our `www/images` directory as `Background.png`
    and `NavigationBar.png` respectively. Notice that, both have a texture, so make
    sure to save them in a way that they will tile without visible seams.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this task, we've defined how our UI should look, and the various interactions
    between widgets and views. We also generated a mockup of the app in our graphics
    editor and created some image resources for our later use.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the app – the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task, we will design our data model for handling Twitter users and streams.
    Our model will, to some extent, rely on Twitter's model as well. The results that
    it returns from its API we will use unmodified. The rest of the model we will
    define in this task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at our data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll be using `TWITTER` as the namespace and within it, we''ll have two objects
    we''ll be using a lot: `TwitterUser` and `TwitterStream`. The idea behind `TwitterUser`
    is to be an instance of a particular user, which we''ll represent by an image
    on the toolbar in the streams view. The `TwitterStream` object will be a representation
    of a single stream.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine `TwitterUser` more closely. The object has two properties: `screenName`
    and `userData`. The `screenName` property holds the user''s Twitter username.
    The `userData` property will hold the response from Twitter''s API. It will have
    lots of different information about the user, including their profile image URL,
    their real name, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor will return an initialized `TwitterUser` based upon the supplied
    screen name. Internally, the constructor just calls the `setScreenName()` method,
    which will request the user data from Twitter. The `getScreenName()` method simply
    returns the screen name. The `getProfileImageUrl()` method will return the URL
    to the user's profile image. The `getUserData()` method will return the data that
    Twitter returned, and the `getTimeline()` method will create a `TwitterStream`
    object for the particular user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TwitterStream` object operates on a similar idea: it will house the data
    returned by Twitter. The `TwitterStream` object also provides us the ability to
    get a stream for a particular user as well as the ability to return a stream for
    any search (such as a hashtag).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructed, we pass three options: the screen name or the search phrase,
    the maximum number of tweets to return (up to 200), and a function to call when
    the stream is fully loaded. It will call the `loadStream()` method to do the actual
    loading.'
  prefs: []
  type: TYPE_NORMAL
- en: We have some methods related to the properties in the object such as `setScreenName()`
    , `setSearchPhrase()` , `getSearchPhrase()` , `setMaxCount()` , `getMaxCount()`
    , and `getStream()` .
  prefs: []
  type: TYPE_NORMAL
- en: The `setScreenName()` method does the same thing as setting a `searchPhrase()`
    method except that it adds an `@` character to the name. The `loadStream()` method
    then can decide which API to call when loading a stream, either by calling the
    API to return the user's stream, or by calling the search API.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created and defined our data model for our app. We''ve defined two objects:
    namely, `TwitterUser` and `TwitterStream`, and saw how they interact.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be creating two files: namely, `twitter.js` and `twitterUsers.js`. Place
    these in the `www/models` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the `twitter.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we define our namespace, in this case, `TWITTER`, as seen in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We define two variables global to the `TWITTER` namespace: namely, `_baseURL`
    and `_searchBase`. These two URLs point at Twitter''s JSON API; the first is for
    API requests such as user lookups, user streams, and such, while the latter is
    only for searching. We define them here for two reasons: to make the URLs a little
    less nasty in the following code, and if Twitter should ever decide to have a
    different version of the API (and you want to change it), you can do so here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define our first object, `TwitterUser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined our two properties: `_screenName` and `_userData`. Unlike in
    the last project, we''re using underscores in front to indicate that these are
    internal (private) variables that no outside object should access. Instead, an
    outside object should use the `get`/`set` methods we define next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This one''s simple enough, it just returns the private member when asked. But
    the next one''s more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Like with a normal `set` method, we've assigned `theScreenName` to `_screenName`.
    But when this happens, we want to load in the user information from Twitter. This
    is why it is important to have `get`/`set` methods in front of private methods.
    You might just need to do something important when the value changes or is read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we've defined our URL that we're going to use to ask Twitter to look up
    the user in question. For more information about how this particular URL works,
    see the Twitter documentation at [https://dev.twitter.com/docs/api/1/get/users/lookup](https://dev.twitter.com/docs/api/1/get/users/lookup).
    You can see a full example of what is returned at the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our URL, we''re going to use another utility function defined
    for us in `PKUTIL` ([www/framework/utility.js](http://www/framework/utility.js))
    called `loadJSON()` . It uses AJAX to send a request to the preceding URL, and
    Twitter then sends a response back, in the form of JSON. When it is finished,
    the function will call the `completion` function we''re passing as the second
    parameter after `getUserURL`. This method can check if the request succeeded or
    not, and set any private members that are necessary. We''ll also call the `completion`
    function passed to the `setScreenName()` method. These actions are defined in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If success is true, then the JSON has been properly returned and parsed into
    the data parameter. We just assign it to the private `_userData` member as seen
    in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But if success is false, then something's gone wrong. Any number of things could
    have happened, Twitter might be down (not unheard of), the network connection
    might have failed, or Twitter might have rate limited us. For now we're just going
    to assume the latter, but you could certainly build more complicated error-detection
    schemes to figure out which is which.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, regardless of success or failure, we call the `completion` function
    passed to us. This is important so that we know when we can safely access the
    `_userData` member (via `getUserData` a little lower down).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the method `getProfileImageURL()` is a convenience
    function that returns the user's profile image URL. This is a link to the avatar
    being used for Twitter. First we check to see if `_userData[0]` exists, and if
    so, return `profile_image_url`, a value defined by the Twitter API. If it doesn't,
    we'll just return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, `getUserData()` is used to return the `_userData` member. If it has been
    properly loaded, it will have a lot of values in it, all determined by Twitter.
    If it has failed to load, it'll have an error property in it, and if it hasn't
    been loaded at all, it'll be empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`getTimeline()` is also a convenience function used to get the timeline for
    the Twitter user. `theMaxCount` is the maximum number of tweets to return (up
    to 200), and `completion` is a function to call when it''s all done. We do this
    by creating a new `TwitterStream` object (defined in the following code snippet)
    with the Twitter screen name prepended by an `@` character.'
  prefs: []
  type: TYPE_NORMAL
- en: If `theMaxCount` isn't specified, we use a little `||` trick to indicate the
    default value, `25` tweets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we do is actually call the `setScreenName()` method with `theScreenName`
    and `completion` functions passed in to the constructor. If you remember your
    JavaScript, this whole function, while we can think of it as defining an object,
    is also the constructor of that object. In this case, as soon as you create the
    `TwitterUser` object, we'll fire off a request to Twitter to load in the user's
    data and set it to `_userData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next object is the `TwitterStream` object defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we've defined three properties, namely, `_searchPhrase`, `_stream`, and
    `_theMaxCount`. The `_searchPhrase` property can be either the screen name of
    a user or a literal search term, such as a hashtag. The `_stream` property is
    the actual collection of tweets obtained from Twitter, and the `_theMaxCount`
    property is the maximum number of tweets to ask for. (Keep in mind that Twitter
    is free to return less than this amount.)
  prefs: []
  type: TYPE_NORMAL
- en: You may ask why we're storing either a search phrase or a screen name. The reason
    is that we're attempting to promote some code re-use. It's only logical to assume
    that a Twitter stream is a Twitter stream, regardless of how it was found, either
    by asking for a particular user's stream or by searching for a word. Nice assumption,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, totally wrong too. The streams are close, close enough that we can work
    around the differences, but still, not the same. So even though we're treating
    them here as one-and-the-same, they really aren't, at least until Twitter decides
    to change their search API to better match their non-search API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we have the `get`/`set` methods for `_theMaxCount`. All we do is `set`
    and retrieve the value. One thing to note is that this should be called before
    we actually load a stream; this value is part of the ultimate URL we sent to Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have two `set` methods that act on `_searchPhrase` while we only
    have one `get` method. What we're doing here is permitting someone to call `setScreenName()`
    without the `@` character. The `_searchPhrase` property will then be set to `@`
    prepended to the screen name. The next `set` method (`setSearchPhrase()`) is intended
    to be used when setting real search terms (such as a hashtag).
  prefs: []
  type: TYPE_NORMAL
- en: Internally, we'll use that `@` at the front to mean something special, but you'll
    see that in a second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getStream()` method just returns our `_stream`, which if we haven''t loaded
    one, will be blank. So let''s look at the `loadStream()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `loadStream()` method takes a `completion` function; we'll call this at
    the end of the operation no matter what. It lets the rest of our code know when
    it is safe to access the `_stream` member via `getStream()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other component is the `forScreenName` variable; if true, we''ll be asking
    Twitter for the stream that belongs to the screen name stored in `_searchPhrase`;
    otherwise, we''ll ask Twitter to do an actual search for `_searchPhrase`. This
    variable is defined in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ve done so far is define `theStreamURL` to point either at the search
    API (for a search term) or the non-search API (for a screen name''s stream). Next
    we''ll load it with `loadJSON(` `)`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here's another reason why we need to know if we're processing for a screen name
    or for a search, the JSON we get back is slightly different. When searching, Twitter
    helpfully includes other information (such as the time it took to execute the
    search). In our case, we're not interested in anything but the results, hence
    the two separate code paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, if we have a failure, we're assuming that we are rate-limited.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When done, we call the `completion` method, helpfully passing along the data
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just like at the end of the last object, we call some methods at the end of
    this object too. First we set the incoming search phrase, then set the maximum
    number of tweets to return (or 25, if it isn't given to us), and then call the
    `loadStream()` method with the `completion` function. This means that the moment
    we create a new `TwitterStream` object, it's already working on loading all the
    tweets we'll be wanting to have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve taken care of almost all our data model, but we''ve just a little bit
    left to do in `twitterUsers.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create a `users()` array in the `TWITTER` namespace. We''re going
    to use this to store our predefined Twitter users, which will be loaded with the
    `loadTwitterUsers()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here essentially is just chained together five requests for
    five different Twitter accounts. You can store these in an array and ask for them
    all at once, yes, but our app needs to know when they've all loaded. You could
    also do this by using recursion through an array of users, but we'll leave it
    as an example to you, the reader.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We implemented our data model and predefined the five Twitter accounts we want
    to use. We also went over the `loadJSON()` method in `PKUTIL` which helps with
    the entire process. We've also been introduced to the Twitter API.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go on, let''s take a look at the `loadJSON()` method you''ve been
    introduced to. It''s been added to this project''s `www/framework/utility.js`
    file, and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First off, this is a pretty simple function to begin with. What we're really
    doing is utilizing `PKUTIL.load()` to do the hard work of calling out to the URL
    and passing us the response, but when the response is received, it's going to
    be coming back to us in the data variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `theParsedData` variable will store the actual JSON data, fully parsed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the URL returns something successfully, we try to parse the data. Assuming
    it is a valid JSON string, it''ll be put into `theParsedData`. If it isn''t, `JSON.parse()`
    will throw an exception, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Any exceptions will be logged to the console, and we''ll end up telling our
    `completion` function that the request failed, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we call our `completion` function and tell it if the request failed
    or succeeded, and what the JSON data was (if successfully parsed).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most PhoneGap plugins aren't terribly hard to install or configure, but they
    will undoubtedly play a vital role in your app, especially if you need to use
    a feature that PhoneGap doesn't provide on its own.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we need two plugins, one to display websites within our app and
    another to share the content. For the first, we'll be using a plugin called `ChildBrowser`
    across all the platforms we support, but for the latter, we'll have to use a separate
    plugin for iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what each sharing plugin will look like when we''re done, starting
    with iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the plugins](img/9403_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android the sharing plugin will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the plugins](img/9403_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already, you should download the entire community PhoneGap plugin
    repository located at [https://github.com/phonegap/phonegap-plugins](https://github.com/phonegap/phonegap-plugins).
    This will provide you with nearly all the content necessary to use the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to support sharing on iOS, you also need to download ShareKit 2.0,
    which is available at [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit),
    or use the fork bundled with the code available for this book. It is located outside
    of the directories for each project in a directory labeled `Submodules`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to split this one up into what we have to do for each platform,
    as the steps and environments are all quite different.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin configuration for iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You wouldn't know it, but our first platform is also the hardest. In fact, it'll
    make the remaining two platforms feel a bit like child's play.
  prefs: []
  type: TYPE_NORMAL
- en: The `ChildBrowser` plugin itself is easy to install and configure, but ShareKit
    2.0 is, well, anything but, especially when used in conjunction with PhoneGap.
    The problem stems from the fact that when you compile the project with PhoneGap
    and ShareKit 2.0 together, some symbols are duplicated, and the linker throws
    out a nasty little error. Long story short, your app doesn't compile. Not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look first at the steps necessary for installing the `ChildBrowser`
    plugin, as these are far more typical of most plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the collection of plugins you downloaded and navigate to `iOS/ChildBrowser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `ChildBrowser.bundle`, `ChildBrowserCommand.h`, `ChildBrowserCommand.m`,
    `ChildBrowserViewController.h`, `ChildBrowserViewController.m`, and `ChildBrowserViewController.xib`
    into XCode to `Socializer/Plugins`, as shown in the following screenshot:![Plugin
    configuration for iOS](img/9403_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, make sure to copy the files (instead of linking to them). This
    can be done by checking the **Copy items into destination group's folder** entry,
    as shown in the following screenshot:![Plugin configuration for iOS](img/9403_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `ChildBrowser.js` to your `www/plugins/iOS` directory. You can do this
    in XCode or in Finder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the plugin to `Cordova.plist` in `Socializer/Supporting Files` in XCode.
    Find the `Plugins` row, and add a new entry of the order as seen in the following
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| `ChildBrowserCommand` | `String` | `ChildBrowserCommand` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'This can be better explained with the help of the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Plugin configuration for iOS](img/9403_02_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There, that was easy, wasn't it? Now comes the hard part, getting ShareKit 2.0
    installed and working. For that, we're going to refer to [Appendix B](apb.html
    "Appendix B. InstallingShareKit 2.0"), *Installing ShareKit 2.0* as the process
    is rather long.
  prefs: []
  type: TYPE_NORMAL
- en: 'When that''s done, we need to duplicate the plugin setup that we did for `ChildBrowser`,
    except for ShareKit, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `iOS/ShareKitPlugin` directory in your plugin repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `ShareKitPlugin.h`, `ShareKitPlugin.m`, `SHKSharer+Phonegap.h`, `SHKSharer+Phonegap.m`
    to the `Plugins` folder in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `ShareKitPlugin.js` to your `www/plugins/iOS` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify `Cordova.plist` to add this new plugin to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the **Plugins** row, and add a new entry, as in the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| `ShareKitPlugin` | `String` | `ShareKitPlugin` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'This can be better explained with the help of the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Plugin configuration for iOS](img/9403_02_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The final step is to update our `www/index.html` file to include these two
    plugins for our app. Add the following lines after the line that is loading the
    `cordova-2.2.0-ios.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Whew! We did it, we've got two plugins installed for iOS devices. Now, let's
    tackle the remaining platform. Don't faint. Android's a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin configuration for Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Android, we''ll be using two plugins: namely, `ChildBrowser` and `Share`.
    Both are located in the repository you should have already downloaded from GitHub.
    Let''s start with installing and configuring `ChildBrowser` first, using the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package (**File** | **New** | **Package**) under your project's
    `src` folder. Name it `com.phonegap.plugins.childBrowser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `Android/ChildBrowser/src/com/phonegap/plugins/childBrowser` and
    drag `ChildBrowser.java` to the newly created package in Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `res/xml` in your project and open `plugins.xml` with the text editor
    (usually this is done by a right-click and then navigating to **Open With** |
    **Text Editor**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line at the bottom of the file, just above the `</plugins>`
    ending tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to the `Android/ChildBrowser/www` folder in the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `childbrowser.js` to `assets/www/plugins/Android`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `childbrowser` folder to `assets/www` (copy the folder, not the contents,
    and you should end up with `assets/www/childbrowser` when done).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our next plugin, `Share`, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a package in Eclipse under your project's `src` directory named `com.schaul.plugins.share`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `Android/Share` in the plugin repository and copy `Share.java` to
    the package in Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line at the bottom of the `plugins.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Copy share.js` to your project''s `assets/www/plugins/Android` directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last step is to update our `www/index_Android.html` file by adding the
    following lines just below the portion that is loading the `cordova-2.2.0-android.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's it! Our plugins are correctly installed and configured for Android.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We set up the `ChildBrowser` plugin on both of our supported platforms. We set
    up ShareKit 2.0 and the `ShareKitPlugin` for iOS, and the `Share` plugin for Android.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve not actually dealt with how to use the plugins; we just installed them.
    We''ll be dealing with that as we come to the necessary steps when implementing
    our project. But there is one important detail to pay attention to: the plugin''s
    `readme` file, if available.'
  prefs: []
  type: TYPE_NORMAL
- en: This file will often indicate the installation steps necessary, or any quirks
    that you might need to watch out for. The proper use of the plugin is also usually
    detailed. Unfortunately, some plugins don't come with instructions. At that point,
    the best thing to do is to try installing it in the *normal* fashion (as we've
    done earlier for `ChildBrowser` and all the other plugins except for ShareKit)
    and see if it works.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing to remember is that PhoneGap is an ongoing project. It means
    that there are plugins that are out-of-date (and indeed, some have had to be updated
    by the author for this book) and won't work correctly with the most recent versions
    of PhoneGap. You'll need to pay attention to the plugins so that you know which
    version it supports, and if it will need to be modified to work with a newer version
    of PhoneGap. Modifications usually aren't terribly difficult, but it does involve
    getting into the native code, so you may want to ask the community for help in
    the modification. (See the end of the project for links to the community.)
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the social view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While our app has three views, the start view is so similar to the previous
    project's start view that we won't go into great detail in this project about
    how it works. You're welcome to take a look at the code in the `www/views/startView.html`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of our code is going to reside in the social view and the tweet view,
    so that's where our primary focus will be. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and create the `socialView.html` file now based on what we have discussed.
    Then we'll go over the portions you haven't seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we''re finished with this task, we should have a view that looks like
    this for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The view for Android will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with all our views to this point, we''re going to start with the HTML portion
    that describes the actual view; it is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generally, this looks very much like our previous views, except that there are
    a couple of critical details. We've added a style to the inner `div` element.
    This takes away our default `div` styling (from `www/framework/base.css`) and
    forces the height to fit to the content (instead of to the screen). This means
    that when we want to scroll, we'll have the whole content to scroll through.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first time we''ve talked about scrolling in our apps at all, actually,
    and for good reason: it''s often hard on mobile platforms. In a perfect world,
    we could just rely on `overflow:scroll` to work on all our platforms, but that
    simply doesn''t work. We can rely on native scrolling in iOS 5 and later, but
    that has its own share of problems (depending on the version of PhoneGap and various
    other WebKit gotchas), and rules out any lower platform, and of course, it doesn''t
    work on Android at any version. So for iOS and Android, we''ll have to use our
    own implementation for scrolling or use a third-party scrolling library such as
    iScroll 4\. In this case, we''re using our own implementation, which we''ll cover
    a little later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to determine how our toolbar will show its profile images using
    the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have a little bit of JavaScript that fires when the user touches
    the image, this is to load the appropriate stream for that image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define what the tweets should look like within our view. This
    is done by using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this segment of HTML, we've defined what the rest of a tweet should look
    like. We've given every `div` and `span` a class so that we can target them in
    our `style.css` file (located in `www/style`). That is mainly to keep the display
    of the tweet as separate from the content of the tweet as possible and to make
    it easy to change the look of a tweet whenever we want. Go ahead and take a look
    at the `style.css` file to get a good idea of how they will work to give our tweets
    some style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we give ourselves a namespace, in this case `socialView`. We also
    declare a few properties: `firstTime`, which will track if this is the first time
    our view is being displayed or not, and `currentStream`, which will hold the current
    visible stream from Twitter. The `lastScrollTop` property will record the position
    the user has scrolled to on our current page so we can restore it when they return
    from looking an individual tweet, and `myScroll` will hold our actual scroller.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our `initializeView()` method isn't terribly different from our previous project.
    I've highlighted a couple lines, however – note that we load our models and when
    they are complete, we call `TWITTER.loadTwitterUsers()`. We pass along a completion
    function, which we define next so that when Twitter has returned the user data
    for all five of our Twitter users, we can call it.
  prefs: []
  type: TYPE_NORMAL
- en: We've also defined our scroller. If you want to see the complete code take a
    look in `www/framework/scroller.js`, but it should suffice to say, it is a reasonably
    nice scroller that is simple to use. It doesn't beat native scrolling, but nothing
    will. You're free to replace it with any library you'd like, but for the purposes
    of this project, we've gone this route.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: One of the first things we do after obtaining the template's HTML is to check
    on our `TWITTER.users` array. This array should have been filled with all sorts
    of user data, but if Twitter has rate-limited us for some reason, it may not be.
    So we check to see if there is an error condition, and if so, we let the user
    know. Granted, it's not the best method to let a user know, but for our example
    app, it suffices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we iterate through each of the users. There should be five, but you could
    configure it for a different number and build up an HTML string that we''ll put
    into the toolbar as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next function, `loadStreamFor()` does the really hard work in this view.
    It requests a stream from Twitter and then processes it for display. The code
    snippet for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Something to note is that we are now inside the `completion` function, the function
    that will be called when the Twitter stream is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because Twitter may rate-limit us at any time, we check again for any error
    in the stream in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we're iterating through each item in the stream and building up a large
    HTML string from the template we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: One important part to notice is how we're obtaining the data of the tweet, using
    `theTweet.from_user || theTweet.user.screen_name` and such. This is to deal with
    how Twitter returns a slightly different data format when searching for a word
    or a hashtag versus the data format when returning a user's timeline. Should one
    be undefined, we'll load the other, and since we can only get one or the other,
    it's easier than building a lot of if statements to take care of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once our stream HTML is built, we assign it to the content area so that the
    user can see it. We also store the stream into the `currentStream` property so
    we can reference it later. When that's done, we scroll to the top of the page
    so that the user can see the most recent tweets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That last `100`? Well, it's actually part of the call to `TwitterStream()`.
    It's the number of items to return in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next function deals with what should happen when a user taps on a displayed
    tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This function is pretty simple. All we do is tell the tweet view what tweet
    was tapped, and then push it on to the view stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This `viewWillAppear()` method is pretty similar to the last project except
    for the middle and the last portion. In the middle we're checking if this is the
    first time the view has been displayed. If it is, we want to load a default stream
    for the user. Remember, up till now we've only loaded a stream when the user taps
    on a profile image in the toolbar. But we don't want to reload this stream every
    time our view displays; we could be coming back from the tweet view and the user
    might want to continue where they left off in the previous stream. In the final
    portion, we're checking to see if we had a previous scroll position, and if so,
    we scroll the view to that point. We have to create a delay here, since if we
    set it too early, the view will be offscreen (and won't scroll), or it will be
    onscreen, and it'll be noticeable to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two functions, `viewWillHide()` and `backButtonPressed()` present
    no new functionality, so while you do need them in your code, we won't go over
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: That's it, not terribly difficult, but it does what we need–display a list of
    tweets. Once a user taps on the tweet, they'll be taken to the tweet view to do
    more, and that's what we'll look at in the next task.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task we defined the HTML code and templates for our social view. We
    also used the Twitter-stream data to construct a Twitter stream that the end user
    can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the tweet view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our tweet view will be where the user interacts with a given tweet. They can
    open any links within the tweet using the `ChildBrowser` plugin, or they can search
    any hashtags contained within the tweet (or any mentions, too). The view also
    gives the user the opportunity to share the tweet to any of their social networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and create your own `www/tweetView.html` file based on the one we discussed.
    We'll go over the code that is new, while leaving the rest to you to review.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this next task, we should end up with a view that looks like the following
    on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, we''re not going to display the HTML for defining the layout of
    our view. You may ask why? This is because you''ve seen it several times before
    and can look it up in the code for this project. We''re going to start with the
    templates that will define the content instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is pretty similar to the template in the previous view with a couple
    of exceptions: one that we''ve made the profile image larger, and two, we''ve
    added a `div` element that lists all the *entities* in the tweet. Twitter defines
    an entity as a URL, a hashtag, or a mention of another twitter user. We''ll display
    any of these that are in a tweet so that the user can tap on them to get more
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here's our template for any entity. Notice that we've given it the class of
    `entity`, so that all our entities can have a similar appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we define what each particular entity looks like, in this case, the
    URL template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `PKUTIL.showURL()` in this template. It is a convenience method
    we've defined in `PKUTIL` to use `ChildBrowser` to show a webpage. We've done
    the work of combining how it works on each platform and put it into one function
    so that it is easy to call. We'll take a look at it a little later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This template is for a hashtag. The big difference between this and the previous
    template is that it is actually referring back to our previous view! It does this
    to tell it to load a stream for the hashtag, and then we call `popView()` to go
    back to the view. Chances are the view won't have the loaded information from
    Twitter just yet, but give it a second and it'll reload with the new stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the code for a mention is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So that defines how our tweet looks and works, let''s see how the view actually
    creates the tweet itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've defined the `setTweet()` method, which stores a given tweet into
    our `theTweet` property. Remember, this is called from the Twitter stream view
    when a tweet is tapped to send us the tweet to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method of interest is `loadTweet()`. We''ll skip the `initializeView()`
    method as it is similar to the previous view. The `loadTweet()` method is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we obtain the HTML for each template we need—and there are several!
    These are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we've gone through every URL entity that Twitter has sent us and
    added it to our entity HTML string. We'll repeat that for hashtags and for mentions,
    but the code is so similar, we won't repeat it here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once we've gone through all the entities, we handle the tweet itself. Note that
    we had to handle the entities first because we handle the substitution earlier.
    Just like with the previous view, we correctly handle if the tweet is from a search
    or from a timeline as well.
  prefs: []
  type: TYPE_NORMAL
- en: The next method of interest is the `share()` method, so we'll skip over `viewWillAppear()`,
    `viewWillHide()`, and `backButtonPressed()`. Suffice to say, the only different
    thing the `viewWIllAppear()` method does than any of the others is call the `loadTweet()`
    method to display the tweet when our view is shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `share()` method is where we call each platform''s plugin for sharing.
    Each platform has a slightly different syntax, so we have to check which platform
    we''re on and decide which plugin to call based on that. We can do so using the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For Android, we're using the `Share` plugin, and this is how we can share with
    it. Android will then display a list of services that support sharing, including
    Twitter and Facebook, if the user has them installed. The text we give it will
    be included in the message, and Android is nice enough to let us send a success
    and a failure function should we want to do something after the tweet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Our default method is for iOS, which will display an action sheet listing a
    few services, probably Twitter and Facebook, and the user can tap the button of
    the service they want to share to. Once they authenticate to the service, they
    can then send the message.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We displayed a single tweet and processed the various entities within it. We
    demonstrated loading an external site in the `ChildBrowser` plugin by using `PKUTIL.showURL()`.
    We also demonstrated how to use the various sharing plugins.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a quick look at `PKUTIL.showURL()`, the method used to display a
    `ChildBrowser` with an external site. It's a pretty simple function, but since
    it takes three different ways to show `ChildBrowser`, we packaged it up into a
    function that makes it easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: For Android, it's simple to call `ChildBrowser`. Typically this is how you call
    any plugin you want to use in PhoneGap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: WP7 is here too, since the platform supports it, and is a little more difficult.
    We have to pack the URL into an options array and then send it to the plugin to
    show.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For iOS, it's very similar to Android's method, except we call it directly instead
    of using `window.plugins.*`.
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, you've done it. You've successfully written an app that displays information
    obtained from Twitter and that lets the user share it on their own social network.
    For some platforms, it wasn't too hard to configure the plugins necessary to do
    this work, while for iOS, you probably got a bit more familiar with Xcode and
    header paths and such than you wanted. The rest was easy; adding plugins gets
    easier the more you do it, and chances are pretty good you'll need at least the
    `ChildBrowser` plugin in nearly every project you do. Thankfully, it's also an
    easy install!
  prefs: []
  type: TYPE_NORMAL
- en: 'Some resources you might find valuable are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ShareKit: [https://github.com/ShareKit/ShareKit](https://github.com/ShareKit/ShareKit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON: [http://www.json.org/](http://www.json.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twitter JSON documentation: [https://dev.twitter.com/docs/api/1](https://dev.twitter.com/docs/api/1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Phonegap plugins: [http://www.github.com/phonegap/phonegap-plugins](http://www.github.com/phonegap/phonegap-plugins)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Phonegap community: [http://groups.google.com/group/phonegap](http://groups.google.com/group/phonegap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iScroll 4: [http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a project, Socializer does what it is set out to do, but there''s actually
    so much more that you could do to it to make it truly useful. Why don''t you try
    one or more of the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Let the end user select their own initial Twitter accounts, instead of our initial
    five.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a loading graphic while the Twitter stream is loading so that the user
    knows that the app is working on something.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style any links, mentions, or hashtags in the Twitter stream to make them stand
    out more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try your hand at working with the API of any other social network you like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to add OAuth authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
