<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-138">7. <a id="_idTextAnchor171"/>Decorators</h1>
		</div>
		<div><p class="callout-heading"><a id="_idTextAnchor172"/>Overview</p>
			<p class="callout">This chapter first establishes the motivation for decorators and then describes the various decorator types available in TypeScript. We'll take a look at how decorators are used and how they are customized to fit your specific needs. We'll also cover writing your own decorators. By the end of this chapter, you will be able to use decorators to alter the behavior of your code, and use decorator factories to customize the decorators that are being used. You will also learn how to create your own decorators, to be used by your code or that of others.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor173"/>Introduction</h1>
			<p>In the previous chapters, you saw how to create types and classes and how to compose them into a proper class hierarchy using interfaces, inheritance, and composition.</p>
			<p>Using the TypeScript type system, you can create some very elegant models of the domains of your applications. However, models do not live by themselves; they are part of a larger picture – they are part of an application. And classes need to be aware that they live in a larger world, with many other parts of the system running in tandem with them, with concerns that go beyond the scope of a given class.</p>
			<p>Adding behaviors to or modifying classes to account for the preceding scenario is not always easy. And this is where decorators come to the rescue. Decorators are special declarations that can be added to class declarations, methods, and parameters.</p>
			<p>In this chapter, we'll learn how you can use a technique called <strong class="bold">decorators</strong> to transparently add complicated and common behaviors to your classes, without getting your application logic all cluttered up with additional code.</p>
			<p>Decorators are one of the features that are available and widely used in TypeScript but are not available in JavaScript. There is a proposal for decorators in JavaScript (<a href="https://github.com/tc39/proposal-decorators">https://github.com/tc39/proposal-decorators</a>), but it's still not part of the standard. The decorators that you will use in TypeScript are closely modeled to function just like the proposal.</p>
			<p>The TypeScript approach has its good and bad aspects. One good aspect is that once decorators become a standard feature in JavaScript, you can seamlessly transfer your decorating skill over to JavaScript, and the code that the TypeScript compiler (<code>tsc</code>) generates will be an even more idiomatic JavaScript. The bad thing is that until it becomes a standard feature, the proposal can and will change. That's why, by default, the usage of decorators is turned off in the compiler, and in order to use them, you need to pass in a flag, either as a command-line option or as part of your <code>tsconfig.json</code>. However, before you get into the details of how to do this, you first need to understand the concept of reflection, which will be explored in the following section.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor174"/>Reflection</h1>
			<p>The concept of decorating your code is tightly coupled with a concept called <strong class="bold">reflection</strong>. In a nutshell, reflection is the capability of a certain piece of code to examine and be introspective about itself – in a sense, to do some navel-gazing. It means that a piece of code can have access to things such as the variables, functions, and classes defined inside it. Most languages provide us with some kind of reflection API that enables us to treat the code itself as if it was data, and since TypeScript is built upon JavaScript, it inherits the JavaScript reflection capabilities.</p>
			<p>JavaScript does not have an extensive reflection API, but there is a proposal (<a href="https://tc39.es/ecma262/#sec-reflection">https://tc39.es/ecma262/#sec-reflection</a>) to add proper metadata (data about data) support to the language.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor175"/>Setting Up Compiler Options</h2>
			<p>TypeScript's decorators use the aforementioned proposed feature, and in order to use them, you have to enable the TypeScript compiler (<code>tsc</code>) accordingly. As covered in the preface, there are two ways to do this. You can either add the necessary flags on the command line when you invoke <code>tsc</code> or you can configure the necessary options inside the <code>tsconfig.json</code> file.</p>
			<p>There are two flags concerning decorators. The first one, <code>experimentalDecorators</code>, is needed to use decorators at all. If you have a file where you're using a decorator and try to compile it without specifying it, you get the following error:</p>
			<pre>tsc --target es2015 .\decorator-example.ts
decorator-example.ts:18:5 – error TS1219: 
  Experimental support for decorators is a feature 
  that is subject to change in a future release. 
  Set the 'experimentalDecorators' option in your 'tsconfig' or 
  'jsconfig' to remove this warning.</pre>
			<p>If you specify the flag, you can compile successfully:</p>
			<pre>tsc --experimentalDecorators --target es2015 
  .\decorator-example.ts</pre>
			<p>In order to avoid specifying the flags all the time, add the following flags in the <code>tsconfig.json</code> file:</p>
			<pre>{
  "compilerOptions": {
    "target": "ES2015",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
  }
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin executing the examples, exercises, and activities, we suggest that you make sure the preceding complier options have been enabled in your <code>tsconfig.json</code> file. Alternatively, you can use the file provided here: <a href="https://packt.link/hoeVy">https://packt.link/hoeVy</a>.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor176"/>Importance of Decorators</h1>
			<p>So, now you're ready to start decorating. But why would you want to do that? Let's run through a simple example that mimics the real-world scenarios you will be encountering later. Let's say that you are building a simple class that will encapsulate the score for a basketball game:</p>
			<pre>Example_Basketball.ts
1  interface Team {
2      score: number;
3      name: string;
4  }
5  
6  class BasketBallGame {
7      private team1: Team;
8      private team2: Team;
9  
10     constructor(teamName1: string, teamName2: string) {
11         this.team1 = { score: 0, name: teamName1 };
12         this.team2 = { score: 0, name: teamName2 };
13     }
14  
15     getScore() {
16         return `${this.team1.score}:${this.team2.score}`;
17     }
18 }
19 
20 const game = new BasketBallGame("LA Lakers", "Boston Celtics");
Link to the preceding example: <a href="https://packt.link/ORdNl">https://packt.link/ORdNl</a>.</pre>
			<p>Our class has two teams, each of which has a name and a numerical score. You're initializing your team in the class constructor, and you have a method that will provide the current score. However, you don't have a method that will update the score. Let's add one:</p>
			<pre>updateScore(byPoints: number, updateTeam1: boolean) {
    if (updateTeam1) {
        this.team1.score += byPoints;
    } else {
        this.team2.score += byPoints;
    }
}</pre>
			<p>This method accepts the number of points to add and a Boolean. If the Boolean is <code>true</code>, you're updating the first team's score, and if it's <code>false</code>, you're updating the second team's score. You can take your class for a spin, as here:</p>
			<pre>const game = new BasketBallGame("LA Lakers", "Boston Celtics");
game.updateScore(3, true);
game.updateScore(2, false);
game.updateScore(2, true);
game.updateScore(2, false);
game.updateScore(2, false);
game.updateScore(2, true);
game.updateScore(2, false);
console.log(game.getScore());</pre>
			<p>This code will show us that the Lakers are losing <code>7:8</code> against the Celtics (<em class="italic">Game 7 of the 2010 finals, if anyone wants to know</em>).</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor177"/>The Problem of Cross-Cutting Concerns</h2>
			<p>So far so good, and your class is fully operational – as far as its own functionalities are concerned. However, as your class will be living within a whole application, you have other concerns as well. One of those concerns is authorization – will just anyone be able to update the score? Of course not, as the common use case is that you have a single person that is allowed to update the score and multiple people, maybe millions, that just watch the score change.</p>
			<p>Let's add that concern to the code using a hypothetical function, <code>isAuthorized</code>, that will check whether the current user is actually authorized to change the score. You will call this function and if it returns <code>true</code>, we'll continue with the regular logic of the method. If it returns <code>false</code>, then we'll just issue an appropriate message. The code will look like this:</p>
			<pre>updateScore(byPoints: number, updateTeam1: boolean) {
    if (isAuthorized()) {
        if (updateTeam1) {
            this.team1.score += byPoints;
        } else {
            this.team2.score += byPoints;
        }
    } else {
        console.log("You're not authorized to change the score");
    }
}</pre>
			<p>Again, this will work nicely, albeit increasing the code size of your method from five lines of code to nine lines of code and adding some complexity. And, to be honest, the added lines are not really relevant to counting the score, but they had to be added in order to support authorization.</p>
			<p>So, is that it? Of course not. Even if you know that somebody is authorized, it does not mean that your operator will be able to update the score whenever they want. The auditor will need detailed information of when and with what parameters the <code>updateScore</code> method was called. No problem, let's add that as well using a hypothetical function called <code>audit</code>. And you'll also need to add some verification for whether the <code>byPoints</code> parameter is a legal value (in basketball, you can only have 1-, 2-, or 3-point increments). And you could add some code that logs the performance of the method in order to have a trace of how long it takes to execute. So, your nice, clear, five-line method will become a 17-line monstrosity:</p>
			<pre>updateScore(byPoints: number, updateTeam1: boolean) {
    audit("updateScore", byPoints, updateTeam1);
    const start = Date.now();
    if (isAuthorized()) {
        if (validatePoints(byPoints)) {
            if (updateTeam1) {
                this.team1.score += byPoints;
            } else {
                this.team2.score += byPoints;
            }
        } else {
            console.log(`Invalid point value ${byPoints}`);
        }
    } else {
        console.log("You're not authorized to change the score");
    }
    const end = Date.now();
    logDuration("updateScore", start, end);
}</pre>
			<p>And inside all that complexity, you still have your simple and clear piece of logic that if the Boolean is <code>true</code>, will update the Lakers' score, and if it's <code>false</code>, will update the Celtics' score.</p>
			<p>The important part here is that the added complexity does not come from your specific business model – the basketball game still works the same. All the added functionalities stem from the system in which the class lives. The basketball game, by itself, does not need authorization, or performance metrics, or auditing. But the scoreboard application does need all of those and more.</p>
			<p>Note that all the added logic is already encapsulated within methods (<code>audit</code>, <code>isAuthorized</code>, <code>logDuration</code>), and the code that actually performs all the aforementioned operations is outside your method. The code you inserted into your function does the bare minimum – yet it still complicated your code.</p>
			<p>In addition, authorization, performance metrics, and auditing will be needed in many places within your application, and in none of those places will that code be instrumental to the actual working of the code that is being authorized or measured or audited.</p>
			<h3 id="_idParaDest-144"><a id="_idTextAnchor178"/>The Solution</h3>
			<p>Let's take a better look at one of the concerns from the previous section, the performance metric, that is, the duration measurement. This is something that is very important to an application, and to add it to any specific method, you need a few lines of code at the beginning and a few lines at the end of the method:</p>
			<pre>const start = Date.now();
// actual code of the method
const end = Date.now();
logDuration("updateScore", start, end);</pre>
			<p>We'll need to add this to each and every method you need to measure. It's very repetitive code, and each time you write it in, you're opening the possibility of doing it slightly wrong. Moreover, if you need to change it, that is, by adding a parameter to the <code>logDuration</code> method, you'll need to change hundreds, if not thousands, of call sites. </p>
			<p>In order to avoid that kind of risk, what you can do is to wrap the actual code of the method inside some other function that will still call it. That function might look something like this:</p>
			<pre>function wrapWithDuration(method: Function) {
    const result = {
        [method.name]: function (this: any, ...args: any[]) {
            const start = Date.now();
            const result = method.apply(this, args);
            const end = Date.now();
            logDuration(method.name, start, end);
            return result;
        },
    };
    return result[method.name];
}</pre>
			<p>The <code>wrapWithDuration</code> function (whose details you can ignore for now) will take a method and return a function that has the following:</p>
			<ul>
				<li>The same <code>this</code> reference</li>
				<li>The same method name</li>
				<li>The same signature (parameters and return type)</li>
				<li>All the behavior that the original method has</li>
				<li>Extended behavior as it will measure the duration of the actual method</li>
			</ul>
			<p>Since it will actually call the original method, when looking from outside, the new function is totally indistinguishable from the original. You have added some behavior while keeping everything that already was. Now, you can replace the original method with the new improved one.</p>
			<p>What you will get with this approach is this: the original method won't know or care about the cross-cutting concerns of the application, instead focusing on its own business logic – the application can "upgrade" the method at runtime with one that has all the necessary business logic as well as all the required additions.</p>
			<p>This kind of transparent "upgrade" is often termed a <strong class="bold">decoration</strong>, and the method that does the decorating is called a <strong class="bold">decorator</strong> method.</p>
			<p>What has been shown here is just one form that a decoration can take. There can be as many solutions as there are developers, and none of them will be simple and straightforward. Some standards should be put in place, and the TypeScript design team decided to use the proposed JavaScript syntax.</p>
			<p>The rest of the chapter will use that syntax, and you can ignore the solution given here.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor179"/>Decorators and Decorator Factories</h1>
			<p>As we've seen so far, decorators are just special wrapping functions that add behavior to your regular methods, classes, and properties. What's special about them is how they can be used in TypeScript. TypeScript supports the following decorator types:</p>
			<ul>
				<li><strong class="bold">Class decorators</strong>: These are attached to a class declaration.</li>
				<li><strong class="bold">Method decorators</strong>: These are attached to a method declaration.</li>
				<li><strong class="bold">Accessor decorators</strong>: These are attached to a declaration of an accessor of a property.</li>
				<li><strong class="bold">Property decorators</strong>: These are attached to a property itself.</li>
				<li><strong class="bold">Parameter decorators</strong>: These are attached to a single parameter in a method declaration.</li>
			</ul>
			<p>And consequently, there are five different places where you can use decorators, so that means that there are five different kinds of special functions that can be used to decorate your code. All of them are shown in the following example:</p>
			<pre>@ClassDecorator
class SampleClass {
    @PropertyDecorator
    public sampleProperty:number = 0;
    private _sampleField: number = 0;
    @AccessorDecorator
    public get sampleField() { return this._sampleField; }
    @MethodDecorator
    public sampleMethod(@ParameterDecorator paramName: string) {}
}</pre>
			<p>The sample decorators are functions that are defined as follows:</p>
			<pre>function ClassDecorator (constructor: Function) {}
function AccessorDecorator (target: any, propertyName: string, descriptor: PropertyDescriptor) {}
function MethodDecorator (target: any, propertyName: string, descriptor: PropertyDescriptor) {}
function PropertyDecorator (target: any, propertyName: string) {}
function ParameterDecorator (target: any, propertyName: string, parameterIndex: number) {}</pre>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor180"/>Decorator Syntax</h2>
			<p>The syntax for adding a decorator to an item is that you have to use the special symbol <code>@</code> followed by the name of the decorators. The decorator is placed before the code that it decorates, so in the preceding example, you have performed the following decorations:</p>
			<ul>
				<li><code>@ClassDecorator</code> is immediately before the <code>SampleClass</code> class and is a class decorator.</li>
				<li><code>@PropertyDecorator</code> is immediately before the <code>public sampleProperty</code> and is a property decorator.</li>
				<li><code>@AccessorDecorator</code> is immediately before the <code>public get sampleField()</code> and is a <code>get</code> accessor decorator.</li>
				<li><code>@MethodDecorator</code> is immediately before the <code>public sampleMethod()</code> and is a method decorator.</li>
				<li><code>@ParameterDecorator</code> is immediately before <code>paramName: string</code> and is a parameter decorator.</li>
			</ul>
			<p>While the decorators themselves are regular functions, it's conventional that the names use <code>PascalCase</code> instead of <code>lowerCamelCase</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on <code>PascalCase</code>  and <code>lowerCamelCase</code>, visit <a href="https://techterms.com/definition/camelcase">https://techterms.com/definition/camelcase</a> and <a href="https://techterms.com/definition/pascalcase">https://techterms.com/definition/pascalcase</a>.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor181"/>Decorator Factories</h2>
			<p>You can see that you did not specify any parameters for the set of sample decorators in the previous section, yet the decorator function takes between one and three parameters. Those parameters are handled by TypeScript itself and are provided automatically when your code runs. This means that there is no way to configure your decorators directly, for example, by passing additional parameters.</p>
			<p>Fortunately, you can use a construct called <code>@</code> symbol specifying a decorator, it will evaluate the expression that follows. So, instead of providing the name of a function that fits the special decorator requirements, you can provide an expression that will evaluate to such a function. In other words, decorator factories are simply higher-order functions that will return a decorator function.</p>
			<p>For example, let's create a simple function that will take a message as a parameter and log a message to the console. The return value of that function, whose input parameters do not conform to the class decorator signature, will be another function, whose input parameters do conform to the class decorator signature. The resulting function will also simply log the message to the console as well. Consider the following code:</p>
			<pre>Example_Decorator_Factory.ts
1 function ClassDecoratorFactory(message: string) {
2     console.log(`${message} inside factory`);
3     return function (constructor: Function) {
4       console.log(`${message} inside decorator`);
5     };
6 }
Link to the preceding example: <a href="https://packt.link/M2Ixp">https://packt.link/M2Ixp</a>.</pre>
			<p>In essence, the <code>ClassDecoratorFactory</code> function is not a decorator, but its return value is. This means that you cannot use <code>ClassDecoratorFactory</code> as a decorator itself, but if you call it, for example, <code>ClassDecoratorFactory("Hi")</code>, that value will indeed be a decorator. You can use that to decorate a couple of classes using this syntax. The following example will help you understand this much better:</p>
			<pre>@ClassDecoratorFactory("Hi")
class DecoratedOne {}
@ClassDecoratorFactory("Hello")
class DecoratedTwo {}</pre>
			<p>Here, instead of using an expression such as <code>@ClassDecorator</code> as before, you use <code>@ClassDecoratorFactory("hi")</code> or <code>@ClassDecoratorFactory("hello")</code>. Since the result of the execution of the <code>ClassDecoratorFactory</code> function is a class decorator, this is operational, and the decorators successfully decorate the code. You will see the following output when you run your code:</p>
			<pre>Hi inside factory
Hi inside decorator
Hello inside factory
Hello inside decorator</pre>
			<p>Note that most decorators that you will use and make will in essence be decorator factories, as it's extremely useful to add parameters when decorating. Most sources and even some documentation will not differentiate between the terms.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor182"/>Class Decorators</h1>
			<p>A class decorator is a decorator function that is applied to the whole class. It can be used to observe, change, or replace wholesale a class definition. When a class decorator is called, it receives a single parameter – the constructor function of the calling class.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor183"/>Property Injection</h2>
			<p>Property injection is one of the common scenarios that class decorations are used for. For example, let's say you're building a system that will model a school. You will have a class called <code>Teacher</code> that will have the properties and model the behavior of a teacher. The constructor for this class will take two parameters, an <code>id</code> number of the teacher, and the <code>name</code> of the teacher. This is how the class will look:</p>
			<pre>class Teacher {
    constructor (public id: number, public name: string) {}
    // other teacher specific code
}</pre>
			<p>Let's say we build the system and it's up and running. Everything is great, but after a while, it's time to update it.</p>
			<p>We want to implement an access control system using tokens. Since the new system is not related to the teaching process, it is much better to add it without changing the code of the class itself, so you can use a decorator for this, and your decorator can inject an extra Boolean property to the prototype of the <code>Teacher</code> class. The <code>Teacher</code> class can be changed in the following way:</p>
			<pre>Example_PropertyInjection.ts
1 @Token
2 class Teacher {
3     // old teacher specific code
4 }</pre>
			<p>The <code>Token</code> decorator can be defined with the following:</p>
			<pre>5 function Token (constructor: Function) {
6     constructor.prototype.token = true;
7 }</pre>
			<p>Now, consider the following code, which creates instances of the class and prints a message:</p>
			<pre>8 const teacher = new Teacher(1, "John Smith");
9 console.log("Does the teacher have a token? ",teacher["token"]);</pre>
			<p>Running all this code will give the following result on the console:</p>
			<pre>Does the teacher have a token? true
Link to the preceding example: <a href="https://packt.link/asjvA">https://packt.link/asjvA</a>.</pre>
			<p>In the injection scenario, you use the provided <code>constructor</code> parameter but do not return anything from your function. In this case, the class continues working as it did before. Usually, we'll be using the prototype of the constructor to add fields and properties to the object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For all exercises and activities in this chapter, before executing the code file, you need to install all dependencies using <code>npm i</code> in the target directory. Then, you can execute the file by running <code>npx ts-node 'filename'</code> in the target directory. </p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor184"/>Exercise 7.01: Creating a Simple Class Decorator Factory</h2>
			<p>In this exercise, you will be creating a simple decorator factory for the <code>Token</code> decorator. Starting from the <code>Teacher</code> class code, we'll create a class called <code>Student</code> that will need to be decorated using the <code>Token</code> decorator. We'll extend the decorator to take a parameter, and decorate both classes using the created decorator factory. </p>
			<p>The following steps will help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/UpdO9">https://packt.link/UpdO9</a>. This repository contains two files: <code>school-token.start.ts</code> and <code>school-token.end.ts</code>. The former contains the code up to <em class="italic">step 6</em> of this exercise, and the latter contains the final code of the exercise.</p>
			<ol>
				<li>Open Visual Studio Code, create a new file in a new directory (<code>Exercise01</code>), and save it as <code>school-token.ts</code>.</li>
				<li>Enter the following code in <code>school-token.ts</code>:<pre>@Token
class Teacher {
    constructor (public id: number, public name: string) {}
    // teacher specific code
}
function Token (constructor: Function) {
    constructor.prototype.token = true;
}
/////////////////////////
const teacher = new Teacher(1, "John Smith");
console.log("Does the teacher have a token? ",teacher["token"]);</pre></li>
				<li>Execute the code, and notice that it outputs <code>true</code> to the console.</li>
				<li>Add a <code>Student</code> class at the end of the file:<pre>class Student {
    constructor (public id: number, public name: string) {}
    // student specific code
}</pre></li>
				<li>Add code that creates a student and tries to print its <code>token</code> property:<pre>const student = new Student(101, "John Bender");
console.log("Does the student have a token? ",student["token"]);</pre></li>
				<li>Execute the code, and notice that it outputs <code>true</code> and <code>undefined</code> to the console.</li>
				<li>Add the <code>Token</code> decorator to the <code>Student</code> class:<pre><strong class="bold">@Token</strong>
class Student {//… </pre></li>
				<li>Execute the code, and notice that it outputs <code>true</code> twice to the console.</li>
				<li>Change the <code>Token</code> function to a factory function that takes a Boolean parameter:<pre>function Token(hasToken: boolean) {
    return function (constructor: Function) {
        constructor.prototype.token = hasToken;
    }
}</pre></li>
				<li>Modify the <code>Teacher</code> class <code>Token</code> decorator to have a <code>true</code> Boolean parameter:<pre><strong class="bold">@Token(true)</strong>
class Teacher {//…</pre></li>
				<li>Modify the <code>Student</code> class <code>Token</code> decorator to have a <code>false</code> Boolean parameter:<pre><strong class="bold">@Token(false)</strong>
class Student {//…</pre></li>
				<li>Execute the code by running <code>npx ts-node</code> <code>school-token.ts</code> on the console, and notice that it outputs <code>true</code> and <code>false</code> to the console as shown:<pre>Does the teacher have a token?  true
Does the student have a token?  false</pre></li>
			</ol>
			<p>In this exercise, you saw how to add a class decorator that adds a property to a decorated class. You then changed the decorator to use a factory and added two different parameters for two decorated classes. At the end, you verified that the injected properties exist on the decorated classes via the prototype chain and that they have the values you specified.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor185"/>Constructor Extension</h2>
			<p>Using property injection enabled you to add behaviors and data to the objects you decorate using their prototypes. That is OK, but sometimes you might want to add data to the constructed objects themselves. You can accomplish this with inheritance, but you can also wrap the inheritance with a decorator.</p>
			<p>If you return a function from the decorator, that function will be used as a replacement constructor for the class. While this gives you the superpower to change the class completely, the main goal of this approach is to enable you to augment the class with some new behaviors or data, so let's use automatic inheritance to add properties to the class. A decorator that will add the <code>token</code> property not on the prototype but on the constructed objects themselves would look like this:</p>
			<pre>type Constructable = {new(...args: any[]):{}};
function Token(hasToken: boolean) {
    return function &lt;T extends Constructable&gt;(constructor: T) {
        return class extends constructor {
            token: boolean = hasToken;
        }
    }
}</pre>
			<p>The syntax for doing that looks a bit strange at first, as you are using a generic parameter to make sure that the class you return from your decorator will still be compatible with the constructor that was passed as a parameter. Aside from the syntax, the important part to remember is that the code <code>token: boolean = hasToken;</code> will be executed in addition to the regular constructor.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor186"/>Exercise 7.02: Using a Constructor Extension Decorator</h2>
			<p>In this exercise, you will be creating a constructor extension decorator factory for the <code>Token</code> decorator. Starting from the <code>Teacher</code> class code, we'll add a token factory called <code>Token</code> that will augment the class by adding a <code>token</code> Boolean property. We'll create an object of the provided class and verify that the object indeed has its own <code>token</code> property. The following steps will help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/DhVfC">https://packt.link/DhVfC</a>. This repository contains two files: <code>school-token.start.ts</code> and <code>school-token.end.ts</code>. The former contains the code up to <em class="italic">step 3</em> of this exercise, and the latter contains the final code of the exercise.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise02</code>), and save it as <code>school-token.ts</code>.</li>
				<li>Enter the following code in <code>school-token.ts</code>:<pre>class Teacher {
    constructor (public id: number, public name: string) {}
    // teacher specific code
}
/////////////////////////
const teacher = new Teacher(1, "John Smith");
console.log("Do you have a token:", teacher["token"]);
console.log("Do you have a token property: ", teacher.hasOwnProperty("token"));</pre></li>
				<li>Execute the code, and notice that it outputs <code>undefined</code> and <code>false</code> to the console:<pre><a id="_idTextAnchor187"/>Do we have a token: undefined
Do we have a token property:  false</pre></li>
				<li>Add a <code>Token</code> function at the end of the file:<pre>type Constructable = {new(...args: any[]):{}};
function Token(hasToken: boolean) {
    return function &lt;T extends Constructable&gt;(constructor: T) {
        return class extends constructor {
            token: boolean = hasToken;
        }
    }
}</pre></li>
				<li>Decorate the <code>Teacher</code> class using the <code>Token</code> decorator factory:<pre>@Token(true)
class Teacher {</pre></li>
				<li>Execute the code, and notice that it outputs <code>true</code> twice to the console:<pre>Do we have a token: true
Do we have a token property:  true</pre></li>
			</ol>
			<p>In this exercise, you saw how to change the provided class constructor to run custom code while instantiating an object. You used that to inject a property on the constructed object itself, and then you verified that the injected properties exist on objects of the decorated class and that they have the value you specified.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor188"/>Constructor Wrapping</h2>
			<p>Another common scenario for class decorators is the need to just run some code when an instance of a class is being created, for example, to add some logging when an instance of a class is created. You do not need or want to change the class behavior in any way, but you do want to be able to somehow piggyback on the process. This means that you need to execute some code whenever a class constructor is being run – you don't need to change the existing constructor.</p>
			<p>In this case, the solution is to have the decorator function return a new constructor that executes the new code needed by the decorator itself as well as the original constructor. For example, if you want to write some text to the console each time you instantiate a decorated class, you can use this decorator:</p>
			<pre>Example_ConstructorWrapping.ts
1  type Constructable = { new (...args: any[]): {} };
2  
3  function WrapConstructor(message: string) {
4      return function &lt;T extends Constructable&gt;(constructor: T) {
5          const wrappedConstructor: any = function (...args: any[]) {
6              console.log(`Decorating ${message}`);
7              const result = new constructor(...args);
8              console.log(`Decorated ${message}`);
9              return result;
10         };
11         wrappedConstructor.prototype = constructor.prototype;
12         return wrappedConstructor;
13    };
14  }
Link to the preceding example: <a href="https://packt.link/kgAme">https://packt.link/kgAme</a>.</pre>
			<p>This decorator factory will generate a decorator using a provided message. Since you're returning a new constructor, you have to use a generic parameter to make sure that the constructor you return from your decorator will still be compatible with the constructor that was passed as a parameter. You can create a new <code>wrappedConstructor</code> function within which you can both call custom code (the <code>Decorating</code> and <code>Decorated</code> messages) and actually create the object by calling <code>new</code> on the original constructor, passing in the original arguments.</p>
			<p>You should note the following here: it's possible to add custom code both pre- and post-creation of the object. In the preceding example, the <code>Decorating</code> message will be printed to the console before the object is created, while the <code>Decorated</code> message will be printed to the console after the creation is finished.</p>
			<p>Another very important thing is that this kind of wrapping breaks the prototype chain of the original object. If the object you decorate thus uses any properties or methods that were available through the prototype chain, they would be missing, changing the behavior of the decorated class. Since that is exactly the opposite of what you wanted to achieve with constructor wrapping, you need to reset the chain. That is done by setting the <code>prototype</code> property of the newly created wrapper function to the prototype of the original constructor.</p>
			<p>So, let's use a decorator on a client class, like this:</p>
			<pre>@WrapConstructor("decorator")
class Teacher {
    constructor(public id: number, public name: string) {
        console.log("Constructing a teacher class instance");
    }
}</pre>
			<p>Next, you can create an object of the <code>Teacher</code> class: </p>
			<pre>const teacher = new Teacher(1, "John");</pre>
			<p>When you run the file, you will see the following written to the console:</p>
			<pre>Decorating decorator
Constructing a teacher class instance
Decorated decorator</pre>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor189"/>Exercise 7.03: Creating a Logging Decorator for a Class</h2>
			<p>In this exercise, you'll be creating a constructor wrapping decorator factory for the <code>LogClass</code> decorator. Starting from the <code>Teacher</code> class code, you'll add a decorator factory called <code>LogClass</code> that will wrap the class constructor with some logging code. You'll create an object of the provided class and verify that the logging methods are actually called. The following steps will help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options section.</em> The code file for this exercise can also be downloaded from <a href="https://packt.link/vBLMg">https://packt.link/vBLMg</a>.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise03</code>), and save it as <code>teacher-logging.ts</code>.</li>
				<li>Enter the following code in <code>teacher-logging.ts</code>:<pre>class Teacher {
    constructor(public id: number, public name: string) {
        console.log("Constructing a teacher");
    }
}
/////////////////////////
const teacher = new Teacher(1, "John Smith");</pre></li>
				<li>Execute the code, and notice that it outputs <code>Constructing a teacher</code> to the console.</li>
				<li>Next, create the decorator. First, you need to add the <code>Constructable</code> type definition:<pre>type Constructable = { new (...args: any[]): {} };</pre></li>
				<li>Now, add a definition of your decorator factory:<pre>function LogClass(message: string) {
    return function &lt;T extends Constructable&gt;(constructor: T) {
        return constructor;
    };
}</pre><p>In the preceding code, the constructor takes in a string parameter and returns a decorator function. The decorator function itself will initially just return the original, unchanged constructor of the decorated class.</p></li>
				<li>Decorate the <code>Teacher</code> class using the <code>LogClass</code> decorator with an appropriate message parameter:<pre>@LogClass("Teacher decorator")
class Teacher {
    constructor(public id: number, public name: string) {
        console.log("Constructing a teacher");
    }
}</pre></li>
				<li>Execute the code, and notice that there are no changes to the behavior.</li>
				<li>Now, add a logger object to your application:<pre>const logger = {
    info: (message: string) =&gt; {
        console.log(`[INFO]: ${message}`);
    },
};</pre><p>In actual production-grade code implementation, you might log to a database, a file, a third-party service, and so on. In the preceding step, you are simply logging to the console.</p></li>
				<li>Next, use the <code>logger</code> object to add a wrapping constructor to your decorator:<pre>    return function &lt;T extends Constructable&gt;(constructor: T) {
        const loggingConstructor: any = function(...args: any[]){
            logger.info(message);
            return new constructor(...args);
        }
        loggingConstructor.prototype = constructor.prototype;
        return loggingConstructor;
    };</pre></li>
				<li>Execute the code and verify that you get a logging message to the console:<pre>[INFO]: Teacher decorator
Constructing a teacher</pre></li>
				<li>Construct a few more objects and verify that the constructor runs each time an object is created:<pre>for (let index = 0; index &lt; 10; index++) {
    const teacher = new Teacher(index +1, "LouAnne Johnson");
}</pre><p>You'll see the following output when you execute the file:</p><pre>[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher
[INFO]: Teacher decorator
Constructing a teacher</pre></li>
			</ol>
			<p>In this exercise, you saw how to wrap the provided class constructor so that it can run custom code, but without changing the construction of the objects. Through wrapping, you added logging capabilities to a class that did not have any. You constructed objects of that class and verified that the logging functionality was operational.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor190"/>Method and Accessor Decorators</h1>
			<p>A method decorator is a decorator function that is applied to a single method of a class. In a method decorator, you can observe, modify, or outright replace a method definition with one provided by the decorator. When a method decorator is called, it receives three parameters: <code>target</code>, <code>propertyKey</code>, and <code>descriptor</code>:</p>
			<ul>
				<li><code>target</code>: Since methods can be both instance methods (defined on instances of the class) and static methods (defined on the class itself), <code>target</code> can be two different things. For instance methods, it's the prototype of the class. For static methods, it's the constructor function of the class. Usually, you type this parameter as <code>any</code>.</li>
				<li><code>propertyKey</code>: This is the name of the method you're decorating.</li>
				<li><code>descriptor</code>: This is the property descriptor of the method you're decorating. The <code>PropertyDescriptor</code> interface is defined with this:<pre>interface PropertyDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    value?: any;
    writable?: boolean;
    get?(): any;
    set?(v: any): void;
}</pre></li>
			</ul>
			<p>This interface defines the value of an object property, as well as the property's properties (whether the property is configurable, enumerable, and writable). We'll also be using a typed version of this interface, <code>TypedPropertyDescriptor</code>, which is defined as shown:</p>
			<pre>interface TypedPropertyDescriptor&lt;T&gt; {
    enumerable?: boolean;
    configurable?: boolean;
    writable?: boolean;
    value?: T;
    get?: () =&gt; T;
    set?: (value: T) =&gt; void;
}</pre>
			<p>Note that, in JavaScript, and subsequently TypeScript, property accessors are just special methods that manage access to a property. Everything that is applicable to decorating methods is also applicable to decorating accessors. Any accessor specifics will be covered separately.</p>
			<p>If you set up a decorator on a method, we'll be getting the <code>PropertyDescriptor</code> instance of the method itself, and the <code>value</code> property of the descriptor will give us access to its body. If you set up a decorator on an accessor, we'll be getting the <code>PropertyDescriptor</code> instance of the corresponding property, with its <code>get</code> and <code>set</code> properties respectively set to the getter and setter accessors. This means that if you're decorating property accessors, you don't have to separately decorate the getter and the setter, as any decoration of one is a decoration on the other. In fact, TypeScript will issue the following error if you do so:</p>
			<pre>TS1207: Decorators cannot be applied to multiple get/set accessors of the same name.</pre>
			<p>The method decorators do not have to return a value, as most of the time you can do the desired actions by modifying the property descriptor. If you do return a value, however, that value will replace the originally provided property descriptor.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor191"/>Decorators on Instance Functions</h2>
			<p>As described in the preceding section, any function that takes the <code>target</code>, <code>propertyKey</code>, and <code>descriptor</code> parameters can be used to decorate methods and property accessors. So, let's have a function that will simply log the <code>target</code>, <code>propertyKey</code>, and <code>descriptor</code> parameters to the console:</p>
			<pre>Example_Decorators_Instance_Functions.ts
1 function DecorateMethod(target: any, propertyName: string,
2 descriptor: PropertyDescriptor) {
3     console.log("Target is:", target);
4     console.log("Property name is:", propertyName);
5     console.log("Descriptor is:", descriptor);
6 }
Link to the preceding example: <a href="https://packt.link/gle5U">https://packt.link/gle5U</a>.</pre>
			<p>You can use this function to decorate a class' methods. This is an extremely simple decorator, but you can use it to investigate the usage of method decorators. </p>
			<p>Let's start with a simple class:</p>
			<pre>class Teacher {
    constructor (public name: string){}
    private _title: string = "";
    public get title() { 
        return this._title;
    }
    
    public set title(value: string) {
        this._title = value;
    }
    public teach() {
        console.log(`${this.name} is teaching`)
    }
}</pre>
			<p>The class has a constructor, a method called <code>teach</code>, and a <code>title</code> property with a defined getter and setter. The accessors simply pass through control to the <code>_title</code> private field. You can add the decorator to the <code>teach</code> methods using the following code:</p>
			<pre>    @DecorateMethod
    public teach() {
        // ....</pre>
			<p>When you run your code (no need to instantiate the class), you'll get the following output on the console:</p>
			<pre>    Target is: {}
    Property name is: teach
    Descriptor is: {
        value: [Function: teach],
        writable: true,
        enumerable: false,
        configurable: true
    }</pre>
			<p>Consider the following snippets in which you apply the decorator to the setter or getter (either one will work fine, but not both):</p>
			<pre>    @DecorateMethod
    public get title() { 
        // ....</pre>
			<p>Or:</p>
			<pre>    @DecorateMethod
    public set title(value: string) {
        // ....</pre>
			<p>You will get the following output when you run the code using either of the preceding suggestions:</p>
			<pre>    Target is: {}
    Property name is: title
    Descriptor is: {
        get: [Function: get title],
        set: [Function: set title],
        enumerable: false,
        configurable: true
    }</pre>
			<p>Note that you cannot add a method decorator on the constructor itself, as you will get an error:</p>
			<pre> TS1206: Decorators are not valid here.</pre>
			<p>If you need to change the behavior of the constructor, you should use class decorators.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor192"/>Exercise 7.04: Creating a Decorator That Marks a Function Enumerable</h2>
			<p>In this exercise, you will create a decorator that will be able to change the <code>enumerable</code> state of the methods and accessors that it decorates. You will use this decorator to set the <code>enumerable</code> state of some functions in a class that you'll write, and finally, you'll verify that when you enumerate the properties of the object instance, you get the modified methods as well.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/1nAff">https://packt.link/1nAff</a>. This repository contains two files: <code>teacher-enumerating.start.ts</code> and <code>teacher-enumerating.end.ts</code>. The former contains the code up to <em class="italic">step 5</em> of this exercise, and the  latter contains the final code of the exercise.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise04</code>), and save it as <code>teacher-enumerating.ts</code>.</li>
				<li>Enter the following code in <code>teacher-enumerating.ts</code>:<pre>class Teacher {
    constructor (public name: string){}
    private _title: string = "";
    public get title() { 
        return this._title;
    }
    
    public set title(value: string) {
        this._title = value;
    }
    public teach() {
        console.log(`${this.name} is teaching`)
    }
}</pre></li>
				<li>Write code that will instantiate an object of this class:<pre>const teacher = new Teacher("John Smith");</pre></li>
				<li>Write code that will enumerate all the keys in the created object:<pre>for (const key in teacher) {
    console.log(key);
}</pre></li>
				<li>Execute the file and verify that the only keys that are displayed on the console are <code>name</code> and <code>_title</code>.</li>
				<li>Add a decorator factory that takes a Boolean parameter and generates a method decorator that will set the <code>enumerable</code> status to the provided parameter:<pre>function Enumerable(value: boolean) {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
    }
};</pre></li>
				<li>Use the decorator to decorate the <code>title</code> getter or setter accessors and the <code>teach</code> method:<pre>    @Enumerable(true)
    public get title() { 
        return this._title;
    }
    
    public set title(value: string) {
        this._title = value;
    }
    @Enumerable(true)
    public teach() {
        console.log(`${this.name} is teaching`)
    }</pre></li>
				<li>Rerun the code and verify that the <code>title</code> and <code>teach</code> properties are being enumerated:<pre>name
_title
title
teach</pre></li>
			</ol>
			<p>In this exercise, you saw how to add a create a method decorator factory and how to apply it to an instance method or an instance property accessor. You learned how to make a property enumerable, and you used that knowledge to set the <code>enumerable</code> state of the functions of a class. Finally, you enumerated all the properties of a class.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor193"/>Decorators on Static Functions</h2>
			<p>Just like with instance methods, decorators can be used with static methods as well. You add a static method to your <code>Teacher</code> class like this:</p>
			<pre><a id="_idTextAnchor194"/>Example_Decorator_StaticFunctions.ts
1 class Teacher {
2     //.....
3 
4     public static showUsage() {
5        console.log("This is the Teacher class")
6    }
7    //.....
Link to the preceding example <a href="https://packt.link/Ckuct">https://packt.link/Ckuct</a>.</pre>
			<p>We are allowed to use method decorators on the static methods as well. So, you can add the <code>DecorateMethod</code> decorator using the following code:</p>
			<pre>    @DecorateMethod
    public static showUsage() {
        //......</pre>
			<p>When you run the code, you will get output similar to this:</p>
			<pre>Target is: [Function: Teacher]
Property name is: showUsage
Descriptor is: {
  value: [Function: showUsage],
  writable: true,
  enumerable: false,
  configurable: true
}</pre>
			<p>The principal difference with the instance methods is the <code>target</code> parameter. Instance methods and accessors are generated on the class prototype, and consequently, when using a method/accessor decorator, you receive the class prototype as a <code>target</code> parameter. Static methods and accessors are generated on the class variable itself, and consequently, when using a method/accessor decorator, you receive the class variable in the guise of the constructor function as a <code>target</code> parameter.</p>
			<p>Note that this is the exact same object that you're getting as a class decorator parameter. You can even use it in much the same way. However, in method decorators, the focus should be on the actual property we've decorated. It is considered a bad practice to manipulate the constructor inside a non-class decorator.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor195"/>Method Wrapping Decorators</h2>
			<p>The most common usage of method decorators is to use it to wrap the original method, adding some custom cross-cutting code. Examples would be adding some general error handling or adding automatic logging capabilities.</p>
			<p>In order to do that, you need to change the function that is being called. You can do that using the <code>value</code> property of method property descriptors, and by using the <code>get</code> and <code>set</code> properties of the property accessor descriptors.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor196"/>Exercise 7.05: Creating a Logging Decorator for a Method</h2>
			<p>In this exercise, you'll be creating a decorator that will log each time a decorated method or accessor is called. You will use this decorator to add logging to the <code>Teacher</code> class and you'll verify that each time you use the decorated methods and property accessors, you get an appropriate log entry:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/rmEZi">https://packt.link/rmEZi</a>.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise05</code>), and save it as <code>teacher-logging.ts</code>.</li>
				<li>Enter the following code in <code>teacher-logging.ts</code>:<pre>class Teacher {
    constructor (public name: string){}
    private _title: string = "";
    public get title() { 
        return this._title;
    }
    
    public set title(value: string) {
        this._title = value;
    }
    public teach() {
        console.log(`${this.name} is teaching`)
    }
}
/////////////////
const teacher = new Teacher("John Smith");
teacher.teach(); // we're invoking the teach method
teacher.title = "Mr." // we're invoking the title setter
console.log(`${teacher.title} ${teacher.name}`); // we're invoking the title getter</pre></li>
				<li>Execute the code, and notice that it outputs <code>John Smith is teaching</code> and <code>Mr. John Smith</code> to the console.</li>
				<li>Create a method decorator factory that can wrap any method, getter or setter, with a logging statement. It will take a string parameter and return a decorator function. Initially, you won't make any changes to the property descriptor:<pre>function LogMethod(message: string) {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    };
}</pre></li>
				<li>Decorate the <code>teach</code> method and the <code>title</code> get accessor using the <code>LogMethod</code> decorator with an appropriate message parameter:<pre>    @LogMethod("Title property")
    public get title() { 
    //...    
    @LogMethod("Teach method")
    public teach() {
    //...    </pre></li>
				<li>Execute the code, and notice that there are no changes to the behavior.</li>
				<li>Now, add a <code>logger</code> object to your application:<pre>const logger = {
    info: (message: string) =&gt; {
        console.log(`[INFO]: ${message}`);
    },
};</pre><p>In an actual production-grade implementation, you might log to a database, a file, a third-party service, and so on. In the preceding step, you are simply logging to the console.</p></li>
				<li>Add code to the decorator factory that will wrap the property descriptors, <code>value</code>, <code>get</code>, and <code>set</code> properties (if they are present):<pre>function LogMethod(message: string) {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
        if (descriptor.value) {
            const original = descriptor.value;
            descriptor.value = function (...args: any[]) {
                logger.info(`${message}: Method ${propertyName} invoked`);
                // we're passing in the original arguments to the method
                return original.apply(this, args);
            }
        }
        if (descriptor.get) {
            const original = descriptor.get;
            descriptor.get = function () {
                logger.info(`${message}: Getter for ${propertyName} invoked`);
                // getter accessors do not take parameters
                return original.apply(this, []);
            }
        }
        if (descriptor.set) {
            const original = descriptor.set;
            descriptor.set = function (value: any) {
                logger.info(`${message}: Setter for ${propertyName} invoked`);
                // setter accessors take a single parameter, i.e. the value to be set
                return original.apply(this, [value]);
            }
        }
    }
}</pre></li>
				<li>Execute the code and verify that you get logging messages to the console when you call the method as well as when you use the <code>title</code> property:<pre>[INFO]: Teach method: Method teach invoked
John Smith is teaching
[INFO]: Title property: Setter for title invoked
[INFO]: Title property: Getter for title invoked
Mr. John Smith</pre></li>
			</ol>
			<p>In this exercise, you saw how to wrap the provided definitions of methods and property accessors class in such a way that you could run custom code on every invocation without changing the behavior of the functions themselves. You used that to add logging capabilities to functions that did not have any. You constructed objects of that class and verified that the logging functionality is operational.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/>Activity 7.01: Creating Decorators for Call Counting</h1>
			<p>As a developer of a backend service for a website, you are tasked with creating a solution that will enable the operations department to have clear auditing on the behavior of the service. For that, the app is required to have a tally of all class instantiations and method invocations.</p>
			<p>In this activity, you're going to create class and method decorators that can be used to count class instantiations and method invocations. You will create a class that contains data about a person and use the decorators to count how many such objects were created and how many times each method was called. After you have constructed several objects and used their properties, take a look at the values of the counters.</p>
			<p>The aim of this activity is to demonstrate the uses of class and method decorators in order to address a cross-cutting concern of your application, without changing the functionality of the given class. You should have a detailed statistic of the life cycles of your objects, without adding any complexity to the business logic.</p>
			<p>The following steps should help you with the solution:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this activity can also be downloaded from <a href="https://packt.link/UK49t">https://packt.link/UK49t</a>.</p>
			<ol>
				<li value="1">Create a class called <code>Person</code> with public properties named <code>firstName</code>, <code>lastName</code>, and <code>birthday</code>.</li>
				<li>Add a constructor that initializes the properties via the constructor parameters.</li>
				<li>Add a private field called <code>_title</code> and expose it via a getter and setter as a property called <code>title</code>.</li>
				<li>Add a method called <code>getFullName</code> that will return the full name of a person.</li>
				<li>Add a method called <code>getAge</code> that will return the current age of the person (by subtracting the birthday from the current year).</li>
				<li>Create a global object called <code>count</code> and initialize it to the empty object. This will be your state variable, where you store the counts for every instantiation and invocation.</li>
				<li>Create a constructor wrapping decorator factory called <code>CountClass</code> that will take a string parameter called <code>counterName</code>. We'll use that parameter as a key into the <code>count</code> object.</li>
				<li>Inside the wrapping code, increase the <code>count</code> object's property defined in the <code>counterName</code> parameter by 1.</li>
				<li>Don't forget to set the prototype chain of the wrapped constructor.</li>
				<li>Create a method wrapping decorator factory called <code>CountMethod</code> that will take a string parameter called <code>counterName</code>.</li>
				<li>Add checks for whether the <code>descriptor</code> parameter has <code>value</code>, <code>get</code>, and <code>set</code> properties. You need to cover both the cases where this decorator is used as an accessor and as a method decorator.</li>
				<li>In each respective branch, add code that wraps the method.</li>
				<li>Inside the wrapping code, increase the <code>count</code> object's property defined in the <code>counterName</code> parameter by 1.</li>
				<li>Decorate the class using the <code>CountClass</code> decorator, with a <code>person</code> parameter.</li>
				<li>Decorate <code>getFullName</code>, <code>getAge</code>, and the <code>title</code> property getter with the <code>CountMethod</code> decorator, using the <code>person-full-name</code>, <code>person-age</code>, and <code>person-title</code> parameters, respectively. Note that you need to decorate only one of the property accessors.</li>
				<li>Write code outside the class that will instantiate three <code>person</code> objects.</li>
				<li>Write code that will call the <code>getFullName</code> and <code>getAge</code> methods on the objects</li>
				<li>Write code that will check whether the <code>title</code> property is empty and set it to something if it is.</li>
				<li>Write code that will log the <code>count</code> object to the console in order to see if your decorators are running correctly.</li>
			</ol>
			<p>The expected output is as follows:</p>
			<pre>{
    person: 3,
    "person-full-name": 3,
    "person-age": 3,
    "person-title": 6
}</pre>
			<p>This activity demonstrates the power of using decorators to extend and augment the capabilities of your classes without polluting the code. You were able to inject custom code execution into your objects, without changing any of the underlying business logic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to the activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor416">this link</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor199"/>Using Metadata in Decorators</h1>
			<p>So far, you've been decorating classes and methods. These are basically pieces of code that get executed, and you have been able to change and augment the code that got executed. But your code consists not only of "active," live code, but of other definitions as well – in particular, your classes have fields, and your methods have parameters. In the activity before this section, you were able to detect whenever the <code>title</code> property was accessed because you had a method that was getting the value, and a method that was setting the value – so you piggybacked your code to the already existing "active" code. But how do you decorate the "passive" parts of your program? You cannot attach code that runs when your "passive" code gets executed, because frankly there's nothing to execute in <code>public firstName: string</code>. It's a simple definition.</p>
			<p>You cannot attach any code that gets executed for your "passive code," but what you can do using decorators is add some data to some global object regarding the decorated "passive" piece of code. In <em class="italic">Activity 7.01: Creating Decorators for Call Counting</em>, you defined a global <code>count</code> object and used that in your decorators to keep track of the executions. That approach works, but it requires creating a global variable, which is bad in most cases. It would be much cleaner if you were able to define some kind of properties on the methods and classes themselves. But, on the other hand, you don't want to add too many properties that are available alongside the business logic code – the possibility of incidental error is too high. What you need is to be able to somehow add metadata to your classes and methods.</p>
			<p>Fortunately, this is a common problem and there is a proposal to add proper metadata support to JavaScript. In the meantime, there is a polyfill library called <strong class="bold">reflect-metadata</strong> that can be used.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on the <code>reflect-metadata</code> library, visit <a href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a>.</p>
			<p>What this library does, in essence, is attach a special property to your classes that gives us a place to store, retrieve, and work with metadata about your class.</p>
			<p>In TypeScript, in order to use this feature, you have to specify an additional compiler flag, either via the command line or via <code>tsconfig.json</code>. That is the <code>emitDecoratorMetadata</code> flag, which needs to be set to <code>true</code> in order to work with the metadata methods.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor200"/>Reflect Object</h2>
			<p>The API of the <code>reflect-metadata</code> library is straightforward, and mostly you can focus on the following methods:</p>
			<ul>
				<li><code>Reflect.defineMetadata</code>: Defines a piece of metadata on a class or a method</li>
				<li><code>Reflect.hasMetadata</code>: Returns a Boolean indicating whether a certain piece of metadata is present</li>
				<li><code>Reflect.getMetadata</code>: Returns the actual piece of metadata, if present</li>
			</ul>
			<p>Consider the following code:</p>
			<pre>class Teacher {
    constructor (public name: string){}
    private _title: string = "";
    public get title() { 
        return this._title;
    }
    
    public set title(value: string) {
        this._title = value;
    }
    public teach() {
        console.log(`${this.name} is teaching`)
    }
}</pre>
			<p>Here you have a class called <code>Teacher</code> that has a simple private field, <code>_title</code>, which has <code>get</code> and <code>set</code> accessor methods for a property called <code>title</code>, and a method called <code>teach</code> that logs to the console that the teacher is, in fact, teaching.</p>
			<p>You can define a metadata key called <code>call-count</code> on the <code>Teacher</code> class and set its value to <code>0</code> by executing the following call to <code>defineMetadata</code>:</p>
			<pre>Reflect.defineMetadata("call-count", 0, Teacher);</pre>
			<p>If you want to add a metadata key called <code>call-count</code>, not on the <code>Teacher</code> class itself but on the <code>teach</code> method, you could do so with the following call to <code>defineMetadata</code>:</p>
			<pre>Reflect.defineMetadata("call-count", 10, Teacher, "teach");</pre>
			<p>This will define a metadata key called <code>call-count</code> on the <code>Teacher</code> class' <code>teach</code> property and set its value to <code>10</code>. You can retrieve these values using the following commands:</p>
			<pre>Reflect.getMetadata("call-count", Teacher); // will return 0
Reflect.getMetadata("call-count", Teacher, "teach"); // will return 10</pre>
			<p>In essence, you can create a method that will register a call of a method with the following code:</p>
			<pre>function increaseCallCount(target: any, propertyKey: string) {
    if (Reflect.hasMetadata("call-count", target)) {
        const value = Reflect.getMetadata("call-count", target, propertyKey);
        Reflect.defineMetadata("call-count", value+1, target, propertyKey)
    } else {
        Reflect.defineMetadata("call-count", 1, target, propertyKey)
    }
}</pre>
			<p>This code will first call the <code>hasMetadata</code> method, to check whether you have already defined a value for the <code>call-count</code> metadata. If that is <code>true</code>, the <code>hasMetadata</code> method will call <code>getMetadata</code> to get the current value and then call <code>defineMetadata</code> to re-define the metadata property with an increased (<code>value+1</code>) value. If you did not have such a metadata property, the <code>defineMetadata</code> method will define it with a value of 1. </p>
			<p>When called with <code>increaseCallCount(Teacher, "teach");</code>, it will successfully increase the call count of the <code>teach</code> method of the <code>Teacher</code> class. The metadata added to the class will in no way hinder the behaviors that the class already has, so any code that is being executed won't be affected.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor201"/>Exercise 7.06: Adding Metadata to Methods via Decorators</h2>
			<p>In this exercise, we'll create a simple class and apply some metadata for describing its methods. After you have done this, you will write a function that given a class, will display its available descriptions:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/JG4F8">https://packt.link/JG4F8</a>.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise06</code>), and save it as <code>calculator-metadata.ts</code>.</li>
				<li>Enter the following code in <code>calculator-metadata.ts</code>:<pre>class Calculator {
    constructor (public first: number, public second: number) {}
    public add() {
        return this.first + this.second;
    }
    public subtract() {
        return this.first – this.second;
    }
    public multiply() {
        return this.first / this.second;
    }
    public divide() {
        return this.first / this.second;
    }
}</pre></li>
				<li>Next, add metadata descriptions for the class and some of its methods:<pre>Reflect.defineMetadata("description", "A class that offers common operations over two numbers", Calculator);
Reflect.defineMetadata("description", "Returns the result of adding two numbers", Calculator, "add");
Reflect.defineMetadata("description", "Returns the result of subtracting two numbers", Calculator, "subtract");
Reflect.defineMetadata("description", "Returns the result of dividing two numbers", Calculator, "divide");</pre></li>
				<li>Define a function that when given a class will reflect upon it and extract and display the class' <code>description</code> metadata:<pre>function showDescriptions (target: any) {
    if (Reflect.hasMetadata("description", target)) {
        const classDescription = Reflect.getMetadata("description", target);
        console.log(`${target.name}: ${classDescription}`);
    }
}</pre></li>
				<li>Call the function using <code>showDescriptions(Calculator);</code> and verify that it will display the following output:<pre>Calculator: A class that offers common operations over two numbers</pre><p>In order to get a list of all methods of a class, we'll have to use the <code>Object.getOwnPropertyNames</code> function. Additionally, since the methods are actually defined on the prototype of the class, the correct line that gets all methods names of a class is <code>const methodNames = Object.getOwnPropertyNames(target.prototype);</code>.</p></li>
				<li>Next, loop over the returned array and check each method for a description. The <code>showDescription</code> function will now have the following format:<pre>function showDescriptions (target: any) {
    if (Reflect.hasMetadata("description", target)) {
        const classDescription = Reflect.getMetadata("description", target);
        console.log(`${target.name}: ${classDescription}`);
        const methodNames = Object.getOwnPropertyNames(target.prototype);
        for (const methodName of methodNames) {
            if (Reflect.hasMetadata("description", target, methodName)) {
                const description = Reflect.getMetadata("description", target, methodName);
                console.log(`  ${methodName}: ${description}`);
            }
        }
    }
}</pre></li>
				<li>Call the function again and verify that it will display the following output:<pre>Calculator: A class that offers common operations over two numbers
  add: Returns the result of adding two numbers
  subtract: Returns the result of subtracting two numbers
  divide: Returns the result of dividing two numbers</pre></li>
			</ol>
			<p>Note that you're not displaying anything for the <code>multiply</code> method, as you did not add any metadata for it.</p>
			<p>In this exercise, you learned how to add metadata to classes and methods and how to check its existence and, if present, to retrieve it. You also managed to get a list of all the methods of a given class.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor202"/>Property Decorators</h1>
			<p>A property decorator is a decorator function that is applied to a single property of a class. Unlike in a method or class decorators, you cannot modify or replace the property definition, but you can indeed observe it. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since you receive the constructor function in the decorator, this is not strictly true. You could change the code of the class, but it's extremely inadvisable.</p>
			<p>When a property decorator is called, it receives two parameters: <code>target</code> and <code>propertyKey</code>:</p>
			<ul>
				<li><code>target</code>: Since properties can be both instance properties (defined on instances of the class) and static properties (defined on the class itself), <code>target</code> can be two different things. For instance properties, it's the prototype of the class. For static properties, it's the constructor function of the class. Usually, you would type this parameter as <code>any</code>.</li>
				<li><code>propertyKey</code>: This is the name of the property you're decorating.</li>
			</ul>
			<p>In contrast to the method decorators, you're not receiving a property descriptor parameter, because, plainly, there isn't one available. Also, because you do not return any code that can be replaced, the return value of a property decorator is ignored.</p>
			<p>For example, you can define a simple property decorator factory that just logs a message to the console to notify that the property is actually decorated:</p>
			<pre>Example_PropertyDecorators.ts
1 function DecorateProperty(message: string) {
2     return function (target: any, propertyKey: string) {
3        console.log(`Decorated 
4 ${target.constructor.name}.${propertyKey} with '${message}'`);
5     }
6 }
Link to the preceding example: <a href="https://packt.link/HkkNi">https://packt.link/HkkNi</a>.</pre>
			<p>Consider the following class definitions:</p>
			<pre>class Teacher {
    public id: number;
    public name: string;
    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
}</pre>
			<p> You can annotate the <code>id</code> and <code>name</code> properties using the following code:</p>
			<pre>    @DecorateProperty("ID")
    public id: number;
    @DecorateProperty("NAME")
    public name: string;</pre>
			<p>If you now execute the code (we don't need to call anything; it will be called by the TypeScript engine), you obtain the following output:</p>
			<pre>Decorated Teacher.id with 'ID'
Decorated Teacher.name with 'NAME'</pre>
			<p>Note that you did not create any objects of the teacher class, or call any methods. The decorators executed when the class was defined. Since property decorators are passive, usually you'll use them to feed some kind of data into some mechanism that will use it. One of the common approaches is to combine the passive decorators with one or several active decorators, that is, class and method decorators.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This is the case in Angular, for example, where the passive <code>@Input</code> and <code>@Output</code> decorators are combined with the active <code>@Component</code> decorator.</p>
			<p>Another common use case is to have an additional mechanism that will get the data provided by the decorators and use it. For example, you can have the decorators recording some metadata, and then have another function that reads and uses that metadata.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor203"/>Exercise 7.07: Creating and Using a Property Decorator</h2>
			<p>In this exercise, you'll create a simple property decorator factory that will provide each property with a description. After you have done this, you will write a function that given a class will display its available descriptions:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section. The code file for this exercise can also be downloaded from <a href="https://packt.link/1WU6d">https://packt.link/1WU6d</a>.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise07</code>), and save it as <code>teacher-properties.ts</code>.</li>
				<li>Enter the following code in <code>teacher-properties.ts</code>:<pre>class Teacher {
    public id: number;
    public name: string;
    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
}</pre></li>
				<li>Add a decorator factory that takes a string parameter and generates a property decorator that will add a metadata <code>description</code> field to the class for the given property:<pre>function Description(message: string) {
    return function (target: any, propertyKey: string) {
        Reflect.defineMetadata("description", message, target, propertyKey)
    }
}</pre></li>
				<li>Next, annotate the properties of the <code>Teacher</code> class using the description:<pre>    @Description("This is the id of the teacher")
    public id: number;
    @Description("This is the name of the teacher")
    public name: string;</pre></li>
				<li>Define a function that, when given an object, will reflect upon it and extract and display the <code>description</code> metadata for the object's properties:<pre>function showDescriptions (target: any) {
    for (const key in target) {
        if (Reflect.hasMetadata("description", target, key)) {
            const description = Reflect.getMetadata("description", target, key);
            console.log(`  ${key}: ${description}`);
        }
    }
}</pre></li>
				<li>Create an object of the <code>Teacher</code> class:<pre>const teacher = new Teacher(1, "John Smith");</pre></li>
				<li>Pass that object to the <code>showDescriptions</code> function:<pre>showDescriptions(teacher);</pre></li>
				<li>Execute the code and verify that the descriptions are displayed:<pre>  id: This is the id of the teacher
  name: This is the name of the teacher</pre></li>
			</ol>
			<p>In this exercise, you learned how to add metadata to properties using property decorators and how to use property decorators to add quick basic documentation to your classes.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor204"/>Parameter Decorators</h1>
			<p>A parameter decorator is a decorator function that is applied to a single parameter of a function call. Just like property decorators, parameter decorators are passive, that is, they can be used only to observe values, but not to inject and execute code. The return value of a parameter decorator is similarly ignored. As a consequence, parameter decorators are almost exclusively used in conjunction with other, active decorators.</p>
			<p>When a parameter decorator is called, it receives three parameters: <code>target</code>, <code>propertyKey</code>, and <code>parameterIndex</code>:</p>
			<ul>
				<li><code>target</code>: The behavior for this parameter is identical to the decorators on the corresponding method. There is an exception if the parameter is on a class' constructor, but that is explained shortly.</li>
				<li><code>propertyKey</code>: This is the name of the method whose parameter you're decorating (the constructor exception is explained shortly).</li>
				<li><code>parameterIndex</code>: This is the ordinal index of the parameter in the function's parameter list (starting with zero for the first parameter).</li>
			</ul>
			<p>So, let's have a function that will simply log the <code>target</code>, <code>propertyKey</code>, and <code>parameterIndex</code> parameters to the console:</p>
			<pre>Example_ParameterDecorators.ts
1 function DecorateParam(target: any, propertyName: string,
2 parameterIndex: number) {
3    console.log("Target is:", target);
4    console.log("Property name is:", propertyName);
5    console.log("Index is:", parameterIndex);
6 }
Link to the preceding example: <a href="https://packt.link/5vuL2">https://packt.link/5vuL2</a>.</pre>
			<p>You can use this function to decorate a function's parameters and can investigate the usage of parameter decorators. Let's start with a simple class:</p>
			<pre>class Teacher {
    public id: number;
    public name: string;
    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
    public getFullName(title: string, suffix: string) {
        return `${title} ${this.name}, ${suffix}`
    }
}</pre>
			<p>The class has a constructor that takes two parameters, <code>id</code> and <code>name</code>, and a method called <code>getFullName</code>, which takes two parameters, <code>title</code> and <code>suffix</code>. Say you add your decorator to the first parameter of the <code>getFullName</code> methods, using this:</p>
			<pre>     public getFullName(@DecorateParam title: string, suffix: string) {
        // ....</pre>
			<p>If you run your code (no need to instantiate the class), you'll get the following output on the console:</p>
			<pre>Target is: Teacher {}
Property name is: getFullName
Index is: 0</pre>
			<p>We can also apply parameter decorators to the parameters of the constructor function itself. Say you decorate the second constructor parameter, like this:</p>
			<pre>    constructor(id: number, @DecorateParam name: string) {
        // ....</pre>
			<p>You will get the following output when you run the code:</p>
			<pre>Target is: [Function: Teacher]
Property name is: undefined
Index is: 1</pre>
			<p>Note that in this case, the target is not the prototype of the class, but the class constructor itself. Also, when decorating constructor parameters, the name of the property is <code>undefined</code>.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor205"/>Exercise 7.08: Creating and Using a Parameter Decorator</h2>
			<p>In this exercise, you will create a parameter decorator that will indicate that a certain parameter is required; that is, it should not have an empty value. You will also create a validation decorator for the method, so that the validation can actually take place. We'll create a class that uses the decorators, and you will try to call the method with both valid and invalid values:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before you begin, make sure you have set up the correct compiler options as mentioned in the <em class="italic">Setting Up Compiler Options</em> section.The code file for this exercise can also be downloaded from <a href="https://packt.link/Hf3fv">https://packt.link/Hf3fv</a>.</p>
			<ol>
				<li value="1">Open Visual Studio Code, create a new file in a new directory (<code>Exercise08</code>), and save it as <code>teacher-parameters.ts</code>.</li>
				<li>Enter the following code in <code>teacher-parameters.ts</code>:<pre>class Teacher {
    public id: number;
    public name: string;
    constructor(id: number, name: string) {
        this.id = id;
        this.name = name;
    }
    public getFullName(title: string, suffix: string) {
        return `${title} ${this.name}, ${suffix}`
    }
}</pre></li>
				<li>Create a parameter decorator called <code>Required</code> that will add the index of the parameter to the <code>required</code> metadata field to the class for the given property:<pre>function Required(target: any, propertyKey: string, parameterIndex: number) {
    if (Reflect.hasMetadata("required", target, propertyKey)) {
        const existing = Reflect.getMetadata("required", target, propertyKey) as number[];
        Reflect.defineMetadata("required", existing.concat(parameterIndex), target, propertyKey);
    } else {
        Reflect.defineMetadata("required", [parameterIndex], target, propertyKey)
    }
}</pre><p>Here, if the metadata already exists, that means that there is another required parameter. If so, you load it and concatenate your <code>parameterIndex</code>. If there is no previous metadata, you define it with an array consisting of your <code>parameterIndex</code>.</p></li>
				<li>Next, create a method decorator that will wrap the original method and check all required parameters <em class="italic">before</em> calling the original method:<pre>function Validate(target: any, propertyKey:string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function (...args: any[]) {
        // validate parameters
        if (Reflect.hasMetadata("required", target, propertyKey)) {
            const requiredParams = Reflect.getMetadata("required", target, propertyKey) as number[];
            for (const required of requiredParams) {
                if (!args[required]) {
                    throw Error(`The parameter at position ${required} is required`)
                }
            }
        }
        return original.apply(this, args);
    }
}</pre><p>If any of your required parameters has a falsy value, instead of executing the original method, your decorator will throw an error.</p></li>
				<li>After that, annotate the <code>title</code> parameter of the <code>getFullName</code> method with the <code>Required</code> decorator and the method itself with the <code>Validate</code> decorator:<pre>    @Validate
    public getFullName(@Required title: string, suffix: string) {
        // ....</pre></li>
				<li>Create an object of the <code>Teacher</code> class:<pre>const teacher = new Teacher(1, "John Smith");</pre></li>
				<li>Try to call the <code>getFullName</code> method with an empty string as the first parameter:<pre>try {
     console.log(teacher.getFullName("", "Esq"));
} catch (e) {
     console.log(e.message);
}</pre></li>
				<li>Execute the code and verify that the error message is displayed instead:<pre>The parameter at position 0 is required</pre></li>
			</ol>
			<p>In this exercise, you covered how to create parameter decorators and how to use them to add metadata. You also orchestrated the usage of the same metadata into another decorator, and build a basic validation system.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor206"/>Application of Multiple Decorators on a Single Target</h1>
			<p>It is often necessary to apply more than one decorator on a single target. And as decorators can (and do) change the code that actually gets executed, it's important to have an understanding of how different decorators play together.</p>
			<p>Basically, decorators are functions, and you're using them to compose your targets. This means that, in essence, decorators will be applied and executed bottom-up, with the decorator that's closest to the target going first and providing the result for the second decorators, and so on. This is similar to functional composition; that is, when we're trying to calculate <code>f(g(x))</code>, first the <code>g</code> function will be called, and then the <code>f</code> function will be called.</p>
			<p>There is a small catch when using decorator factories, though. The composition rule only applies to the decorators themselves – and decorator factories are not decorators per se. They are functions that need to be executed in order to return a decorator. This means that they are executed in source code order, that is, top-down. Imagine that you have two decorator factories: </p>
			<pre>Example_MultipleDecorators.ts
1 function First () {
2    console.log("Generating first decorator")
3    return function (constructor: Function) {
4        console.log("Applying first decorator")
5    }
6 }
Link to the preceding example <a href="https://packt.link/jMhDj">https://packt.link/jMhDj</a>.</pre>
			<p>Second decorator factory:</p>
			<pre>7  function Second () {
8      console.log("Generating second decorator")
9      return function (constructor: Function) {
10         console.log("Applying second decorator")
11     }
12 }</pre>
			<p>Now imagine that they are applied on a single target:</p>
			<pre>13 @First()
14 @Second()
15 class Target {}</pre>
			<p>The generation process will generate the first decorator before the second, but in the application process, the second will be applied, and then the first:</p>
			<pre>Generating first decorator
Generating second decorator
Applying second decorator
Applying first decorator<a id="_idTextAnchor207"/></pre>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor208"/>Activity 7.02: Using Decorators to Apply Cross-Cutting Concerns</h2>
			<p>In this activity, we're going full circle to the basketball game example (<code>Example_Basketball.ts</code>). You are tasked with adding all the necessary cross-cutting concerns, such as authentication, performance metrics, auditing, and validation to the <code>Example_Basketball.ts</code> file in a maintainable manner.</p>
			<p>You can begin the activity with the code that you already have in the <code>Example_Basketball.ts.</code> First, take stock of the elements that are already present in the file:</p>
			<ul>
				<li>The interface that describes the team.</li>
				<li>The class for the game itself. You have a constructor that creates the team objects given the team names. You also have a <code>getScore</code> function that displayed the score and a simple <code>updateScore</code> method that updates the score of the game, taking the scoring team and the score value as parameters.</li>
			</ul>
			<p>Now you need to add the cross-cutting concerns as mentioned previously without changing the code of the class itself, only by using decorators.</p>
			<p>Earlier in <code>Example_Basketball.ts</code>, you had to completely subsume the business logic of keeping score under the code that was needed to address everything else (such as authorization, auditing, metrics, and so on). Now apply all the decorator skills that are needed so that the application runs properly but still has a crisp and clear codebase.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can also be downloaded from <a href="https://packt.link/7KfCx">https://packt.link/7KfCx</a>.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">Create the code for the <code>BasketBallGame</code> class.</li>
				<li>Create a class decorator factory called <code>Authenticate</code> that will take a <code>permission</code> parameter and return a class decorator with constructor wrapping. The class decorator should load the <code>permissions</code> metadata property (array of <code>strings</code>), then check if the passed parameter is an element of the array. If the passed parameter is not an element of the array, the class decorator should throw an error, and if it's present, it should continue with the class creation.</li>
				<li>Define a metadata property of the <code>BasketballGame</code> class called <code>permissions</code> with the value <code>["canUpdateScore"]</code>.</li>
				<li>Apply the class decorator factory on the <code>BasketballGame</code> class with a parameter value of <code>canUpdateScore</code>.</li>
				<li>Create a method decorator called <code>MeasureDuration</code> that will use method wrapping to start a timer before the method body is executed and stop it after it's done. It should calculate the duration and push it to a metadata property called <code>durations</code> for the method.</li>
				<li>Apply the <code>MeasureDuration</code> method decorator on the <code>updateScore</code> method.</li>
				<li>Create a method decorator factory called <code>Audit</code> that will take a <code>message</code> parameter and return a method decorator. The method decorator should use method wrapping to get the arguments and the return value of the method. After the successful execution of the original method, it should display the audit log to the console.</li>
				<li>Apply the <code>Audit</code> method decorator factory on the <code>updateScore</code> method, with a parameter value of <code>Updated score</code>.</li>
				<li>Create a parameter decorator called <code>OneTwoThree</code> that will add the decorated parameter in the <code>one-two-three</code> metadata property.</li>
				<li>Create a method decorator called <code>Validate</code> that will use method wrapping to load all values for the <code>one-two-three</code> metadata property, and for all marked parameters check their value. If the value is <code>1</code>, <code>2</code>, or <code>3</code>, it should continue the execution of the original method. If not, it should stop the execution with an error.</li>
				<li>Apply the <code>OneTwoThree</code> decorator to the <code>byPoints</code> parameter of <code>updateScore</code> and apply the <code>Validate</code> decorator to the <code>updateScore</code> method:<pre>Create a game object, and update its score a few times. The console should reflect the applications of all decoratorsas shown:
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 3, true ]
[AUDIT] and returned result:
[AUDIT] undefined
//…
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, true ]
[AUDIT] and returned result:
[AUDIT] undefined
[AUDIT] Updated score (updateScore) called with arguments:
[AUDIT] [ 2, false ]
[AUDIT] and returned result:
[AUDIT] undefined
7:8</pre><p class="callout-heading">Note </p><p class="callout">For ease of presentation, only a section of the expected output is shown here. The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor418">this link</a>.</p></li>
			</ol>
			<p>In this activity, you are leveraging decoration to quickly and efficiently implement complicated cross-cutting concerns. When you have successfully completed the activity, you will have implemented multiple kinds of decorators, according to the needs of the application, and thus will have widened the functionalities of your code without sacrificing clarity and readability.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor209"/>Summary</h1>
			<p>In this chapter, you looked at a technique called <strong class="bold">decorating</strong> that is natively supported in TypeScript. The chapter first established the motivation for the use of decorators and then looked at the multiple types of decorators in TypeScript (class, method, accessor, property, and parameter decorators), along with examining the possibilities of each. You learned how to swap or change the complete constructor of a class with a class decorator, how to wrap a single method or property accessor with a method decorator, and how to enrich the available metadata using property and parameter decorators.</p>
			<p>The chapter also discussed the differences between active and passive decorators, which boil down to a difference between code and definition. You implemented several common variants of each of the decorator types and demonstrated how different decorator types can nicely complement each other. This chapter should help you easily manage the usage and creation of decorators both from third-party libraries such as Angular and from decorator factories created by yourself. In the next chapter, we will begin our foray into dependency injection in TypeScript.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>