<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. The Kendo MVVM Framework</h1></div></div></div><p>JavaScript development has come a long way since its inception and the appearance of rich MVVM frameworks is wonderful evidence of that evolution. These allow the developer to separate responsibilities within the code to better handle complexity. They also provide a beautifully simple syntax so that the MVVM framework itself is left to handle the tedious work of binding dynamic data into your web pages. If you have never used a JavaScript MVVM framework before, you are in for a treat with the <a id="id239" class="indexterm"/>Kendo MVVM framework.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Understanding MVVM – basics</h1></div></div></div><p>MVVM <a id="id240" class="indexterm"/>stands for <strong>Model</strong> (<strong>M</strong>)<a id="id241" class="indexterm"/>, <strong>View</strong> (<strong>V</strong>)<a id="id242" class="indexterm"/>, and <strong>View-Model</strong> (<strong>VM</strong>)<a id="id243" class="indexterm"/>. It is part of a family of design patterns related to system architecture that separate responsibilities into distinct units. Some other related patterns are <strong>Model-View-Controller</strong> (<strong>MVC</strong>)<a id="id244" class="indexterm"/> and <strong>Model-View-Presenter</strong> (<strong>MVP</strong>)<a id="id245" class="indexterm"/>. These differ on what each portion of the framework is responsible for, but they all attempt to manage complexity through the same underlying design principles. Without going into unnecessary details here, suffice it to say that these patterns are good for developing reliable and reusable code and they are something that you will undoubtedly benefit from if you have implemented them properly. Fortunately, the good JavaScript MVVM frameworks make it easy by wiring up the components for you and letting you focus on the code instead of the "plumbing".</p><p>In the MVVM pattern for JavaScript through Kendo UI, you will need to create a definition for the data that you want to display and manipulate (the Model), the HTML markup that structures your overall web page (the View), and the JavaScript code that handles user input, reacts to events, and transforms the static markup into dynamic elements (the View-Model). Another way to put it is that you will have data (Model), presentation (View), and logic (View-Model).</p><p>In practice, the Model is the most loosely-defined portion of the MVVM pattern and is not always even present as a unique entity in the implementation. The View-Model can assume the role of both Model and View-Model by directly containing the Model data properties within itself, <a id="id246" class="indexterm"/>instead of referencing them as a separate unit. This is acceptable and is also seen within ASP.NET MVC when a View uses the <code class="literal">ViewBag</code> or the <code class="literal">ViewData</code> collections instead of referencing a strongly-typed Model class. Don't let it bother you if the Model isn't as well defined as the View-Model and the View. The implementation of any pattern should be filtered down to what actually makes sense for your application.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Simple data binding</h2></div></div></div><p>As an<a id="id247" class="indexterm"/> introductory example, consider that you have a web page that <a id="id248" class="indexterm"/>needs to display a table of data, and also provide the users with the ability to interact with that data, by clicking specifically on a single row or element. The data is dynamic, so you do not know beforehand how many records will be displayed. Also, any change should be reflected immediately on the page instead of waiting for a full page refresh from the server. How do you make this happen?</p><p>A traditional approach would involve using special server-side controls that can dynamically create tables from a data source and can even wire-up some JavaScript interactivity. The problem with this approach is that it usually requires some complicated extra communication between the server and the web browser either through "view state", hidden fields, or long and ugly query strings. Also, the output from these special controls is rarely easy to customize or manipulate in significant ways and reduces the options for how your site should look and behave. Another choice would be to create special JavaScript functions to asynchronously retrieve data from an endpoint, generate HTML markup within a table and then wire up events for buttons and links. This is a good solution, but requires a lot of coding and complexity which means that it will likely take longer to debug and refine. It may also be beyond the skill set of a given developer without significant research. The third option, available through a JavaScript MVVM like Kendo UI, strikes a balance between these two positions by reducing the complexity of the JavaScript but still providing powerful and simple data binding features inside of the page.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Creating the view</h3></div></div></div><p>Here is a <a id="id249" class="indexterm"/>simple HTML page to show how a view basically works:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;title&gt;MVVM Demo 1&lt;/title&gt;
&lt;script src="img/jquery.js"&gt;&lt;/script&gt;
&lt;script src="img/kendo.all.js"&gt;&lt;/script&gt;
&lt;link href="/Content/kendo/kendo.common.css" rel="stylesheet" /&gt;
&lt;link href="/Content/kendo/kendo.default.css" rel="stylesheet" /&gt;
&lt;style type="text/css"&gt;
th {
width: 135px;
   }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt;
&lt;th&gt;Favorite Food&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" 
data-bind="source: people"&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Here we have a simple <code class="literal">table</code> element<a id="id250" class="indexterm"/> with three columns but instead of the <code class="literal">body</code> containing any <code class="literal">tr</code> elements, <a id="id251" class="indexterm"/>there are some special HTML5 <code class="literal">data-*</code> attributes indicating that something special is going on here. These <code class="literal">data-*</code> attributes<a id="id252" class="indexterm"/> do nothing by themselves, but Kendo UI reads them (as you will see below) and interprets their values in order to link the View with the View-Model. The <code class="literal">data-bind</code> attribute<a id="id253" class="indexterm"/> indicates to Kendo UI that this element should be bound to a collection of objects called <code class="literal">people</code>
<a id="id254" class="indexterm"/>.</p><p>The <code class="literal">data-template</code> attribute<a id="id255" class="indexterm"/> tells Kendo UI that the <code class="literal">people</code> objects should be formatted using a Kendo UI template. Here is the code for the template:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td data-bind="text: name"&gt;&lt;/td&gt;
&lt;td data-bind="text: hairColor"&gt;&lt;/td&gt;
&lt;td data-bind="text: favoriteFood"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>This is a simple template that defines a <code class="literal">tr</code> structure for each row within the table. The <code class="literal">td</code> elements also have a <code class="literal">data-bind</code> attribute on them so that Kendo UI knows to insert the value of a certain property as the "text" of the HTML element, which in this case means placing the value in between <code class="literal">&lt;td&gt;</code> and <code class="literal">&lt;/td&gt;</code> as simple text on the page.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Creating the Model and View-Model</h3></div></div></div><p>In order to wire this up,<a id="id256" class="indexterm"/> we need a View-Model<a id="id257" class="indexterm"/> that performs the data binding. Here is the View-Model code<a id="id258" class="indexterm"/> for this View:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [
            {name: "John", hairColor: "Blonde", favoriteFood: "Burger"},
            {name: "Bryan", hairColor: "Brown", favoriteFood: "Steak"},
            {name: "Jennifer", hairColor: "Brown", favoriteFood: "Salad"}
        ]
    });
kendo.bind($("body"), viewModel);
&lt;/script&gt;</pre></div><p>A Kendo UI View-Model<a id="id259" class="indexterm"/> is declared through a call to <code class="literal">kendo.observable()</code>
<a id="id260" class="indexterm"/> which creates an <strong>observable object</strong> that is then used for the data-binding within the View. An observable object is a special object that wraps a normal JavaScript variable with events that fire any time the value of that variable changes. These events notify the MVVM framework to update any data bindings that are using that variable's value, so that they can update immediately and reflect the change. These data bindings also work both ways so that if a field bound to an observable object variable is changed, the variable bound to that field is also changed in real time.</p><p>In this case, I created an array called <code class="literal">people</code> that contains three objects with properties about some people. This array, then, operates as the Model in this example since it contains the data and the definition of how the data is structured. At the end of this code sample, you can see the call to <code class="literal">kendo.bind($("body"), viewModel)</code> which is how Kendo UI actually performs its MVVM wiring. I passed a jQuery selector for the <code class="literal">body</code> tag to the first parameter since this <code class="literal">viewModel</code> object applies to the full body of my HTML page, not just a portion of it.</p><p>With everything combined, here is the full source for this simplified example:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;title&gt;MVVM Demo 1&lt;/title&gt;
&lt;scriptsrc="img/jquery.js"&gt;&lt;/script&gt;
&lt;scriptsrc="img/kendo.all.js"&gt;&lt;/script&gt;
&lt;link href="/Content/kendo/kendo.common.css" rel="stylesheet" /&gt;
&lt;link href="/Content/kendo/kendo.default.css" rel="stylesheet" /&gt;
&lt;style type="text/css"&gt;
th {
width: 135px;
        }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt;
&lt;th&gt;Favorite Food&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" 
data-bind="source: people"&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td data-bind="text: name"&gt;&lt;/td&gt;
&lt;td data-bind="text: hairColor"&gt;&lt;/td&gt;
&lt;td data-bind="text: favoriteFood"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [
       {name: "John", hairColor: "Blonde", favoriteFood: "Burger"},
       {name: "Bryan", hairColor: "Brown", favoriteFood: "Steak"},
{ name: "Jennifer", hairColor: "Brown", favoriteFood: "Salad" }
            ]
        });
kendo.bind($("body"), viewModel);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Here is a screenshot of the page in action. Note how the data from the JavaScript <code class="literal">people</code> array is populated into the table automatically:</p><div><img src="img/4346OT_04_01.jpg" alt="Creating the Model and View-Model"/></div><p>Even though this example contains a Model, a View, and a View-Model, all three units appear in the same HTML file. You could separate the JavaScript into other files, of course, but it is also acceptable to keep them together like this. Hopefully you are already seeing what sort of things this MVVM framework can do for you.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Observable data binding</h2></div></div></div><p>Binding data <a id="id261" class="indexterm"/>into your HTML web page (View) using <a id="id262" class="indexterm"/>declarative attributes is great, and very useful, but the MVVM framework offers some much more significant functionality that we didn't see in the last example. Instead of simply attaching data to the View and leaving it at that, the MVVM framework maintains a running copy of all of the View-Model's properties, and keeps references to those properties up to date in real time. This is why the View-Model is created with a function called "observable". The properties inside, being observable, report changes back up the chain so that the data-bound fields always reflect the latest data. Let's see some examples.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Adding data dynamically</h3></div></div></div><p>Building on <a id="id263" class="indexterm"/>the example we just saw, add this horizontal rule and form just below the table in the HTML page:</p><div><pre class="programlisting">&lt;hr /&gt;
&lt;form&gt;
&lt;header&gt;Add a Person&lt;/header&gt;
&lt;input type="text" name="personName" placeholder="Name" 
data-bind="value: personName" /&gt;&lt;br /&gt;
&lt;input type="text" name="personHairColor" placeholder="Hair Color" 
data-bind="value: personHairColor" /&gt;&lt;br /&gt;
&lt;input type="text" name="personFavFood" placeholder="Favorite Food" 
data-bind="value: personFavFood" /&gt;&lt;br /&gt;
&lt;button type="button" data-bind="click: addPerson"&gt;Add&lt;/button&gt;
&lt;/form&gt;</pre></div><p>This adds a form to the page so that a user can enter data for a new person that should appear in the table. <a id="id264" class="indexterm"/>Note that we have added some <code class="literal">data-bind</code> attributes, but this time we are binding the <code class="literal">value</code> of the input fields not the <code class="literal">text</code>. Note also that we have added a <code class="literal">data-bind</code> attribute to the <code class="literal">button</code> at the bottom of the form that binds the <code class="literal">click</code> event<a id="id265" class="indexterm"/> of that <code class="literal">button</code> with a function inside our View-Model. By binding the <code class="literal">click</code> event to the <code class="literal">addPerson</code> JavaScript method, the <code class="literal">addPerson</code> method<a id="id266" class="indexterm"/> will be fired every time this button is clicked.</p><p>These bindings keep the value of those input fields linked with the View-Model object at all times. If the value in one of these input fields changes, such as when a user types something in the box, the View-Model object will immediately see that change and update its properties to match; it will also update any areas of the page that are bound to the value of that property so that they match the new data as well.</p><p>The binding for the button is special because it allows the View-Model object to attach its own event handler to the click event for this element. Binding an event handler to an event is nothing special by itself, but it is important to do it this way (through the <code class="literal">data-bind</code> attribute) so that the specific running View-Model instance inside of the page has attached one of its functions to this event so that the code inside the event handler has access to this specific View-Model's data properties and values. It also allows for a very specific context to be passed to the event that would be very hard to access otherwise.</p><p>Here is the code I added to the View-Model just below the <code class="literal">people</code> array. The first three properties that we have in this example are what make up the Model. They contain that data that is observed and bound to the rest of the page:</p><div><pre class="programlisting">personName: "",       // Model property
personHairColor: "",  // Model property
personFavFood: "",    // Model property
addPerson: function () {
this.get("people").push({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
});
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
}</pre></div><p>The first several properties you see are the same properties that we are binding to in the input form above. They start with an empty value because the form should not have any values when the page is first loaded. It is still important to declare these empty properties inside the View-Model in order that their value can be tracked when it changes.</p><p>The function after<a id="id267" class="indexterm"/> the data properties, <code class="literal">addPerson</code>
<a id="id268" class="indexterm"/>, is what we have bound to the click event of the button in the input form. Here in this function we are accessing the <code class="literal">people</code> array and adding a new record to it based on what the user has supplied in the form fields. Notice that we have to <a id="id269" class="indexterm"/>use the <code class="literal">this.get()</code> and <code class="literal">this.set()</code> functions<a id="id270" class="indexterm"/> to access the data inside of our View-Model. This is important because the properties in this View-Model are special observable properties so accessing their values directly may not give you the results you would expect.</p><p>The most significant thing that you should notice about the <code class="literal">addPerson</code> function is that it is interacting with the data on the page through the View-Model properties. It is not using jQuery, <code class="literal">document.querySelector</code>, or any other DOM interaction to read the value of the elements! Since we declared a <code class="literal">data-bind</code> attribute on the values of the input elements to the properties of our View-Model, we can always get the value from those elements by accessing the View-Model itself. The values are tracked at all times. This allows us to both retrieve and then change those View-Model properties inside the <code class="literal">addPerson</code> function and the HTML page will show the changes right as it happens. By calling <code class="literal">this.set()</code> on the properties and changing their values to an empty string, the HTML page will clear the values that the user just typed and added to the table. Once again, we change the View-Model properties without needing access to the HTML ourselves.</p><p>Here is the complete source of this example:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;title&gt;MVVM Demo 2&lt;/title&gt;
&lt;scriptsrc="img/jquery.js"&gt;&lt;/script&gt;
&lt;scriptsrc="img/kendo.all.js"&gt;&lt;/script&gt;
&lt;link href="/Content/kendo/kendo.common.css" rel="stylesheet" /&gt;
&lt;link href="/Content/kendo/kendo.default.css" rel="stylesheet" /&gt;
&lt;style type="text/css"&gt;
th {
width: 135px;
        }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt;
&lt;th&gt;Favorite Food&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" data-bind="source: people"&gt;&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;form&gt;
&lt;header&gt;Add a Person&lt;/header&gt;
&lt;input type="text" name="personName" placeholder="Name" data-bind="value: personName" /&gt;&lt;br /&gt;
&lt;input type="text" name="personHairColor" placeholder="Hair Color" data-bind="value: personHairColor" /&gt;&lt;br /&gt;
&lt;input type="text" name="personFavFood" placeholder="Favorite Food" data-bind="value: personFavFood" /&gt;&lt;br /&gt;
&lt;button type="button" data-bind="click: addPerson"&gt;Add&lt;/button&gt;
&lt;/form&gt;
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td data-bind="text: name"&gt;&lt;/td&gt;
&lt;td data-bind="text: hairColor"&gt;&lt;/td&gt;
&lt;td data-bind="text: favoriteFood"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [
                {name: "John", hairColor: "Blonde", favoriteFood: "Burger"},
                {name: "Bryan", hairColor: "Brown", favoriteFood: "Steak"},
                {name: "Jennifer", hairColor: "Brown", favoriteFood: "Salad"}
            ],
personName: "",
personHairColor: "",
personFavFood: "",
addPerson: function () {
this.get("people").push({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
                });
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
            }
        });
kendo.bind($("body"), viewModel);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>And here is a screenshot of the page in action. You will see that one additional person has been added to the table by<a id="id271" class="indexterm"/> filling out the form. Try it out yourself to see the immediate interaction that you get with this code:</p><div><img src="img/4346OT_04_02.jpg" alt="Adding data dynamically"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Using observable properties in the View</h3></div></div></div><p>We just saw how <a id="id272" class="indexterm"/>simple it is to add new data to observable collections in the View-Model, and how this causes any data-bound elements to immediately show that new data. Let's add some more functionality to illustrate working with individual elements and see how their observable values can update content on the page.</p><p>To demonstrate<a id="id273" class="indexterm"/> this new functionality, I have added some columns to the table:</p><div><pre class="programlisting">&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt;
&lt;th&gt;Favorite Food&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Live Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" data-bind="source: people"&gt;&lt;/tbody&gt;
&lt;/table&gt;</pre></div><p>The first new column has no heading text but will contain a button on the page for each of the table rows. The second new column will be displaying the value of the "live data" in the View-Model for each of the objects displayed in the table.</p><p>Here is the updated row template:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td&gt;&lt;span data-bind="text: name"&gt;&lt;/span&gt;&amp;nbsp;-&amp;nbsp;
&lt;span data-bind="text: hairColor"&gt;&lt;/span&gt;&amp;nbsp;-&amp;nbsp;
&lt;span data-bind="text: favoriteFood"&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>Notice that I have replaced all of the simple <code class="literal">text data-bind</code> attributes<a id="id274" class="indexterm"/> with input elements and <code class="literal">valuedata-bind</code> attributes<a id="id275" class="indexterm"/>. I also added a button with a <code class="literal">clickdata-bind</code> attribute and a column that displays the text of the three properties so that you can see the observable behavior in real time.</p><p>The View-Model gets a new method for the delete button:</p><div><pre class="programlisting">deletePerson: function (e) {
var person = e.data;
var people = this.get("people");
var index = people.indexOf(person);
people.splice(index, 1);
}</pre></div><p>When this function is called through the binding that Kendo UI has created, it passes an event argument, here called <code class="literal">e</code>, into the function that contains a data property. This data property is a reference to the model object that was used to render the specific row of data. In this function, <a id="id276" class="indexterm"/>I created a <code class="literal">person</code> variable for a reference to the person in this row and a reference to the <code class="literal">people</code> array; we then use the index of this person to splice it out of the array. When you click on the <strong>Delete</strong> button, you can observe the table reacting immediately to the change.</p><p>Here is the full source code of the updated View-Model:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor" /&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" data-bind="click:
deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td&gt;&lt;span data-bind="text: name"&gt;&lt;/span&gt;&amp;nbsp;-&amp;nbsp;
&lt;span data-bind="text: hairColor"&gt;&lt;/span&gt;&amp;nbsp;-&amp;nbsp;
&lt;span data-bind="text: favoriteFood"&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/script&gt;&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [
        {name: "John", hairColor: "Blonde", favoriteFood: "Burger"},
        {name: "Bryan", hairColor: "Brown", favoriteFood: "Steak"},
        {name: "Jennifer", hairColor: "Brown", favoriteFood: "Salad"}
            ],
personName: "",
personHairColor: "",
personFavFood: "",
addPerson: function () {
this.get("people").push({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
                });
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
            },
deletePerson: function (e) {
var person = e.data;
var people = this.get("people");
var index = people.indexOf(person);
people.splice(index, 1);
            }
        });
kendo.bind($("body"), viewModel);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Here is a screenshot of the new page:</p><div><img src="img/4346OT_04_03.jpg" alt="Using observable properties in the View"/></div><p>Click on the <strong>Delete</strong> button to see an entry disappear. You can also see that I have added a new person to <a id="id277" class="indexterm"/>the table and that I have made changes in the input boxes of the table and that those changes immediately show up on the right-hand side. This indicates that the View-Model is keeping track of the live data and updating its bindings accordingly.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Making better use of observable arrays</h3></div></div></div><p>In the last <a id="id278" class="indexterm"/>several examples, we have been using an array called <code class="literal">people</code> to show a dynamic table with Kendo UI bindings. This has worked fine so far, but with more complicated Models and functionality we can run into a wall, so to speak. For example, there is no way to have the "live data" come from the Model objects themselves; we had to concatenate three <code class="literal">span</code> elements in <a id="id279" class="indexterm"/>the template to form the final output. This could cause problems for more complicated and full-featured pages, where you may have an array of Model objects that need to be able to handle events and calculate values on their own, instead of at the View-Model level.</p><p>Modify the row template like this:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name.stuff" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor.stuff" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood.stuff" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td data-bind="text: dataString"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>We have changed the property names in the <code class="literal">data-bind</code> declaration so that they point to an inner property<a id="id280" class="indexterm"/> that we created for them, called <code class="literal">stuff</code>. The important part of the example is that we also changed the final column to point to a calculated value function called <code class="literal">dataString</code>
<a id="id281" class="indexterm"/>. The meaning of this will become clear as we continue. Next, update the JavaScript block for the View-Model so that it looks like this:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [],
personName: "",
personHairColor: "",
personFavFood: "",
addPerson: function () {
this.get("people").push(new person({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
            }));
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
        },
deletePerson: function (e) {
var person = e.data;
var people = this.get("people");
var index = people.indexOf(person);
people.splice(index, 1);
        }
    });

var person = function (data) {
var self = this;
this.name = kendo.observable({ stuff: data.name });
this.hairColor = kendo.observable({ stuff: data.hairColor });
this.favoriteFood = kendo.observable({ stuff: data.favoriteFood });
this.dataString = function () {
returnself.name.get("stuff") + " - " + 
self.hairColor.get("stuff") + " - " +
self.favoriteFood.get("stuff");
        }
    };

viewModel.get("people").push(new person({ name: "John", 
hairColor: "Blonde",
favoriteFood: "Burger" }));
viewModel.get("people").push(new person({ name: "Bryan", 
hairColor: "Brown",
favoriteFood: "Steak" }));
viewModel.get("people").push(new person({ name: "Jennifer",
hairColor:"Brown",
favoriteFood: "Salad" }));

kendo.bind($("body"), viewModel);
&lt;/script&gt;</pre></div><p>We made several changes, so let's step through them carefully. The first important change is right at the top, <a id="id282" class="indexterm"/>where we have replaced the static array declaration with the <code class="literal">people</code> property as an empty array with the bracket notation <code class="literal">[]</code>. Secondly, we created a new type of object called <code class="literal">person</code> and gave it a constructor function with its own internal observable objects. Each of these observable objects needs an object to manage, simple values don't work quite as well, so we made an arbitrary property for them called <code class="literal">stuff</code>. The only thing going on here is that the properties of this new <code class="literal">person</code> object type are pointing to observable objects instead of simple data. Why? Because if the properties are not observable, then the View-Model will not be notified of the change and the user interface will not be updated through data-binding.</p><p>The purpose of this change is to enable calculated values local to the specific instance of the object, which we have done with the <code class="literal">dataString</code> function inside of the <code class="literal">person</code> constructor. As you can see, the <code class="literal">dataString</code> function extracts the values from the locally observable <a id="id283" class="indexterm"/>properties and returns them as a formatted string. This is significant because it means that every <code class="literal">person</code> object has its own copy of this function, and that the View-Model itself is not involved in this calculation. This means that each object inside of the View-Model's <code class="literal">people</code> array can observe changes specific to itself and calculate values based on those changes. This type of Model can become very useful for advanced scenarios.</p><p>After declaring the <code class="literal">person</code> constructor function, we manually added some new <code class="literal">person</code> objects to the <code class="literal">people</code> array and then called <code class="literal">kendo.bind()</code>
<a id="id284" class="indexterm"/> as usual. When rendered, the page looks and behaves just as it did in the previous example, but now the Model objects are smarter. Here is the full source code of the updated View-Model:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td data-bind="text: dataString"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
people: [],
personName: "",
personHairColor: "",
personFavFood: "",
addPerson: function () {
this.get("people").push(new person({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
                }));
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
            },
deletePerson: function (e) {
var person = e.data;
var people = this.get("people");
var index = people.indexOf(person);
people.splice(index, 1);
            }
        });

var person = function (data) {
var self = this;
            this.name = kendo.observable({ d: data.name });
this.hairColor = kendo.observable({ d: data.hairColor });
this.favoriteFood = kendo.observable({ d: data.favoriteFood });
this.dataString = function () {
returnself.name.get("d") + " - " +
self.hairColor.get("d") + " - " + self.favoriteFood.get("d");
            }
        };

viewModel.get("people").push(new person({
name: "John", hairColor: "Blonde",
favoriteFood: "Burger"
        }));
viewModel.get("people").push(new person({
name: "Bryan", hairColor: "Brown",
favoriteFood: "Steak"
        }));
viewModel.get("people").push(new person({
name: "Jennifer", hairColor: "Brown",
favoriteFood: "Salad"
        }));

kendo.bind($("body"), viewModel);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>And the output when the page is run:</p><div><img src="img/4346OT_04_04.jpg" alt="Making better use of observable arrays"/></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Data-bind properties for Kendo MVVM</h1></div></div></div><p>There are <a id="id285" class="indexterm"/>thirteen different types of values that can be used inside of the <code class="literal">data-bind</code> Kendo UI attribute. Here is a summary of their definitions and uses.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>The attr property</h2></div></div></div><p>The <a id="id286" class="indexterm"/>
<code class="literal">attr</code> property is used to bind the value of a <a id="id287" class="indexterm"/>View-Model to a specific HTML attribute of a page element. For example, this is very useful for setting attributes such as the <code class="literal">src</code> for an image or the <code class="literal">href</code> for an anchor tag.</p><div><pre class="programlisting">... //View-Model definition
imageSource: 'http://www.images.com/randomImage.jpg',
...
&lt;img data-bind="attr: {src: imageSource}" /&gt;</pre></div><p>A binding like this would guarantee that the image would change along with the View-Model to allow for dynamically loading or changing images on a web page.</p><p>Note that the <code class="literal">attr</code> property can set multiple attributes at once when they are separated by commas like this:</p><div><pre class="programlisting">data-bind="attr: {attribute1: value, attribute2: value, attribute3: value, ...}"</pre></div><p>This property can be used with any HTML element and with any valid HTML attribute (including custom HTML5 <code class="literal">data-*</code> attributes).</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>The checked property</h2></div></div></div><p>The <a id="id288" class="indexterm"/>
<code class="literal">checked</code> property is used to bind <a id="id289" class="indexterm"/>the checked status of an input element with type <code class="literal">checkbox</code> or <code class="literal">radio</code>. For checkboxes, the data-bound property can be either a Boolean (<code class="literal">true</code>/<code class="literal">false</code>) value or an array. For radio selections, the property needs to be a string. For example:</p><div><pre class="programlisting">isChecked: true, ...

// Simple Boolean binding
// The data-bound property will be updated when the user clicks the checkbox

&lt;input type="checkbox" data-bind="checked: isChecked" /&gt;


animals: ["cow", "pig"], ...

// Array binding for checkboxes
// The array will change based on which checkboxes are checked by the user
// The initial page will show both the "cow" and "pig" inputs as checked

&lt;input type="checkbox" value="horse" data-bind="checked: animals" /&gt;
&lt;input type="checkbox" value="cow" data-bind="checked: animals" /&gt;
&lt;input type="checkbox" value="pig" data-bind="checked: animals" /&gt;

tablet: "surface", ...

// String binding for radio buttons
// The string will change based on which radio option is selected by the user
// The initial page will show the input with the value "surface" as checked

&lt;input type="radio" name="tablet" value="surface" data-bind="checked: tablet" /&gt;
&lt;input type="radio" name="tablet" value="ipad" data-bind="checked: tablet" /&gt;
&lt;input type="radio" name="tablet" value="android" data-bind="checked: tablet" /&gt;</pre></div><p>As you will see later, the <code class="literal">checked</code> binding can be very useful in conjunction with the <code class="literal">visible</code>/<code class="literal">invisible</code> bindings so that the checkboxes or radio buttons on the page will dynamically show or hide other portions of the page.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>The click property</h2></div></div></div><p>The <a id="id290" class="indexterm"/>
<code class="literal">click</code> property binds the click event of <a id="id291" class="indexterm"/>a button to a function inside of the View-Model. It is a shortcut to the <code class="literal">events</code> binding that we will see later. Unlike a traditional click event wire-up, the Kendo UI framework will pass context data to the event handler to allow for a richer event-handling experience. For example, when a click event is bound within a row template, the event argument passed to the event handler will have access to the item from the source collection. This allows the event handler to operate against that Model data directly without any further DOM exploration and keeps all of the observable functionality in place.</p><p>Technically, Kendo UI supplies the DOM event wrapped in a jQuery event object to the event handler indicated in the binding, but it also manages the data property like we talked about in the previous paragraph. Since the event argument is still connected to the DOM event, you can call <code class="literal">stopPropogation()</code> and <code class="literal">preventDefault()</code> on that event argument to stop the DOM from performing any other actions in the page.</p><p>We already saw examples of the <code class="literal">click</code> binding in our code samples above so here are some of the snippets that we used there:</p><div><pre class="programlisting">// Our example row template that included the click binding that will
// pass the data property to the event handler
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td data-bind="text: dataString"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;

// Our example form that included the click binding that has no
// relevant data property to pass to the event handler
&lt;form&gt;
&lt;header&gt;Add a Person&lt;/header&gt;
&lt;input type="text" name="personName" placeholder="Name" 
data-bind="value: personName" /&gt;&lt;br /&gt;
&lt;input type="text" name="personHairColor" placeholder="Hair Color" 
data-bind="value: personHairColor" /&gt;&lt;br /&gt;
&lt;input type="text" name="personFavFood" placeholder="Favorite Food" 
data-bind="value: personFavFood" /&gt;&lt;br /&gt;
&lt;button type="button" data-bind="click: addPerson"&gt;Add&lt;/button&gt;
&lt;/form&gt;

...

// This version of the click binding does not use the event argument
addPerson: function () {
this.get("people").push(new person({
name: this.get("personName"),
hairColor: this.get("personHairColor"),
favoriteFood: this.get("personFavFood")
    }));
this.set("personName", "");
this.set("personHairColor", "");
this.set("personFavFood", "");
},

// This version of the click binding uses the event argument to
// current data item from the source collection
deletePerson: function (e) {
var person = e.data;
var people = this.get("people");
var index = people.indexOf(person);
people.splice(index, 1);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>The custom property</h2></div></div></div><p>Kendo <a id="id292" class="indexterm"/>UI allows for custom bindings<a id="id293" class="indexterm"/> so that you can create custom behaviors related to the View-Model of your page. An example on the Kendo UI documentation site uses a jQuery UI <code class="literal">slideDown</code> and <code class="literal">slideUp</code> call based on a Boolean value in the View-Model as a short-cut to some UI transformations. Refer to the Kendo UI documentation for a more detailed API reference for custom bindings.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>The disabled/enabled properties</h2></div></div></div><p>The<a id="id294" class="indexterm"/> <code class="literal">disabled</code>
<a id="id295" class="indexterm"/> and <a id="id296" class="indexterm"/>
<code class="literal">enabled</code> bindings <a id="id297" class="indexterm"/>work on input, select, and text area HTML elements. Just as their names would indicate, they disable or enable the bound elements respectively. These bindings are designed for use with Boolean properties, but for the sake of JavaScript loose-typing they will consider the non-Boolean values <code class="literal">0</code>, <code class="literal">null</code>, <code class="literal">undefined</code>, and <code class="literal">""</code> (empty string) as <code class="literal">false</code> and all other non-Boolean values as <code class="literal">true</code>. An example code is as follows:</p><div><pre class="programlisting">allowEdit: false, ...

// This input element will be initially disabled until the View-Model's allowEdit
// View-Model's allowEdit property is changed to true
&lt;input type="text" data-bind="enabled: allowEdit" /&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>The events property</h2></div></div></div><p>The <a id="id298" class="indexterm"/>
<code class="literal">events</code> binding is a convenient way to<a id="id299" class="indexterm"/> wire-up event handlers in your View-Model to events on HTML elements in your View. The click binding, as we saw above, is a specific example of this pattern and operates in exactly the same way. For example:</p><div><pre class="programlisting">&lt;button type="button" data-bind="events: {blur: blurHandler, click: clickHandler,
mouseover: mouseHandler,...}"&gt;Interactive Button&lt;/button&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>The html/text properties</h2></div></div></div><p>The<a id="id300" class="indexterm"/> <code class="literal">html</code> binding<a id="id301" class="indexterm"/> sets the <code class="literal">innerHtml</code> content of an HTML element using the value of a property from the View-Model. This binding differs from <a id="id302" class="indexterm"/>the <code class="literal">text</code> binding in that it does not encode HTML tags before generating its output, which means that HTML tags in the View-Model property will be <a id="id303" class="indexterm"/>rendered as HTML instead of as text (which is probably what you want if you are using the <code class="literal">html</code> binding). An example:</p><div><pre class="programlisting">spanContent: "&lt;strong&gt;Some Content&lt;/strong&gt;",...

&lt;span data-bind="html: spanContent"&gt;&lt;/span&gt;</pre></div><p>This would generate output like this in the source of the rendered page:</p><div><pre class="programlisting">&lt;span&gt;&lt;strong&gt;Some Content&lt;/strong&gt;&lt;/span&gt;</pre></div><p>The <code class="literal">text</code> binding works in exactly the same way as the <code class="literal">html</code> binding, except that it sets the simple text between element tags and it does encode HTML before output, so do not put HTML in the property containing the text to display unless you want the tags to show as part of the text output.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>The invisible/visible properties</h2></div></div></div><p>The<a id="id304" class="indexterm"/> <code class="literal">invisible</code> and<a id="id305" class="indexterm"/> <code class="literal">visible</code> bindings work on HTML elements that you want <a id="id306" class="indexterm"/>to either show or hide dynamically. Just as <a id="id307" class="indexterm"/>their names indicate, they make the given element invisible or visible respectively. These bindings are designed for use with Boolean properties, but for the sake of JavaScript loose-typing they will consider the non-Boolean values <code class="literal">0</code>, <code class="literal">null</code>, <code class="literal">undefined</code>, and <code class="literal">""</code> (empty string) as false and all other non-Boolean values as true. An example code is as follows:</p><div><pre class="programlisting">showDetails: true, ...

// This element will be initially visible unless the View-Model's
// showDetails property is changed to false
&lt;pdata-bind="visible: showDetails"&gt;All sorts of text here...&lt;/p&gt;</pre></div><p>As mentioned earlier, it can be very useful to connect the value of a checkbox or a radio button with the visible status of other elements on a page. This allows you to change what data is displayed on the page based on selections that the user makes. Here is a simple example:</p><div><pre class="programlisting">showDetails: false, ...

&lt;input type="checkbox" data-bind="checked: showDetails" name="showDetails" /&gt;

&lt;p data-bind="visible: showDetails"&gt;All sorts of text and details…&lt;/p&gt;</pre></div><p>This code will make the checkbox control the visibility of the paragraph element that would contain some text that you only want displayed if the checkbox is checked. This is probably simpler than code you would use in a normal web application, but it illustrates the basic point.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>The source property</h2></div></div></div><p>The <a id="id308" class="indexterm"/>source binding is designed to render a <a id="id309" class="indexterm"/>Kendo UI template using the value of a View-Model property. If the property is an array, then the Kendo UI framework will render the template for each element of the array. This template is specified by the data-template attribute attached to the HTML element in question, and should indicate the template by its <code class="literal">id</code> attribute. When the templates are rendered, they will be placed directly beneath the element with the source attribute in the DOM. This is <a id="id310" class="indexterm"/>why you would place the source attribute on the <code class="literal">tbody</code> element of a table so that the <code class="literal">tr</code> elements in the Kendo UI template will be rendered and placed directly beneath it in the DOM so that they will appear as rows in a <code class="literal">table</code>. This binding can work on any element where it makes sense to include a collection of lower level elements, a <code class="literal">table</code> is just a natural example; other good uses would be <code class="literal">ul</code>, <code class="literal">ol</code>, and <code class="literal">select</code> elements.</p><p>We saw the source binding with a table already in our code samples. I will paste a little of it here as a reminder:</p><div><pre class="programlisting">// table with the source binding on the tbody element
&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt;
&lt;th&gt;Favorite Food&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Live Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" data-bind="source: people"&gt;&lt;/tbody&gt;
&lt;/table&gt;
...
// the template that creates the rows
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: hairColor.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: favoriteFood.d" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td data-bind="text: dataString"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>This is a good example of using the <code class="literal">source</code> binding with an array of objects. The <code class="literal">source</code> binding can also be used with an array of simple values, in which case you would use the keyword <code class="literal">this</code> inside the template instead of a property name inside an object:</p><div><pre class="programlisting">&lt;script id="row-template" type="text/x-kendo/template"&gt;
&lt;tr&gt;
&lt;td data-bind="text: this"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>The <code class="literal">source</code> binding can also be used with a single object (as opposed to an array) in which case it <a id="id311" class="indexterm"/>behaves just like binding to an array with a single element. You can also bind to the View-Model itself if you want to access a single property within it as the <code class="literal">source,</code> in which case you reference the <code class="literal">source</code> as a property of the <code class="literal">this</code> keyword:</p><div><pre class="programlisting">// table with the source binding on the tbody element
&lt;table&gt;
&lt;caption&gt;People Data&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Hair Color&lt;/th&gt; &lt;th&gt;Favorite Food&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Live Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody data-template="row-template" data-bind="source: viewModel"&gt;&lt;/tbody&gt;
&lt;/table&gt;
...
// the template that creates the rows
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: this.name" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: this.hairColor" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: this.favoriteFood" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;button type="button" 
data-bind="click: deletePerson"&gt;Delete&lt;/button&gt;&lt;/td&gt;
&lt;td data-bind="text: dataString"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;
...
&lt;script type="text/javascript&gt;
var viewModel = kendo.observable({
name: "john",
hairColor: "blonde",
favoriteFood: "burger"
    });
...
&lt;/script&gt;</pre></div><p>Notice how the structure is the same as if you were referencing a single object, but we are using the <code class="literal">this</code> keyword since we are referencing the View-Model directly.</p><p>When binding to <a id="id312" class="indexterm"/>a <code class="literal">select</code> element, note that you can use an array of simple values or an array of objects. If you just an array of objects, use the <code class="literal">data-text-field</code> to indicate which property contains the text to display within each <code class="literal">option,</code> and use the <code class="literal">data-value-field</code> to indicate which property contains the value within each <code class="literal">option</code> element.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>The style property</h2></div></div></div><p>The <a id="id313" class="indexterm"/>style binding is a great way to create <a id="id314" class="indexterm"/>a dynamic relationship between data in your View-Model and CSS styles on your page. It is a very simple binding that creates a direct relationship between the properties in your View-Model and the styles in your markup. An example:</p><div><pre class="programlisting">&lt;span data-bind="style: {color: myColor, fontWeight: myFontWeight}" /&gt;
&lt;script type="text/javascript"&gt;
var viewModel = kendo.observable({
myColor: "orange",
myFontWeight: "bold"
    });
&lt;/script&gt;</pre></div><p>Obviously, this becomes a lot more useful if you tie some logic to the styles you are using in your page, such as changing the styles for alternating table rows or changing the color of text if it meets some special criteria (such as an overdrawn balance looking red).</p><p>Notice that we used the style property <code class="literal">fontWeight</code> which should look strange to you. If you need to reference styles that normally contain a hyphen (<code class="literal">font-weight</code>), you need to use a camel-cased version in the binding so that it works as a valid JavaScript property name. So <code class="literal">font-weight</code> becomes <code class="literal">fontWeight</code> in the actual binding statement.</p><p>Finally, if you set the style value to an empty string, it will reset the value back to its original setting.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>The value property</h2></div></div></div><p>The<a id="id315" class="indexterm"/> <code class="literal">value</code> binding works in a very similar way to the <code class="literal">text</code> binding, except that it sets the value of an input element instead of the text of a<a id="id316" class="indexterm"/> display element. The bound value in the View-Model is updated on blur by default, such as when you press <em>Tab</em> to leave the input element on the page. If you want the View-Model property to be updated based on a different DOM event, you can set that in the <code class="literal">data-value-update</code> property on the same element as the binding. We have already seen the use of the value binding in our code samples. Here is an example of using the data-value-update binding to customize some behavior:</p><div><pre class="programlisting">// the row template
&lt;script id="row-template" type="text/x-kendo-template"&gt;
&lt;tr&gt;
&lt;td&gt;&lt;input type="text" data-bind="value: name"
             data-value-update="keyup" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/script&gt;</pre></div><p>Remember that this is a two-way binding and is most useful for retrieving data from the users as they fill out a form.</p><p>Much like the <code class="literal">checked</code> binding that we saw above, the <code class="literal">value</code> binding works with <code class="literal">select</code> elements in a similar way. By binding the <code class="literal">value</code> of a <code class="literal">select</code> element to a string property, it will be bound to the value of the selected <code class="literal">option</code> element inside of the <code class="literal">select</code> element if the options have values, or the <code class="literal">text</code> of the selected <code class="literal">option</code> element if no <code class="literal">value</code> is present. Here is how this would look in the markup:</p><div><pre class="programlisting">// Binding using the value, the selectedCar property will be bound to the numbers
&lt;select data-bind="value: selectedCar"&gt;
&lt;option value="1"&gt;Honda&lt;/option&gt;
&lt;option value="2"&gt;Toyota&lt;/option&gt;
&lt;option value="3"&gt;Ford&lt;/option&gt;
&lt;/select&gt;

// Binding using the text, the selectedCar property will be bound to the text
// between the option tags
&lt;select data-bind="value: selectedCar"&gt;
&lt;option&gt;Honda&lt;/option&gt;
&lt;option&gt;Toyota&lt;/option&gt;
&lt;option&gt;Ford&lt;/option&gt;
&lt;/select&gt;</pre></div><p>Of course, you can also bind both the <code class="literal">source</code> and the <code class="literal">value</code> of a <code class="literal">select</code> element to the View-Model. You are not limited to a single binding in the <code class="literal">data-bind</code> property. Also, as you might expect, you can bind the value of a multiple-select element if you are binding it to an array (instead of a simple string) so that it can hold multiple values.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Declarative widgets through Data-Role MVVM attributes</h1></div></div></div><p>Kendo's MVVM also allows <a id="id317" class="indexterm"/>declarative initialization of widgets through the <code class="literal">data-role</code> attribute. Declarative initialization is a different method of creating Kendo widgets by using the <code class="literal">data-role</code> attribute <a id="id318" class="indexterm"/>instead of setting up the widget through JavaScript. This is not as flexible as the JavaScript method, but it does allow for a lot of functionality with almost no code at all. Here is a section of code taken from the Kendo UI Web website that shows some basic set up as an introduction. The full details for these widgets can be found there.</p><div><pre class="programlisting">&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;Widget&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;AutoComplete&lt;/h4&gt;
&lt;input data-role="autocomplete" data-text-field="name" 
data-bind="source: colors, value: autoCompleteValue"/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;ComboBox&lt;/h4&gt;
&lt;select data-role="combobox"
data-text-field="name" data-value-field="value" data-bind="source:
colors, value: comboBoxValue"&gt;&lt;/select&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;DatePicker&lt;/h4&gt;
&lt;input data-role="datepicker" data-bind="value: datePickerValue" /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;DropDownList&lt;/h4&gt;
&lt;select data-role="dropdownlist"
data-text-field="name" data-value-field="value" data-bind="source:
colors, value: dropDownListValue"&gt;&lt;/select&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;Grid&lt;/h4&gt;
&lt;div data-role="grid"
data-sortable="true" data-editable="true"
data-columns='["Name", "Price", "UnitsInStock", 
{"command": "destroy"}]'
data-bind="source: gridSource"&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;NumericTextBox&lt;/h4&gt;
&lt;input data-role="numerictextbox" data-format="c" 
data-bind="value: numericTextBoxValue" /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;Slider&lt;/h4&gt;
&lt;input data-role="slider" data-bind="value: sliderValue" /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;TimePicker&lt;/h4&gt;
&lt;input data-role="timepicker" data-bind="value: timePickerValue" /&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;TabStrip&lt;/h4&gt;
&lt;div data-role="tabstrip" data-animation="false"&gt;
&lt;ul&gt;
&lt;li class="k-state-active"&gt;First&lt;/li&gt;
&lt;li&gt;Second&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
&lt;h4&gt;First page:&lt;/h4&gt;
Pick a time: &lt;input data-role="timepicker" 
data-bind="value: timePickerValue"/&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;h4&gt;Second page:&lt;/h4&gt;
Time is: &lt;span data-bind="text:
displayTimePickerValue"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;h4&gt;TreeView&lt;/h4&gt;
&lt;div data-role="treeview"
data-animation="false"
data-drag-and-drop="true"
data-bind="source: treeviewSource"&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</pre></div><p>This is a great example of using multiple bindings together, and of which bindings rightly pertain to which widgets.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Summary</h1></div></div></div><p>The Kendo MVVM framework brings complicated interactive JavaScript into the realm of simple HTML attributes, templates, and View-Model functions. It is a very powerful feature and is one that you are likely to become very accustomed to using in your web pages. Keep in mind as you develop code that Kendo is a system in which features can be built together very nicely; for example, you could use a Kendo data source object as the source binding for a <code class="literal">table</code> or <code class="literal">select</code> list.</p><p>When you have powerful tools like this within your reach, you will find that function-rich pages become normal instead of exceptionally difficult and that your programming experience will be better than ever. In the next chapter, we will learn about the Kendo UI HTML Editor widget. This widget adds a full-featured HTML editing box to your web pages so that users can create content in a friendly input area with formatting, images, and hyperlinks. It is especially useful if users can contribute content on your site, such as with a blog or a forum.</p></div></body></html>