<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing TypeScript</h1>
                </header>
            
            <article>
                
<p>This book aims to provide you with a broad overview of TypeScript's features, its limitations, and its ecosystem. You will learn about the TypeScript language, development tools, design patterns, and recommended practices.</p>
<p>This chapter will give you an overview of the history behind TypeScript and introduce you to some of its basics.</p>
<p>In this chapter, you will learn about the following concepts:</p>
<ul>
<li>The TypeScript architecture</li>
<li>Type annotations</li>
<li>Variables and primitive data types</li>
<li>Operators</li>
<li>Flow control statements</li>
<li>Functions</li>
<li>Classes</li>
<li>Interfaces</li>
<li>Namespaces</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The TypeScript architecture</h1>
                </header>
            
            <article>
                
<p>In this section, we will focus on TypeScript's internal architecture and its original design goals.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Design goals</h1>
                </header>
            
            <article>
                
<p>The following list describes the main design goals and architectural decisions that shaped the way the TypeScript programming language looks today:</p>
<ul>
<li><strong>Statically identify JavaScript constructs that are likely to be errors</strong>: The engineers at Microsoft decided that the best way to identify and prevent potential runtime issues was to create a strongly-typed programming language and perform static type checking at compile time. The engineers also designed a language services layer to provide developers with better tools.</li>
<li><strong>High compatibility with existing JavaScript code</strong>: TypeScript is a superset of JavaScript; this means that any valid JavaScript program is also a valid TypeScript program (with a few small exceptions).</li>
<li><strong>Provide a structuring mechanism for larger pieces of code</strong>: TypeScript adds class-based object-orientation, interfaces, namespaces, and modules. These features will help us to structure our code in a much better way. We will also reduce potential integration issues within our development team and our code will become easier to maintain and scale by adhering to the best object-oriented principles and recommended practices.</li>
<li><strong>Impose no runtime overhead on emitted programs</strong>: It is common to differentiate between design time and execution time when thinking about TypeScript. We use the term <em>design time</em> or <em>compile time</em> to refer to the TypeScript code that we write while designing an application, while we use the term <em>execution time</em> or <em>runtime</em> to refer to the JavaScript code executed after compiling some TypeScript code.</li>
</ul>
<p style="padding-left: 60px">TypeScript adds some features to JavaScript, but those features are only available at design time. For example, we can declare interfaces in TypeScript, but since JavaScript doesn't support interfaces, the TypeScript compiler will not declare or try to emulate this feature at runtime (in the output JavaScript code).</p>
<p style="padding-left: 60px">The Microsoft engineers provided the TypeScript compiler with some mechanisms, such as <strong>code transformations</strong> (converting TypeScript features into plain JavaScript implementations) and <strong>type erasure</strong> (removing static type notation), to generate clean JavaScript code. Type erasure removes not only the type annotations, but also all the TypeScript-exclusive language features such as interfaces.</p>
<p style="padding-left: 60px">Furthermore, the generated code is highly compatible with web browsers as it targets the ECMAScript 3 specification by default, but it also supports ECMAScript 5 and ECMAScript 6. In general, we can use the TypeScript features when compiling to any of the available compilation targets, but sometimes some features will require ECMAScript 5 or a higher version as the compilation target.</p>
<ul>
<li><strong>Align with current and future ECMAScript proposals</strong>: TypeScript is not just compatible with existing JavaScript code; it is also compatible with some future versions of JavaScript. At first glance, we may think that some TypeScript features make it quite different from JavaScript, but the reality is that all the features available in TypeScript (except the type system features) follow the ECMAScript proposals, which means that many of the TypeScript files will eventually be available as native JavaScript features.</li>
<li><strong>Be a cross-platform development tool</strong>: Microsoft released TypeScript under the open source Apache license and it can be installed and executed in all major operating systems.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TypeScript components</h1>
                </header>
            
            <article>
                
<p>The TypeScript language has three main internal layers. Each of these layers is, in turn, divided into sublayers or components. In the following diagram, we can see the three layers (three different shades of gray) and each of their internal components (boxes):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-321 image-border" src="Images/7a5b02ad-cdc4-4ec9-a3cb-2982bb15ef2f.png" style="width:30.42em;height:12.42em;" width="704" height="287"/></div>
<div class="packt_infobox">In the preceding diagram, the acronym <strong>VS</strong> refers to Microsoft's Visual Studio, which is the official family of <strong>integrated development environments</strong> (<strong>IDEs</strong>) for all Microsoft products (including TypeScript). We will learn more about this and the other IDEs in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>Automating Your Development Workflow</em>.</div>
<p>Each of these main layers has a different purpose:</p>
<ul>
<li><strong>Language</strong>: Features the TypeScript language elements.</li>
<li><strong>Compiler</strong> Performs the parsing, type checking, and transformation of your TypeScript code to JavaScript code.</li>
<li><strong>Language services</strong>: Generates information that helps editors and other tools provide better assistance features, such as IntelliSense or automated refactoring.</li>
<li><strong>IDE integration (VS Shim)</strong>: The developers of the IDEs and text editors must perform some integration work to take advantage of the TypeScript features. TypeScript was designed to facilitate the development of tools that help to increase the productivity of JavaScript developers. Because of these efforts, integrating TypeScript with an IDE is not a complicated task. A proof of this is that the most popular IDEs these days include good TypeScript support.</li>
</ul>
<div class="packt_infobox">In other books and online resources, you may find references to the term <em>transpiler</em> instead of <em>compiler</em>. A <strong>transpiler</strong> is a type of compiler that takes the source code of a programming language as its input and outputs the source code into another programming language with a similar level of abstraction.<br/>
<br/>
We will learn more about the TypeScript language services and the TypeScript compiler in <a href="9cc3e5f2-72c1-4f3c-9ed8-ba2760eae2d8.xhtml" target="_blank">Chapter 15</a>, <em>Working with the TypeScript Compiler and the Language Services</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TypeScript language features</h1>
                </header>
            
            <article>
                
<p>Now that you have learned about the purpose of TypeScript, it's time to get our hands dirty and start writing some code.</p>
<p>Before you can start learning how to use some of the basic TypeScript building blocks, you will need to set up your development environment. The easiest and fastest way to start writing some TypeScript code is to use the online editor, available on the official TypeScript website at <a href="https://www.typescriptlang.org/play/index.html"><span class="URLPACKT">https://www.typescriptlang.org/play/index.html</span></a>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-322 image-border" src="Images/683b2ade-87db-499a-97f6-9dc9f1743a7c.png" style="width:100.92em;height:50.67em;" width="1211" height="608"/></div>
<p>The preceding screenshot shows the appearance of the TypeScript playground. If you visit the playground, you will be able to use the text editor on the left-hand side of the screen to write TypeScript code. The code will then be automatically compiled into JavaScript. The output code will be inserted in the text editor located on the right-hand side of the screen. If your TypeScript code is invalid, the JavaScript code on the right-hand side will not be updated.</p>
<p>Alternatively, if you prefer to be able to work offline, you can download and install the TypeScript compiler. If you work with a Visual Studio version older than Visual Studio 2015, you will need to download the official TypeScript extension from <a href="https://marketplace.visualstudio.com/"><span class="URLPACKT">https://marketplace.visualstudio.com/</span></a>. If you are working with a version of Visual Studio released after the 2015 version (or Visual Studio Code), you will not need to install the extension, as these versions includes TypeScript support by default.</p>
<div class="packt_infobox">There are TypeScript plugins available for many popular editors such as Sublime (<span class="URLPACKT"><a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin">https://github.com/Microsoft/TypeScript-Sublime-Plugin</a></span>) or Atom (<a href="https://atom.io/packages/atom-typescript"><span class="URLPACKT">https://atom.io/packages/atom-typescript</span></a>).</div>
<p>You can also use TypeScript from the command-line interface by downloading it as an <kbd>npm</kbd> module. Don't worry if you are not familiar with npm. For now, you only need to know that it stands for <strong>node package manager</strong> and is the default Node.js package manager. Node.js is an open source, cross-platform JavaScript runtime environment for executing JavaScript code server-side. To be able to use npm, you will need to install Node.js in your development environment. You will be able to find the Node.js installation files on the official website at <a href="https://nodejs.org/">https://nodejs.org/</a>.</p>
<p>Once you have installed Node.js in your development environment, you will be able to run the following command in a console or Terminal:</p>
<pre><strong>npm install -g typescript</strong></pre>
<div class="packt_infobox">Unix-based operating systems may require the use of the <kbd>sudo</kbd> command when installing global (<kbd>-g</kbd>) npm packages. The <kbd>sudo</kbd> command will prompt the user credentials and install the package using administrative privileges:<br/>
<br/>
<span><kbd>sudo npm install -g typescript</kbd></span></div>
<p>Create a new file named <kbd>test.ts</kbd>, and add the following code to it:</p>
<pre>let myNumberVariable: number = 1; 
console.log(myNumberVariable); </pre>
<p>Save the file into a directory of your choice and open a command-line interface. Navigate to the directory in which you saved the file and execute the following command:</p>
<pre><strong>tsc test.ts</strong></pre>
<p>If everything goes well, you will find a file named <kbd>test.js</kbd> in the same directory in which the <kbd>test.ts</kbd> file is located. Now you know how to compile your TypeScript code into JavaScript code.</p>
<p>You can execute the output JavaScript code using Node.js:</p>
<pre><strong>node test.js</strong></pre>
<p>Now that we know how to compile and execute TypeScript source code, we can start learning about some of the TypeScript features.</p>
<div class="packt_infobox">You will be able to learn more about editors, compiler options, and other TypeScript tools in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a><em>,</em> <em>Automating Your Development Workflow</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types</h1>
                </header>
            
            <article>
                
<p>As we have already learned, TypeScript is a typed superset of JavaScript. TypeScript added a static type system and optional static type annotations to JavaScript to transform it into a strongly-typed programming language.</p>
<p>TypeScript's type analysis occurs entirely at compile time and adds no runtime overhead to program execution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type inference and optional static type annotations</h1>
                </header>
            
            <article>
                
<p>The TypeScript language service is great at automatically detecting the type of a variable. However, there are certain cases where it is not able to automatically detect a type.</p>
<p>When the type inference system is not able to identify the type of a variable, it uses a type known as the <em>any</em> type. The any type is a value that represents all the existing types, and as a result, it is too flexible and unable to detect most errors, which is not a problem because TypeScript allows us to explicitly declare the type of a variable using what is known as <strong>optional static type annotations</strong>.</p>
<p>The optional static type annotations are used as constraints on program entities such as functions, variables, and properties so that compilers and development tools can offer better verification and assistance (such as IntelliSense) during software development.</p>
<p>Strong typing allows programmers to express their intentions in their code, both to themselves and to others in the development team.</p>
<p>For a variable, a type notation comes preceded by a colon after the name of a variable:</p>
<pre>let counter; // unknown (any) type 
let counter = 0; // number (inferred) 
let counter: number; // number 
let counter: number = 0; // number </pre>
<div class="packt_infobox">We have used the <kbd>let</kbd> keyword instead of the <kbd>var</kbd> keyword. The <kbd>let</kbd> keyword is a newer JavaScript construct that TypeScript makes available. We'll discuss the details later, but some common problems in JavaScript can be solved by using <kbd>let</kbd>, so, you should use <kbd>let</kbd> instead of <kbd>var</kbd> whenever possible.</div>
<p>As you can see, we declare the type of a variable after its name; this style of type notation is based on type theory and helps to reinforce the idea of types being optional.</p>
<p>When no type annotations are available, TypeScript will try to guess the type of the variable by examining the assigned values. For example, in the second line, in the preceding code snippet, we can see that the variable counter has been identified as a numeric variable, because its value is a numeric value. There is a process known as <strong>type inference</strong> that can automatically detect and assign a type to a variable. The any type is used as the type of a variable when the type inference system is not able to detect its type.</p>
<p>Please note that the companion source code might be slightly different from the code presented during the chapters. The companion source code uses namespaces to isolate each demo from all the other demos and sometimes appends numbers to the name of the variables to prevent naming conflicts. For example, the preceding code is included in the companion source code as follows:</p>
<pre>namespace type_inference_demo { 
    let counter1; // unknown (any) type 
    let counter2 = 0; // number (inferred) 
    let counter3: number; // number 
    let counter4: number = 0; // number 
} </pre>
<div class="packt_infobox">You will be able to learn more about the TypeScript type system in <a href="7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Working with Types</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variables, basic types, and operators</h1>
                </header>
            
            <article>
                
<p>The basic types are boolean, number, string, array, tuple, Object, object, null, undefined, {}, void, and enumerations. Let's learn about each of these basic types:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Data type</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p>Boolean</p>
</td>
<td>
<p>Whereas the string and number data types can have a virtually unlimited number of different values, the boolean data type can only have two. They are the literals: <kbd>true</kbd> and <kbd>false</kbd>. A boolean value is a truth value; it specifies whether the condition is true or not:</p>
<pre>let isDone:   boolean = false;   </pre></td>
</tr>
<tr>
<td>
<p>Number</p>
</td>
<td>
<p>As in JavaScript, all numbers in TypeScript are floating-point values. These floating-point numbers get the type <kbd>number</kbd>:</p>
<pre>let height:   number = 6;   </pre></td>
</tr>
<tr>
<td>
<p>String</p>
</td>
<td>
<p>We use the <kbd>string</kbd> data type to represent text in TypeScript. You include string literals in your scripts by enclosing them in single or double quotation marks. Double quotation marks can be contained in strings surrounded by single quotation marks and single quotation marks can be contained in strings surrounded by double quotation marks:</p>
<pre>let name: string   = "bob";   
name = 'Smith';   </pre></td>
</tr>
<tr>
<td>
<p>Array</p>
</td>
<td>
<p>We use the <kbd>array</kbd> data type to represent a collection of values. The <kbd>array</kbd> type can be written using two different syntax styles. We can use the type of the elements in the array followed by brackets <kbd>[]</kbd> to annotate a collection of that element type:</p>
<pre>let list: number[]   = [1, 2, 3];   </pre>
<p>The second syntax style uses a generic array type named <kbd>Array&lt;T&gt;</kbd>:</p>
<pre>let list: Array&lt;number&gt;   = [1, 2, 3];   </pre></td>
</tr>
<tr>
<td>
<p>Tuple</p>
</td>
<td>
<p>Tuple types can be used to represent an array with a fixed number of elements with different types where the type is known. For example, we can represent a value as a pair of a string and a number:</p>
<pre>let x: [string,   number];   
x = ["hello",   10]; // OK   
x = ["world",   20]; // OK   
x = [10, "hello"];   // Error   
x = [20, "world"];   // Error   </pre></td>
</tr>
<tr>
<td>
<p>Enum</p>
</td>
<td>
<p>We use enumerations to add more meaning to a set of values. Enumerations can be numeric or text-based. By default, numeric enumerations assign the value 0 to the first member in the enumeration and increase it by one for each of the members in the enumeration:</p>
<pre>enum Color {Red,   Green, Blue};   
let c: Color =   Color.Green;   </pre></td>
</tr>
<tr>
<td>
<p>Any</p>
</td>
<td>
<p>All types in TypeScript are subtypes of a single top type called the <strong>any</strong> <strong>type</strong>. The <kbd>any</kbd> keyword references this type. The any type eliminates most of the TypeScript type checks and represents all the possible types:</p>
<pre>let notSure: any   = 4; // OK   
notSure = "maybe   a string instead"; // OK   
notSure =   false; // OK   </pre>
<p>The <kbd>any</kbd> type can be useful while migrating existing JavaScript code to TypeScript, or when we know some details about a type but we don't know all its details. For example, when we know that a type is an array, but we don't know the type of the elements in such an array:</p>
<pre>let list: any[] =   [1, true, "free"];   
list[1] = 100;   </pre></td>
</tr>
<tr>
<td>
<p>object (lowercase)</p>
</td>
<td>
<p>The <kbd>object</kbd> type represents any non-primitive type. The following types are considered to be primitive types in JavaScript: boolean, number, string, symbol, null, and undefined.</p>
</td>
</tr>
<tr>
<td>
<p>Object (uppercase)</p>
</td>
<td>
<p>In JavaScript, all objects are derived from the <kbd>Object</kbd> class. <kbd>Object</kbd> (uppercase) describes functionality that is common to all JavaScript objects. That includes the <kbd>toString()</kbd> and the <kbd>hasOwnProperty()</kbd> methods, for example.</p>
</td>
</tr>
<tr>
<td>
<p>Empty object type {}</p>
</td>
<td>
<p>This describes an object that has no members of its own. TypeScript issues a compile-time error when you try to access arbitrary properties of such an object:</p>
<pre>const obj =   {};    
obj.prop = "value";   // Error   </pre></td>
</tr>
<tr>
<td>
<p>Null and undefined</p>
</td>
<td>
<p>In TypeScript, both undefined and null are types. By default, null and undefined are subtypes of all other types. That means you can assign null and undefined to something like a number.</p>
<p>However, when using the <kbd>--strictNullChecks</kbd> flag, null and undefined are only assignable to void and their respective types.</p>
</td>
</tr>
<tr>
<td>
<p>Never</p>
</td>
<td>
<p>The <kbd>never</kbd> type is used in the following two places:</p>
<ul>
<li>As the return type of functions that never return</li>
<li>As the type of variables under type guards that are never true</li>
</ul>
<pre>   
function   impossibleTypeGuard(value: any) {   
    if (   
        typeof   value === "string" &amp;&amp;   
        typeof   value === "number"   
    ) {   
        value; //   Type never   
    }    
}   </pre></td>
</tr>
<tr>
<td>
<p>Void</p>
</td>
<td>
<p>In some ways the opposite of <kbd>any</kbd> is  <kbd>void</kbd>, the absence of having any type at all. You will see this as the return type of functions that do not return a value:</p>
<pre>function   warnUser(): void {   
    console.log("This   is my warning message");   
}   </pre></td>
</tr>
</tbody>
</table>
<p>In TypeScript and JavaScript, undefined is a property in the global scope that is assigned as a value to variables that have been declared but have not yet been initialized. The value <kbd>null</kbd> is a literal (not a property of the global object) and it can be assigned to a variable as a representation of no value:</p>
<pre>let testVar; // variable is declared but not initialized 
consoe.log(testVar); // shows undefined  
console.log(typeof testVar); // shows undefined 
 
let testVar = null; // variable is declared, and null is assigned as its value 
cosole.log(testVar); // shows null  
console.log(typeof testVar); // shows object </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variable scope (var, let, and const)</h1>
                </header>
            
            <article>
                
<p>When we declare a variable in TypeScript, we can use the <kbd>var</kbd>, <kbd>let</kbd>, or <kbd>const</kbd> keywords:</p>
<pre>var myNumber: number = 1; 
let isValid: boolean = true; 
const apiKey: string = "0E5CE8BD-6341-4CC2-904D-C4A94ACD276E"; </pre>
<p>Variables declared with <kbd>var</kbd> are scoped to the nearest function block (or global, if outside a function block).</p>
<p>Variables declared with <kbd>let</kbd> are scoped to the nearest enclosing block (or global, if outside any block), which can be smaller than a function block.</p>
<p>The <kbd>const</kbd> keyword creates a constant that can be global or local to the block in which it is declared. This means that constants are block-scoped.</p>
<div class="packt_infobox">You will learn more about scopes in <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Arithmetic operators</h1>
                </header>
            
            <article>
                
<p>TypeScript supports the following arithmetic operators. We must assume that variable <kbd>A</kbd> holds <kbd>10</kbd> and variable <kbd>B</kbd> holds <kbd>20</kbd> to understand the following examples:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>-</kbd></p>
</td>
<td>
<p>Subtracts the second operand from the first.</p>
</td>
<td>
<p><em>A - B</em> will give <kbd>-10</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>+</kbd></p>
</td>
<td>
<p>Adds two operands.</p>
</td>
<td>
<p><em>A + B</em> will give <kbd>30</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>*</kbd></p>
</td>
<td>
<p>Multiplies both the operands.</p>
</td>
<td>
<p><em>A * B</em> will give <kbd>200</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>**</kbd></p>
</td>
<td>
<p>Multiplies the first operand by itself a number of times which is indicated by the second operand.</p>
</td>
<td>
<p><em>A ** B</em> will give <em>1e+20</em></p>
</td>
</tr>
<tr>
<td>
<p><kbd>%</kbd></p>
</td>
<td>
<p>This is the modulus operator and remainder after an integer division.</p>
</td>
<td>
<p><em>B % A</em> will give <kbd>0</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>/</kbd></p>
</td>
<td>
<p>Divides the numerator by the denominator.</p>
</td>
<td>
<p><em>B / A</em> will give <kbd>2</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>--</kbd></p>
</td>
<td>
<p>Decreases an integer value by one.</p>
</td>
<td>
<p><em>A--</em> will give <kbd>9</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>++</kbd></p>
</td>
<td>
<p>Increases an integer value by one.</p>
</td>
<td>
<p><em>A++</em> will give <kbd>11</kbd></p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Comparison operators</h1>
                </header>
            
            <article>
                
<p>TypeScript supports the following comparison operators. To understand the examples, you must assume that variable <kbd>A</kbd> holds <kbd>10</kbd> as value and variable <kbd>B</kbd> holds <kbd>20</kbd> as value:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>==</kbd></p>
</td>
<td>
<p>Checks whether the values of two operands are equal or not. This operator uses type coercion. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p><em>(A == B)</em> is false. A == "10" is true.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>===</kbd></p>
</td>
<td>
<p>Checks whether the value and type of two operands are equal or not. This operator doesn't use type coercion. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>A === B is false. A === "10" is false.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>!=</kbd></p>
</td>
<td>
<p>Checks whether the value of two operands are equal or not. If the values are not equal, then the condition becomes <kbd>true</kbd>. This operator uses type coercion.</p>
</td>
<td>
<p>(A != B) is true. A != "10" is false.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>!==</kbd></p>
</td>
<td>
<p>Checks whether the value of two operands are equal or not. If the values are not equal, then the condition becomes <kbd>true</kbd>. This operator doesn't use type coercion.</p>
</td>
<td>
<p>A !== B is true. A !== "10" is true.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&gt;</kbd></p>
</td>
<td>
<p>Checks whether the value of the left operand is greater than the value of the right operand. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A &gt; B) is false.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;</kbd></p>
</td>
<td>
<p>Checks whether the value of the left operand is less than the value of the right operand. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A &lt; B) is true.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&gt;=</kbd></p>
</td>
<td>
<p>Checks whether the value of the left operand is greater than or equal to the value of the right operand. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A &gt;= B) is false.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;=</kbd></p>
</td>
<td>
<p>Checks whether the value of the left operand is less than or equal to the value of the right operand. If yes, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A &lt;= B) is true.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Logical operators</h1>
                </header>
            
            <article>
                
<p>TypeScript supports the following logical operators. To understand the examples, you must assume that variable <kbd>A</kbd> holds <kbd>10</kbd> and variable <kbd>B</kbd> holds <kbd>20</kbd>:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&amp;&amp;</kbd></p>
</td>
<td>
<p>Known as the logical <kbd>AND</kbd> operator. If both the operands are nonzero, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A &amp;&amp; B) is true.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>||</kbd></p>
</td>
<td>
<p>Known as the logical <kbd>OR</kbd> operator. If any of the two operands are nonzero, then the condition becomes <kbd>true</kbd>.</p>
</td>
<td>
<p>(A || B) is true.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>!</kbd></p>
</td>
<td>
<p>Known as the logical <kbd>NOT</kbd> operator. It is used to reverse the logical state of its operand. If a condition is <kbd>true</kbd>, then the logical <kbd>NOT</kbd> operator will make it <kbd>false</kbd>.</p>
</td>
<td>
<p>!(A &amp;&amp; B) is false.</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bitwise operators</h1>
                </header>
            
            <article>
                
<p>TypeScript supports the following bitwise operators. To understand the examples, you must assume that variable <kbd>A</kbd> holds <kbd>2</kbd> as value and variable <kbd>B</kbd> holds <kbd>3</kbd> as value:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&amp;</kbd></p>
</td>
<td>
<p>Known as the bitwise <kbd>AND</kbd> operator, it performs a boolean <kbd>AND</kbd> operation on each bit of its integer arguments.</p>
</td>
<td>
<p>(A &amp; B) is 2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>|</kbd></p>
</td>
<td>
<p>Known as the bitwise <kbd>OR</kbd> operator, it performs a boolean <kbd>OR</kbd> operation on each bit of its integer arguments.</p>
</td>
<td>
<p>(A | B) is 3.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>^</kbd></p>
</td>
<td>
<p>Known as the bitwise <kbd>XOR</kbd> operator, it performs a boolean exclusive <kbd>OR</kbd> operation on each bit of its integer arguments. Exclusive <kbd>OR</kbd> means that either operand one is true or operand two is true, but not both.</p>
</td>
<td>
<p>(A ^ B) is 1.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>~</kbd></p>
</td>
<td>
<p>Known as the bitwise <kbd>NOT</kbd> operator, it is a unary operator and operates by reversing all bits in the operand.</p>
</td>
<td>
<p>(~B) is -4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;&lt;</kbd></p>
</td>
<td>
<p>Known as the bitwise shift-left operator. It moves all bits in its first operand to the left by the number of places specified in the second operand. New bits are filled with zeros. Shifting a value left by one position is equivalent to multiplying by two, shifting two positions is equivalent to multiplying by four, and so on.</p>
</td>
<td>
<p>(A &lt;&lt; 1) is 4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&gt;&gt;</kbd></p>
</td>
<td>
<p>Known as the bitwise shift-right with sign operator. It moves all bits in its first operand to the right by the number of places specified in the second operand.</p>
</td>
<td>
<p>(A &gt;&gt; 1) is 1</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&gt;&gt;&gt;</kbd></p>
</td>
<td>
<p>Known as the bitwise shift-right with zero operators. This operator is just like the <kbd>&gt;&gt;</kbd> operator, except that the bits shifted from the left are always zero.</p>
</td>
<td>
<p>(A &gt;&gt;&gt; 1) is 1</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_infobox">One of the main reasons to use bitwise operators in languages such as C++, Java, or C# is that they're extremely fast. However, bitwise operators are often considered not that efficient in TypeScript and JavaScript. The bitwise operators are less efficient in JavaScript, because it is necessary to cast from floating-point representation (how JavaScript stores all of its numbers) to a 32-bit integer to perform the bit manipulation and back.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Assignment operators</h1>
                </header>
            
            <article>
                
<p>TypeScript supports the following assignment operators:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
<td>
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>=</kbd></p>
</td>
<td>
<p>Assigns the values from the right-side operands to the left-side operand.</p>
</td>
<td>
<p>C = A + B will assign the value of A + B into C</p>
</td>
</tr>
<tr>
<td>
<p><kbd>+=</kbd></p>
</td>
<td>
<p>Adds the right operand to the left operand and assigns the result to the left operand.</p>
</td>
<td>
<p>C += A is equivalent to C = C + A</p>
</td>
</tr>
<tr>
<td>
<p><kbd>-=</kbd></p>
</td>
<td>
<p>Substracts the right operand from the left operand and assigns the result to the left operand.</p>
</td>
<td>
<p>C -= A is equivalent to C = C - A</p>
</td>
</tr>
<tr>
<td>
<p><kbd>*=</kbd></p>
</td>
<td>
<p>Multiplies the right operand by the left operand and assigns the result to the left operand.</p>
</td>
<td>
<p>C *= A is equivalent to C = C * A</p>
</td>
</tr>
<tr>
<td>
<p><kbd>/=</kbd></p>
</td>
<td>
<p>Divides the left operand by the right operand and assigns the result to the left operand.</p>
</td>
<td>
<p>C /= A is equivalent to C = C / A</p>
</td>
</tr>
<tr>
<td>
<p><kbd>%=</kbd></p>
</td>
<td>
<p>Calculates the modulus using two operands and assigns the result to the left operand.</p>
</td>
<td>
<p>C %= A is equivalent to C = C % A</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spread operator</h1>
                </header>
            
            <article>
                
<p>The spread operator can be used to initialize arrays and objects from another array or object:</p>
<pre>let originalArr1 = [ 1, 2, 3]; 
let originalArr2 = [ 4, 5, 6]; 
let copyArr = [...originalArr1]; 
let mergedArr = [...originalArr1, ...originalArr2]; 
let newObjArr = [...originalArr1, 7, 8]; </pre>
<p>The preceding code snippet showcases the usage of the spread operator with arrays, while the following code snippet showcases its usage with object literals:</p>
<pre>let originalObj1 = {a: 1, b: 2, c: 3}; 
let originalObj2 = {d: 4, e: 5, f: 6}; 
let copyObj = {...originalObj1}; 
let mergedObj = {...originalObj1, ...originalObj2}; 
let newObjObj = {... originalObj1, g: 7, h: 8}; </pre>
<p>The spread operator can also be used to expand to an expression into multiple arguments (in function calls), but we will skip that use case for now.</p>
<div class="packt_infobox">We will learn more about the spread operator in <a href="82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml">Chapter 3</a>, <em>Working with Functions</em> and <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a>, <em>Object-Oriented Programming with TypeScript</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flow control statements</h1>
                </header>
            
            <article>
                
<p>This section describes the decision-making statements, the looping statements, and the branching statements supported by the TypeScript programming language.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The single-selection structure (if)</h1>
                </header>
            
            <article>
                
<p>The following code snippet declares a variable of type boolean and name <kbd>isValid</kbd>. Then, an <kbd>if</kbd> statement will check whether the value of <kbd>isValid</kbd> is equal to <kbd>true</kbd>. If the statement turns out to be <kbd>true</kbd>, the <kbd>Is valid!</kbd> message will be displayed on the screen:</p>
<pre>let isValid: boolean = true; 
 
if (isValid) { 
  console.log("is valid!"); 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The double-selection structure (if...else)</h1>
                </header>
            
            <article>
                
<p>The following code snippet declares a variable of type boolean and name <kbd>isValid</kbd>. Then, an <kbd>if</kbd> statement will check whether the value of <kbd>isValid</kbd> is equal to <kbd>true</kbd>. If the statement turns out to be <kbd>true</kbd>, the message <kbd>Is valid!</kbd> will be displayed on the screen. On the other hand, if the statement turns out to be <kbd>false</kbd>, the message <kbd>Is NOT valid!</kbd> will be displayed on the screen:</p>
<pre>let isValid: boolean = true; 
 
if (isValid) { 
  console.log("Is valid!"); 
} else { 
  console.log("Is NOT valid!"); 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The inline ternary operator (?)</h1>
                </header>
            
            <article>
                
<p>The inline ternary operator is just an alternative way of declaring a double-selection structure:</p>
<pre>let isValid: boolean = true; 
let message = isValid ? "Is valid!" : "Is NOT valid!"; 
console.log(message); </pre>
<p>The preceding code snippet declares a variable of type boolean and name <kbd>isValid</kbd>. Then, it checks whether the variable or expression on the left-hand side of the operator <kbd>?</kbd> is equal to <kbd>true</kbd>.</p>
<p>If the statement turns out to be <kbd>true</kbd>, the expression on the left-hand side of the character will be executed and the message <kbd>Is valid!</kbd> will be assigned to the message variable.</p>
<p>On the other hand, if the statement turns out to be <kbd>false</kbd>, the expression on the right-hand side of the operator will be executed and the message, <kbd>Is NOT valid!</kbd> will be assigned to the message variable.</p>
<p>Finally, the value of the message variable is displayed on the screen.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The multiple-selection structure (switch)</h1>
                </header>
            
            <article>
                
<p>The <kbd>switch</kbd> statement evaluates an expression, matches the expression's value to a case clause, and executes statements associated with that case. Switch statements and enumerations are often used together to improve the readability of the code.</p>
<p>In the following example, we declare a function that takes an enumeration named <kbd>AlertLevel</kbd>.</p>
<div class="packt_infobox">You will learn more about enumerations in <a href="7211d7ea-dc2f-4ff0-bb19-14400bb911bc.xhtml">Chapter 2</a>, <em>Working with Types.</em></div>
<p>Inside the function, we will generate an array of strings to store email addresses and execute a <kbd>switch</kbd> structure. Each of the options of the enumeration is a case in the <kbd>switch</kbd> structure:</p>
<pre>enum AlertLevel{ <br/> info, 
  warning, 
  error   
} 
 
function getAlertSubscribers(level: AlertLevel){ 
  let emails = new Array&lt;string&gt;(); 
  switch(level){ 
  case AlertLevel.info: 
     emails.push("cst@domain.com"); 
     break; 
  case AlertLevel.warning: 
     emails.push("development@domain.com"); 
     emails.push("sysadmin@domain.com"); 
     break; 
  case AlertLevel.error: 
    emails.push("development@domain.com"); 
    emails.push("sysadmin@domain.com"); 
    emails.push("management@domain.com"); 
    break; 
  default: 
    throw new Error("Invalid argument!"); 
  } 
  return emails; 
} 
 
getAlertSubscribers(AlertLevel.info); // ["cst@domain.com"] 
getAlertSubscribers(AlertLevel.warning); // <br/> ["development@domain.com", "sysadmin@domain.com"]</pre>
<p>The value of the <kbd>level</kbd> variable is tested against all the cases in the <kbd>switch</kbd>. If the variable matches one of the cases, the statement associated with that case is executed. Once the <kbd>case</kbd> statement has been executed, the variable is tested against the next case.</p>
<p>Once the execution of the statement associated with a matching case is finalized, the next case will be evaluated. If the <kbd>break</kbd> keyword is present, the program will not continue the execution of the following <kbd>case</kbd> statement.</p>
<p>If no matching case clause is found, the program looks for the optional <kbd>default</kbd> clause, and if found, it transfers control to that clause and executes the associated statements.</p>
<p>If no <kbd>default</kbd> clause is found, the program continues execution at the statement following the end of switch. By convention, the <kbd>default</kbd> clause is the last clause, but it does not have to be so.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The expression is tested at the top of the loop (while)</h1>
                </header>
            
            <article>
                
<p>The <kbd>while</kbd> expression is used to repeat an operation while a certain requirement is satisfied. For example, the following code snippet declares a numeric variable <kbd>i</kbd>. If the requirement (the value of <kbd>i</kbd> is less than <kbd>5</kbd>) is satisfied, an operation takes place (increase the value of <kbd>i</kbd> by one and display its value in the browser console). Once the operation has completed, the accomplishment of the requirement will be checked again:</p>
<pre>let i: number = 0; 
while (i &lt; 5) { 
  i += 1; 
  console.log(i); 
} </pre>
<p>In a <kbd>while</kbd> expression, the operation will take place only if the requirement is satisfied.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The expression is tested at the bottom of the loop (do...while)</h1>
                </header>
            
            <article>
                
<p>The <kbd>do...while</kbd> expression can be used to repeat an instruction until a certain requirement is not satisfied. For example, the following code snippet declares a numeric variable <kbd>i</kbd> and repeats an operation (increase the value of <kbd>i</kbd> by <kbd>one</kbd> and display its value in the browser console) for as long as the requirement (the value of <kbd>i</kbd> is less than <kbd>five</kbd>) is satisfied:</p>
<pre>let i: number = 0; 
do { 
  i += 1; 
  console.log(i); 
} while (i &lt; 5); </pre>
<p>Unlike the <kbd>while</kbd> loop, the <kbd>do...while</kbd> expression will execute at least once, regardless of the tested expression, as the operation will take place before checking whether a certain requirement is satisfied or not.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Iterate on each object's properties (for...in)</h1>
                </header>
            
            <article>
                
<p>The <kbd>for...in</kbd> statement by itself is not a <em>bad practice</em>; however, it can be misused, for example, to iterate over arrays or array-like objects. The purpose of the <kbd>for...in</kbd> statement is to enumerate over object properties:</p>
<pre>let obj: any = { a: 1, b: 2, c: 3 }; 
 
for (let key in obj) { 
    if (obj.hasOwnProperty(key)) { 
        console.log(key + " = " + obj[key]); 
    } 
} 
 
// Output: 
// "a = 1" 
// "b = 2" 
// "c = 3" </pre>
<p>The following code snippet will go up in the prototype chain, also enumerating the inherited properties. The <kbd>for...in</kbd> statement iterates the entire prototype chain, also enumerating the inherited properties. When you want to enumerate only the object's properties that aren't inherited, you can use the <kbd>hasOwnProperty</kbd> method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Iterate values in an iterable (for...of)</h1>
                </header>
            
            <article>
                
<p>In JavaScript, some built-in types are built-in iterables with a default iteration behavior. To be an iterable, an object must implement the <kbd>@@iterator</kbd> method, meaning that the object (or one of the objects in its prototype chain) must have a property with a <kbd>@@iterator</kbd> key, which is available via constant <kbd>Symbol.iterator</kbd>.</p>
<p>The <kbd>for...of</kbd> statement creates a loop iterating over iterable objects (including array, map, set, string, arguments object, and so on):</p>
<pre>let iterable = [10, 20, 30]; 
 
for (let value of iterable) { 
  value += 1; 
  console.log(value); 
} </pre>
<div class="packt_infobox">You will learn more about iterables in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>, Object-Oriented Programming with TypeScript</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Counter-controlled repetition (for)</h1>
                </header>
            
            <article>
                
<p>The <kbd>for</kbd> statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement or a set of statements executed in the loop:</p>
<pre>for (let i: number = 0; i &lt; 9; i++) { 
   console.log(i); 
} </pre>
<p>The preceding code snippet contains a <kbd>for</kbd> statement. It starts by declaring the variable <kbd>i</kbd> and initializing it to <kbd>0</kbd>. It checks whether <kbd>i</kbd> is less than <kbd>9</kbd>, performs the two succeeding statements, and increments <kbd>i</kbd> by one after each pass through the loop.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions</h1>
                </header>
            
            <article>
                
<p>Just as in JavaScript, TypeScript functions can be created either as a named function or as an anonymous function, which allows us to choose the most appropriate approach for an application, whether we are building a list of functions in an API or a one-off function to hand over to another function:</p>
<pre>// named function 
function greet(name?: string): string { 
  if(name){ 
    return "Hi! " + name; 
  } else { 
    return "Hi!"; 
  } 
} 
 
// anonymous function 
let greet = function(name?: string): string { 
  if (name) { 
    return "Hi! " + name; 
  } else { 
    return "Hi!"; 
  } 
} </pre>
<p>As we can see in the preceding code snippet, in TypeScript, we can add types to each of the parameters and then to the function itself to add a return type. TypeScript can infer the return type by looking at the <kbd>return</kbd> statements, so we can also optionally leave this off in many cases.</p>
<p>There is an alternative syntax for functions that use the <kbd>=&gt;</kbd> operator after the return type and don't use the <kbd>function</kbd> keyword:</p>
<pre>let greet = (name: string): string =&gt; { 
    if(name){ 
      return "Hi! " + name; 
    } 
    else 
    { 
      return "Hi"; 
    } 
}; </pre>
<p>Now that we have learned about this alternative syntax, we can return to the previous example, in which we were assigning an anonymous function to the <kbd>greet</kbd> variable. We can now add the type annotations to the <kbd>greet</kbd> variable to match the anonymous function signature:</p>
<pre>let greet: (name: string) =&gt; string = function(name: string): <br/> string { 
    if (name) { 
      return "Hi! " + name; 
    } else { 
      return "Hi!"; 
    } 
}; </pre>
<div class="packt_infobox">Keep in mind that the arrow function (<kbd>=&gt;</kbd>) syntax changes the way the <kbd>this</kbd> keyword works when working with classes. We will learn more about this in the upcoming chapters.</div>
<p>Now you know how to add type annotations to force a variable to be a function with a specific signature. The usage of this kind of annotation is really common when we use a callback (functions used as an argument of another function):</p>
<pre>function add( 
    a: number, b: number, callback: (result: number) =&gt; void 
) { 
    callback(a + b); 
} </pre>
<p>In the preceding example, we are declaring a function named <kbd>add</kbd> that takes two numbers and a <kbd>callback</kbd> as a function. The type annotations will force the callback to return <kbd>void</kbd> and take a number as its only argument.</p>
<div class="packt_infobox">We will focus on functions in <a href="82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml">Chapter 3</a><em>,</em> <em>Working with Functions</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p>ECMAScript 6, the next version of JavaScript, adds class-based object-orientation to JavaScript and, since TypeScript includes all the features available in ES6, developers are allowed to use class-based object orientation today, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</p>
<p>Let's take a look at a simple TypeScript class definition example:</p>
<pre>class Character { 
  public fullname: string; 
  public constructor(firstname: string, lastname: string) { 
    this.fullname = `${firstname} ${lastname}`; 
  } 
  public greet(name?: string) { 
    if (name) { 
      return `Hi! ${name}! my name is ${this.fullname}`; 
    } else { 
      return `Hi! my name is ${this.fullname}`; 
    } 
  } 
} 
 
let spark = new Character("Jacob","Keyes"); 
let msg = spark.greet();              
console.log(msg); // "Hi! my name is Jacob Keyes" 
 
let msg1 = spark.greet("Dr. Halsey");  
console.log(msg1); // "Hi! Dr. Halsey! my name is Jacob Keyes" </pre>
<p>In the preceding example, we have declared a new class, <kbd>Character</kbd>. This class has three members: a property called <kbd>fullname</kbd>, a <kbd>constructor</kbd>, and a method <kbd>greet</kbd>. When we declare a class in TypeScript, all the methods and properties are public by default. We have used the <kbd>public</kbd> keyword to be more explicit; being explicit about the accessibility of the class members is recommended but it is not a requirement.</p>
<p>You'll notice that when we refer to one of the members of the class (from within itself), we prepend the <kbd>this</kbd> operator. The <kbd>this</kbd> operator denotes that it's a member access. In the last lines, we construct an instance of the <kbd>Character</kbd> class using a <kbd>new</kbd> operator. This calls into the constructor we defined earlier, creating a new object with the <kbd>Character</kbd> shape and running the constructor to initialize it.</p>
<p>TypeScript classes are compiled into JavaScript functions in order to achieve compatibility with ECMAScript 3 and ECMAScript 5.</p>
<div class="packt_infobox">We will learn more about classes and other object-oriented programming concepts in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>,</em> <em>Object-Oriented Programming with TypeScript</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p>In TypeScript, we can use interfaces to ensure that a class follows a particular specification:</p>
<pre>interface LoggerInterface{ 
    log(arg: any): void; 
} 
 
class Logger implements LoggerInterface { 
    log (arg: any){ 
        if (typeof console.log === "function") { 
            console.log(arg); 
        } else { 
            console.log(arg); 
        } 
    } 
} </pre>
<p>In the preceding example, we have defined an interface <kbd>LoggerInterface</kbd> and a class <kbd>Logger</kbd>, which implements it. TypeScript will also allow you to use interfaces to declare the type of an object. This can help us to prevent many potential issues, especially when working with object literals:</p>
<pre>interface UserInterface { 
    name: string; 
    password: string; 
} 
 
// Error property password is missing 
let user: UserInterface = { 
    name: "" 
}; </pre>
<div class="packt_infobox">We will learn more about interfaces and other object-oriented programming concepts in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>,</em> <em>Object-Oriented Programming with TypeScript</em>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Namespaces</h1>
                </header>
            
            <article>
                
<p>Namespaces, also known as <strong>internal modules</strong>, are used to encapsulate features and objects that share a certain relationship. Namespaces will help you to organize your code. To declare a namespace in TypeScript, you will use the <kbd>namespace</kbd> and <kbd>export</kbd> keywords:</p>
<div class="packt_infobox">In older versions of TypeScript, the keyword to define an internal module was <kbd>module</kbd> instead of <kbd>namespace</kbd>.</div>
<pre>namespace geometry { 
    interface VectorInterface { 
        /* ... */ 
    } 
    export interface Vector2DInterface { 
        /* ... */ 
    } 
    export interface Vector3DInterface { 
        /* ... */ 
    } 
    export class Vector2D 
        implements VectorInterface, Vector2dInterface { 
        /* ... */ 
    } 
    export class Vector3D 
        implements VectorInterface, Vector3DInterface { 
        /* ... */ 
    } 
} 
 
let vector2DInstance: geometry.Vector2DInterface = new  
geometry.Vector2D(); 
let vector3DInstance: geometry.Vector3DInterface = new  
geometry.Vector3d(); </pre>
<p>In the preceding code snippet, we have declared a namespace that contains the classes <kbd>vector2D</kbd> and <kbd>vector3D</kbd> and the interfaces <kbd>VectorInterface</kbd>, <kbd>Vector2DInterface</kbd>, and <kbd>Vector3DInterface</kbd>. Note that the first interface is missing the keyword <kbd>export</kbd>. As a result, the interface <kbd>VectorInterface</kbd> will not be accessible from outside the module's scope.</p>
<div class="packt_infobox">Namespaces are a good way to organize your code; however, they are <strong>not the recommended way to organize your code</strong> in a TypeScript application. We will not get into more details about this topic for now, but we will learn more about internal and external modules and we'll discuss when each is appropriate and how to use them in <a href="841fbd7e-a358-479c-95f7-9cd3ec104446.xhtml">Chapter 4</a><em>, Object-Oriented Programming with TypeScript.</em></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Putting everything together</h1>
                </header>
            
            <article>
                
<p>Now that we have learned how to use the basic TypeScript building blocks individually, let's take a look at a final example in which we will use modules, classes, functions, and type annotations for each of these elements:</p>
<pre>namespace geometry_demo { 
     
    export interface Vector2DInterface { 
        toArray(callback: (x: number[]) =&gt; void): void; 
        length(): number; 
        normalize(): void; 
    } 
 
    export class Vector2D implements Vector2DInterface { 
        private _x: number; 
        private _y: number; 
        constructor(x: number, y: number) { 
            this._x = x; 
            this._y = y; 
        } 
        public toArray(callback: (x: number[]) =&gt; void): void { 
            callback([this._x, this._y]); 
        } 
        public length(): number { 
            return Math.sqrt( 
                this._x * this._x + this._y * this._y 
            ); 
        } 
        public normalize() { 
            let len = 1 / this.length(); 
            this._x *= len; 
            this._y *= len; 
        } 
    } 
 
} </pre>
<p>The preceding example is just a small portion of a basic 3D engine written in JavaScript. In 3D engines, there are a lot of mathematical calculations involving matrices and vectors. As you can see, we have defined a module <kbd>Geometry</kbd> that will contain some entities; to keep the example simple, we have only added the class <kbd>Vector2D</kbd>. This class stores two coordinates (<kbd>x</kbd> and <kbd>y</kbd>) in 2D space and performs some operations on the coordinates. One of the most widely used operations in vectors is normalization, which is one of the methods in our <kbd>Vector2D</kbd> class.</p>
<p>3D engines are complex software solutions, and as a developer, you are much more likely to use a third-party 3D engine than create your own. For this reason, it is important to understand that TypeScript will not only help you develop large-scale applications but also interact with complex libraries.</p>
<p>In the following code snippet, we will use the module declared earlier to create a <kbd>Vector2D</kbd> instance:</p>
<pre>let vector: geometry_demo.Vector2DInterface = new geometry_demo.Vector2D(2,3); 
vector.normalize(); 
vector.toArray(function(vectorAsArray: number[]){ 
  console.log(`x: ${vectorAsArray[0]}, y: ${vectorAsArray[1]}`); 
}); </pre>
<p>The type-checking and IntelliSense features will help us create a <kbd>Vector2D</kbd> instance, normalize its value, and convert it into an array to finally show its value on the screen with ease:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-323 image-border" src="Images/dc7c2a1d-a52d-41e2-9d8a-fdfcafe3026c.png" style="width:78.33em;height:14.67em;" width="940" height="176"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you have learned about the purposes of TypeScript. You have also learned about some of the design decisions made by the TypeScript engineers at Microsoft.</p>
<p>Toward the end of this chapter, you learned a lot about the basic building blocks of a TypeScript application, and we started to write some TypeScript code for the first time.</p>
<p>We now know the basics of type annotations, variables, primitive data types, operators, flow control statements, functions, interfaces, classes, and namespaces.</p>
<p>In the next chapter, we will learn more about the TypeScript type system.</p>


            </article>

            
        </section>
    </div>



  </body></html>