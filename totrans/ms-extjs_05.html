<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Advanced Dynamic Menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Dynamic Menu</h1></div></div></div><p>We already have the login capability that we implemented throughout <a class="link" href="ch03.html" title="Chapter 3. The Login Page">Chapter 3</a>, <span class="emphasis"><em>The Login Page</em></span>, and the base of the application, that we implemented in <a class="link" href="ch04.html" title="Chapter 4. The Logout and Multilingual Capabilities">Chapter 4</a>, <span class="emphasis"><em>The Logout and Multilingual Capabilities</em></span>. In the base of our application there is one missing piece, which is the menu. So the next thing we are going to develop is the dynamic menu.</p><p>Once the user has been authenticated, we are going to display the base screen of the application, which consists of a Viewport with a Border layout. On the left-hand side of the Viewport, we are going to display a menu. This menu will be dynamic, and the items that will be displayed on the menu depend on the permissions that the user has, which is why we call it a dynamic menu.</p><p>One of the options is to render all the screens of the system and then, depending on the user roles, we can hide or show them. However, this is not the approach we are going to use in this book. We are going to render and display only the screens the user has access to. The approach we are going to use is to dynamically render a menu according to the user entitlements.</p><p>So in this chapter, we will learn how to display a dynamic menu using different Ext JS components and layouts (that we have not covered yet). To summarize, in this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a dynamic menu with the Accordion layout and TreePanel</li><li class="listitem" style="list-style-type: disc">Using the Model association to load the data from the server</li><li class="listitem" style="list-style-type: disc">Handling the dynamic menu on the server</li><li class="listitem" style="list-style-type: disc">Opening a menu item dynamically</li><li class="listitem" style="list-style-type: disc">Using the MVC architecture</li></ul></div><div class="section" title="An overview of the dynamic menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>An overview of the dynamic menu</h1></div></div></div><p>So the first <a id="id426" class="indexterm"/>component that we are going to implement in this chapter is the dynamic menu. We could use only a TreePanel to display the menu, but we do like a challenge and we want to offer the best experience to the user. So, we are going to implement a dynamic menu using the Accordion layout and TreePanels, which results in a more advanced dynamic menu.</p><p>Our system consists<a id="id427" class="indexterm"/> of modules, and each module has subitems, which are the screens of our system. An accordion panel will represent the menu itself with all the modules; this way, the user can expand to see the options of each module at a time. And for the options of each module, we will use a TreePanel; each option of the menu will be a node from the TreePanel.</p><p>So, at the end of this topic, we will have a dynamic menu like the following screenshot:</p><div class="mediaobject"><img src="graphics/0457OT_05_01.jpg" alt="An overview of the dynamic menu"/></div><p>Before we get started with the dynamic menu, let's take a quick look at how the Ext JS TreePanel component works and how the Accordion layout works. Understanding these two concepts first will make it easier to understand how the dynamic menu is implemented.</p><div class="section" title="Ext JS TreePanel"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Ext JS TreePanel</h2></div></div></div><p>A TreePanel <a id="id428" class="indexterm"/>is<a id="id429" class="indexterm"/> the perfect component to display hierarchical data in an application. This is the reason why we will use it to display the menu. The following image exemplifies a TreePanel and its pieces:</p><div class="mediaobject"><img src="graphics/0457OT_05_02.jpg" alt="Ext JS TreePanel"/></div><p>As we learned in <a class="link" href="ch01.html" title="Chapter 1. Sencha Ext JS Overview">Chapter 1</a>, <span class="emphasis"><em>Sencha Ext JS Overview</em></span>, the TreePanel extends from the <code class="literal">Ext.panel.Table</code> class, and so does the GridPanel. The <code class="literal">Ext.panel.Table</code> class extends from the <code class="literal">Panel</code> class. All the <code class="literal">Panel</code> classes have a <span class="emphasis"><em>shell</em></span>, which is the panel itself, which allows us to set a title and add toolbars and also add child items.</p><p>The piece that is responsible for displaying the data is called the View, which is of the type <code class="literal">Ext.view.View</code>, and it is placed inside the <code class="literal">Panel</code> container. There are two ways that we can set data to a TreePanel: predefined using the <code class="literal">root</code> configuration or using a Store.</p><p>The Store behaves as our <a id="id430" class="indexterm"/>
<span class="strong"><strong>Data Access Object</strong></span> (<span class="strong"><strong>DAO</strong></span>). In this example, we will load data from the server, so we will use a Store. The Store loads a collection of objects that we call <code class="literal">Model</code> (<code class="literal">Ext.data.Model</code>). In the case of the TreePanel, these models are decorated with <code class="literal">NodeInterface</code> (<code class="literal">Ext.data.NodeInterface</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>For more information about the <a id="id431" class="indexterm"/>decorator pattern, please access <a class="ulink" href="http://en.wikipedia.org/wiki/Decorator_pattern">http://en.wikipedia.org/wiki/Decorator_pattern</a>.</p></div></div><p>We can choose to show or hide <code class="literal">Root</code> of the TreePanel. In the preceding image, <code class="literal">Root</code> is visible (the node called <code class="literal">Root</code>).</p><p>Each <span class="strong"><strong>Node</strong></span> of a TreePanel can have <span class="strong"><strong>Children</strong></span> (in as many nested levels as needed). When a <span class="strong"><strong>Node</strong></span> does not have any child, we call it a <span class="strong"><strong>Leaf</strong></span>.</p><p>We will dive more<a id="id432" class="indexterm"/> into the TreePanel when we implement the menu later in this chapter. For now, these are the concepts that we need to be familiar with.</p></div><div class="section" title="Accordion layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Accordion layout</h2></div></div></div><p>The <a id="id433" class="indexterm"/>Accordion layout<a id="id434" class="indexterm"/> manages multiple panels in an expandable accordion style such that by default only one panel can be expanded at any given time (this can be changed by setting the <code class="literal">multi</code> configuration as true). Only Ext panels and all subclasses of <code class="literal">Ext.panel.Panel</code> can be used in an Accordion layout container.</p><p>We could implement the dynamic menu using only a TreePanel, but we do like a challenge! Besides, from the UI point of view, having the modules separated by an Accordion layout container looks prettier than a simple TreePanel, as we can see in the following image:</p><div class="mediaobject"><img src="graphics/0457OT_05_03.jpg" alt="Accordion layout"/></div><p>The menu itself is a panel that <a id="id435" class="indexterm"/>uses the Accordion layout. A TreePanel represents each module of the menu (note that you can expand or collapse each module due the capabilities of the Accordion layout). We are <a id="id436" class="indexterm"/>going to load the required data to display this menu from the server, and we are going to load the data from the database according to the user entitlements. That is why we call it a dynamic menu.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>An important note on this approach: we are creating a TreePanel for each module for navigation. Creating many objects at the same time has some disadvantages, such as memory consumption. We can also create a single TreePanel and display all the modules as nodes with children. For more information about JavaScript, and memory consumption and its problems, please read <a class="ulink" href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling">https://developer.chrome.com/devtools/docs/javascript-memory-profiling</a>.</p></div></div><p>So now that we are familiar with all the concepts, we can start with the menu!</p></div></div></div>
<div class="section" title="The database model &#x2013; groups, menus, and permissions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>The database model – groups, menus, and permissions</h1></div></div></div><p>We have<a id="id437" class="indexterm"/> already created the<a id="id438" class="indexterm"/> <code class="literal">user</code> and <a id="id439" class="indexterm"/>
<code class="literal">groups</code> tables. To store the information of the menu and its options and also the permission that each group has, we need to create two more<a id="id440" class="indexterm"/> tables: the <code class="literal">menu</code> and <code class="literal">permissions</code> tables, as<a id="id441" class="indexterm"/> shown by the following screenshot:</p><div class="mediaobject"><img src="graphics/0457OT_05_04.jpg" alt="The database model – groups, menus, and permissions"/></div><p>On the <code class="literal">menu</code> table, we will store all the <code class="literal">menu</code> information. As each option of the <code class="literal">menu</code> table will be a node of a TreePanel, we will store the information in a way that represents a TreePanel. So, we have an <code class="literal">id</code> field to identify the node, a <code class="literal">text</code> field as the text that<a id="id442" class="indexterm"/> is going to be displayed on the node (in our case, we will store the attribute of the translations file since we are using a multilingual capability), <code class="literal">iconCls</code> representing the <code class="literal">css</code> class <a id="id443" class="indexterm"/>that will be used to display the icon for each node, <code class="literal">className</code> representing the <code class="literal">alias</code> (<code class="literal">xtype</code>) of the<a id="id444" class="indexterm"/> class that we are going to instantiate dynamically and open at the central tab panel of the application, and finally the <code class="literal">menu_id</code> field representing the <code class="literal">root</code> node (if it has one—the module nodes will not have a <code class="literal">menu_id</code> field, but the module items will).</p><p>Then, as the <code class="literal">menu</code> table has an <span class="strong"><strong>N:N</strong></span> relationship with the <code class="literal">groups</code> table, we need to create the <code class="literal">permissions</code> table that will represent this relationship. We will learn more about how to assign a user to a group in the next chapter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>If you are not familiar with database relationships, the following link provides a good tutorial: <a class="ulink" href="http://goo.gl/hXRsPx">http://goo.gl/hXRsPx</a>.</p></div></div><p>So to create the new table, we will use the following SQL script:</p><div class="informalexample"><pre class="programlisting">USE `sakila` ;

CREATE  TABLE IF NOT EXISTS `sakila`.`menu` (
  `id` INT NOT NULL AUTO_INCREMENT ,
  `text` VARCHAR(45) NOT NULL ,
  `iconCls` VARCHAR(15) NULL ,
  `className` VARCHAR(45) NULL ,
  `menu_id` INT NULL ,
  PRIMARY KEY (`id`) ,
  INDEX `fk_menu_menu1_idx` (`menu_id` ASC) ,
  CONSTRAINT `fk_menu_menu1`
  FOREIGN KEY (`menu_id` )
  REFERENCES `sakila`.`menu` (`id` )
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
  ENGINE = InnoDB;

CREATE  TABLE IF NOT EXISTS `sakila`.`permissions` (
  `menu_id` INT NOT NULL ,
  `groups_id` INT NOT NULL ,
  PRIMARY KEY (`menu_id`, `groups_id`) ,
  INDEX `fk_permissions_groups1_idx` (`groups_id` ASC) ,
  CONSTRAINT `fk_permissions_menu1`
  FOREIGN KEY (`menu_id` )
  REFERENCES `sakila`.`menu` (`id` )
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_permissions_groups1`
  FOREIGN KEY (`groups_id` )
  REFERENCES `sakila`.`groups` (`id` )
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
  ENGINE = InnoDB;
});</pre></div><p>And we also need <a id="id445" class="indexterm"/>to populate the <code class="literal">menu</code> and <code class="literal">permissions</code> tables with some data. We can use the following SQL code to create all the modules and menu options that we <a id="id446" class="indexterm"/>are going to develop throughout this book. We are <a id="id447" class="indexterm"/>also going to grant the user we created in the preceding chapter access to all menu options, as this user is <span class="emphasis"><em>admin</em></span>. Here's the code that encapsulates what we discussed in this paragraph:</p><div class="informalexample"><pre class="programlisting">INSERT INTO `menu` (`id`,`text`,`iconCls`,`className`,`menu_id`) 
VALUES 
(1,'menu1','fa fa-group fa-lg',NULL,NULL),
(2,'menu11','xf0c0',<span class="strong"><strong>'panel'</strong></span>,1),
(3,'menu12','xf007',<span class="strong"><strong>'panel'</strong></span>,1),
(4,'staticData','fa fa-database fa-lg',NULL,NULL),
(5,'actors','xf005',<span class="strong"><strong>'panel'</strong></span>,4),
(6,'categories','xf013',<span class="strong"><strong>'panel'</strong></span>,4),
(7,'languages','xf1ab',<span class="strong"><strong>'panel'</strong></span>,4),
(8,'cities','xf018',<span class="strong"><strong>'panel'</strong></span>,4),
(9,'countries','xf0ac',<span class="strong"><strong>'panel'</strong></span>,4),
(10,'cms','fa fa-film fa-lg',NULL,NULL),
(11,'films','xf1c8',<span class="strong"><strong>'panel'</strong></span>,10),
(12,'reports','fa fa-line-chart fa-lg',NULL,NULL),
(13,'salesfilmcategory','xf200',<span class="strong"><strong>'panel'</strong></span>,12);

INSERT INTO `permissions` (`menu_id`,`groups_id`) VALUES 
(1,1), (2,1), (3,1), (4,1), (5,1), (6,1), (7,1),
(8,1), (9,1), (10,1), (11,1), (12,1), (13,1);</pre></div><p>Throughout this book, we are going to create the screens of our application, and we will need to run some update queries. For now, whenever we click on any menu option, the application is going to open an empty panel so that we can test it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Note that <code class="literal">className</code> is set to <code class="literal">Panel</code> for all options. We will update the records in the database accordingly throughout the next chapters.</p></div></div></div>
<div class="section" title="The dynamic menu &#x2013; an MVC approach"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>The dynamic menu – an MVC approach</h1></div></div></div><p>We have covered the<a id="id448" class="indexterm"/> MVC architecture concept in <a class="link" href="ch02.html" title="Chapter 2. Getting Started">Chapter 2</a>, <span class="emphasis"><em>Getting Started</em></span>, already, but let's do a quick overview one more time.</p><p>The <a id="id449" class="indexterm"/>Model represents the data we want to manipulate. It is a representation of the tables we have in the database. A Model instance represents a single data row of a table. The Store will be responsible for loading the collection of models from the server. A Store is usually bound to a View. A View is the component with which the user is seeing the screen (we have created a few so far; for example, a GridPanel provides a visual representation of data found in a Store.). And the Controller is what keeps everything together. The Controller will capture the events from the View and will execute some logic based on it. The Controller can also redirect the logic to the Model or the Store, making all the pieces communicate with each other, behaving like a mediator.</p><p>In the previous chapters, we used the MVVM architecture. We saw an example using the View and ViewController only and an example with View, ViewModel (predefined data), and ViewController. We have also learned that the ViewController is bound to its View's component life cycle, which means it is created when the View is created, and it is destroyed when the View is destroyed. With the MVC approach, the Controllers are alive as long as the application is running in the browser.</p><p>While in the ViewController, we can easily retrieve the view's reference or any of its children's references as well (using the <code class="literal">reference</code> configuration), in the Controller, we need to define what events from what components we want to listen to, and there is another approach to retrieve the components references.</p><p>MVC is not better than MVVM or vice versa. It depends on the application, the type of screen you are developing, the use case, and also your personal preference (why not?). That is why we are going to use all the possibilities in this book in the examples. This way, you can learn all of them (MVVM, MVC, and hybrid architecture) and use the one you like the most!</p><div class="section" title="Creating the models"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Creating the models</h2></div></div></div><p>When <a id="id450" class="indexterm"/>working with the MVC architecture, we usually create the models first.</p><p>So first, we will create a class named <code class="literal">Packt.model.menu.Accordion</code>. To do that, we need to create the directory <code class="literal">app/model/menu</code> and also create a file named <code class="literal">Accordion.js</code>. With this Model, we will be able to represent each of the accordion panels we want to create (that will be represented by a TreePanel). So, for each module (or TreePanel), we want to set a title and also an icon.</p><p>The following code snippet shows the implementation of the <code class="literal">Packt.model.menu.Accordion</code> class:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.model.menu.Accordion', {
    extend: 'Ext.data.Model',

    fields: [ //#1
        { name: 'id', type: 'int'}, //#2
        { name: 'text' },
        { name: 'iconCls' }
    ]
});</pre></div><p>The main <a id="id451" class="indexterm"/>configuration for a Model is called <code class="literal">fields</code> (<code class="literal">#1</code>). In this configuration, we can declare all the <code class="literal">fields</code> for the Model (which would be similar to the columns of a table from the database). The class <code class="literal">Ext.data.field.Field</code> represents each field. Each field can have <code class="literal">name</code> and it can also have <code class="literal">type</code>. The available types are <code class="literal">string</code>, <code class="literal">int</code>, <code class="literal">number</code>, <code class="literal">boolean</code>, <code class="literal">date</code>, and <code class="literal">auto</code> (when no type is defined, and in this case, the field does not try to convert the value to any of the default types). The fields <code class="literal">text</code> and <code class="literal">iconCls</code> have the type <code class="literal">auto</code>.</p><p>Every Model needs a field that works as its unique identifier. In this case, we are defining the field <code class="literal">id</code> (<code class="literal">#2</code>) as our unique field. If the unique identifier of the Model is not called <code class="literal">id</code>, we need to configure this information in the Model as well by using the <code class="literal">idProperty</code> configuration. For example, if our ID was named <code class="literal">accordionId</code>, we would declare it normally, and inside the Model, we would add <code class="literal">idProperty: 'accordionId'</code> so that the Model would know that the field is the identifier.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>The <code class="literal">Model</code> and <code class="literal">Field</code> classes also have other features. Please refer to them to see all their capabilities in the Ext JS documentation, which is very complete and full of examples. Please take a look at <a class="ulink" href="http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model">http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.Model</a> and <a class="ulink" href="http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field">http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.data.field.Field</a>.</p></div></div><p>We also need a Model to represent the menu option, which consists of the Tree nodes of the TreePanel. To do so, we will declare the following Model:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.model.menu.TreeNode', {
    extend: 'Ext.data.Model',

    fields: [
        { name: 'id', type: 'int'},
        { name: 'text' },
        { name: 'iconCls' },
        { name: 'className' },
        { name: 'parent_id', mapping: 'menu_id'} //#1
    ]
});</pre></div><p>The <code class="literal">TreeNode</code> Model declared three fields present in the <code class="literal">NodeInterface</code> class, which are <code class="literal">id</code>, <code class="literal">text</code>, and <code class="literal">iconCls</code>. The <code class="literal">className</code> value is going to be used as <code class="literal">xtype</code> to instantiate the class that represents<a id="id452" class="indexterm"/> the screen of the menu option. We will talk more about this later. Then, we have the <code class="literal">parent_id</code> field. In the JSON, when we load data from the server, we will have the <code class="literal">menu_id</code> property instead of <code class="literal">parent_id</code>. We can use the <code class="literal">mapping</code> configuration to make this link (<code class="literal">#1</code>). This is nice because our Ext JS models do not need to be exactly like what is coming from the server (but it makes our life easier if they are the same).</p><div class="section" title="Working with the hasMany association"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Working with the hasMany association</h3></div></div></div><p>There<a id="id453" class="indexterm"/> are two different ways of working with associations in Ext JS. The first one is using <code class="literal">Ext.data.association.Association</code> introduced in Ext JS 4. And the second one is using the <code class="literal">reference</code> configuration introduced in Ext JS 5. Ext JS 5 maintains backwards compatibility with the Model associations from Ext JS 4, although these Ext JS 4 features are marked as legacy code in the sources.</p><p>In this example, we are going to use the hasMany association introduced in Ext JS 4. Later in this book, we will see another example using <code class="literal">reference</code>, and we will be able to compare the difference and choose when to use one or the other.</p><p>To use the hasMany association, inside the <code class="literal">Accordion</code> Model, we first need to add the <code class="literal">hasMany</code> configuration:</p><div class="informalexample"><pre class="programlisting">hasMany: {
    model: 'Packt.model.menu.TreeNode',
    foreignKey: 'parent_id',
    name: 'items' //#1
}</pre></div><p>This means that a new field named <code class="literal">items</code> (<code class="literal">#1</code>) will be created for the <code class="literal">Accordion</code> Model. For each instance of the <code class="literal">Accordion</code> Model, a method named <code class="literal">items()</code> will also be available to retrieve the <code class="literal">TreeNode</code> Model instances.</p><p>We cannot forget to add the <code class="literal">requires</code> declaration to the beginning of the <code class="literal">Accordion</code> Model as well, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">requires: [
    'Packt.model.menu.TreeNode'
],</pre></div></div></div><div class="section" title="Creating the store-loading menu from the server"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Creating the store-loading menu from the server</h2></div></div></div><p>Now that we <a id="id454" class="indexterm"/>have the Model defined, we can move on and create the Store. We will create a new class named <code class="literal">Packt.store.Menu</code>, so we need to create a new file named <code class="literal">Menu.js</code> under the <code class="literal">app/store</code> folder with the following content:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.store.Menu', {
    extend: 'Ext.data.Store',

    requires: [
        'Packt.util.Util' //#1
    ],

    model: 'Packt.model.menu.Accordion', //#2

    proxy: {
        type: 'ajax',             //#3
        url: 'php/menu/list.php', //#4

        reader: { //#5
            type: 'json',
            rootProperty: 'data'
        },
        listeners: {
            exception: function(proxy, response, operation){ //#6
              Packt.util.Util.showErrorMsg(response.responseText);
            }
        }
    }
});</pre></div><p>There are two important things we need to declare in the Store: the <code class="literal">model</code> and the <code class="literal">proxy</code> properties. The <code class="literal">model</code> tells the Store what type of data the Store needs to load from the server (or client storages), and the <code class="literal">proxy</code> tells the Store how and where to get the data.</p><p>This Store is going to use the model <code class="literal">Packt.model. </code>(<code class="literal">#2</code>). Instead of using the <code class="literal">model</code> configuration, it is also possible to declare the fields directly inside the Store using the <code class="literal">fields</code> configuration (it would be a copy from <code class="literal">fields</code> from the Model). In this case, the Store would use a so-called "anonymous model".</p><p>The Store is going to communicate with the server through the proxy using an Ajax request to the provided <code class="literal">url</code>. The <code class="literal">reader</code> (<code class="literal">#5</code>) tells the proxy how to decode the information from the server and transform it into a collection of the specified models. This Store is expecting a JSON format with <code class="literal">rootProperty</code> (known in Ext JS 4 as <code class="literal">root</code>) named <code class="literal">data</code>, as follows:</p><div class="informalexample"><pre class="programlisting">{
  "data":[
    {
      "id":"1",
      "text":"menu1",
      "iconCls":"fa fa-group fa-lg",
      "items":[
        {
          "id":"2",
          "text":"menu11",
          "iconCls":"xf0c0",
          "className":"panel",
          "menu_id":"1",
          "leaf":true
        },
        {
          "id":"3",
          "text":"menu12",
          "iconCls":"xf007",
          "className":"panel",
          "menu_id":"1",
          "leaf":true
        }
      ]
    }
  ]
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>Because we declare the associations in the previous topic, the Store knows how to decode a nested JSON and create the respective Model instances.</p></div></div><p>And, of course, exceptions<a id="id455" class="indexterm"/> can occur! For this reason, we can add <code class="literal">exception</code> <code class="literal">listener</code> (<code class="literal">#6</code>) in <code class="literal">proxy</code> so that we can display an error message to the user. As we are using the <code class="literal">Util</code> class we created, we also need to add this class in the <code class="literal">requires</code> declaration (<code class="literal">#1</code>).</p><p>We can listen to events from views and stores in the Controller; however, the Store does not have any exception event. For this reason, <code class="literal">listener</code> needs to be added directly to <code class="literal">proxy</code>. This is an optional step, but if an error occurs, nothing will happen in the UI (Ext JS will output an error message in the browser's console, but users do not use the application with the developer tools console opened). That is why it is a good practice to have <code class="literal">exception listener</code> declared inside every proxy we use. We will develop a more elegant approach, but for now, we will use it like this.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>Instead of declaring <code class="literal">proxy</code> inside the Store, we can declare it inside the Model. You can declare <code class="literal">proxy</code> in the place of your preference. However, if you declare <code class="literal">proxy</code> on the Model and on the Store, when using the Store's <code class="literal">sync()</code> method, it will call the <code class="literal">proxy</code> instance declared on the Store; else the Model's <code class="literal">proxy</code> will be used.</p></div></div><p>Now that we <a id="id456" class="indexterm"/>know the data format that we need to retrieve from the server, let's implement it!</p></div><div class="section" title="Handling the dynamic menu on the server"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Handling the dynamic menu on the server</h2></div></div></div><p>As we declared <a id="id457" class="indexterm"/>on the <code class="literal">Packt.store.Menu</code> Store, we need to create a new file named <code class="literal">menu/list.php</code> under the <code class="literal">php</code> folder. The following is the programming logic that we need to follow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Get the user that is logged in from the session.</li><li class="listitem">Open a connection with the database.</li><li class="listitem">Select the menu <code class="literal">id</code> instances from the <code class="literal">permission</code> table so that we know what permissions the user from the session has.</li><li class="listitem">Select the modules that the user has permission to access—<code class="literal">menu_id</code> is <code class="literal">null</code>.</li><li class="listitem">For each module, select the nodes (menu options) that the user has access to.</li><li class="listitem">Encode the result in the JSON format and wrap it in the <code class="literal">data</code> root (as specified by the Store).</li></ol></div><p>So let's get our hands on the code. The following code was organized in functions, so we can organize the code exactly as listed in the preceding set of instructions:</p><div class="informalexample"><pre class="programlisting">&lt;?php
require('menuFunctions.php'); // #1

session_start(); // #2

$userName = $_SESSION['username']; // #3

$permissions = retrievePermissions($userName); // #4
$modules = retrieveModules($permissions);      // #5
$result = retrieveMenuOptions($modules, $permissions); // #6

echo json_encode(array( // #7
    "data" =&gt; $result
));</pre></div><p>As the code was organized in functions, let's create another file called <code class="literal">menuFunction.php</code> inside the <code class="literal">php/menu</code> folder as well. As we are going to code the functions inside this file, we need to require this file inside <code class="literal">menu/list.php</code> (<code class="literal">#1</code>).</p><p>Then, we will <a id="id458" class="indexterm"/>get the user that is logged in to the session (<code class="literal">#2</code>). So we will get the entitlements for the user that is logged in, increasing the security a little bit.</p><p>Then, we will do as listed. For each function to which we open the connection with the database, we will retrieve the user's permissions (<code class="literal">#4</code>), then we will retrieve the modules the user has permission to access (<code class="literal">#5</code>), and then based on the module, we retrieve the menu options the user also has access to (<code class="literal">#6</code>).</p><p>At last, we will encode the result array in the JSON format (<code class="literal">#7</code>), and it is going to produce the JSON listed in the preceding topic.</p><div class="section" title="Fetching the user permissions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Fetching the user permissions</h3></div></div></div><p>Now, let's <a id="id459" class="indexterm"/>dive into each function declared inside the <code class="literal">menuFunctions.php</code> file. The first one is the function used to retrieve the user's permissions as listed here:</p><div class="informalexample"><pre class="programlisting">function retrievePermissions($userName){

    require('../db/db.php'); // #8

    $sqlQuery = "SELECT p.menu_id menuId FROM User u "; // #9
    $sqlQuery .= "INNER JOIN permissions p ON u.groups_id = p.groups_id ";
    $sqlQuery .= "INNER JOIN menu m ON p.menu_id = m.id ";
    $sqlQuery .= "WHERE u.username = '$userName' ";

    $permissions = [];

    if ($resultDb = $mysqli-&gt;query($sqlQuery)) { // #10
        while($user = $resultDb-&gt;fetch_assoc()) { // #11
            $permissions[] =  $user['menuId'];
        }
    }

    $resultDb-&gt;free(); // #12
    $mysqli-&gt;close();  // #13

    return $permissions; // #14
}</pre></div><p>First, we will open the connection with the database (<code class="literal">#8</code>), and then we prepare the SQL query to get the <code class="literal">id</code> instances<a id="id460" class="indexterm"/> from the <code class="literal">menu</code> table that the user has access to (<code class="literal">#9</code>). We are using <code class="literal">JOIN</code> because the only information we have is <code class="literal">username</code>, and we need to pass through the <code class="literal">groups</code> table to get to the <code class="literal">permissions</code> table.</p><p>We execute the SQL query (<code class="literal">#10</code>), and we create an array with the menu <code class="literal">id</code> that the user has permission to use (<code class="literal">#11</code>).</p><p>In the end, we free the result set (<code class="literal">#12</code>), close the database connection (<code class="literal">#13</code>), and we return the <code class="literal">permissions</code> array (<code class="literal">#14</code>).</p></div><div class="section" title="Fetching the modules the user is entitled to"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Fetching the modules the user is entitled to</h3></div></div></div><p>Now let's take <a id="id461" class="indexterm"/>a look at the function that will retrieve the modules based on users' permissions:</p><div class="informalexample"><pre class="programlisting">function retrieveModules($permissions){

    require('../db/db.php');

    $inClause = '(' . join(',',$permissions) . ')'; // #15

    $sqlQuery = "SELECT id, text, iconCls FROM menu WHERE menu_id IS NULL AND id in $inClause"; // #16

    $modules = [];

    if ($resultDb = $mysqli-&gt;query($sqlQuery)) { // #17
        while($module = $resultDb-&gt;fetch_assoc()) {
            $modules[] = $module;

        }
    }

    $resultDb-&gt;free();
    $mysqli-&gt;close();

    return $modules; // #18
}</pre></div><p>To be able to retrieve the modules the user has access to, we need to know what modules (records from the <code class="literal">menu</code> table that do not have a <code class="literal">menu_id</code> parent menu) the user has permission to access. In our SQL query (<code class="literal">#16</code>), there is an <code class="literal">IN</code> clause to fetch all modules. As we have the <code class="literal">permissions</code> array, we can use the <code class="literal">join</code> PHP function (<code class="literal">#15</code>) that will return a string with all the array values separated by the "<code class="literal">,</code>" delimiter we informed. Then, we concatenate with "<code class="literal">( )</code>" and we are good to go.</p><p>The next step is <a id="id462" class="indexterm"/>executing the SQL query (<code class="literal">#17</code>), and with the results from the database, we create an array with the <code class="literal">modules</code> that the user has access to, and at the end of the function, we return this information (<code class="literal">#18</code>).</p><p>The <code class="literal">modules</code> variable represents the <code class="literal">Accordion Model</code> class we created.</p></div><div class="section" title="Fetching the menu options based on modules and permissions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Fetching the menu options based on modules and permissions</h3></div></div></div><p>After we<a id="id463" class="indexterm"/> have retrieved the <code class="literal">permissions</code> and <code class="literal">modules</code> the user has access to, it is time to retrieve the last piece to create the data for the dynamic menu, which is retrieving the menu options. The code is presented as follows:</p><div class="informalexample"><pre class="programlisting">function retrieveMenuOptions($modules, $permissions){

    require('../db/db.php');

    $inClause = '(' . join(',',$permissions) . ')'; // #1

    $result = [];

    foreach ($modules as $module) { // #2

        $sqlQuery = "SELECT * FROM menu WHERE menu_id = '"; // #3
        $sqlQuery .= $module['id'] ."' AND id in $inClause";

        if ($resultDb = $mysqli-&gt;query($sqlQuery)) { // #4

            $count = $resultDb-&gt;num_rows; // #5
            if ($count &gt; 0){ // #6
                $module['items'] = array(); // #7
                while ($item = $resultDb-&gt;fetch_assoc()) {
                    $module['items'][] = $item; // #8
                }
            }
            $result[] = $module; // #9
        }
    }
    $resultDb-&gt;close();
    $mysqli-&gt;close();

    return $result; // #10
}</pre></div><p>For each <code class="literal">module</code> that the user has access to (<code class="literal">#2</code>), we will retrieve the menu options (<code class="literal">#3</code>). To do so, we need the ID of the module and also the <code class="literal">permissions</code> (<code class="literal">#1</code>). As each module might have several menu options, a user might not have permission to access all of them.</p><p>Next, we execute the query (<code class="literal">#4</code>) and retrieve the number of records returned by the database (<code class="literal">#5</code>). If this number is positive (<code class="literal">#6</code>), we create the <code class="literal">items</code> array ((<code class="literal">#7</code>), the <code class="literal">hasMany</code> association) and we fetch each item adding it to the <code class="literal">module['items']</code> array (<code class="literal">#8</code>).</p><p>Each <code class="literal">$item</code> variable inside <code class="literal">module['items']</code> represents the <code class="literal">TreeNode</code> model.</p><p>At the end of it, we <a id="id464" class="indexterm"/>add <code class="literal">$item</code> to the <code class="literal">result</code> variable (<code class="literal">#9</code>) and return it (<code class="literal">#10</code>). This <code class="literal">result</code> variable is the one that will be wrapped inside the <code class="literal">data</code> root and encoded as JSON to be returned to Ext JS.</p><p>The database for the <code class="literal">menu</code> fits perfectly to what Ext JS needs. We designed the <code class="literal">menu</code> table according to Ext JS expectations, and in a way that would be easier for us to retrieve the information. The preceding server-side code also fits perfectly to what Ext JS needs. Unless we have the chance to design the database ourselves in a project that we are starting from scratch, we will probably have a different design; therefore, the server-side code to retrieve the information will be a little different too. There is no problem at all. It does not matter how the database looks or the server-side code you need to write to retrieve the information. However, Ext JS is expecting a specific format to be sent back to the frontend code, and unfortunately, we need to send the information in this specific format (the JSON listed before). If the information we retrieved from the database is not in the format that Ext JS expects (the same format as our preceding code), all we need to do is parse and transform it, which means there will be an extra step in our server-side code before we send it back to Ext JS.</p></div></div><div class="section" title="Creating the menu with the Accordion layout and TreePanel"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Creating the menu with the Accordion layout and TreePanel</h2></div></div></div><p>We can go <a id="id465" class="indexterm"/>back to the Ext JS code and start implementing the dynamic menu View component now. First, we need to create a new folder under <code class="literal">app/view/menu</code> and create a new file named <code class="literal">Accordion.js</code>, as follows:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.menu.Accordion', {
    extend: 'Ext.panel.Panel',
    xtype: 'mainmenu', // #1

    width: 250, // #2
    layout: {
        type: 'accordion', // #3
        multi: true        // #4
    },
    collapsible: true, // #3
    split: true,       // #4
    iconCls: 'fa fa-sitemap fa-lg', // #5
    title: translations.menu  // #6
});</pre></div><p>This class is <a id="id466" class="indexterm"/>going to be a panel and it is going to wrap the TreePanels that will be the menus. It is going to use the Accordion layout (<code class="literal">#3</code>); this way, the user can expand or collapse the desired module. As the default behavior, all modules will be expanded (<code class="literal">#4</code>). If only the first module should be expanded at a time, we can comment line <code class="literal">#4</code>.</p><p>As we are going to use this class in the <code class="literal">west</code> region of the <code class="literal">Main</code> class, we are going to declare <code class="literal">xtype</code> (<code class="literal">#1</code>).</p><p>Be very careful when declaring <code class="literal">xtype</code>. Always remember to create a unique <code class="literal">xtype</code> and not any that is already being used by Ext JS components. For example, let's say there is an <code class="literal">xtype</code> property you might want to use, but if we go to the documentation and use the quick search, we will see this <code class="literal">xtype</code> property is already in use by Ext JS, as shown below:</p><div class="mediaobject"><img src="graphics/0457OT_05_05.jpg" alt="Creating the menu with the Accordion layout and TreePanel"/></div><p>As this panel will be rendered in the <code class="literal">west</code> region, we need to set a <code class="literal">width</code> (<code class="literal">#2</code>)—remember that whenever we are using the Border layout, we need to specify a <code class="literal">width</code> for the <code class="literal">west</code> and <code class="literal">east</code> regions. We will also allow the user to resize the <code class="literal">west</code> region (<code class="literal">#4</code>) and collapse (<code class="literal">#3</code>) so that there is more space for the screen in the center.</p><p>At last, to prettify, we are declaring a Font Awesome icon (<code class="literal">#5</code>) and a <code class="literal">title</code> property (<code class="literal">#6</code>). We cannot forget to add the following entry in the <code class="literal">locale/en.js</code> file and its translations:</p><div class="informalexample"><pre class="programlisting">menu: 'menu',</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>You can get the Spanish and Portuguese translations by downloading the source code bundle from this book or downloading from the GitHub repository <a class="ulink" href="https://github.com/loiane/masteringextjs">https://github.com/loiane/masteringextjs</a>.</p></div></div><p>Next, we need to create a TreePanel to represent each module. We will create a new class named <code class="literal">Packt.view.menu.Tree</code>; therefore, we need to create a new file named <code class="literal">Tree.js</code> under <code class="literal">app/view/menu</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.view.menu.Tree', {
    extend: 'Ext.tree.Panel',
    xtype: 'menutree',

    border: 0,
    autoScroll: true,
    rootVisible: false
});</pre></div><p>This class is a <a id="id467" class="indexterm"/>TreePanel. We do not want a <code class="literal">border</code> property for our module, and the <code class="literal">root</code> property will not be visible. As we can see, we are not setting many attributes. We will set the missing information dynamically on the Controller.</p><p>The last step is going back to the <code class="literal">Main</code> class and adding <code class="literal">Accordion</code> to the <code class="literal">west</code> region. To do so, first we cannot forget to add the class <code class="literal">'Packt.view.menu.Accordion'</code> to <code class="literal">requires</code> and change the <code class="literal">west</code> region code to the following:</p><div class="informalexample"><pre class="programlisting">{
<span class="strong"><strong>    xtype: 'mainmenu',</strong></span>
    region: 'west'
}</pre></div><p>We removed all the configurations (<code class="literal">width</code>, <code class="literal">split</code>) and replaced <code class="literal">xtype</code> with <code class="literal">menu.Accordion</code>. When we execute the application, we will be able to see the <code class="literal">west</code> region with a panel now. The creation of the dynamic menu is pending though, and we will take care of it next.</p></div><div class="section" title="Creating the menu Controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Creating the menu Controller</h2></div></div></div><p>We already <a id="id468" class="indexterm"/>have all the views, models, and stores and also have the server-side covered. Now the only thing left is to implement <a id="id469" class="indexterm"/>the Controller, which is where all the magic will happen. So, let's go <a id="id470" class="indexterm"/>ahead and create a new file named <code class="literal">Menu.js</code> under the <code class="literal">app/controller</code> folder:</p><div class="informalexample"><pre class="programlisting">Ext.define('Packt.controller.Menu', {
    extend: 'Ext.app.Controller',

    init: function(application) {

     this.control({ // #1
            "menutree": { // #2
                itemclick: this.onTreePanelItemClick // #3
            },
            "mainmenu": {
                render: this.renderDynamicMenu // #4
            }
        });
    }
});</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>In the MVC approach, all controllers are created inside the <code class="literal">app/controller</code> folder, while in the MVVM approach, ViewController is created in the same folder as the View.</p></div></div><p>The <code class="literal">init</code> function<a id="id471" class="indexterm"/> is called when the application boots, and it is called before the application's <code class="literal">launch</code> function is. We can use this function to execute any logic before the first View (<code class="literal">Login</code> or Viewport) is created. Inside this function is also the place where we want to set up the events we want this Controller to listen to using the <code class="literal">control</code> function (<code class="literal">#1</code>).</p><p>In this Controller, we want to listen to two events. The first one is we want to render the dynamic menu (<code class="literal">#4</code>) when the Viewport (<code class="literal">Main</code> class) has been rendered. The second one is whenever the user clicks on a menu option (a node from the TreePanel—<code class="literal">#2</code>), we want to open the screen inside the center panel (#3).</p><p>To listen to an event inside the <code class="literal">control</code> method, we need to define three things: the selector, the event we want the Controller to listen to, and the method to be executed. It has the following format:</p><div class="informalexample"><pre class="programlisting">"{selector}": {
    event1: this.methodToBeExecuted1,
    event2: this.methodToBeExecuted2
}</pre></div><p>Finding the selector is the most challenging part. The scope in this case is not the View as in the ViewController, but the application. For selectors, we usually use the <code class="literal">xtype</code> component. It helps when it is an <code class="literal">xtype</code> component we created for the application and not an Ext JS <code class="literal">xtype</code> such as <code class="literal">'tree'</code>; for example, <code class="literal">'menutree'</code> is much better because we narrow down the possibilities (there might be several TreePanels within the application, but we know that only the TreePanels from the dynamic menu have <code class="literal">menutree</code> as <code class="literal">xtype</code>). We have to remember that if we use the selector <code class="literal">'tree'</code> (<code class="literal">xtype</code> for TreePanel), the Controller will listen to the event from all TreePanels of the application, so it is good to be as specific as we can be.</p><p>We can listen to as many events from a selector as we want to. We simply need to separate the events by a "<code class="literal">,</code>".</p><p>For example, let's<a id="id472" class="indexterm"/> implement the <code class="literal">renderDynamicMenu</code> method first. We use <code class="literal">mainmenu</code> as the selector. This is the <code class="literal">xtype</code> component for the <code class="literal">view.menu.Accordion</code> class, which is being rendered in the <code class="literal">west</code> region of the <code class="literal">Main</code> class (Viewport). So, when this component is rendered, the Controller is going to execute the <code class="literal">renderDynamicMenu</code> method. Let's declare this method inside the <code class="literal">Menu</code> Controller:</p><div class="informalexample"><pre class="programlisting">renderDynamicMenu: function(view, options) {
  console.log('menu rendered');
}</pre></div><p>We can always start the implementation of an event listener in the Controller by adding a <code class="literal">console.log</code> or <code class="literal">alert</code> message to make sure the method is being executed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>Remember to always go to the documentation to verify the parameters that are being passed to the event so that we can declare them. For the <code class="literal">render</code> event, it is usually the component itself and <code class="literal">options</code>.</p></div></div><p>Let's declare <code class="literal">onTreePanelItemClick</code> as well so that we can test this Controller:</p><div class="informalexample"><pre class="programlisting">onTreePanelItemClick: function(view, record, item, index, event, options){ },</pre></div><p>The method signature is enough so that we do not get any errors.</p><p>We need to add this Controller in <code class="literal">Application.js</code> as well. So, go back to <code class="literal">Application.js</code> and add the highlighted code shown as follows:</p><div class="informalexample"><pre class="programlisting">controllers: [
    'Root',
<span class="strong"><strong>    'Menu'</strong></span>
],</pre></div><p>If we execute the application, we will get the output as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0457OT_05_06.jpg" alt="Creating the menu Controller"/></div><p>This means that it<a id="id473" class="indexterm"/> is working as we expect. Do not worry about the other warning messages; we will take care of them later in this book (the important thing is not getting error messages).</p><p>So let's go ahead and add the required business logic.</p><div class="section" title="Rendering the menu from nested JSON (the hasMany association)"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Rendering the menu from nested JSON (the hasMany association)</h3></div></div></div><p>We need to add<a id="id474" class="indexterm"/> the logic that will be responsible for creating the dynamic menu with the information that will be received from the server. We will add the following code inside the <code class="literal">renderDynamicMenu</code> method:</p><div class="informalexample"><pre class="programlisting">var dynamicMenus = [];  //#1

view.body.mask('Loading Menus... Please wait...');  //#2

this.getMenuStore().load(function(records, op, success){ //#3

    Ext.each(records, function(root){ //#4

        var menu = Ext.create('Packt.view.menu.Tree',{ //#5
            title: translations[root.get('text')],     //#6
            iconCls: root.get('iconCls')               //#7
        });

        var treeNodeStore = root.items(),     //#8
            nodes = [],
   item;

        for (var i=0; i&lt;treeNodeStore.getCount(); i++){ //#9
            item = treeNodeStore.getAt(i);              //#10

            nodes.push({                      //#11
                text: translations[item.get('text')],
                leaf: true,                   //#12
                glyph: item.get('iconCls'),   //#13
                id: item.get('id'),
                className: item.get('className')
            });
        }
       menu.getRootNode().appendChild(nodes); //#14
        dynamicMenus.push(menu); //#15
    });
    view.add(dynamicMenus); //#16
    view.body.unmask();     //#17
});</pre></div><p>The first thing we <a id="id475" class="indexterm"/>are going to do is create an empty array so that we can add all the modules to it (<code class="literal">#1</code>). As we are going to make a request to the server and as initially the menu in the <code class="literal">west</code> region is going to be empty, it is nice to add a loading message (<code class="literal">#2</code>) just in case there is any delay with the server response (<span class="emphasis"><em>Ajax is asynchronous</em></span>). The <code class="literal">view</code> was passed as a parameter to the event and is a reference to the <code class="literal">Packt.view.menu.Accordion</code> class instance.</p><p>Then, we need to load the <code class="literal">Menu</code> Store (<code class="literal">#3</code>), which is responsible for loading the nested JSON from the server (<code class="literal">#1</code>). Note that we are using <code class="literal">this.getMenuStore()</code> to retrieve the Store, which means this is a method from the Controller. We need to declare the <code class="literal">menu</code> Store inside the <code class="literal">stores</code> configuration in the Controller so that it will generate this method for us:</p><div class="informalexample"><pre class="programlisting">stores: [
    'Menu'
],</pre></div><p>In this case, there is no need to declare the complete name of the Store—only what is after <code class="literal">'Packt.store'</code>. Because of the MVC architecture, Ext JS knows that it needs to look for a file named <code class="literal">Menu.js</code> inside the <code class="literal">app/store</code> folder. As the name of the Store is <code class="literal">Menu</code>, the Controller will generate a method named <code class="literal">get</code> + <code class="literal">Menu</code> + <code class="literal">Store</code> (<code class="literal">getMenuStore</code>) once the Store is loaded (that is why we are going to handle the creation of the dynamic menu inside the load callback). For each <code class="literal">record</code> returned from the Store (<code class="literal">#4</code>), we will create a TreePanel (<code class="literal">Packt.view.menu.Tree</code>—<code class="literal">#5</code>) to represent each module. We will set the <code class="literal">title</code> property (getting the <code class="literal">title</code> property from the locale file <code class="literal">(#6</code>). In the database, we will store the key from the <code class="literal">en.js</code> file in the column <code class="literal">text</code> and set <code class="literal">iconCls</code> (<code class="literal">#7</code>) for it to look prettier (a Font Awesome icon).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p><span class="strong"><strong>Ext.create or Ext.widget</strong></span></p><p>In <a class="link" href="ch02.html" title="Chapter 2. Getting Started">Chapter 2</a>, <span class="emphasis"><em>Getting Started</em></span>, when we instantiated a class for the first time in this book, we discussed the options we can use when we need to instantiate a <code class="literal">component</code> class. Just to remind you, we can use <code class="literal">Ext.create</code> passing the complete name of the class as an argument, or we can use <code class="literal">Ext.widget</code> passing the class alias as an argument (there are other ways as well, but these two are more commonly used). It is a matter of preference, but you can use any of the ways we mentioned in <a class="link" href="ch02.html" title="Chapter 2. Getting Started">Chapter 2</a>, <span class="emphasis"><em>Getting Started</em></span>.</p></div></div><p>So, with this <a id="id476" class="indexterm"/>code, we are able to display each TreePanel representing each of the modules (with no menu option). The next step is getting the data to display inside the TreePanel. This data is available in the JSON already through the <code class="literal">hasMany</code> association we configured. Because of the <code class="literal">hasMany</code> association, a method named <code class="literal">items</code> (<code class="literal">name</code> of the association we configured) will be created for each Model instance inside the Store. The <code class="literal">items</code> method returns a Store with the <code class="literal">hasMany</code> data in it (<code class="literal">#8</code>).</p><p>When we are not sure whether the method was created or not, we can always inspect the Model instance in the console. For example, if we output <code class="literal">console.log(this)</code> inside the <code class="literal">load</code> callback, we will get the Store outputted in the browser's console. Inspect the <code class="literal">data</code> configuration, and inside the <code class="literal">data</code> configuration, we will find <code class="literal">items</code>, which contains the Model collection as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0457OT_05_07.jpg" alt="Rendering the menu from nested JSON (the hasMany association)"/></div><p>For each <code class="literal">Packt.model.menu.TreeNode</code> Model instance from the Store (<code class="literal">#9</code> and <code class="literal">#10</code>), we will push a new node (<code class="literal">#11</code>) into an array. When adding the new node, we set the <code class="literal">text</code> and <code class="literal">leaf</code> (<code class="literal">#12</code>) that are properties from the <code class="literal">NodeInterface</code> class. We are adding <code class="literal">id</code> and <code class="literal">className</code> that are not part of the <code class="literal">NodeInterface</code> class.</p><p>To add all the nodes <a id="id477" class="indexterm"/>created, we need access to the <code class="literal">Root</code> node of the TreePanel. As <code class="literal">Root</code> is also a node (decorated with the <code class="literal">NodeInterface</code> class), it has a method called <code class="literal">appendChild</code>, which can be used to append nodes to a specific node (in this case, <code class="literal">Root</code>). So, we add all the nodes we created at once (<code class="literal">#14</code>).</p><p>To avoid many changes in the DOM, which is not a good practice, we are going to create an array with all the menus we created (<code class="literal">#15</code>). And then, we will add all the menus at once (<code class="literal">#16</code>) to the <code class="literal">Accordion</code> panel (this will avoid browser reflow).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>Minimizing browser reflow is a technique used to increase performance. We could do the insertions inside the loops, but this would increase DOM manipulation, which is very expensive. With simple changes in the code to add whatever needs to be added at once, we can increase the performance a little bit. For more information, please visit <a class="ulink" href="https://developers.google.com/speed/articles/reflow">https://developers.google.com/speed/articles/reflow</a>.</p></div></div><p>At last, we remove the <code class="literal">mask</code> from the <code class="literal">Accordion</code> menu (<code class="literal">#17</code>).</p><p>If we execute the code, the menu will be rendered.</p><div class="section" title="Using glyphs in TreePanel – working with overrides"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec08"/>Using glyphs in TreePanel – working with overrides</h4></div></div></div><p>There was a<a id="id478" class="indexterm"/> piece from the code that we did not cover in the previous topic, which is line <code class="literal">#13</code>, the <code class="literal">glyph</code> configuration in the node. We know that we can use icon fonts, such as Font Awesome, with Ext JS, but the support is still limited. It is not possible to use Font Awesome icons in TreePanel nodes. However, there is an override we can use that will allow us to do that.</p><p>This is the first time we are mentioning the term <span class="strong"><strong>glyph</strong></span> in this book. It is basically the same thing as the font icon we have been using until now, but it has an alternative configuration for it. For example, we used a key icon in the <code class="literal">Login</code> class, and we set <code class="literal">iconCls</code> as follows:</p><div class="informalexample"><pre class="programlisting">iconCls: 'fa fa-key fa-lg'</pre></div><p>We could have used the <code class="literal">glyph</code> configuration instead as an alternative:</p><div class="informalexample"><pre class="programlisting">glyph:'xf084@FontAwesome'</pre></div><p>The preceding code could also be written as follows:</p><div class="informalexample"><pre class="programlisting">glyph:'xf084'</pre></div><p>But we need to configure the <code class="literal">glyphFontFamily</code> configuration inside the <code class="literal">Packt.Application</code> class in <code class="literal">Application.js</code>, as follows:</p><div class="informalexample"><pre class="programlisting">glyphFontFamily: 'FontAwesome'</pre></div><p>And then, we can remove <code class="literal">'@FontAwesome'</code> from the <code class="literal">glyph</code> configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>Font Awesome provides a cheat sheet with the CSS names and glyph codes at <a class="ulink" href="http://fortawesome.github.io/Font-Awesome/cheatsheet/">http://fortawesome.github.io/Font-Awesome/cheatsheet/</a>.</p></div></div><p>The <a id="id479" class="indexterm"/>Font Awesome <code class="literal">iconCls</code> is not going to work for the Tree nodes, but as mentioned before, we can apply an override. An override is a way of changing the behavior of the Ext JS class. It would be similar to modifying the prototype of a JavaScript object—the new behavior is applied to all the instances of that class.</p><p>Even though Ext JS is open source, we should avoid changing the source code directly (despite the open source code philosophy). Changing the source code can be an issue when upgrading the framework version in the future. Using overrides is more elegant.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>The override we are going to use can be found at <a class="ulink" href="http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels">http://www.sencha.com/forum/showthread.php?281383-Glyph-support-on-treepanels</a>.</p></div></div><p>We are going to create the override inside the file <code class="literal">app/overrides/tree/ColumnOverride.js</code>. We cannot forget to change the name of the override to <code class="literal">Packt.overrides.tree.ColumnOverride</code> (the first line of code).</p><p>Then, inside <code class="literal">Application.js</code>, we are going to add the following code to make sure it is loaded when the application is loaded and the override is applied, as follows:</p><div class="informalexample"><pre class="programlisting">requires: [
    'Packt.overrides.tree.ColumnOverride'
],</pre></div><p>We can also add this <code class="literal">require</code> declaration inside the <code class="literal">Packt.view.menu.Tree</code> class to remind us that we are using an override as well, but it is optional.</p><p>This is what the <code class="literal">menu</code> table looks like at this moment. The modules have the Font Awesome CSS, and the menu options have the glyph codes (<code class="literal">iconCls</code> column), as follows:</p><div class="mediaobject"><img src="graphics/0457OT_05_08.jpg" alt="Using glyphs in TreePanel – working with overrides"/></div><p>You can use <a id="id480" class="indexterm"/>only the glyph codes throughout the application. We are using both to show it is possible to use both. From now on, you can use the approach you prefer.</p></div><div class="section" title="Menu locale support"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec09"/>Menu locale support</h4></div></div></div><p>We also <a id="id481" class="indexterm"/>need to add the keys to the <code class="literal">en.js</code> file (and other locale files as well). For the menu, these are the entries needed:</p><div class="informalexample"><pre class="programlisting">menu1 : 'Security',
menu11 : 'Groups and Permissions',
menu12 : 'Users',
staticData: 'Static Data',
actors: 'Actors',
categories: 'Categories',
languages: 'Languages',
cities: 'Cities',
countries: 'Countries',
cms: 'Content Management',
films: 'Films',
reports: 'Reports',
salesfilmcategory: 'Sales by Film Category'</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>Note the keys are the same entries as the <code class="literal">text</code> column from the <code class="literal">menu</code> table.</p></div></div></div></div><div class="section" title="Opening a menu item programmatically"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec26"/>Opening a menu item programmatically</h3></div></div></div><p>After <a id="id482" class="indexterm"/>the menu is rendered, the user will be able to select an option from it. The logic behind the method is: when the user selects an option from the menu we need to verify that the tab has already been created on the tab panel. If yes, we do not need to create it again; we only need to select the tab on the tab panel and make it active. If not, then we need to instantiate the screen selected by the user. To do so, the Controller will execute the following method:</p><div class="informalexample"><pre class="programlisting">onTreePanelItemClick: function(view, record, item, index, event, options){
    var mainPanel = this.getMainPanel(); // #1

    var newTab = mainPanel.items.findBy( // #2
        function (tab){ 
           return tab.title === record.get('text'); // #3
    });

    if (!newTab){ // #4
        newTab = mainPanel.add({            // #5
            xtype: record.get('className'), // #6
            closable: true,                 // #7
            glyph: record.get('glyph'),     // #8
            title: record.get('text')       // #9
        });
    }
    mainPanel.setActiveTab(newTab); // #10
}</pre></div><p>First, we need to get the reference of the tab panel (<code class="literal">#1</code>). We are using <code class="literal">this.getMainPanel()</code>, which was created by the Controller.</p><p>There are three ways of getting object references inside Controller methods. The first one is using the parameters passed to the method. The second one is using the <code class="literal">ComponentQuery</code> (that we have not discussed yet), and the third one is using <code class="literal">refs</code>.</p><p>For this example, we are going to use <code class="literal">refs</code>. We need to add the following code inside the Controller:</p><div class="informalexample"><pre class="programlisting">refs: [
    {
        ref: 'mainPanel',
        selector: 'mainpanel'
    }
],</pre></div><p>We can configure the selector we want the Controller to search for and the name of the reference. In this case, the Controller will create a method called <code class="literal">get</code> + <code class="literal">mainPanel</code> (in the <code class="literal">ref</code> name, the first letter becomes a capital letter) resulting in <code class="literal">getMainPanel</code>. This is equivalent to <code class="literal">reference</code> used by the ViewController.</p><p>Then, we need to <a id="id483" class="indexterm"/>verify that the selected menu option was already created (<code class="literal">#2</code>), and we will do it comparing the tab <code class="literal">title</code> with the <code class="literal">text</code> configuration of the selected node (<code class="literal">#3</code>).</p><p>If it is not a new tab, we will add it to the tab panel, passing as an instance to the <code class="literal">add</code> method (<code class="literal">#5</code>). So we will get the <code class="literal">xtype</code> configuration of the component we are going to add from the node <code class="literal">className</code> (<code class="literal">#6</code>), and the tab can be <code class="literal">closed</code> (<code class="literal">#7</code>); it will have the same <code class="literal">glyph</code> as its node (<code class="literal">#8</code>) and will also have the same <code class="literal">title</code> as the node (<code class="literal">#9</code>—menu option).</p><p>Then, we will set it as the active tab. If the screen is already rendered, we will only change the <code class="literal">active</code> tab to the screen that the user selected from the menu (<code class="literal">#10</code>).</p><p>The dynamic menu functionality is now complete!</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we learned how to implement an advanced dynamic menu using an Accordion layout and also TreePanels for each module of the application. We learned how to handle the dynamic logic on the sever side and also how to handle its return on the Ext JS side loading a Store to build the menu dynamically. And finally, we have also learned how to open an item from the menu programmatically and display it on the center component of the application. We also used the MVC architecture for the first time.</p><p>In the next chapter, we will learn how to implement screens to list, create, and update users and also how to assign a group to the user.</p></div></body></html>