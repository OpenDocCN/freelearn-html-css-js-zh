- en: Making Types That Represent Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we've seen how to build types to model many kinds of data.
    Through all of these chapters, we've relied on functions. Functions wrap calculations
    and actions for easy reuse, so it makes sense that they're among the most heavily
    used features in any programming language. So, by taking advantage of Reason's
    type system and functional programming techniques, we can design functions for
    maximum effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Meaningful function types and useful properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying and partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using functions to control dependency ordering and program flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used functions and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But first, what is a function? A **function** in type theory and mathematics
    has a formal definition, but we can think of it as a formula for calculating an
    output given an input. In Reason and other statically-typed functional programming
    languages, functions *always* have an output, even if they don't actually calculate
    anything. We'll examine how to express these inputs and outputs, but we first
    need a basic understanding of function types and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Function types and other useful properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Reason, functions have very specific types and, just like other values, functions
    of different types can't be substituted for one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic type of every Reason function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Read this as *a arrow b*.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the input, `a`, and the output, `b`, can be any type (even the
    same one). This basic function type, with a single input and a single output,
    gives rise to every other function type in Reason. We'll cover how this happens
    shortly, but first let's talk about a couple of useful functional programming
    concepts that are important in the type-driven world.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first property, called **referential transparency** (or **RT**), means that
    a function will always produce the same output, `b`, for a given input, `a`, no
    matter how, when, or how many times we call it. This means that a function can't
    behave unpredictably; we must be able to predict its output for every input, purely
    like a mathematical formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a non-referentially transparent function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Reason, float arithmetic operators are distinct from integer operators (they
    are suffixed with a dot). Reason tries to be as explicit as possible about arithmetic
    and conversions so that we can avoid surprising results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t tell what the output will be for any given input, `x`, because that
    depends on the date and time  the function is called. The problem instead is the
    hidden dependency on the current date or time. One solution is to remove the dependency
    by passing it in as a function argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The immediate benefit is that the function is easier to test, but the bigger
    benefit is that functions such as this in the codebase make it easier to reason
    about*.*
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning about code (also known as **equational reasoning**) means being able
    to substitute actual values in place of function arguments, and just like a math
    equation, evaluate to the result by simplifying it. This sounds like a trivial
    benefit, but when used over a codebase, it can be a powerful technique for ensuring
    transparency.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically speaking, we can't make the entire codebase referentially transparent
    (unless we use advanced techniques such as effect types). We can, however, push
    out the non-RT operations to the edges of the program. For example, we can call
    the (second) `xDaysAgo` function with either the result of a call to `Js.Date.now()` or
    a date value passed in from somewhere else. This is a simple but effective form
    of **dependency injection** (passing in values to a program instead of letting
    the program try to get the values itself). We'll cover dependency injection in
    more detail later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function purity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second important property that we try to achieve is **purity**. This concept
    means that, to the caller (that is, the code that calls it) and the outside world,
    a function has no impact other than evaluating to its result. We say that the
    function does not have any **observable effects**. Observability is the crucial
    thing here; there may well be effects happening and contained inside the function
    (such as mutation), but the caller doesn''t, and cannot, know about them. The
    following is an example of a pure function that mutates internally but not observably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we were to add a `Js.log(result^)` inside the body of the `for` loop, the
    function would become impure because its effects would become observable. People
    sometimes disagree with what exactly observable means, especially in the context
    of logging the operations of otherwise-pure functions, but it's safe to err on
    the side of caution and accept that any observable effect is an impurity in the
    function (and that's OK, because sometimes we actually need those observable effects).
  prefs: []
  type: TYPE_NORMAL
- en: Totality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last important property that we want functions to have is **totality**.
    This means that functions should handle every possible value of the type that
    they accept, which is actually trickier than it seems! For example, look at the
    `xDaysAgo` function again. What happens if `x` is negative? Or very large or small?
    Did we account for integer overflow? Especially when working with numbers, we
    need to understand their properties on the platform we're running on top of.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we''re running on a JavaScript platform such as Node.js, so all
    numbers are internally represented as IEEE floats (that''s how JavaScript works)
    and we can get pretty far before we need to worry about overflow. But consider
    the following trivial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first dollar symbol needs to be escaped, otherwise the compiler tries to
    treat it as starting an interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're just printing out what we want to happen. In a real application,
    we might want to do a money transfer. Suppose we exposed this function with an
    HTTP service call. What would happen if someone called the service with a negative
    float? The best-case scenario is that the error would be caught somewhere else;
    the worst is that people could make calls to siphon money out of other people's
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to solving this is to validate our arguments at the very beginning
    of the function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For good measure, in this snippet, we're doing some basic validation on the
    sender and receiver strings. We're also able to get rid of the type annotations
    because the assertions will cause them to be inferred correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert` is a built-in keyword, although it looks and works like a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the function''s point of view, internally it''s now a total function because
    it explicitly errors on the cases it doesn''t want to handle, but does handle
    the remaining happy path. To the outside world, however, the function is still
    taking in raw strings and floats, and failing to handle most of them. A better
    solution is to use more constrained types to describe exactly what the function
    can accept, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We had to use `to_` as the parameter name instead of `to` because the latter
    is a reserved keyword in Reason. It's a common practice to add an underscore to
    a keyword if we want to use it as a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet looks more verbose, but in the long run is the better solution
    because we can write tests for the wrapper types and their modules in isolation,
    get peace of mind that the types really do enforce our rules, and reuse the types
    instead of adding checks throughout the codebase. Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: We set up a type whose values can only be non-empty strings. If a caller tries
    to construct an empty string of the type, that will fail with an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type declaration says that this is a `private` type, meaning that we expose
    its internal representation, but we don't allow users to construct values of the
    type. This is a useful technique when we want to semi-transparently take an existing
    type and restrict it in some way. We will see how to do that shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, we set up a type whose values can be only positive floats.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `sendMoney` function, we reap the benefit of these types by only accepting
    these constrained types instead of their raw variants. The function is now total
    because it only accepts exactly the values it works with by (type) definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We still need to unwrap the constrained values to get at the raw ones, because
    ultimately we want to print the raw values. Because the types are declared as
    `private` though, we can **coerce** them back to their more general versions.
    Coercion means forcing a value of a constrained type (such as `NonEmptyString.t`)
    back to being a more general type (such as `string`). Coercion is completely static;
    if we can't coerce something, we'll get a compile error. Note that the syntax
    for coercion needs to be pretty exact, and it needs to include the parentheses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to wrap the values before we pass them into the function. This
    is the point that can potentially fail, so we've moved it outside of our function
    implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we've used the convention of adding `Exn` to the names of the functions
    that may throw exceptions. Some people prefer to return optional values instead
    of throwing exceptions. This convention is idiomatic and type-safe, but is ultimately
    just another method of reporting errors. The key point to take away is that any
    possible failures have been moved out of our total `sendMoney` function, and other
    functions that use constrained types.
  prefs: []
  type: TYPE_NORMAL
- en: What a function type means
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of type-driven development, why are functional programming concepts
    such as referential transparency, purity, and totality important? The reason is
    that a function's type has a well-understood mathematical meaning, and breaking
    such rules muddy this meaning.
  prefs: []
  type: TYPE_NORMAL
- en: A function type such as `a => b` means that a function of this type will accept
    an input of type `a` and evaluate to a result of type `b`, and will do nothing
    else (for example, print out a log, start the coffee maker, or launch missiles).
    We like having this guarantee in much the same way that we like knowing that an
    `int` is just an `int`, and not a missile launch followed by an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that Reason allows side effects is a great pragmatic decision, but
    we can still strive to push the side effects to the very edges of our programs
    and keep their cores purely functional. Purity in the functional sense is necessary
    for the type of a function to be accurate. If types in our program are accurate,
    we can perform type-driven development with more confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple arguments and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already mentioned that Reason functions always accept a single argument
    and return a single value, but we've been happily using functions that look like
    they take multiple arguments, for example, `xDaysAgo(now, x)`. How is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, functions with multiple arguments are automatically **curried**.
    This means that they are actually functions that accept a single argument and
    return a new function, which accepts the next argument, and so on, forming a chain
    of single-argument functions that finally return a result. This might seem like
    it''s inefficient, but in practice the compiler can almost always optimize the
    chain of calls into a single, efficient call. Let''s look at the following concrete
    example, defining `xDaysAgo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is equivalent to the following (which is supported by the Reason
    code formatter tool, and thus usually seen in the wild):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can call the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That is equivalent to the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The compiler understands that this syntax is a **fully applied** function call,
    and optimizes accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a call isn''t fully applied. In other words, it''s **partially applied**.
    This means that it has been called with only some of the arguments that it accepts.
    A partially-applied function is just a function that accepts one or more arguments
    but, by definition, fewer arguments than the original function. Let''s look at
    the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example captures the current moment in time by making a call to the appropriate
    JavaScript date function and then feeds or injects it into the `xDaysAgo` function
    to get back a new function that's been primed with the current time. This new
    function is then bound to the name `xDaysBeforeNow` and called to get a result.
    The result will be deterministic; in other words, we'll always get back the same
    output for a given input. The reason is that the non-deterministic data has already
    been *fed* into the function and is captured as a static value inside it. In other
    words, `xDaysBeforeNow` is also referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule, functions that we get from applications of a referentially-transparent
    function (such as `xDaysAgo`) are also referentially transparent. The same rule
    holds true for the other functional properties: purity and totality. This helps
    us out a lot when we''re building specialized functions out of more general ones,
    as we can start with confidence and keep that confidence at every step.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at another example of partial application that is both
    fun and shows its usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define a function that returns or prints the label
    for an envelope used to mail a letter, using the name of the recipient, the postal
    address, and so on. This function could be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the function the normal way, with all of its parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define another function for partial application, passing a value
    for the country parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass a value for the `lastname` parameter, for a function that
    prints the label for the members of the same household, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the JS resulting from the compilation of this example (`src/Ch07/Ch07_Currying.re`)
    gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Functions as values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we covered how function definitions syntactically **desugar**
    (that is, slightly more cumbersome syntax is used) into a series of chained function
    values. Let's examine the idea that functions are actually first-class values
    in Reason, just as much as things like numbers, strings, records, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Function literal syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason provides strong support for so-called **function literals,** also known
    as **lambdas** or **closures**. This means that, as in JavaScript and various
    other languages, we can directly write down function values wherever it''s legal
    to write down any value. The following is the basic syntax for a function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the syntax for writing a curried function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Reason provides a familiar-looking syntactic sugar for writing a curried function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the deliberate use of `PATTERN`, as with bindings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, Reason functions (whether literal or normal function bindings) can
    always directly pattern match on their parameters. As with any pattern match,
    however, we must be cautious about matching against refutable patterns in function
    parameters, because those risk failing at runtime. The following snippet includes
    examples of function literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This file shows quite a lot of things, explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a function using the syntax we've been using throughout the book,
    for comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to define and immediately bind a function literal using the slightly desugared
    Reason syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How to define and immediately bind a function literal using the fully desugared
    curried syntax. The important thing to realise here is that these three functions
    are of exactly the same type and behavior, and can be called in exactly the same
    way: `addV*n*(1, 2)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How to define a type that can contain two functions: one to convert a given
    type, `''a`, to a `float`, and another to convert the `float` back to that same
    `''a`. Note that we use the naming convention to show that both functions can
    potentially throw exceptions, because we can''t guarantee beforehand that every
    type `''a` can actually be converted to and from `float`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to define a `FloatConverter.t(float)`, which (trivially) knows how to convert
    a `float` to a `float`. The functions are implemented as simply `float => float`,
    which in this context means to return the same float that was received as input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to define a `FloatConverter.t(int)` that knows how to convert between `int` and
    `float`, using functions available in the Reason standard library for comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we saw how to define another greeter function by creating a function
    literal, using destructuring pattern matching of the parameter and binding the
    function to the name `greet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eta abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice that, in the preceding sixth point, we used two standard library-provided
    functions directly as values. We could have wrapped them inside first-class functions
    instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping something inside a function in general is called **eta abstraction**.
    It's an abstraction because it adds a layer of indirection instead of returning
    a value straight away. In other words, we first need to pass in an argument, which
    is substituted inside the body of the function, before the calculated result is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, an eta abstraction is necessary. For example, our preceding float
    converter needed a way to convert a `float` to a `float` in order to fit inside
    the type we set up. For that purpose, the eta abstraction `float => float` is
    perfect. However, eta abstraction is redundant when it wraps a single function
    call directly, for example, `int => float_of_int(int)` or `output => Js.log(output)`.
    This is because that single function call is already an equivalent eta abstraction;
    it already takes the same parameter and calculates the same result. Thanks to
    Reason functions being values, we can always pass them around directly.
  prefs: []
  type: TYPE_NORMAL
- en: Often, when we're concentrating on writing the functions we need, it's easy
    to miss these redundancies. Luckily, we can remove redundant eta abstractions
    when simplifying the codebase at a later date, and without changing the meaning
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are an important part of Reason and are used a lot. This chapter
    focused on presenting their essential properties: referential transparency, purity,
    and totality. We also discussed the specific techniques involved with Reason functions,
    such as currying and partial application.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at more approaches and techniques
    supported in Reason that help in code reuse and programming generically.
  prefs: []
  type: TYPE_NORMAL
