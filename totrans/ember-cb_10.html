<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Awesome Tasks with Ember</h1></div></div></div><p class="calibre8">In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Using Ember validations</li><li class="listitem">Using D3.js with Ember.js</li><li class="listitem">Using Ember with Sockets</li><li class="listitem">Using Ember with Firebase</li><li class="listitem">Using server-side rendering</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec76" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">In this chapter, you'll learn everything from validating form data to looking at Ember's server-side rendering. Each recipe will show you the power and possibilities that Ember gives to create ambitious applications.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec77" class="calibre1"/>Using Ember validations</h1></div></div></div><p class="calibre8">Data form validation is a <a id="id494" class="calibre1"/>very common use case in web development. The end <a id="id495" class="calibre1"/>user will know immediately if they've made a mistake when you create validation rules in your application.</p><p class="calibre8">In this recipe, we'll take a look at two examples on validation. In the first example, we'll use a component and check data based on a few simple validation rules. In the second example, we'll use a popular Ember add-on to make things easier.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec141" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, create two components and install the validation add-on:<div><pre class="programlisting">
<strong class="calibre9">$ ember g component val-example</strong>
<strong class="calibre9">$ ember g component val-example2</strong>
<strong class="calibre9">$ ember install ember-cp-validations</strong>
</pre></div><p class="calibre14">The <code class="email">val-example</code> component will be the first example. The <code class="email">val-example2</code> component will be the second example using the <code class="email">ember-cp-validations</code> add-on.</p></li><li class="listitem" value="2">Update the <a id="id496" class="calibre1"/><code class="email">val-example.hbs</code> component template file:<div><pre class="programlisting">// app/templates/components/val-example.hbs
Enter Age:&lt;br&gt;
{{input value=num}}
&lt;button {{action 'check'}}&gt;Check&lt;/button&gt;&lt;br&gt;
{{error}}&lt;br&gt;</pre></div><p class="calibre14">This component asks for an age. If the button is clicked, the <code class="email">'check'</code> action will be triggered. A simple <code class="email">input</code> helper is used to capture the input. The <code class="email">{{error}}</code> property displays the error text.</p></li><li class="listitem" value="3">In the <code class="email">val-example.js</code> component file, add a <code class="email">check</code> action and simple <code class="email">validation</code> method:<div><pre class="programlisting">// app/components/val-example.js
import Ember from 'ember';

export default Ember.Component.extend({
    num: null,
    actions:{
      check(){
        if(this.validation(this.get('num'))){
          this.set('error','');
        }
        else{
          this.set('error','Error in box!');
        }

        console.log(this.getProperties('num'));
      }
    },
    validation(value){
      return Number(parseInt(value))==value;
    }

});</pre></div><p class="calibre14">The <code class="email">check</code> action calls the <code class="email">validation</code> method. The <code class="email">validation</code> method's only purpose is to return <code class="email">true</code> if the value is a number and return <code class="email">false</code> if the value is not. This result is used to set the <code class="email">error</code> property that will be used in the template.</p><p class="calibre14">This is a fairly simple example. It shows what you might need to validate the field. Another example might be creating a new computed property and have it depend on the <code class="email">num</code> property. Either way will work.</p></li><li class="listitem" value="4">Add the component <a id="id497" class="calibre1"/>to the <code class="email">application.hbs</code> template file:<div><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}

{{val-example}}</pre></div><p class="calibre14">The <code class="email">val-example</code> component will render at <code class="email">{{val-example}}</code>.</p></li><li class="listitem" value="5">Run <code class="email">ember server</code> and enter a non-numeric value in the textbox. The following window will be displayed:<div><img src="img/00073.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">The <strong class="calibre9">Error in box!</strong> message is displayed because a number was not entered. This was triggered after the <strong class="calibre9">Check</strong> button was clicked.</p><p class="calibre14">For the next example, we'll use an Ember add-on instead.</p></li><li class="listitem" value="6">Update <a id="id498" class="calibre1"/>the <code class="email">val-example2.hbs</code> template file so that it can accept an e-mail and number:<div><pre class="programlisting">// app/templates/components/val-example2.hbs
Enter Age:&lt;br&gt;
{{input value=num}}&lt;br&gt;
    &lt;div style='color: red'&gt;
      {{message}}&lt;br&gt;
    &lt;/div&gt;
Enter Email:&lt;br&gt;
{{input value=email}}&lt;br&gt;
    &lt;div style='color: red'&gt;
      {{emailMessage}}&lt;br&gt;
    &lt;/div&gt;
&lt;button {{action 'check'}}&gt;Check&lt;/button&gt;&lt;br&gt;</pre></div><p class="calibre14">This second component is a little more complicated than the first. We'll be validating two form fields, a number field and e-mail field. In addition, we'll be surrounding the message in a <code class="email">div</code> tag that will be used to help set <code class="email">color</code> of the text. Both fields will be validated after pressing the <code class="email">check</code> button.</p></li><li class="listitem" value="7">Create a new <code class="email">validations.js</code> file in the <code class="email">components</code> folder:<div><pre class="programlisting">// app/components/validations.js
import { validator, buildValidations } from 'ember-cp-validations';

export default buildValidations({
    num: [
    validator('number',{
      allowString: true,
      integer: true,
      message: 'Error! This is not an integer!'
    }),
    validator('presence', true)
    ],
    email: [
      validator('format', {
        type: 'email',
        message: 'This is not an email address!'
      }),
    ],
});</pre></div><p class="calibre14">This file is needed for the <code class="email">ember-cp-validations</code> add-on. In this file, we define our validation rules. We begin by naming each property and defining the validations needed. We can validate many different types of inputs. A list of <a id="id499" class="calibre1"/>these validations can be found at <a class="calibre1" href="http://offirgolan.github.io/ember-cp-validations/docs/index.html">http://offirgolan.github.io/ember-cp-validations/docs/index.html</a>.</p><p class="calibre14">The <code class="email">validator</code> add-on comes with several prebuilt messages. We can overwrite these <a id="id500" class="calibre1"/>messages by setting the <code class="email">message</code> property. In the preceding code, the <code class="email">num</code> and <code class="email">email</code> validators have custom messages. The <code class="email">num</code> validator checks to see whether any value is in the field and whether it's a number. The e-mail field checks to see whether the value is in the format of an e-mail address.</p></li><li class="listitem" value="8">Add a new <code class="email">check</code> action to the component:<div><pre class="programlisting">// app/components/val-example2.js
Import Ember from 'ember';
import Validations from './validations';

export default Ember.Component.extend(Validations,{
    num: null,
      email: null,
      message: '',
      emailMessage: '',
      actions: {
        check(){
          this.set('message','');
          this.set('emailMessage','');
          this.validate().then(({model, validations})=&gt;{

            if(validations.get('isValid')){
              this.set('message','');
              this.set('emailMessage','');
            }
            else{

              if(model.get('validations.attrs.num.isInvalid')){
                this.set('message',model.get('validations.attrs.num.messages'));
              }
              if(model.get('validations.attrs.email.isInvalid')){
                this.set('emailMessage',model.get('validations.attrs.email.messages'));
              }
            }

          },(errors)=&gt;{
            console.log(errors);
          });

        }
      }
});</pre></div></li><li class="listitem" value="9">After setting up the <code class="email">validations</code> file, you can add it to the component as a mixin. After <a id="id501" class="calibre1"/>adding the <code class="email">validations</code> mixin, you'll have access to the <code class="email">validate()</code> method. This is a promise that returns after it validates the fields:<div><pre class="programlisting">…
    this.validate().then(({model, validations})=&gt;{

      if(validations.get('isValid')){
        this.set('message','');
        this.set('emailMessage','');
      }
…</pre></div><p class="calibre14">The <code class="email">validations</code> have an <code class="email">isValid</code> property. This will only return <code class="email">true</code> if both properties, <code class="email">num</code> and <code class="email">email</code>, passed <code class="email">validation</code>.</p></li><li class="listitem" value="10">We can check each individual validation as well:<div><pre class="programlisting">…
 else{

    if(model.get('validations.attrs.num.isInvalid')){
      this.set('message',model.get('validations.attrs.num.messages'));
    }
    if(model.get('validations.attrs.email.isInvalid')){
      this.set('emailMessage',model.get('validations.attrs.email.messages'));
…</pre></div><p class="calibre14">We can access the <code class="email">model</code> properties in the component. This <code class="email">model</code> will have both the <code class="email">num</code> and email <code class="email">properties</code>. We can use <code class="email">validations.attrs.num.isInvalid</code> to check whether the validation failed. If it did, we can set  <code class="email">message</code> we created earlier with <code class="email">validations.attrs.num.messages</code>.</p><p class="calibre14">In the preceding code, if the validation is not valid, then we set the error message that will be displayed in the template after the <code class="email">check</code> action is triggered.</p><p class="calibre14">This add-on is very flexible. We can create our own custom validations if needed.</p></li><li class="listitem" value="11">Update the <a id="id502" class="calibre1"/><code class="email">application.hbs</code> file with the second component:<div><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}


{{val-example2}}</pre></div><p class="calibre14">This will display the second component example in our application template.</p></li><li class="listitem" value="12">Start the Ember server and enter invalid values for age and e-mail, and click on the <strong class="calibre9">Check</strong> button. The following image will be displayed:<div><img src="img/00074.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">After clicking on the <strong class="calibre9">Check</strong> button, an action is triggered. The validators we created earlier check the text and return whether the text is valid or not. In this instance, the text is not valid so it displays an error message.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec142" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Data form <a id="id503" class="calibre1"/>validation is an extremely important feature of any web app. Any Ember application that has any type of user forms will need to validate data. Ember.js can retrieve data from templates and validate it. Other properties can be used to toggle or set error messages to be displayed.</p><p class="calibre8">The Ember CP validations add-on makes this process easier. You can create your own validations or use some of the built-in ones. This code uses computed properties and other methods to validate and report back issues to the user.</p><p class="calibre8">There are several other popular <a id="id504" class="calibre1"/>validation add-ons available on Ember. Check out this website for more information: <a class="calibre1" href="http://emberobserver.com/categories/validations">http://emberobserver.com/categories/validations</a></p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec78" class="calibre1"/>Using D3.js with Ember.js</h1></div></div></div><p class="calibre8">D3.js is a <a id="id505" class="calibre1"/>JavaScript library used to manipulate document <a id="id506" class="calibre1"/>data. It can be used to create shapes, animations, and powerful visualizations. It uses web standards such as HTML, SVG, and CSS to accomplish its goals.</p><p class="calibre8">Ember.js can use D3 by importing it as a library using Bower or using it as an add-on. We'll be trying it out using Bower. However, you can install the popular <code class="email">ember-cli-d3</code> package (<code class="email">ember install ember-cli-d3</code>) instead and get some extra functionality.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec143" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, run these commands in the <code class="email">application</code> folder:<div><pre class="programlisting">
<strong class="calibre9">$ bower install d3 –save</strong>
<strong class="calibre9">$ ember g component d3-code</strong>
</pre></div><p class="calibre14">The <code class="email">bower</code> command will install D3 and save it to the <code class="email">bower.json </code>file. The component will end up holding all our D3 code.</p></li><li class="listitem" value="2">Edit the <code class="email">ember-cli-build.js</code> file and add the <code class="email">d3</code> file:<div><pre class="programlisting">// ember-cli-build.js
/*jshint node:true*/
/* global require, module */
var EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
    var app = new EmberApp(defaults, {
      // Add options here
});

app.import('bower_components/d3/d3.js');
return app.toTree();
};</pre></div><p class="calibre14">This file is <a id="id507" class="calibre1"/>where we can add all our third-party libraries. To add D3, we have to add the <code class="email">app.import</code> statement pointing to the directory where the D3 library is. At this point, D3 will be available to use anywhere in the application.</p></li><li class="listitem" value="3">Open the <code class="email">d3-code.js</code> template file and add a <code class="email">div</code> tag:<div><pre class="programlisting">&lt;div id='holder'&gt;&lt;/div&gt;</pre></div><p class="calibre14">This will be our placeholder for the animation we'll be creating later.</p></li><li class="listitem" value="4">Edit the <a id="id508" class="calibre1"/><code class="email">d3-code.js</code> file in the <code class="email">components</code> folder. Add a new circle animation:<div><pre class="programlisting">// app/components/d3-code.js
import Ember from 'ember';

export default Ember.Component.extend({
    didInsertElement() {

      let svgContainer = d3.select('#holder').append('svg').attr('width',700)
      .attr('height',700);


      svgContainer.append('circle').attr('cx',250)
      .attr('cy',250)
      .attr('r', 100)
      .transition()
      .attr('cx',500)
      .attr('cy',450)
      .duration(2000)
      .style('fill','red');

    }
});</pre></div><p class="calibre14">This component's purpose is to use D3 to create a new <code class="email">svg</code> tag and a new <code class="email">circle</code> object in it. To accomplish this, we want to render it on screen after the component loads. Ember.js views (<code class="email">components</code>) have <code class="email">didInsertElement</code>, <code class="email">willInsertElement</code>, and <code class="email">willDestroyElement</code> hooks. These all correspond to different points in the component's application life cycle.</p><p class="calibre14">The <code class="email">willInsertElement</code> hook takes place after the view has rendered but before it has <a id="id509" class="calibre1"/>been inserted into the DOM. The <code class="email">didInsertElement</code> hook occurs after the view has been inserted into the DOM. It's the most useful hook to use when dealing with third-party libraries such as D3. The <code class="email">willDestroyElement</code> hook is called before the element is removed from the DOM. This is a good place to put code that removes event handlers that you might have added.</p><p class="calibre14">The <code class="email">svgContainer</code> variable creates the <code class="email">svg</code> tag and appends it to the <code class="email">div</code> holder we created earlier. The <code class="email">circle</code> variable appends the <code class="email">circle</code> tag that will be animated.</p></li><li class="listitem" value="5">Add the component to the application template:<div><pre class="programlisting">// app/templates/application.hbs

{{d3-code}}</pre></div><p class="calibre14">This <a id="id510" class="calibre1"/>adds the component to the application <a id="id511" class="calibre1"/>template so that it can be rendered.</p></li><li class="listitem" value="6">Run <code class="email">ember server</code> and you'll see the circle move from one side of the screen to the other:<div><img src="img/00075.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">The circle will move from the top left-hand side corner to the bottom right-hand side corner after the page loads. This occurs after the component is completely rendered on screen.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec144" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">D3 uses web standards to generate powerful visualizations. Ember can import any third-party library <a id="id512" class="calibre1"/>using the built-in Broccoli library. Once a library is loaded, it can be accessed throughout the application. We can use the <code class="email">didInsertElement</code> <a id="id513" class="calibre1"/>hook in our view to manipulate the DOM. D3 will render a circle on the screen and animate it.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec79" class="calibre1"/>Using Ember with Sockets</h1></div></div></div><p class="calibre8"><strong class="calibre9">WebSockets</strong> <a id="id514" class="calibre1"/>make it possible to open a communication <a id="id515" class="calibre1"/>session with a server. Ember.js does not handle this <a id="id516" class="calibre1"/>natively. However, there are some easy-to-use add-ons that can be used to make this possible.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec145" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, generate a new route and install the WebSockets add-on:<div><pre class="programlisting">
<strong class="calibre9">$ ember install ember-websockets</strong>
<strong class="calibre9">$ ember g component w-s</strong>
<strong class="calibre9">$ ember g route ws</strong>
</pre></div><p class="calibre14">This will install the component route and add-on that we need to begin.</p></li><li class="listitem" value="2">In the <code class="email">components</code> template folder, edit the <code class="email">w-s.hbs</code> file:<div><pre class="programlisting">// app/templates/components/w-s.hbs
Welcome Chat!&lt;br&gt;&lt;br&gt;

Received Message: {{message}}&lt;br&gt;
&lt;button id="sendButtonPressed" {{action "sendButtonPressed"}}&gt;Press Me&lt;/button&gt;</pre></div><p class="calibre14">In this template, we have a <code class="email">message</code> property and button that sends an action, <code class="email">sendButtonPressed</code>. When the action is triggered, a message is sent to the server. The <code class="email">message</code> property will display any messages returned from the server.</p></li><li class="listitem" value="3">Update the <code class="email">w-s.js</code> component file so that it can handle the action from the template:<div><pre class="programlisting">// app/components/w-s.js
import Ember from 'ember';

export default Ember.Component.extend({
    websockets: Ember.inject.service(),
    socket: null,
    init() {
      this._super();
      let socket = this.get('websockets').socketFor('ws://localhost:7000/');
      this.set('socket',socket);
      socket.on('open', this.myOpenHandler, this);
      socket.on('message', this.myMessageHandler, this);
      socket.on('close', (event)=&gt; {
        console.log('closed');
      }, this);
    },
    message: '',

    myOpenHandler(event) {
      console.log('On open event has been called: ' + event);
    },

    myMessageHandler(event) {
      console.log('Message: ' + event.data);
      this.set('message',event.data);
    },

    actions: {
      sendButtonPressed() {
        this.get('socket').send('Hello Websocket World');
      }
    }
});</pre></div><p class="calibre14">The <a id="id517" class="calibre1"/>add-on installs a service called <code class="email">websockets</code> <a id="id518" class="calibre1"/>in the application. It can be accessed by injecting it into the component using <code class="email">Ember.inject.service</code>. As the property name matches the service name, we don't need to specify the service name in the inject statement.</p></li><li class="listitem" value="4">To begin, we'll set up the <code class="email">init</code> function:<div><pre class="programlisting">…
    init() {
      this._super();
      let socket = this.get('websockets').socketFor('ws://localhost:7000/');
      this.set('socket',socket);
      socket.on('open', this.myOpenHandler, this);
      socket.on('message', this.myMessageHandler, this);
      socket.on('close', (event)=&gt; {
        console.log('closed');
      },this);
    },
…</pre></div><p class="calibre14">The <code class="email">init</code> function in a component is called on when the object is instantiated. You can override this by setting up your own <code class="email">init</code>. To make sure that nothing odd occurs, we must call <code class="email">this._super()</code> so that Ember sets up the component correctly.</p><p class="calibre14">The <a id="id519" class="calibre1"/>
<code class="email">socket.on</code> method creates three events called <code class="email">open</code>, <code class="email">message</code>, and <code class="email">close</code>. During instantiation, these three event handlers are <a id="id520" class="calibre1"/>created. The first one handles events that occur when a connection is made with the server.</p><p class="calibre14">The WebSocket service can be set up using the <code class="email">socketFor</code> method. This tells the service where the server is located.</p><div><pre class="programlisting">…
    message: '',

    myOpenHandler(event) {
      console.log('On open event has been called: ' + event);
    },
…</pre></div><p class="calibre14">When the connection is established, a message is logged to the console.</p></li><li class="listitem" value="5">The second event is triggered when a message is received from the server:<div><pre class="programlisting">…
    myMessageHandler(event) {
      console.log('Message: ' + event.data);
      this.set('message',event.data);
    },
…</pre></div></li><li class="listitem" value="6">After a message is received, it's set to the <code class="email">message</code> property. The last event is triggered when the connection with the server is closed:<div><pre class="programlisting">…
    socket.on('close', (event)=&gt; {
      console.log('closed');
    }, this);
..</pre></div><p class="calibre14">This logs a message to the console.</p></li><li class="listitem" value="7">The <a id="id521" class="calibre1"/><code class="email">sendButtonPressed</code> action creates a message and sends it to the server:<div><pre class="programlisting">…
    actions: {
      sendButtonPressed() {
        this.get('socket').send('Hello Websocket World');
      }
    }
…</pre></div><p class="calibre14">After the action is triggered, we use the existing <code class="email">socket</code> property to send a message out to the server.</p></li><li class="listitem" value="8">Add the <code class="email">w-s</code> component to the <code class="email">ws.hbs</code> route:<div><pre class="programlisting">// app/templates/ws.hbs
{{w-s}}</pre></div><p class="calibre14">The component <a id="id522" class="calibre1"/>will render at <code class="email">{{w-s}}</code>.</p></li><li class="listitem" value="9">Load the server and navigate to the <code class="email">w-s</code> route at <code class="email">/ws</code>. You'll see the following message:<div><img src="img/00076.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">This message displays the values from the server. Pressing the button sends a message to the server.</p><p class="calibre14">You can see how we can take this simple example and create a complete chat server.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec146" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">WebSockets <a id="id523" class="calibre1"/>helps facilitate communication between a server and browser. The <a id="id524" class="calibre1"/>browser can send and receive data over sockets. This can be used with event-driven messages or APIs.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec147" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">There are many ways to implement a WebSockets server. A great way to do this is to use the ws library. In the following steps, we'll create a basic WebSockets server to use with this recipe:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new empty directory and run this command:<div><pre class="programlisting">
<strong class="calibre9">$ npm init</strong>
</pre></div><p class="calibre14">Follow the prompts and create your project.</p></li><li class="listitem" value="2">Install the <code class="email">ws</code> package:<div><pre class="programlisting">
<strong class="calibre9">$ npm install ws –save</strong>
</pre></div><p class="calibre14">This will install the <code class="email">ws</code> <code class="email">npm</code> package and save it to the <code class="email">package.json</code> file.</p></li><li class="listitem" value="3">Create a new <code class="email">server.js</code> file. Create a simple WebSockets server:<div><pre class="programlisting">// server.js
var WebSocketServer = require('ws').Server;
var ws = new WebSocketServer({port: 7000});


ws.on('connection', function connection(ws) {
ws.on('message', function incoming(message) {
    console.log('received: %s', message);
    ws.send('Hey! Welcome to my websocket challenge!');
});


});</pre></div></li><li class="listitem" value="4">Start the node server:<div><pre class="programlisting">
<strong class="calibre9">$ node ./server.js</strong>
</pre></div><p class="calibre14">This server creates <code class="email">port</code> open at <code class="email">7000</code>. It then waits for a connection. If it receives a message, it outputs it to the console and returns a new message. This <a id="id525" class="calibre1"/>will be displayed in the Ember template <a id="id526" class="calibre1"/>file and received by the message handler.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec80" class="calibre1"/>Using Ember with Firebase</h1></div></div></div><p class="calibre8">Firebase <a id="id527" class="calibre1"/>is a backend as a service provider. It can store data and <a id="id528" class="calibre1"/>authenticate your users with just a few lines of code. It integrates well with many different frameworks, including Ember.js.</p><p class="calibre8">In this recipe, we'll take a look at a few of the features of Firebase by creating a blogging application. This app will allow users to create, edit, or delete posts. Users will be able to log in with Twitter and be authenticated as well.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec148" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before getting started, we <a id="id529" class="calibre1"/>must set up an account with Firebase at <a class="calibre1" href="http://www.firebase.com">http://www.firebase.com</a>. Google owns Firebase so this should be really easy. In fact, you should be able to log in directly with your Google credentials.</p><p class="calibre8">After logging in, you'll need to create a new application and set up a new provider. Follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Create a new application in the Firebase dashboard. It should look like the following image. Write down <strong class="calibre9">APP URL</strong> for later:<div><img src="img/00077.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="2">After <a id="id530" class="calibre1"/>creating the app, click on <strong class="calibre9">manage</strong> and then <a id="id531" class="calibre1"/>click on the left-hand side, where it says <strong class="calibre9">Login &amp; Auth</strong>. Click on <strong class="calibre9">Twitter</strong> and enter your <strong class="calibre9">Twitter API Key </strong>and <strong class="calibre9">Twitter API Secret</strong>:<div><img src="img/00078.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">To get <a id="id532" class="calibre1"/>these keys, you'll need to create a new <a id="id533" class="calibre1"/>application through Twitter. To do this, go to <code class="email">apps.twitter.com</code> and click on <strong class="calibre9">CREATE NEW APP</strong>. Follow the <a id="id534" class="calibre1"/>onscreen instructions. Make sure to set the callback URL to <code class="email">https://auth.firebase.com/auth/twitter/callback</code>.</p><p class="calibre14">This should be it. Make sure that you write down the name of the URL that Firebase created. You'll need it later when you set everything up in the <code class="email">environment.js</code> file.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec149" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, generate and install these files:<div><pre class="programlisting">
<strong class="calibre9">$ ember install emberfire</strong>
<strong class="calibre9">$ ember install torii</strong>
<strong class="calibre9">$ ember install ember-bootstrap</strong>
<strong class="calibre9">$ ember install ember-cli-showdown</strong>
<strong class="calibre9">$ ember g route new</strong>
<strong class="calibre9">$ ember g route posts</strong>
<strong class="calibre9">$ ember g route application</strong>
<strong class="calibre9">$ ember g controller new</strong>
<strong class="calibre9">$ ember g controller posts</strong>
<strong class="calibre9">$ ember g model post title:string body:string author:string titleURL:string</strong>
<strong class="calibre9">$ ember g template index</strong>
<strong class="calibre9">$ ember g util clean</strong>
</pre></div><p class="calibre14">The files generated will be the skeleton of our application. The two <code class="email">install</code> commands will install the necessary files for Firebase with authentication using an add-on called <code class="email">torii</code>.</p></li><li class="listitem" value="2">Verify <a id="id535" class="calibre1"/>that the application adapter is set up for <a id="id536" class="calibre1"/>Firebase:<div><pre class="programlisting">// app/adapters/application.js
import Ember from 'ember';
import FirebaseAdapter from 'emberfire/adapters/firebase';

const { inject } = Ember;

export default FirebaseAdapter.extend({
  firebase: inject.service(),
});</pre></div><p class="calibre14">This adapter is automatically generated for us when we install the <code class="email">emberfire</code> add-on. It injects the Firebase service into our application and data store.</p></li><li class="listitem" value="3">Configure the <code class="email">emberfire</code> adapter by editing the <code class="email">environment.js</code> file:<div><pre class="programlisting">// config/environment.js
…
    firebase: 'https://testemberfire.firebaseio.com/',
    torii: {
      sessionServiceName: 'session'
    },
…</pre></div><p class="calibre14">To use Firebase, you must set the <code class="email">firebase</code> property to your Firebase URL that you created earlier. Make sure that the <code class="email">torii</code> property is also set so that we can use the <code class="email">session</code> object in our application.</p></li><li class="listitem" value="4">Add a new folder called <code class="email">torii-adapters</code> and add the <code class="email">application.js</code> file:<div><pre class="programlisting">// app/tori-adapters/application.js
import Ember from 'ember';
import ToriiFirebaseAdapter from 'emberfire/torii-adapters/firebase';
export default ToriiFirebaseAdapter.extend({
    firebase: Ember.inject.service()
});</pre></div><p class="calibre14">Torii is a <a id="id537" class="calibre1"/>type of authentication abstraction for <a id="id538" class="calibre1"/>Ember.js. This will make it possible to use the session variable in our program.</p></li><li class="listitem" value="5">Update the <code class="email">clean.j</code>s file in the <code class="email">utils</code> folder:<div><pre class="programlisting">// app/utils/clean.js
export default function clean(title) {
    title = title.replace(/ /g, '_');
    return title.replace(/[^a-zA-Z0-9-_]/g, '');
}</pre></div><p class="calibre14">This file is simply used to clean a URL and return it. In other words, it removes anything other than dashes and the characters, <code class="email">a-z</code>. We'll be using this later for our URLs.</p></li><li class="listitem" value="6">Let's take a look at the model file and make sure that it looks <em class="calibre13">OK</em>:<div><pre class="programlisting">// app/models/post.js
import DS from 'ember-data';

export default DS.Model.extend({
    title: DS.attr('string'),
    body: DS.attr('string'),
    author: DS.attr('string'),
    titleURL: DS.attr('string')

});</pre></div><p class="calibre14">The model contains all the data we'll be using for each post in our application. This should have been generated earlier.</p></li><li class="listitem" value="7">Update the <code class="email">router.js</code> file using the <code class="email">titleURL</code> as the path:<div><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

const Router = Ember.Router.extend({
    location: config.locationType
});

Router.map(function() {
    this.route('posts', {path: '/:titleURL'}, function() {
});
    this.route('new');
});

export default Router;</pre></div><p class="calibre14">Some of <a id="id539" class="calibre1"/>this was generated for us when we <a id="id540" class="calibre1"/>created the posts and new route. However, we want to make sure that <code class="email">titleURL</code> is set to the path of each individual post. We do this by passing the <code class="email">:titleURL</code> dynamic segment to the path.</p></li><li class="listitem" value="8">Add the query for each individual post to the posts route:<div><pre class="programlisting">// app/routes/posts.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(param) {
      return this.store.query('post', {
        orderBy: 'titleURL',
      equalTo: param.titleURL });
    }
});</pre></div><p class="calibre14">When the user navigates to the <code class="email">/posts</code> URL, the model will expect a parameter passed in. For example, if you navigate to <code class="email">/posts/my_post</code>, the <code class="email">my_post</code> segment will be passed as a parameter that can be accessed in the route. We'll use this parameter in the Firebase <code class="email">this.store.query</code> method. The first argument is the name of the model. We can then use <code class="email">orderBy</code> and <code class="email">equalTo</code> to specify the exact post that we are looking for.</p><div><h3 class="title2"><a id="tip30" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Uniqueness</strong></p><p class="calibre8">As you can imagine, when creating a new post, the title may or may not be unique. The <code class="email">this.store.query</code> method will return all results as an array to the model. We could enforce uniqueness in Firebase by making the <code class="email">titleURL</code> unique. Another possibility would be to check the uniqueness of the post title during creation. Either way, for this example, we'll assume that all titleURLs are unique.</p></div></li><li class="listitem" value="9">Edit the <a id="id541" class="calibre1"/>application route file and add the model <a id="id542" class="calibre1"/>and a few actions:<div><pre class="programlisting">// app/routes/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return this.store.findAll('post');
    },
    actions:{
      login(){
        this.get('session').open('firebase', { provider: 'twitter'}).then((data)=&gt; {
        });
      },
      logout(){
        this.get('session').close();
      }
    }
});</pre></div><p class="calibre14">We want the main application to have access to the model route so that we can use the <code class="email">findAll</code> method to retrieve all posts. This is basically the same as the Ember Data method we've used in previous recipes.</p><p class="calibre14">There are two actions, <code class="email">login</code> and <code class="email">logout</code>. As we injected, using <code class="email">torii</code>, our session into the program, we can access it from anywhere. By invoking <code class="email">this.get('session')</code>, we can <code class="email">open</code> or <code class="email">close</code> a session. Firebase has several built-in authenticators, including Twitter and Facebook. The <code class="email">login</code> action in this example will <code class="email">open</code> a window to <code class="email">twitter</code> so that the user can be authenticated.</p><div><h3 class="title2"><a id="tip31" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Firebase security</strong></p><p class="calibre8">With any JavaScript <a id="id543" class="calibre1"/>browser application, security can be tricky. Firebase makes this a little easier for us. Firebase keeps track of users that are authenticated. In the Firebase dashboard, you can set rules that make it possible for only authenticated users to receive data. This is a little beyond the scope of this recipe. However, it is possible to secure your data with Firebase using a third-party authenticator such as Twitter or Facebook.</p></div></li><li class="listitem" value="10">Open the application template file. Add a navigation bar at the top and buttons to <a id="id544" class="calibre1"/>log in, log out, and add a new post:<div><pre class="programlisting">//app/templates/application.hbs
&lt;nav class="navbar navbar-inverse navbar-fixed-top"&gt;
    &lt;div class="container-fluid"&gt;
    &lt;div class="navbar-header" href="#"&gt;
    {{#link-to 'index' class='navbar-brand'}}My New Blog{{/link-to}}
    &lt;/div&gt;
    &lt;ul class="nav navbar-nav"&gt;
    {{#if session.isAuthenticated}}
    &lt;li&gt;{{#link-to 'new'}}Add New Post{{/link-to}}&lt;/li&gt;
    {{/if}}
    &lt;/ul&gt;
    &lt;ul class="nav navbar-nav navbar-right"&gt;
    {{#unless session.isAuthenticated}}
    &lt;li&gt;&lt;a href="#" {{action 'login' }}&gt;Login&lt;/a&gt;&lt;/li&gt;
    {{else}}
    &lt;li&gt;&lt;a href="#" {{action 'logout' }}&gt;Logout&lt;/a&gt;&lt;/li&gt;
    {{/unless}}
    &lt;/ul&gt;
    &lt;/div&gt;
&lt;/nav&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
{{outlet}}</pre></div><p class="calibre14">As we have installed the <code class="email">ember-bootstrap</code> add-on, we can create a really simple top <a id="id545" class="calibre1"/>navigation bar. The <code class="email">login</code> and <code class="email">logout</code> buttons are surrounded by the <code class="email">if</code> helper. In every template, you have access to the <code class="email">session</code> property. This property has a method called <code class="email">isAuthenticated</code> that returns <code class="email">true</code> if the user is logged in and <code class="email">false</code> if the user is not logged in. We can use this to show the <code class="email">login</code> button only if the user is <em class="calibre13">NOT</em> logged in. If the user is logged in, they'll see a <code class="email">logout</code> button.</p><p class="calibre14">We don't have an application controller, so these actions will bubble up to the application route where they'll be handled.</p></li><li class="listitem" value="11">Now update the <code class="email">index.hbs</code> file with a link to each individual post:<div><pre class="programlisting">// app/templates/index.hbs

&lt;div class = 'row'&gt;
    &lt;div class='col-md-4'&gt;
      &lt;h1&gt;Posts&lt;/h1&gt;
        {{#each model as |post|}}
          &lt;br&gt;{{#link-to 'posts' post.titleURL}}{{post.title}}{{/link-to}}
        {{/each}}
    &lt;/div&gt;

&lt;/div&gt;</pre></div><p class="calibre14">The <code class="email">model</code> loops through each post and displays the <code class="email">title</code> on the screen. Each <code class="email">titleURL</code> is passed as a parameter to the posts route.</p></li><li class="listitem" value="12">In the new <a id="id546" class="calibre1"/>template, add some textboxes so that the user <a id="id547" class="calibre1"/>can add a post. Add a section to preview a post as well:<div><pre class="programlisting">// app/templates/new.hbs
&lt;br&gt;&lt;br&gt;
&lt;div class='col-md-4 border' &gt;
    &lt;h1&gt;New Post&lt;/h1&gt;
    &lt;form {{action 'save' on="submit"}}&gt;
      &lt;dl&gt;
        &lt;dt&gt;Title:&lt;br&gt; {{textarea value=title cols="40" |rows="1" placeholder='Title'}}&lt;/dt&gt;
        &lt;dt&gt;Body:&lt;br&gt; {{textarea value=body cols="40" rows="6" placeholder='Body'}}&lt;/dt&gt;
      &lt;/dl&gt;
      &lt;button type='submit' class='btn btn-primary'&gt;Add&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;div class='col-md-4 border'  &gt;
    &lt;h1&gt;Preview&lt;/h1&gt;
    &lt;h3&gt;{{title}}&lt;/h3&gt;
    &lt;h4&gt;{{markdown-to-html markdown=body}}&lt;/h4&gt;
&lt;/div&gt;</pre></div><p class="calibre14">The new template will be used to create a new post. The <code class="email">textarea</code> helper creates two textboxes. The form has a <code class="email">save</code> action that will be triggered when the form is submitted.</p><p class="calibre14">When setting up the project, we installed a <code class="email">markdown</code> add-on. This allows us to use <code class="email">markdown</code> in the body of the post. Markdown is a text-to-HTML conversion tool. It makes it easier to write HTML in your text.</p></li><li class="listitem" value="13">In the <a id="id548" class="calibre1"/>posts template, display each post and show <a id="id549" class="calibre1"/>a way to edit the post as well:<div><pre class="programlisting">// app/templates/posts.js
{{#each model as |model|}}
&lt;div class='row'&gt;
    {{#if isEditing}}
      &lt;div class='col-md-4 border'&gt;
        &lt;form {{action 'save' on='submit'}}&gt;
          &lt;dl&gt;
            &lt;dt&gt;Title:&lt;br&gt; {{textarea value=model.title cols='40' rows='1'}}&lt;/dt&gt;
            &lt;dt&gt;Body:&lt;br&gt; {{textarea value=model.body cols='40' rows='6'}}&lt;/dt&gt;
          &lt;/dl&gt;
      &lt;div class = 'row'&gt;
        &lt;button type='submit' class = 'btn btn-primary'&gt;Done&lt;/button&gt;
      &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    {{/if}}
    &lt;div class='col-md-4 border'&gt;
      &lt;h1&gt;{{model.title}}&lt;/h1&gt;
      &lt;h3&gt;{{markdown-to-html markdown=model.body}}&lt;/h3&gt;
      &lt;h4&gt;-{{model.author}}&lt;/h4&gt;
      {{#if session.isAuthenticated}}
        &lt;form {{action 'edit' }}&gt;
        &lt;button type='submit' class='btn btn-primary'&gt;Edit&lt;/button&gt;
            &lt;button type='delete' class= 'btn btn-primary' {{action 'delete'}}&gt;Delete&lt;/button&gt;
        &lt;/form&gt;
      {{/if}}
    &lt;/div&gt;
&lt;/div&gt;
{{/each}}</pre></div><p class="calibre14">This displays each individual post. If the user is authenticated, they can either delete or edit the post.</p><p class="calibre14">Once again, we use the <code class="email">textarea</code> template helpers to display the textboxes. The form has an edit action attached that will set the <code class="email">isEditing</code> property to <code class="email">true</code> so that the post can be edited. The <code class="email">delete</code> action deletes the post.</p></li><li class="listitem" value="14">Add the <a id="id550" class="calibre1"/><code class="email">save</code> action to the new controller:<div><pre class="programlisting">// app/controllers/new.js
import Ember from 'ember';
import cleanURI from '../utils/clean';

export default Ember.Controller.extend({
    actions: {
      save(){

        const titleURL= cleanURI(this.get('title'));
        const post = this.store.createRecord('post',{
        title: this.get('title'),
        body: this.get('body'),
        author: 'test',
        titleURL: titleURL
        });
        post.save();
        this.set('title','');
        this.set('body','');
        this.transitionToRoute('index');
      }
    }
});</pre></div><p class="calibre14">The <code class="email">save</code> action is used to save the data to Firebase. First, it takes the title of the post and <a id="id551" class="calibre1"/>uses the utility, <code class="email">cleanURI</code>, to remove all special characters and spaces. Firebase has a function called <code class="email">createRecord</code> that is used to create new records. We then save the record to the store and <code class="email">set</code> the values back to default. Finally, the application transitions back to the index.</p></li><li class="listitem" value="15">In the posts controller, add actions for <code class="email">edit</code>, <code class="email">delete</code>, and <code class="email">save</code>:<div><pre class="programlisting">// app/controllers/posts.js
import Ember from 'ember';
import cleanURI from '../utils/clean';

export default Ember.Controller.extend({
    actions: {
      edit(){
        this.set('isEditing', true);
      },
      delete(){
        this.get('model').forEach(model=&gt;{
          model.deleteRecord();
        });
        this.get('model').save();
        this.set('isEditing', false);
        this.transitionToRoute('index');
      },
      save(){
        this.get('model').forEach(model=&gt;{
          const titleURL = cleanURI(model.get('title'));
          model.set('titleURL', titleURL);
          model.save();
        });
        this.set('isEditing',false);
        this.transitionToRoute('index');
      }
    }
});</pre></div><p class="calibre14">Let's <a id="id552" class="calibre1"/>break this down into more detail:</p><div><pre class="programlisting">…
    edit(){
      this.set('isEditing',true);
    },
…</pre></div><p class="calibre14">The edit <a id="id553" class="calibre1"/>function sets the <code class="email">isEditing</code> property to <code class="email">true</code>. The posts template uses this property to show or not show the editing window:</p><div><pre class="programlisting">…
    delete(){
      this.get('model').forEach(model=&gt;{
        model.deleteRecord();
      });
      this.get('model').save();
      this.set('isEditing',false);
      this.transitionToRoute('index');
    },
…</pre></div><p class="calibre14">The <code class="email">delete</code> action deletes the record. To do this, we must use the <code class="email">forEach</code> method on our <code class="email">model</code>. In the route, we used the <code class="email">query</code> method, which returns an array. Therefore, we have to go through every record returned, and delete it. Once again, we'll assume that every title is unique and only has one record. Remember to always .<code class="email">save()</code> so that the record is persisted in <a id="id554" class="calibre1"/>Firebase. After the record is deleted, we transition to the index route:</p><div><pre class="programlisting">…
    save(){
      this.get('model').forEach(model=&gt;{
        const titleURL = cleanURI(model.get('title'));
        model.set('titleURL',titleURL);
        model.save();
      });
      this.set('isEditing',false);
      this.transitionToRoute('index');
    }
…</pre></div><p class="calibre14">The <code class="email">save</code> function gets the title, cleans it, sets it, and saves the model. In this example, we must use the <code class="email">forEach</code> method to iterate over the array. Afterward, we set the <code class="email">isEditing</code> property back to <code class="email">false</code> and transition back to the <code class="email">index</code>.</p></li><li class="listitem" value="16">Run the <a id="id555" class="calibre1"/>application and the following screen will be displayed:<div><img src="img/00079.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">This displays the top left corner of the screen. No posts are listed as we haven't added them yet:</p><div><img src="img/00080.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="17">The top <a id="id556" class="calibre1"/>right corner of the screen will show the <a id="id557" class="calibre1"/><strong class="calibre9">Login</strong> button. We'll need to log in by pressing this button. This will bring a popup asking for credentials to our Twitter account. After logging in, the <strong class="calibre9">Add New Post</strong> text will be displayed:<div><img src="img/00081.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="18">Clicking on <strong class="calibre9">Add New Post</strong> will display the following screen:<div><img src="img/00082.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="19">You can <a id="id558" class="calibre1"/>see that the preview takes the markdown and <a id="id559" class="calibre1"/>converts it to HTML. After adding the new post, it will then be listed:<div><img src="img/00083.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="20">Clicking <a id="id560" class="calibre1"/>on the title will bring us to an edit <a id="id561" class="calibre1"/>screen. Here, we can <strong class="calibre9">Edit</strong> or <strong class="calibre9">Delete</strong> the post:<div><img src="img/00084.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="21">Clicking on the <strong class="calibre9">Edit</strong> button will bring up the edit screen:<div><img src="img/00085.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">From here, we can make any changes and save it back again. Each time a save occurs, the post is persisted in Firebase.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec150" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Firebase talks to <a id="id562" class="calibre1"/>its backend service via the <code class="email">emberfire</code> and <code class="email">torii</code> add-ons. EmberFire is an official Ember Data adapter. It has many of the same <a id="id563" class="calibre1"/>features as other popular adapters. It can save, delete, edit, and query data fairly easily. One of its purposes is to make it really easy to persist and save data without having to set up your own backend.</p><p class="calibre8">Firebase also has authentication providers that it can hook into. Firebase handles all the authentication between the provider and application. All that this requires is that the provider is set up in Firebase.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec81" class="calibre1"/>Using server side rendering</h1></div></div></div><p class="calibre8">Ember.js runs in the <a id="id564" class="calibre1"/>browser. It uses JavaScript to handle all the routing and rendering of data. It only talks to the server on the initial page load and to retrieve JSON data. This can have some limitations. Larger applications might take longer to load on slower connections and there is still some concern around search engine optimization.</p><p class="calibre8">To help alleviate these concerns, the Ember team created <strong class="calibre9">FastBoot</strong>. FastBoot is an Ember CLI add-on that <a id="id565" class="calibre1"/>allows Ember.js to render and serve applications on the server. It's a work in progress as of writing this and has some limitations. It's not recommended for production and doesn't work with jQuery or <code class="email">didInsertElement</code>. It will hopefully be production-ready by Ember v2.4.</p><p class="calibre8">Nevertheless, it's <a id="id566" class="calibre1"/>improving and is an important add-on for Ember.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec151" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, run these commands:<div><pre class="programlisting">
<strong class="calibre9">$ ember install ember-cli-fastboot</strong>
<strong class="calibre9">$ rm –rf bower_components</strong>
<strong class="calibre9">$ bower install --save ember#canary</strong>
</pre></div><p class="calibre14">FastBoot requires the <code class="email">canary</code> version of Ember to work. We must delete the <code class="email">bower_components</code> folder before installing. During installation, you may get a message that Bower cannot find a suitable version of Ember. This is normal; make sure to choose <code class="email">ember#canary</code> from the list.</p></li><li class="listitem" value="2">Build the application for production:<div><pre class="programlisting">
<strong class="calibre9">$ ember build –prod</strong>
</pre></div><p class="calibre14">This will build the production server and minify all the files.</p></li><li class="listitem" value="3">Run the Ember FastBoot server:<div><pre class="programlisting">
<strong class="calibre9">$ ember fastboot --serve-assets --port 4200 --environment production</strong>
</pre></div><p class="calibre14">This will run the FastBoot server. Let's break down these arguments:</p><div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre9">--serve-assets</strong>: This serves the assets out of the <code class="email">dist</code> folder.</li><li class="listitem"><strong class="calibre9">--port 4200</strong>: This specifies the port. The default is 3000. In this case, we can use <code class="email">4200</code> to match the test server that we normally use.</li><li class="listitem"><strong class="calibre9">--environment production</strong>: The default is development. Use production. It works better as Ember FastBoot is faster with minified files.</li></ul></div></li><li class="listitem" value="4">Open up localhost at port <code class="email">4200</code> to see the web page load:<div><img src="img/00086.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">The page doesn't look any different. However, if you look at the browser console, you'll <a id="id567" class="calibre1"/>notice that the Ember application rendered without downloading all the JavaScript it normally needs to run in the browser.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec152" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember FastBoot is an Ember add-on that's being worked on. As of writing this, it has a lot of limitations. With this said, it will eventually allow you to render your Ember.js application on the server, or at least part of the application, for the initial page load. This will help reduce page <a id="id568" class="calibre1"/>load times significantly. To learn more about Ember FastBoot, check out their website at <a class="calibre1" href="https://github.com/tildeio/ember-cli-fastboot">https://github.com/tildeio/ember-cli-fastboot</a>.</p></div></div></body></html>