- en: Chapter 4. Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a chat application. The application that we are
    going to build will serve perfectly as an in-house communication tool for a company.
    Teams could create channels to discuss certain things related to their projects,
    even send auto-deleting messages with sensitive data, such as login credentials
    for servers and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start by setting up the base application using the same boilerplate
    code used in the previous chapter. Follow these simple steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the project from GitHub: [https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename your boilerplate project `mean-blueprints-chatapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want, you can stop pointing to the initial Git repository by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to your working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install all dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a development configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your configuration file, `config/environments/development.js`, should look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't need much information about a user, so we can reduce the `User` schema
    to only the strictly necessary information. Also, we can add a `profile` field,
    which can hold any extra info about the user, such as social media profile info
    or other accounts data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `User` schema from `app/models/user.js` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The message history data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message history will be a collection of user-submitted messages through
    the chat application. We can choose from a number of approaches when storing such
    data in MongoDB. The good thing is that there is no correct implementation, although
    we have a number of common approaches and considerations for each implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Our starting point will be that messages sent by users are part of a conversation
    thread. When two or more users chat with each other, initially a conversation
    thread is created for them. The messages become private for that conversation.
    This means that the messages have a parent-child relationship with another entity,
    a thread entity in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind our application''s requirements, we can explore the following
    implementations to store our messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store each message in a separate document**: This is the easiest to implement
    and it''s the most flexible one, but it comes with some application-level complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embed all messages in the thread document**: Because of MongoDB''s limit
    on document size, this is not an acceptable solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement a hybrid solution**: Messages are stored separately from the thread
    document but are held in a bucket-like manner, each bucket storing a limited number
    of documents. So, instead of storing all messages for a thread in one bucket,
    we are going to spread them out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our application, we can go with the one-document-per-message implementation.
    It will provide us with the greatest flexibility and ease of implementation. Also,
    we can easily retrieve messages in a chronological and threaded order.
  prefs: []
  type: TYPE_NORMAL
- en: The thread schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each message is going to be part of a conversation thread. Information such
    as who is participating in the conversation will be stored in a document in the
    threads collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start with a simple schema with only the necessary fields,
    in which we''ll store simple information about a thread. Create a new file called
    `/app/models/thread.js` with the following schema design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The most important part for us at the moment is the `participants` field, which
    describes who is participating in the current conversation. By design, our application
    will support multiple users participating in the same conversation thread. Imagine
    it to be a channel, where your team can discuss a specific project.
  prefs: []
  type: TYPE_NORMAL
- en: The message schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said earlier, we are going to use the one-document-per-message approach.
    For now, we are going to have a fairly simple schema for our messages. This can
    change based on the application's complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to define our schema in `app/models/message.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The schema is fairly simple. We have a sender that has a reference to a user
    and to a thread. In the thread entity, we are going to store additional data regarding
    the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Thread backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Node.js backend application, we are going make available endpoints, defined
    in our Express application routes, related to managing conversation threads. Also,
    there should be a way to get the message history from a specific thread.
  prefs: []
  type: TYPE_NORMAL
- en: Thread controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to add the necessary business logic to manage our threads in a
    new controller file, called `app/controllers/thread.js`, by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Export the module''s methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find all the threads for a specific user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find a thread by different criteria, for example, by the currently logged-in
    user and the ID of another user who participates in the conversation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a new conversation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, finding a thread by its ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the necessary business logic is implemented in the controller file.
    We just need to mount the methods from the controller to the routes so that they
    can be called externally. Create a new file called `app/routes/thread.js`. Add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have added the necessary module dependencies, we can implement each
    route one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get all the user''s threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a new thread. If a thread already exists for the participants, it will
    be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a thread by ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get all messages for a thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We jump a few steps and already used a method from the message controller; don't
    worry, we are going to implement it in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Message controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our API should return the message history for a specific conversation. We are
    going to keep things simple and just retrieve all the data from the `Message`
    collection from MongoDB. Create a new controller file, `app/controllers/message.js`,
    and add the following logic to find all message documents for a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because we have a lot of ground to cover, we are not going to treat pagination
    for the message history, neither on the backend nor on the frontend. But I've
    added a little bit of help in the preceding code. If the `beforeId` query string
    is sent, then messages can be easily paginated by the last known ID. Also remember
    that the `_id` field can be used to sort by, if it stores an `ObjectId` value,
    is almost equivalent as sorting by creation time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive a little bit deeper into this `_id` field. Most MongoDB clients will
    generate the `ObjectId` value to the `_id` field by themselves. If no `_id` field
    is sent with the document, `mongod` (the primary daemon process for MongoDB) will
    add the field.
  prefs: []
  type: TYPE_NORMAL
- en: One problem we could encounter is if the message documents are generated by
    multiple processes or systems within a single second. In such a case, the insertion
    order will not be strictly preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Backend chat service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only scratched the surface of our backend application. We are
    going to add a service layer to our server. This abstraction layer will implement
    all the business logic, such as instant messaging. The service layer will handle
    interaction with other application modules and layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `WebSockets` part of the application, we are going to use `socketIO`,
    which is a real-time communication engine. They have a really neat chat application
    example. If you haven''t heard of it, you can take a look at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://socket.io/get-started/chat/](http://socket.io/get-started/chat/)'
  prefs: []
  type: TYPE_NORMAL
- en: Chat service implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are familiar with `socketIO`, we can continue and implement our
    chat service. We are going to start by creating a new file called `app/services/chat/index.js`.
    This will be the main file for our chat service. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry about the `InstantMessagingModule`. We just added it as a reference
    so that we''ll not forget about it. We''ll come back later to reveal the mystery.
    Our class should have a constructor. Let''s add that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we initialize `socketIO`, get the session middleware, and
    finally bind all the handlers to our `socketIO` instance. More information about
    the session middleware can be found in our Express configuration file, `config/express.js`.
    Look for something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The nice thing is that we can share this session logic with `socketIO` and
    mount it with the `.use()` method. This will be done in the `.initMiddlewares()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we mount the session middleware to our instance, which will do something
    similar to mounting it on our Express app. Second, we check whether the user is
    present on the socket's session, in other words, whether the user is authenticated
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being able to add middleware is a pretty neat feature and enables us to do
    interesting things for each connected socket. We should also add the last method
    from the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For each successfully connected client, we are going to initialize the instant
    messaging module and store the connected clients in a map, for later reference.
  prefs: []
  type: TYPE_NORMAL
- en: Instant messaging module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be a little bit modular, we''ll split functionalities that represent connected
    clients into separate modules. For now there will be only one module, but in the
    future, you can easily add new ones. The `InstantMessagingModule` will be found
    in the same folder with the main chat file, more precisely, `app/services/chat/instant-messaging.module.js`.
    You can safely add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The service will use the `Message` and `Thread` models to validate and persist
    data. We are exporting an initialization function instead of the entire class.
    You could easily add extra initialization logic to the exported function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class constructor will be fairly simple, and it will look something similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We just assign the necessary dependencies to each property, and bind all the
    handlers to the connected socket. Let''s continue with the `.bindHandlers()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When sending a new message through WebSockets, it will be stored using the `.storeIM()`
    method and delivered to each participant by the `.deliverIM()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We slightly abstracted the logic to send instant messages, so let''s define
    our first method, which stores the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So basically, the `.storeIM()` method finds the conversation thread and creates
    a new message. We have also added a simple authorization when storing a message.
    The sender must be a participant in the given conversation. You could move that
    piece of logic into a more suitable module. I'll leave it to you as practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the next two methods that we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can deliver our message to the rest of the participants. The implementation
    can be found in the following class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have reached the end with our backend application. It should have all the
    necessary features implemented to start working on the client Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the Angular app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start building our client application using Angular 2\. We are
    going to integrate `SocketIO` with the client to communicate with our backend
    application. We are going to showcase only the most important parts of the application,
    but you can look at the final version anytime.
  prefs: []
  type: TYPE_NORMAL
- en: The boot file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are going to implement four services for this particular application, and
    we'll start with an app component. For the sake of simplicity, we are going to
    use a hash-based location strategy.
  prefs: []
  type: TYPE_NORMAL
- en: App component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main component of our application is the `app` component. We are going to
    keep it simple for now, only adding a router outlet to it, and configure the routes
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `public/src/app.component.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We created the main application component and configured a route that will have
    child routes. By default, the `ChatComponent` will be mounted. So, this was very
    basic. Before we continue with our application's components, let's take a break
    and define custom data types.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to group similar functionalities and have custom type checking, we
    are going to define classes for each entity used in our application. This will
    give us access to custom initialization and default values when creating entities.
  prefs: []
  type: TYPE_NORMAL
- en: User type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first custom data type used in the frontend Angular application will be
    a user. You can use an interface to define a custom type or a regular class. If
    you need default values or custom validation, go with a regular class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `public/src/datatypes/user.ts` and add the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When instantiating a new user, the `user` instance will have the `avatar` property
    prepopulated, with a specific link for the avatar picture. I've used a `gravatar`
    for this and added the user's ID as a hash to generate the image. Normally, you
    have to use the user's e-mail as an `md5` hash. Obviously, the avatar image can
    be provided by any service. You can even try adding file upload and profile management
    to this application.
  prefs: []
  type: TYPE_NORMAL
- en: Thread type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we are going to define a thread class, with some custom initialization
    logic. Create a new file, called `public/src/datatypes/thread.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the user data type was imported and used to signal that the
    participants for a given thread must be an array of users. Also, a class method
    was defined to generate a custom name for a specific thread-based on the participating
    users in the conversation thread.
  prefs: []
  type: TYPE_NORMAL
- en: Message type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At last, we are going to define what structure a message will have in our application.
    For that, we are going to create a new file called `public/src/datatypes/message.ts`
    with the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You may already be thinking, "Why not include the `User` data type and mark
    the sender as a user?" To be honest, this is not a must have. You can have *any*
    type you like and the code would be still valid. It's up to you how much granularity
    you want to add to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to our code, we have added two extra methods to the `Message` class
    in order to generate two timestamps, one that displays the time when the message
    was created and one that displays a full timestamp with date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the initial chapters, we grouped our files by their domain context. We did
    things a bit differently this time to highlight the fact that you can also start
    with a more flat approach. And, if necessary, you can start grouping your files
    based on their domain context instead of their type.
  prefs: []
  type: TYPE_NORMAL
- en: Still, we are going to group our components based on their context in order
    to locate them faster. Also imagine that you can load the whole application into
    a different application, and having a flatter folder structure will reduce the
    unnecessary navigation hassle.
  prefs: []
  type: TYPE_NORMAL
- en: User service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start with a simple service that will handle all of the user
    application logic. Create a new file called `public/src/services/user.service.ts`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We exposed a `users` property, which is an observable, and transformed it to
    a `hot` observable. We defined an internal data storage for the service, which
    is a simple object. Almost forgot to mention! Remember to import your dependencies.
    As a closing line for our constructor, we retrieve all users from the backend.
    We are doing this in the service so that we don't have to call it explicitly from
    a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the `.getAll()` method is not implemented, so let''s append the following
    method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also moved the data persistence to another method, just in case we
    want to use it somewhere else. Add the following method to the `UserService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For now, our application has all the necessary functionalities from `UserService`,
    and we can move on to implementing other application components.
  prefs: []
  type: TYPE_NORMAL
- en: The thread service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thread service will handle and share across our application data related
    to threads. We are going to store the retrieved threads from the backend. Also,
    the currently active thread will be stored in this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the service file, called `public/src/services/thread.service.ts`.
    After that, follow a few steps to implement the core logic of the service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a few custom data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the necessary method to get all threads from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will retrieve all the threads from the backend service. It will
    store them inside the service's data store and push the latest values to the thread
    observers so that all subscribers can get the latest values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define how to open a new thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `open()` method will return an observable instead of handling data inside
    the service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to be able to set the current thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`currentThread` is a `BehaviorSubject` that will hold only the last value and
    share it with any new subscriber. This comes in handy when storing the current
    thread. Remember that you need to initialize the subject with an initial value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Expose a method to store threads from an external data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We don't want to store the same thread twice. One thing we can improve is updating
    the thread if it has changed, but we don't need this in our application at this
    point. It is something you should remember when you are improving this application.
  prefs: []
  type: TYPE_NORMAL
- en: With the last implemented logic, we should have the minimal functionality required
    for the conversation threads.
  prefs: []
  type: TYPE_NORMAL
- en: The message service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message service is going to be a little bit different, because we are going
    to use socket.io to send and receive data through `WebSockets` from the socket
    server, which was set up earlier in this chapter. No worries! The difference will
    not be reflected in the rest of the application. A service should always abstract
    the underlining logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by creating the service file, called `public/src/services/message.service.ts`,
    and import the necessary dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we imported everything from the `socket.io-client` library
    as `io`. Next, we are going to append the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we are going to initialize and connect to the socket server.
    Because we are using the default configuration both on the server side and the
    client side, we can just call the `.connect()` method. The `_socketOn()` private
    method will define all event bindings for the socket; let''s append this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We just defined two events to listen for and call the `_storeMessage()` method.
    For each event, a new message will arrive through the socket. Following this,
    we should add the method to our `MessageSerivce` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When storing a new message, we are going to create a new `User` instance in
    order to have all the necessary data regarding the message sender. This method
    will only be used internally within the service, but we need to expose a method
    to send messages, and it will be accessed by other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending a message was not so hard. We had to emit the `send:im` event and attach
    the message itself. Besides sending and receiving messages, we also need to get
    the message history for a given thread and store the messages in the service''s
    data store. Let''s do that right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method should retrieve for us the necessary data from the Express
    application. We are doing the same thing for each message as before when we stored
    an incoming message. More precisely, we are instantiating a new user with the
    sender's information. This should be all for the message service.
  prefs: []
  type: TYPE_NORMAL
- en: The chat component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the necessary data types and services, we can get back
    to our application''s components. Looking back at the `app` component, a good
    thing would be to start with the `chat` component. Create a new file called `public/src/chat/chat.component.ts`
    and add the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have imported all our required modules, we can actually implement
    our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the component's template are included components that we'll implement later
    on, for example, the thread list component, which will display all the current
    conversations with other users. The chat component will be the container for our
    smaller components, but we are also adding a `RouterOutlet` to dynamically load
    components matched to the current route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default route will load a helper component in case no thread ID is added
    as a parameter in the route. We can associate this with a home page for our component.
    You can make the default view as complex as you want; for example, you can add
    a link for the last opened thread. We are going to keep it simple for now. Create
    a new file called `public/src/chat-help.component.ts` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Noting fancy here! Just a simple component with an inline template that has
    a nice message displayed for the user. Now that we have covered this, we can move
    on and implement the rest of our components.
  prefs: []
  type: TYPE_NORMAL
- en: The user list component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user list component will give us the ability to search for users and start
    a new conversation with them. We will need to display a list of users and filter
    them by a search criterion. Also, by clicking on a user from the list, a new conversation
    thread should open. All this should be fairly simple to implement. Let''s start
    by creating the component file. Create a new file called `public/src/user/user.component.ts`,
    with the following base structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported the necessary dependencies and defined the base for our component.
    The component will have two major parts, a list of users and an input field, which
    will be used to search for a given user from the list. Let''s define the template
    for our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to show a list of users, we are going to subscribe to the `users`
    observable from the user service. Append the following code to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To display a list of filtered users, we are going to use the following logic.
    Append this code to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To feed data from the input, we can use something like this method, which will
    execute only when the user starts typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to open a new thread, we bound a click event for each user displayed
    in the list. Let''s add the required method for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will just call the `.open()` method from the thread service,
    and upon success, it will navigate to the returned thread. We are also calling
    the `cleanUp()` method from this component, which will reset our component to
    the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add all the missing logic from our component. Just append the
    methods to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As a quick recap, we created a user list component that displays all users in
    a list when focusing on the search input; by default, the list is hidden. We added
    some special events; for example, by pressing the *Esc* key, the list should be
    hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A user must know in which conversation he/she is participating, so we need to
    display this information to the user. To do so, we are going to implement a thread
    listing component.
  prefs: []
  type: TYPE_NORMAL
- en: Thread component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to display a list of threads, we are going to use a component for
    each thread to encapsulate all the information displayed to the user and functionalities.
    To create the desired component, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the component file, called `public/src/thread/thread.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the component annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the component''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a single thread component to be used to display information in a
    list. We are using `routerLink` to navigate to the desired conversation thread.
    On initialization, we check which is the current thread so that we can mark the
    selected thread.
  prefs: []
  type: TYPE_NORMAL
- en: Thread list component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our thread component, we can display them in a list. For this,
    a new component will be used. Let''s do something similar to what was done before:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the component file, called `public/src/thread/thread-list.component.ts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the necessary dependencies, together with the `thread` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the component annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `ThreadListComponent` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should display a nice list of opened conversation threads for the user.
    We are using the `thread` service to get the necessary data for the component.
    If the `threads` collection from the service changes, the update strategy will
    handle the necessary updates for us.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can initiate and resume a conversation, we need to be able to send
    messages in that conversation to the participants. We are going to focus on achieving
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The flow for sending messages is pretty simple. First, we send the desired message
    to the backend application, storing the message for history purposes, and we notify
    the recipient of a new message. Both the sender and the recipient have the message
    displayed on their devices.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, in the `chat` component, we used a `message form` component. This component
    will permit us to input messages and send them to the Node.js backend service.
    Let's keep it simple and add only the necessary functionalities. Create a new
    component file called `public/src/message/message-form.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to import two services in our component. We append the following
    code for our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to add the component annotation and define the component''s
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To define the rest of the necessary logic, we are going to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following properties to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the constructor to something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the component''s initialization to reset the `draft message` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the send message logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will simply call the `.sendMessage()` method from the `thread` service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define what happens when the user hits the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Technically, we can now send messages to the backend and persist them in MongoDB
    to construct the message history.
  prefs: []
  type: TYPE_NORMAL
- en: The message component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To display all the messages, we are going to start small and create the message
    component. This component will be a single entry from the list of messages. We
    should already have the necessary data and logic to display a single message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `message` component, create a new file called `public/src/message/message.component.ts`
    and append the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The component is fairly simple. It just displays data about a single message,
    and after the view has initialized, it will scroll the message list to the bottom.
    With the last functionality, if there are more messages than can actually fit
    in the view, it will simply scroll to the latest message.
  prefs: []
  type: TYPE_NORMAL
- en: The message list component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we implemented a single message component, this was necessary for our
    message list component, which will display all messages to the user. We are going
    to use a similar pattern to implement this component as for the thread list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the message list component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the Angular component annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the component''s class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we are reloading the component each time we navigate to the matched
    route, we can get the current `identifier` parameter and load messages by the
    current thread ID. We are also setting the current thread ID so that other subscribers
    can take actions accordingly. For example, in the `thread` component, we check
    whether the current thread matches the component's thread.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of this chapter. The chapter was about building a real-time
    chat application. We used `WebSockets` for the real-time communication, stored
    the message history in MongoDB, and created threaded conversations. We also left
    some room for improvements, or to add new functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll try to build an e-commerce application.
  prefs: []
  type: TYPE_NORMAL
