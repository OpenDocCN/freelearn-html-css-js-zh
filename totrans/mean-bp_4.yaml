- en: Chapter 4. Chat Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。聊天应用程序
- en: In this chapter, we will build a chat application. The application that we are
    going to build will serve perfectly as an in-house communication tool for a company.
    Teams could create channels to discuss certain things related to their projects,
    even send auto-deleting messages with sensitive data, such as login credentials
    for servers and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个聊天应用程序。我们将构建的应用程序将完美地作为公司内部沟通工具。团队可以创建频道来讨论与项目相关的某些事项，甚至可以发送自动删除的敏感数据消息，例如服务器的登录凭证等。
- en: Setting up the base application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本应用程序
- en: 'We are going to start by setting up the base application using the same boilerplate
    code used in the previous chapter. Follow these simple steps to achieve this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用与上一章中相同的样板代码设置基本应用程序。按照以下简单步骤来实现这一点：
- en: 'Clone the project from GitHub: [https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter).'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 克隆项目：[https://github.com/robert52/express-api-starter](https://github.com/robert52/express-api-starter)。
- en: Rename your boilerplate project `mean-blueprints-chatapp`.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的样板项目重命名为`mean-blueprints-chatapp`。
- en: 'If you want, you can stop pointing to the initial Git repository by running
    the following command:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想，你可以通过运行以下命令来停止指向初始 Git 仓库：
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Jump to your working directory:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到你的工作目录：
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install all dependencies:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所有依赖项：
- en: '[PRE2]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a development configuration file:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建开发配置文件：
- en: '[PRE3]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your configuration file, `config/environments/development.js`, should look
    similar to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的配置文件`config/environments/development.js`应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Modifying the user model
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改用户模型
- en: We don't need much information about a user, so we can reduce the `User` schema
    to only the strictly necessary information. Also, we can add a `profile` field,
    which can hold any extra info about the user, such as social media profile info
    or other accounts data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要太多关于用户的信息，因此我们可以将`User`模式缩减到仅严格必要的信息。此外，我们可以添加一个`profile`字段，它可以存储关于用户的任何额外信息，例如社交媒体配置文件信息或其他账户数据。
- en: 'Let''s modify the `User` schema from `app/models/user.js` with the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`User`模式从`app/models/user.js`如下：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The message history data model
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息历史数据模型
- en: The message history will be a collection of user-submitted messages through
    the chat application. We can choose from a number of approaches when storing such
    data in MongoDB. The good thing is that there is no correct implementation, although
    we have a number of common approaches and considerations for each implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 消息历史将是一个用户通过聊天应用程序提交的消息集合。在 MongoDB 中存储此类数据时，我们可以选择多种方法。好事是，没有正确的实现，尽管我们有许多常见的实现方法和考虑因素。
- en: Our starting point will be that messages sent by users are part of a conversation
    thread. When two or more users chat with each other, initially a conversation
    thread is created for them. The messages become private for that conversation.
    This means that the messages have a parent-child relationship with another entity,
    a thread entity in our case.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点将是用户发送的消息是会话线程的一部分。当两个或更多用户互相聊天时，最初为他们创建一个会话线程。消息对那个会话是私有的。这意味着消息与另一个实体具有父子关系，在我们的例子中是线程实体。
- en: 'Keeping in mind our application''s requirements, we can explore the following
    implementations to store our messages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们应用程序的需求，我们可以探索以下实现来存储我们的消息：
- en: '**Store each message in a separate document**: This is the easiest to implement
    and it''s the most flexible one, but it comes with some application-level complexity.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将每条消息存储在单独的文档中**：这是最容易实现的，也是最灵活的，但它伴随着一些应用程序级别的复杂性。'
- en: '**Embed all messages in the thread document**: Because of MongoDB''s limit
    on document size, this is not an acceptable solution.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有消息嵌入到线程文档中**：由于 MongoDB 对文档大小的限制，这不是一个可接受的解决方案。'
- en: '**Implement a hybrid solution**: Messages are stored separately from the thread
    document but are held in a bucket-like manner, each bucket storing a limited number
    of documents. So, instead of storing all messages for a thread in one bucket,
    we are going to spread them out.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现混合解决方案**：消息存储在与线程文档分开的地方，但以类似桶的方式保存，每个桶存储有限数量的文档。因此，我们不会在一个桶中存储线程的所有消息，而是将它们分散开来。'
- en: For our application, we can go with the one-document-per-message implementation.
    It will provide us with the greatest flexibility and ease of implementation. Also,
    we can easily retrieve messages in a chronological and threaded order.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们可以采用每条消息一个文档的实现。这将为我们提供最大的灵活性和易于实现性。此外，我们可以轻松地以时间顺序和线程顺序检索消息。
- en: The thread schema
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程模式
- en: Each message is going to be part of a conversation thread. Information such
    as who is participating in the conversation will be stored in a document in the
    threads collection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都将成为对话线程的一部分。有关谁参与对话等信息将存储在线程集合的文档中。
- en: 'We are going to start with a simple schema with only the necessary fields,
    in which we''ll store simple information about a thread. Create a new file called
    `/app/models/thread.js` with the following schema design:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从只包含必要字段的简单模式开始，其中我们将存储有关线程的简单信息。创建一个名为 `/app/models/thread.js` 的新文件，并使用以下模式设计：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most important part for us at the moment is the `participants` field, which
    describes who is participating in the current conversation. By design, our application
    will support multiple users participating in the same conversation thread. Imagine
    it to be a channel, where your team can discuss a specific project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对我们来说最重要的部分是 `participants` 字段，它描述了谁参与了当前的对话。按照设计，我们的应用程序将支持多个用户参与同一个对话线程。想象一下，它就像一个频道，你的团队可以讨论一个特定的项目。
- en: The message schema
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息模式
- en: As we said earlier, we are going to use the one-document-per-message approach.
    For now, we are going to have a fairly simple schema for our messages. This can
    change based on the application's complexity.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，我们将使用每条消息一个文档的方法。目前，我们将为我们的消息使用相当简单的模式。这可以根据应用程序的复杂性而改变。
- en: 'We are going to define our schema in `app/models/message.js`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `app/models/message.js` 中定义我们的模式：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The schema is fairly simple. We have a sender that has a reference to a user
    and to a thread. In the thread entity, we are going to store additional data regarding
    the conversation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模式相当简单。我们有一个发送者，它引用了一个用户和一个线程。在线程实体中，我们将存储有关对话的附加数据。
- en: Thread backend
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程后端
- en: In the Node.js backend application, we are going make available endpoints, defined
    in our Express application routes, related to managing conversation threads. Also,
    there should be a way to get the message history from a specific thread.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js后端应用程序中，我们将通过Express应用程序的路由定义提供与管理工作线程相关的端点。还应该有一种方法可以从特定的线程中获取消息历史。
- en: Thread controller
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程控制器
- en: 'We are going to add the necessary business logic to manage our threads in a
    new controller file, called `app/controllers/thread.js`, by following these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤在新的控制器文件 `app/controllers/thread.js` 中添加管理线程所需的所有业务逻辑：
- en: 'Add the required modules:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的模块：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Export the module''s methods:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出模块的方法：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Find all the threads for a specific user:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找特定用户的全部线程：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Find a thread by different criteria, for example, by the currently logged-in
    user and the ID of another user who participates in the conversation:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过不同的标准查找线程，例如，通过当前登录的用户和参与对话的另一个用户的ID：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open a new conversation:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的对话：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, finding a thread by its ID:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过其ID查找线程：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Defining routes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义路由
- en: 'All of the necessary business logic is implemented in the controller file.
    We just need to mount the methods from the controller to the routes so that they
    can be called externally. Create a new file called `app/routes/thread.js`. Add
    the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的业务逻辑都在控制器文件中实现。我们只需要将控制器中的方法挂载到路由上，以便它们可以从外部调用。创建一个名为 `app/routes/thread.js`
    的新文件。添加以下代码：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After we have added the necessary module dependencies, we can implement each
    route one by one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加了必要的模块依赖项之后，我们可以逐个实现每个路由：
- en: 'Get all the user''s threads:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有用户的线程：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open a new thread. If a thread already exists for the participants, it will
    be returned:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的线程。如果参与者已经有一个线程，它将被返回：
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Get a thread by ID:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过ID获取线程：
- en: '[PRE17]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Get all messages for a thread:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取线程的所有消息：
- en: '[PRE18]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We jump a few steps and already used a method from the message controller; don't
    worry, we are going to implement it in the next step.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了几个步骤，并已经使用了消息控制器的一个方法；不要担心，我们将在下一步实现它。
- en: Message controller
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息控制器
- en: 'Our API should return the message history for a specific conversation. We are
    going to keep things simple and just retrieve all the data from the `Message`
    collection from MongoDB. Create a new controller file, `app/controllers/message.js`,
    and add the following logic to find all message documents for a thread:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 API 应该返回特定对话的消息历史。我们将保持简单，直接从 MongoDB 的 `Message` 集合中检索所有数据。创建一个新的控制器文件，`app/controllers/message.js`，并添加以下逻辑以查找线程的所有消息文档：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because we have a lot of ground to cover, we are not going to treat pagination
    for the message history, neither on the backend nor on the frontend. But I've
    added a little bit of help in the preceding code. If the `beforeId` query string
    is sent, then messages can be easily paginated by the last known ID. Also remember
    that the `_id` field can be used to sort by, if it stores an `ObjectId` value,
    is almost equivalent as sorting by creation time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有很多内容要覆盖，我们既不会在后端也不会在前端处理消息历史的分页。但在前面的代码中，我已经添加了一些帮助。如果发送了 `beforeId` 查询字符串，则可以通过最后已知的
    ID 容易地进行分页。还请记住，如果 `_id` 字段存储了 `ObjectId` 值，则按其排序几乎等同于按创建时间排序。
- en: Let's dive a little bit deeper into this `_id` field. Most MongoDB clients will
    generate the `ObjectId` value to the `_id` field by themselves. If no `_id` field
    is sent with the document, `mongod` (the primary daemon process for MongoDB) will
    add the field.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨一下这个 `_id` 字段。大多数 MongoDB 客户端会自动生成 `ObjectId` 值并将其赋给 `_id` 字段。如果文档中没有发送
    `_id` 字段，`mongod`（MongoDB 的主要守护进程）将添加该字段。
- en: One problem we could encounter is if the message documents are generated by
    multiple processes or systems within a single second. In such a case, the insertion
    order will not be strictly preserved.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到的一个问题是，如果消息文档是由单个秒内的多个进程或系统生成的。在这种情况下，插入顺序将不会严格保留。
- en: Backend chat service
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端聊天服务
- en: So far, we've only scratched the surface of our backend application. We are
    going to add a service layer to our server. This abstraction layer will implement
    all the business logic, such as instant messaging. The service layer will handle
    interaction with other application modules and layers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是触及了我们后端应用程序的表面。我们将在服务器上添加一个服务层。这个抽象层将实现所有业务逻辑，例如即时消息。服务层将处理与其他应用程序模块和层的交互。
- en: 'As for the `WebSockets` part of the application, we are going to use `socketIO`,
    which is a real-time communication engine. They have a really neat chat application
    example. If you haven''t heard of it, you can take a look at the following link:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 至于应用程序的 `WebSockets` 部分，我们将使用 `socketIO`，这是一个实时通信引擎。他们有一个非常棒的聊天应用程序示例。如果你还没有听说过它，可以查看以下链接：
- en: '[http://socket.io/get-started/chat/](http://socket.io/get-started/chat/)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://socket.io/get-started/chat/](http://socket.io/get-started/chat/)'
- en: Chat service implementation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天服务实现
- en: 'Now that we are familiar with `socketIO`, we can continue and implement our
    chat service. We are going to start by creating a new file called `app/services/chat/index.js`.
    This will be the main file for our chat service. Add the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 `socketIO`，我们可以继续并实现我们的聊天服务。我们将首先创建一个名为 `app/services/chat/index.js`
    的新文件。这将是我们的聊天服务的主要文件。添加以下代码：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Don''t worry about the `InstantMessagingModule`. We just added it as a reference
    so that we''ll not forget about it. We''ll come back later to reveal the mystery.
    Our class should have a constructor. Let''s add that now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心 `InstantMessagingModule`。我们只是将其添加为参考，以免忘记。我们稍后会回来揭示这个谜团。我们的类应该有一个构造函数。现在让我们添加它：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the constructor, we initialize `socketIO`, get the session middleware, and
    finally bind all the handlers to our `socketIO` instance. More information about
    the session middleware can be found in our Express configuration file, `config/express.js`.
    Look for something similar:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化 `socketIO`，获取会话中间件，并最终将所有处理程序绑定到我们的 `socketIO` 实例。有关会话中间件的更多信息，可以在我们的
    Express 配置文件 `config/express.js` 中找到。寻找类似的内容：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The nice thing is that we can share this session logic with `socketIO` and
    mount it with the `.use()` method. This will be done in the `.initMiddlewares()`
    method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于我们可以将这个会话逻辑与 `socketIO` 共享，并通过 `.use()` 方法挂载。这将在 `.initMiddlewares()` 方法中完成：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we mount the session middleware to our instance, which will do something
    similar to mounting it on our Express app. Second, we check whether the user is
    present on the socket's session, in other words, whether the user is authenticated
    or not.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将会话中间件挂载到我们的实例上，这将会在类似挂载到我们的Express应用程序上的操作。其次，我们检查用户是否存在于套接字会话中，换句话说，即用户是否已经认证。
- en: 'Being able to add middleware is a pretty neat feature and enables us to do
    interesting things for each connected socket. We should also add the last method
    from the constructor:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 能够添加中间件是一个非常酷的特性，并使我们能够为每个已连接的套接字执行有趣的事情。我们还应该添加构造函数中的最后一个方法：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For each successfully connected client, we are going to initialize the instant
    messaging module and store the connected clients in a map, for later reference.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个成功连接的客户端，我们将初始化即时通讯模块并将已连接的客户端存储在映射中，以供以后参考。
- en: Instant messaging module
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时通讯模块
- en: 'To be a little bit modular, we''ll split functionalities that represent connected
    clients into separate modules. For now there will be only one module, but in the
    future, you can easily add new ones. The `InstantMessagingModule` will be found
    in the same folder with the main chat file, more precisely, `app/services/chat/instant-messaging.module.js`.
    You can safely add the following code to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微模块化一些，我们将把表示已连接客户端的功能性拆分到单独的模块中。目前只有一个模块，但将来你可以轻松地添加新的模块。`InstantMessagingModule`将位于主聊天文件的同一文件夹中，更确切地说，是`app/services/chat/instant-messaging.module.js`。你可以安全地向其中添加以下代码：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The service will use the `Message` and `Thread` models to validate and persist
    data. We are exporting an initialization function instead of the entire class.
    You could easily add extra initialization logic to the exported function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务将使用`Message`和`Thread`模型来验证和持久化数据。我们导出一个初始化函数而不是整个类。你可以轻松地向导出的函数添加额外的初始化逻辑。
- en: 'The class constructor will be fairly simple, and it will look something similar
    to this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数将会相当简单，看起来会类似于以下这样：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We just assign the necessary dependencies to each property, and bind all the
    handlers to the connected socket. Let''s continue with the `.bindHandlers()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将必要的依赖项分配给每个属性，并将所有处理程序绑定到已连接的套接字。让我们继续使用`.bindHandlers()`方法：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When sending a new message through WebSockets, it will be stored using the `.storeIM()`
    method and delivered to each participant by the `.deliverIM()` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过WebSockets发送新消息时，它将通过`.storeIM()`方法存储，并通过`.deliverIM()`方法分发给每个参与者。
- en: 'We slightly abstracted the logic to send instant messages, so let''s define
    our first method, which stores the messages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微抽象了发送即时消息的逻辑，所以让我们定义我们的第一个方法，它用于存储消息：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So basically, the `.storeIM()` method finds the conversation thread and creates
    a new message. We have also added a simple authorization when storing a message.
    The sender must be a participant in the given conversation. You could move that
    piece of logic into a more suitable module. I'll leave it to you as practice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，`.storeIM()`方法找到对话线程并创建一条新消息。我们还添加了存储消息时的简单授权。发送者必须是给定对话的参与者。你可以将这部分逻辑移动到更合适的模块中。我将把它留给你作为练习。
- en: 'Let''s add the next two methods that we used before:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加之前使用过的下两个方法：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we can deliver our message to the rest of the participants. The implementation
    can be found in the following class method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的消息传递给其他参与者。实现可以在以下类方法中找到：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have reached the end with our backend application. It should have all the
    necessary features implemented to start working on the client Angular application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了后端应用程序的开发。它应该实现了所有必要的功能，以便开始开发客户端Angular应用程序。
- en: Bootstrapping the Angular app
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导Angular应用程序
- en: It's time to start building our client application using Angular 2\. We are
    going to integrate `SocketIO` with the client to communicate with our backend
    application. We are going to showcase only the most important parts of the application,
    but you can look at the final version anytime.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始使用Angular 2构建我们的客户端应用程序了。我们将集成`SocketIO`与客户端以与我们的后端应用程序通信。我们将展示应用程序最重要的部分，但你可以在任何时候查看最终版本。
- en: The boot file
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导文件
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are going to implement four services for this particular application, and
    we'll start with an app component. For the sake of simplicity, we are going to
    use a hash-based location strategy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个特定的应用程序实现四个服务，并且我们将从一个应用程序组件开始。为了简化，我们将使用基于哈希的位置策略。
- en: App component
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: The main component of our application is the `app` component. We are going to
    keep it simple for now, only adding a router outlet to it, and configure the routes
    of our application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要组件是`app`组件。目前我们将保持其简单性，只向其中添加一个路由出口，并配置我们应用程序的路由。
- en: 'Create a new file called `public/src/app.component.ts` with the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`public/src/app.component.ts`的新文件，包含以下代码：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We created the main application component and configured a route that will have
    child routes. By default, the `ChatComponent` will be mounted. So, this was very
    basic. Before we continue with our application's components, let's take a break
    and define custom data types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了主应用程序组件并配置了一个将具有子路由的路由。默认情况下，`ChatComponent`将被挂载。所以，这非常基础。在我们继续应用程序的组件之前，让我们休息一下并定义自定义数据类型。
- en: Custom data types
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义数据类型
- en: In order to group similar functionalities and have custom type checking, we
    are going to define classes for each entity used in our application. This will
    give us access to custom initialization and default values when creating entities.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类似的功能分组并具有自定义类型检查，我们将为应用程序中使用的每个实体定义类。这将使我们能够在创建实体时访问自定义初始化和默认值。
- en: User type
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户类型
- en: Our first custom data type used in the frontend Angular application will be
    a user. You can use an interface to define a custom type or a regular class. If
    you need default values or custom validation, go with a regular class definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前端Angular应用程序中使用的第一个自定义数据类型将是用户。您可以使用接口来定义自定义类型或一个常规类。如果您需要默认值或自定义验证，请使用常规类定义。
- en: 'Create a new file called `public/src/datatypes/user.ts` and add the following
    class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`public/src/datatypes/user.ts`的新文件，并添加以下类：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When instantiating a new user, the `user` instance will have the `avatar` property
    prepopulated, with a specific link for the avatar picture. I've used a `gravatar`
    for this and added the user's ID as a hash to generate the image. Normally, you
    have to use the user's e-mail as an `md5` hash. Obviously, the avatar image can
    be provided by any service. You can even try adding file upload and profile management
    to this application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化新用户时，`user`实例将预先填充`avatar`属性，包含一个特定的头像图片链接。我使用了`gravatar`并添加了用户的ID作为哈希来生成图像。通常，您必须使用用户的电子邮件作为`md5`哈希。显然，头像图像可以由任何服务提供。您甚至可以尝试向此应用程序添加文件上传和资料管理。
- en: Thread type
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程类型
- en: 'Next, we are going to define a thread class, with some custom initialization
    logic. Create a new file, called `public/src/datatypes/thread.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个线程类，包含一些自定义初始化逻辑。创建一个名为`public/src/datatypes/thread.ts`的新文件：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the user data type was imported and used to signal that the
    participants for a given thread must be an array of users. Also, a class method
    was defined to generate a custom name for a specific thread-based on the participating
    users in the conversation thread.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户数据类型已被导入并用于表示给定线程的参与者必须是一个用户数组。还定义了一个类方法，用于根据对话线程中的参与用户生成特定线程的名称。
- en: Message type
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息类型
- en: 'At last, we are going to define what structure a message will have in our application.
    For that, we are going to create a new file called `public/src/datatypes/message.ts`
    with the following logic:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将定义在我们的应用程序中消息的结构。为此，我们将创建一个名为`public/src/datatypes/message.ts`的新文件，包含以下逻辑：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You may already be thinking, "Why not include the `User` data type and mark
    the sender as a user?" To be honest, this is not a must have. You can have *any*
    type you like and the code would be still valid. It's up to you how much granularity
    you want to add to your code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在想，“为什么不包括`User`数据类型并将发送者标记为用户？”坦白说，这并不是必须的。您可以包含您喜欢的任何类型，代码仍然有效。这取决于您想向代码中添加多少粒度。
- en: Getting back to our code, we have added two extra methods to the `Message` class
    in order to generate two timestamps, one that displays the time when the message
    was created and one that displays a full timestamp with date and time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码，我们向`Message`类中添加了两个额外的方法，以生成两个时间戳，一个显示消息创建的时间，另一个显示包含日期和时间的完整时间戳。
- en: Application services
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序服务
- en: In the initial chapters, we grouped our files by their domain context. We did
    things a bit differently this time to highlight the fact that you can also start
    with a more flat approach. And, if necessary, you can start grouping your files
    based on their domain context instead of their type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始章节中，我们根据它们的领域上下文对文件进行了分组。这次我们做了一些不同的处理，以强调你也可以从更扁平的方法开始。如果需要，你可以根据它们的领域上下文而不是类型来对文件进行分组。
- en: Still, we are going to group our components based on their context in order
    to locate them faster. Also imagine that you can load the whole application into
    a different application, and having a flatter folder structure will reduce the
    unnecessary navigation hassle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还是将我们的组件根据它们的上下文分组，以便更快地定位它们。想象一下，你可以将整个应用程序加载到不同的应用程序中，并且拥有更扁平的文件夹结构将减少不必要的导航麻烦。
- en: User service
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户服务
- en: 'We are going to start with a simple service that will handle all of the user
    application logic. Create a new file called `public/src/services/user.service.ts`
    with the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的服务开始，该服务将处理所有用户应用程序逻辑。创建一个名为 `public/src/services/user.service.ts`
    的新文件，并包含以下代码：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We exposed a `users` property, which is an observable, and transformed it to
    a `hot` observable. We defined an internal data storage for the service, which
    is a simple object. Almost forgot to mention! Remember to import your dependencies.
    As a closing line for our constructor, we retrieve all users from the backend.
    We are doing this in the service so that we don't have to call it explicitly from
    a component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们公开了一个 `users` 属性，它是一个可观察对象，并将其转换为 `hot` 可观察对象。我们为服务定义了一个内部数据存储，它是一个简单的对象。差点忘了提！记得导入你的依赖项。作为构造函数的结尾，我们从后端检索所有用户。我们在服务中这样做，这样我们就不需要从组件中显式调用它。
- en: 'Actually, the `.getAll()` method is not implemented, so let''s append the following
    method to the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`.getAll()` 方法尚未实现，所以让我们给这个类添加以下方法：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have also moved the data persistence to another method, just in case we
    want to use it somewhere else. Add the following method to the `UserService` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将数据持久性移动到另一个方法，以防我们想在别处使用它。将以下方法添加到 `UserService` 类中：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For now, our application has all the necessary functionalities from `UserService`,
    and we can move on to implementing other application components.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序已经拥有了来自 `UserService` 的所有必要功能，我们可以继续实现其他应用程序组件。
- en: The thread service
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程服务
- en: The thread service will handle and share across our application data related
    to threads. We are going to store the retrieved threads from the backend. Also,
    the currently active thread will be stored in this service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 线程服务将处理并共享与线程相关的数据。我们将存储从后端检索到的线程。此外，当前活动线程也将存储在这个服务中。
- en: 'Let''s start by creating the service file, called `public/src/services/thread.service.ts`.
    After that, follow a few steps to implement the core logic of the service:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建服务文件，命名为 `public/src/services/thread.service.ts`。之后，遵循以下步骤来实现服务的核心逻辑：
- en: 'Load the necessary dependencies:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载必要的依赖项：
- en: '[PRE40]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Define a few custom data types:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义几个自定义数据类型：
- en: '[PRE41]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the base class:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基类：
- en: '[PRE42]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the constructor:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加构造函数：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Append the necessary method to get all threads from the server:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的获取所有线程的方法：
- en: '[PRE44]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method will retrieve all the threads from the backend service. It will
    store them inside the service's data store and push the latest values to the thread
    observers so that all subscribers can get the latest values.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将从后端服务检索所有线程。它将它们存储在服务的数据存储中，并将最新值推送到线程观察者，以便所有订阅者都可以获取最新值。
- en: 'Define how to open a new thread:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义如何打开一个新线程：
- en: '[PRE45]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `open()` method will return an observable instead of handling data inside
    the service.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`open()` 方法将返回一个可观察对象，而不是在服务内部处理数据。'
- en: 'We also need to be able to set the current thread:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要能够设置当前线程：
- en: '[PRE46]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`currentThread` is a `BehaviorSubject` that will hold only the last value and
    share it with any new subscriber. This comes in handy when storing the current
    thread. Remember that you need to initialize the subject with an initial value.'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`currentThread` 是一个 `BehaviorSubject`，它将只保留最后一个值并与任何新的订阅者共享。这在存储当前线程时很有用。记住，你需要用初始值初始化这个主题。'
- en: 'Expose a method to store threads from an external data source:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露一个方法来从外部数据源存储线程：
- en: '[PRE47]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We don't want to store the same thread twice. One thing we can improve is updating
    the thread if it has changed, but we don't need this in our application at this
    point. It is something you should remember when you are improving this application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想存储相同的线程两次。我们可以改进的一件事是更新已更改的线程，但在这个应用程序中我们不需要这个功能。这是你在改进此应用程序时应记住的事情。
- en: With the last implemented logic, we should have the minimal functionality required
    for the conversation threads.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最后实现的逻辑，我们应该有对话线程所需的最小功能。
- en: The message service
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息服务
- en: The message service is going to be a little bit different, because we are going
    to use socket.io to send and receive data through `WebSockets` from the socket
    server, which was set up earlier in this chapter. No worries! The difference will
    not be reflected in the rest of the application. A service should always abstract
    the underlining logic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 消息服务将会有一些不同，因为我们打算使用socket.io通过`WebSockets`从之前在本章中设置的socket服务器发送和接收数据。别担心！这种差异不会反映在应用程序的其他部分。服务应该始终抽象底层逻辑。
- en: 'We are going to start by creating the service file, called `public/src/services/message.service.ts`,
    and import the necessary dependencies:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`public/src/services/message.service.ts`的服务文件，并导入必要的依赖项：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can see that we imported everything from the `socket.io-client` library
    as `io`. Next, we are going to append the class definition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们已将`socket.io-client`库中的所有内容导入为`io`。接下来，我们将添加类定义：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the constructor, we are going to initialize and connect to the socket server.
    Because we are using the default configuration both on the server side and the
    client side, we can just call the `.connect()` method. The `_socketOn()` private
    method will define all event bindings for the socket; let''s append this method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将初始化并连接到socket服务器。因为我们同时在服务器端和客户端使用默认配置，所以我们可以直接调用`.connect()`方法。`_socketOn()`私有方法将定义所有socket事件绑定；让我们添加这个方法：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We just defined two events to listen for and call the `_storeMessage()` method.
    For each event, a new message will arrive through the socket. Following this,
    we should add the method to our `MessageSerivce` class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了两个要监听的事件并调用`_storeMessage()`方法。对于每个事件，将通过socket接收到一条新消息。在此之后，我们应该在我们的`MessageSerivce`类中添加该方法：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When storing a new message, we are going to create a new `User` instance in
    order to have all the necessary data regarding the message sender. This method
    will only be used internally within the service, but we need to expose a method
    to send messages, and it will be accessed by other components:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储一条新消息时，我们将创建一个新的`User`实例，以便拥有关于消息发送者的所有必要数据。此方法将仅在服务内部使用，但我们需要公开一个发送消息的方法，它将被其他组件访问：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Sending a message was not so hard. We had to emit the `send:im` event and attach
    the message itself. Besides sending and receiving messages, we also need to get
    the message history for a given thread and store the messages in the service''s
    data store. Let''s do that right now:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息并不难。我们只需要发出`send:im`事件并附加消息本身。除了发送和接收消息外，我们还需要获取特定线程的消息历史并存储在服务的数据存储中。让我们现在就做这件事：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding method should retrieve for us the necessary data from the Express
    application. We are doing the same thing for each message as before when we stored
    an incoming message. More precisely, we are instantiating a new user with the
    sender's information. This should be all for the message service.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法应该为我们从Express应用程序中检索必要的数据。我们像之前存储传入消息时一样，为每条消息做同样的事情。更确切地说，我们正在使用发送者的信息实例化一个新的用户。对于消息服务来说，这就足够了。
- en: The chat component
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天组件
- en: 'Now that we have all the necessary data types and services, we can get back
    to our application''s components. Looking back at the `app` component, a good
    thing would be to start with the `chat` component. Create a new file called `public/src/chat/chat.component.ts`
    and add the following imports:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有必要的数据类型和服务，我们可以回到应用程序的组件。回顾一下`app`组件，一个好的开始是先从`chat`组件开始。创建一个名为`public/src/chat/chat.component.ts`的新文件，并添加以下导入：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After we have imported all our required modules, we can actually implement
    our component:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所有所需的模块后，我们实际上可以实施我们的组件：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the component's template are included components that we'll implement later
    on, for example, the thread list component, which will display all the current
    conversations with other users. The chat component will be the container for our
    smaller components, but we are also adding a `RouterOutlet` to dynamically load
    components matched to the current route.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的模板中包含了我们将要实现的组件，例如，线程列表组件，它将显示与其他用户的所有当前对话。聊天组件将是我们的较小组件的容器，但我们还添加了一个 `RouterOutlet`
    来动态加载与当前路由匹配的组件。
- en: 'The default route will load a helper component in case no thread ID is added
    as a parameter in the route. We can associate this with a home page for our component.
    You can make the default view as complex as you want; for example, you can add
    a link for the last opened thread. We are going to keep it simple for now. Create
    a new file called `public/src/chat-help.component.ts` and add the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认路由将在路由参数中没有添加线程 ID 时加载一个辅助组件。我们可以将此与组件的主页关联起来。你可以使默认视图尽可能复杂；例如，你可以添加一个链接到最近打开的线程。我们现在将保持简单。创建一个名为
    `public/src/chat-help.component.ts` 的新文件，并添加以下代码：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Noting fancy here! Just a simple component with an inline template that has
    a nice message displayed for the user. Now that we have covered this, we can move
    on and implement the rest of our components.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西！只是一个简单的组件，它有一个内联模板，为用户显示一条友好的消息。现在我们已经覆盖了这一点，我们可以继续并实现其余的组件。
- en: The user list component
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户列表组件
- en: 'The user list component will give us the ability to search for users and start
    a new conversation with them. We will need to display a list of users and filter
    them by a search criterion. Also, by clicking on a user from the list, a new conversation
    thread should open. All this should be fairly simple to implement. Let''s start
    by creating the component file. Create a new file called `public/src/user/user.component.ts`,
    with the following base structure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 用户列表组件将为我们提供搜索用户和与他们开始新对话的能力。我们需要显示用户列表并根据搜索标准进行过滤。此外，点击列表中的用户应打开一个新的对话线程。所有这些都应该相对简单易行。让我们首先创建组件文件。创建一个名为
    `public/src/user/user.component.ts` 的新文件，并具有以下基本结构：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We imported the necessary dependencies and defined the base for our component.
    The component will have two major parts, a list of users and an input field, which
    will be used to search for a given user from the list. Let''s define the template
    for our component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了必要的依赖项并定义了组件的基础。组件将包含两个主要部分，用户列表和输入字段，用于从列表中搜索指定的用户。让我们定义组件的模板：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to show a list of users, we are going to subscribe to the `users`
    observable from the user service. Append the following code to the constructor:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示用户列表，我们将订阅用户服务中的 `users` 可观察对象。将以下代码添加到构造函数中：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To display a list of filtered users, we are going to use the following logic.
    Append this code to the constructor:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示过滤后的用户列表，我们将使用以下逻辑。将以下代码添加到构造函数中：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To feed data from the input, we can use something like this method, which will
    execute only when the user starts typing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从输入中获取数据，我们可以使用类似以下的方法，该方法仅在用户开始输入时执行：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to open a new thread, we bound a click event for each user displayed
    in the list. Let''s add the required method for this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打开一个新的线程，我们为列表中显示的每个用户绑定了一个点击事件。让我们添加执行此操作所需的方法：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding code will just call the `.open()` method from the thread service,
    and upon success, it will navigate to the returned thread. We are also calling
    the `cleanUp()` method from this component, which will reset our component to
    the initial state.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将仅调用线程服务的 `.open()` 方法，并在成功后导航到返回的线程。我们还从这个组件中调用了 `cleanUp()` 方法，这将重置我们的组件到初始状态。
- en: 'Finally, let''s add all the missing logic from our component. Just append the
    methods to the component:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加组件中缺失的所有逻辑。只需将方法附加到组件中：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As a quick recap, we created a user list component that displays all users in
    a list when focusing on the search input; by default, the list is hidden. We added
    some special events; for example, by pressing the *Esc* key, the list should be
    hidden.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下，我们创建了一个用户列表组件，当聚焦到搜索输入时，它会显示列表中的所有用户；默认情况下，列表是隐藏的。我们添加了一些特殊事件；例如，按 *Esc*
    键时，列表应该被隐藏。
- en: Displaying threads
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示线程
- en: A user must know in which conversation he/she is participating, so we need to
    display this information to the user. To do so, we are going to implement a thread
    listing component.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须知道他/她参与的是哪个对话，因此我们需要向用户显示此信息。为此，我们将实现一个线程列表组件。
- en: Thread component
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程组件
- en: 'In order to display a list of threads, we are going to use a component for
    each thread to encapsulate all the information displayed to the user and functionalities.
    To create the desired component, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示线程列表，我们将为每个线程使用一个组件来封装显示给用户的所有信息和功能。要创建所需的组件，请遵循以下步骤：
- en: Create the component file, called `public/src/thread/thread.component.ts`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件文件，命名为 `public/src/thread/thread.component.ts`。
- en: 'Import the necessary dependencies:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的依赖项：
- en: '[PRE64]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add the component annotation:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件注解：
- en: '[PRE65]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Define the component''s class:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义组件的类：
- en: '[PRE66]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We created a single thread component to be used to display information in a
    list. We are using `routerLink` to navigate to the desired conversation thread.
    On initialization, we check which is the current thread so that we can mark the
    selected thread.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个单独的线程组件，用于在列表中显示信息。我们使用 `routerLink` 导航到所需的对话线程。在初始化时，我们检查当前是哪个线程，以便我们可以标记选定的线程。
- en: Thread list component
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程列表组件
- en: 'Now that we have our thread component, we can display them in a list. For this,
    a new component will be used. Let''s do something similar to what was done before:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了线程组件，我们可以将它们显示在列表中。为此，将使用一个新的组件。让我们做类似的事情：
- en: Create the component file, called `public/src/thread/thread-list.component.ts`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件文件，命名为 `public/src/thread/thread-list.component.ts`。
- en: 'Import the necessary dependencies, together with the `thread` component:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的依赖项，包括 `thread` 组件：
- en: '[PRE67]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Build the component annotation:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建组件注解：
- en: '[PRE68]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define the `ThreadListComponent` class:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `ThreadListComponent` 类：
- en: '[PRE69]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This should display a nice list of opened conversation threads for the user.
    We are using the `thread` service to get the necessary data for the component.
    If the `threads` collection from the service changes, the update strategy will
    handle the necessary updates for us.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向用户显示一个打开的对话线程列表。我们使用 `thread` 服务获取组件所需的数据。如果服务的 `threads` 集合发生变化，更新策略将为我们处理必要的更新。
- en: Messaging
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: Now that we can initiate and resume a conversation, we need to be able to send
    messages in that conversation to the participants. We are going to focus on achieving
    this functionality.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始和恢复对话，我们需要能够向该对话的参与者发送消息。我们将专注于实现此功能。
- en: The flow for sending messages is pretty simple. First, we send the desired message
    to the backend application, storing the message for history purposes, and we notify
    the recipient of a new message. Both the sender and the recipient have the message
    displayed on their devices.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息的流程相当简单。首先，我们将所需的消息发送到后端应用程序，为历史记录存储消息，并通知收件人有新消息。发送者和收件人都会在他们的设备上显示消息。
- en: Sending messages
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息
- en: Earlier, in the `chat` component, we used a `message form` component. This component
    will permit us to input messages and send them to the Node.js backend service.
    Let's keep it simple and add only the necessary functionalities. Create a new
    component file called `public/src/message/message-form.component.ts`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `chat` 组件中，我们使用了 `message form` 组件。此组件将允许我们输入消息并将它们发送到 Node.js 后端服务。让我们保持简单，只添加必要的功能。创建一个新的组件文件，命名为
    `public/src/message/message-form.component.ts`。
- en: 'We are going to import two services in our component. We append the following
    code for our dependencies:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在组件中导入两个服务。为我们的依赖项添加以下代码：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we are going to add the component annotation and define the component''s
    class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加组件注解并定义组件的类：
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To define the rest of the necessary logic, we are going to follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义其余必要的逻辑，我们将遵循以下步骤：
- en: 'Add the following properties to the class:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向该类添加以下属性：
- en: '[PRE72]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Change the constructor to something similar to the following:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数更改为以下类似的形式：
- en: '[PRE73]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Modify the component''s initialization to reset the `draft message` value:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改组件的初始化以重置 `草稿消息` 值：
- en: '[PRE74]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the send message logic:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加发送消息的逻辑：
- en: '[PRE75]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This will simply call the `.sendMessage()` method from the `thread` service.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将简单地调用 `thread` 服务的 `.sendMessage()` 方法。
- en: 'Define what happens when the user hits the *Enter* key:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义当用户按下 *Enter* 键时会发生什么：
- en: '[PRE76]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Technically, we can now send messages to the backend and persist them in MongoDB
    to construct the message history.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们现在可以向后端发送消息并将它们持久化到MongoDB以构建消息历史。
- en: The message component
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息组件
- en: To display all the messages, we are going to start small and create the message
    component. This component will be a single entry from the list of messages. We
    should already have the necessary data and logic to display a single message.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示所有消息，我们将从小处着手，创建消息组件。此组件将是消息列表中的一个条目。我们应该已经有了显示单个消息所需的数据和逻辑。
- en: 'To implement the `message` component, create a new file called `public/src/message/message.component.ts`
    and append the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`message`组件，创建一个名为`public/src/message/message.component.ts`的新文件，并附加以下代码：
- en: '[PRE77]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The component is fairly simple. It just displays data about a single message,
    and after the view has initialized, it will scroll the message list to the bottom.
    With the last functionality, if there are more messages than can actually fit
    in the view, it will simply scroll to the latest message.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件相当简单。它仅显示单个消息的数据，并在视图初始化后，将消息列表滚动到最底部。通过最后一个功能，如果实际可以放入视图中的消息多于实际消息，它将简单地滚动到最后一条消息。
- en: The message list component
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息列表组件
- en: Before we implemented a single message component, this was necessary for our
    message list component, which will display all messages to the user. We are going
    to use a similar pattern to implement this component as for the thread list.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现单个消息组件之前，这是我们的消息列表组件所必需的，该组件将向用户显示所有消息。我们将使用与线程列表类似的模式来实现此组件。
- en: 'Follow these steps to implement the message list component:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现消息列表组件：
- en: 'Import the necessary dependencies:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的依赖：
- en: '[PRE78]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Append the Angular component annotation:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Angular组件注解：
- en: '[PRE79]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define the component''s class:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义组件的类：
- en: '[PRE80]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Because we are reloading the component each time we navigate to the matched
    route, we can get the current `identifier` parameter and load messages by the
    current thread ID. We are also setting the current thread ID so that other subscribers
    can take actions accordingly. For example, in the `thread` component, we check
    whether the current thread matches the component's thread.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们每次导航到匹配的路由时都会重新加载组件，我们可以获取当前的`identifier`参数并通过当前线程ID加载消息。我们还设置了当前线程ID，以便其他订阅者可以相应地采取行动。例如，在`thread`组件中，我们检查当前线程是否与组件的线程匹配。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have reached the end of this chapter. The chapter was about building a real-time
    chat application. We used `WebSockets` for the real-time communication, stored
    the message history in MongoDB, and created threaded conversations. We also left
    some room for improvements, or to add new functionalities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本章的结尾。本章是关于构建实时聊天应用程序。我们使用了`WebSockets`进行实时通信，将消息历史存储在MongoDB中，并创建了线程式对话。我们还为改进或添加新功能留出了空间。
- en: In the next chapter, we'll try to build an e-commerce application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将尝试构建一个电子商务应用程序。
