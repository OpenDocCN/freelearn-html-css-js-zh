<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Working with Functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Functions</h1></div></div></div><p>You'll find functions everywhere within a sufficiently large piece of JavaScript code. That's because they're treated in the same way as any other primitive type. Everything is an object in JavaScript, including functions. Functions have a context and a prototype, and they can be assigned to a new context and to variables.</p><p>Lo-Dash helps to best utilize functions. Where there are missing pieces, the utilities that Lo-Dash provides let us write some truly elegant, functional code. This chapter dives into these utilities. Whether we're changing the meaning of <code class="literal">this</code> or decorating an existing function, we'll walk through examples that illustrate how to get started.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Binding function contexts</li><li class="listitem" style="list-style-type: disc">Decorating functions</li><li class="listitem" style="list-style-type: disc">Function constraints</li><li class="listitem" style="list-style-type: disc">Timed execution</li><li class="listitem" style="list-style-type: disc">Composing and currying functions</li></ul></div><div class="section" title="Binding function contexts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Binding function contexts</h1></div></div></div><p>Every JavaScript <a id="id184" class="indexterm"/>function has a context. If you're coming from an object-oriented language, the function context is a lot like the object a method belongs to. The difference of course is that JavaScript doesn't classify objects in the object-oriented sense of the concept. Instead, functions are bound to a default context, and this can easily be changed at runtime. There are even built-in language mechanisms to make this happen.</p><p>Lo-Dash makes changing function contexts easy. We'll need to work with function contexts often when programming with Lo-Dash. We'll take a look at a number of approaches to working with and changing the context of functions now.</p><div class="section" title="Changing the this keyword"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Changing the this keyword</h2></div></div></div><p>Inside a function, the<a id="id185" class="indexterm"/> execution context is referred to by <a id="id186" class="indexterm"/>the <code class="literal">this</code> keyword. This is a special binding that we don't need to declare. It's always available to reference within a given function scope. It's important to keep in mind that it's entirely up to the caller, should he/she decide to override the meaning of <code class="literal">this</code>.</p><p>The <code class="literal">bind()</code> function<a id="id187" class="indexterm"/> is a powerful way to construct a new function that is permanently bound to the specified context. Here's a first look at how <code class="literal">bind()</code> works:</p><div class="informalexample"><pre class="programlisting">function sayWhat() {
    return 'Say, ' + this.what;
}   

var sayHello = _.bind(sayWhat, {
    what: 'hello'
});

var sayGoodbye = _.bind(sayWhat, {
    what: 'goodbye'
}); 

sayHello();
// → "Say, hello"

sayGoodbye();
// → "Say, goodbye"</pre></div><p>The preceding code defines a generic <code class="literal">sayWhat()</code> function that formats a string message based on the context for the function. In particular, it looks for the <code class="literal">what</code> property of the context. Next we use <code class="literal">bind()</code> to define two new functions based on <code class="literal">sayWhat()</code>. The <code class="literal">sayHello()</code> function is bound to a new context, while the <code class="literal">sayGoodbye()</code> function is bound to yet another context. The second argument to <code class="literal">bind()</code> is the object that becomes <code class="literal">this</code> in the function that's being bound. We can see that each of these contexts defines a unique <code class="literal">what</code> property value and this is reflected in the output of calling these two functions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Without Lo-Dash, we would rely on the <code class="literal">call()</code>, <code class="literal">apply()</code>, or <code class="literal">bind()</code> methods of the function to change its context. The advantage with the Lo-Dash <code class="literal">bind()</code> implementation is that it performs better because it's able to optimize better than the native methods.</p></div></div><p>The <code class="literal">sayWhat()</code> function<a id="id188" class="indexterm"/> didn't make use of any arguments. But just <a id="id189" class="indexterm"/>because we're fiddling with contexts doesn't mean the function we're binding can't accept arguments. Many functions make use of both arguments passed by the caller and the context object. Functions with custom contexts can indeed accept arguments. They can also be called with additional arguments after being bound to a new context, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function sayWhat(what) {
    if (_.isUndefined(what)) {
        what = this.what;
    }   
    return 'Say, ' + what;
}   

var sayHello = _.bind(sayWhat, {
    what: 'hello'
});

var sayGoodbye = _.bind(sayWhat, {}, 'goodbye'),
    saySomething = _.bind(sayWhat, {});

sayHello();
// → "Say, hello"

sayGoodbye();
// → "Say, goodbye"

saySomething('what?');
// → "Say, what?"</pre></div><p>The <code class="literal">sayWhat()</code> function accepts a <code class="literal">what</code> parameter used to construct the string message. If this parameter is not supplied, it falls back to the <code class="literal">what</code> property of the context. Now we define three new functions, all with unique context and argument constraints. The <code class="literal">sayHello()</code> function isn't any different from the previous example; the <code class="literal">what</code> value is in the context. The <code class="literal">sayGoodbye()</code> function definition passes a third argument to <code class="literal">bind()</code>. After the context object, <code class="literal">bind()</code> will accept any number of arguments that are also bound to the function, but in a different way. This is called <a id="id190" class="indexterm"/>
<span class="strong"><strong>partial application</strong></span>, and we'll look at this later on in the chapter. The function is always bound, not only to the context, but to the argument values as well. Lastly, the <code class="literal">saySomething()</code> function is bound to a context that lacks the <code class="literal">what</code> property. Also, it is not bound to any <code class="literal">what</code> parameter. However, the <code class="literal">what</code> argument can still be supplied when the function is called, as is the case here.</p></div><div class="section" title="Binding methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Binding methods</h2></div></div></div><p>There are no methods, per se, in JavaScript—just functions and context. However, that doesn't prevent programmers <a id="id191" class="indexterm"/>from following a more traditional <a id="id192" class="indexterm"/>object-oriented model.</p><p>If we assign a function to an object property, that object then becomes the context for the function. This is just the default behavior, and as the previous section illustrated, the context can change. However, the object to which the function belongs, being the default context, maps well to methods and encapsulation. The <code class="literal">bindAll()</code> function<a id="id193" class="indexterm"/> can help enforce this mapping:</p><div class="informalexample"><pre class="programlisting">function bindName(name) {
    return _.bind(name, {
        first: 'Becky',
        last: 'Rice'
    }); 
}   

var object = { 
    first: 'Ralph',
    last: 'Crawford',
    name: function() {
        return this.first + ' ' + this.last;
    }   
};

var name = bindName(object.name);


object.name();
// → "Ralph Crawford"

name();
// → "Becky Rice"

_.bindAll(object);

name = bindName(object.name)

name();
// → "Ralph Crawford"</pre></div><p>Let's walk through the bits of this experiment. The goal is to illustrate that once the <code class="literal">bindAll()</code> function is applied to an object, all methods belonging to that object have the context glued to it. It cannot change after this. First, the <code class="literal">bindName()</code> function just takes another function and binds it to the <code class="literal">Becky</code> context. We'll use this later on to prove a point.</p><p>The <code class="literal">object</code> variable holds a <a id="id194" class="indexterm"/>plain object with some simple properties and a simple method. The <code class="literal">name</code> variable is a function defined using the <code class="literal">bindName()</code> function. Notice that we're taking the <code class="literal">object.name()</code> method and assigning it a new context. The values we put in the <code class="literal">result</code> object confirm this. Next is the call<a id="id195" class="indexterm"/> to <code class="literal">bindAll()</code> on <code class="literal">object</code>. From this point onward, the <code class="literal">name()</code> method context can't change—it's glued to <code class="literal">object</code>. We then proceed to prove this fact by trying to bind it to a new context again, but <code class="literal">bindAll()</code> has enforced the context.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>When using <code class="literal">bindAll()</code>, you can unintentionally break other functionality in your application. The ability to change function context is a strength, not a weakness. Use <code class="literal">bindAll()</code> when you're absolutely certain that the method context should never change. If there's little to no chance of your method context changing when it shouldn't, don't bother with <code class="literal">bindAll()</code>.</p></div></div><p>The name <code class="literal">bindAll()</code> implies that this is an all or nothing operation, which actually isn't the case. We don't have to enforce the context of every method attached to your object. We can actually specify the method names as a second argument and only these methods are glued to the object context. This is illustrated in the following example:</p><div class="informalexample"><pre class="programlisting">function getName() {
    return this.name;
}   

var object = { 
    name: 'My Bound Object',
    method1: getName,
    method2: getName,
    method3: getName
};


_.bindAll(object, [ 'method1', 'method2' ]); 

var method3 = _.bind(object.method3, {
    name: 'New Context'
}); 

object.method1();
// → "My Bound Object"

object.method2();
// → "My Bound Object"

method3();
// → "New Context"</pre></div><p>We can see that the call to <code class="literal">bindAll()</code> specifies that only <code class="literal">method1</code> and <code class="literal">method2</code> are bound to <code class="literal">object</code>. Later on, we actually try binding <code class="literal">method3</code> to a completely new context and it works as expected. Had we not limited the <code class="literal">bindAll()</code> call to specific methods, we wouldn't have been able to change the context of <code class="literal">method3</code>.</p></div><div class="section" title="Dynamic methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Dynamic methods</h2></div></div></div><p>Methods can also lazily bind to <a id="id196" class="indexterm"/>objects. We can use the <code class="literal">bindKey()</code> function<a id="id197" class="indexterm"/> to <a id="id198" class="indexterm"/>construct a new function that will call the given method name on the given object. The method doesn't actually have to exist prior to calling <code class="literal">bindKey()</code>. That's the lazy part. And this comes in handy if you need to assign a method as a callback but aren't exactly sure if the method exists yet. Consider the following example:</p><div class="informalexample"><pre class="programlisting">function workLeft() {
    return 65 - this.age + ' years';
}   

var object = { 
    age: 38
};  

var work = _.bindKey(object, 'work');

object.work = workLeft;

work();
// → "27 years"</pre></div><p>Here we have an object with an <code class="literal">age</code> property. We also have a <code class="literal">workLeft()</code> function that computes a number based on the <code class="literal">age</code> property of the context. We could assign this function directly to the <code class="literal">work</code> property, but we've instead used the <code class="literal">bindKey()</code> function to construct a new function that will reference the <code class="literal">work()</code> method when called. The crucial thing to note is that we're able to build this callback function before the <code class="literal">work()</code> method exists in <code class="literal">object</code>. It gets added later. It could also get swapped out for a different implementation and would still call the appropriate method.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The bound key has to exist when the function created by <code class="literal">bindKey()</code> is eventually called. Otherwise, you'll get a <code class="literal">TypeError</code>.</p></div></div><p>Just like a function that has been bound to a context using the <code class="literal">bind()</code> function, we still have freedom with the way arguments are managed. That is, we can bind argument values or supply argument values when the bound function is called, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function workLeft(retirement, period) {
    return retirement - this.age + ' ' + period;
}   

var collection = [ 
    { age: 34, retirement: 60 },
    { age: 47 },
    { age: 28, retirement: 55 },
    { age: 41 }
];

var functions = [], 
    result = []; 

 _.forEach(collection, function(item) {
    functions.push(_.bindKey(item, 'work', item.retirement ?
        item.retirement : 65));
}); 

_.forEach(collection, function(item) {
    _.extend(item, { work: workLeft }); 
}); 

_.forEach(functions, function(item) {
    result.push(item('years'));
});
// → 
// [
//   "26 years",
//   "18 years",
//   "27 years",
//   "24 years"
// ]</pre></div><p>The <code class="literal">workLeft()</code> function <a id="id199" class="indexterm"/>depends on a couple of arguments and the <code class="literal">age</code> property of<a id="id200" class="indexterm"/> the context. Next, we define a collection of objects and a couple of empty arrays to perform our experiment. Now we have three <code class="literal">forEach()</code> iterations that demonstrate how arguments work with <code class="literal">bindKey()</code>.</p><p>The first iteration is over the collection and is where the <code class="literal">bindKey()</code> function is applied in order to generate a <code class="literal">work()</code> method. We can see that not every object in the collection has a <code class="literal">retirement</code> property value. If it doesn't, we bind <code class="literal">65</code> as the argument value. At this point, we have an array of functions, each bound to the <code class="literal">work()</code> method of their object. The second iteration populates the <code class="literal">work</code> property of each object in the collection, so now <code class="literal">work()</code> is a callable function.</p><p>The last iteration calls each of these bound method functions with another argument.</p></div></div></div>
<div class="section" title="Decorating functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Decorating functions</h1></div></div></div><p>A decorator does what the name implies. It<a id="id201" class="indexterm"/> decorates functions with additional capabilities. It's like an adornment for a piece of functionality. For example, let's say we've already implemented a function that looks up data in some structure. It's already used throughout our application, but now we're implementing a new component that requires this same functionality and something extra. We can use the function-decorating tools provided by Lo-Dash to take existing functions and extend them.</p><p>There are two flavors of Lo-Dash function decoration: <span class="strong"><strong>Partials</strong></span>, which <a id="id202" class="indexterm"/>construct new functions that have the arguments of the original function partially supplied, and <a id="id203" class="indexterm"/>
<span class="strong"><strong>Wrappers</strong></span>, which build a new function that wraps the original function with a whole new function.</p><div class="section" title="Partials"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Partials</h2></div></div></div><p>To create a partial function<a id="id204" class="indexterm"/> using Lo-Dash, you use<a id="id205" class="indexterm"/> the <code class="literal">partial()</code> function. The resulting function then has some arguments presupplied—we don't have to supply them again when called. This concept is really useful when we need to dynamically supply arguments to a function, just before it's passed to a new context where those arguments aren't available. This is also the case with callbacks, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">function sayWhat(what) {
    return 'Say, ' + what;
}

var hello = _.partial(sayWhat, 'hello'),
    goodbye = _.partial(sayWhat, 'goodbye');

hello();
// → "Say, hello"

goodbye();
// → "Say, goodbye"</pre></div><p>The <code class="literal">sayWhat()</code> function builds a simple string based on the supplied string argument. The two calls to <code class="literal">partial()</code> that follow supply this argument. The <code class="literal">hello()</code> and <code class="literal">goodbye()</code> functions, when called, will call <code class="literal">sayWhat()</code> with their respective partial arguments.</p><p>As we've seen so far in <a id="id206" class="indexterm"/>this chapter, many of the Lo-Dash functions that deal with functions return new ones. They also support the arguments passed by the caller. This is valuable because adding new parameters to our functions doesn't require changes to our function bindings, as shown here:</p><div class="informalexample"><pre class="programlisting">function greet(greeting, name) {
    return greeting + ', ' + name;
}   

var hello = _.partial(greet, 'hello'),
    goodbye = _.partial(greet, 'goodbye');

hello('Fran');
// → "hello, Fran"

goodbye('Jacob');
// → "goodbye, Jacob"</pre></div><p>The <code class="literal">greet()</code> function in the preceding code accepts two arguments, <code class="literal">greeting</code> and <code class="literal">name</code>. The <code class="literal">hello()</code> and the <code class="literal">goodbye()</code> functions are constructed as partial functions that call <code class="literal">greet()</code> with the first argument already supplied. Later on, when these functions are called, we can supply the more context-specific argument—<code class="literal">name</code>.</p><p>What if the context-specific argument were the first function argument? Can we still have the caller of the partial function supply the name? To answer this question, we turn to the <code class="literal">partialRight()</code> function:</p><div class="informalexample"><pre class="programlisting">function greet(name, greeting) {
    return greeting + ', ' + name;
}   

var hello = _.partialRight(greet, 'hello'),
    goodbye = _.partialRight(greet, 'goodbye');

hello('Brent');
// → "hello, Brent"

goodbye('Alison');
// → "goodbye, Alison"</pre></div><p>This code looks similar to the previous example, but there is one important difference. The <code class="literal">greet()</code> function expects the <code class="literal">name</code> parameter as the first argument. We want the caller to be able to specify this value, but we also want to specify <code class="literal">greeting</code> as a partial argument. The <code class="literal">partialRight()</code> function works the same as <code class="literal">partial()</code> except that it passes arguments to the function in a different order.</p><p>Partials aren't limited to our <a id="id207" class="indexterm"/>own functions. We can exploit this shorthand against Lo-Dash functionality itself. If you need to run a Lo-Dash function, in a callback for example, you can construct a new partial function that redefines the Lo-Dash function, with the arguments presupplied. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    'Sheila',
    'Kurt',
    'Wade',
    'Kyle'
];

var random = _.partial(_.random, 1, collection.length),
    sample = _.partial(_.sample, collection);

random();
// → 4

sample();
// → "Wade"</pre></div><p>Here we have a simple collection and two partial functions that operate on it. First, we utilize the <code class="literal">random()</code> Lo-Dash function, supplying the range as partial arguments. Then we utilize the <code class="literal">sample()</code> function, supplying the collection to sample as a partial argument.</p></div><div class="section" title="Function decorators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Function decorators</h2></div></div></div><p>We can utilize the <code class="literal">wrap()</code> function to decorate a <a id="id208" class="indexterm"/>value or another function with specific behavior. As with all other Lo-Dash function helpers, one advantage of using <code class="literal">wrap()</code> is that the caller of the generated function can supply more data via arguments, as demonstrated in the following code:</p><div class="informalexample"><pre class="programlisting">function strong(value) {
    return '&lt;strong&gt;' + value + '&lt;/strong&gt;';
}   

function regex(exp, val) {
    exp = _.isRegExp(exp) ?
        exp : new RegExp(exp);
    return _.isUndefined(val) ?
        exp : exp.exec(val);
}   

var boldName = _.wrap('Marianne', strong),
    getNumber = _.wrap('(\\d+)', regex);

boldName();
// → "&lt;strong&gt;Marianne&lt;/strong&gt;"

getNumber('abc123')[1];
// → "123"</pre></div><p>The first function, <code class="literal">strong()</code>, wraps <a id="id209" class="indexterm"/>the value in <code class="literal">&lt;strong/&gt;</code> tags. The second function, <code class="literal">regex()</code>, is a little more involved. It wraps a value in a <code class="literal">RegExp</code> instance. But it's smart enough to do this only if the value is a string—if it's already a regular expression, there's no need to create another. Also, if a value is supplied to the second argument, it'll execute the regular expression against it, returning the result.</p><p>The result of calling <code class="literal">boldName()</code> is self-explanatory. The value <code class="literal">'Marianne'</code> is wrapped with the <code class="literal">strong()</code> function. The <code class="literal">getNumber()</code> function is a result of wrapping a regular expression string that looks for numbers. However, the call to <code class="literal">getNumber()</code> supplies an additional argument, that is, the call provides a string to execute the regular expression against it. This is why we access the result using a numerical index following the call.</p><p>Let's turn our attention to decorating existing functions with new functionality using <code class="literal">wrap()</code>:</p><div class="informalexample"><pre class="programlisting">var user = _.sample([
    'Scott',
    'Breanne'
]);

var allowed = [
    'Scott',
    'Estelle'
];  

function permission(func) {
    if (_.contains(allowed, user)) {
        return func.apply(null, _.slice(arguments, 1));
    }   
    throw new Error('DENIED');
}   

function echo(value) {
    return value;
}   

var welcome = _.wrap(echo, permission);

welcome('Yo there!');</pre></div><p>The basic idea here is to decorate the <code class="literal">echo()</code> function with permission checking ability. The <code class="literal">permission()</code> function will call the function that is passed to it only if the <code class="literal">user</code> variable exists in the <code class="literal">allowed</code> array. An exception is raised if this is not the case. Repeatedly running this code will randomly generate denied errors. It all depends on whether <code class="literal">'Breanne'</code>, who isn't in the <code class="literal">allowed</code> array, is sampled as the current user or not.</p></div></div>
<div class="section" title="Function constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Function constraints</h1></div></div></div><p>Similar to decorating<a id="id210" class="indexterm"/> functions with new behavior are the constraints imposed on functions. This impacts when and how often the function can be called. Function constraints also control how values returned by calling a function are cached. Lo-Dash has functions that deal with each of these scenarios.</p><div class="section" title="Limiting call counts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Limiting call counts</h2></div></div></div><p>There are two<a id="id211" class="indexterm"/> Lo-Dash functions that deal with counting the number of times a given function is called. The <code class="literal">after()</code> function will execute a callback after the composed function is called a given number of times. The <code class="literal">once()</code> function constrains the given function to being called only once. Let's look at <code class="literal">after()</code> and see how it works:</p><div class="informalexample"><pre class="programlisting">function work(value) {
    progress();
}   

function reportProgress() {
    console.log(++complete + '%');
    progress = complete &lt; 100 ?
        _.after(0.01 * collection.length, reportProgress) :
        _.noop;
}   

var complete = 0,
    collection = _.range(9999999),
    progress = _.noop;

reportProgress();

_.forEach(collection, work);
// →
// 1%
// 2%
// 3%
// …</pre></div><p>The <code class="literal">work()</code> function is a <a id="id212" class="indexterm"/>contrived function that actually does nothing other than calling <code class="literal">progress()</code>, which notifies the world that progress has been made. A real function that actually did work would call <code class="literal">progress()</code> after having done the work. Next, we have a <code class="literal">reportProgress()</code> function. It is responsible for logging the progress. It also creates the <code class="literal">progress()</code> function using <code class="literal">after()</code>. Until the <code class="literal">complete</code> variable has reached 100 percent, it'll call <code class="literal">reportProgress()</code> again, which redefines the <code class="literal">progress()</code> function. The <code class="literal">after()</code> function will call the callback function supplied to it after the <code class="literal">progress()</code> function has been called <code class="literal">x</code> number of times. In this case, <code class="literal">x</code> is 1 percent of the collection length.</p><p>To sum up, <code class="literal">reportProgress()</code> defines the <code class="literal">progress()</code> function. This function is called by worker functions that need to notify the world about their progress. After <code class="literal">progress()</code> has been called so many times, <code class="literal">reportProgress()</code> is called. This is where the progress is logged and <code class="literal">progress()</code> is redefined.</p><p>All this is put into action by creating a rather large collection and iterating over it, calling <code class="literal">work()</code> along the way. But before the iterating starts, we kick off the progress tracker by calling <code class="literal">reportProgress()</code>. One nice aspect of this code is that there is a separation of concerns between tracking progress and performing work. The worker function only needs to worry about calling <code class="literal">progress()</code>. The <code class="literal">reportProgress()</code> is only concerned about periodically logging the progress and doesn't care about the actual work being done.</p><p>Asynchronous operations can make use of <code class="literal">after()</code> as well. The previous example explicitly called the function that was created by <code class="literal">after()</code>. However, what if we want to synchronize what happens after several asynchronous callback functions have fired? Let's find out using the following code:</p><div class="informalexample"><pre class="programlisting">function process(coll, callback) {
    var sync = _.after(coll.length, callback);
    _.forEach(coll, function() {
        setTimeout(sync, _.random(2000));
    }); 
    console.log('timeouts all set');
}   

process(_.range(5), function() {
    console.log('callbacks completed');
});
// →
// timeouts all set
// callbacks completed  </pre></div><p>First, we have a <code class="literal">process()</code> function meant to symbolize a long-running asynchronous process—something that runs in the background, in other words. This function takes two arguments: a collection and a callback. The <code class="literal">callback</code> is a function that is called after each asynchronous operation on the collection has completed. We do this by creating a new <code class="literal">sync()</code> function using <code class="literal">after()</code>. The collection length is passed to <code class="literal">after()</code>. This means that after <code class="literal">sync()</code> has been called five times, which is the length of our collection, the callback is called.</p><p>Next, we randomly choose a timeout and call <code class="literal">sync()</code>—this is the asynchronous part. After all the timeouts have been set, we then log that the calls to <code class="literal">sync()</code> have been scheduled. The callback that executes when these are done logs a basic message.</p><p>Sometimes, it's useful to<a id="id213" class="indexterm"/> call a function just once. Beyond that, it is just useless repetition—harmless, but unnecessary. Therefore, a useful constraint for a function might be only allowing it to be called once. But how would we enforce such a thing? This can be done using the following code:</p><div class="informalexample"><pre class="programlisting">function getLeader(coll) {
    return _.first(_.sortBy(coll, 'score').reverse());
}   

var collection = [ 
    { name: 'Dana', score: 84.4 },
    { name: 'Elsa', score: 44.3 },
    { name: 'Terrance', score: 55.9 },
    { name: 'Derrick', score: 86.1 }
];

var leader = _.once(getLeader);

leader(collection);
// → { name: "Derrick", score: 86.1 }</pre></div><p>The <code class="literal">getLeader()</code> function in this code takes a collection and returns the name of the leader, according to the <code class="literal">score</code> property. We use this function to construct the <code class="literal">leader()</code> function. Using <code class="literal">once()</code>, we tell the <code class="literal">leader()</code> function to only call <code class="literal">getLeader()</code> once, and only once. You can't prevent the caller from making 50 calls to these functions. The job of the <code class="literal">once()</code> function is to encapsulate the function passed to it, storing the return value of the first invocation. If this value is set, it's cached for subsequent calls. So the preceding code assumes that the collection is unchanging and the leader will always be the same.</p></div><div class="section" title="Caching values"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Caching values</h2></div></div></div><p>The preceding example<a id="id214" class="indexterm"/> gave the first glimpse into caching values with Lo-Dash. If the function is constrained to be called only once, it might as well store the value of that first invocation. This is almost caching as a side effect—there's a more explicit approach that uses the <code class="literal">memoize()</code> function. Explicit caching is especially useful for mathematical functions, where given the same input, the same output is always produced. This is also referred to as <a id="id215" class="indexterm"/>
<span class="strong"><strong>referential transparency</strong></span>. An example for this is as follows:</p><div class="informalexample"><pre class="programlisting">function toCelsius(degrees) {
    return (degrees - 32) * 5 / 9;
}   

function toFahrenheit(degrees) {
    return degrees * 9 / 5 + 32; 
}   

var celsius = _.memoize(toCelsius),
    fahrenheit = _.memoize(toFahrenheit);

toCelsius(89).toFixed(2) + ' C';
// → "31.67 C"
 
celsius(89).toFixed(2) + ' C'; 
// → "31.67 C"

toFahrenheit(23).toFixed(2) + ' F'; 
// → "73.40 F"

fahrenheit(23).toFixed(2) + ' F';
// → "73.40 F"</pre></div><p>Here, we have two simple mathematical functions and they are good <a id="id216" class="indexterm"/>candidates for <span class="strong"><strong>memoization</strong></span>. The <code class="literal">toCelsius()</code> function takes the given degrees in Fahrenheit and returns the Celsius equivalent. The <code class="literal">toFahrenheit()</code> function is the inverse—it takes a Celsius argument and returns a Fahrenheit value. We then take these two functions and wrap them with <code class="literal">memoize()</code>, yielding two new functions, <code class="literal">celsius()</code> and <code class="literal">fahrenheit()</code>.</p><p>After that, we make two calls each to the same function successively. The first call computes the value and stores it. The second call returns the cached result and computes nothing, but how does this cache lookup work? How does the memoized function know to use a value from the cache and not to compute a value? Let's find this out using the following code:</p><div class="informalexample"><pre class="programlisting">function toCelsius(degrees) {
    return (degrees - 32) * 5 / 9;
}   

function toFahrenheit(degrees) {
    return degrees * 9 / 5 + 32; 
}   

function convertTemp(degrees, system) {
    return system.toUpperCase() === 'C' ?
        toFahrenheit(degrees).toFixed(2) + ' F' :
        toCelsius(degrees).toFixed(2) + ' C'; 
}   

var convert = _.memoize(convertTemp, function(degrees, system) {
     return degrees + system;
}); 

convert(89, 'F');
convert(89, 'F');
convert(23, 'C');
convert(23, 'C');</pre></div><p>By default, the<a id="id217" class="indexterm"/> resulting function generated by <code class="literal">memoize()</code> will use the first supplied argument as the cache key. The cache is a simple object and values are looked up by the property key. In the previous example, the memoized functions accepted only one argument. This is fine, but in more complex functions that accept more than one argument, you need a means to resolve the lookup key, as is illustrated in the preceding example.</p><p>This is basically a rewrite of the previous example, as it generates the same result. We still have the <code class="literal">toCelsius()</code> and <code class="literal">toFahrenheit()</code> functions, but we've introduced a new <code class="literal">convertTemp()</code> function. This function accepts two arguments: the <code class="literal">degrees</code> and the temperature <code class="literal">system</code> these degrees represent. Based on these argument values, we can make the appropriate call to either <code class="literal">toCelsius()</code> or <code class="literal">toFahrenheit()</code>.</p><p>We then construct the <code class="literal">convert()</code> function, a memoized version of <code class="literal">convertTemp()</code>. You'll notice the second function passed to <code class="literal">memoize()</code> here builds and returns a cache key. Without it, cache keys would still be consulted based only on the first argument value, which would return incorrect data. Be careful.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>You may have noticed that we could have continued using the previously cached functions, <code class="literal">celsius()</code> and <code class="literal">fahrenheit()</code>. That would mean a multilayered cache, which sounds kind of cool actually. Resist the temptation to do stuff like this. If you're performing badly enough to require a multilayer cache, it's time to reconsider the design at a higher level.</p></div></div></div></div>
<div class="section" title="Timed execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Timed execution</h1></div></div></div><p>By nature, JavaScript code executes<a id="id218" class="indexterm"/> synchronously, that is, you don't have multiple threads of control, each running a piece of your code and competing for the CPU's attention. There are web workers in modern browsers, but these are far from commonplace yet and don't share much similarity with a threading API you'd find in another language. The upside to all of this is that you, as the programmer, don't need to concern yourself with synchronization primitives and all the other nasty details associated with multithreaded programming.</p><p>Instead, you face a different kind of difficulty in that you have to deal with events, the DOM, and other forms of callbacks; so much for synchronous code. Sometimes, this is actually desired. For example, you need to wait for a predetermined amount of time before something can happen. Or, perhaps you want to update the DOM and then pick up where you left off. Lo-Dash has tools that help you figure out the tricky details when it comes to timing function calls and coping with the side effects.</p><div class="section" title="Delaying function calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Delaying function calls</h2></div></div></div><p>The <code class="literal">delay()</code> function<a id="id219" class="indexterm"/> is used to execute a given callback function after the<a id="id220" class="indexterm"/> given number of <a id="id221" class="indexterm"/>milliseconds has elapsed. This actually works the same way as the built-in <code class="literal">setTimeout()</code> function does. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">function poll() {
    if (++cnt &lt; max) {
        console.log('polling round ' + (cnt + 1));
        timer = _.delay(poll, interval);
    } else {
        clearTimeout(timer);
    }   
}   

var cnt = -1, 
    max = 5,
    interval = 3000,
    timer;

poll();
// →
// polling round 1
// polling round 2
// polling round 3
// polling round 4
// polling round 5 </pre></div><p>This code defines a <code class="literal">poll()</code> function<a id="id222" class="indexterm"/> that is used to periodically log which round of polling <a id="id223" class="indexterm"/>we're on. Polling is a common pattern <a id="id224" class="indexterm"/>used in frontends to synchronize data from the API, with what the user is looking at. We've set the <code class="literal">max</code> variable, which controls the number of polling iterations, to <code class="literal">5</code>. The <code class="literal">interval</code> variable is set to <code class="literal">3000</code> milliseconds. It controls the polling call frequency. You can see that the <code class="literal">poll()</code> function will first check whether we've already reached the maximum number of iterations or not. If not, the <code class="literal">timer</code> variable gets a timeout value—just an integer—by calling <code class="literal">delay()</code>. The <code class="literal">delay()</code> callback is <code class="literal">poll()</code>. If we've already reached our threshold, the timeout is cleared and there's no further poll scheduling.</p><p>If you look closely, you'll notice that there's no difference between using <code class="literal">delay()</code> and the built-in <code class="literal">setTimeout()</code> function. Both accept a callback function and duration as arguments, and both return a timeout number that can be cleared using <code class="literal">clearTimeout()</code>. What's interesting about <code class="literal">delay()</code> compared to <code class="literal">setTimeout()</code> is how they deal with arguments. Let's see how arguments are handled:</p><div class="informalexample"><pre class="programlisting">function sayHi(name, delay) {
    function sayHiImp(name) {
        console.log('Hi, ' + name);
    }   
    if (_.isUndefined(delay)) {
        _.delay(sayHiImp, 1, name);
    } else {
        _.delay(sayHiImp, delay, name);
    }   
}   

sayHi('Jan');
sayHi('Jim', 3000);
// →
// Hi, Jan
// Hi, Jim</pre></div><p>Here we've created a <code class="literal">sayHi()</code> function. This has a nested function within the called <code class="literal">sayHiImp()</code>function , which is the actual implementation. The <code class="literal">sayHi()</code> function is just a wrapper for <code class="literal">sayHiImp()</code>. It logs the given <code class="literal">name</code> parameter and checks whether the <code class="literal">delay</code> parameter was supplied or not; if not, it supplies a default <code class="literal">delay</code> value. It's important that our function either always runs synchronously or asynchronously, but never both. However, if there's a <code class="literal">delay</code> value, we use it with the <code class="literal">delay()</code> function to postpone the call to <code class="literal">sayHiImp()</code>. Notice that we pass the <code class="literal">name</code> parameter to the <code class="literal">delay()</code> call as well. Rather than having to construct our own partial function, we let <code class="literal">delay()</code> make one for us.</p></div><div class="section" title="Deferring function calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Deferring function calls</h2></div></div></div><p>Whenever JavaScript code is run<a id="id225" class="indexterm"/> in the browser, it kicks off what is known as a <a id="id226" class="indexterm"/>
<span class="strong"><strong>call stack</strong></span>. Most programming languages <a id="id227" class="indexterm"/>share the notion of a call stack. It can be thought of as a traceable graph of function calls, starting with the root call. What's interesting is that the JavaScript call stack and the DOM are two completely separate entities that share the same thread of control. The implication is that the DOM doesn't run while there's an active JavaScript call stack. This is why long-running JavaScript code locks up UI interactivity.</p><p>Using the <code class="literal">defer()</code> function is a workaround for scenarios where you have a function that could take a while (a while being a relative term here—2 seconds is a while). You can push the call to that function till after the call stack has cleared, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function expensive() {
    _.forEach(_.range(Math.pow(2, 25)), _.noop);
    console.log('done');
}   

_.defer(expensive);
console.log('computing...');
// →
// computing...
// done  </pre></div><p>The <code class="literal">expensive()</code> function does nothing but hog the CPU for a bit, preventing the <code class="literal">console.log()</code> call from running. So we use <code class="literal">defer()</code> to call <code class="literal">expensive()</code>, which waits till the current call stack has finished. The <code class="literal">'computing...'</code> string is logged as the last statement in the call stack. Shortly thereafter, the <code class="literal">'done'</code> string appears in the console log. The trick is that we're giving the DOM a chance to update before the expensive code runs.</p><p>An alternative approach to calling <code class="literal">defer()</code> every time you want to invoke something after the call stack has cleared is to create a wrapper function. You then call this wrapper as you would call any other function and it'll take care of deferring it for you. This is done using the following code:</p><div class="informalexample"><pre class="programlisting">function deferred(func) {
    return _.defer.apply(_, ([ func ])
        .concat(_.slice(arguments, 1)));
}   

function setTitle(title) {
    console.log('Title: "' + title + '"');
}   

function setState(app) {
    console.log('State: "' + app.state + '"');
}   

var title = _.wrap(setTitle, deferred),
    state = _.wrap(setState, deferred),
    app = { state: 'stopped' };

title('Home');
state(app);
app.state = 'started';
// →
// Title: "Home"
// State: "started"</pre></div><p>There are two<a id="id228" class="indexterm"/> functions here, <code class="literal">setTitle()</code> and <code class="literal">setState()</code>, both<a id="id229" class="indexterm"/> of which we'd like to be made deferrable. The first function takes a <code class="literal">title</code> argument and logs it. The second function takes an <code class="literal">app</code> object and logs the <code class="literal">state</code> property of that object. The <code class="literal">deferred()</code> function is a wrapper. We'll use it along with <code class="literal">wrap()</code> to make any function deferrable. All <code class="literal">deferred()</code> does is apply <code class="literal">defer()</code> to the function that was passed along with some arguments.</p><p>Next, you can see that the <code class="literal">title()</code> function is the deferred version of <code class="literal">setTitle()</code> while the <code class="literal">state()</code> function is the deferred version of <code class="literal">setState()</code>. We also have an <code class="literal">app</code> object with an initial state of <code class="literal">'stopped'</code>. Calling <code class="literal">title()</code> and <code class="literal">state()</code> will always be deferred to after the call stack clears. This point is further illustrated in the preceding code by setting the state to <code class="literal">started</code>, after the call to <code class="literal">state()</code>. You can guess which string is logged.</p></div><div class="section" title="Throttling function calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Throttling function calls</h2></div></div></div><p>Often, events in the DOM <a id="id230" class="indexterm"/>can trigger much more frequently than <a id="id231" class="indexterm"/>you're equipped to handle them. The simple act of moving the mouse pointer around has the potential to generate hundreds of events per second. If each of these events has a handler and that handler does anything meaningful, the UI will lag. There's simply no way to keep up, no matter how fast the processor is. The only way to keep up is to ignore the majority of these events and only responds at a certain frequency. The idea is illustrated in the following code:</p><div class="informalexample"><pre class="programlisting">var el = document.querySelector('#container'),
    onMouseMove = _.throttle(function(e) {
        console.log('X: ' + e.clientX + ' Y: ' + e.clientY);
    }, 750);

el.addEventListener('mousemove', onMouseMove);
window.addEventListener('hashchange', function cleanup() {
    el.removeEventListener('mousemove', onMouseMove);
    window.removeEventListener('mousemove', cleanup);
});</pre></div><p>The <code class="literal">el</code> variable is a DOM element that we want to listen to for <code class="literal">mousemove</code> events. The <code class="literal">onMouseMove</code> function is created by passing a function to <code class="literal">throttle()</code>. This callback simply logs the mouse coordinates. We also pass <code class="literal">750</code> to <code class="literal">throttle()</code> as the maximum frequency with this callback is allowed to run. Next, we bind the event and set up the cleanup actions to remove the listener when we're done with it. Had we not throttled <code class="literal">onMouseMove()</code>, you would see a noticeable difference in the <code class="literal">console.log()</code> verbosity.</p></div><div class="section" title="Debouncing function calls"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Debouncing function calls</h2></div></div></div><p><span class="strong"><strong>Debouncing</strong></span><a id="id232" class="indexterm"/> functions is<a id="id233" class="indexterm"/> similar to throttling<a id="id234" class="indexterm"/> them. The difference is in what happens when the wait duration has elapsed. With <code class="literal">throttle()</code>, the function is invariably called. For example, if the <code class="literal">wait</code> value was set to <code class="literal">10</code> milliseconds on a throttled function, and the function was called during those 10 milliseconds, it'll get called before the next wait. With <code class="literal">debounce()</code>, during the 10-millisecond wait, if the function was called, it'll wait an additional 10 milliseconds. Let's look at some debouncing code:</p><div class="informalexample"><pre class="programlisting">function log(msg, item) {
    console.log(msg + ' ' + item);
}

var debounced = _.debounce(_.partial(log, 'debounced'), 1),
    throttled = _.throttle(_.partial(log, 'throttled'), 1),
    size = 1500;

_.forEach(_.range(size), debounced);
_.forEach(_.range(size), throttled);</pre></div><p>We have a simple <code class="literal">log()</code> function that logs a message and an item number. We then proceed to build a <code class="literal">debounced()</code> and a <code class="literal">throttled()</code> version of the function. Then we run both through the same-sized loop. What's the difference? The output looks something like this:</p><div class="informalexample"><pre class="programlisting">throttled 0 
throttled 1
throttled 744 
debounced 1499
throttled 1499</pre></div><p>What happened here? We <a id="id235" class="indexterm"/>set the <code class="literal">wait</code> time to <code class="literal">1</code> millisecond for<a id="id236" class="indexterm"/> both <code class="literal">debounced()</code> and <code class="literal">throttled()</code>. In the time it took to process <code class="literal">1500</code> items, the wait period elapsed twice for the <code class="literal">throttled()</code> function. As soon as that happened, the <code class="literal">log()</code> function was called, hence the output. Notice that the <code class="literal">debounce()</code> output happened only after the processing was done. That's because <code class="literal">debounce()</code> was called many times during the 1-millisecond wait, and again during the next wait.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The <code class="literal">throttle()</code> function<a id="id237" class="indexterm"/> actually uses <code class="literal">debounce()</code> under the <a id="id238" class="indexterm"/>hood. All of the complexity is in <code class="literal">debounce()</code> and it accepts several configuration options. Among these are the <span class="strong"><strong>leading</strong></span> and <span class="strong"><strong>trailing</strong></span> edges of execution. What does this mean? You'll notice in the preceding output that the <code class="literal">throttled()</code> function is called after <code class="literal">debounce()</code>. That's the trailing edge of the wait period. The leading edge of the wait period is before the wait period starts. Both of these edges default to <code class="literal">true</code> for <code class="literal">throttle()</code>. This means that you're in an intense loop where your throttled function is being hammered, the function is called immediately, before waiting for the next call. Then, if the loop ends abruptly, the function is called again when the wait period ends.</p></div></div></div></div>
<div class="section" title="Composing and currying functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Composing and currying functions</h1></div></div></div><p>The last section of this chapter is<a id="id239" class="indexterm"/> about assembling functions that realize larger <a id="id240" class="indexterm"/>behavior out of smaller functions. There are two ways to assemble such functions. The first is to use the appropriately named <code class="literal">compose()</code> function, which performs a nested invocation of the provided functions, or where order is important, we can use the <code class="literal">flow()</code> function to return values together. Currying lets you adapt your function to be called successively in different contexts. Each of these Lo-Dash tools lets you take the existing functionality in your application and build on it in interesting ways.</p><div class="section" title="Composing functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Composing functions</h2></div></div></div><p>The <code class="literal">compose()</code> function<a id="id241" class="indexterm"/> builds a new function <a id="id242" class="indexterm"/>out of the provided functions. When we call this new function, a nested invocation of the supplied function starts, that is, the last supplied function is called with any additional arguments. The returned value is then fed to the next function and so on, ultimately producing a value for the caller. This is better explained in the following example:</p><div class="informalexample"><pre class="programlisting">function dough(pizza) {
    if (_.isUndefined(pizza)) {
        pizza = {};
    }   
    return _.extend({
        dough: true
    }, pizza);
}   

function sauce(pizza) {
    if (!pizza.dough) {
        throw new Error('Dough not ready');
    }   
    return _.extend({
        sauce: true
    }, pizza);
}   

function cheese(pizza) {
    if (!pizza.sauce) {
        throw new Error('Sauce not ready');
    }   
    return _.extend({
        cheese: true
    }, pizza);
}   

var pizza = _.compose(cheese, sauce, dough);

pizza();
// → { cheese: true, sauce: true, dough: true }</pre></div><p>There are three functions responsible for assembling pizza—<code class="literal">dough()</code>, <code class="literal">sauce()</code>, and <code class="literal">cheese()</code>. The job of each one of these functions is to set their corresponding attribute to <code class="literal">true</code> on the supplied <code class="literal">pizza</code> object. The <code class="literal">pizza()</code> function is composed using these functions which in turn use the <code class="literal">compose()</code> function. So calling <code class="literal">pizza()</code> will call <code class="literal">cheese(sauce(dough()))</code>. Note some of the checking that happens in these functions. For example, <code class="literal">dough()</code> will accept an object or construct a new one. However, the <code class="literal">sauce()</code> function won't work if there's no <code class="literal">dough</code> attribute. Likewise, <code class="literal">cheese()</code> complains if there's no <code class="literal">sauce</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>While being able to compose functions is handy, it's a good idea to have precondition checking. Then they fail fast, so other developers attempting to compose something out of your functions have an obvious indication if something isn't possible.</p></div></div><p>If the reverse order of the<a id="id243" class="indexterm"/> function invocation is confusing, don't worry. We can reverse the order using the <code class="literal">flow()</code> function. Using the same <code class="literal">pizza</code> functions, we could make a slight modification to the <code class="literal">pizza()</code> composition function:</p><div class="informalexample"><pre class="programlisting">var pizza = _.flow(dough, sauce, cheese);

return pizza();</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>The <code class="literal">compose()</code> function is actually an alias for the <code class="literal">flowRight()</code> function. The <code class="literal">flow()</code> and <code class="literal">flowRight()</code> functions are newer. In previous versions of Lo-Dash, the <code class="literal">compose()</code> function was standalone.</p></div></div></div><div class="section" title="Currying functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Currying functions</h2></div></div></div><p>Have you ever <a id="id244" class="indexterm"/>found yourself having to create a bunch of variables that do nothing aside from eventually getting passed to a function? Instead of variable creation, the currying technique lets you partially apply the function. That is, you call the function, supplying only the data you have at that moment. Curried functions will keep returning the function until it has all the arguments necessary. This technique is explained using the following example:</p><div class="informalexample"><pre class="programlisting">function makePizza(dough, sauce, cheese) {
    return {
        dough: dough,
        sauce: sauce,
        cheese: cheese
    };  
}   

function dough(pizza) {
    return pizza(true);
}   

function sauceAndCheese(pizza) {
    return pizza(true, true);
}   

var pizza = _.curry(makePizza);

sauceAndCheese(dough(pizza));
// → { cheese: true, sauce: true, dough: true }</pre></div><p>The <code class="literal">makePizza()</code> function<a id="id245" class="indexterm"/> has any arity of three—the number of arguments expected by the function. This means that the <code class="literal">pizza()</code> function created by calling <code class="literal">curry()</code> on <code class="literal">makePizza()</code> will keep returning the function until it's invoked with three arguments. We have the flexibility to pass these arguments however we want. This could be all three at once or it could be one at a time. This means that different contexts could pass data into the function, without the need to store them elsewhere.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>Hopefully after reading this chapter, your appreciation for functions in JavaScript went up a little. Lo-Dash just makes functional programming in the frontend that much better. Functions in JavaScript are flexible by default, changing the execution context for example. This chapter showed you how some Lo-Dash functions make working with function contexts much easier by removing much of the boiler-plate code that would otherwise be needed. Partials are fundamental to functional programming, but it's one of those tasks that's anything but easy in JavaScript. Lo-Dash makes it easy to create partials and to decorate functions by wrapping them with additional logic.</p><p>We looked at functions that help constrain when a function should run. For example, should a function be allowed to run only once? Should the return values be cached? Timing the execution of functions is a complex topic, especially when you consider the DOM and how it integrates with the JavaScript call stack. Lo-Dash has a number of functions that deal with managing the timed execution of functions. We looked at these in detail.</p><p>The chapter wrapped up with a look at how to compose larger pieces of functionality out of smaller functions. Currying functions let you define functions flexible enough to be invoked in a number of contexts, reducing the need to temporarily store arguments before they're passed. And on that note, we covered the Lo-Dash fundamentals. The concepts you've learned so far about collections, objects, and functions are applicable throughout the remainder of the book. We're now ready to move on to mapping and reducing values, a powerful technique that you'll utilize over and over again when programming with Lo-Dash.</p></div></body></html>