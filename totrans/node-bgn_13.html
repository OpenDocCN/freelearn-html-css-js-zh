<html><head></head><body>
		<div id="_idContainer094">
			<h1 id="_idParaDest-340" class="chapter-number"><a id="_idTextAnchor348"/>13</h1>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor349"/>User Authentication and Authorization with Passport.js</h1>
			<p>In this chapter, we will learn how authentication and authorization work in a modern web application. We will explore the cryptography behind many security mechanisms and will learn how to implement<a id="_idIndexMarker782"/> these concepts in our web applications using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWT</strong>). We will also see how we can extend our authentication strategies with third-party providers such as Facebook or Spotify <span class="No-Break">with Passport.js.</span></p>
			<p>At the end of this chapter, we will implement authentication and authorization in our web application project iterating over the code that we generated in the previous chapter. We will also learn how to specifically <span class="No-Break">test them.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How authentication and authorization work in a <span class="No-Break">web application</span></li>
				<li>How to use JWT to authenticate users in our <span class="No-Break">web application</span></li>
				<li>The cryptography basics that we need to know to understand modern authentication and <span class="No-Break">authorization mechanisms</span></li>
				<li>How Passport.js works and how to use it to implement authentication with third-party providers such as Facebook or Spotify in our <span class="No-Break">web application</span></li>
				<li>How to add authentication and authorization layers to any web project using JWT <span class="No-Break">and Express</span></li>
			</ul>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor350"/>Technical requirements</h1>
			<p>In order to follow this chapter, the following are <span class="No-Break">some recommendations:</span></p>
			<p>You should be familiar with the code that we generated in the previous chapter, as this is an iteration of the code that <span class="No-Break">we generated</span></p>
			<ul>
				<li>Node.js 20.11.0 installed on <span class="No-Break">your machine</span></li>
				<li>A code editor such as Visual <span class="No-Break">Studio Code</span></li>
				<li>Have Docker set up <span class="No-Break">and running</span></li>
				<li>A modern web browser such as Chrome <span class="No-Break">or Firefox</span></li>
			</ul>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/mdE5eXS5enM"><span class="No-Break">https://youtu.be/mdE5eXS5enM</span></a></p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor351"/>Understanding modern authentication and authorization</h1>
			<p><strong class="bold">Authentication</strong> and <strong class="bold">authorization</strong> are two different concepts that are often confused. Authentication involves confirming the identity of a user, whereas authorization involves verifying the specific access privileges they possess. In this chapter, we will explore how to implement both concepts in our web application in the <em class="italic">Adding authentication and authorization to our web </em><span class="No-Break"><em class="italic">application </em></span><span class="No-Break">section.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor352"/>Authentication</h2>
			<p>One of the big challenges<a id="_idIndexMarker783"/> of the HTTP protocol is that it is stateless. This means that the server does not keep any information about the client. Each request is independent, so we need to design and provide mechanisms that allow us to know who the user performing the request is. This is the main goal of the <span class="No-Break">authentication process.</span></p>
			<p>There are many ways to implement authentication in a web application. The most common way is to use a username and password, and there are many libraries that can help us to implement this mechanism as well as different approaches <span class="No-Break">to follow.</span></p>
			<p>We can delegate most of it to a third-party provider such as <em class="italic">Auth0</em> or we can implement <span class="No-Break">it ourselves.</span></p>
			<p>In this chapter, we will explore how to implement<a id="_idIndexMarker784"/> authentication in our web application using the <em class="italic">Passport.js library</em> and <em class="italic">JSON Web </em><span class="No-Break"><em class="italic">Tokens (JWT)</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor353"/>Authorization</h2>
			<p>We need to implement<a id="_idIndexMarker785"/> a clear way to determine whether a user is authorized to perform a certain action, such as creating a new post or deleting an old post. Even something as simple as accessing a certain page requires us to implement a way to determine whether the user is authorized to <span class="No-Break">access it.</span></p>
			<p>It is quite common that a lot of effort is put into the authentication part, but the authorization aspect gets forgotten about. Historically, web systems were less complex at the beginning of the internet and we didn’t have a lot of roles assigned to each user, so we tended to focus more on who you are rather than whether you should be able to do certain actions. Today, it is quite common to build complex systems that end up having access control tables that define the relationships between the actions and the roles. As an example, we can take as a reference the Role-based Authorization Strategy plugin for Jenkins, described in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em>. Using this, we can easily understand and update relationships between the roles and the potential activities to be performed. For example, the <strong class="bold">builder</strong> role can cancel jobs but not <span class="No-Break">configure them.</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B21678_13_1.jpg" alt="Figure 13.1 – Web browser screenshot from https://github.com/jenkinsci/role-strategy-plugin, available under the MIT license"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Web browser screenshot from <a href="https://github.com/jenkinsci/role-strategy-plugin">https://github.com/jenkinsci/role-strategy-plugin</a>, available under the MIT license</p>
			<p>Failing to properly consider authorization is a very common mistake that can lead to severe security issues. For example, if we forget to implement the authorization part, we can end up with a web application that allows any user to access any page, or to perform any action. This is a very dangerous situation that can lead to <span class="No-Break">security risks.</span></p>
			<p>We will explore this topic in practical terms in the <em class="italic">Adding authentication and authorization to our web application</em> section of this chapter, seeing how to implement an appropriate authorization strategy in our <span class="No-Break">web application.</span></p>
			<p>Now that we have a clear understanding <a id="_idIndexMarker786"/>of the differences between authentication and authorization, let’s explore how to implement them in our web application. In the next section, we will learn how we can use JWT to authenticate users in our <span class="No-Break">web application.</span></p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor354"/>JWT in a nutshell</h1>
			<p>One of the most popular ways to implement<a id="_idIndexMarker787"/> authentication in a web application is to <span class="No-Break">use JWT.</span></p>
			<p>So, let’s see <span class="No-Break">some definitions:</span></p>
			<p class="author-quote">JSON Web Token is a proposed internet standard for creating data with optional signature and/or optional encryption whose payload holds JSON that asserts some number of claims. The tokens are signed either using a private secret or a public/private key.</p>
			<p>(JSON Web <span class="No-Break">Token, </span><a href="https://en.wikipedia.org/wiki/JSON_Web_Token"><span class="No-Break">https://en.wikipedia.org/wiki/JSON_Web_Token</span></a><span class="No-Break">)</span></p>
			<p class="author-quote">JSON Web Tokens are an open, industry-standard RFC 7519 method for representing claims securely between two parties.</p>
			<p>(<span class="No-Break">JWT, </span><a href="https://jwt.io/"><span class="No-Break">https://jwt.io/</span></a><span class="No-Break">)</span></p>
			<p>So, basically, a <strong class="bold">JWT</strong> is a string (<em class="italic">JSON</em>) that contains information (<em class="italic">claims</em>) and is signed using a secret key. This process ensures that the information within the JWT remains secure and tamper-proof, allowing for verification during subsequent requests. Although this may seem like a straightforward concept, delving deeper reveals a multitude of intricacies and considerations that must be <span class="No-Break">understood first.</span></p>
			<p>Let’s list some of the most critical features that we expect to be supported to understand the <span class="No-Break">underlying complexity:</span></p>
			<ul>
				<li>Anyone can send a request<a id="_idIndexMarker788"/> to our server, so we cannot trust any request <span class="No-Break">by default.</span></li>
				<li>Anyone can try to manipulate the request, so we need to implement a mechanism that allows us to verify that the request has not <span class="No-Break">been manipulated.</span></li>
				<li>We need to implement a mechanism that allows us to verify the request without the need to store any information on the server. That way we can scale our application without any issues and can even use the same JWT across <span class="No-Break">multiple servers.</span></li>
			</ul>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor355"/>The process</h2>
			<p>In plain terms, the user<a id="_idIndexMarker789"/> will authenticate using a username and password, and then the server will return a JWT. The user will send the JWT in every request and the server will verify the JWT to authenticate <span class="No-Break">the user.</span></p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor356"/>The theory</h2>
			<p>The JWT is a string with information<a id="_idIndexMarker790"/> about the user (such as their name, role, etc.) and is signed using a secret key. So, the server can verify the JWT using the secret key and can then extract the information about the user. Any attempt to modify the JWT will invalidate the signature, so the server will reject <span class="No-Break">the request.</span></p>
			<p>So, in order to properly sign the tokens, first we need to understand the basics <span class="No-Break">of cryptography.</span></p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor357"/>Cryptography 101</h2>
			<p>To make the JWT work, we need to understand two things: hashing <span class="No-Break">and signing.</span></p>
			<h3>Hashing</h3>
			<p><strong class="bold">Hashing</strong> is a process that takes a string<a id="_idIndexMarker791"/> and returns a fixed-length<a id="_idIndexMarker792"/> string. This algorithm works as a one-way function, so we can hash a string, but we cannot get the original string from <span class="No-Break">the hash.</span></p>
			<p>Here is an example of hashing a string using the <strong class="source-inline">SHA256</strong> algorithm <span class="No-Break">in Node.js:</span></p>
			<pre class="source-code">
import crypto from 'crypto';
const hash = crypto.createHash('sha256');
hash.update('Hello World');
console.log(hash.digest('hex'));
// a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e</pre>			<p>We will use this<a id="_idIndexMarker793"/> algorithm to hash<a id="_idIndexMarker794"/> the password of the user later on in this chapter, in the <em class="italic">Adding authentication and authorization to our web </em><span class="No-Break"><em class="italic">application</em></span><span class="No-Break"> section.</span></p>
			<h3>Signing</h3>
			<p><strong class="bold">Signing</strong> is a process that takes<a id="_idIndexMarker795"/> a string and a secret<a id="_idIndexMarker796"/> key and returns a new string. This algorithm works as a two-way function, so we can sign a string and then we can verify the signature using the <span class="No-Break">secret key.</span></p>
			<h3>Wide use</h3>
			<p>This pattern of using hashing and signing<a id="_idIndexMarker797"/> is very common across many different software fields. As an example, when a new Node.js version is released, the Node.js team will publish the hash <a id="_idIndexMarker798"/>of every binary file. This allows us to download the binary file and then verify the hash of the file using the hash that the Node.js team published. If the hashes are the same, then we can be sure that the file has not <span class="No-Break">been modified.</span></p>
			<p>The hash file is signed prior to publishing it, so we can verify the signature using the public key of the Node.js team members. If the signature is valid, then we can be sure that the hash file has not <span class="No-Break">been modified.</span></p>
			<p>As an example, the following link is the  file shasum for Node v20.11.0 (<a href="https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc">https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc</a>). The following code block is the content of the file (redacted for space) to understand how <span class="No-Break">it works:</span></p>
			<pre class="console">
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
 f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f  node-v20.11.0-aix-ppc64.tar.gz
...
 dce7cd4b62a721d783ce961e9f70416ac63cf9cdc87b01f6be46540201333b1e  win-x86/node_pdb.zip
-----BEGIN PGP SIGNATURE-----
iQGzBAEBCA...aig9KO/s=
=B/OP
-----END PGP SIGNATURE-----</pre>			<p>As you can see, the file contains<a id="_idIndexMarker799"/> two parts (the message and the signature) and uses <strong class="bold">Pretty Good Privacy</strong> (<strong class="bold">PGP</strong>). The signature is the result of signing the hash produced from <strong class="source-inline">-----BEGIN PGP SIGNED MESSAGE-----</strong> to <strong class="source-inline">-----BEGIN PGP SIGNATURE-----</strong>. This helps us to verify the authenticity of the file – basically, we can verify that a Node.js releaser<a id="_idIndexMarker800"/> has created this file and the content<a id="_idIndexMarker801"/> has not been manipulated, even if the server from which the file was downloaded <span class="No-Break">was compromised.</span></p>
			<p>The message itself contains the hash of every binary file, so we can download the <strong class="source-inline">node-v20.11.0-aix-ppc64.tar.gz</strong> file and check that the content of the file is the same as the hash published in the message, <strong class="source-inline">f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f</strong>. If the hash is the same, then we can be sure that the file has not been modified. This allows us to distribute <span class="No-Break">information securely.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">With JWT, we will use a similar pattern, but instead of PGP, we will use a different algorithm to sign the content. You can find the list of supported algorithms in RFC <span class="No-Break">7518 (</span><a href="https://tools.ietf.org/html/rfc7518#section-3.1"><span class="No-Break">https://tools.ietf.org/html/rfc7518#section-3.1</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor358"/>JWT structure</h2>
			<p>JWT is a string that is composed of three<a id="_idIndexMarker802"/> parts separated by a dot. Each part is encoded in <em class="italic">base64</em>. The three parts are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Header</strong>: Contains information about the type of token and the algorithm used to sign <span class="No-Break">the token</span></li>
				<li><strong class="bold">Payload</strong>: Contains the claims (information) that we want to store in <span class="No-Break">the token</span></li>
				<li><strong class="bold">Signature</strong>: Contains the signature of the token that is used to verify <span class="No-Break">the token</span></li>
			</ul>
			<p>The signature is the result of signing the header and the payload using the secret key. The best part is that we can verify the signature using the secret key, so we can verify the token without needing to store any information on the server. Additionally, the information is encoded in base64, so anyone can decode it and read it, but we cannot <span class="No-Break">modify it.</span></p>
			<p>One important thing to mention is that you should never store sensitive information in the payload, as anyone can decode it and read it. This includes users’ passwords and bank account details, among other <span class="No-Break">sensitive information.</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor359"/>JWT.io</h2>
			<p>One of the best tools<a id="_idIndexMarker803"/> to work with JWT<a id="_idIndexMarker804"/> is the JWT Debugger (<a href="https://jwt.io/">https://jwt.io/</a>) (see <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.2</em>). This website allows us to encode and decode JWTs, as well as to verify the signature of the token. You can use it to play with or debug <span class="No-Break">your JWTs.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B21678_13_2.jpg" alt="Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded token</p>
			<p>Feel free to play with it and explore<a id="_idIndexMarker805"/> how it works before moving to the next section of <span class="No-Break">this chapter.</span></p>
			<p>In the next section, we will learn how Passport.js works and how it can be used to implement authentication with third-party providers such as Facebook or Spotify in our <span class="No-Break">web application.</span></p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor360"/>Understanding Passport.js fundamentals</h1>
			<p><strong class="bold">Passport.js</strong> is a fantastic library, widely used<a id="_idIndexMarker806"/> to implement authentication in Node.js applications. The official website of Passport.js defines the library <span class="No-Break">as follows:</span></p>
			<p class="author-quote">Passport is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based web application. A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more.</p>
			<p>(<span class="No-Break">Passport.js, </span><a href="http://www.passportjs.org/"><span class="No-Break">http://www.passportjs.org/</span></a><span class="No-Break">)</span></p>
			<p>In essence, Passport.js is a middleware (<a href="https://expressjs.com/en/guide/using-middleware.html">https://expressjs.com/en/guide/using-middleware.html</a>) that we will include<a id="_idIndexMarker807"/> in our Express application to provide many different strategies to implement authentication. Having a selection of such strategies allows us to choose the one that best fits our needs. We can use the library to easily implement social login functionality (such as Facebook, Twitter, Spotify, GitHub, and much more in more than 500 strategies) and the typical <span class="No-Break">username/password login.</span></p>
			<p>In the next section, we will iterate<a id="_idIndexMarker808"/> the code from our web application to include authentication and authorization mechanisms using what we have learned in this chapter <span class="No-Break">so far.</span></p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor361"/>Adding authentication and authorization to our web application</h1>
			<p>In this section, we will add<a id="_idIndexMarker809"/> authentication and authorization to our web application. We will use the jsonwebtoken library to implement the authentication part and will use a custom middleware to implement the <span class="No-Break">authorization part.</span></p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor362"/>Clone the base project</h2>
			<p>The authentication and authorization<a id="_idIndexMarker810"/> additions are not very complex, but it is quite long to follow with ease, so for this chapter you can download the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a>  and access the <strong class="source-inline">step4</strong> folder. The implementation is ready to go, but I will comment on the most relevant changes that we made since the last chapter (<strong class="source-inline">step3</strong> folder) so you can easily follow what <span class="No-Break">we’ve done.</span></p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor363"/>Setup</h2>
			<p>Our first steps are to<a id="_idIndexMarker811"/> explore the folder, install the dependencies, configure the environment, and start the infrastructure. This can be performed by running the <span class="No-Break">following commands:</span></p>
			<ol>
				<li>Install the dependencies with <span class="No-Break"><strong class="source-inline">npm i</strong></span><span class="No-Break">.</span></li>
				<li>Update the secrets, adding the <strong class="source-inline">.env</strong> file in the root folder with the <span class="No-Break">following content:</span><pre class="source-code">
MONGODB_URI=mongodb://localhost:27017/whispering-database
PORT=3000
SALT_ROUNDS=10
JWT_SECRET=Tu1fo3mO0PcAvjq^q3wQ24BXNI8$9R
Run <strong class="source-inline">npm run infra:stop &amp;&amp; npm run infra:start</strong>.</pre></li>				<li>Run <strong class="source-inline">npm run infra:stop &amp;&amp; npm </strong><span class="No-Break"><strong class="source-inline">run infra:start</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Now, the infrastructure and configuration are ready, but before we start making more changes to the application, it is recommended to run <span class="No-Break">some tests.</span></p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor364"/>Run the tests</h2>
			<p>Next, we need to run<a id="_idIndexMarker812"/> some tests<a id="_idIndexMarker813"/> to ensure that the code is working as expected by typing  <strong class="source-inline">npm run test</strong> in <span class="No-Break">our terminal.</span></p>
			<h3>New tests added</h3>
			<p>We can see that we have a few new routes <a id="_idIndexMarker814"/>related to login/signup and specific tests for them. When we execute the tests, we will see that the test messages (descriptions) are clear and self-explanatory in terms of what the routes are expected to do and what we aim to do with the test, even if we are not yet familiar with <span class="No-Break">the code:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B21678_13_3.jpg" alt="Figure 13.3 – Terminal screenshot that showcases how the routes are tested"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Terminal screenshot that showcases how the routes are tested</p>
			<p>We should recognize these tests<a id="_idIndexMarker815"/> as we worked on these routes in the previous chapters. But if we keep scrolling through the test output, we should see that new tests have been added <span class="No-Break">as well.</span></p>
			<h3>Updated tests</h3>
			<p>The previous tests have been<a id="_idIndexMarker816"/> updated to include new test cases related to authentication for the routes that require authentication <span class="No-Break">with JWT:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B21678_13_4.jpg" alt="Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to follow what is being tested with the descriptions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to follow what is being tested with the descriptions</p>
			<p>As you can see, the use cases<a id="_idIndexMarker817"/> in the tests cover more scenarios related to authentication and authorization, such as <strong class="source-inline">Should return 401 when the user is not authenticated</strong> and <strong class="source-inline">Should return a 403 when the user is not </strong><span class="No-Break"><strong class="source-inline">the author</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor365"/>The UI changes</h2>
			<p>But overall, the most significant changes<a id="_idIndexMarker818"/> are related<a id="_idIndexMarker819"/> to the UI, as now we have new routes and views to login/register and so on. So we can start the application by running <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run start</strong></span></p>
			<h3>Login</h3>
			<p>You can enter your credentials<a id="_idIndexMarker820"/> to log in at <strong class="source-inline">http://localhost:3000/login</strong>, upon which the backend API will return a JWT that you can use to authenticate for any <span class="No-Break">CRUD operation.</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B21678_13_5.jpg" alt="Figure 13.5 – Web browser screenshot showing the login page where the user can enter their username and password"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Web browser screenshot showing the login page where the user can enter their username and password</p>
			<h3>Register</h3>
			<p>You can create a new account <a id="_idIndexMarker821"/>whenever you please at <strong class="source-inline">http://localhost:3000/signup</strong>. This operation will generate a new user in the database and the backend will return you a JWT that you can use to perform CRUD operations and authenticate yourself against <span class="No-Break">the API.</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B21678_13_6.jpg" alt="Figure 13.6 – Web browser screenshot showing where the user can create a new account or log in with existing credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Web browser screenshot showing where the user can create a new account or log in with existing credentials</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The server has defined certain rules regarding username, email and password. So, as an example you can use the <span class="No-Break">following values:</span></p>
			<ul>
				<li><span class="No-Break">Username: </span><span class="No-Break"><strong class="source-inline">nodejs</strong></span></li>
				<li><span class="No-Break">Email: </span><span class="No-Break"><strong class="source-inline">demo@demo.com</strong></span></li>
				<li><span class="No-Break">Password: </span><span class="No-Break"><strong class="source-inline">aA1#dt$tu</strong></span></li>
			</ul>
			<h3>CRUD operations</h3>
			<p>As remarked on in the previous<a id="_idIndexMarker822"/> section, it is important to understand how authorization works. So, here are the rules for our <span class="No-Break">business logic:</span></p>
			<ul>
				<li>Any logged user can see all the whispers available on the <span class="No-Break">Whispering platform</span></li>
				<li>You can modify or delete only the whispers that you <span class="No-Break">have created</span></li>
			</ul>
			<p>These clear rules will help us to build an authorization system that will cover all the scenarios, so, for example, you won’t be able to delete a whisper created by another user. In some applications, this approach can be very complex, such as with Google Drive or Facebook. In those scenarios, it is quite useful to have a permission matrix in place and well documented. GitLab offers a great <span class="No-Break">example (</span><a href="https://docs.gitlab.com/ee/user/permissions.html"><span class="No-Break">https://docs.gitlab.com/ee/user/permissions.html</span></a><span class="No-Break">)</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B21678_13_7.jpg" alt="Figure 13.7 – Web browser screenshot showing the main page with all the whispers and the buttons to interact with them from the UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Web browser screenshot showing the main page with all the whispers and the buttons to interact with them from the UI</p>
			<p>As you can see, we can modify only the whispers that we created but the option is not visually available for <span class="No-Break">other whispers.</span></p>
			<p>While the UI is a key factor<a id="_idIndexMarker823"/> in managing authorization, we need to ensure that the backend is also properly managing authorization on its part, so it won’t allow the users to modify or delete whispers from other users. To ensure that the application is capable of preventing these scenarios (like modify other’s users whispers) it is highly recommended to add specify test case. Check the test suite cases, as we have already included these scenarios that cover the <strong class="source-inline">403 </strong><span class="No-Break"><strong class="source-inline">Forbidden</strong></span><span class="No-Break"> response.</span></p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor366"/>Added dependencies</h2>
			<p>We have included <a id="_idIndexMarker824"/>the <span class="No-Break">following dependencies:</span></p>
			<ul>
				<li><strong class="bold">Bcrypt</strong> (<a href="https://www.npmjs.com/package/bcrypt">https://www.npmjs.com/package/bcrypt</a>): This is a library that will help<a id="_idIndexMarker825"/> us to store passwords<a id="_idIndexMarker826"/> safely in <span class="No-Break">the database.</span></li>
				<li><strong class="bold">Jsonwebtoken</strong> (<a href="https://www.npmjs.com/package/jsonwebtoken">https://www.npmjs.com/package/jsonwebtoken</a>): This is a utility that<a id="_idIndexMarker827"/> helps us to generate<a id="_idIndexMarker828"/> and parse <span class="No-Break">the JWTs.</span></li>
				<li><strong class="bold">Validator</strong> (<a href="https://www.npmjs.com/package/validator">https://www.npmjs.com/package/validator</a>): This is a library that we use to validate<a id="_idIndexMarker829"/> strings. Basically, we can<a id="_idIndexMarker830"/> use it to sanitize the inputs received from the users, including email addresses, URLs, phone numbers, and <span class="No-Break">so on.</span></li>
			</ul>
			<p>These dependencies will be used later in order to properly build our application. It is quite common in Node.js projects to rely on third-party libraries. The most important thing to remember is to be sure that we are using good-quality external dependencies without known vulnerabilities, as we learned in <a href="B21678_06.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break"><em class="italic">.</em></span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor367"/>Changes in the frontend</h2>
			<p>We added a new file<a id="_idIndexMarker831"/> called <strong class="source-inline">public/auth.js</strong> to manage the form submissions while the user logs in or registers with the platform. After sending the requests, we will store the JWT in the local storage, so we can recover the JWT easily even if we refresh <span class="No-Break">the page:</span></p>
			<pre class="source-code">
fetch('/login', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        username,
        password
    })
})
.then(response =&gt; {
    if(response.status !== 200) {
        throw new Error("Invalid credentials")
    }
    return response.json()
})
.then(({accessToken}) =&gt; {
    localStorage.setItem('accessToken', accessToken);
    window.location.href = '/';
})</pre>			<p>With the previous changes, we now<a id="_idIndexMarker832"/> send the user and password to the <strong class="source-inline">/login</strong> route using the <strong class="source-inline">POST</strong> HTTP method. As a response, we expect JSON data that will contain the access token that we will store in the local storage in order to keep session persistence in case the user refreshes the page. Finally, we will redirect the user to the home page as the authentication has been <span class="No-Break">completed successfully.</span></p>
			<p>We also added the JWT to every request made against the API for any CRUD operation <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">public/app.js</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const fetchAllWhispers = () =&gt; fetch('http://localhost:3000/api/v1/whisper', {
    headers: {Authentication: `Bearer ${accessToken}`}
}).then((response) =&gt; response.json())</pre>			<p>As you can see, every request includes the <strong class="source-inline">Authentication</strong> header with the <strong class="source-inline">Bearer TOKEN</strong> value, which is the expected way to authenticate against the backend. We also use the JWT to get the user’s name and display it in the UI in the <span class="No-Break">Whispers view.</span></p>
			<p>Also, we disabled the edit/delete buttons<a id="_idIndexMarker833"/> from the Whisper view if the current user is not the user that <span class="No-Break">created them:</span></p>
			<pre class="source-code">
`&lt;article data-id="${whisper.id}"&gt;
    &lt;div class="actions" ${controlEdition(whisper, user)}&gt;
        &lt;button data-action="edit"&gt;<img src="image/01.png" alt="" role="presentation"/>&lt;/button&gt;
        &lt;button data-action="delete"&gt;<img src="image/02.png" alt="" role="presentation"/>&lt;/button&gt;
    &lt;/div&gt;
&lt;/article&gt;`</pre>			<p>The <strong class="source-inline">controlEdition</strong> function can hide/show the actions depending on <span class="No-Break">the author:</span></p>
			<pre class="source-code">
const controlEdition = (whisper, user) =&gt; {
    if(whisper.author.id === user.id) {
        return ''
    } else {
        return 'style="display:none;"'
    }
}</pre>			<p>Now that we are clear on the changes<a id="_idIndexMarker834"/> made in the frontend part, it is time to jump to the backend part and review the changes needed in order to properly manage the users’ authentication data in the databases. We’ll start with the changes in <span class="No-Break">the stores.</span></p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor368"/>Added a new store for users</h2>
			<p>The most relevant changes<a id="_idIndexMarker835"/> were added to the <strong class="source-inline">database.js</strong> file, where a new schema was added for the users. We now include more advanced validations and transformations. The user has <strong class="source-inline">username</strong>, <strong class="source-inline">email</strong>, and <span class="No-Break"><strong class="source-inline">password</strong></span><span class="No-Break"> properties:</span></p>
			<pre class="source-code">
const userSchema = new mongoose.Schema({
  //...
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters long'],
    validate: {
      validator: checkPasswordStrength
    }
  }
  //...
})</pre>			<p>In the case of <strong class="source-inline">password</strong>, we include an additional validation with a new function that we added to the utilities file, <strong class="source-inline">utils.js</strong>. This new function uses a regular expression to validate the password strength (a minimum of eight characters, at least one letter, one number, and one <span class="No-Break">special character):</span></p>
			<pre class="source-code">
export function checkPasswordStrength(password) {
   const strengthRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&amp;])[A-Za-z\d@$!%*#?&amp;]{8,}$/
   return strengthRegex.test(password)
}</pre>			<p>Now, the <strong class="source-inline">whisperSchema</strong> schema<a id="_idIndexMarker836"/> has a relation with <strong class="source-inline">User</strong>, as each whisper is owned by a <span class="No-Break">specific author:</span></p>
			<pre class="source-code">
const whisperSchema = new mongoose.Schema({
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  message: String,
  updatedDate: {
    type: Date,
    default: Date.now
  },
  creationDate: {
    type: Date,
    default: Date.now
  }
})</pre>			<p>We can see how this relationship takes place in <strong class="source-inline">stores/whisper.js</strong>, as we can populate <span class="No-Break">the queries:</span></p>
			<pre class="source-code">
const getAll = () =&gt; Whisper.find().populate('author', 'username')
const getById = id =&gt; Whisper.findById({ _id: id }).populate('author', 'username')
const create = async (message, authorId ) =&gt; {
  const whisper = new Whisper({ message, author: authorId })
  await whisper.save()
  return whisper
}</pre>			<h3>Password management</h3>
			<p>As part of proper password management<a id="_idIndexMarker837"/> in the <strong class="source-inline">database.js</strong>, we will use the <strong class="source-inline">bcrypt</strong> library, specifically the <strong class="source-inline">pre</strong> middleware, to hash passwords before storing them in the database. The <strong class="source-inline">pre</strong> middleware is a function that is triggered before we perform a specific action such as a save. You can find<a id="_idIndexMarker838"/> great examples in the official <span class="No-Break">documentation (</span><a href="https://mongoosejs.com/docs/middleware.html#pre"><span class="No-Break">https://mongoosejs.com/docs/middleware.html#pre</span></a><span class="No-Break">):</span></p>
			<pre class="source-code">
userSchema.pre('save', async function (next) {
  const user = this
  if (user.isModified('password')) {
    const salt = await bcrypt.genSalt()
    user.password = await bcrypt.hash(user.password, salt)
  }
  next()
})</pre>			<p>Also, in the same <strong class="source-inline">database.js</strong> file, we will add a new function to compare the saved password of the user with the password that the user is sending in <span class="No-Break">the request:</span></p>
			<pre class="source-code">
userSchema.methods.comparePassword = async function (candidatePassword) {
  const user = this
  return await bcrypt.compare(candidatePassword, user.password)
}</pre>			<p>That way we can store and compare<a id="_idIndexMarker839"/> the password securely, never storing it in <span class="No-Break">plain text.</span></p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor369"/>JWT utilities</h2>
			<p>Our authentication is now done with <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>), so we need to add some utilities<a id="_idIndexMarker840"/> to generate and parse the JWTs. We will use the <strong class="source-inline">jsonwebtoken</strong> library for <span class="No-Break">this purpose.</span></p>
			<p>In the <strong class="source-inline">utils.js</strong> file, we add one function to generate <span class="No-Break">the JWT:</span></p>
			<pre class="source-code">
export function generateToken (data) {
   return jwt.sign({
      data: data
    }, process.env.JWT_SECRET, { expiresIn: '1h' })
}</pre>			<p>We also add another function to parse the JWT; in our case, an Express middleware that will parse the JWT and add the user to <span class="No-Break">the request:</span></p>
			<pre class="source-code">
export function requireAuthentication (req, res, next) {
   const token = req.headers.authentication
   if (!token) {
      res.status(401).json({ error: 'No token provided' })
      return
   }
   try {
      const accessToken = token.split(' ')[1]
      const decoded = jwt.verify(accessToken, process.env.JWT_SECRET)
      req.user = decoded.data
      next()
   } catch (err) {
      res.status(401).json({ error: 'Invalid token' })
   }
}</pre>			<p>As you can see, we use the <strong class="source-inline">JWT_SECRET</strong> to sign and verify the JWTs. This environmental variable is stored in the <strong class="source-inline">.env</strong> file, so we can change it easily in any environment. Also, we set an expiration time of 1 hour for the JWTs, after which time the user will need to authenticate again. It is quite common to have short expiration times so that if the token did get compromised, the time in which it could be used to do harm is limited. This is a very popular secure measurement<a id="_idIndexMarker841"/> that can be combined with refresh tokens (<a href="https://auth0.com/learn/refresh-tokens">https://auth0.com/learn/refresh-tokens</a>) to have an even more <span class="No-Break">solid implementation.</span></p>
			<p>If the token has been modified or the secret is not the same, then the <strong class="source-inline">jwt.verify</strong> function will throw an error, so we can catch it and return an error to the user. The same will happen if the token <span class="No-Break">is expired.</span></p>
			<p>If the token is valid, then we will add the user to the request, so we can use it in the next middleware or in the <span class="No-Break">route handler.</span></p>
			<p>This completes the authentication<a id="_idIndexMarker842"/> part – we can now authenticate the users in our web application! It is important to note that we are not storing any information on the server so we can scale our application without any issues, but there are some drawbacks to this, as we will explore in <a href="B21678_15.xhtml#_idTextAnchor394"><span class="No-Break"><em class="italic">Chapter 15</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor370"/>Adding new routes</h2>
			<p>Now we have all the utilities<a id="_idIndexMarker843"/> to implement the authentication, so we can include the new routes. In our case, we will include the <span class="No-Break">following routes:</span></p>
			<ul>
				<li><strong class="source-inline">GET /login</strong> to render the login view to <span class="No-Break">the user:</span><pre class="source-code">
app.get('/login', (req, res) =&gt; {
  res.render('login')
})</pre></li>				<li><strong class="source-inline">POST /login</strong> to process the login request, store the new user, and return <span class="No-Break">the JWT:</span><pre class="source-code">
app.post('/login', async (req, res) =&gt; {
  try {
    const { username, password } = req.body
    const foundUser = await user.getUserByCredentials(username, password)
    const accessToken = generateToken({ username, id: foundUser._id})
    res.json({ accessToken})
  } catch ( err ){
    res.status(400).json({ error: err.message })
  }
})</pre></li>				<li><strong class="source-inline">GET /signup</strong> to render the signup view to <span class="No-Break">the user:</span><pre class="source-code">
app.get('/signup', (req, res) =&gt; {
  res.render('signup')
})</pre></li>				<li><strong class="source-inline">POST /signup</strong> to process the signup<a id="_idIndexMarker844"/> request and return <span class="No-Break">the JWT:</span><pre class="source-code">
app.post('/signup', async (req, res) =&gt; {
  try {
    const { username, password, email } = req.body
    const newUser = await user.create(username, password, email)
    const accessToken = generateToken({ username, id: newUser._id})
    res.json({ accessToken})
  } catch ( err ){
    res.status(400).json({ error: err.message })
  }
})</pre></li>				<li>Then, we also need to update<a id="_idIndexMarker845"/> the routes that require authentication to use <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">require</strong></span><strong class="source-inline">
Authentication</strong> middleware and modify the internal logic to ensure that the authorizations are properly managed. For example, users shouldn’t be able to modify/delete whispers from <span class="No-Break">other users:</span><pre class="source-code">
app.put('/api/v1/whisper/:id', requireAuthentication, async (req, res) =&gt; {
  const { message } = req.body
  const id = req.params.id
  if (!message) {
    res.sendStatus(400)
    return
  }
  const storedWhisper = await whisper.getById(id)
  if (!storedWhisper) {
    res.sendStatus(404)
    return
  }
  if(storedWhisper.author.id !== req.user.id) {
    res.sendStatus(403)
    return
  }
  await whisper.updateById(id, message)
  res.sendStatus(200)
})</pre></li>			</ul>
			<p>As you can see, we use the <strong class="source-inline">requireAuthentication</strong> middleware to ensure that the user is authenticated, and then we check that the user is the author of the whisper that we are trying to modify. If the user is not the author, then we return a <strong class="source-inline">403 </strong><span class="No-Break"><strong class="source-inline">Forbidden</strong></span><span class="No-Break"> error.</span></p>
			<p>There are other scenarios<a id="_idIndexMarker846"/> that we also covered in the tests such as when the whisper is not found.In those cases is expected that we to return the proper HTTP error code in <span class="No-Break">each case.</span></p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor371"/>Improved testing utilities</h2>
			<p>We modified the testing utilities<a id="_idIndexMarker847"/> to include valid fixtures for the users, so we have predefined users that we can use to test the <span class="No-Break">authentication functionality.</span></p>
			<p>Also, we included sample whispers for the tests, so we can use them to test the <span class="No-Break">authorization part.</span></p>
			<p>And finally, we included some fixtures that include a valid JWT for each user, so we can use them to test the <span class="No-Break">authorization part.</span></p>
			<p>You can check the changes in detail in the <span class="No-Break"><strong class="source-inline">tests/utils.js</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor372"/>Test case changes</h2>
			<p>Regarding the test cases, we updated<a id="_idIndexMarker848"/> them to include the new routes and to test the authorization part. You can check the changes in detail in the <span class="No-Break"><strong class="source-inline">tests/server.test.js</strong></span><span class="No-Break"> file.</span></p>
			<p>In general, most of the routes now include specific test cases to test the authorization part, ensuring that the authorization is <span class="No-Break">properly managed.</span></p>
			<p>We added test cases for each route to test requests from users that are <span class="No-Break">not authenticated:</span></p>
			<pre class="source-code">
it('Should return a 401 when the user is not authenticated', async () =&gt; {
  const response = await supertest(app)
  .delete(`/api/v1/whisper/${existingId}`)
  expect(response.status).toBe(401)
  expect(response.body.error).toBe('No token provided')
})</pre>			<p>Also, in some routes, we added test cases to test the authorization part, so we can ensure that the authorization is <span class="No-Break">properly managed:</span></p>
			<pre class="source-code">
it('Should return a 403 when the user is not the author', async () =&gt; {
  const response = await supertest(app)
  .delete(`/api/v1/whisper/${existingId}`)
  .set('Authentication', `Bearer ${secondUser.token}`)
  expect(response.status).toBe(403)
})</pre>			<p>Overall, many tests were modified<a id="_idIndexMarker849"/> to include the JWT with a specific Bearer token, in the form of <strong class="source-inline">.set('Authentication', `</strong><span class="No-Break"><strong class="source-inline">Bearer ${firstUser.token}`)</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor373"/>Test coverage</h2>
			<p>If we run the tests<a id="_idIndexMarker850"/> with <strong class="source-inline">npm run test:coverage</strong>, we can see in detail how the changes affected the test coverage. If you check the <strong class="source-inline">coverage/lcov-report/index.html</strong> file, you can see the details of <span class="No-Break">the coverage:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B21678_13_8.jpg" alt="Figure 13.8 – Web browser screenshot with the test coverage report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Web browser screenshot with the test coverage report</p>
			<p>Overall, the coverage is quite<a id="_idIndexMarker851"/> good (between 94-98%), but we can see that we have some lines that are not covered. We could improve the tests to cover them, but those are <span class="No-Break">edge cases.</span></p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor374"/>Summary</h1>
			<p>In this chapter, we had the opportunity to learn how authentication and authorization work in a web application. We implemented the authentication part using JWT and the authorization part using a <span class="No-Break">custom middleware.</span></p>
			<p>Additionally, we explored in detail how JWTs work and how to implement them in a <span class="No-Break">Node.js application.</span></p>
			<p>Finally, we added authentication and authorization functionalities to our web application, so we can now authenticate users and we can ensure that the users can only modify/delete the whispers that <span class="No-Break">they created.</span></p>
			<p>In the next chapter, we are going to learn in more detail how to properly manage errors in our web application and in any Node.js application <span class="No-Break">or library.</span></p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor375"/>Further reading</h1>
			<ul>
				<li><em class="italic">Session vs Token Authentication in 100 </em><span class="No-Break"><em class="italic">Seconds</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=UBUNrFtufWo"><span class="No-Break">https://www.youtube.com/watch?v=UBUNrFtufWo</span></a></li>
				<li><em class="italic">Authentication: It’s Easier Than You </em><span class="No-Break"><em class="italic">Think</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=h6wBYWWdyYQ"><span class="No-Break">https://www.youtube.com/watch?v=h6wBYWWdyYQ</span></a></li>
				<li><em class="italic">JWT Handbook by </em><span class="No-Break"><em class="italic">Auth0</em></span><span class="No-Break">: </span><a href="https://auth0.com/resources/ebooks/jwt-handbook"><span class="No-Break">https://auth0.com/resources/ebooks/jwt-handbook</span></a></li>
				<li><em class="italic">Auth0 in 100 Seconds // And beyond with a Next.js Authentication </em><span class="No-Break"><em class="italic">Tutorial</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=yufqeJLP1rI"><span class="No-Break">https://www.youtube.com/watch?v=yufqeJLP1rI</span></a></li>
			</ul>
		</div>
	</body></html>