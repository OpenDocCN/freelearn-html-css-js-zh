<html><head></head><body>
		<div><h1 id="_idParaDest-340" class="chapter-number"><a id="_idTextAnchor348"/>13</h1>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor349"/>User Authentication and Authorization with Passport.js</h1>
			<p>In this chapter, we will learn how authentication and authorization work in a modern web application. We will explore the cryptography behind many security mechanisms and will learn how to implement<a id="_idIndexMarker782"/> these concepts in our web applications using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWT</strong>). We will also see how we can extend our authentication strategies with third-party providers such as Facebook or Spotify with Passport.js.</p>
			<p>At the end of this chapter, we will implement authentication and authorization in our web application project iterating over the code that we generated in the previous chapter. We will also learn how to specifically test them.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>How authentication and authorization work in a web application</li>
				<li>How to use JWT to authenticate users in our web application</li>
				<li>The cryptography basics that we need to know to understand modern authentication and authorization mechanisms</li>
				<li>How Passport.js works and how to use it to implement authentication with third-party providers such as Facebook or Spotify in our web application</li>
				<li>How to add authentication and authorization layers to any web project using JWT and Express</li>
			</ul>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor350"/>Technical requirements</h1>
			<p>In order to follow this chapter, the following are some recommendations:</p>
			<p>You should be familiar with the code that we generated in the previous chapter, as this is an iteration of the code that we generated</p>
			<ul>
				<li>Node.js 20.11.0 installed on your machine</li>
				<li>A code editor such as Visual Studio Code</li>
				<li>Have Docker set up and running</li>
				<li>A modern web browser such as Chrome or Firefox</li>
			</ul>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a></p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/mdE5eXS5enM">https://youtu.be/mdE5eXS5enM</a></p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor351"/>Understanding modern authentication and authorization</h1>
			<p><strong class="bold">Authentication</strong> and <strong class="bold">authorization</strong> are two different concepts that are often confused. Authentication involves confirming the identity of a user, whereas authorization involves verifying the specific access privileges they possess. In this chapter, we will explore how to implement both concepts in our web application in the <em class="italic">Adding authentication and authorization to our web </em><em class="italic">application </em>section.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor352"/>Authentication</h2>
			<p>One of the big challenges<a id="_idIndexMarker783"/> of the HTTP protocol is that it is stateless. This means that the server does not keep any information about the client. Each request is independent, so we need to design and provide mechanisms that allow us to know who the user performing the request is. This is the main goal of the authentication process.</p>
			<p>There are many ways to implement authentication in a web application. The most common way is to use a username and password, and there are many libraries that can help us to implement this mechanism as well as different approaches to follow.</p>
			<p>We can delegate most of it to a third-party provider such as <em class="italic">Auth0</em> or we can implement it ourselves.</p>
			<p>In this chapter, we will explore how to implement<a id="_idIndexMarker784"/> authentication in our web application using the <em class="italic">Passport.js library</em> and <em class="italic">JSON Web </em><em class="italic">Tokens (JWT)</em>.</p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor353"/>Authorization</h2>
			<p>We need to implement<a id="_idIndexMarker785"/> a clear way to determine whether a user is authorized to perform a certain action, such as creating a new post or deleting an old post. Even something as simple as accessing a certain page requires us to implement a way to determine whether the user is authorized to access it.</p>
			<p>It is quite common that a lot of effort is put into the authentication part, but the authorization aspect gets forgotten about. Historically, web systems were less complex at the beginning of the internet and we didn’t have a lot of roles assigned to each user, so we tended to focus more on who you are rather than whether you should be able to do certain actions. Today, it is quite common to build complex systems that end up having access control tables that define the relationships between the actions and the roles. As an example, we can take as a reference the Role-based Authorization Strategy plugin for Jenkins, described in <em class="italic">Figure 13</em><em class="italic">.1</em>. Using this, we can easily understand and update relationships between the roles and the potential activities to be performed. For example, the <strong class="bold">builder</strong> role can cancel jobs but not configure them.</p>
			<div><div><img src="img/B21678_13_1.jpg" alt="Figure 13.1 – Web browser screenshot from https://github.com/jenkinsci/role-strategy-plugin, available under the MIT license"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Web browser screenshot from <a href="https://github.com/jenkinsci/role-strategy-plugin">https://github.com/jenkinsci/role-strategy-plugin</a>, available under the MIT license</p>
			<p>Failing to properly consider authorization is a very common mistake that can lead to severe security issues. For example, if we forget to implement the authorization part, we can end up with a web application that allows any user to access any page, or to perform any action. This is a very dangerous situation that can lead to security risks.</p>
			<p>We will explore this topic in practical terms in the <em class="italic">Adding authentication and authorization to our web application</em> section of this chapter, seeing how to implement an appropriate authorization strategy in our web application.</p>
			<p>Now that we have a clear understanding <a id="_idIndexMarker786"/>of the differences between authentication and authorization, let’s explore how to implement them in our web application. In the next section, we will learn how we can use JWT to authenticate users in our web application.</p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor354"/>JWT in a nutshell</h1>
			<p>One of the most popular ways to implement<a id="_idIndexMarker787"/> authentication in a web application is to use JWT.</p>
			<p>So, let’s see some definitions:</p>
			<p class="author-quote">JSON Web Token is a proposed internet standard for creating data with optional signature and/or optional encryption whose payload holds JSON that asserts some number of claims. The tokens are signed either using a private secret or a public/private key.</p>
			<p>(JSON Web Token, <a href="https://en.wikipedia.org/wiki/JSON_Web_Token">https://en.wikipedia.org/wiki/JSON_Web_Token</a>)</p>
			<p class="author-quote">JSON Web Tokens are an open, industry-standard RFC 7519 method for representing claims securely between two parties.</p>
			<p>(JWT, <a href="https://jwt.io/">https://jwt.io/</a>)</p>
			<p>So, basically, a <strong class="bold">JWT</strong> is a string (<em class="italic">JSON</em>) that contains information (<em class="italic">claims</em>) and is signed using a secret key. This process ensures that the information within the JWT remains secure and tamper-proof, allowing for verification during subsequent requests. Although this may seem like a straightforward concept, delving deeper reveals a multitude of intricacies and considerations that must be understood first.</p>
			<p>Let’s list some of the most critical features that we expect to be supported to understand the underlying complexity:</p>
			<ul>
				<li>Anyone can send a request<a id="_idIndexMarker788"/> to our server, so we cannot trust any request by default.</li>
				<li>Anyone can try to manipulate the request, so we need to implement a mechanism that allows us to verify that the request has not been manipulated.</li>
				<li>We need to implement a mechanism that allows us to verify the request without the need to store any information on the server. That way we can scale our application without any issues and can even use the same JWT across multiple servers.</li>
			</ul>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor355"/>The process</h2>
			<p>In plain terms, the user<a id="_idIndexMarker789"/> will authenticate using a username and password, and then the server will return a JWT. The user will send the JWT in every request and the server will verify the JWT to authenticate the user.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor356"/>The theory</h2>
			<p>The JWT is a string with information<a id="_idIndexMarker790"/> about the user (such as their name, role, etc.) and is signed using a secret key. So, the server can verify the JWT using the secret key and can then extract the information about the user. Any attempt to modify the JWT will invalidate the signature, so the server will reject the request.</p>
			<p>So, in order to properly sign the tokens, first we need to understand the basics of cryptography.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor357"/>Cryptography 101</h2>
			<p>To make the JWT work, we need to understand two things: hashing and signing.</p>
			<h3>Hashing</h3>
			<p><strong class="bold">Hashing</strong> is a process that takes a string<a id="_idIndexMarker791"/> and returns a fixed-length<a id="_idIndexMarker792"/> string. This algorithm works as a one-way function, so we can hash a string, but we cannot get the original string from the hash.</p>
			<p>Here is an example of hashing a string using the <code>SHA256</code> algorithm in Node.js:</p>
			<pre class="source-code">
import crypto from 'crypto';
const hash = crypto.createHash('sha256');
hash.update('Hello World');
console.log(hash.digest('hex'));
// a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e</pre>			<p>We will use this<a id="_idIndexMarker793"/> algorithm to hash<a id="_idIndexMarker794"/> the password of the user later on in this chapter, in the <em class="italic">Adding authentication and authorization to our web </em><em class="italic">application</em> section.</p>
			<h3>Signing</h3>
			<p><strong class="bold">Signing</strong> is a process that takes<a id="_idIndexMarker795"/> a string and a secret<a id="_idIndexMarker796"/> key and returns a new string. This algorithm works as a two-way function, so we can sign a string and then we can verify the signature using the secret key.</p>
			<h3>Wide use</h3>
			<p>This pattern of using hashing and signing<a id="_idIndexMarker797"/> is very common across many different software fields. As an example, when a new Node.js version is released, the Node.js team will publish the hash <a id="_idIndexMarker798"/>of every binary file. This allows us to download the binary file and then verify the hash of the file using the hash that the Node.js team published. If the hashes are the same, then we can be sure that the file has not been modified.</p>
			<p>The hash file is signed prior to publishing it, so we can verify the signature using the public key of the Node.js team members. If the signature is valid, then we can be sure that the hash file has not been modified.</p>
			<p>As an example, the following link is the  file shasum for Node v20.11.0 (<a href="https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc">https://nodejs.org/dist/v20.11.0/SHASUMS256.txt.asc</a>). The following code block is the content of the file (redacted for space) to understand how it works:</p>
			<pre class="console">
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256
 f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f  node-v20.11.0-aix-ppc64.tar.gz
...
 dce7cd4b62a721d783ce961e9f70416ac63cf9cdc87b01f6be46540201333b1e  win-x86/node_pdb.zip
-----BEGIN PGP SIGNATURE-----
iQGzBAEBCA...aig9KO/s=
=B/OP
-----END PGP SIGNATURE-----</pre>			<p>As you can see, the file contains<a id="_idIndexMarker799"/> two parts (the message and the signature) and uses <code>-----BEGIN PGP SIGNED MESSAGE-----</code> to <code>-----BEGIN PGP SIGNATURE-----</code>. This helps us to verify the authenticity of the file – basically, we can verify that a Node.js releaser<a id="_idIndexMarker800"/> has created this file and the content<a id="_idIndexMarker801"/> has not been manipulated, even if the server from which the file was downloaded was compromised.</p>
			<p>The message itself contains the hash of every binary file, so we can download the <code>node-v20.11.0-aix-ppc64.tar.gz</code> file and check that the content of the file is the same as the hash published in the message, <code>f76a47616ceb47b9766cb7182ec6b53100192349de6a8aebb11f3abce045748f</code>. If the hash is the same, then we can be sure that the file has not been modified. This allows us to distribute information securely.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">With JWT, we will use a similar pattern, but instead of PGP, we will use a different algorithm to sign the content. You can find the list of supported algorithms in RFC 7518 (<a href="https://tools.ietf.org/html/rfc7518#section-3.1">https://tools.ietf.org/html/rfc7518#section-3.1</a>).</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor358"/>JWT structure</h2>
			<p>JWT is a string that is composed of three<a id="_idIndexMarker802"/> parts separated by a dot. Each part is encoded in <em class="italic">base64</em>. The three parts are the following:</p>
			<ul>
				<li><strong class="bold">Header</strong>: Contains information about the type of token and the algorithm used to sign the token</li>
				<li><strong class="bold">Payload</strong>: Contains the claims (information) that we want to store in the token</li>
				<li><strong class="bold">Signature</strong>: Contains the signature of the token that is used to verify the token</li>
			</ul>
			<p>The signature is the result of signing the header and the payload using the secret key. The best part is that we can verify the signature using the secret key, so we can verify the token without needing to store any information on the server. Additionally, the information is encoded in base64, so anyone can decode it and read it, but we cannot modify it.</p>
			<p>One important thing to mention is that you should never store sensitive information in the payload, as anyone can decode it and read it. This includes users’ passwords and bank account details, among other sensitive information.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor359"/>JWT.io</h2>
			<p>One of the best tools<a id="_idIndexMarker803"/> to work with JWT<a id="_idIndexMarker804"/> is the JWT Debugger (<a href="https://jwt.io/">https://jwt.io/</a>) (see <em class="italic">Figure 13</em><em class="italic">.2</em>). This website allows us to encode and decode JWTs, as well as to verify the signature of the token. You can use it to play with or debug your JWTs.</p>
			<div><div><img src="img/B21678_13_2.jpg" alt="Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Web browser screenshot showing how to digest and validate an encoded token</p>
			<p>Feel free to play with it and explore<a id="_idIndexMarker805"/> how it works before moving to the next section of this chapter.</p>
			<p>In the next section, we will learn how Passport.js works and how it can be used to implement authentication with third-party providers such as Facebook or Spotify in our web application.</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor360"/>Understanding Passport.js fundamentals</h1>
			<p><strong class="bold">Passport.js</strong> is a fantastic library, widely used<a id="_idIndexMarker806"/> to implement authentication in Node.js applications. The official website of Passport.js defines the library as follows:</p>
			<p class="author-quote">Passport is authentication middleware for Node.js. Extremely flexible and modular, Passport can be unobtrusively dropped in to any Express-based web application. A comprehensive set of strategies support authentication using a username and password, Facebook, Twitter, and more.</p>
			<p>(Passport.js, <a href="http://www.passportjs.org/">http://www.passportjs.org/</a>)</p>
			<p>In essence, Passport.js is a middleware (<a href="https://expressjs.com/en/guide/using-middleware.html">https://expressjs.com/en/guide/using-middleware.html</a>) that we will include<a id="_idIndexMarker807"/> in our Express application to provide many different strategies to implement authentication. Having a selection of such strategies allows us to choose the one that best fits our needs. We can use the library to easily implement social login functionality (such as Facebook, Twitter, Spotify, GitHub, and much more in more than 500 strategies) and the typical username/password login.</p>
			<p>In the next section, we will iterate<a id="_idIndexMarker808"/> the code from our web application to include authentication and authorization mechanisms using what we have learned in this chapter so far.</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor361"/>Adding authentication and authorization to our web application</h1>
			<p>In this section, we will add<a id="_idIndexMarker809"/> authentication and authorization to our web application. We will use the jsonwebtoken library to implement the authentication part and will use a custom middleware to implement the authorization part.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor362"/>Clone the base project</h2>
			<p>The authentication and authorization<a id="_idIndexMarker810"/> additions are not very complex, but it is quite long to follow with ease, so for this chapter you can download the project from <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip">https://github.com/PacktPublishing/NodeJS-for-Beginners/archive/refs/heads/main.zip</a>  and access the <code>step4</code> folder. The implementation is ready to go, but I will comment on the most relevant changes that we made since the last chapter (<code>step3</code> folder) so you can easily follow what we’ve done.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor363"/>Setup</h2>
			<p>Our first steps are to<a id="_idIndexMarker811"/> explore the folder, install the dependencies, configure the environment, and start the infrastructure. This can be performed by running the following commands:</p>
			<ol>
				<li>Install the dependencies with <code>npm i</code>.</li>
				<li>Update the secrets, adding the <code>.env</code> file in the root folder with the following content:<pre class="source-code">
MONGODB_URI=mongodb://localhost:27017/whispering-database
PORT=3000
SALT_ROUNDS=10
JWT_SECRET=Tu1fo3mO0PcAvjq^q3wQ24BXNI8$9R
Run <code>npm run infra:stop &amp;&amp; npm run infra:start</code>.</pre></li>				<li>Run <code>npm run infra:stop &amp;&amp; npm </code><code>run infra:start</code>.</li>
			</ol>
			<p>Now, the infrastructure and configuration are ready, but before we start making more changes to the application, it is recommended to run some tests.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor364"/>Run the tests</h2>
			<p>Next, we need to run<a id="_idIndexMarker812"/> some tests<a id="_idIndexMarker813"/> to ensure that the code is working as expected by typing  <code>npm run test</code> in our terminal.</p>
			<h3>New tests added</h3>
			<p>We can see that we have a few new routes <a id="_idIndexMarker814"/>related to login/signup and specific tests for them. When we execute the tests, we will see that the test messages (descriptions) are clear and self-explanatory in terms of what the routes are expected to do and what we aim to do with the test, even if we are not yet familiar with the code:</p>
			<div><div><img src="img/B21678_13_3.jpg" alt="Figure 13.3 – Terminal screenshot that showcases how the routes are tested"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Terminal screenshot that showcases how the routes are tested</p>
			<p>We should recognize these tests<a id="_idIndexMarker815"/> as we worked on these routes in the previous chapters. But if we keep scrolling through the test output, we should see that new tests have been added as well.</p>
			<h3>Updated tests</h3>
			<p>The previous tests have been<a id="_idIndexMarker816"/> updated to include new test cases related to authentication for the routes that require authentication with JWT:</p>
			<div><div><img src="img/B21678_13_4.jpg" alt="Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to follow what is being tested with the descriptions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Terminal screenshot shows the tests passing and how easy is to follow what is being tested with the descriptions</p>
			<p>As you can see, the use cases<a id="_idIndexMarker817"/> in the tests cover more scenarios related to authentication and authorization, such as <code>Should return 401 when the user is not authenticated</code> and <code>Should return a 403 when the user is not </code><code>the author</code>.</p>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor365"/>The UI changes</h2>
			<p>But overall, the most significant changes<a id="_idIndexMarker818"/> are related<a id="_idIndexMarker819"/> to the UI, as now we have new routes and views to login/register and so on. So we can start the application by running <code>npm </code><code>run start</code></p>
			<h3>Login</h3>
			<p>You can enter your credentials<a id="_idIndexMarker820"/> to log in at <code>http://localhost:3000/login</code>, upon which the backend API will return a JWT that you can use to authenticate for any CRUD operation.</p>
			<div><div><img src="img/B21678_13_5.jpg" alt="Figure 13.5 – Web browser screenshot showing the login page where the user can enter their username and password"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Web browser screenshot showing the login page where the user can enter their username and password</p>
			<h3>Register</h3>
			<p>You can create a new account <a id="_idIndexMarker821"/>whenever you please at <code>http://localhost:3000/signup</code>. This operation will generate a new user in the database and the backend will return you a JWT that you can use to perform CRUD operations and authenticate yourself against the API.</p>
			<div><div><img src="img/B21678_13_6.jpg" alt="Figure 13.6 – Web browser screenshot showing where the user can create a new account or log in with existing credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Web browser screenshot showing where the user can create a new account or log in with existing credentials</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The server has defined certain rules regarding username, email and password. So, as an example you can use the following values:</p>
			<ul>
				<li>Username: <code>nodejs</code></li>
				<li>Email: <code>demo@demo.com</code></li>
				<li>Password: <code>aA1#dt$tu</code></li>
			</ul>
			<h3>CRUD operations</h3>
			<p>As remarked on in the previous<a id="_idIndexMarker822"/> section, it is important to understand how authorization works. So, here are the rules for our business logic:</p>
			<ul>
				<li>Any logged user can see all the whispers available on the Whispering platform</li>
				<li>You can modify or delete only the whispers that you have created</li>
			</ul>
			<p>These clear rules will help us to build an authorization system that will cover all the scenarios, so, for example, you won’t be able to delete a whisper created by another user. In some applications, this approach can be very complex, such as with Google Drive or Facebook. In those scenarios, it is quite useful to have a permission matrix in place and well documented. GitLab offers a great example (<a href="https://docs.gitlab.com/ee/user/permissions.html">https://docs.gitlab.com/ee/user/permissions.html</a>)</p>
			<div><div><img src="img/B21678_13_7.jpg" alt="Figure 13.7 – Web browser screenshot showing the main page with all the whispers and the buttons to interact with them from the UI"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Web browser screenshot showing the main page with all the whispers and the buttons to interact with them from the UI</p>
			<p>As you can see, we can modify only the whispers that we created but the option is not visually available for other whispers.</p>
			<p>While the UI is a key factor<a id="_idIndexMarker823"/> in managing authorization, we need to ensure that the backend is also properly managing authorization on its part, so it won’t allow the users to modify or delete whispers from other users. To ensure that the application is capable of preventing these scenarios (like modify other’s users whispers) it is highly recommended to add specify test case. Check the test suite cases, as we have already included these scenarios that cover the <code>403 </code><code>Forbidden</code> response.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor366"/>Added dependencies</h2>
			<p>We have included <a id="_idIndexMarker824"/>the following dependencies:</p>
			<ul>
				<li><strong class="bold">Bcrypt</strong> (<a href="https://www.npmjs.com/package/bcrypt">https://www.npmjs.com/package/bcrypt</a>): This is a library that will help<a id="_idIndexMarker825"/> us to store passwords<a id="_idIndexMarker826"/> safely in the database.</li>
				<li><strong class="bold">Jsonwebtoken</strong> (<a href="https://www.npmjs.com/package/jsonwebtoken">https://www.npmjs.com/package/jsonwebtoken</a>): This is a utility that<a id="_idIndexMarker827"/> helps us to generate<a id="_idIndexMarker828"/> and parse the JWTs.</li>
				<li><strong class="bold">Validator</strong> (<a href="https://www.npmjs.com/package/validator">https://www.npmjs.com/package/validator</a>): This is a library that we use to validate<a id="_idIndexMarker829"/> strings. Basically, we can<a id="_idIndexMarker830"/> use it to sanitize the inputs received from the users, including email addresses, URLs, phone numbers, and so on.</li>
			</ul>
			<p>These dependencies will be used later in order to properly build our application. It is quite common in Node.js projects to rely on third-party libraries. The most important thing to remember is to be sure that we are using good-quality external dependencies without known vulnerabilities, as we learned in <a href="B21678_06.xhtml#_idTextAnchor171"><em class="italic">Chapter 6</em></a><em class="italic">.</em></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor367"/>Changes in the frontend</h2>
			<p>We added a new file<a id="_idIndexMarker831"/> called <code>public/auth.js</code> to manage the form submissions while the user logs in or registers with the platform. After sending the requests, we will store the JWT in the local storage, so we can recover the JWT easily even if we refresh the page:</p>
			<pre class="source-code">
fetch('/login', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        username,
        password
    })
})
.then(response =&gt; {
    if(response.status !== 200) {
        throw new Error("Invalid credentials")
    }
    return response.json()
})
.then(({accessToken}) =&gt; {
    localStorage.setItem('accessToken', accessToken);
    window.location.href = '/';
})</pre>			<p>With the previous changes, we now<a id="_idIndexMarker832"/> send the user and password to the <code>/login</code> route using the <code>POST</code> HTTP method. As a response, we expect JSON data that will contain the access token that we will store in the local storage in order to keep session persistence in case the user refreshes the page. Finally, we will redirect the user to the home page as the authentication has been completed successfully.</p>
			<p>We also added the JWT to every request made against the API for any CRUD operation in <code>public/app.js</code>:</p>
			<pre class="source-code">
const fetchAllWhispers = () =&gt; fetch('http://localhost:3000/api/v1/whisper', {
    headers: {Authentication: `Bearer ${accessToken}`}
}).then((response) =&gt; response.json())</pre>			<p>As you can see, every request includes the <code>Authentication</code> header with the <code>Bearer TOKEN</code> value, which is the expected way to authenticate against the backend. We also use the JWT to get the user’s name and display it in the UI in the Whispers view.</p>
			<p>Also, we disabled the edit/delete buttons<a id="_idIndexMarker833"/> from the Whisper view if the current user is not the user that created them:</p>
			<pre class="source-code">
`&lt;article data-id="${whisper.id}"&gt;
    &lt;div class="actions" ${controlEdition(whisper, user)}&gt;
        &lt;button data-action="edit"&gt;<img src="img/01.png" alt="" role="presentation"/>&lt;/button&gt;
        &lt;button data-action="delete"&gt;<img src="img/02.png" alt="" role="presentation"/>&lt;/button&gt;
    &lt;/div&gt;
&lt;/article&gt;`</pre>			<p>The <code>controlEdition</code> function can hide/show the actions depending on the author:</p>
			<pre class="source-code">
const controlEdition = (whisper, user) =&gt; {
    if(whisper.author.id === user.id) {
        return ''
    } else {
        return 'style="display:none;"'
    }
}</pre>			<p>Now that we are clear on the changes<a id="_idIndexMarker834"/> made in the frontend part, it is time to jump to the backend part and review the changes needed in order to properly manage the users’ authentication data in the databases. We’ll start with the changes in the stores.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor368"/>Added a new store for users</h2>
			<p>The most relevant changes<a id="_idIndexMarker835"/> were added to the <code>database.js</code> file, where a new schema was added for the users. We now include more advanced validations and transformations. The user has <code>username</code>, <code>email</code>, and <code>password</code> properties:</p>
			<pre class="source-code">
const userSchema = new mongoose.Schema({
  //...
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters long'],
    validate: {
      validator: checkPasswordStrength
    }
  }
  //...
})</pre>			<p>In the case of <code>password</code>, we include an additional validation with a new function that we added to the utilities file, <code>utils.js</code>. This new function uses a regular expression to validate the password strength (a minimum of eight characters, at least one letter, one number, and one special character):</p>
			<pre class="source-code">
export function checkPasswordStrength(password) {
   const strengthRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&amp;])[A-Za-z\d@$!%*#?&amp;]{8,}$/
   return strengthRegex.test(password)
}</pre>			<p>Now, the <code>whisperSchema</code> schema<a id="_idIndexMarker836"/> has a relation with <code>User</code>, as each whisper is owned by a specific author:</p>
			<pre class="source-code">
const whisperSchema = new mongoose.Schema({
  author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  message: String,
  updatedDate: {
    type: Date,
    default: Date.now
  },
  creationDate: {
    type: Date,
    default: Date.now
  }
})</pre>			<p>We can see how this relationship takes place in <code>stores/whisper.js</code>, as we can populate the queries:</p>
			<pre class="source-code">
const getAll = () =&gt; Whisper.find().populate('author', 'username')
const getById = id =&gt; Whisper.findById({ _id: id }).populate('author', 'username')
const create = async (message, authorId ) =&gt; {
  const whisper = new Whisper({ message, author: authorId })
  await whisper.save()
  return whisper
}</pre>			<h3>Password management</h3>
			<p>As part of proper password management<a id="_idIndexMarker837"/> in the <code>database.js</code>, we will use the <code>bcrypt</code> library, specifically the <code>pre</code> middleware, to hash passwords before storing them in the database. The <code>pre</code> middleware is a function that is triggered before we perform a specific action such as a save. You can find<a id="_idIndexMarker838"/> great examples in the official documentation (<a href="https://mongoosejs.com/docs/middleware.html#pre">https://mongoosejs.com/docs/middleware.html#pre</a>):</p>
			<pre class="source-code">
userSchema.pre('save', async function (next) {
  const user = this
  if (user.isModified('password')) {
    const salt = await bcrypt.genSalt()
    user.password = await bcrypt.hash(user.password, salt)
  }
  next()
})</pre>			<p>Also, in the same <code>database.js</code> file, we will add a new function to compare the saved password of the user with the password that the user is sending in the request:</p>
			<pre class="source-code">
userSchema.methods.comparePassword = async function (candidatePassword) {
  const user = this
  return await bcrypt.compare(candidatePassword, user.password)
}</pre>			<p>That way we can store and compare<a id="_idIndexMarker839"/> the password securely, never storing it in plain text.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor369"/>JWT utilities</h2>
			<p>Our authentication is now done with <code>jsonwebtoken</code> library for this purpose.</p>
			<p>In the <code>utils.js</code> file, we add one function to generate the JWT:</p>
			<pre class="source-code">
export function generateToken (data) {
   return jwt.sign({
      data: data
    }, process.env.JWT_SECRET, { expiresIn: '1h' })
}</pre>			<p>We also add another function to parse the JWT; in our case, an Express middleware that will parse the JWT and add the user to the request:</p>
			<pre class="source-code">
export function requireAuthentication (req, res, next) {
   const token = req.headers.authentication
   if (!token) {
      res.status(401).json({ error: 'No token provided' })
      return
   }
   try {
      const accessToken = token.split(' ')[1]
      const decoded = jwt.verify(accessToken, process.env.JWT_SECRET)
      req.user = decoded.data
      next()
   } catch (err) {
      res.status(401).json({ error: 'Invalid token' })
   }
}</pre>			<p>As you can see, we use the <code>JWT_SECRET</code> to sign and verify the JWTs. This environmental variable is stored in the <code>.env</code> file, so we can change it easily in any environment. Also, we set an expiration time of 1 hour for the JWTs, after which time the user will need to authenticate again. It is quite common to have short expiration times so that if the token did get compromised, the time in which it could be used to do harm is limited. This is a very popular secure measurement<a id="_idIndexMarker841"/> that can be combined with refresh tokens (<a href="https://auth0.com/learn/refresh-tokens">https://auth0.com/learn/refresh-tokens</a>) to have an even more solid implementation.</p>
			<p>If the token has been modified or the secret is not the same, then the <code>jwt.verify</code> function will throw an error, so we can catch it and return an error to the user. The same will happen if the token is expired.</p>
			<p>If the token is valid, then we will add the user to the request, so we can use it in the next middleware or in the route handler.</p>
			<p>This completes the authentication<a id="_idIndexMarker842"/> part – we can now authenticate the users in our web application! It is important to note that we are not storing any information on the server so we can scale our application without any issues, but there are some drawbacks to this, as we will explore in <a href="B21678_15.xhtml#_idTextAnchor394"><em class="italic">Chapter 15</em></a>.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor370"/>Adding new routes</h2>
			<p>Now we have all the utilities<a id="_idIndexMarker843"/> to implement the authentication, so we can include the new routes. In our case, we will include the following routes:</p>
			<ul>
				<li><code>GET /login</code> to render the login view to the user:<pre class="source-code">
app.get('/login', (req, res) =&gt; {
  res.render('login')
})</pre></li>				<li><code>POST /login</code> to process the login request, store the new user, and return the JWT:<pre class="source-code">
app.post('/login', async (req, res) =&gt; {
  try {
    const { username, password } = req.body
    const foundUser = await user.getUserByCredentials(username, password)
    const accessToken = generateToken({ username, id: foundUser._id})
    res.json({ accessToken})
  } catch ( err ){
    res.status(400).json({ error: err.message })
  }
})</pre></li>				<li><code>GET /signup</code> to render the signup view to the user:<pre class="source-code">
app.get('/signup', (req, res) =&gt; {
  res.render('signup')
})</pre></li>				<li><code>POST /signup</code> to process the signup<a id="_idIndexMarker844"/> request and return the JWT:<pre class="source-code">
app.post('/signup', async (req, res) =&gt; {
  try {
    const { username, password, email } = req.body
    const newUser = await user.create(username, password, email)
    const accessToken = generateToken({ username, id: newUser._id})
    res.json({ accessToken})
  } catch ( err ){
    res.status(400).json({ error: err.message })
  }
})</pre></li>				<li>Then, we also need to update<a id="_idIndexMarker845"/> the routes that require authentication to use the <code>require</code><strong class="source-inline">
Authentication</strong> middleware and modify the internal logic to ensure that the authorizations are properly managed. For example, users shouldn’t be able to modify/delete whispers from other users:<pre class="source-code">
app.put('/api/v1/whisper/:id', requireAuthentication, async (req, res) =&gt; {
  const { message } = req.body
  const id = req.params.id
  if (!message) {
    res.sendStatus(400)
    return
  }
  const storedWhisper = await whisper.getById(id)
  if (!storedWhisper) {
    res.sendStatus(404)
    return
  }
  if(storedWhisper.author.id !== req.user.id) {
    res.sendStatus(403)
    return
  }
  await whisper.updateById(id, message)
  res.sendStatus(200)
})</pre></li>			</ul>
			<p>As you can see, we use the <code>requireAuthentication</code> middleware to ensure that the user is authenticated, and then we check that the user is the author of the whisper that we are trying to modify. If the user is not the author, then we return a <code>403 </code><code>Forbidden</code> error.</p>
			<p>There are other scenarios<a id="_idIndexMarker846"/> that we also covered in the tests such as when the whisper is not found.In those cases is expected that we to return the proper HTTP error code in each case.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor371"/>Improved testing utilities</h2>
			<p>We modified the testing utilities<a id="_idIndexMarker847"/> to include valid fixtures for the users, so we have predefined users that we can use to test the authentication functionality.</p>
			<p>Also, we included sample whispers for the tests, so we can use them to test the authorization part.</p>
			<p>And finally, we included some fixtures that include a valid JWT for each user, so we can use them to test the authorization part.</p>
			<p>You can check the changes in detail in the <code>tests/utils.js</code> file.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor372"/>Test case changes</h2>
			<p>Regarding the test cases, we updated<a id="_idIndexMarker848"/> them to include the new routes and to test the authorization part. You can check the changes in detail in the <code>tests/server.test.js</code> file.</p>
			<p>In general, most of the routes now include specific test cases to test the authorization part, ensuring that the authorization is properly managed.</p>
			<p>We added test cases for each route to test requests from users that are not authenticated:</p>
			<pre class="source-code">
it('Should return a 401 when the user is not authenticated', async () =&gt; {
  const response = await supertest(app)
  .delete(`/api/v1/whisper/${existingId}`)
  expect(response.status).toBe(401)
  expect(response.body.error).toBe('No token provided')
})</pre>			<p>Also, in some routes, we added test cases to test the authorization part, so we can ensure that the authorization is properly managed:</p>
			<pre class="source-code">
it('Should return a 403 when the user is not the author', async () =&gt; {
  const response = await supertest(app)
  .delete(`/api/v1/whisper/${existingId}`)
  .set('Authentication', `Bearer ${secondUser.token}`)
  expect(response.status).toBe(403)
})</pre>			<p>Overall, many tests were modified<a id="_idIndexMarker849"/> to include the JWT with a specific Bearer token, in the form of <code>.set('Authentication', `</code><code>Bearer ${firstUser.token}`)</code>.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor373"/>Test coverage</h2>
			<p>If we run the tests<a id="_idIndexMarker850"/> with <code>npm run test:coverage</code>, we can see in detail how the changes affected the test coverage. If you check the <code>coverage/lcov-report/index.html</code> file, you can see the details of the coverage:</p>
			<div><div><img src="img/B21678_13_8.jpg" alt="Figure 13.8 – Web browser screenshot with the test coverage report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Web browser screenshot with the test coverage report</p>
			<p>Overall, the coverage is quite<a id="_idIndexMarker851"/> good (between 94-98%), but we can see that we have some lines that are not covered. We could improve the tests to cover them, but those are edge cases.</p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor374"/>Summary</h1>
			<p>In this chapter, we had the opportunity to learn how authentication and authorization work in a web application. We implemented the authentication part using JWT and the authorization part using a custom middleware.</p>
			<p>Additionally, we explored in detail how JWTs work and how to implement them in a Node.js application.</p>
			<p>Finally, we added authentication and authorization functionalities to our web application, so we can now authenticate users and we can ensure that the users can only modify/delete the whispers that they created.</p>
			<p>In the next chapter, we are going to learn in more detail how to properly manage errors in our web application and in any Node.js application or library.</p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor375"/>Further reading</h1>
			<ul>
				<li><em class="italic">Session vs Token Authentication in 100 </em><em class="italic">Seconds</em>: <a href="https://www.youtube.com/watch?v=UBUNrFtufWo">https://www.youtube.com/watch?v=UBUNrFtufWo</a></li>
				<li><em class="italic">Authentication: It’s Easier Than You </em><em class="italic">Think</em>: <a href="https://www.youtube.com/watch?v=h6wBYWWdyYQ">https://www.youtube.com/watch?v=h6wBYWWdyYQ</a></li>
				<li><em class="italic">JWT Handbook by </em><em class="italic">Auth0</em>: <a href="https://auth0.com/resources/ebooks/jwt-handbook">https://auth0.com/resources/ebooks/jwt-handbook</a></li>
				<li><em class="italic">Auth0 in 100 Seconds // And beyond with a Next.js Authentication </em><em class="italic">Tutorial</em>: <a href="https://www.youtube.com/watch?v=yufqeJLP1rI">https://www.youtube.com/watch?v=yufqeJLP1rI</a></li>
			</ul>
		</div>
	</body></html>