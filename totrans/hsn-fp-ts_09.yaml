- en: Functional-Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we learned about the functional programming paradigm.
    We explored the main functional programming concepts, techniques, and patterns.
    In this chapter, we are going to learn about the functional-reactive programming
    paradigm, including the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional-reactive programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to learn what functional-reactive programming is and how it can
    help us to develop applications that are easier to extend and maintain.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn what the main differences are between
    functional programming and reactive programming as well as what principal benefits
    of reactive programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming versus functional-reactive programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming and reactive programming should be considered as two
    different paradigms. Functional programming focuses on the interpretation of functions
    as mathematical functions—stateless and without side effects. On the other hand,
    reactive programming focuses on the propagation of changes as streams of events.
    The term *functional-reactive programming* is used to refer to a superset of reactive
    programming. Functional-reactive programming tries to take advantage of both the
    functional and reactive programming paradigms. For example, in functional-reactive
    programming, the event streams can be composed, we are encouraged to avoid external
    state mutations, and many of the functional programming principles are still relevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of functional-reactive programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional-reactive programming is highly influenced by the functional programming
    principles and, as a result, many of the benefits of functional programming are
    also shared by functional-reactive programming. Functional-reactive applications
    are easier to reason about because they tend to avoid state mutations and side
    effects and promote a declarative style. They are particularly well suited for
    event-based architectures and concurrent systems. Functional-reactive programming
    is also considered by many developers a programming style that tends to be scalable
    because it follows the principle of composability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Working with observables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming requires us to change the way that we think about events
    in an application. Reactive programming requires us to think about events as a
    stream of values. For example, a mouse click event can be represented as a stream
    of data. Every click event generates a new value in the data stream. In reactive
    programming, we can use the stream of data to query and manipulate the values
    in the stream.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the **Reactive Extensions Library for JavaScript** (**RxJS**).
    RxJS provides us with an implementation of the observable pattern, as well as
    many operators and utilities that allow us to manipulate the observables. RxJS
    also includes helpers that allow us to create observables given different data
    types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install RxJS using `npm`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The observable pattern is also known as the **observable sequence pattern**,
    which is the result of putting two other popular patterns together: the observer
    and the iterator patterns. In this section, we are going to learn more about these
    patterns so that we can have a better understanding of what observables are and
    how they work internally.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In an implementation of the observer pattern, we can have many known listener
    entities that subscribe to messages. The following code snippet contains a very
    basic implementation of a listener in the observer pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `Listener` has a method named `update`, which is invoked when a second entity known as
    the `Producer` generates a new message. A `Producer` instance manages a number
    of `Listener` instances. A `message` can be generated with the `notify` method.
    The `message` is then passed to all the subscribed listeners. The following code
    snippet contains a very basic implementation of a producer in the observer pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippet declares a couple of `Listener` instances and a
    `Producer` instance. It then subscribes both listeners to the `Producer` messages using
    the `add` method. Later, we use the `notify` method in `Producer` to send a message.
    The message will be received by all the subscribed listeners. In this case, both
    listeners will receive the message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have learned how to implement the observer pattern, we are going
    to focus on the second pattern used by the observable sequence pattern—the iterator
    pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The iterator pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand how the observable sequence pattern works, we also need to understand
    the iterator pattern. The following code snippet uses a generator to create an
    iterator that iterates the multiples of a given number in an array. Only the elements
    in the array that are multiples of a given number are iterated:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get an instance of the iterator, we only need to invoke the function and
    pass an array and a number as its arguments. The function returns an iterator
    that will return the numbers in the array that are multiples of the given number:
    `3`. We can invoke the iterator''s `next` method to get the next element. Each
    element has a property named `done` and a property named `value`. The `done` property
    can be used to check whether there are more items to be iterated. The `value`
    property can be used to access the value of the current item:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also iterate all the items in an iterator using a `for...of` statement,
    as opposed to accessing the `done` property by hand:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The observer and the iterator pattern can be very useful in many different scenarios.
    We can combine these two patterns in a pattern known as the **observable sequence**,
    or simply **observable**. An observable allows us to iterate and be notified about
    changes in a sequence. Now that we understand what is an observable is, we are
    going to learn how we can create instances of observables with RxJS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Observables** are streams of data, and this explains why it is easy to imagine
    that we can represent an event such as an `onClick` event using an observable.
    However, the use cases for observables are much more diverse than that. In this
    section, we are going to explore how to create an observable given different types.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables from a value
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create an observable given a value using the `of` function. In the old
    versions of RxJS, the function `of` was a static method of the `Observable` class,
    which was available as `Observable.of`. This should remind us to use the `of`
    method of the `Applicative` type in category theory because observables take some
    inspiration from category theory. However, in RxJS 6.0, the `of` method is available
    as a standalone factory function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code snippet declares an observable with one unique value using
    the `of` function. The code snippet also showcases how we can subscribe to an
    observable using the `subscribe` method. The `subscribe` method takes three function
    arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Item handler**: Invoked once for each item in the sequence.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handler**: Invoked if there is an error in the sequence. This argument
    is optional.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Done handler**: Invoked when there are no more items in the sequence. This
    argument is optional.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram is known as a **marble diagram**, and is used to represent
    observables in a visual manner. The arrow represents the time and the circles
    are values. In this case, we have only one value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b39af7a3-e60b-4e05-a161-ca543aa8ffed.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: As we can see, the circle also has a small vertical line in the middle. This
    line is used to represent the last element in an observable. In this case, the
    item handler in the subscription will only be invoked once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables from arrays
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create an observable given an existing array using the `from` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet declares an observable with three values using the `from` function.
    The code snippet also showcases how we can subscribe once more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The following marble diagram represents the preceding example in a visual manner.
    The generated observable has three values (**10**, **20,** and **30**) and **30**
    is the last element in the observable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2781af68-d51b-4689-997f-fe7f43b76e9a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'We can alternatively use the `interval` function to generate an array with
    a given number of elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet declares an observable with ten values using the `interval` function.
    The code snippet also showcases how we can subscribe once more. In this case,
    the item handler in the subscription will be invoked ten times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The following marble diagram represents the preceding example in a visual manner.
    The generating observable has ten values, and `9` is the last item contained by
    it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff64f459-4563-45d0-977f-4d2d154e9e1e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: In this case, the item handler in the subscription will be invoked ten times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables from events
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also possible to create an observable using an event as the source of
    the items in the stream. We can do this using the `fromEvent` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the item handler in the subscription will be invoked as many times
    as the click event `takes` place.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding example can only be executed in a web browser.
    To execute the preceding code in a web browser, you will need to use a module
    bundler, such as Webpack. We will not cover this topic, since it is beyond the
    scope of this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables from callbacks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also possible to create an observable that will iterate the arguments
    of a callback using the `bindCallback` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding example uses the `node-fetch` module because the fetch function
    is not available in Node.js. You can install the `node-fetch` module using the
    following `npm` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `getJSON` function takes a URL and a callback as its arguments. When we
    pass it to the `bindCallback` function, a new function is returned. The new function takes
    a URL as its only argument and returns an observable instead of taking a callback.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js, callbacks follow a well-defined pattern. The Node.js callbacks
    take two arguments, `error` and `result`, and don''t throw exceptions. We must
    use the `error` argument to check whether something went wrong instead of a `try`/`catch`
    statement. RxJS also defines a function named `bindNodeCallback` that allows us
    to work with the callbacks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The helpers, `bindCallback` and `bindNodeCallback`, have very similar behavior,
    but the second has been specially designed to work with Node.js callbacks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Creating observables from promises
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another potential source of items for an observable sequence is a `Promise`.
    RxJS also allows us to handle this use case with the `from` function. We must
    pass a `Promise` instance to the `from` function. In the following example, we
    use the `fetch` function to send an HTTP request. The `fetch` function returns
    a promise that is passed to the `from` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The generated observable will contain the result of the promise as its only
    item.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Cold and hot observables
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official RxJS documentation explores the differences between cold and hot
    observables as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '"Cold observables start running upon subscription, that is, the observable
    sequence only starts pushing values to the observers when Subscribe is called.
    Values are also not shared among subscribers. This is different from hot observables,
    such as mouse move events or stock tickers, which are already producing values
    even before a subscription is active. When an observer subscribes to a hot observable
    sequence, it will get all values in the stream that are emitted after it subscribes.
    The hot observable sequence is shared among all subscribers, and each subscriber
    is pushed the next value in the sequence."'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand these differences if we want to have control over
    the execution flow of our components. The key point to remember is that cold observables
    are lazily evaluated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Working with operators
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to use some functions known as operators,
    which allow us to manipulate observables in many different ways.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Pipe
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In RxJS, observables have a method named `pipe`, which is very similar to the
    pipe operator in functional programming. When we pipe two functions, we generate
    a new function that passes the return of the first function as arguments to the
    second function in the pipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The idea is very similar in reactive programming. When we pipe an observable
    through an operator, we generate a new observable. The new observable passes each
    of the items in the original observable to an operator that transforms them into
    the items in the new sequence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to include a code example here, because we are going to use
    the pipe method multiple times during the remaining part of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Max
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `max` operator function can be used to find the biggest value in an observable.
    We must apply the `max` operator using the `pipe` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following marble diagram showcases the initial sequence and the result
    sequence after applying the `max` operator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b447b334-12c9-495b-abe7-c9a06397777d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains only one value (the biggest value in the original
    sequence).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Every
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `every` operator function can be used to test whether all the values in
    an observable adhere to a given requirement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code snippet uses the `every` operator to test that all the values
    in an observable are lower than ten. The following marble diagram showcases the
    initial sequence and the result sequence after applying the `every` operator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51541bb3-4fc4-4492-932c-7315ad70c4cc.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains only one value (true or false).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Find
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find` operator function can be used to find the first value in an observable
    that adheres to a given constraint:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet uses the `find` operator to find the first value
    in an observable greater than ten. The following marble diagram showcases the
    initial sequence and the result sequence after applying the `find` operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a60c397d-6adc-49f7-967d-28774443498a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains only one value (the first value in the stream that
    matches the given constraint).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `filter` operator function can be used to find the values in an observable
    that adhere to a given constraint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code snippet uses the `filter` operator to find the values in
    an observable greater than ten. The following marble diagram showcases the initial
    sequence and the result sequence after applying the `filter` operator:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13821276-63f2-45b5-b68f-0699900f5a68.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains only some values (the values in the stream that
    match the given constraint).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Map
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `map` operator function can be used to transform the values in an observable
    into derived values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code snippet uses the `map` operator to transform the values
    in an observable into new values (the original value multiplied by ten). The following
    marble diagram showcases the initial sequence and the result sequence after applying
    the `map` operator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e05cb0a1-68f9-40fb-a0d6-1f66366e5f33.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains a new mapped value for each value in the original
    sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reduce` operator function can be used to transform all the values in an
    observable into one single value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code snippet uses the `reduce` operator to transform the values
    in an observable into a new single value (the total of all the values). The function
    that transforms multiple values into one single value is known as an accumulator.
    The following marble diagram showcases the initial sequence and the result sequence
    after applying the `reduce` operator:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a26f8f43-33ec-4f9b-9abd-5c554fe06553.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: The result sequence contains only one value (the result of the accumulator).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Throttle
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `throttle` operator function can be used to reduce the number of values
    that are added to an observable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code snippet creates an observable for `click` events. Every click
    will add an item to the sequence. The example also uses the `pipe` method and
    the `mapTo` function to map all the click events to the numeric value `1`. It
    is then when we use the `throttle` operator to reduce the number of values that
    are added to the sequence. If two or more click events take place within a time
    interval lower than the one declared by the interval, only the first value will
    be added to the sequence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the preceding example can only be executed in a web browser.
    To execute the preceding code in a web browser, you will need to use a module
    bundler such as Webpack. We will not cover this topic because it is beyond the
    scope of this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The following marble diagram showcases the initial sequence and the result
    sequence after applying the `reduce` operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5607f7c-ffa3-48c2-b189-534720121053.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: The result sequence only contains some values because the values that take place
    too close in time are ignored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Merge
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `merge` operator function can be used to merge the values of two observables
    into value pairs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `merge` 操作符函数将两个可观察对象的值合并成值对：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code snippet uses the `merge` operator to combine the values
    of two observables into a new observable. The values are ordered chronologically.
    The following marble diagram showcases the initial sequences and the result sequence
    after applying the `merge` operator:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段使用了 `merge` 操作符将两个可观察对象的值合并到一个新的可观察对象中。这些值按时间顺序排列。以下的水晶图展示了应用 `merge`
    操作符之前的初始序列和结果序列：
- en: '![](img/b02ed865-4487-49a5-bc24-3690f618cdc6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b02ed865-4487-49a5-bc24-3690f618cdc6.png)'
- en: The result sequence contains the values of both observables ordered in the same
    sequence as they took place in time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列包含两个可观察对象的时间顺序中的值，并按其发生的时间顺序排列。
- en: Zip
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zip
- en: 'The `zip` operator function can be used to merge the values of two observables
    into value pairs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `zip` 操作符函数将两个可观察对象的值合并成值对：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet uses the `zip` operator to combine the values of
    two observables into a new observable. The values in the new observable are value
    pairs that contain a value from the first observable and a value from the second
    observable and are grouped by their index in the sequence. The following marble
    diagram showcases the initial sequences and the result sequence after applying
    the `zip` operator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段使用了 `zip` 操作符将两个可观察对象的值合并到一个新的可观察对象中。新可观察对象中的值是包含来自第一个可观察对象的值和来自第二个可观察对象的值的值对，并且按其在序列中的索引分组。以下的水晶图展示了应用
    `zip` 操作符之前的初始序列和结果序列：
- en: '![](img/a7e246ce-1a59-46d5-9e6e-d0eb1f2a58a4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7e246ce-1a59-46d5-9e6e-d0eb1f2a58a4.png)'
- en: The result sequence contains the values of both observables merged into single
    value pairs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列包含合并成单个值对的两个可观察对象的值。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the functional-reactive programming paradigm.
    We have learned that many of the functional programming ideas, such as pure functions
    and function composition, can be applied to reactive programming. We also learned
    what observables are and how we can create them and work with them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数式反应式编程范式。我们了解到许多函数式编程思想，如纯函数和函数组合，可以应用于反应式编程。我们还学习了什么是可观察对象，以及我们如何创建它们并与之交互。
- en: In the next chapter, we are going to learn about some production-ready functional
    programming libraries, such as Ramda and Immutable.js.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些生产就绪的函数式编程库，例如 Ramda 和 Immutable.js。
