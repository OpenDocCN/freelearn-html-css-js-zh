- en: Functional-Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数-响应式编程
- en: 'In the previous chapters, we learned about the functional programming paradigm.
    We explored the main functional programming concepts, techniques, and patterns.
    In this chapter, we are going to learn about the functional-reactive programming
    paradigm, including the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了函数式编程范式。我们探讨了函数式编程的主要概念、技术和模式。在本章中，我们将学习函数式响应式编程范式，包括以下主题：
- en: Reactive programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Functional-reactive programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式响应式编程
- en: Streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流
- en: Observables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察对象
- en: The observer pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The iterator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: Operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: We are going to learn what functional-reactive programming is and how it can
    help us to develop applications that are easier to extend and maintain.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习函数式响应式编程是什么以及它如何帮助我们开发易于扩展和维护的应用程序。
- en: Reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: In this section, we are going to learn what the main differences are between
    functional programming and reactive programming as well as what principal benefits
    of reactive programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习函数式编程和响应式编程之间的主要区别以及响应式编程的主要好处。
- en: Functional programming versus functional-reactive programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程与函数式响应式编程的比较
- en: Functional programming and reactive programming should be considered as two
    different paradigms. Functional programming focuses on the interpretation of functions
    as mathematical functions—stateless and without side effects. On the other hand,
    reactive programming focuses on the propagation of changes as streams of events.
    The term *functional-reactive programming* is used to refer to a superset of reactive
    programming. Functional-reactive programming tries to take advantage of both the
    functional and reactive programming paradigms. For example, in functional-reactive
    programming, the event streams can be composed, we are encouraged to avoid external
    state mutations, and many of the functional programming principles are still relevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程和响应式编程应被视为两种不同的范式。函数式编程侧重于将函数解释为数学函数——无状态且无副作用。另一方面，响应式编程侧重于将变化传播为事件流。术语*函数式响应式编程*用于指代响应式编程的超集。函数式响应式编程试图利用函数式和响应式编程范式的好处。例如，在函数式响应式编程中，事件流可以被组合，我们被鼓励避免外部状态变更，并且许多函数式编程原则仍然适用。
- en: The benefits of functional-reactive programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式响应式编程的好处
- en: Functional-reactive programming is highly influenced by the functional programming
    principles and, as a result, many of the benefits of functional programming are
    also shared by functional-reactive programming. Functional-reactive applications
    are easier to reason about because they tend to avoid state mutations and side
    effects and promote a declarative style. They are particularly well suited for
    event-based architectures and concurrent systems. Functional-reactive programming
    is also considered by many developers a programming style that tends to be scalable
    because it follows the principle of composability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式编程深受函数式编程原则的影响，因此，许多函数式编程的好处也被函数式响应式编程所共享。函数式响应式应用程序更容易推理，因为它们倾向于避免状态变更和副作用，并促进声明式风格。它们特别适合基于事件的架构和并发系统。许多开发者认为，函数式响应式编程是一种易于扩展的编程风格，因为它遵循可组合性的原则。
- en: Working with observables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与可观察对象一起工作
- en: Reactive programming requires us to change the way that we think about events
    in an application. Reactive programming requires us to think about events as a
    stream of values. For example, a mouse click event can be represented as a stream
    of data. Every click event generates a new value in the data stream. In reactive
    programming, we can use the stream of data to query and manipulate the values
    in the stream.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程要求我们改变对应用程序中事件思考的方式。响应式编程要求我们将事件视为值流。例如，鼠标点击事件可以表示为数据流。每次点击事件都会在数据流中生成一个新值。在响应式编程中，我们可以使用数据流来查询和操作流中的值。
- en: We are going to use the **Reactive Extensions Library for JavaScript** (**RxJS**).
    RxJS provides us with an implementation of the observable pattern, as well as
    many operators and utilities that allow us to manipulate the observables. RxJS
    also includes helpers that allow us to create observables given different data
    types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **JavaScript 的响应式扩展库（RxJS**）。RxJS 为我们提供了一个可观察模式的实现，以及许多操作符和实用工具，使我们能够操作可观察对象。RxJS
    还包括一些辅助工具，允许我们根据不同的数据类型创建可观察对象。
- en: 'We can install RxJS using `npm`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `npm` 来安装 RxJS：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The observable pattern is also known as the **observable sequence pattern**,
    which is the result of putting two other popular patterns together: the observer
    and the iterator patterns. In this section, we are going to learn more about these
    patterns so that we can have a better understanding of what observables are and
    how they work internally.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察模式也被称为 **可观察序列模式**，这是将两种其他流行的模式结合在一起的结果：观察者和迭代器模式。在本节中，我们将更深入地了解这些模式，以便更好地理解可观察对象是什么以及它们是如何在内部工作的。
- en: The observer pattern
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'In an implementation of the observer pattern, we can have many known listener
    entities that subscribe to messages. The following code snippet contains a very
    basic implementation of a listener in the observer pattern:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式的实现中，我们可以有许多已知的监听器实体订阅消息。以下代码片段包含了一个观察者模式中监听器实现的非常基础的示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A `Listener` has a method named `update`, which is invoked when a second entity known as
    the `Producer` generates a new message. A `Producer` instance manages a number
    of `Listener` instances. A `message` can be generated with the `notify` method.
    The `message` is then passed to all the subscribed listeners. The following code
    snippet contains a very basic implementation of a producer in the observer pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Listener` 对象有一个名为 `update` 的方法，该方法在第二个实体，即 `Producer`，生成一条新消息时被调用。一个 `Producer`
    实例管理多个 `Listener` 实例。可以通过 `notify` 方法生成一条 `message`。然后，这条 `message` 被传递给所有已订阅的监听器。以下代码片段包含了一个观察者模式中生产者实现的非常基础的示例：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following code snippet declares a couple of `Listener` instances and a
    `Producer` instance. It then subscribes both listeners to the `Producer` messages using
    the `add` method. Later, we use the `notify` method in `Producer` to send a message.
    The message will be received by all the subscribed listeners. In this case, both
    listeners will receive the message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一些 `Listener` 实例和一个 `Producer` 实例。然后，它使用 `add` 方法将两个监听器都订阅到 `Producer`
    的消息。稍后，我们使用 `Producer` 中的 `notify` 方法发送一条消息。这条消息将被所有已订阅的监听器接收。在这种情况下，两个监听器都将接收到这条消息：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have learned how to implement the observer pattern, we are going
    to focus on the second pattern used by the observable sequence pattern—the iterator
    pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何实现观察者模式，接下来我们将关注可观察序列模式使用的第二种模式——迭代器模式。
- en: The iterator pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: 'To understand how the observable sequence pattern works, we also need to understand
    the iterator pattern. The following code snippet uses a generator to create an
    iterator that iterates the multiples of a given number in an array. Only the elements
    in the array that are multiples of a given number are iterated:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解可观察序列模式是如何工作的，我们还需要了解迭代器模式。以下代码片段使用生成器创建了一个迭代器，该迭代器遍历数组中给定数字的倍数。只有数组中给定数字的倍数会被迭代：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get an instance of the iterator, we only need to invoke the function and
    pass an array and a number as its arguments. The function returns an iterator
    that will return the numbers in the array that are multiples of the given number:
    `3`. We can invoke the iterator''s `next` method to get the next element. Each
    element has a property named `done` and a property named `value`. The `done` property
    can be used to check whether there are more items to be iterated. The `value`
    property can be used to access the value of the current item:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取迭代器的一个实例，我们只需要调用该函数，并传递一个数组和数字作为其参数。该函数返回一个迭代器，它将返回数组中给定数字的倍数：`3`。我们可以调用迭代器的
    `next` 方法来获取下一个元素。每个元素都有一个名为 `done` 的属性和一个名为 `value` 的属性。`done` 属性可以用来检查是否还有更多项目需要迭代。`value`
    属性可以用来访问当前项的值：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also iterate all the items in an iterator using a `for...of` statement,
    as opposed to accessing the `done` property by hand:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `for...of` 语句迭代迭代器中的所有项目，而不是手动访问 `done` 属性：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The observer and the iterator pattern can be very useful in many different scenarios.
    We can combine these two patterns in a pattern known as the **observable sequence**,
    or simply **observable**. An observable allows us to iterate and be notified about
    changes in a sequence. Now that we understand what is an observable is, we are
    going to learn how we can create instances of observables with RxJS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者和迭代器模式在许多不同场景中非常有用。我们可以将这两种模式结合在一个称为**可观察序列**或简单地称为**可观察值**的模式中。可观察值允许我们迭代并通知序列中的变化。现在我们了解了什么是可观察值，我们将学习如何使用RxJS创建可观察值的实例。
- en: Creating observables
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可观察值
- en: '**Observables** are streams of data, and this explains why it is easy to imagine
    that we can represent an event such as an `onClick` event using an observable.
    However, the use cases for observables are much more diverse than that. In this
    section, we are going to explore how to create an observable given different types.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**可观察值**是数据流，这也解释了为什么我们可以想象使用可观察值来表示像`onClick`事件这样的事件。然而，可观察值的用例比这要多样化得多。在本节中，我们将探讨如何根据不同类型创建可观察值。'
- en: Creating observables from a value
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从值创建可观察值
- en: 'We can create an observable given a value using the `of` function. In the old
    versions of RxJS, the function `of` was a static method of the `Observable` class,
    which was available as `Observable.of`. This should remind us to use the `of`
    method of the `Applicative` type in category theory because observables take some
    inspiration from category theory. However, in RxJS 6.0, the `of` method is available
    as a standalone factory function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`of`函数根据值创建一个可观察值。在RxJS的老版本中，`of`函数是`Observable`类的一个静态方法，可用作`Observable.of`。这应该提醒我们使用范畴论中的`Applicative`类型的`of`方法，因为可观察值从范畴论中汲取了一些灵感。然而，在RxJS
    6.0中，`of`方法作为一个独立的工厂函数可用：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code snippet declares an observable with one unique value using
    the `of` function. The code snippet also showcases how we can subscribe to an
    observable using the `subscribe` method. The `subscribe` method takes three function
    arguments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`of`函数声明了一个具有一个唯一值的可观察值。代码片段还展示了如何使用`subscribe`方法订阅可观察值。`subscribe`方法接受三个函数参数：
- en: '**Item handler**: Invoked once for each item in the sequence.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目处理器**：为序列中的每个项目调用一次。'
- en: '**Error handler**: Invoked if there is an error in the sequence. This argument
    is optional.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理器**：如果序列中发生错误，则调用。此参数是可选的。'
- en: '**Done handler**: Invoked when there are no more items in the sequence. This
    argument is optional.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成处理器**：当序列中没有更多项目时被调用。此参数是可选的。'
- en: 'The following diagram is known as a **marble diagram**, and is used to represent
    observables in a visual manner. The arrow represents the time and the circles
    are values. In this case, we have only one value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表被称为**弹珠图**，用于以视觉方式表示可观察值。箭头代表时间，圆圈代表值。在这种情况下，我们只有一个值：
- en: '![](img/b39af7a3-e60b-4e05-a161-ca543aa8ffed.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b39af7a3-e60b-4e05-a161-ca543aa8ffed.png)'
- en: As we can see, the circle also has a small vertical line in the middle. This
    line is used to represent the last element in an observable. In this case, the
    item handler in the subscription will only be invoked once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，圆圈中间也有一条小的垂直线。这条线用来表示可观察值的最后一个元素。在这种情况下，订阅中的项目处理器只会被调用一次。
- en: Creating observables from arrays
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组创建可观察值
- en: 'We can create an observable given an existing array using the `from` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`from`函数根据现有的数组创建一个可观察值：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet declares an observable with three values using the `from` function.
    The code snippet also showcases how we can subscribe once more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`from`函数声明了一个具有三个值的可观察值。代码片段还展示了如何再次进行订阅。
- en: 'The following marble diagram represents the preceding example in a visual manner.
    The generated observable has three values (**10**, **20,** and **30**) and **30**
    is the last element in the observable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这个弹珠图以视觉方式表示了前面的例子。生成的可观察值有三个值（**10**、**20**和**30**），其中**30**是可观察值的最后一个元素：
- en: '![](img/2781af68-d51b-4689-997f-fe7f43b76e9a.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2781af68-d51b-4689-997f-fe7f43b76e9a.png)'
- en: 'We can alternatively use the `interval` function to generate an array with
    a given number of elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`interval`函数生成具有给定元素数量的数组：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet declares an observable with ten values using the `interval` function.
    The code snippet also showcases how we can subscribe once more. In this case,
    the item handler in the subscription will be invoked ten times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用 `interval` 函数声明了一个包含十个值的可观察对象。代码片段还展示了我们可以再次订阅。在这种情况下，订阅中的项目处理程序将被调用十次。
- en: 'The following marble diagram represents the preceding example in a visual manner.
    The generating observable has ten values, and `9` is the last item contained by
    it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的油管图以可视化的方式表示了前面的示例。生成可观察对象包含十个值，其中 `9` 是它包含的最后一个项目：
- en: '![](img/ff64f459-4563-45d0-977f-4d2d154e9e1e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff64f459-4563-45d0-977f-4d2d154e9e1e.png)'
- en: In this case, the item handler in the subscription will be invoked ten times.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，订阅中的项目处理程序将被调用十次。
- en: Creating observables from events
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从事件创建可观察对象
- en: 'It is also possible to create an observable using an event as the source of
    the items in the stream. We can do this using the `fromEvent` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用事件作为流中项目来源来创建一个可观察对象。我们可以使用 `fromEvent` 函数来完成此操作：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the item handler in the subscription will be invoked as many times
    as the click event `takes` place.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，订阅中的项目处理程序将根据点击事件发生的次数被调用。
- en: Please note that the preceding example can only be executed in a web browser.
    To execute the preceding code in a web browser, you will need to use a module
    bundler, such as Webpack. We will not cover this topic, since it is beyond the
    scope of this book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例只能在网页浏览器中执行。要在网页浏览器中执行前面的代码，您需要使用模块打包器，例如 Webpack。我们不会涉及这个主题，因为它超出了本书的范围。
- en: Creating observables from callbacks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从回调创建可观察对象
- en: 'It is also possible to create an observable that will iterate the arguments
    of a callback using the `bindCallback` function:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bindCallback` 函数也可以创建一个可观察对象，它会迭代回调的参数：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding example uses the `node-fetch` module because the fetch function
    is not available in Node.js. You can install the `node-fetch` module using the
    following `npm` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了 `node-fetch` 模块，因为 Node.js 中没有 `fetch` 函数。您可以使用以下 `npm` 命令安装 `node-fetch`
    模块：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `getJSON` function takes a URL and a callback as its arguments. When we
    pass it to the `bindCallback` function, a new function is returned. The new function takes
    a URL as its only argument and returns an observable instead of taking a callback.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`getJSON` 函数接受一个 URL 和一个回调作为其参数。当我们将其传递给 `bindCallback` 函数时，会返回一个新的函数。这个新函数只接受一个
    URL 作为其唯一参数，并返回一个可观察对象，而不是接受一个回调。'
- en: 'In Node.js, callbacks follow a well-defined pattern. The Node.js callbacks
    take two arguments, `error` and `result`, and don''t throw exceptions. We must
    use the `error` argument to check whether something went wrong instead of a `try`/`catch`
    statement. RxJS also defines a function named `bindNodeCallback` that allows us
    to work with the callbacks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，回调遵循一个明确的模式。Node.js 回调接受两个参数，`error` 和 `result`，并且不会抛出异常。我们必须使用
    `error` 参数来检查是否出错，而不是使用 `try`/`catch` 语句。RxJS 还定义了一个名为 `bindNodeCallback` 的函数，允许我们与回调一起工作：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The helpers, `bindCallback` and `bindNodeCallback`, have very similar behavior,
    but the second has been specially designed to work with Node.js callbacks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数 `bindCallback` 和 `bindNodeCallback` 有非常相似的行为，但第二个是专门设计来与 Node.js 回调一起工作的。
- en: Creating observables from promises
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从承诺创建可观察对象
- en: 'Another potential source of items for an observable sequence is a `Promise`.
    RxJS also allows us to handle this use case with the `from` function. We must
    pass a `Promise` instance to the `from` function. In the following example, we
    use the `fetch` function to send an HTTP request. The `fetch` function returns
    a promise that is passed to the `from` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象序列的项目来源的另一个潜在来源是 `Promise`。RxJS 还允许我们使用 `from` 函数处理此用例。我们必须将 `Promise`
    实例传递给 `from` 函数。在下面的示例中，我们使用 `fetch` 函数发送 HTTP 请求。`fetch` 函数返回一个承诺，该承诺被传递给 `from`
    函数：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The generated observable will contain the result of the promise as its only
    item.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可观察对象将只包含承诺的结果作为其唯一项目。
- en: Cold and hot observables
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷和热可观察对象
- en: 'The official RxJS documentation explores the differences between cold and hot
    observables as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 RxJS 文档如下探讨了冷和热可观察对象之间的差异：
- en: '"Cold observables start running upon subscription, that is, the observable
    sequence only starts pushing values to the observers when Subscribe is called.
    Values are also not shared among subscribers. This is different from hot observables,
    such as mouse move events or stock tickers, which are already producing values
    even before a subscription is active. When an observer subscribes to a hot observable
    sequence, it will get all values in the stream that are emitted after it subscribes.
    The hot observable sequence is shared among all subscribers, and each subscriber
    is pushed the next value in the sequence."'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"冷可观察对象在订阅时开始运行，也就是说，只有当调用Subscribe时，可观察对象序列才开始向观察者推送值。值也不会在订阅者之间共享。这与热可观察对象不同，例如鼠标移动事件或股票行情，它们在订阅活动之前就已经开始产生值。当观察者订阅一个热可观察对象序列时，它将获得订阅后发出的所有流值。热可观察对象序列在所有订阅者之间共享，并且每个订阅者都会收到序列中的下一个值。"'
- en: It is important to understand these differences if we want to have control over
    the execution flow of our components. The key point to remember is that cold observables
    are lazily evaluated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要控制组件的执行流程，理解这些区别是很重要的。关键点是要记住冷可观察对象是惰性评估的。
- en: Working with operators
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作符
- en: In this section, we are going to learn how to use some functions known as operators,
    which allow us to manipulate observables in many different ways.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用一些称为操作符的函数，这些函数允许我们以许多不同的方式操作可观察对象。
- en: Pipe
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pipe
- en: In RxJS, observables have a method named `pipe`, which is very similar to the
    pipe operator in functional programming. When we pipe two functions, we generate
    a new function that passes the return of the first function as arguments to the
    second function in the pipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS中，可观察对象有一个名为`pipe`的方法，这与函数式编程中的管道操作符非常相似。当我们连接两个函数时，我们生成一个新的函数，该函数将第一个函数的返回值作为参数传递给管道中的第二个函数。
- en: The idea is very similar in reactive programming. When we pipe an observable
    through an operator, we generate a new observable. The new observable passes each
    of the items in the original observable to an operator that transforms them into
    the items in the new sequence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，这个想法非常相似。当我们通过一个操作符将一个可观察对象管道化时，我们生成一个新的可观察对象。新的可观察对象将原始可观察对象中的每个项目传递给一个操作符，该操作符将它们转换为新序列中的项目。
- en: We are not going to include a code example here, because we are going to use
    the pipe method multiple times during the remaining part of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会包含代码示例，因为在本章的剩余部分，我们将多次使用`pipe`方法。
- en: Max
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Max
- en: 'The `max` operator function can be used to find the biggest value in an observable.
    We must apply the `max` operator using the `pipe` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`操作符函数可以用来在一个可观察对象中找到最大值。我们必须使用`pipe`方法来应用`max`操作符：'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following marble diagram showcases the initial sequence and the result
    sequence after applying the `max` operator:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的弹珠图展示了应用`max`操作符之前的初始序列和应用`max`操作符之后的结果序列：
- en: '![](img/b447b334-12c9-495b-abe7-c9a06397777d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b447b334-12c9-495b-abe7-c9a06397777d.png)'
- en: The result sequence contains only one value (the biggest value in the original
    sequence).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一个值（原始序列中的最大值）。
- en: Every
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Every
- en: 'The `every` operator function can be used to test whether all the values in
    an observable adhere to a given requirement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`every`操作符函数可以用来测试一个可观察对象中的所有值是否都符合给定的要求：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code snippet uses the `every` operator to test that all the values
    in an observable are lower than ten. The following marble diagram showcases the
    initial sequence and the result sequence after applying the `every` operator:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段使用了`every`操作符来测试一个可观察对象中的所有值是否都低于十。下面的弹珠图展示了应用`every`操作符之前的初始序列和应用`every`操作符之后的结果序列：
- en: '![](img/51541bb3-4fc4-4492-932c-7315ad70c4cc.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51541bb3-4fc4-4492-932c-7315ad70c4cc.png)'
- en: The result sequence contains only one value (true or false).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一个值（true或false）。
- en: Find
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Find
- en: 'The `find` operator function can be used to find the first value in an observable
    that adheres to a given constraint:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`操作符函数可以用来查找一个可观察对象中符合给定约束的第一个值：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet uses the `find` operator to find the first value
    in an observable greater than ten. The following marble diagram showcases the
    initial sequence and the result sequence after applying the `find` operator:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段使用了`find`操作符来查找一个可观察对象中大于十的第一个值。下面的弹珠图展示了应用`find`操作符之前的初始序列和应用`find`操作符之后的结果序列：
- en: '![](img/a60c397d-6adc-49f7-967d-28774443498a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a60c397d-6adc-49f7-967d-28774443498a.png)'
- en: The result sequence contains only one value (the first value in the stream that
    matches the given constraint).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一个值（符合给定约束的流中的第一个值）。
- en: Filter
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Filter
- en: 'The `filter` operator function can be used to find the values in an observable
    that adhere to a given constraint:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`运算符函数可以用来找到符合给定约束的可观察对象中的值：'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code snippet uses the `filter` operator to find the values in
    an observable greater than ten. The following marble diagram showcases the initial
    sequence and the result sequence after applying the `filter` operator:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`filter`运算符来找到大于十的观察对象中的值。以下是大理石图，展示了应用`filter`运算符后的初始序列和结果序列：
- en: '![](img/13821276-63f2-45b5-b68f-0699900f5a68.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13821276-63f2-45b5-b68f-0699900f5a68.png)'
- en: The result sequence contains only some values (the values in the stream that
    match the given constraint).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一些值（与给定约束匹配的流中的值）。
- en: Map
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: 'The `map` operator function can be used to transform the values in an observable
    into derived values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`运算符函数可以用来将可观察对象中的值转换为派生值：'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code snippet uses the `map` operator to transform the values
    in an observable into new values (the original value multiplied by ten). The following
    marble diagram showcases the initial sequence and the result sequence after applying
    the `map` operator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`map`运算符将观察对象中的值转换为新的值（原始值乘以十）。以下是大理石图，展示了应用`map`运算符后的初始序列和结果序列：
- en: '![](img/e05cb0a1-68f9-40fb-a0d6-1f66366e5f33.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e05cb0a1-68f9-40fb-a0d6-1f66366e5f33.png)'
- en: The result sequence contains a new mapped value for each value in the original
    sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列包含原始序列中每个值的新的映射值。
- en: Reduce
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reduce
- en: 'The `reduce` operator function can be used to transform all the values in an
    observable into one single value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`运算符函数可以用来将可观察对象中的所有值转换为一个单一值：'
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code snippet uses the `reduce` operator to transform the values
    in an observable into a new single value (the total of all the values). The function
    that transforms multiple values into one single value is known as an accumulator.
    The following marble diagram showcases the initial sequence and the result sequence
    after applying the `reduce` operator:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`reduce`运算符将观察对象中的值转换为一个新单一值（所有值的总和）。将多个值转换为一个单一值的函数称为累加器。以下是大理石图，展示了应用`reduce`运算符后的初始序列和结果序列：
- en: '![](img/a26f8f43-33ec-4f9b-9abd-5c554fe06553.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a26f8f43-33ec-4f9b-9abd-5c554fe06553.png)'
- en: The result sequence contains only one value (the result of the accumulator).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一个值（累加器的结果）。
- en: Throttle
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Throttle
- en: 'The `throttle` operator function can be used to reduce the number of values
    that are added to an observable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle`运算符函数可以用来减少添加到可观察对象中的值的数量：'
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code snippet creates an observable for `click` events. Every click
    will add an item to the sequence. The example also uses the `pipe` method and
    the `mapTo` function to map all the click events to the numeric value `1`. It
    is then when we use the `throttle` operator to reduce the number of values that
    are added to the sequence. If two or more click events take place within a time
    interval lower than the one declared by the interval, only the first value will
    be added to the sequence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段创建了一个用于`click`事件的观察对象。每次点击都会向序列中添加一个项目。示例还使用了`pipe`方法和`mapTo`函数将所有点击事件映射到数值`1`。然后我们使用`throttle`运算符来减少添加到序列中的值的数量。如果在小于声明的时间间隔内发生两个或多个点击事件，则只有第一个值将被添加到序列中。
- en: Please note that the preceding example can only be executed in a web browser.
    To execute the preceding code in a web browser, you will need to use a module
    bundler such as Webpack. We will not cover this topic because it is beyond the
    scope of this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例只能在网页浏览器中执行。要在网页浏览器中执行前面的代码，您需要使用模块打包器，例如Webpack。我们不会涉及这个主题，因为它超出了本书的范围。
- en: 'The following marble diagram showcases the initial sequence and the result
    sequence after applying the `reduce` operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下大理石图展示了应用`reduce`运算符后的初始序列和结果序列：
- en: '![](img/f5607f7c-ffa3-48c2-b189-534720121053.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5607f7c-ffa3-48c2-b189-534720121053.png)'
- en: The result sequence only contains some values because the values that take place
    too close in time are ignored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列只包含一些值，因为时间上过于接近的值被忽略了。
- en: Merge
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Merge
- en: 'The `merge` operator function can be used to merge the values of two observables
    into value pairs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `merge` 操作符函数将两个可观察对象的值合并成值对：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code snippet uses the `merge` operator to combine the values
    of two observables into a new observable. The values are ordered chronologically.
    The following marble diagram showcases the initial sequences and the result sequence
    after applying the `merge` operator:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段使用了 `merge` 操作符将两个可观察对象的值合并到一个新的可观察对象中。这些值按时间顺序排列。以下的水晶图展示了应用 `merge`
    操作符之前的初始序列和结果序列：
- en: '![](img/b02ed865-4487-49a5-bc24-3690f618cdc6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b02ed865-4487-49a5-bc24-3690f618cdc6.png)'
- en: The result sequence contains the values of both observables ordered in the same
    sequence as they took place in time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列包含两个可观察对象的时间顺序中的值，并按其发生的时间顺序排列。
- en: Zip
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zip
- en: 'The `zip` operator function can be used to merge the values of two observables
    into value pairs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `zip` 操作符函数将两个可观察对象的值合并成值对：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet uses the `zip` operator to combine the values of
    two observables into a new observable. The values in the new observable are value
    pairs that contain a value from the first observable and a value from the second
    observable and are grouped by their index in the sequence. The following marble
    diagram showcases the initial sequences and the result sequence after applying
    the `zip` operator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段使用了 `zip` 操作符将两个可观察对象的值合并到一个新的可观察对象中。新可观察对象中的值是包含来自第一个可观察对象的值和来自第二个可观察对象的值的值对，并且按其在序列中的索引分组。以下的水晶图展示了应用
    `zip` 操作符之前的初始序列和结果序列：
- en: '![](img/a7e246ce-1a59-46d5-9e6e-d0eb1f2a58a4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7e246ce-1a59-46d5-9e6e-d0eb1f2a58a4.png)'
- en: The result sequence contains the values of both observables merged into single
    value pairs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果序列包含合并成单个值对的两个可观察对象的值。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the functional-reactive programming paradigm.
    We have learned that many of the functional programming ideas, such as pure functions
    and function composition, can be applied to reactive programming. We also learned
    what observables are and how we can create them and work with them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数式反应式编程范式。我们了解到许多函数式编程思想，如纯函数和函数组合，可以应用于反应式编程。我们还学习了什么是可观察对象，以及我们如何创建它们并与之交互。
- en: In the next chapter, we are going to learn about some production-ready functional
    programming libraries, such as Ramda and Immutable.js.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些生产就绪的函数式编程库，例如 Ramda 和 Immutable.js。
