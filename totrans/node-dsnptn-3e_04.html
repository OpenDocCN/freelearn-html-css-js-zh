<html><head></head><body>
  <div><h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-97" class="chapterTitle">Asynchronous Control Flow Patterns with Callbacks</h1>
    <p class="normal">Moving from a synchronous programming style to a platform such as Node.js, where <strong class="keyword">continuation-passing style</strong> (<strong class="keyword">CPS</strong>) and asynchronous APIs are the norm, can be frustrating. Asynchronous code can make it hard to predict the order in which statements are executed. Simple problems such as iterating over a set of files, executing tasks in sequence, or waiting for a set of operations to complete require the developer to take on new approaches and techniques just to avoid ending up writing inefficient and unreadable code. When using callbacks to deal with asynchronous control flow, the most common mistake is to fall into the trap of callback hell and see the code growing horizontally, rather than vertically, with a nesting that makes even simple routines hard to read and maintain.</p>
    <p class="normal">In this chapter, you will see how it's actually possible to tame callbacks and write clean, manageable asynchronous code by using some discipline and with the aid of some patterns. Knowing how to properly deal with callbacks will pave the way for adopting modern approaches such as promises and async/await.</p>
    <p class="normal">In short, in this chapter, you will learn about:</p>
    <ul>
      <li class="Bullet--PACKT-">The challenges of asynchronous programming.</li>
      <li class="Bullet--PACKT-">Avoiding callback hell and other callback best practices.</li>
      <li class="Bullet-End--PACKT-">Common asynchronous patterns such as sequential execution, sequential iteration, parallel execution, and limited parallel execution.</li>
    </ul>
    <h1 id="_idParaDest-98" class="title">The difficulties of asynchronous programming</h1>
    <p class="normal">Losing control <a id="_idIndexMarker253"/>of asynchronous code in JavaScript is undoubtedly easy. Closures and in-place definitions of anonymous functions allow for a smooth programming experience that doesn't require the developer to jump to other points in the codebase. This is perfectly in line with the <strong class="keyword">KISS</strong> principle (<strong class="keyword">Keep It Simple, Stupid</strong>); it's simple, it keeps the <a id="_idIndexMarker254"/>code flowing, and we get it working in less time. Unfortunately, sacrificing qualities such as modularity, reusability, and maintainability will, sooner or later, lead to the uncontrolled proliferation of callback nesting, functions growing in size, and poor code organization. Most of the time, creating callbacks as in-place functions is not strictly required, so it's more a matter of discipline than a problem related to asynchronous programming. Recognizing that our code is becoming unwieldy or, even better, knowing in advance that it might become unwieldy and then acting accordingly with the most adequate solution, is what differentiates a novice from an expert.</p>
    <h2 id="_idParaDest-99" class="title">Creating a simple web spider</h2>
    <p class="normal">To explain this problem, we will <a id="_idIndexMarker255"/>create a little web spider, a command-line application that takes in a web URL as input and downloads its contents locally into a file. In the code presented in this chapter, we are going to use a couple of npm dependencies:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">superagent</code>: A library to<a id="_idIndexMarker256"/> streamline HTTP calls (<a href="http://nodejsdp.link/superagent">nodejsdp.link/superagent</a>)</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">mkdirp</code>: A small <a id="_idIndexMarker257"/>utility to create directories recursively (<a href="http://nodejsdp.link/mkdirp">nodejsdp.link/mkdirp</a>)</li>
    </ul>
    <p class="normal">Also, we will often refer to a local module named <code class="Code-In-Text--PACKT-">./utils.js</code>, which contains some helpers that we will be using in our application. We will omit the contents of this file for brevity, but you can find the full implementation, along with a <code class="Code-In-Text--PACKT-">package.json</code> file containing the full list of dependencies, in the official repository at <a href="http://nodejsdp.link/repo">nodejsdp.link/repo</a>.</p>
    <p class="normal">The core functionality of our application is contained inside a module named <code class="Code-In-Text--PACKT-">spider.js</code>. Let's see how it looks. To start with, let's load all the dependencies that we are going to use:</p>
    <pre class="programlisting code"><code class="hljs-code">import fs from 'fs'
import path from 'path'
import superagent from 'superagent'
import mkdirp from 'mkdirp'
import { urlToFilename } from './utils.js'
</code></pre>
    <p class="normal">Next, let's create a new function named <code class="Code-In-Text--PACKT-">spider()</code>, which takes in the URL to download and a callback function that will be invoked when the download process completes:</p>
    <pre class="programlisting code"><code class="hljs-code">export function spider (url, cb) {
  const filename = urlToFilename(url)
  fs.access(filename, err =&gt; {                                // (1)
    if (err &amp;&amp; err.code === 'ENOENT') {
      console.log(`Downloading ${url} into ${filename}`)
      superagent.get(url).end((err, res) =&gt; {                 // (2)
        if (err) {
          cb(err)
        } else {
          mkdirp(path.dirname(filename), err =&gt; {             // (3)
            if (err) {
              cb(err)
            } else {
              fs.writeFile(filename, res.text, err =&gt; {       // (4)
                if (err) {
                  cb(err)
                } else {
                  cb(null, filename, true)
                }
              })
            }
          })
        }
      })
    } else {
      cb(null, filename, false)
    }
  })
}
</code></pre>
    <p class="normal">There is a lot going on here, so let's<a id="_idIndexMarker258"/> discuss in more detail what happens in every step:</p>
    <ol>
      <li class="numbered">The code checks whether the URL was already downloaded by verifying that the corresponding file was not already created. If <code class="Code-In-Text--PACKT-">err</code> is defined and has type <code class="Code-In-Text--PACKT-">ENOENT</code>, then the file does not exist and it's safe to create it:
        <pre class="programlisting code"><code class="hljs-code">fs.access(filename, err =&gt; ...
</code></pre>
      </li>
      <li class="numbered">If the file is not found, the URL is downloaded using the following line of code:
        <pre class="programlisting code"><code class="hljs-code">superagent.get(url).end((err, res) =&gt; ...
</code></pre>
      </li>
      <li class="numbered">Then, we make sure that the directory that will contain the file exists:
        <pre class="programlisting code"><code class="hljs-code">mkdirp(path.dirname(filename), err =&gt; ...
</code></pre>
      </li>
      <li class="numbered">Finally, we write the body of the HTTP response to the filesystem:
        <pre class="programlisting code"><code class="hljs-code">fs.writeFile(filename, res.text, err =&gt; ...
</code></pre>
      </li>
    </ol>
    <p class="normal">To complete our web spider application, we just need to invoke the <code class="Code-In-Text--PACKT-">spider()</code> function by providing a URL as an input (in our case, we read it from the command-line arguments). The <code class="Code-In-Text--PACKT-">spider()</code> function is exported from the file we defined previously. Let's now create a new file called <code class="Code-In-Text--PACKT-">spider-cli.js</code> that can be directly invoked from the command line:</p>
    <pre class="programlisting code"><code class="hljs-code">import { spider } from './spider.js'
spider(process.argv[2], (err, filename, downloaded) =&gt; {
  if (err) {
    console.error(err)
  } else if (downloaded) {
    console.log(`Completed the download of "${filename}"`)
  } else {
    console.log(`"${filename}" was already downloaded`)
  }
})
</code></pre>
    <p class="normal">Now, we are ready to try our web spider application, but first, make sure you have the <code class="Code-In-Text--PACKT-">utils.js</code> module and the <code class="Code-In-Text--PACKT-">package.json</code> file containing the full list of dependencies in your <code class="Code-In-Text--PACKT-">project</code> directory. Then, install all the dependencies by running the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install
</code></pre>
    <p class="normal">Now, let's execute the <code class="Code-In-Text--PACKT-">spider-cli.js</code> module to download the contents of a web page with a command like this:</p>
    <pre class="programlisting con"><code class="hljs-con">node spider-cli.js http://www.example.com
</code></pre>
    <div><p class="Information-Box--PACKT-">Our web spider application requires that we always include the protocol (for example, <code class="Code-In-Text--PACKT-">http://</code>) in the URL we provide. Also, do not expect HTML links to be rewritten or resources such as images to be downloaded, as this is just a simple example to demonstrate how asynchronous programming works.</p>
    </div>
    <p class="normal">In the next section, you will learn how to improve the readability of this code and, in general, how to keep callback-based code as clean and readable as possible.</p>
    <h2 id="_idParaDest-100" class="title">Callback hell</h2>
    <p class="normal">Looking at the <code class="Code-In-Text--PACKT-">spider()</code> function we defined earlier, you will likely notice that even though the algorithm we implemented is really straightforward, the resulting code has several levels of indentation and is very hard to read. Implementing a similar function with a direct style blocking API would be straightforward, and most likely, the code would be much more readable. However, using asynchronous CPS is another story, and making bad use of in-place callback definitions can lead to incredibly bad code.</p>
    <p class="normal">The situation where the abundance of <a id="_idIndexMarker259"/>closures and in-place callback definitions transforms the code into an unreadable and unmanageable blob is known as <strong class="keyword">callback hell</strong>. It's one of the most widely recognized and severe anti-patterns in Node.js and JavaScript in general. The typical structure of code affected by this problem looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">asyncFoo(err =&gt; {
  asyncBar(err =&gt; {
    asyncFooBar(err =&gt; {
      //...
    })
  })
})
</code></pre>
    <p class="normal">You can see how code written in this way assumes the shape of a pyramid due to deep nesting, and that's why it is also colloquially known as<a id="_idIndexMarker260"/> the <strong class="keyword">pyramid of doom</strong>.</p>
    <p class="normal">The most evident problem with code such as the preceding snippet is its poor readability. Due to the nesting being so deep, it's almost impossible to keep track of where a function ends and where another one begins.</p>
    <p class="normal">Another issue is caused by the overlapping of the variable names used in each scope. Often, we have to use similar or even identical names to describe the content of a variable. The best example is the error argument received by each callback. Some people often try to use variations of the same name to differentiate the object in each scope, for example, <code class="Code-In-Text--PACKT-">err</code>, <code class="Code-In-Text--PACKT-">error</code>, <code class="Code-In-Text--PACKT-">err1</code>, <code class="Code-In-Text--PACKT-">err2</code>, and so on. Others prefer to just shadow the variable defined in the upper scope by always using the same name, for example, <code class="Code-In-Text--PACKT-">err</code>. Both alternatives are far from perfect, and cause confusion and increase the probability of introducing defects.</p>
    <p class="normal">Also, we have to keep in <a id="_idIndexMarker261"/>mind that closures come at a small price in terms of performance and memory consumption. In addition, they can create memory leaks that are not very easy to identify. In fact, we shouldn't forget that any context referenced by an active closure is retained from garbage collection.</p>
    <div><p class="Information-Box--PACKT-">For a great introduction to how closures work in V8, you can refer to the following blog post by Vyacheslav Egorov, a software engineer at Google working on V8, which you can read at <a href="http://nodejsdp.link/v8-closures">nodejsdp.link/v8-closures</a>.</p>
    </div>
    <p class="normal">If you look at our <code class="Code-In-Text--PACKT-">spider()</code> function, you will notice that it clearly represents a callback hell situation and has all the problems just described. That's exactly what we are going to fix with the patterns and techniques that are covered in the following sections of this chapter.</p>
    <h1 id="_idParaDest-101" class="title">Callback best practices and control flow patterns</h1>
    <p class="normal">Now that you have met your <a id="_idIndexMarker262"/>first example of callback hell, you know what you should definitely avoid; however, that's not the only concern when writing asynchronous code. In fact, there are several situations where controlling the flow of a set of asynchronous tasks requires the use of specific patterns and techniques, especially if we are only using plain <a id="_idIndexMarker263"/>JavaScript without the aid of any external library. For example, iterating over a collection by applying an asynchronous operation in sequence is not as easy as invoking <code class="Code-In-Text--PACKT-">forEach()</code> over an array; it actually requires a technique similar to recursion.</p>
    <p class="normal">In this section, you will learn not only about how to avoid callback hell, but also how to implement some of the most common control flow patterns, using only simple and plain JavaScript.</p>
    <h2 id="_idParaDest-102" class="title">Callback discipline</h2>
    <p class="normal">When <a id="_idIndexMarker264"/>writing asynchronous code, the first rule to keep in mind is to not abuse in-place function definitions when defining callbacks. It can be tempting to do so, because it does not require any additional thinking for problems such as modularization and reusability; however, you have seen how this can have more disadvantages than advantages. Most of the time, fixing the callback hell problem does not require any libraries, fancy techniques, or changes of paradigm; you just need some common sense.</p>
    <p class="normal">These are some basic principles that can help us keep the nesting level low and improve the organization of our code in general:</p>
    <ul>
      <li class="Bullet--PACKT-">Exit as soon as possible. Use <code class="Code-In-Text--PACKT-">return</code>, <code class="Code-In-Text--PACKT-">continue</code>, or <code class="Code-In-Text--PACKT-">break</code>, depending on the context, to immediately exit the current statement instead of writing (and nesting) complete <code class="Code-In-Text--PACKT-">if...else</code> statements. This will help to keep our code shallow.</li>
      <li class="Bullet--PACKT-">Create named<a id="_idIndexMarker265"/> functions for callbacks, keeping them out of closures and passing intermediate results as arguments. Naming our functions will also make them look better in stack traces.</li>
      <li class="Bullet-End--PACKT-">Modularize the code. Split the code into smaller, reusable functions whenever possible.</li>
    </ul>
    <p class="normal">Now, let's put these principles into practice.</p>
    <h2 id="_idParaDest-103" class="title">Applying the callback discipline</h2>
    <p class="normal">To demonstrate the power of the<a id="_idIndexMarker266"/> ideas mentioned in the previous section, let's apply them to fix the callback hell in our web spider application.</p>
    <p class="normal">For the first step, we can refactor our error-checking pattern by removing the <code class="Code-In-Text--PACKT-">else</code> statement. This is made possible by returning from the function immediately after we receive an error. So, instead of having code such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">if (err) {
  cb(err)
} else {
  // code to execute when there are no errors
}
</code></pre>
    <p class="normal">We can improve the organization of our code by writing the following instead:</p>
    <pre class="programlisting code"><code class="hljs-code">if (err) {
  return cb(err)
}
// code to execute when there are no errors
</code></pre>
    <p class="normal">This is often referred <a id="_idIndexMarker267"/>to as the <strong class="keyword">early return principle</strong>. With this simple trick, we immediately have a reduction in the nesting level of our functions. It is easy and doesn't require any complex refactoring.</p>
    <div><p class="Information-Box--PACKT-">A common mistake when executing the optimization just described is forgetting to terminate the function after the callback is invoked. For an error-handling scenario, the following code is a typical source of defects:</p>
      <pre class="programlisting code"><code class="hljs-code">if (err) {
  callback(err)
}
// code to execute when there are no errors.
</code></pre>
      <p class="Information-Box--PACKT-">We should never forget that the execution of our function will continue even after we invoke the callback. It is then important to insert a <code class="Code-In-Text--PACKT-">return</code> instruction to block the execution of the rest of the function. Also, note that it doesn't really matter what value is returned by the function; the real result (or error) is produced asynchronously and passed to the callback. The return value of the asynchronous function is usually ignored. This property allows us to write shortcuts such as the following:</p>
      <pre class="programlisting code"><code class="hljs-code">return callback(...)
</code></pre>
      <p class="Information-Box--PACKT-">Otherwise, we'd have to write slightly more verbose code, such as the following:</p>
      <pre class="programlisting code"><code class="hljs-code">callback(...)
return
</code></pre>
    </div>
    <p class="normal">As a second<a id="_idIndexMarker268"/> optimization for our <code class="Code-In-Text--PACKT-">spider()</code> function, we can try to identify reusable pieces of code. For example, the functionality that writes a given string to a file can be easily factored out into a separate function, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">function saveFile (filename, contents, cb) {
  mkdirp(path.dirname(filename), err =&gt; {
    if (err) {
      return cb(err)
    }
    fs.writeFile(filename, contents, cb)
  })
}
</code></pre>
    <p class="normal">Following the same principle, we can create a generic function named <code class="Code-In-Text--PACKT-">download()</code> that takes a URL and a filename as input, and downloads the URL into the given file. Internally, we can use the <code class="Code-In-Text--PACKT-">saveFile()</code> function we created earlier:</p>
    <pre class="programlisting code"><code class="hljs-code">function download (url, filename, cb) {
  console.log(`Downloading ${url}`)
  superagent.get(url).end((err, res) =&gt; {
    if (err) {
      return cb(err)
    }
    saveFile(filename, res.text, err =&gt; {
      if (err) {
        return cb(err)
      }
      console.log(`Downloaded and saved: ${url}`)
      cb(null, res.text)
    })
  })
}
</code></pre>
    <p class="normal">For the last step, we<a id="_idIndexMarker269"/> modify the <code class="Code-In-Text--PACKT-">spider()</code> function, which, thanks to our changes, will now look like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">export function spider (url, cb) {
  const filename = urlToFilename(url)
  fs.access(filename, err =&gt; {
    if (!err || err.code !== 'ENOENT') {   // (1)
      return cb(null, filename, false)
    }
    download(url, filename, err =&gt; {
      if (err) {
        return cb(err)
      }
      cb(null, filename, true)
    })
  })
}
</code></pre>
    <p class="normal">The functionality and the interface of the <code class="Code-In-Text--PACKT-">spider()</code> function remained exactly the same; what changed was the way the code was organized. One important detail to notice (1) is that we inverted the check for the file's existence so that we could apply the <em class="italic">early return principle</em> discussed previously.</p>
    <p class="normal">By applying the early return principle and the other callback discipline principles, we were able to drastically reduce the nesting of our code and, at the same time, increase its reusability and testability. In fact, we could think about exporting both <code class="Code-In-Text--PACKT-">saveFile()</code> and <code class="Code-In-Text--PACKT-">download()</code> so that we could reuse them in other modules. This would also allow us to test their functionality as independent units.</p>
    <p class="normal">The refactoring we carried <a id="_idIndexMarker270"/>out in this section clearly demonstrates that most of the time, all we need is some discipline to make sure we do not abuse closures and anonymous functions. It works brilliantly, requires minimal effort, and it doesn't require external libraries.</p>
    <p class="normal">Now that you know how to write clean asynchronous code using callbacks, we are ready to explore some of the most common asynchronous patterns, such as sequential and parallel execution.</p>
    <h2 id="_idParaDest-104" class="title">Sequential execution</h2>
    <p class="normal">In this section, we will look at asynchronous <a id="_idIndexMarker271"/>control flow patterns and start by analyzing the sequential execution flow.</p>
    <p class="normal">Executing a set of tasks in sequence means running them one at a time, one after the other. The order of execution matters and must be preserved, because the result of a task in the list may affect the execution of the next. <em class="italic">Figure 4.1</em> illustrates this concept:</p>
    <figure class="mediaobject"><img src="img/B15729_04_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.1: An example of sequential execution flow with three tasks</p>
    <p class="normal">There are different variations of this flow:</p>
    <ul>
      <li class="Bullet--PACKT-">Executing a set of known tasks in sequence, without propagating data across them.</li>
      <li class="Bullet--PACKT-">Using the output of a task as the input for the next (also known as <em class="italic">chain</em>, <em class="italic">pipeline</em>, or <em class="italic">waterfall</em>).</li>
      <li class="Bullet-End--PACKT-">Iterating over a collection while running an asynchronous task on each element, one after the other.</li>
    </ul>
    <p class="normal">Sequential execution, despite being trivial when implemented using a direct style blocking API, is usually the main cause of the callback hell problem when using asynchronous CPS.</p>
    <h3 id="_idParaDest-105" class="title">Executing a known set of tasks in sequence</h3>
    <p class="normal">We already looked at a sequential execution flow<a id="_idIndexMarker272"/> while implementing the <code class="Code-In-Text--PACKT-">spider()</code> function in the previous section. By applying some simple rules, we were able to organize a set of known tasks in a sequential execution flow. Taking that code as a guideline, we can now generalize the solution with the following pattern:</p>
    <pre class="programlisting code"><code class="hljs-code">function task1 (cb) {
  asyncOperation(() =&gt; {
    task2(cb)
  })
}
function task2 (cb) {
  asyncOperation(() =&gt; {
    task3(cb)
  })
}
function task3 (cb) {
  asyncOperation(() =&gt; {
    cb() // finally executes the callback
  })
}
task1(() =&gt; {
  // executed when task1, task2 and task3 are completed
  console.log('tasks 1, 2 and 3 executed')
})
</code></pre>
    <p class="normal">The preceding pattern shows how each task invokes the next upon completion of a generic asynchronous operation. The pattern puts the emphasis on the modularization of tasks, showing how closures are not always necessary to handle asynchronous code.</p>
    <h3 id="_idParaDest-106" class="title">Sequential iteration</h3>
    <p class="normal">The pattern described in the <a id="_idIndexMarker273"/>previous section works perfectly if we know in advance what and how many tasks are to be executed. This allows us to hardcode the invocation of the next task in the sequence, but what happens if we want to execute an asynchronous operation for each item in a collection? In cases such as this, we can't hardcode the task sequence anymore; instead, we have to build it dynamically.</p>
    <h4 class="title">Web spider version 2</h4>
    <p class="normal">To show an example <a id="_idIndexMarker274"/>of sequential iteration, let's introduce a new feature to the web spider application. We now want to download all the links contained in a web page recursively. To do that, we are going to extract all the links from the page and then trigger our web spider on each recursively and in sequence.</p>
    <p class="normal">The first step is modifying our <code class="Code-In-Text--PACKT-">spider()</code> function so that it triggers a recursive download of all the links of a page by using a function named <code class="Code-In-Text--PACKT-">spiderLinks()</code>, which we are going to create shortly.</p>
    <p class="normal">Also, instead of checking whether the file already exists, we will try to read it and start spidering its links. This way, we will be able to resume interrupted downloads. As a final change, we need to make sure we propagate a new parameter, <code class="Code-In-Text--PACKT-">nesting</code>, which will help us to limit the recursion depth. The code is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">export function spider (url, nesting, cb) {
  const filename = urlToFilename(url)
  fs.readFile(filename, 'utf8', (err, fileContent) =&gt; {
    if (err) {
      if (err.code !== 'ENOENT') {
        return cb(err)
      }
      // The file doesn't exist, so let's download it
      return download(url, filename, (err, requestContent) =&gt; {
        if (err) {
          return cb(err)
        }
        spiderLinks(url, requestContent, nesting, cb)
      })
    }
    // The file already exists, let's process the links
    spiderLinks(url, fileContent, nesting, cb)
  })
}
</code></pre>
    <p class="normal">In the next section, we will explore how the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function can be implemented.</p>
    <h4 class="title">Sequential crawling of links</h4>
    <p class="normal">Now, we<a id="_idIndexMarker275"/> can create the core of this <a id="_idIndexMarker276"/>new version of our web spider application, the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function, which downloads all the links of an HTML page using a sequential asynchronous iteration algorithm. Pay attention to the way we are going to define that in the following code block:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, body, nesting, cb) {
  if (nesting === 0) {
    // Remember Zalgo from chapter 3?
    return process.nextTick(cb)
  }
  const links = getPageLinks(currentUrl, body)            // (1)
  if (links.length === 0) {
    return process.nextTick(cb)
  }
  function iterate (index) {                              // (2)
    if (index === links.length) {
      return cb()
    }
    spider(links[index], nesting - 1, function (err) {    // (3)
      if (err) {
        return cb(err)
      }
      iterate(index + 1)
    })
  }
  iterate(0)                                              // (4)
}
</code></pre>
    <p class="normal">The important steps to<a id="_idIndexMarker277"/> understand from this new function are as follows:</p>
    <ol>
      <li class="numbered">We obtain the list of all the links <a id="_idIndexMarker278"/>contained in the page using the <code class="Code-In-Text--PACKT-">getPageLinks()</code> function. This function returns only the links pointing to an internal destination (the same hostname).</li>
      <li class="numbered">We iterate over the links using a local function called <code class="Code-In-Text--PACKT-">iterate()</code>, which takes the <code class="Code-In-Text--PACKT-">index</code> of the next link to analyze. In this function, the first thing we do is check whether the <code class="Code-In-Text--PACKT-">index</code> is equal to the length of the <code class="Code-In-Text--PACKT-">links</code> array, in which case we immediately invoke the <code class="Code-In-Text--PACKT-">cb()</code> function, as it means we have processed all the items.</li>
      <li class="numbered">At this point, everything should be ready for processing the link. We invoke the <code class="Code-In-Text--PACKT-">spider()</code> function by decreasing the nesting level and invoking the next step of the iteration when the operation completes.</li>
      <li class="numbered">As the last step in the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function, we bootstrap the iteration by invoking <code class="Code-In-Text--PACKT-">iterate(0)</code>.</li>
    </ol>
    <p class="normal">The algorithm that was just presented allows us to iterate over an array by executing an asynchronous operation in sequence, which in our case is the <code class="Code-In-Text--PACKT-">spider()</code> function.</p>
    <p class="normal">Finally, we can change our <code class="Code-In-Text--PACKT-">spider-cli.js</code> a bit so that we can specify the nesting level as an additional command-line interface (CLI) argument:</p>
    <pre class="programlisting code"><code class="hljs-code">import { spider } from './spider.js'
const url = process.argv[2]
const nesting = Number.parseInt(process.argv[3], 10) || 1
spider(url, nesting, err =&gt; {
  if (err) {
    console.error(err)
    process.exit(1)
  }
  console.log('Download complete')
})
</code></pre>
    <p class="normal">We can now try this new version of the spider application and watch it download all the links of a web page recursively, one after the other. To interrupt the process, which can take a while if there are many links, remember that we can always use Ctrl + C. If we then decide to resume it, we can do so by launching the spider application and providing the same URL we used for<a id="_idIndexMarker279"/> the first <a id="_idIndexMarker280"/>run.</p>
    <div><p class="Information-Box--PACKT-">Now that our web spider application can potentially trigger the download of an entire website, please consider using it carefully. For example, do not set a high nesting level or leave the spider running for more than a few seconds. It is not polite to overload a server with thousands of requests. In some circumstances, this can also be considered illegal. Spider responsibly!</p>
    </div>
    <h4 class="title">The pattern</h4>
    <p class="normal">The <a id="_idIndexMarker281"/>code of the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function from the previous section is a clear example of how it's possible to iterate over a collection while applying an asynchronous operation. You may also notice that it's a pattern that can be adapted to any other situation where we need to iterate asynchronously over the elements of a collection or, in general, over a list of tasks. This pattern can be generalized as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">function iterate (index) {
  if (index === tasks.length) {
    return finish()
  }
  const task = tasks[index]
  task(() =&gt; iterate(index + 1))
}
function finish () {
  // iteration completed
}
iterate(0)
</code></pre>
    <div><p class="Information-Box--PACKT-">It's important to notice that these types of algorithms become really recursive if <code class="Code-In-Text--PACKT-">task()</code> is a synchronous operation. In such a case, the stack will not unwind at every cycle and there might be a risk of hitting the maximum call stack size limit.</p>
    </div>
    <p class="normal">The pattern that was just presented is very powerful and can be extended or adapted to address several<a id="_idIndexMarker282"/> common needs. Just to mention some examples:</p>
    <ul>
      <li class="Bullet--PACKT-">We can map the values of an array asynchronously.</li>
      <li class="Bullet--PACKT-">We can pass the results of an operation to the next one in the iteration to implement an asynchronous version of the <code class="Code-In-Text--PACKT-">reduce</code> algorithm.</li>
      <li class="Bullet--PACKT-">We can quit the loop prematurely if a particular condition is met (asynchronous implementation of the <code class="Code-In-Text--PACKT-">Array.some()</code> helper).</li>
      <li class="Bullet-End--PACKT-">We can even iterate over an infinite number of elements.</li>
    </ul>
    <p class="normal">We could also choose to generalize the solution even further by wrapping it in a function with a signature such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">iterateSeries(collection, iteratorCallback, finalCallback)
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">collection</code> is the actual dataset you want to iterate over, <code class="Code-In-Text--PACKT-">iteratorCallback</code> is the function to execute over every item, and <code class="Code-In-Text--PACKT-">finalCallback</code> is the function that gets executed when all the items are processed or in case of an error. The implementation of this helper function is left to you as an exercise.</p>
    <div><p class="Information-Box--PACKT-"><strong class="screenText">The Sequential Iterator pattern</strong></p>
      <p class="Information-Box--PACKT-">Execute a list of tasks in sequence by creating a function named <code class="Code-In-Text--PACKT-">iterator</code>, which invokes the next available task in the collection and makes sure to invoke the next step of the iteration when the current task completes.</p>
    </div>
    <p class="normal">In the next section, we will explore the parallel execution pattern, which is more convenient when the order of the various tasks is not important.</p>
    <h2 id="_idParaDest-107" class="title">Parallel execution</h2>
    <p class="normal">There are some situations where the<a id="_idIndexMarker283"/> order of execution of a set of asynchronous tasks is not important, and all we want is to be notified when all those running tasks are completed. Such situations are better handled using a parallel execution flow, as shown in <em class="italic">Figure 4.2</em>:</p>
    <figure class="mediaobject"><img src="img/B15729_04_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.2: An example of parallel execution with three tasks</p>
    <p class="normal">This may sound strange if you<a id="_idIndexMarker284"/> consider that Node.js is single-threaded, but if you remember what we discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">The Node.js Platform</em>, you'll realize that even though we have just one thread, we can still achieve concurrency, thanks to the non-blocking nature of Node.js. In fact, the word <em class="italic">parallel</em> is used improperly in this case, as it does not mean that the tasks run simultaneously, but rather that their execution is carried out by an underlying, non-blocking API and interleaved by the event loop.</p>
    <p class="normal">As you know, a task gives control back to the event loop when it requests a new asynchronous operation, allowing the event loop to execute another task. The proper word to use for this kind of flow is <em class="italic">concurrency</em>, but we will still use parallel for simplicity.</p>
    <p class="normal">The following diagram shows how two asynchronous tasks can run in parallel in a Node.js program:</p>
    <figure class="mediaobject"><img src="img/B15729_04_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.3: An example of how asynchronous tasks run in parallel</p>
    <p class="normal">In <em class="italic">Figure 4.3</em>, we have a <strong class="keyword">Main</strong> function that <a id="_idIndexMarker285"/>executes two asynchronous tasks:</p>
    <ol>
      <li class="numbered">The <strong class="keyword">Main</strong> function triggers the execution of <strong class="keyword">Task 1</strong> and <strong class="keyword">Task 2</strong>. As they trigger an asynchronous operation, they immediately return control back to the <strong class="keyword">Main</strong> function, which then returns it to the event loop.</li>
      <li class="numbered">When the asynchronous operation of <strong class="keyword">Task 1</strong> is completed, the event loop gives control to it. When <strong class="keyword">Task 1</strong> completes its internal synchronous processing as well, it notifies the <strong class="keyword">Main</strong> function.</li>
      <li class="numbered">When the asynchronous operation triggered by <strong class="keyword">Task 2</strong> is complete, the event loop invokes its callback, giving control back to <strong class="keyword">Task 2</strong>. At the end of <strong class="keyword">Task 2</strong>, the <strong class="keyword">Main</strong> function is notified once more. At this point, the <strong class="keyword">Main</strong> function knows that both <strong class="keyword">Task 1</strong> and <strong class="keyword">Task 2</strong> are complete, so it can continue its execution or return the results of the operations to another callback.</li>
    </ol>
    <p class="normal">In short, this means that in Node.js, we can only execute asynchronous operations in parallel, because their concurrency is handled internally by the non-blocking APIs. In Node.js, synchronous (blocking) operations can't run concurrently unless their execution is interleaved with an asynchronous operation, or interleaved with <code class="Code-In-Text--PACKT-">setTimeout()</code> or <code class="Code-In-Text--PACKT-">setImmediate()</code>. You will see this in more detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Advanced Recipes</em>.</p>
    <h3 id="_idParaDest-108" class="title">Web spider version 3</h3>
    <p class="normal">Our web spider application <a id="_idIndexMarker286"/>seems like a perfect candidate to apply the concept of parallel execution. So far, our application is executing the recursive download of the linked pages in a sequential fashion. We can easily improve the performance of this process by downloading all the linked pages in parallel.</p>
    <p class="normal">To do that, we just need to modify the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function to make sure we spawn all the <code class="Code-In-Text--PACKT-">spider()</code> tasks at once, and then invoke the final callback only when all of them have completed their execution. So, let's modify our <code class="Code-In-Text--PACKT-">spiderLinks()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, body, nesting, cb) {
  if (nesting === 0) {
    return process.nextTick(cb)
  }
  const links = getPageLinks(currentUrl, body)
  if (links.length === 0) {
    return process.nextTick(cb)
  }
  let completed = 0
  let hasErrors = false
  function done (err) {
    if (err) {
      hasErrors = true
      return cb(err)
    }
    if (++completed === links.length &amp;&amp; !hasErrors) {
      return cb()
    }
  }
  links.forEach(link =&gt; spider(link, nesting - 1, done))
}
</code></pre>
    <p class="normal">Let's discuss what we changed. As mentioned earlier, the <code class="Code-In-Text--PACKT-">spider()</code> tasks are now started all at once. This is possible by simply iterating over the <code class="Code-In-Text--PACKT-">links</code> array and starting each task without waiting for the previous one to finish:</p>
    <pre class="programlisting code"><code class="hljs-code">links.forEach(link =&gt; spider(link, nesting - 1, done))
</code></pre>
    <p class="normal">Then, the trick to make our <a id="_idIndexMarker287"/>application wait for all the tasks to complete is to provide the <code class="Code-In-Text--PACKT-">spider()</code> function with a special callback, which we call <code class="Code-In-Text--PACKT-">done()</code>. The <code class="Code-In-Text--PACKT-">done()</code> function increases a counter when a <code class="Code-In-Text--PACKT-">spider</code> task completes. When the number of completed downloads reaches the size of the <code class="Code-In-Text--PACKT-">links</code> array, the final callback is invoked:</p>
    <pre class="programlisting code"><code class="hljs-code">function done (err) {
  if (err) {
    hasErrors = true
    return cb(err)
  }
  if (++completed === links.length &amp;&amp; !hasErrors) {
    return cb()
  }
}
</code></pre>
    <div><p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">hasErrors</code> variable is necessary because if one parallel task fails, we want to immediately call the callback with the given error. Also, we need to make sure that other parallel tasks that might still be running won't invoke the callback again.</p>
    </div>
    <p class="normal">With these changes in place, if we now try to run our spider against a web page, we will notice a huge improvement in the speed of the overall process, as every download will be carried out in parallel, without waiting for the previous link to be processed.</p>
    <h3 id="_idParaDest-109" class="title">The pattern</h3>
    <p class="normal">Finally, we can extract our<a id="_idIndexMarker288"/> nice little pattern for the parallel execution flow. Let's represent a generic version of the pattern with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">const tasks = [ /* ... */ ]
let completed = 0
tasks.forEach(task =&gt; {
  task(() =&gt; {
    if (++completed === tasks.length) {
      finish()
    }
  })
})
function finish () {
  // all the tasks completed
}
</code></pre>
    <p class="normal">With small modifications, we<a id="_idIndexMarker289"/> can adapt the pattern to accumulate the results of each task into a collection, to filter or map the elements of an array, or to invoke the <code class="Code-In-Text--PACKT-">finish()</code> callback as soon as one or a given number of tasks complete (this last situation in particular <a id="_idIndexMarker290"/>is called <strong class="keyword">competitive race</strong>).</p>
    <div><p class="Information-Box--PACKT-"><strong class="screenText">The Unlimited Parallel Execution pattern</strong></p>
      <p class="Information-Box--PACKT-">Run a set of asynchronous tasks in parallel by launching them all at once, and then wait for all of them to complete by counting the number of times their callbacks are invoked.</p>
    </div>
    <p class="normal">When we have multiple tasks running in parallel, we might have race conditions, that is, contention to access external resources (for example, files or records in a database). In the next section, we will talk about race conditions in Node.js and explore some techniques to identify and address them.</p>
    <h3 id="_idParaDest-110" class="title">Fixing race conditions with concurrent tasks</h3>
    <p class="normal">Running a<a id="_idIndexMarker291"/> set of tasks in parallel can cause issues when <a id="_idIndexMarker292"/>using blocking I/O in combination with multiple threads. However, you have just seen that, in Node.js, this is a totally different story. Running multiple asynchronous tasks in parallel is, in fact, straightforward and cheap in terms of resources. </p>
    <p class="normal">This is one of the most important strengths of Node.js, because it makes parallelization a common practice rather than a complex technique to only use when strictly necessary.</p>
    <p class="normal">Another important characteristic of the concurrency model of Node.js is the way we deal with task synchronization and race conditions. In multithreaded programming, this is usually done using constructs such as locks, mutexes, semaphores, and monitors, and it can be one of the most complex aspects of parallelization, and has a considerable impact on performance. In Node.js, we usually don't need a fancy synchronization mechanism, as everything runs on a single thread. However, this doesn't mean that we can't have race conditions; on the contrary, they can be quite common. The root of the problem is the delay between the invocation of an asynchronous operation and the notification of its result.</p>
    <p class="normal">To see a concrete example, we will refer again to our web spider application, and in particular, the last version we created, which actually contains a race condition (can you spot it?). The problem we are talking about lies in the <code class="Code-In-Text--PACKT-">spider()</code> function, where we check whether a file already exists before we start to download the corresponding URL:</p>
    <pre class="programlisting code"><code class="hljs-code">export function spider (url, nesting, cb) {
  const filename = urlToFilename(url)
  fs.readFile(filename, 'utf8', (err, fileContent) =&gt; {
    if (err) {
      if (err.code !== 'ENOENT') {
        return cb(err)
      }
      return download(url, filename, (err, requestContent) =&gt; {
        // ...
</code></pre>
    <p class="normal">The problem is that <a id="_idIndexMarker293"/>two <code class="Code-In-Text--PACKT-">spider</code> tasks operating on the <a id="_idIndexMarker294"/>same URL might invoke <code class="Code-In-Text--PACKT-">fs.readFile()</code> on the same file before one of the two tasks completes the download and creates a file, causing both tasks to start a download. <em class="italic">Figure 4.4</em> explains this situation:</p>
    <figure class="mediaobject"><img src="img/B15729_04_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.4: An example of a race condition in our spider() function</p>
    <p class="normal"><em class="italic">Figure 4.4</em> shows how <strong class="keyword">Task 1</strong> and <strong class="keyword">Task 2</strong> are interleaved in the single thread of Node.js, as well as how an asynchronous operation can actually introduce a race condition. In our case, the two <code class="Code-In-Text--PACKT-">spider</code> tasks end up downloading the same file.</p>
    <p class="normal">How can we fix that? The answer is much simpler than you might think. In fact, all we need is a variable to mutually exclude multiple <code class="Code-In-Text--PACKT-">spider()</code> tasks running on the same URL. This can be achieved with some code, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code">const spidering = new Set()
function spider (url, nesting, cb) {
  if (spidering.has(url)) {
    return process.nextTick(cb)
  }
  spidering.add(url)
// ...
</code></pre>
    <p class="normal">The fix does not require many comments. We simply exit the function immediately if the given <code class="Code-In-Text--PACKT-">url</code> is already present in the <code class="Code-In-Text--PACKT-">spidering</code> set; otherwise, we add the <code class="Code-In-Text--PACKT-">url</code> to the set and continue with the download. In our case, we don't need to release the lock, as we are not interested in downloading a URL twice, even if the <code class="Code-In-Text--PACKT-">spider</code> tasks are executed at two completely different<a id="_idIndexMarker295"/> points in time. If you are building a <a id="_idIndexMarker296"/>spider that might have to download hundreds of thousands of web pages, removing the downloaded <code class="Code-In-Text--PACKT-">url</code> from the set once a file is downloaded will help you to keep the set cardinality, and therefore the memory consumption, from growing indefinitely.</p>
    <p class="normal">Race conditions can cause many problems, even if we are in a single-threaded environment. In some circumstances, they can lead to data corruption and are usually very hard to debug because of their ephemeral nature. So, it's always good practice to double-check for these types of situations when running tasks in parallel.</p>
    <p class="normal">Also, running an arbitrary number of parallel tasks can be a dangerous practice. In the next section, you will discover why it can be a problem and how to keep the number of parallel tasks under control.</p>
    <h2 id="_idParaDest-111" class="title">Limited parallel execution</h2>
    <p class="normal">Spawning parallel tasks<a id="_idIndexMarker297"/> without control can often lead to excessive load. Imagine having thousands of files to read, URLs to access, or database queries to run in parallel. A common problem in such situations is running out of resources. The most common example is when an application tries to open too many files at once, utilizing all the file descriptors available to the process. </p>
    <p class="normal">A server that spawns unbounded parallel tasks to handle a user request could be <a id="_idIndexMarker298"/>exploited with a <strong class="keyword">denial-of-service</strong> (<strong class="keyword">DoS</strong>) attack. That is when a malicious actor can forge one or more requests to push the server to consume all the available resources and become unresponsive. Limiting the number of parallel tasks is, in general, a good practice that helps with building resilient applications.</p>
    <p class="normal">Version 3 of our web spider<a id="_idIndexMarker299"/> does not limit the number of parallel tasks and therefore, it is susceptible to crashing in a number of cases. For instance, if we try to run it against a significantly big website, we might see it running for a few seconds and then failing with the error code <code class="Code-In-Text--PACKT-">ECONNREFUSED</code>. When we are downloading too many pages concurrently from a web server, the server might decide to start rejecting new connections from the same IP. In this case, our spider would just crash and we would be forced to relaunch the process if we wanted to continue crawling the website. We could just handle <code class="Code-In-Text--PACKT-">ECONNREFUSED</code> to stop the process from crashing, but we would still be risking allocating too many parallel tasks and might run into other issues.</p>
    <p class="normal">In this section, you will see how we can make our spider more resilient by keeping the concurrency limited.</p>
    <p class="normal">The following diagram shows a situation where we have five tasks that run in parallel with a concurrency limit of two:</p>
    <figure class="mediaobject"><img src="img/B15729_04_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 4.5: An example of how concurrency can be limited to a maximum of two parallel tasks</p>
    <p class="normal">From <em class="italic">Figure 4.5</em>, it should be clear how our algorithm works:</p>
    <ol>
      <li class="numbered">Initially, we spawn as many tasks as we can without exceeding the concurrency limit.</li>
      <li class="numbered">Then, every time a task is completed, we spawn one or more tasks until we reach the limit again.</li>
    </ol>
    <p class="normal">In the next section, we will explore a possible implementation of the limited parallel execution pattern.</p>
    <h3 id="_idParaDest-112" class="title">Limiting concurrency</h3>
    <p class="normal">We will now look at a pattern that<a id="_idIndexMarker300"/> will execute a set of given tasks in parallel with limited concurrency:</p>
    <pre class="programlisting code"><code class="hljs-code">const tasks = [
  // ...
]
const concurrency = 2
let running = 0
let completed = 0
let index = 0
function next () {                                          // (1)
  while (running &lt; concurrency &amp;&amp; index &lt; tasks.length) {
    const task = tasks[index++]
    task(() =&gt; {                                            // (2)
      if (++completed === tasks.length) {
        return finish()
      }
      running--
      next()
    })
    running++
  }
}
next()
function finish() {
  // all tasks finished
}
</code></pre>
    <p class="normal">This algorithm can be considered a mixture of sequential execution and parallel execution. In fact, you might notice similarities with both patterns:</p>
    <ol>
      <li class="numbered">We have an iterator function, which we call <code class="Code-In-Text--PACKT-">next()</code>, and then an inner loop that spawns as many tasks as possible in parallel while staying within the concurrency limit.</li>
      <li class="numbered">The next important part is the callback we pass to each task, which checks whether we completed all the tasks in the list. If there are still tasks to run, it invokes <code class="Code-In-Text--PACKT-">next()</code> to spawn another set of tasks.</li>
    </ol>
    <p class="normal">Pretty simple, isn't it?</p>
    <h3 id="_idParaDest-113" class="title">Globally limiting concurrency</h3>
    <p class="normal">Our web spider application <a id="_idIndexMarker301"/>is perfect for applying what we just learned about limiting the concurrency of a set of tasks. In fact, to avoid the situation in which we have thousands of links being crawled at the same time, we can enforce a limit on the concurrency of this process by adding some predictability regarding the number of concurrent downloads.</p>
    <p class="normal">We could apply this implementation of the limited concurrency pattern to our <code class="Code-In-Text--PACKT-">spiderLinks()</code> function, but by doing that, we would only be limiting the concurrency of tasks spawned from the links found within a given page. If we chose, for example, a concurrency of two, we would have, at most, two links downloaded in parallel for each page. However, as we can download multiple links at once, each page would then spawn another two downloads, causing the grand total of download operations to grow exponentially anyway.</p>
    <p class="normal">In general, this implementation of the limited concurrency pattern works very well when we have a predetermined set of tasks to execute, or when the set of tasks grows linearly over time. When, instead, a task can spawn two or more tasks directly, as happens with our web spider, this implementation is not suitable for limiting the global concurrency.</p>
    <h4 class="title">Queues to the rescue</h4>
    <p class="normal">What we really want, then, is to limit the global number of download operations we can have running in parallel. We could slightly modify the pattern shown in the previous section, but this is left as an exercise for you. Instead, let's discuss another mechanism that makes use of <strong class="keyword">queues</strong> to limit the <a id="_idIndexMarker302"/>concurrency of multiple tasks. Let's see how this works.</p>
    <p class="normal">We are now going to implement a simple class named <code class="Code-In-Text--PACKT-">TaskQueue</code>, which will combine a queue with the algorithm that was presented while discussing limited concurrency. Let's create a new module named <code class="Code-In-Text--PACKT-">taskQueue.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">export class TaskQueue {
  constructor (concurrency) {
    this.concurrency = concurrency
    this.running = 0
    this.queue = []
  }
  pushTask (task) {
    this.queue.push(task)
    process.nextTick(this.next.bind(this))
    return this
  }
  next () {
    while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
      const task = this.queue.shift()
      task(() =&gt; {
        this.running--
        process.nextTick(this.next.bind(this))
      })
      this.running++
    }
  }
}
</code></pre>
    <p class="normal">The constructor of this class takes, as input, only the concurrency limit, but besides that, it initializes the instance variables <code class="Code-In-Text--PACKT-">running</code> and <code class="Code-In-Text--PACKT-">queue</code>. The former variable is a counter used to keep track of all the running tasks, while the latter is the array that will be used as a queue to store the pending tasks.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">pushTask()</code> method <a id="_idIndexMarker303"/>simply adds a new task to the queue and then bootstraps the execution of the worker by asynchronously invoking <code class="Code-In-Text--PACKT-">this.next()</code>. Note that we have to use <code class="Code-In-Text--PACKT-">bind</code> because otherwise, the <code class="Code-In-Text--PACKT-">next</code> function will lose its context when invoked by <code class="Code-In-Text--PACKT-">process.nextTick</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">next()</code> method spawns a set of tasks from the queue, ensuring that it does not exceed the concurrency limit.</p>
    <p class="normal">You may notice that this method has some similarities with the pattern presented at the beginning of the <em class="italic">Limiting concurrency</em> section. It essentially starts as many tasks from the queue as possible, without exceeding the concurrency limit. When each task is complete, it updates the count of running tasks and then starts another round of tasks by asynchronously invoking <code class="Code-In-Text--PACKT-">next()</code> again. The interesting property of the <code class="Code-In-Text--PACKT-">TaskQueue</code> class is that it allows us to dynamically add new items to the queue. The other advantage is that, now, we have a central entity responsible for the limitation of the concurrency of our tasks, which can be shared across all the instances of a function's execution. In our case, it's the <code class="Code-In-Text--PACKT-">spider()</code> function, as you will see in a moment.</p>
    <h4 class="title">Refining the TaskQueue</h4>
    <p class="normal">The previous implementation of <code class="Code-In-Text--PACKT-">TaskQueue</code> is sufficient to demonstrate the queue pattern, but in order to be used in real-life projects, it needs a couple of extra features. For instance, how can we tell when one of the tasks has failed? How do we know whether all the work in the queue has been completed?</p>
    <p class="normal">Let's bring back some of the <a id="_idIndexMarker304"/>concepts we discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Callbacks and Events</em>, and let's turn the <code class="Code-In-Text--PACKT-">TaskQueue</code> into an <code class="Code-In-Text--PACKT-">EventEmitter</code> so that we can emit events to propagate task failures and to inform any observer when the queue is empty.</p>
    <p class="normal">The first change we have to make is to import the <code class="Code-In-Text--PACKT-">EventEmitter</code> class and let our <code class="Code-In-Text--PACKT-">TaskQueue</code> extend it:</p>
    <pre class="programlisting code"><code class="hljs-code">import { EventEmitter } from 'events'
export class TaskQueue extends EventEmitter {
  constructor (concurrency) {
    super()
    // ...
  }
  // ...
}
</code></pre>
    <p class="normal">At this point, we can use <code class="Code-In-Text--PACKT-">this.emit</code> to fire events from within the <code class="Code-In-Text--PACKT-">TaskQueue</code> <code class="Code-In-Text--PACKT-">next()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">next () {
  if (this.running === 0 &amp;&amp; this.queue.length === 0) {         // (1)
    return this.emit('empty')
  }
  while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {
    const task = this.queue.shift()
    task((err) =&gt; {                                            // (2)
      if (err) {
        this.emit('error', err)
      }
      this.running--
      process.nextTick(this.next.bind(this))
    })
    this.running++
  }
}
</code></pre>
    <p class="normal">Comparing this implementation with the previous one, there are two additions here:</p>
    <ul>
      <li class="Bullet--PACKT-">Every time the <code class="Code-In-Text--PACKT-">next()</code> function is called, we check that no task is running and whether the queue is empty. In such a case, it means that the queue has been drained and we can fire the <code class="Code-In-Text--PACKT-">empty</code> event.</li>
      <li class="Bullet-End--PACKT-">The completion callback of every task can now be invoked by passing an error. We check whether an error is actually passed, indicating that the task has failed, and in that case, we propagate such an error with an <code class="Code-In-Text--PACKT-">error</code> event.</li>
    </ul>
    <p class="normal">Notice that in case of an error, we<a id="_idIndexMarker305"/> are deliberately keeping the queue running. We are not stopping other tasks in progress, nor removing any pending tasks. This is quite common with queue-based systems. Errors are expected to happen and rather than letting the system crash on these occasions, it is generally better to identify errors and to think about retry or recovery strategies. We will discuss these concepts a bit more in <em class="chapterRef">Chapter 13</em>, <em class="italic">Messaging and Integration Patterns</em>.</p>
    <h4 class="title">Web spider version 4</h4>
    <p class="normal">Now that we have our generic <a id="_idIndexMarker306"/>queue to execute tasks in a limited parallel flow, let's use it straightaway to refactor our web spider application.</p>
    <p class="normal">We are going to use an instance of <code class="Code-In-Text--PACKT-">TaskQueue</code> as a work backlog; every URL that we want to crawl needs to be appended to the queue as a task. The starting URL will be added as the first task, then every other URL discovered during the crawling process will be added as well. The queue will manage all the scheduling for us, making sure that the number of tasks in progress (that is, the number of pages being downloaded or read from the filesystem) at any given time is never greater than the concurrency limit configured for the given <code class="Code-In-Text--PACKT-">TaskQueue</code> instance.</p>
    <p class="normal">We have already defined the logic to crawl a given URL inside our <code class="Code-In-Text--PACKT-">spider()</code> function. We can consider this to be our generic crawling task. For more clarity, it's best to rename this function <code class="Code-In-Text--PACKT-">spiderTask</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderTask (url, nesting, queue, cb) {             // (1)
  const filename = urlToFilename(url)
  fs.readFile(filename, 'utf8', (err, fileContent) =&gt; {
    if (err) {
      if (err.code !== 'ENOENT') {
        return cb(err)
      }
      return download(url, filename, (err, requestContent) =&gt; {
        if (err) {
          return cb(err)
        }
        spiderLinks(url, requestContent, nesting, queue)    // (2)
        return cb()
      })
    }
    spiderLinks(url, fileContent, nesting, queue)           // (3)
    return cb()
  })
}
</code></pre>
    <p class="normal">Other than renaming the function, you might have noticed that we applied some other small changes:</p>
    <ul>
      <li class="Bullet--PACKT-">The function signature now accepts a new parameter called <code class="Code-In-Text--PACKT-">queue</code>. This is an instance of <code class="Code-In-Text--PACKT-">TaskQueue</code> that we need to carry over to be able to append new tasks when necessary.</li>
      <li class="Bullet--PACKT-">The function responsible for adding new links to crawl is <code class="Code-In-Text--PACKT-">spiderLinks</code>, so we need to make sure that we pass the queue instance when we call this function after downloading a new page.</li>
      <li class="Bullet-End--PACKT-">We also need to pass the queue instance to <code class="Code-In-Text--PACKT-">spiderLinks</code> when we are invoking that from an already downloaded file.</li>
    </ul>
    <p class="normal">Let's revisit the <code class="Code-In-Text--PACKT-">spiderLinks()</code> function. This<a id="_idIndexMarker307"/> function can now be greatly simplified as it doesn't have to keep track of task completion anymore, as this work has been delegated to the queue. Its job becomes effectively synchronous now; it just needs to invoke the new <code class="Code-In-Text--PACKT-">spider()</code> function (which we will define shortly) to push a new task to the queue, one for each discovered link:</p>
    <pre class="programlisting code"><code class="hljs-code">function spiderLinks (currentUrl, body, nesting, queue) {
  if (nesting === 0) {
    return
  }
  const links = getPageLinks(currentUrl, body)
  if (links.length === 0) {
    return
  }
  links.forEach(link =&gt; spider(link, nesting - 1, queue))
}
</code></pre>
    <p class="normal">Let's now revisit the <code class="Code-In-Text--PACKT-">spider()</code> function, which needs to act as the <em class="italic">entry point</em> for the first URL; it will also be used to add every new discovered URL to the <code class="Code-In-Text--PACKT-">queue</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">const spidering = new Set()                               // (1)
export function spider (url, nesting, queue) {
  if (spidering.has(url)) {
    return
  }
  spidering.add(url)
  queue.pushTask((done) =&gt; {                              // (2)
    spiderTask(url, nesting, queue, done)
  })
}
</code></pre>
    <p class="normal">As you can see, this function now has two main responsibilities:</p>
    <ol>
      <li class="numbered">It manages the bookkeeping of the URLs already visited or in progress by using the <code class="Code-In-Text--PACKT-">spidering</code> set.</li>
      <li class="numbered">It pushes a new task to<a id="_idIndexMarker308"/> the <code class="Code-In-Text--PACKT-">queue</code>. Once executed, this task will invoke the <code class="Code-In-Text--PACKT-">spiderTask()</code> function, effectively starting the crawling of the given URL.</li>
    </ol>
    <p class="normal">Finally, we can update the <code class="Code-In-Text--PACKT-">spider-cli.js</code> script, which allows us to invoke our spider from the command line:</p>
    <pre class="programlisting code"><code class="hljs-code">import { spider } from './spider.js'
import { TaskQueue } from './TaskQueue.js'
const url = process.argv[2]                                    // (1)
const nesting = Number.parseInt(process.argv[3], 10) || 1
const concurrency = Number.parseInt(process.argv[4], 10) || 2
const spiderQueue = new TaskQueue(concurrency)                 // (2)
spiderQueue.on('error', console.error)
spiderQueue.on('empty', () =&gt; console.log('Download complete'))
spider(url, nesting, spiderQueue)                              // (3)
</code></pre>
    <p class="normal">This script is now composed of three main parts:</p>
    <ol>
      <li class="numbered">CLI arguments parsing. Note that the script now accepts a third additional parameter that can be used to customize the concurrency level.</li>
      <li class="numbered">A <code class="Code-In-Text--PACKT-">TaskQueue</code> object is created and listeners are attached to the <code class="Code-In-Text--PACKT-">error</code> and <code class="Code-In-Text--PACKT-">empty</code> events. When an error occurs, we simply want to print it. When the queue is empty, that means that we've finished crawling the website.</li>
      <li class="numbered">Finally, we start the <a id="_idIndexMarker309"/>crawling process by invoking the <code class="Code-In-Text--PACKT-">spider</code> function.</li>
    </ol>
    <p class="normal">After we have applied these changes, we can try to run the spider module again. When we run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">node spider-cli.js https://loige.co 1 4
</code></pre>
    <p class="normal">We should notice that no more than four downloads will be active at the same time.</p>
    <p class="normal">With this final example, we've concluded our exploration of callback-based patterns. In the next section, we will close this chapter by looking at a famous library that provides a production-ready implementation of these patterns and many other asynchronous utilities.</p>
    <h1 id="_idParaDest-114" class="title">The async library</h1>
    <p class="normal">If you take a<a id="_idIndexMarker310"/> look for a moment at every control flow pattern we have analyzed so far, you will see that they can be used as a base to build reusable and more generic solutions. For example, we could wrap the unlimited parallel execution algorithm into a function that accepts a list of tasks, runs them in parallel, and invokes the given callback when all of them are complete. This way of wrapping control flow algorithms into reusable functions can lead to a more declarative and expressive way of defining asynchronous control flows, and that's exactly what <code class="Code-In-Text--PACKT-">async</code> (<a href="http://nodejsdp.link/async">nodejsdp.link/async</a>) does.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">async</code> library (not to be confused with the <code class="Code-In-Text--PACKT-">async</code>/<code class="Code-In-Text--PACKT-">await</code> keywords, which we will discuss later in this book) is a very popular solution, in Node.js and JavaScript in general, for dealing with asynchronous code. It offers a set of functions that greatly simplify the execution of tasks in different configurations, and it also provides useful helpers for dealing with collections asynchronously. Even though there are several other libraries with a similar goal, <code class="Code-In-Text--PACKT-">async</code> is the de facto standard in Node.js due to its historic popularity, especially when using callbacks to define asynchronous tasks.</p>
    <p class="normal">Just to give you an idea of some of the most important capabilities of the async module, here is a sample of the functionalities it exposes:</p>
    <ul>
      <li class="Bullet--PACKT-">Execute asynchronous functions over a collection of elements (in series or in parallel with limited concurrency).</li>
      <li class="Bullet--PACKT-">Execute a chain of asynchronous functions (waterfall) where the output of every function becomes the input of the next one.</li>
      <li class="Bullet--PACKT-">Offers a queue abstraction functionally equivalent to the one we implemented with our <code class="Code-In-Text--PACKT-">TaskQueue</code> utility.</li>
      <li class="Bullet-End--PACKT-">Provides other <a id="_idIndexMarker311"/>interesting asynchronous patterns such as <strong class="keyword">race</strong> (executes multiple asynchronous functions in parallel and stops when the first one completes).</li>
    </ul>
    <p class="normal">Check out the <code class="Code-In-Text--PACKT-">async</code> documentation (<a href="http://nodejsdp.link/async">nodejsdp.link/async</a>) to find out more about the module and to see some examples.</p>
    <p class="normal">Once you've understood the fundamentals of the asynchronous patterns described in this chapter, you shouldn't rely on the simplified implementations presented here for your everyday control flow needs. Instead, it's better to adopt a broadly used and battle-tested library like <code class="Code-In-Text--PACKT-">async</code> for your production applications, unless your use case is so advanced that you require a custom algorithm.</p>
    <h1 id="_idParaDest-115" class="title">Summary</h1>
    <p class="normal">At the beginning of this chapter, it was stated that Node.js programming can be tough because of its asynchronous nature, especially for people used to developing on other platforms. However, throughout this chapter, you saw how asynchronous APIs can be bent to your will. You discovered that the tools at your disposal are indeed versatile and provide good solutions to most of your problems, in addition to offering a programming style for every taste.</p>
    <p class="normal">In this chapter, we also kept refactoring and improving our web crawler example. When dealing with asynchronous code, it can sometimes be challenging to figure out the right ergonomics that can keep your code simple and effective, so allow yourself some time to digest the concepts explored in this chapter and to experiment with them.</p>
    <p class="normal">Our journey with asynchronous Node.js programming has just started. In the next few chapters, you will be introduced to other broadly adopted techniques that leverage promises, and async/await. After you've learned all these techniques, you will be able to choose the best solution for your needs or use many of them together in the same project.</p>
    <h1 id="_idParaDest-116" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">4.1 File concatenation</strong>: Write the implementation of <code class="Code-In-Text--PACKT-">concatFiles()</code>, a callback-style function that takes two or more paths to text files in the filesystem and a destination file:
        <pre class="programlisting code"><code class="hljs-code">function concatFiles (srcFile1, srcFile2, srcFile3, ... ,
                      dest, cb) {
  // ...
}
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">This function must copy the contents of every source file into the destination file, respecting the order of the files, as provided by the arguments list. For instance, given two files, if the first file contains <em class="italic">foo</em> and the second file contains <em class="italic">bar</em>, the function should write <em class="italic">foobar</em> (and not <em class="italic">barfoo</em>) in the destination file. Note that the preceding example signature is not valid JavaScript syntax: you need to find a different way to handle an arbitrary number of arguments. For instance, you could use the <strong class="keyword">rest parameters</strong> syntax (<a href="http://nodejsdp.link/rest-parameters">nodejsdp.link/rest-parameters</a>).</p>
      </li>
      <li class="Bullet--PACKT-"><strong class="keyword">4.2 List files recursively</strong>: Write <code class="Code-In-Text--PACKT-">listNestedFiles()</code>, a callback-style function that takes, as the input, the path to a directory in the local filesystem and that asynchronously iterates over all the subdirectories to eventually return a list of all the files discovered. Here is what the signature of the function should look like:
        <pre class="programlisting code"><code class="hljs-code">function listNestedFiles (dir, cb) { /* ... */ }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Bonus points if you manage to avoid callback hell. Feel free to create additional helper functions if needed.</p>
      </li>
      <li class="Bullet--PACKT-"><strong class="keyword">4.3 Recursive find</strong>: Write <code class="Code-In-Text--PACKT-">recursiveFind()</code>, a callback-style function that takes a path to a directory in the local filesystem and a keyword, as per the following signature:
        <pre class="programlisting code"><code class="hljs-code">function recursiveFind(dir, keyword, cb) { /* ... */ }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The function must find all the text files within the given directory that contain the given keyword in the file contents. The list of matching files should be returned using the callback when the search is completed. If no matching file is found, the callback must be invoked with an empty array. As an example test case, if you have the files <code class="Code-In-Text--PACKT-">foo.txt</code>, <code class="Code-In-Text--PACKT-">bar.txt</code>, and <code class="Code-In-Text--PACKT-">baz.txt</code> in <code class="Code-In-Text--PACKT-">myDir</code> and the keyword <code class="Code-In-Text--PACKT-">'batman'</code> is contained in the files <code class="Code-In-Text--PACKT-">foo.txt</code> and <code class="Code-In-Text--PACKT-">baz.txt</code>, you should be able to run the following code:</p>
        <pre class="programlisting code"><code class="hljs-code">recursiveFind('myDir', 'batman', console.log)
// should print ['foo.txt', 'baz.txt']
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet-End--PACKT-">Bonus points if you make the search recursive (it looks for text files in any subdirectory as well). Extra bonus points if you manage to perform the search within different files and subdirectories in parallel, but be careful to keep the number of parallel tasks under control!</p>
      </li>
    </ul>
  </div>
</body></html>