- en: Chapter 8. Internationalization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 国际化
- en: 'In this chapter, we will talk about **internationalization** (**i18n**). It
    is abbreviated as i18n because there are 18 letters between the initial *i* and
    the final *n*. Opa now provides two approaches for i18n: the internal approach
    and the external approach. To utilize the internal approach, we include translation
    functions directly inside our Opa code. If, however, we wish to separate the translation
    from our main code, then we can do so by using the external approach. To make
    it clear, we will discuss a very simple application that displays the word "hello"
    in three different languages: English, French, and Chinese.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论**国际化**（**i18n**）。它被缩写为i18n，因为从初始的*i*到最后的*n*之间有18个字母。Opa现在提供了两种i18n方法：内部方法和外部方法。要使用内部方法，我们直接在我们的Opa代码中包含翻译函数。然而，如果我们希望将翻译与我们的主要代码分离，我们可以通过使用外部方法来实现。为了使问题清晰，我们将讨论一个非常简单的应用程序，该程序以三种不同的语言显示单词“hello”：英语、法语和中文。
- en: Internal approach
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部方法
- en: 'Opa now provides support for translation by means of the `@i18n` directive.
    We can put a translation function inside the `@i18n` directive, and it will be
    replaced by a proper value according to different languages. An example is worth
    a thousand words, so let''s get started with a simple example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Opa现在通过`@i18n`指令提供了对翻译的支持。我们可以在`@i18n`指令中放置一个翻译函数，并且它将根据不同的语言被替换为适当的值。一个例子胜过千言万语，所以让我们从一个简单的例子开始：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this code into a file, `801.opa`, then compile and run it with the following
    command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存到文件`801.opa`中，然后使用以下命令编译和运行它：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result looks as shown in the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来如下面的截图所示：
- en: '![Internal approach](img/3749OS_08_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![内部方法](img/3749OS_08_01.jpg)'
- en: 'The page shows **Hello** in three different languages: English, French, and
    Chinese, and we can change the language by clicking on the language buttons.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 页面以三种不同的语言显示**Hello**：英语、法语和中文，我们可以通过点击语言按钮来更改语言。
- en: As we can see from the code, we internationalize the page by enclosing a translation
    function, `hello`, in the `@i18n` directive—`@i18n(hello)`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从代码中可以看到的，我们通过将翻译函数`hello`包裹在`@i18n`指令中来实现页面国际化——`@i18n(hello)`。
- en: 'The function `hello` maps from the language code (for example, "`en`", "`fr`",
    and "`zh`", of the type `I18n.language`) to a string. Note that the function `hello`
    is written in a convenient way, in that `…`. This notation is permitted if the
    initial lines of code in a function consist of matching its parameter against
    some values, as we do in the `hello` function. The corresponding long notation
    would be:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`hello`将语言代码（例如，`en`、`fr`和`zh`，类型为`I18n.language`）映射到一个字符串。请注意，函数`hello`的编写方式很方便，即`…`。如果函数的初始几行代码是将其参数与某些值匹配，那么这种表示法是被允许的，就像我们在`hello`函数中所做的那样。相应的长表示法将是：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also note that the return type of a translation function is not restricted
    to the type `String`; an XHTML fragment can also be returned from the function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，翻译函数的返回类型不仅限于`String`类型；函数也可以返回XHTML片段：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have reviewed how to write a translation function, we now need to
    clarify how users control the language of the website they are seeing. The module
    `I18n`, the internationalization module, contains the answer. The `I18n.lang()`
    function returns the currently selected language. Note that this is not the language
    of the browser, it is the language that the user selected. We can change the selected
    language programmatically by invoking the function `I18n.set_lang(lang)`. This
    is just what we did after clicking on the three language buttons **English**,
    **French**, and **Chinese** in the example we just saw. This function allows us
    to change the language for a specific client. The language our program defines
    is then stored in a cookie. Since the changes our program makes will only take
    effect during the next page request, to make them effective right away our program
    must refresh the page by calling the function `Client.reload`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何编写翻译函数，我们现在需要明确用户如何控制他们所看到的网站的语言。国际化模块`I18n`包含了答案。`I18n.lang()`函数返回当前选定的语言。请注意，这并不是浏览器的语言，而是用户所选的语言。我们可以通过调用函数`I18n.set_lang(lang)`来程序化地更改选定的语言。这正是我们在刚才看到的示例中点击三个语言按钮**英语**、**法语**和**中文**后所做的事情。这个函数允许我们为特定的客户端更改语言。我们的程序定义的语言随后被存储在一个cookie中。由于我们的程序所做的更改只会在下一个页面请求期间生效，为了立即使其生效，我们的程序必须通过调用函数`Client.reload`来刷新页面。
- en: External approach
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部方法
- en: The internal approach suffers from one important problem, that is, it mixes
    the source code and the translations. The remedy for this problem is the external
    approach. Using it, we can separate the program code and the translations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法存在一个重要问题，那就是它将源代码和翻译混合在一起。解决这个问题的方法是外部方法。使用它，我们可以将程序代码和翻译分开。
- en: 'To use external translations, we use the same `@i18n` directive, but we provide
    it with a key string instead of a function. Thus, `@i18n(hello)` can be replaced
    by:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用外部翻译，我们使用相同的`@i18n`指令，但提供给它一个键字符串而不是一个函数。因此，`@i18n(hello)`可以被替换为：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is an example of an external approach:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个外部方法的示例：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the file as `802.opa`. If we do not provide any translation, `@i18n("hello")`
    will be replaced by the string `"hello"`. How do we add the translation? The solution
    is to compile our source code with the translation switch `--i18n-template-opa`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`802.opa`。如果我们不提供任何翻译，`@i18n("hello")`将被替换为字符串`"hello"`。我们如何添加翻译？解决方案是使用带有翻译开关`--i18n-template-opa`编译我们的源代码：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make a directory named `langs` and execute this line. This will create a file
    named `trans.opa` in the `langs` directory. The option `--i18n-pkg` specifies
    the package name of the translation code. If it is not provided, the default name
    will be `linking.translation`. The option `--i18n-dir` specifies the directory
    of translation code. If it is not provided, the current directory will be used.
    The content of `trans.opa` looks as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`langs`的目录并执行此行。这将创建一个名为`trans.opa`的文件，位于`langs`目录中。选项`--i18n-pkg`指定了翻译代码的包名。如果没有提供，默认名称将是`linking.translation`。选项`--i18n-dir`指定了翻译代码的目录。如果没有提供，将使用当前目录。`trans.opa`的内容如下所示：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The file contains all the messages that require translation in all the source
    code files of a given package. The long sequence `5d41402abc4b2a76b9719d911017c592`
    is an automatically generated identifier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包含给定包中所有源代码文件中需要翻译的所有消息。长序列`5d41402abc4b2a76b9719d911017c592`是一个自动生成的标识符。
- en: 'Next, we must edit the translation file that Opa generated, adding our translation
    messages to the file. In our example case, for instance, we could add the following
    translation instructions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须编辑Opa生成的翻译文件，将我们的翻译信息添加到文件中。例如，在我们的示例案例中，我们可以添加以下翻译指令：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The translation file is a normal Opa file, and its contents can be intuitively
    comprehended. Such a notation is called classic syntax. We must tell the compiler
    that we are utilizing classic Opa source code when we compile the translation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译文件是一个普通的Opa文件，其内容可以直观理解。这种表示法被称为经典语法。当我们编译翻译时，我们必须告诉编译器我们正在使用经典Opa源代码：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, compile our source code with the translation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用翻译编译我们的源代码：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how to internationalize a web page in Opa. We
    can either use the internal approach of writing a translate function in our code,
    or the external approach of utilizing an external file that is translated separately
    from our code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何在Opa中国际化一个网页。我们可以使用在代码中编写翻译函数的内部方法，或者使用从代码中单独翻译的外部方法。
