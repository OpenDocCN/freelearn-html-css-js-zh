- en: Chapter 8. Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about **internationalization** (**i18n**). It
    is abbreviated as i18n because there are 18 letters between the initial *i* and
    the final *n*. Opa now provides two approaches for i18n: the internal approach
    and the external approach. To utilize the internal approach, we include translation
    functions directly inside our Opa code. If, however, we wish to separate the translation
    from our main code, then we can do so by using the external approach. To make
    it clear, we will discuss a very simple application that displays the word "hello"
    in three different languages: English, French, and Chinese.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opa now provides support for translation by means of the `@i18n` directive.
    We can put a translation function inside the `@i18n` directive, and it will be
    replaced by a proper value according to different languages. An example is worth
    a thousand words, so let''s get started with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this code into a file, `801.opa`, then compile and run it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internal approach](img/3749OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The page shows **Hello** in three different languages: English, French, and
    Chinese, and we can change the language by clicking on the language buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the code, we internationalize the page by enclosing a translation
    function, `hello`, in the `@i18n` directive—`@i18n(hello)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `hello` maps from the language code (for example, "`en`", "`fr`",
    and "`zh`", of the type `I18n.language`) to a string. Note that the function `hello`
    is written in a convenient way, in that `…`. This notation is permitted if the
    initial lines of code in a function consist of matching its parameter against
    some values, as we do in the `hello` function. The corresponding long notation
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that the return type of a translation function is not restricted
    to the type `String`; an XHTML fragment can also be returned from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed how to write a translation function, we now need to
    clarify how users control the language of the website they are seeing. The module
    `I18n`, the internationalization module, contains the answer. The `I18n.lang()`
    function returns the currently selected language. Note that this is not the language
    of the browser, it is the language that the user selected. We can change the selected
    language programmatically by invoking the function `I18n.set_lang(lang)`. This
    is just what we did after clicking on the three language buttons **English**,
    **French**, and **Chinese** in the example we just saw. This function allows us
    to change the language for a specific client. The language our program defines
    is then stored in a cookie. Since the changes our program makes will only take
    effect during the next page request, to make them effective right away our program
    must refresh the page by calling the function `Client.reload`.
  prefs: []
  type: TYPE_NORMAL
- en: External approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The internal approach suffers from one important problem, that is, it mixes
    the source code and the translations. The remedy for this problem is the external
    approach. Using it, we can separate the program code and the translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use external translations, we use the same `@i18n` directive, but we provide
    it with a key string instead of a function. Thus, `@i18n(hello)` can be replaced
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of an external approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file as `802.opa`. If we do not provide any translation, `@i18n("hello")`
    will be replaced by the string `"hello"`. How do we add the translation? The solution
    is to compile our source code with the translation switch `--i18n-template-opa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a directory named `langs` and execute this line. This will create a file
    named `trans.opa` in the `langs` directory. The option `--i18n-pkg` specifies
    the package name of the translation code. If it is not provided, the default name
    will be `linking.translation`. The option `--i18n-dir` specifies the directory
    of translation code. If it is not provided, the current directory will be used.
    The content of `trans.opa` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The file contains all the messages that require translation in all the source
    code files of a given package. The long sequence `5d41402abc4b2a76b9719d911017c592`
    is an automatically generated identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must edit the translation file that Opa generated, adding our translation
    messages to the file. In our example case, for instance, we could add the following
    translation instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The translation file is a normal Opa file, and its contents can be intuitively
    comprehended. Such a notation is called classic syntax. We must tell the compiler
    that we are utilizing classic Opa source code when we compile the translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, compile our source code with the translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to internationalize a web page in Opa. We
    can either use the internal approach of writing a translate function in our code,
    or the external approach of utilizing an external file that is translated separately
    from our code.
  prefs: []
  type: TYPE_NORMAL
