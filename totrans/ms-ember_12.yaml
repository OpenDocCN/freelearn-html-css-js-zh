- en: Chapter 12. Modularizing Your Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 模块化你的项目
- en: 'Many Ember.js projects get complex, and so it may be necessary to modularize
    the project for maintainability through a combination of any of the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Ember.js项目可能会变得复杂，因此可能需要通过以下任何一种组合对项目进行模块化，以提高可维护性：
- en: Split the project into a number of script files and load them individually.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目拆分为多个脚本文件并单独加载它们。
- en: Concatenate the script files into one build file. This reduces the number of
    requests the browser needs to make to the backend; hence, the page load time is
    reduced.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将脚本文件连接成一个构建文件。这减少了浏览器需要向后端发出的请求数量；因此，页面加载时间减少。
- en: Maintain reusable components that can be used on a number of projects.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护可重用组件，这些组件可以在多个项目中使用。
- en: 'There are a number of open source tools that can be used to perform such tasks.
    These tools may contain the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源工具可以用来执行此类任务。这些工具可能包含以下内容：
- en: A package manager that installs external reusable components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以安装外部可重用组件的包管理器
- en: A build process that intelligently concatenates all the project files into a
    single build file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个智能地将所有项目文件连接成一个单一构建文件的构建过程
- en: 'The following are some of these popular tools:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些这些流行的工具：
- en: Grunt (a build tool)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt（一个构建工具）
- en: Gulp (a build tool)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp（一个构建工具）
- en: Bower (a package manager)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bower（一个包管理器）
- en: NPM (a package manager)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM（一个包管理器）
- en: Browserify (a build tool)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Browserify（一个构建工具）
- en: Ember CLI (a build tool)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember CLI（一个构建工具）
- en: Brocolli (a build tool)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brocolli（一个构建工具）
- en: Ember add-ons ([http://emberaddons.com](http://emberaddons.com))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ember插件([http://emberaddons.com](http://emberaddons.com))
- en: Duojs (build tool and package manager based on Component and Browserify)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Duojs（基于Component和Browserify的构建工具和包管理器）
- en: Component (a build tool and package manager)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Component（一个构建工具和包管理器）
- en: Any of these can be used to get the job done in any combination. In this chapter,
    we will be discussing how to use **Component** to easily manage complex Ember.js
    projects. It's worth noting that the ES6 module feature is being worked on to
    tackle these problems. Luckily, some of these tools are compliant with the specifications,
    thereby enabling easy migration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以以任何组合方式完成任务。在本章中，我们将讨论如何使用**Component**轻松管理复杂的Ember.js项目。值得注意的是，ES6模块功能正在开发中，以解决这些问题。幸运的是，一些这些工具符合规范，从而使得迁移变得容易。
- en: Installing the Component build tool
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Component构建工具
- en: 'Component is both a package manager and a build tool for client-side web projects.
    It provides the ability to install external project dependencies as well as organize
    a project into several local components that later can be built into a single
    build file. The chapter sample uses the tool to install and use the required project
    dependencies. To run the sample, we first need to install Node.js, which can be
    downloaded from [http://nodejs.org/download](http://nodejs.org/download). To run
    the project, simply execute `make` in a terminal shell. If the system doesn''t
    have `make` installed, the project can still be run with the following commands,
    the first of which installs the tool:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个客户端Web项目的包管理器和构建工具。它提供了安装外部项目依赖项以及将项目组织成几个本地组件的能力，这些组件稍后可以构建成一个单独的构建文件。本章示例使用此工具安装和使用所需的项目依赖项。要运行此示例，我们首先需要安装Node.js，可以从[http://nodejs.org/download](http://nodejs.org/download)下载。要运行项目，只需在终端外壳中执行`make`命令。如果系统没有安装`make`，可以使用以下命令运行项目，其中第一个命令安装了工具：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Component is an NPM package and can therefore be installed by adding the dependency
    to `package.json`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Component是一个NPM包，因此可以通过将依赖项添加到`package.json`中来进行安装：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we install the external component dependencies and build the file using
    the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码安装外部组件依赖项并构建文件：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The app can finally be opened by loading `index.html` in the browser. This app
    is an implementation of the popular 2048 game ([http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/))
    by Gabriele Cirulli, and takes advantage of the Ember.js' runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以通过在浏览器中加载`index.html`来打开应用程序。此应用程序是Gabriele Cirulli开发的流行2048游戏的实现([http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/))，并利用了Ember.js的运行时。
- en: 'The open source game, shown in the following screenshot, is a good introduction
    to web game development:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示的开源游戏是Web游戏开发的良好介绍：
- en: '![Installing the Component build tool](img/00021.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![安装Component构建工具](img/00021.jpeg)'
- en: Code organization
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'The Component tool requires a project to be organized into `components`. A
    component is a reusable module that can contain scripts, styles, images, templates,
    and fonts defined in a `component.json` configuration file. It can also optionally
    define dependencies that are themselves components. These dependencies can be
    local or remote. Therefore, a project can be thought of as a tree of components,
    as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 组件工具要求项目组织到 `components`。组件是一个可重用的模块，可以包含在 `component.json` 配置文件中定义的脚本、样式、图像、模板和字体。它还可以可选地定义依赖项，这些依赖项本身也是组件。这些依赖项可以是本地或远程的。因此，可以将项目视为一个组件的树，如下面的截图所示：
- en: '![Code organization](img/00022.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![代码组织](img/00022.jpeg)'
- en: 'In this project, the root of the project defines a component `2048`, shown
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，项目的根目录定义了一个组件 `2048`，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This component doesn''t include any scripts or styles because these are contained
    in child components, and so we do not have to specify them. It does, however,
    specify that it depends on a local component named `app` that is found in the
    `lib` relative directory, which in turn defines yet another local component dependency
    `game`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件不包含任何脚本或样式，因为这些都在子组件中，所以我们不需要指定它们。然而，它指定了它依赖于一个名为 `app` 的本地组件，该组件位于 `lib`
    相对目录中，它反过来又定义了另一个本地组件依赖 `game`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing components
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装组件
- en: 'A component can define remote components as dependencies. A remote component
    is an external Git repository that is hosted in either Github or BitBucket. Some
    versions of components allow the installation of components from other remote
    components as long as they adhere to a `<username>/<repo>` format. In this case,
    the app component defines one dependency that will be installed from [http://github.com/kelonye/ember](http://github.com/kelonye/ember):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以定义远程组件作为依赖项。远程组件是托管在 Github 或 BitBucket 上的外部 Git 仓库。一些组件版本允许从其他远程组件安装组件，只要它们遵循
    `<username>/<repo>` 格式。在这种情况下，应用程序组件定义了一个依赖项，该依赖项将从 [http://github.com/kelonye/ember](http://github.com/kelonye/ember)
    安装：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The game component, on the other hand, also defines three dependencies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，游戏组件也定义了三个依赖项：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These components can be installed into the `components/` relative directory
    by invoking the following in the project''s root directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件可以通过在项目根目录中调用以下命令安装到 `components/` 相对目录中：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We could also simply ask `component install` if the module is installed globally
    with `npm install -g component` or if `./node_modules/.bin` is added to the bash
    profile PATH.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以简单地询问 `component install`，如果模块通过 `npm install -g component` 全局安装，或者如果 `./node_modules/.bin`
    被添加到 bash 配置文件 PATH 中，那么模块是否已安装：
- en: Building components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建组件
- en: 'Once the remote components have been installed, the project can be built by
    invoking the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦远程组件被安装，可以通过调用以下命令来构建项目：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This concatenates scripts and styles into a `builds` folder. By default, the
    folder is named `build` but can be changed by passing the `–out` or `-o` flag.
    Also, by default, the built files are named `build.js` and `build.css`, but this
    can be altered using the `–name` or `-n` flag, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将脚本和样式连接到 `builds` 文件夹中。默认情况下，文件夹命名为 `build`，但可以通过传递 `–out` 或 `-o` 标志来更改。此外，默认情况下，构建文件命名为
    `build.js` 和 `build.css`，但可以使用 `–name` 或 `-n` 标志来更改，例如：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Loading the built files
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载构建文件
- en: 'The built files are referenced from the build folder as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件如下所示从构建文件夹中引用：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that the application is booted by *requiring* the `app` component. The
    `app` component includes an `index.js` file that gets executed in the process.
    Every requirable component needs to specify this file in its `.scripts` property
    in the configuration file. It may also specify the main file via the `.main` flag,
    so we can name the `index.js` file as `app.js` and then set the main flag as `"app.js"`.
    The script requires the remotely-installed `ember.js` component, creates the application,
    and defines the router:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应用程序是通过 *require* `app` 组件来启动的。`app` 组件包含一个 `index.js` 文件，该文件在进程中被执行。每个可要求的组件都需要在配置文件中的
    `.scripts` 属性中指定此文件。它也可以通过 `.main` 标志指定主文件，因此我们可以将 `index.js` 文件命名为 `app.js`，然后设置主标志为
    `"app.js"`。脚本需要远程安装的 `ember.js` 组件，创建应用程序，并定义路由器：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A good way to organize local components is to separate them by the routes or
    resources defined in the router; in this case, the `app` and `game` components.
    Each of the components contains corresponding controllers, views, models, routes,
    and template scripts, explicitly defined in the configuration files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组织本地组件的一个好方法是将它们根据路由器中定义的路由或资源分开；在这种情况下，是`app`和`game`组件。每个组件都包含相应的控制器、视图、模型、路由和模板脚本，这些都在配置文件中明确定义：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These are required in the main script as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在主脚本中如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `app` component defines two templates that are required accordingly:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`app`组件定义了两个相应所需的模板：'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the `index` route redirects the application state to the game route.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`index`路由将应用程序状态重定向到游戏路由。
- en: Game logic
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏逻辑
- en: 'Before we discuss the `game` component, it''s a good idea to discuss the game
    logic:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论`game`组件之前，讨论游戏逻辑是个好主意：
- en: The game is a 4 by 4 grid whose moves are made by sliding tiles using the keyboard
    arrow keys
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏是一个4x4的网格，通过使用键盘箭头键滑动方块进行移动
- en: The tiles merge if they are of equal magnitude
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方块的大小相等，它们将合并
- en: Each move generates a new random tile
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次移动都会生成一个新的随机方块
- en: The objective of the game is to slide these tiles until one of them merges to
    a value of 2048
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏的目标是将这些方块滑动，直到其中一个合并到2048的值
- en: 'The grid cells are represented by the `App.Cell` model located in `models.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 网格单元格由位于`models.js`中的`App.Cell`模型表示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A cell is considered a tile if its value is defined. When the game begins,
    we first populate the game with the cells:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格的值被定义时，它被视为一个方块。当游戏开始时，我们首先用单元格填充游戏：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The game controller houses the cells and so we populate it accordingly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器包含单元格，因此我们相应地填充它：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At this stage, we restore the saved game from the local storage using the `store`
    component:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们使用`store`组件从本地存储中恢复保存的游戏：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition, we cache the traversals for the four possible game move directions
    that we will need to make at this stage. For example, when the user makes an upward
    move, we will traverse cells from the left to the right and downwards:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们缓存了在这个阶段需要进行的四个可能的游戏移动方向的遍历。例如，当用户向上移动时，我们将从左到右向下遍历单元格：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will generate the first two tiles of the game if its state is not
    restored:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果游戏状态未恢复，我们将生成游戏的前两个方块：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The random tile generator simply picks a random cell and converts it into a
    tile by setting its value to either `2` or `4` if the game hasn''t ended:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随机方块生成器简单地选择一个随机单元格，并将其转换为方块，通过将其值设置为`2`或`4`（如果游戏尚未结束）：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The game view sets up a listener to play the moves:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏视图设置一个监听器来播放移动：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the user makes a play, we send the key code of the pressed key to the
    game controller''s `onMove` action. If the game hasn''t ended, the action will
    first determine which direction the play was made in, with the help of the `keycode`
    component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行操作时，我们将按下的键的键码发送到游戏控制器的`onMove`动作。如果游戏尚未结束，该动作将首先确定操作的方向，借助`keycode`组件：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is to find the traversal matrix that corresponds to the direction
    of the play:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到与游戏方向相对应的遍历矩阵：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then traverse through the cells and attempt to move the tile, if eligible:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历单元格，并尝试移动方块，如果符合条件的话：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For each of these tiles, we find the farthest new cell that it can occupy,
    by calling the `getNewFarthestCell` controller method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些方块中的每一个，我们通过调用`getNewFarthestCell`控制器方法来找到它可以占据的最远的新的单元格：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method takes the cell to move the trajectory vector and the magnitude
    of the movement:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受移动的轨迹向量和移动的幅度：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The method is meant to be recursive, that is, we incrementally move the cell
    in the direction of the game until we find the farthest cell. First, we find the
    position of the current, previous, and next cells, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法旨在是递归的，即我们逐步将单元格移动到游戏的方向，直到我们找到最远的单元格。首先，我们找到当前、前一个和下一个单元格的位置，如下所示：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then check to see whether the cell is off the grid:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查单元格是否超出网格：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the new cell is indeed outbound, we return the previous cell as the new
    position of the tile. However, if we encounter a tile, we test whether the two
    can be merged:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的单元格确实超出了边界，我们将返回前一个单元格作为方块的新位置。然而，如果我们遇到一个方块，我们将测试这两个方块是否可以合并：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the preceding conditions aren''t met, we proceed to test the next cell:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的条件没有满足，我们将继续测试下一个单元格：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we check to see whether the cell can actually move to the new position:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查单元格是否能够移动到新位置：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we need a state that determines whether a cell moved within that iteration
    for later reference:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个状态来确定在该迭代中是否有单元格移动，以便稍后参考：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If a merge has already occurred, then we need to use the cell just before it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经发生了合并，那么我们需要使用它之前的单元格：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we move the tile and increment the game''s score:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移动瓷砖并增加游戏的分数：
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since the tile has moved, we add it to the new set of tiles that would be rendered
    on repaint:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于瓷砖已经移动，我们将它添加到将在重绘时渲染的新瓷砖集合中：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For each merge in the iteration, we need to check whether the game has been
    won or lost:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于迭代的每次合并，我们需要检查游戏是否已经获胜或失败：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As per Gabriele''s game specification, a new random tile can only be generated
    if any of the existing tiles move after the end of the iterations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Gabriele的游戏规范，只有在迭代结束后任何现有瓷砖移动的情况下，才能生成新的随机瓷砖：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we need to check if the game has ended by catching the raised exception:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过捕获抛出的异常来检查游戏是否结束：
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The method that is called displays a message overlay, indicating whether the
    game has been won or not:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的方法会显示一个消息覆盖层，指示游戏是否已经获胜：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `game` template, found in `templates/game.html`, reacts to changes in the
    bound controller. First, the `New Game` button''s click event is bound to the
    `createNewGame` action:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates/game.html`中找到的`game`模板会响应绑定控制器的变化。首先，`New Game`按钮的点击事件绑定到`createNewGame`操作：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The score label is bound to the controller''s `score` property:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 分数标签绑定到控制器的`score`属性：
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The grid is composed of cells overlaid by tiles, and so we first lay out the
    16 cells as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 网格由覆盖在瓷砖上的单元格组成，因此我们首先按照以下方式布局16个单元格：
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we lay out the tiles:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们布局瓷砖：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The main role of `App.TileView` is to animate the tile movement as well as
    showing the different tile shades based on their values. Now, getting a smooth
    slide transition is a bit tricky. Once a tile view has been inserted into the
    DOM, we first set the initial position of the tile in `didInsertElement`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.TileView`的主要作用是动画化瓷砖移动以及根据它们的值显示不同的瓷砖阴影。现在，获得平滑的滑动过渡有点棘手。一旦瓷砖视图被插入到 DOM
    中，我们首先在`didInsertElement`中设置瓷砖的初始位置：'
- en: '[PRE47]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the tile is in motion, we use the `requestAnimationFrame` component to set
    the new position before the next browser repaint:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果瓷砖正在移动，我们使用`requestAnimationFrame`组件在下一个浏览器重绘之前设置新的位置：
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Serving images and fonts
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端的图像和字体
- en: 'Images and fonts specified in styles can be referenced using their corresponding
    relative paths, as shown in the first line of the game component''s style sheet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式表中指定的图像和字体可以使用它们对应的相对路径进行引用，如游戏组件样式表的第一行所示：
- en: '[PRE49]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Component automatically resolves these paths:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 组件会自动解析这些路径：
- en: '[PRE50]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Notice that the assets are symbolically linked to the build folder. If needed,
    we can prefix these paths with the required static root. For example, if Django
    was used to server these files, we would add a prefix flag to the build command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，资源是符号链接到构建文件夹的。如果需要，我们可以用所需的静态根前缀这些路径。例如，如果使用 Django 来服务器这些文件，我们会在构建命令中添加一个前缀标志：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This would result in a path such as this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致如下路径：
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On some platforms, symbolical links may cause problems, so you can pass the
    `copy` flag to copy the files instead of linking them, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些平台上，符号链接可能会引起问题，因此你可以传递`copy`标志来复制文件而不是链接它们，如下所示：
- en: '[PRE53]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Component is a great tool that you can use to organize your Ember.js project.
    It''s a great tool that can be used to install and reuse tiny components hosted
    in Github. As a rule of thumb, publish Ember.js components as either mixins or
    those that extend the `Em.Component` class. For example, the component at [http://github.com/kelonye/ember-link](http://github.com/kelonye/ember-link)
    is an example of a good minimal component that can be extended into any project
    view:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一个你可以用来组织你的 Ember.js 项目的强大工具。它是一个可以用来安装和重用托管在 Github 上的小型组件的强大工具。一般来说，将 Ember.js
    组件发布为混合或扩展`Em.Component`类的组件。例如，位于[http://github.com/kelonye/ember-link](http://github.com/kelonye/ember-link)的组件是一个很好的最小组件示例，它可以扩展到任何项目视图中：
- en: '[PRE54]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This way, the Ember.js community can benefit from commonly used snippets that
    result in faster project developments.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Ember.js 社区就可以从常用的代码片段中受益，从而加快项目开发速度。
