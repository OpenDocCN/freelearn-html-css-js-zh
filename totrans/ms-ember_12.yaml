- en: Chapter 12. Modularizing Your Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many Ember.js projects get complex, and so it may be necessary to modularize
    the project for maintainability through a combination of any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the project into a number of script files and load them individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate the script files into one build file. This reduces the number of
    requests the browser needs to make to the backend; hence, the page load time is
    reduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain reusable components that can be used on a number of projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of open source tools that can be used to perform such tasks.
    These tools may contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A package manager that installs external reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A build process that intelligently concatenates all the project files into a
    single build file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of these popular tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Grunt (a build tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gulp (a build tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bower (a package manager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPM (a package manager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browserify (a build tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember CLI (a build tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brocolli (a build tool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ember add-ons ([http://emberaddons.com](http://emberaddons.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duojs (build tool and package manager based on Component and Browserify)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component (a build tool and package manager)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these can be used to get the job done in any combination. In this chapter,
    we will be discussing how to use **Component** to easily manage complex Ember.js
    projects. It's worth noting that the ES6 module feature is being worked on to
    tackle these problems. Luckily, some of these tools are compliant with the specifications,
    thereby enabling easy migration.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Component build tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Component is both a package manager and a build tool for client-side web projects.
    It provides the ability to install external project dependencies as well as organize
    a project into several local components that later can be built into a single
    build file. The chapter sample uses the tool to install and use the required project
    dependencies. To run the sample, we first need to install Node.js, which can be
    downloaded from [http://nodejs.org/download](http://nodejs.org/download). To run
    the project, simply execute `make` in a terminal shell. If the system doesn''t
    have `make` installed, the project can still be run with the following commands,
    the first of which installs the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Component is an NPM package and can therefore be installed by adding the dependency
    to `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we install the external component dependencies and build the file using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The app can finally be opened by loading `index.html` in the browser. This app
    is an implementation of the popular 2048 game ([http://gabrielecirulli.github.io/2048/](http://gabrielecirulli.github.io/2048/))
    by Gabriele Cirulli, and takes advantage of the Ember.js' runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The open source game, shown in the following screenshot, is a good introduction
    to web game development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Component build tool](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Code organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Component tool requires a project to be organized into `components`. A
    component is a reusable module that can contain scripts, styles, images, templates,
    and fonts defined in a `component.json` configuration file. It can also optionally
    define dependencies that are themselves components. These dependencies can be
    local or remote. Therefore, a project can be thought of as a tree of components,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code organization](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this project, the root of the project defines a component `2048`, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This component doesn''t include any scripts or styles because these are contained
    in child components, and so we do not have to specify them. It does, however,
    specify that it depends on a local component named `app` that is found in the
    `lib` relative directory, which in turn defines yet another local component dependency
    `game`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Installing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A component can define remote components as dependencies. A remote component
    is an external Git repository that is hosted in either Github or BitBucket. Some
    versions of components allow the installation of components from other remote
    components as long as they adhere to a `<username>/<repo>` format. In this case,
    the app component defines one dependency that will be installed from [http://github.com/kelonye/ember](http://github.com/kelonye/ember):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The game component, on the other hand, also defines three dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These components can be installed into the `components/` relative directory
    by invoking the following in the project''s root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We could also simply ask `component install` if the module is installed globally
    with `npm install -g component` or if `./node_modules/.bin` is added to the bash
    profile PATH.
  prefs: []
  type: TYPE_NORMAL
- en: Building components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the remote components have been installed, the project can be built by
    invoking the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This concatenates scripts and styles into a `builds` folder. By default, the
    folder is named `build` but can be changed by passing the `–out` or `-o` flag.
    Also, by default, the built files are named `build.js` and `build.css`, but this
    can be altered using the `–name` or `-n` flag, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Loading the built files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The built files are referenced from the build folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the application is booted by *requiring* the `app` component. The
    `app` component includes an `index.js` file that gets executed in the process.
    Every requirable component needs to specify this file in its `.scripts` property
    in the configuration file. It may also specify the main file via the `.main` flag,
    so we can name the `index.js` file as `app.js` and then set the main flag as `"app.js"`.
    The script requires the remotely-installed `ember.js` component, creates the application,
    and defines the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A good way to organize local components is to separate them by the routes or
    resources defined in the router; in this case, the `app` and `game` components.
    Each of the components contains corresponding controllers, views, models, routes,
    and template scripts, explicitly defined in the configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These are required in the main script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `app` component defines two templates that are required accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `index` route redirects the application state to the game route.
  prefs: []
  type: TYPE_NORMAL
- en: Game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss the `game` component, it''s a good idea to discuss the game
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: The game is a 4 by 4 grid whose moves are made by sliding tiles using the keyboard
    arrow keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tiles merge if they are of equal magnitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each move generates a new random tile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The objective of the game is to slide these tiles until one of them merges to
    a value of 2048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The grid cells are represented by the `App.Cell` model located in `models.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A cell is considered a tile if its value is defined. When the game begins,
    we first populate the game with the cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The game controller houses the cells and so we populate it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we restore the saved game from the local storage using the `store`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we cache the traversals for the four possible game move directions
    that we will need to make at this stage. For example, when the user makes an upward
    move, we will traverse cells from the left to the right and downwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will generate the first two tiles of the game if its state is not
    restored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The random tile generator simply picks a random cell and converts it into a
    tile by setting its value to either `2` or `4` if the game hasn''t ended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The game view sets up a listener to play the moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user makes a play, we send the key code of the pressed key to the
    game controller''s `onMove` action. If the game hasn''t ended, the action will
    first determine which direction the play was made in, with the help of the `keycode`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to find the traversal matrix that corresponds to the direction
    of the play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then traverse through the cells and attempt to move the tile, if eligible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For each of these tiles, we find the farthest new cell that it can occupy,
    by calling the `getNewFarthestCell` controller method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes the cell to move the trajectory vector and the magnitude
    of the movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is meant to be recursive, that is, we incrementally move the cell
    in the direction of the game until we find the farthest cell. First, we find the
    position of the current, previous, and next cells, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see whether the cell is off the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new cell is indeed outbound, we return the previous cell as the new
    position of the tile. However, if we encounter a tile, we test whether the two
    can be merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding conditions aren''t met, we proceed to test the next cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we check to see whether the cell can actually move to the new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a state that determines whether a cell moved within that iteration
    for later reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If a merge has already occurred, then we need to use the cell just before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we move the tile and increment the game''s score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the tile has moved, we add it to the new set of tiles that would be rendered
    on repaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For each merge in the iteration, we need to check whether the game has been
    won or lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As per Gabriele''s game specification, a new random tile can only be generated
    if any of the existing tiles move after the end of the iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to check if the game has ended by catching the raised exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The method that is called displays a message overlay, indicating whether the
    game has been won or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `game` template, found in `templates/game.html`, reacts to changes in the
    bound controller. First, the `New Game` button''s click event is bound to the
    `createNewGame` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The score label is bound to the controller''s `score` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The grid is composed of cells overlaid by tiles, and so we first lay out the
    16 cells as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we lay out the tiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The main role of `App.TileView` is to animate the tile movement as well as
    showing the different tile shades based on their values. Now, getting a smooth
    slide transition is a bit tricky. Once a tile view has been inserted into the
    DOM, we first set the initial position of the tile in `didInsertElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the tile is in motion, we use the `requestAnimationFrame` component to set
    the new position before the next browser repaint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Serving images and fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images and fonts specified in styles can be referenced using their corresponding
    relative paths, as shown in the first line of the game component''s style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Component automatically resolves these paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the assets are symbolically linked to the build folder. If needed,
    we can prefix these paths with the required static root. For example, if Django
    was used to server these files, we would add a prefix flag to the build command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This would result in a path such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'On some platforms, symbolical links may cause problems, so you can pass the
    `copy` flag to copy the files instead of linking them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Component is a great tool that you can use to organize your Ember.js project.
    It''s a great tool that can be used to install and reuse tiny components hosted
    in Github. As a rule of thumb, publish Ember.js components as either mixins or
    those that extend the `Em.Component` class. For example, the component at [http://github.com/kelonye/ember-link](http://github.com/kelonye/ember-link)
    is an example of a good minimal component that can be extended into any project
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This way, the Ember.js community can benefit from commonly used snippets that
    result in faster project developments.
  prefs: []
  type: TYPE_NORMAL
