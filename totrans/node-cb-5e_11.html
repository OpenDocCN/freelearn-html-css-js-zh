<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-345">
    <a id="_idTextAnchor353">
    </a>
    
     11
    
   </h1>
   <h1 id="_idParaDest-346">
    <a id="_idTextAnchor354">
    </a>
    
     Deploying Node.js Microservices
    
   </h1>
   <p>
    
     The term
    
    <strong class="bold">
     
      microservices
     
    </strong>
    
     is used to
    
    <a id="_idIndexMarker852">
    </a>
    
     describe applications that have been built based on the microservice architecture paradigm.
    
    
     This architecture encourages larger applications to be built as a set of smaller modular applications, where each application focuses on one key concern.
    
    
     Microservice architectures are a contrast to the monolithic architectures of the past.
    
    <strong class="bold">
     
      Monolith
     
    </strong>
    
     is a term given to an application
    
    <a id="_idIndexMarker853">
    </a>
    
     that handles many
    
    
     
      disparate concerns.
     
    
   </p>
   <p>
    
     There are numerous benefits to adopting a microservice architecture.
    
    
     Ensuring that an application only serves one purpose means that the application can be optimized to best serve that purpose.
    
    
     Microservices help to decouple various parts of a system, which can result in easier debuggability if something goes wrong.
    
    
     Adopting a microservice architecture also enables you to scale different parts of the
    
    
     
      system independently.
     
    
   </p>
   <p>
    
     There are not only technical benefits to adopting a microservice architecture.
    
    
     Separating microservices into separate code bases can enable smaller teams to have autonomy over the microservices they’re responsible for.
    
    
     Many microservice-based systems are written in a variety of frameworks and languages.
    
    
     Development teams can choose the language and framework they feel is best suited for
    
    
     
      their microservice.
     
    
   </p>
   <p>
    
     Microservices can, however, increase complexity due to the management of multiple services, which requires mature DevOps practices and comprehensive monitoring.
    
    
     For this reason, microservices are often not suitable for simple applications where the management overhead outweighs
    
    
     
      the benefits.
     
    
   </p>
   <p>
    
     Node.js microservices commonly
    
    <a id="_idIndexMarker854">
    </a>
    
     expose
    
    <strong class="bold">
     
      RESTful
     
    </strong>
    
     APIs.
    
    <strong class="bold">
     
      Representational State Transfer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      REST
     
    </strong>
    
     ) is very
    
    <a id="_idIndexMarker855">
    </a>
    
     popular.
    
    
     A RESTful API exposes its API via HTTP, making appropriate use of the HTTP verbs.
    
    
     For example, if a blogging service exposed a RESTful API, you’d expect it to expose an endpoint to which you could send an HTTP GET request to retrieve a blog post.
    
    
     Similarly, it would likely expose an endpoint to which you could send an HTTP POST request, with data, to publish
    
    
     
      new blogs.
     
    
   </p>
   <p>
    
     Microservices and container technologies go hand in hand.
    
    
     Cloud and container technologies are growing in adoption, with Docker and Kubernetes, which are the leading choices for deploying
    
    
     
      microservice-based applications.
     
    
   </p>
   <p>
    
     This chapter contains the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Generating a microservice
     
     
      
       with LoopBack
      
     
    </li>
    <li>
     
      Consuming
     
     
      
       a microservice
      
     
    </li>
    <li>
     
      Building a
     
     
      
       Docker container
      
     
    </li>
    <li>
     
      Publishing a
     
     
      
       Docker image
      
     
    </li>
    <li>
     
      Deploying
     
     
      
       to Kubernetes
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-347">
    <a id="_idTextAnchor355">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     You will need to have Node.js installed, preferably the latest version – Node.js 22.
    
    
     You’ll also need access to an editor and browser of
    
    
     
      your choice.
     
    
   </p>
   <p>
    
     Before completing this chapter, it is recommended that you have some understanding of HTTP protocols – you can refer to
    
    <a href="B19212_04.xhtml#_idTextAnchor100">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The latter three recipes of this chapter will require you to have
    
    <strong class="bold">
     
      Docker for Desktop
     
    </strong>
    
     installed.
    
    
     It is recommended to install Docker for Desktop
    
    
     
      from
     
    
    <a href="https://docs.docker.com/engine/install/">
     
      
       https://docs.docker.com/engine/install/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The recipe code for this chapter can be found at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     in the
    
    
     <strong class="source-inline">
      
       Chapter11
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <h1 id="_idParaDest-348">
    <a id="_idTextAnchor356">
    </a>
    
     Generating a microservice with LoopBack
    
   </h1>
   <p>
    <strong class="bold">
     
      LoopBack
     
    </strong>
    
     (
    
    <a href="https://loopback.io/">
     
      https://loopback.io/
     
    </a>
    
     ) is an
    
    <a id="_idIndexMarker856">
    </a>
    
     extensible open source Node.js framework
    
    <a id="_idIndexMarker857">
    </a>
    
     that is purpose-built for creating
    
    <a id="_idIndexMarker858">
    </a>
    
     REST APIs and microservices.
    
    
     Early versions of LoopBack were both inspired by and based directly on the Express.js web framework.
    
    
     The most recent version, LoopBack 4, went through a significant refactor and was rewritten in TypeScript.
    
    
     This refactor allowed the maintainers to expand the features of LoopBack without being restricted by the technical implementation decisions made in
    
    
     
      prior versions.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to use
    
    <a id="_idIndexMarker859">
    </a>
    
     the LoopBack 4
    
    <strong class="bold">
     
      Command-Line Interface
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CLI
     
    </strong>
    
     ) to generate a
    
    
     
      Node.js microservice.
     
    
   </p>
   <h2 id="_idParaDest-349">
    <a id="_idTextAnchor357">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To prepare for the recipe, we need to globally install the LoopBack CLI.
    
    
     Enter the following command in
    
    
     
      your terminal:
     
    
   </p>
   <pre class="console">
$ npm install --global @loopback/cli</pre>
   <p>
    
     Now that we have globally installed the LoopBack CLI, let’s move on to
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-350">
    <a id="_idTextAnchor358">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to generate a RESTful API, which will form our Node.js microservice.
    
    
     The RESTful API that we will create will mimic a
    
    
     
      bookstore inventory:
     
    
   </p>
   <ol>
    <li>
     
      The LoopBack CLI should be available in your path as
     
     <strong class="source-inline">
      
       lb4
      
     </strong>
     
      .
     
     
      To start generating the project, we call the LoopBack CLI, providing a project name.
     
     
      Let’s give our project the name
     
     <strong class="source-inline">
      
       loopback-bookstore
      
     </strong>
     
      .
     
     
      Enter the following command in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ lb4 loopback-bookstore</strong></pre>
    </li>
    <li>
     
      Entering the command will start an interactive interface where the LoopBack CLI will request
     
     <a id="_idIndexMarker860">
     </a>
     
      information
     
     <a id="_idIndexMarker861">
     </a>
     
      for your new project.
     
     
      For the project description, project root directory, and application class name, just hit
     
     <em class="italic">
      
       Enter
      
     </em>
     
      to accept the
     
     
      
       default names.
      
     
    </li>
    <li>
     
      The fourth CLI question asks the user which features should be enabled in the project.
     
     
      Hit
     
     <em class="italic">
      
       Enter
      
     </em>
     
      to enable all features.
     
     
      If you are shown a subsequent command detailing that Yarn is available, enter
     
     <strong class="source-inline">
      
       N
      
     </strong>
     
      to indicate we do not wish to enable it
     
     
      
       by default.
      
     
    </li>
    <li>
     
      You should now see the LoopBack CLI scaffolding your application.
     
     
      Expect to see output starting with the following in your terminal window, detailing files and directories that have
     
     
      
       been created:
      
     
     <pre class="source-code">
    force loopback-bookstore/.yo-rc.json
   create loopback-bookstore/.eslintignore
   create loopback-bookstore/.eslintrc.js
   create loopback-bookstore/.mocharc.json
   create loopback-bookstore/.prettierignore
   create loopback-bookstore/.prettierrc
   create loopback-bookstore/DEVELOPING.md
   create loopback-bookstore/package.json
   create loopback-bookstore/tsconfig.json
...</pre>
    </li>
    <li>
     
      The LoopBack CLI has now generated our application.
     
     
      It should have also automatically
     
     <a id="_idIndexMarker862">
     </a>
     
      installed our
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      dependencies.
     
     
      Navigate
     
     <a id="_idIndexMarker863">
     </a>
     
      to the application directory and start the application with the
     
     
      
       following commands:
      
     
     <pre class="source-code">
<strong class="bold">$ cd loopback-bookstore</strong>
<strong class="bold">$ npm install</strong>
<strong class="bold">$ npm start</strong></pre>
    </li>
    <li>
     
      If you navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in your browser, you should expect to see the
     
     
      
       application running:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore application" src="img/Figure_11.1_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.1 – The generated LoopBack home page for the LoopBack bookstore application
    
   </p>
   <ol>
    <li value="7">
     
      Go back to your terminal and press
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     <em class="italic">
      
       C
      
     </em>
     
      to stop the application.
     
     
      So far, the LoopBack CLI has just generated a barebones project structure.
     
     
      Now we can build our
     
     <a id="_idIndexMarker864">
     </a>
     
      bookstore
     
     <a id="_idIndexMarker865">
     </a>
     
      API.
     
     
      We can do this using LoopBack’s model generator.
     
     
      Enter the following command to start creating
     
     
      
       a model:
      
     
     <pre class="source-code">
<strong class="bold">$ lb4 model</strong></pre>
    </li>
    <li>
     
      LoopBack’s model generator will open an interactive CLI where we can define the model and its properties.
     
     
      The model we want to create is a book of the
     
     <strong class="bold">
      
       Entity
      
     </strong>
     
      type.
     
     
      First, add
     
     <a id="_idIndexMarker866">
     </a>
     
      the
     
     <strong class="source-inline">
      
       id
      
     </strong>
     
      property, which will be a number.
     
     
      You’ll also need to add
     
     <strong class="source-inline">
      
       author
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       title
      
     </strong>
     
      properties to the model, which should both be mandatory and of the string type.
     
     
      Enter these via the interactive session.
     
     
      The transcript of the session should look like
     
     
      
       the following:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.2 – An overview of the expected transcript of the LoopBack model generator" src="img/Figure_11.2_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.2 – An overview of the expected transcript of the LoopBack model generator
    
   </p>
   <ol>
    <li value="9">
     
      Now that we’ve
     
     <a id="_idIndexMarker867">
     </a>
     
      created
     
     <a id="_idIndexMarker868">
     </a>
     
      our model, we need to create our data source using LoopBack’s data source CLI.
     
     
      Enter the following command in your
     
     
      
       terminal window:
      
     
     <pre class="source-code">
<strong class="bold">$ lb4 datasource</strong></pre>
    </li>
    <li>
     
      The interactive CLI will request information about the data source.
     
     
      We’re going to use an in-memory data store.
     
     
      The values you should supply should be
     
     <strong class="source-inline">
      
       Data source name: local
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       In-memory DB
      
     </strong>
     
      .
     
     
      For the last two questions, hit
     
     <em class="italic">
      
       Enter
      
     </em>
     
      to accept the defaults.
     
     
      Expect the transcript of your session to match
     
     
      
       the following:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.3 – An overview of the transcript of the LoopBack data source generator" src="img/Figure_11.3_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.3 – An overview of the transcript of the LoopBack data source generator
    
   </p>
   <ol>
    <li value="11">
     
      Next, we need to create a LoopBack repository.
     
     
      This is a LoopBack class that binds the data source and the model.
     
     
      Enter the following command to start the repository
     
     <a id="_idIndexMarker869">
     </a>
     
      
       generator
      
     
     
      <a id="_idIndexMarker870">
      </a>
     
     
      
       interface:
      
     
     <pre class="source-code">
<strong class="bold">$ lb4 repository</strong></pre>
    </li>
    <li>
     
      For the repository, we want to use
     
     <strong class="source-inline">
      
       LocalDatasource
      
     </strong>
     
      for the
     
     <strong class="bold">
      
       Book
      
     </strong>
     
      model with a
     
     <strong class="source-inline">
      
       DefaultCrudRepository
      
     </strong>
     
      base class.
     
     
      The terminal should match the
     
     
      
       following
      
     
     
      <a id="_idIndexMarker871">
      </a>
     
     
      
       output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.4 – Expected transcript of the LoopBack repository generator" src="img/Figure_11.4_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.4 – Expected transcript of the LoopBack repository generator
    
   </p>
   <ol>
    <li value="13">
     
      Now, we need to create a LoopBack controller.
     
     
      A LoopBack controller handles the API requests and responses.
     
     
      Enter the following command to start the controller
     
     
      
       generator interface:
      
     
     <pre class="source-code">
<strong class="bold">$ lb4 controller</strong></pre>
    </li>
    <li>
     
      Our controller should be a
     
     <strong class="bold">
      
       REST Controller with Create, Read, Update, and Delete
      
     </strong>
     
      (
     
     <strong class="bold">
      
       CRUD
      
     </strong>
     
      )
     
     <strong class="bold">
      
       functions
      
     </strong>
     
      named
     
     <strong class="source-inline">
      
       Books
      
     </strong>
     
      .
     
     
      For the remainder of the questions, you can
     
     <a id="_idIndexMarker872">
     </a>
     
      accept
     
     <a id="_idIndexMarker873">
     </a>
     
      the
     
     <a id="_idIndexMarker874">
     </a>
     
      defaults by hitting
     
     <em class="italic">
      
       Enter
      
     </em>
     
      .
     
     
      The terminal should look
     
     
      
       as follows:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.5 – An overview of the transcript of the LoopBack controller generator" src="img/Figure_11.5_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.5 – An overview of the transcript of the LoopBack controller generator
    
   </p>
   <ol>
    <li value="15">
     
      Start the application with
     
     <strong class="source-inline">
      
       $ npm start
      
     </strong>
     
      and navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/explorer/
      
     </strong>
     
      .
     
     
      This will open up the LoopBack API explorer that we can use to test our API.
     
     
      Observe that the routes for various HTTP verbs have been automatically generated
     
     
      
       for us:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application" src="img/Figure_11.6_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.6 – LoopBack API Explorer for the loopback-bookstore application
    
   </p>
   <ol>
    <li value="16">
     
      Navigate to the
     
     <a id="_idIndexMarker875">
     </a>
     
      HTTP
     
     <a id="_idIndexMarker876">
     </a>
     
      POST route in the explorer.
     
     
      Clicking the
     
     <strong class="bold">
      
       Try it out
      
     </strong>
     
      button will open an interface where you will be able to add a book to the inventory.
     
     
      Change the sample
     
     <strong class="source-inline">
      
       title
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       author
      
     </strong>
     
      values and then
     
     
      
       click
      
     
     
      <strong class="bold">
       
        Execute
       
      </strong>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.7 – LoopBack API Explorer request interface" src="img/Figure_11.7_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.7 – LoopBack API Explorer request interface
    
   </p>
   <ol>
    <li value="17">
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/books
      
     </strong>
     
      .
     
     
      This route will return a JSON array of all of
     
     <a id="_idIndexMarker877">
     </a>
     
      the
     
     <a id="_idIndexMarker878">
     </a>
     
      books stored.
     
     
      Expect to see the book that we added in the
     
     
      
       previous step:
      
     
     <pre class="source-code">
[{"id":1,"title":"Watership Down","author":"Richard Adams"}]</pre>
    </li>
   </ol>
   <p>
    
     We’ve generated a RESTful API that represents a bookstore inventory using the
    
    
     
      LoopBack CLI.
     
    
   </p>
   <h2 id="_idParaDest-351">
    <a id="_idTextAnchor359">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The recipe demonstrated how to build a RESTful API for a sample
    
    
     
      bookstore inventory.
     
    
   </p>
   <p>
    
     The first command we supplied to the generator was
    
    <strong class="source-inline">
     
      $ lb4 loopback-bookstore
     
    </strong>
    
     .
    
    
     This command scaffolds a LoopBack project structure for our application.
    
    
     In the recipe, we enabled all the following
    
    
     
      optional features:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       ESLint
      
     </strong>
     
      : A popular linter
     
     <a id="_idIndexMarker879">
     </a>
     
      with some pre-defined
     
     
      
       linter rules
      
     
    </li>
    <li>
     <strong class="bold">
      
       Prettier
      
     </strong>
     
      : A popular code formatter that is used throughout the examples in
     
     
      
       this book
      
     
    </li>
    <li>
     <strong class="bold">
      
       Mocha
      
     </strong>
     
      : A Node.js
     
     
      
       test framework
      
     
    </li>
    <li>
     <strong class="bold">
      
       Loopback Build
      
     </strong>
     
      : A set of LoopBack build helpers, exposed via the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        loopback/build
       
      </strong>
     
     
      
       module
      
     
    </li>
    <li>
     <strong class="bold">
      
       VSCode
      
     </strong>
     
      : Configuration files for the
     
     
      
       VSCode editor
      
     
    </li>
    <li>
     <strong class="bold">
      
       Docker
      
     </strong>
     
      : Generates
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       .dockerignore
      
     </strong>
     
      for
     
     
      
       the application
      
     
    </li>
    <li>
     <strong class="bold">
      
       Repositories
      
     </strong>
     
      : Enables convenience methods that can automatically bind
     
     
      
       repository classes
      
     
    </li>
    <li>
     <strong class="bold">
      
       Services
      
     </strong>
     
      : Includes service-proxy imports (refer to
     
     <a href="https://loopback.io/doc/en/lb4/Service.html">
      
       https://loopback.io/doc/en/lb4/Service.html
      
     </a>
     
      for more information
     
     
      
       on services)
      
     
    </li>
   </ul>
   <p>
    
     Once the optional features were selected, the LoopBack CLI generated a base application structure.
    
    
     This
    
    <a id="_idIndexMarker880">
    </a>
    
     structure
    
    <a id="_idIndexMarker881">
    </a>
    
     includes directories and files related to the optional features that were selected.
    
    
     For example, the
    
    <strong class="source-inline">
     
      eslintrc.js
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      mocharc.js
     
    </strong>
    
     files were generated to configure ESLint
    
    
     
      and Mocha.
     
    
   </p>
   <p>
    
     We used the LoopBack model generator to create representations of the data we needed to store.
    
    
     In our case, we created one model named
    
    <strong class="source-inline">
     
      Book
     
    </strong>
    
     that contained the data we wished to store for each book.
    
    
     The LoopBack generator assisted us in adding these properties, including specifying which type the properties should be and whether they are required or optional properties.
    
    
     In larger and more complex APIs, it’s common to have multiple models, where some models may reference others, in a comparable manner to how relational databases
    
    
     
      are structured.
     
    
   </p>
   <p>
    
     The model generator created our
    
    <strong class="source-inline">
     
      Book
     
    </strong>
    
     model in
    
    <strong class="source-inline">
     
      src/models/book.model.ts
     
    </strong>
    
     .
    
    
     The model file contains a representation of a book in the form of a
    
    
     
      TypeScript class.
     
    
   </p>
   <p>
    
     After creating the model, we used the LoopBack data source generator to create a data source.
    
    
     We opted to use an in-memory data source to avoid the need to provision an instance of a database.
    
    
     Using an in-memory data source means that by default, when we stop our API from running, the data is lost.
    
    
     LoopBack handles data source integrations, removing the need for the developer to create and set up the data store connection.
    
    
     For the most part, this means the developer will not need to write code that is specific to the data store, making it easier to change between
    
    
     
      data stores.
     
    
   </p>
   <p>
    
     With LoopBack 4, it is necessary to create a repository for our
    
    <strong class="bold">
     
      Book
     
    </strong>
    
     model.
    
    
     A repository acts as an interface to a model, providing strong-typed
    
    
     
      data operations.
     
    
   </p>
   <p>
    
     The final step of the recipe involved generating a controller to handle API requests and responses.
    
    
     We instructed the generator to create a REST Controller with CRUD functions for the
    
    <strong class="source-inline">
     
      Book
     
    </strong>
    
     model.
    
    <strong class="bold">
     
      CRUD
     
    </strong>
    
     covers the four basic functions that enable
    
    
     
      persistent storage.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Book
     
    </strong>
    
     controller
    
    <a id="_idIndexMarker882">
    </a>
    
     was
    
    <a id="_idIndexMarker883">
    </a>
    
     created at
    
    <strong class="source-inline">
     
      src/controllers/books.controller.ts
     
    </strong>
    
     and contains generated functions to handle each REST API operation for our
    
    <strong class="source-inline">
     
      Book
     
    </strong>
    
     model.
    
    
     For example, the following code was generated in the controller to handle an HTTP GET request on the
    
    <strong class="source-inline">
     
      /books
     
    </strong>
    
     route.
    
    
     This route returns all books in the
    
    
     
      data store:
     
    
   </p>
   <pre class="source-code">
@get('/books', {
    responses: {
      '200': {
        description: 'Array of Book model instances',
        content: {
          'application/json': {
            schema: {
              type: 'array',
              items: getModelSchemaRef(Book, {includeRelations: true}),
            },
          },
        },
      },
    },
  })
  async find(
    @param.filter(Book) filter?: Filter&lt;Book&gt;,
  ): Promise&lt;Book[]&gt; {
    return this.bookRepository.find(filter);
  }</pre>
   <p>
    
     The controller, repositories, and data sources that were created are all loaded and bound to the application at boot time.
    
    
     This is handled by the
    
    <strong class="source-inline">
     
      @
     
    </strong>
    
     <strong class="source-inline">
      
       loopback/boot
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <p>
    
     In the final part of the recipe, we used the API explorer (
    
    <strong class="source-inline">
     
      http://localhost:3000/explorer/
     
    </strong>
    
     ) to send requests to our API.
    
    
     The route explorer displays the
    
    <a id="_idIndexMarker884">
    </a>
    
     available routes and provides
    
    <a id="_idIndexMarker885">
    </a>
    
     sample requests for each route, allowing for an intuitive way to test your API.
    
    
     This explorer is implemented using Swagger
    
    
     
      UI (
     
    
    <a href="https://swagger.io/">
     
      
       https://swagger.io/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     LoopBack also allows for the generation of an OpenAPI specification document for the API, providing a standard interface for the RESTful API that includes human- and machine-readable definitions of the API routes.
    
    
     This can be achieved by running the
    
    <strong class="source-inline">
     
      npm run openapi-spec ./open-api.json
     
    </strong>
    
     command, which will create an
    
    <strong class="source-inline">
     
      open-api.json
     
    </strong>
    
     file containing the
    
    
     
      OpenAPI specification.
     
    
   </p>
   <p>
    
     This recipe highlighted that it is possible to generate a RESTful Node.js API without writing any code.
    
    
     Once your base API has been generated, it would then be possible to extend the application with any necessary business logic.
    
    
     LoopBack abstracts and handles some of the common technical tasks related to creating APIs, such as implementing CRUD operations.
    
    
     This enables developers to focus on the business logic of their microservice, rather than
    
    <a id="_idIndexMarker886">
    </a>
    
     underlying and repetitive
    
    <a id="_idIndexMarker887">
    </a>
    
     
      technical implementations.
     
    
   </p>
   <h2 id="_idParaDest-352">
    <a id="_idTextAnchor360">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Consuming a microservice
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-353">
    <a id="_idTextAnchor361">
    </a>
    
     Consuming a microservice
    
   </h1>
   <p>
    
     In this recipe, we will create
    
    <a id="_idIndexMarker888">
    </a>
    
     an Express.js web application that will consume the
    
    <strong class="source-inline">
     
      loopback-bookstore
     
    </strong>
    
     microservice created in the previous recipe,
    
    <em class="italic">
     
      Generating a microservice with LoopBack
     
    </em>
    
     .
    
    
     This will demonstrate how modern web architectures are implemented based on the
    
    
     
      microservice pattern.
     
    
   </p>
   <h2 id="_idParaDest-354">
    <a id="_idTextAnchor362">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In this recipe, we will be consuming the microservice created in the
    
    <em class="italic">
     
      Generating a microservice with LoopBack
     
    </em>
    
     recipe.
    
    
     If you have not completed that recipe, you can obtain the code from the Packt GitHub repository at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     in the
    
    
     <strong class="source-inline">
      
       Chapter11/loopback-bookstore
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     We will also be creating a frontend web application, using the Express.js generator to create a base for our web application.
    
    
     For more information on the Express.js generator,
    
    
     
      visit
     
    
    <a href="https://expressjs.com/en/starter/generator.html">
     
      
       https://expressjs.com/en/starter/generator.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Enter the following commands in your terminal to create the base application using the
    
    
     
      Express.js generator:
     
    
   </p>
   <pre class="console">
$ npx express-generator --view=ejs ./bookstore-web-app
$ cd bookstore-web-app
$ npm install</pre>
   <p>
    
     We will be creating a route and HTML form to add a book to the bookstore inventory.
    
    
     Let’s create the files for those
    
    
     
      in advance:
     
    
   </p>
   <pre class="console">
$ touch routes/inventory.js views/inventory.ejs</pre>
   <p>
    
     Now that we have a base Express.js web application, we’re ready to move on to the recipe steps, where we’ll extend the application to interact with the bookstore
    
    
     
      inventory microservice.
     
    
   </p>
   <h2 id="_idParaDest-355">
    <a id="_idTextAnchor363">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re going to build a web application with Express.js that consumes our
    
    <strong class="source-inline">
     
      loopback-bookstore
     
    </strong>
    
     microservice.
    
    
     The web application should enable us to view the inventory and add a book to
    
    
     
      the inventory:
     
    
   </p>
   <ol>
    <li>
     
      Start by adding two routes to the application.
     
     
      The first route we will add is a
     
     <strong class="source-inline">
      
       /inventory
      
     </strong>
     
      route that will accept an HTTP GET request.
     
     
      This route will respond with a list of books in the inventory and an HTML form that can be used to add a book to the inventory.
     
     
      The second route will accept an HTTP POST request on the
     
     <strong class="source-inline">
      
       /inventory/add
      
     </strong>
     
      endpoint.
     
     
      The
     
     <strong class="source-inline">
      
       /inventory/add
      
     </strong>
     
      route will interact with the bookstore inventory microservice to persist a new book.
     
     
      Add the
     
     <a id="_idIndexMarker889">
     </a>
     
      following to
     
     <strong class="source-inline">
      
       routes/inventory.j
      
      <a id="_idTextAnchor364">
      </a>
      
       s
      
     </strong>
     
      to create these
     
     
      
       two routes:
      
     
     <pre class="source-code">
const { Router } = require('express');
const router = Router();
router.get('/', function (req, res) {
  fetch('http://localhost:3000/books')
    .then((res) =&gt; res.json())
    .then((json) =&gt;
      res.render('inventory', {
        books: json,
      })
    );
});
router.post('/add', function (req, res) {
  console.log(req.body);
  fetch('http://localhost:3000/books', {
    method: "POST",
    body: JSON.stringify(req.body),
    headers: { 'Content-Type': 'application/json' },
  })
    .then(res.redirect('/inventory'))
    .catch((err) =&gt; {
      throw err;
    });
});
module.exports = router;</pre>
    </li>
    <li>
     
      Now, in
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      , we need to
     
     <a id="_idIndexMarker890">
     </a>
     
      register our new
     
     <strong class="source-inline">
      
       inventory
      
     </strong>
     
      router.
     
     
      Add the following line to
     
     <strong class="source-inline">
      
       app.js
      
     </strong>
     
      to first import the router using
     
     <strong class="source-inline">
      
       var
      
     </strong>
     
      to be consistent with the rest of the generated file.
     
     
      Add the following just below the other
     
     
      
       router imports:
      
     
     <pre class="source-code">
var inventoryRouter = require('./routes/inventory');</pre>
    </li>
    <li>
     
      Next, we need to instruct our Express.js application to use the
     
     <strong class="source-inline">
      
       inventory
      
     </strong>
     
      router.
     
     
      Add the following line below
     
     
      <strong class="source-inline">
       
        app.use('/users', usersRouter);
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
app.use('/inventory', inventoryRouter);</pre>
    </li>
    <li>
     
      Our inventory routes reference
     
     <a id="_idIndexMarker891">
     </a>
     
      an
     
     <strong class="bold">
      
       Embedded JavaScript
      
     </strong>
     
      (
     
     <strong class="bold">
      
       EJS
      
     </strong>
     
      ) template file named
     
     <strong class="source-inline">
      
       inventory.ejs
      
     </strong>
     
      .
     
     
      This template file will output a list of all books stored in the inventory and expose a form we can use to add books to the inventory.
     
     
      Add the following to the
     
     <strong class="source-inline">
      
       views/inventory.ejs
      
     </strong>
     
      file we created in the
     
     <em class="italic">
      
       Getting started
      
     </em>
     
      section
     
     <a id="_idIndexMarker892">
     </a>
     
      of
     
     
      
       this recipe:
      
     
     <pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Book Inventory&lt;/title&gt;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Book Inventory&lt;/h1&gt;
    &lt;ul&gt;
        &lt;% for(let book of books) { %&gt;
            &lt;li&gt;&lt;%= book.title %&gt; - &lt;%= book.author %&gt;&lt;/li&gt;
        &lt;% } %&gt;
    &lt;/ul&gt;
    &lt;h2&gt;Add Book:&lt;/h2&gt;
    &lt;form action="/inventory/add" method="POST"&gt;
        &lt;label for="title"&gt;Title&lt;/label&gt;
        &lt;input type="text" name="title" /&gt;
        &lt;label for="author"&gt;Author&lt;/label&gt;
        &lt;input type="text" name="author" /&gt;
        &lt;button type="submit" value="Submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
    </li>
    <li>
     
      Start your
     
     <strong class="source-inline">
      
       loopback-bookstore
      
     </strong>
     
      microservice from the previous recipe.
     
     
      Do this from within the
     
     
      <strong class="source-inline">
       
        loopback-bookstore
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
<strong class="bold">$ npm start</strong></pre>
    </li>
    <li>
     
      Now, in a separate
     
     <a id="_idIndexMarker893">
     </a>
     
      terminal window, start the
     
     <strong class="source-inline">
      
       bookstore-web-app
      
     </strong>
     
      application with the following command.
     
     
      We’ll also pass a
     
     <strong class="source-inline">
      
       PORT
      
     </strong>
     
      environment variable to the start command to set a custom port.
     
     
      Express.js web applications default to port
     
     <strong class="source-inline">
      
       3000
      
     </strong>
     
      , but this will already be in use by our
     
     <strong class="source-inline">
      
       loopback-bookstore
      
     </strong>
     
      microservice, so we need to supply an alternative port.
     
     
      Run the following command from the
     
     
      <strong class="source-inline">
       
        bookstore-web-app
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
<strong class="bold">$ PORT=8080 npm start</strong></pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:8080/inventory
      
     </strong>
     
      in your browser and expect to see the
     
     
      
       following output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML form to add a new book" src="img/Figure_11.8_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.8 – HTML page showing an empty bookstore inventory and an HTML form to add a new book
    
   </p>
   <ol>
    <li value="8">
     
      Now we can try
     
     <a id="_idIndexMarker894">
     </a>
     
      adding a book to the inventory.
     
     
      Populate the
     
     <strong class="source-inline">
      
       title
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       author
      
     </strong>
     
      input fields and then click the
     
     <strong class="bold">
      
       Submit
      
     </strong>
     
      button.
     
     
      After submitting, you should expect to see the book you submitted added to
     
     
      
       the inventory:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.9 – Web page showing a populated bookstore inventory" src="img/Figure_11.9_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.9 – Web page showing a populated bookstore inventory
    
   </p>
   <p>
    
     We’ve successfully built
    
    <a id="_idIndexMarker895">
    </a>
    
     a frontend web application that communicates with our
    
    
     <strong class="source-inline">
      
       loopback-bookstore
      
     </strong>
    
    
     
      microservice.
     
    
   </p>
   <h2 id="_idParaDest-356">
    <a id="_idTextAnchor365">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we implemented a frontend web application layer that was backed by our
    
    
     <strong class="source-inline">
      
       loopback-bookstore
      
     </strong>
    
    
     
      microservice.
     
    
   </p>
   <p>
    
     When our
    
    <strong class="source-inline">
     
      /inventory
     
    </strong>
    
     web page loads, under the covers, the Express.js web frontend queries the data from the
    
    
     
      loopback microservice.
     
    
   </p>
   <p>
    
     Our Express.js server sends an HTTP POST request to the
    
    <strong class="source-inline">
     
      http://localhost:3000/books
     
    </strong>
    
     endpoint.
    
    
     The request is supplied with the HTML
    
    
     
      form data.
     
    
   </p>
   <p>
    
     Once the request to the LoopBack microservice is complete, the Express.js web application redirects to the
    
    <strong class="source-inline">
     
      /inventory
     
    </strong>
    
     route.
    
    
     This refreshes the template, which will then list the newly
    
    
     
      added book.
     
    
   </p>
   <p>
    
     This architecture demonstrates how you can modularize an application by building the backend API, in this case,
    
    <strong class="source-inline">
     
      loopback-microservice
     
    </strong>
    
     , separately from the frontend web application.
    
    
     This enables both applications to be scaled independently and keeps the code
    
    
     
      loosely coupled.
     
    
   </p>
   <p>
    
     For larger systems, it’s
    
    <a id="_idIndexMarker896">
    </a>
    
     common to have many microservices
    
    
     
      communicating together.
     
    
   </p>
   <h2 id="_idParaDest-357">
    <a id="_idTextAnchor366">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Receiving HTTP POST requests
      
     </em>
     
      recipe in
     
     <a href="B19212_04.xhtml#_idTextAnchor100">
      
       <em class="italic">
        
         Chapter 4
        
       </em>
      
     </a>
    </li>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Generating a microservice w
      
      <a id="_idTextAnchor367">
      </a>
      <a id="_idTextAnchor368">
      </a>
      
       ith LoopBack
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-358">
    <a id="_idTextAnchor369">
    </a>
    
     Building a Docker container
    
   </h1>
   <p>
    
     Once we have a Node.js microservice, we
    
    <a id="_idIndexMarker897">
    </a>
    
     need to package it ready for deployment to the cloud.
    
    
     Cloud and container technologies go hand in hand, and one of the most prevalent container technologies
    
    
     
      is Docker.
     
    
   </p>
   <p>
    
     Docker is a tool used for creating, deploying, and running applications with containers.
    
    
     A container enables you to package up your application with all its dependencies.
    
    
     A container is often said to be like a virtual machine, the key difference being that Docker allows applications to reuse the same Linux kernel, whereas a virtual machine virtualizes the whole
    
    
     
      operating system.
     
    
   </p>
   <p>
    
     The key benefit to containerizing a microservice is that it is encapsulated, which means that the container holds everything that the microservice requires in order to run.
    
    
     This helps make the application portable and consistent
    
    
     
      across machines.
     
    
   </p>
   <p>
    
     Container technologies such as Docker are seen as the de facto tools for deploying to modern cloud environments, often combined with a container orchestrator such as Kubernetes, which we’ll cover in the
    
    <em class="italic">
     
      Deploying to Kubernetes
     
    </em>
    
     recipe of
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Docker and Kubernetes are large and complex technologies.
    
    
     This chapter will focus on demonstrating how to leverage Docker and Kubernetes to deploy Node.js microservices.
    
    
     An in-depth overview of Docker and Kubernetes is beyond the scope of this book.
    
    
     Refer to the following links for more detailed information about Docker
    
    
     
      and Kubernetes:
     
    
   </p>
   <ul>
    <li>
     
      Kubernetes
     
     
      
       overview:
      
     
     <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">
      
       
        https://kubernetes.io/docs/tutorials/kubernetes-basics/
       
      
     </a>
    </li>
    <li>
     
      Kubernetes setup
     
     
      
       guide:
      
     
     <a href="https://kubernetes.io/docs/setup/">
      
       
        https://kubernetes.io/docs/setup/
       
      
     </a>
    </li>
   </ul>
   <p>
    
     In this recipe, we’ll be packaging a sample Node.js microservice into a
    
    
     
      Docker container.
     
    
   </p>
   <h2 id="_idParaDest-359">
    <a id="_idTextAnchor370">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     For this recipe, you will need to have Docker installed.
    
    
     It is recommended to install Docker for Desktop
    
    <a id="_idIndexMarker898">
    </a>
    
     
      from
     
    
    <a href="https://docs.docker.com/engine/install/">
     
      
       https://docs.docker.com/engine/install/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Ensure Docker is running.
    
    
     You can test this by entering the following command in your
    
    
     
      terminal window:
     
    
   </p>
   <pre class="console">
$ docker run hello-world</pre>
   <p>
    
     This command pulls the
    
    <strong class="source-inline">
     
      hello-world
     
    </strong>
    
     image from Docker Hub and creates a container to run it.
    
    
     Docker Hub is a central repository of Docker images, almost like an
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     registry for
    
    
     
      Docker images.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      hello-world
     
    </strong>
    
     image is a sample image that you can use to test that Docker is installed and operating correctly.
    
    
     When you run the image, expect to see
    
    <strong class="bold">
     
      Hello from Docker!
     
    </strong>
    
     returned along with additional
    
    
     
      help text.
     
    
   </p>
   <p>
    
     We will also need an API, or microservice, to build into a Docker container.
    
    
     We’ll use the Fastify CLI to generate an API.
    
    
     For more information on Fastify, refer to
    
    <a href="B19212_06.xhtml#_idTextAnchor178">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Generate a sample API in a new directory named
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     by entering the following commands in your
    
    
     
      terminal window:
     
    
   </p>
   <pre class="console">
$ npx fastify-cli generate fastify-microservice
$ cd fastify-microservice</pre>
   <p>
    
     Now that we have confirmed that Docker is installed and we have a sample microservice, we can move on to the recipe steps, where we’ll build
    
    
     
      a container.
     
    
   </p>
   <h2 id="_idParaDest-360">
    <a id="_idTextAnchor371">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be building a container for
    
    
     
      our
     
    
    
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      file and a
     
     <strong class="source-inline">
      
       .dockerignore
      
     </strong>
     
      file in the
     
     
      <strong class="source-inline">
       
        fastify-microservice
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
<strong class="bold">$ touch Dockerfile .dockerignore</strong></pre>
    </li>
    <li>
     
      A
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      file is a set of instructions on how to build the container for our application or
     
     <a id="_idIndexMarker899">
     </a>
     
      microservice.
     
     
      Open the
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      file and add the
     
     
      
       following lines:
      
     
     <pre class="source-code">
FROM node:22
WORKDIR "/app"
RUN apt-get update \
 &amp;&amp; apt-get dist-upgrade -y \
 &amp;&amp; apt-get clean \
 &amp;&amp; echo 'Finished installing dependencies'
COPY package*.json ./
RUN npm install --production
COPY . /app
ENV PORT 3000
EXPOSE 3000
USER node
CMD ["npm", "start"]</pre>
    </li>
    <li>
     
      Next, we’ll create the
     
     <strong class="source-inline">
      
       .dockerignore
      
     </strong>
     
      file.
     
     
      Similar to a
     
     <strong class="source-inline">
      
       .gitignore
      
     </strong>
     
      file, the
     
     <strong class="source-inline">
      
       .dockerignore
      
     </strong>
     
      file is used to exclude files from being built into a container.
     
     
      Add the following to the
     
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        dockerignore
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
.git
.gitignore
node_modules
npm-debug.log</pre>
    </li>
    <li>
     
      We’re now ready to
     
     <a id="_idIndexMarker900">
     </a>
     
      build the microservice.
     
     
      We do this by using the
     
     <strong class="source-inline">
      
       docker build
      
     </strong>
     
      command, along with
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      as a tag for
     
     
      
       our image:
      
     
     <pre class="source-code">
<strong class="bold">$ docker build --tag fastify-microservice .</strong></pre>
    </li>
    <li>
     
      Expect to see the following output as Docker builds
     
     
      
       the image:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.10 – Web page showing a populated bookstore inventory" src="img/Figure_11.10_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.10 – Web page showing a populated bookstore inventory
    
   </p>
   <ol>
    <li value="6">
     
      Enter the following
     
     <a id="_idIndexMarker901">
     </a>
     
      command in your terminal window to list all of your Docker images.
     
     
      You should expect to see the
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      Docker image in
     
     
      
       the list:
      
     
     <pre class="source-code">
<strong class="bold">$ docker images</strong></pre>
    </li>
    <li>
     
      Now we can run the Docker image as a Docker container, passing the
     
     <strong class="source-inline">
      
       --publish
      
     </strong>
     
      flag to instruct Docker to map port
     
     <strong class="source-inline">
      
       3000
      
     </strong>
     
      from within the container to port
     
     <strong class="source-inline">
      
       3000
      
     </strong>
     
      on our local machine.
     
     
      Enter the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ docker run --publish 3000:3000 fastify-microservice</strong>
&gt; fastify-microservice@1.0.0 start /app
&gt; fastify start -l info app.js
{"level":30,"time":1594555188739,"pid":19,"hostname":"f83abfa3276a","msg":"Server listening at http://0.0.0.0:3000"}</pre>
    </li>
    <li>
     
      You should be able to navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000/example
      
     </strong>
     
      and see the
     
     <strong class="bold">
      
       this is an
      
     </strong>
     
      <strong class="bold">
       
        example
       
      </strong>
     
     
      
       output.
      
     
    </li>
    <li>
     
      Press
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     <em class="italic">
      
       C
      
     </em>
     
      in your terminal window to stop
     
     
      
       your container.
      
     
    </li>
   </ol>
   <p>
    
     We’ve now successfully built our first
    
    
     
      containerized microservice.
     
    
   </p>
   <h2 id="_idParaDest-361">
    <a id="_idTextAnchor372">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     Containers enable you to package your application into an isolated environment.
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     is used to define the environment.
    
    
     The environment should include the libraries and dependencies that are required to run the
    
    
     
      application code.
     
    
   </p>
   <p>
    
     Let’s examine the contents of the
    
    
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       FROM node:22
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       node
      
     </strong>
     
      instruction is used to initialize a new build stage.
     
     
      A
     
     <strong class="source-inline">
      
       Dockerfile
      
     </strong>
     
      file must start with a
     
     <strong class="source-inline">
      
       FROM
      
     </strong>
     
      instruction pointing to a valid Docker image that can be
     
     <a id="_idIndexMarker902">
     </a>
     
      used as a base for our image.
     
     
      In this example, the image is based on the Docker Official
     
     
      
       Node.js image.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       RUN apt-get update...
      
     </strong>
     
      : This line instructs Docker to update the containers’ OS dependencies using
     
     <a id="_idIndexMarker903">
     </a>
     
      the
     
     <strong class="bold">
      
       Advanced Package Tool
      
     </strong>
     
      (
     
     <strong class="bold">
      
       APT
      
     </strong>
     
      ), which is Debian’s default package manager.
     
     
      It’s important that OS dependencies are up to date to ensure that your dependencies contain the latest available fixes
     
     
      
       and patches.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       COPY package*.json ./
      
     </strong>
     
      : This copies the
     
     <strong class="source-inline">
      
       package.json
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       package-lock.json
      
     </strong>
     
      files, should they exist, into
     
     
      
       the container.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       RUN npm install --production
      
     </strong>
     
      : This executes the
     
     <strong class="source-inline">
      
       npm install
      
     </strong>
     
      command within the container based on the
     
     <strong class="source-inline">
      
       package*.json
      
     </strong>
     
      files copied earlier into the container.
     
     <strong class="source-inline">
      
       npm install
      
     </strong>
     
      must be run within the container as some dependencies may have native components that need to be built based on the container’s OS.
     
     
      For example, if you’re developing locally on macOS and have native dependencies, you will not be able to just copy the contents of
     
     <strong class="source-inline">
      
       node_modules
      
     </strong>
     
      into the container, as the native macOS dependencies will not work in the
     
     
      
       Debian-based container.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       COPY .
      
      
       /app.
      
     </strong>
     
      : This copies our application code into the container.
     
     
      Note that the
     
     <strong class="source-inline">
      
       COPY
      
     </strong>
     
      command will ignore all patterns listed in the
     
     <strong class="source-inline">
      
       .dockerignore
      
     </strong>
     
      file.
     
     
      This means that the
     
     <strong class="source-inline">
      
       COPY
      
     </strong>
     
      command will not copy
     
     <strong class="source-inline">
      
       node_modules
      
     </strong>
     
      and other information to
     
     
      
       the container.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       ENV PORT 3000
      
     </strong>
     
      : This sets the
     
     <strong class="source-inline">
      
       PORT
      
     </strong>
     
      environment variable in the container
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        3000
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       EXPOSE 3000
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       EXPOSE
      
     </strong>
     
      instruction is used as a form of documentation as to which port is intended to be published for the containerized application.
     
     
      It does not publish
     
     
      
       the port.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       USER node
      
     </strong>
     
      : This instructs Docker to run the image as the
     
     <strong class="source-inline">
      
       node
      
     </strong>
     
      user.
     
     
      The
     
     <strong class="source-inline">
      
       node
      
     </strong>
     
      user is created by the Docker Official Node.js image.
     
     
      When omitted, the image will default to being run as the root user.
     
     
      You should run your containers as an unprivileged (non-root) user where possible as
     
     
      
       security mitigation.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       CMD ["npm", "start"]
      
     </strong>
     
      : This executes the command to start
     
     
      
       the application.
      
     
    </li>
   </ul>
   <p>
    
     The ordering of the
    
    <a id="_idIndexMarker904">
    </a>
    
     commands in
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     is important.
    
    
     For each command in the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file, Docker creates a new layer in the image.
    
    
     Docker will only rebuild the layers that have changed, so the ordering of the commands in the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file can impact rebuild times.
    
    
     It is for this reason that we copy the application code into the container after running
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     , as we’re more commonly going to be changing the application code as opposed to changing
    
    
     
      our dependencies.
     
    
   </p>
   <p>
    
     It’s possible to view the Docker layers for an image using the
    
    <strong class="source-inline">
     
      docker history
     
    </strong>
    
     command.
    
    
     For example,
    
    <strong class="source-inline">
     
      $ docker history fastify-microservice
     
    </strong>
    
     will output the layers of our
    
    
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
    
    
     
      image:
     
    
   </p>
   <div><div><img alt="Figure 11.11 – An overview of Docker history output for the fastify-microservice image" src="img/Figure_11.11_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.11 – An overview of Docker history output for the fastify-microservice image
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      $ docker build --tag fastify-microservice .
     
    </strong>
    
     command builds the Docker image, based
    
    <a id="_idIndexMarker905">
    </a>
    
     on the instructions in the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file in the
    
    
     
      current directory.
     
    
   </p>
   <p>
    
     To run the image, we call
    
    <strong class="source-inline">
     
      docker run --publish 3000:3000 fastify-microservice
     
    </strong>
    
     .
    
    
     We pass this command the name of the image we’d like to run, and also the port we wish to expose.
    
    
     The
    
    <strong class="source-inline">
     
      --publish 3000:3000
     
    </strong>
    
     option maps port
    
    <strong class="source-inline">
     
      3000
     
    </strong>
    
     on your host machine to port
    
    <strong class="source-inline">
     
      3000
     
    </strong>
    
     on the container, ensuring that any traffic sent to port
    
    <strong class="source-inline">
     
      3000
     
    </strong>
    
     on the host is forwarded to port
    
    <strong class="source-inline">
     
      3000
     
    </strong>
    
     in
    
    
     
      the container.
     
    
   </p>
   <h2 id="_idParaDest-362">
    <a id="_idTextAnchor373">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     When creating a Docker image, it’s important to make it as small as possible.
    
    
     It’s considered good practice for your production image to only contain the dependencies and libraries required to run the application in production.
    
    
     To create a smaller image, we can leverage Docker’s multistage builds
    
    
     
      capability (
     
    
    <a href="https://docs.docker.com/develop/develop-images/multistage-build/">
     
      
       https://docs.docker.com/develop/develop-images/multistage-build/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Docker multistage builds allow us to define multiple Docker images in the same
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file.
    
    
     For Node.js applications, we can split the
    
    <em class="italic">
     
      build
     
    </em>
    
     and
    
    <em class="italic">
     
      run
     
    </em>
    
     steps into separate containers.
    
    
     The result is that the final production container, the
    
    <strong class="source-inline">
     
      run
     
    </strong>
    
     container, will be a smaller and
    
    
     
      lighter-weight container.
     
    
   </p>
   <p>
    
     We could use the
    
    <a id="_idIndexMarker906">
    </a>
    
     following multistage
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file
    
    <a id="_idTextAnchor374">
    </a>
    
     to containerize
    
    
     
      our
     
    
    
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
FROM node:22
WORKDIR "/app"
RUN apt-get update \
 &amp;&amp; apt-get dist-upgrade -y \
 &amp;&amp; apt-get clean \
 &amp;&amp; echo 'Finished installing dependencies'
COPY package*.json ./
RUN npm install --production
FROM node:22-slim
WORKDIR "/app"
RUN apt-get update \
 &amp;&amp; apt-get dist-upgrade -y \
 &amp;&amp; apt-get clean \
 &amp;&amp; echo 'Finished installing dependencies'
COPY --from=0 /app/node_modules /app/node_modules
COPY . /app
ENV NODE_ENV production
ENV PORT 3000
USER node
EXPOSE 3000
CMD ["npm", "start"]</pre>
   <p>
    
     Observe that there are two
    
    <strong class="source-inline">
     
      FROM
     
    </strong>
    
     instructions in the
    
    <strong class="source-inline">
     
      Dockerfile
     
    </strong>
    
     file, indicating that there are two
    
    
     
      build stages.
     
    
   </p>
   <p>
    
     The first build stage creates a container that handles the installation of dependencies and any build tasks.
    
    
     In our example, the first container executes the
    
    <strong class="source-inline">
     
      npm install
     
    </strong>
    
     command.
    
    <strong class="source-inline">
     
      node_modules
     
    </strong>
    
     may contain native add-ons, which means the first container needs the relevant compilers
    
    
     
      and dependencies.
     
    
   </p>
   <p>
    
     The second container uses a base of the
    
    <strong class="source-inline">
     
      node:22-slim
     
    </strong>
    
     image.
    
    
     The
    
    <strong class="source-inline">
     
      node:22-slim
     
    </strong>
    
     image is a variant of
    
    <a id="_idIndexMarker907">
    </a>
    
     the official Node.js Docker image that contains the minimum libraries required to run Node.js.
    
    
     This image is a much smaller and lighter-weight image.
    
    
     The regular
    
    <strong class="source-inline">
     
      node
     
    </strong>
    
     Docker image is around 1 GB in size, whereas the multi-stage
    
    <strong class="source-inline">
     
      slim
     
    </strong>
    
     image is around 200 MB.
    
    
     When deploying to the cloud, in many cases, you’ll be charged per MB.
    
    
     Minimizing your image size can result in
    
    
     
      cost savings.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Once you’ve completed the recipes in this chapter, you should stop and remove the Docker containers and images.
    
    
     Otherwise, the containers and images may linger on your system and consume system resources.
    
    
     Use
    
    <strong class="source-inline">
     
      $ docker ps
     
    </strong>
    
     to list your containers.
    
    
     Locate the container identifier and pass this to
    
    <strong class="source-inline">
     
      $ docker stop &lt;containerID&gt;
     
    </strong>
    
     to stop a container.
    
    
     Follow this up with
    
    <strong class="source-inline">
     
      $ docker rm -f &lt;containerID&gt;
     
    </strong>
    
     to remove a container.
    
    
     Similarly, to remove a Docker image, use the
    
    <strong class="source-inline">
     
      $ docker image rm &lt;image&gt;
     
    </strong>
    
     command.
    
    
     You can also use (with caution) the
    
    <strong class="source-inline">
     
      $ docker system prune --all
     
    </strong>
    
     command to remove all images and containers on
    
    
     
      your system.
     
    
   </p>
   <h2 id="_idParaDest-363">
    <a id="_idTextAnchor375">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Publishing a Docker image
      
     </em>
     
      recipe
     
     <a id="_idIndexMarker908">
     </a>
     
      in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Deploying to Kubernetes
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-364">
    <a id="_idTextAnchor376">
    </a>
    
     Publishing a Docker image
    
   </h1>
   <p>
    
     Docker Hub provides a
    
    <a id="_idIndexMarker909">
    </a>
    
     global repository of images.
    
    
     Throughout this chapter and
    
    <a href="B19212_07.xhtml#_idTextAnchor212">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     , we’ve pulled Docker images that were stored in the Docker Hub repository.
    
    
     This includes the Docker Official Node.js image, which we used as a basis for our image in the
    
    <em class="italic">
     
      Building a Docker container
     
    </em>
    
     recipe in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to publish our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to
    
    
     
      Docker Hub.
     
    
   </p>
   <h2 id="_idParaDest-365">
    <a id="_idTextAnchor377">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     This recipe will use the image created in the previous recipe,
    
    <em class="italic">
     
      Building a
     
    </em>
    
     <em class="italic">
      
       Docker container
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     If you haven’t completed that recipe, the code is available in the Packt GitHub repository (
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     ) in the
    
    
     <strong class="source-inline">
      
       Chapter11/fastify-microservice
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h2 id="_idParaDest-366">
    <a id="_idTextAnchor378">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to sign up for a Docker Hub account and publish our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to
    
    
     
      Docker Hub:
     
    
   </p>
   <ol>
    <li>
     
      First, we need to create a Docker Hub account.
     
     
      Visit
     
     <a href="https://hub.docker.com/signup">
      
       https://hub.docker.com/signup
      
     </a>
     
      to create an account.
     
     
      You will need to enter your details and click
     
     
      <strong class="bold">
       
        Sign up
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Once you’ve created your Docker Hub account, you need to authenticate your Docker client.
     
     
      Do this by entering the following command in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ docker login</strong></pre>
    </li>
    <li>
     
      Once we have authenticated our Docker client, we then need to retag our image for it to be pushed to Docker Hub.
     
     
      Tag the image with the following command, substituting
     
     <strong class="source-inline">
      
       &lt;namespace&gt;
      
     </strong>
     
      with your Docker
     
     
      
       Hub ID:
      
     
     <pre class="source-code">
<strong class="bold">$ docker tag fastify-microservice &lt;namespace&gt;/fastify-microservice</strong></pre>
    </li>
    <li>
     
      Now, we need to
     
     <a id="_idIndexMarker910">
     </a>
     
      push the newly tagged image using the
     
     <strong class="source-inline">
      
       docker
      
     </strong>
     
      <strong class="source-inline">
       
        push
       
      </strong>
     
     
      
       command:
      
     
     <pre class="source-code">
<strong class="bold">$ docker push &lt;namespace&gt;/fastify-microservice</strong>
Using default tag: latest
The push refers to repository [docker.io/&lt;namespace&gt;/fastify-microservice]
2e4fc733214e: Preparing
f4ab51cf75a4: Preparing
92f894697ee2: Preparing
69619ce237eb: Preparing
3e23088f380e: Preparing
...</pre>
    </li>
    <li>
     
      You can now navigate to
     
     <strong class="source-inline">
      
       https://hub.docker.com/repository/docker/&lt;namespace&gt;/fastify-microservice
      
     </strong>
     
      to verify that your image has been published to Docker Hub.
     
     
      Again, you’ll need to substitute
     
     <strong class="source-inline">
      
       &lt;namespace&gt;
      
     </strong>
     
      with your Docker Hub ID.
     
     
      Expect to see output similar to
     
     
      
       the following:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.12 – Docker Hub view of the published fastify-microservice image" src="img/Figure_11.12_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.12 – Docker Hub view of the published fastify-microservice image
    
   </p>
   <ol>
    <li value="6">
     
      If you click on
     
     <strong class="bold">
      
       Tags
      
     </strong>
     
      , you
     
     <a id="_idIndexMarker911">
     </a>
     
      should see that our Docker image has one tag
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        latest
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      It is also now possible to pull the image with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ docker pull &lt;namespace&gt;/fastify-microservice</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve pushed a Docker image containing our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to
    
    
     
      Docker Hub.
     
    
   </p>
   <h2 id="_idParaDest-367">
    <a id="_idTextAnchor379">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We first tagged the
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image with the
    
    <strong class="source-inline">
     
      &lt;namespace&gt;/fastify-microservice
     
    </strong>
    
     tag.
    
    
     This tag format instructs Docker that this image is associated with a repository on Docker Hub.
    
    
     Once we’ve appropriately tagged our image, we use the
    
    <strong class="source-inline">
     
      docker push
     
    </strong>
    
     command to publish the image to
    
    
     
      Docker Hub.
     
    
   </p>
   <p>
    
     By default, our Docker Hub image will be publicly accessible.
    
    
     Production microservices are not typically expected to be published publicly to Docker Hub to avoid exposing any proprietary code or secrets.
    
    
     Docker Hub does provide private image functionality, but users are limited to one private registry on Docker Hub’s free account plan.
    
    
     It is possible to sign up for a paid account plan with Docker Hub, which provides unlimited
    
    
     
      private repositories.
     
    
   </p>
   <p>
    
     When deploying images for use in production-grade systems, it is common to create a private Docker registry.
    
    
     Docker exposes a registry image (
    
    <a href="https://hub.docker.com/_/registry">
     
      https://hub.docker.com/_/registry
     
    </a>
    
     ) that can be used to provision a private registry.
    
    
     For more information on setting up a private registry, refer
    
    
     
      to
     
    
    <a href="https://docs.docker.com/registry/deploying/">
     
      
       https://docs.docker.com/registry/deploying/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      &lt;IP&gt;:&lt;PORT&gt;/&lt;IMAGE&gt;
     
    </strong>
    
     format is used when referring to images stored in private registries, where the IP is the address of the private registry.
    
    
     Many of the leading cloud providers also provide
    
    <a id="_idIndexMarker912">
    </a>
    
     commercial container registry solutions, which can be used to avoid the overhead of managing a
    
    
     
      container registry.
     
    
   </p>
   <h2 id="_idParaDest-368">
    <a id="_idTextAnchor380">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In this recipe, we did not specify a version tag for our Docker image.
    
    
     Therefore, Docker defaulted to creating the
    
    <strong class="source-inline">
     
      latest
     
    </strong>
    
     version tag for our image.
    
    
     The
    
    <strong class="source-inline">
     
      latest
     
    </strong>
    
     tag is automatically updated each time we rebuild our image without explicitly specifying a
    
    
     
      version tag.
     
    
   </p>
   <p>
    
     It is generally considered good practice to version Docker Hub images similar to how you’d version an application.
    
    
     Versioning Docker Hub images provides a history of images, which makes it possible to roll back to earlier image versions should something
    
    
     
      go wrong.
     
    
   </p>
   <p>
    
     We can tag our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image with the following command, substituting the namespace for our Docker
    
    
     
      Hub username:
     
    
   </p>
   <pre class="console">
$ docker tag fastify-microservice &lt;namespace&gt;/fastify-microservice:1.0.0</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      1.0.0
     
    </strong>
    
     version is specified in the preceding command to match the version declared in our
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     file.
    
    
     This is just one of many approaches we can take to versioning as there is no formal standard for how Docker images should be versioned.
    
    
     Other options include an incremental versioning scheme or even using the Git commit SHA of the application code as the
    
    
     
      version tag.
     
    
   </p>
   <p>
    
     We push the image to Docker Hub with the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
$ docker push &lt;namespace&gt;/fastify-microservice:1.0.0</pre>
   <p>
    
     If we navigate to the
    
    <strong class="bold">
     
      Tags
     
    </strong>
    
     panel for our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image on Docker Hub, we should be able to
    
    <a id="_idIndexMarker913">
    </a>
    
     see that our newly pushed image version
    
    
     
      is available.
     
    
   </p>
   <h2 id="_idParaDest-369">
    <a id="_idTextAnchor381">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building a Docker container
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Deploying to Kubernetes
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-370">
    <a id="_idTextAnchor382">
    </a>
    
     Deploying to Kubernetes
    
   </h1>
   <p>
    
     Kubernetes is
    
    <a id="_idIndexMarker914">
    </a>
    
     an open source container orchestration and management system originally developed by Google.
    
    
     Today, the Kubernetes project is maintained by the Cloud Native Computing
    
    <a id="_idIndexMarker915">
    </a>
    
     
      Foundation (
     
    
    <a href="https://www.cncf.io/">
     
      
       https://www.cncf.io/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Kubernetes is a comprehensive and complex tool that provides the following features,
    
    
     
      among others:
     
    
   </p>
   <ul>
    <li>
     
      Service discovery and
     
     
      
       load balancing
      
     
    </li>
    <li>
     
      
       Storage orchestration
      
     
    </li>
    <li>
     
      Automated rollouts
     
     
      
       and rollbacks
      
     
    </li>
    <li>
     
      Automatic bin packing, specifying how much CPU and memory each
     
     
      
       container needs
      
     
    </li>
    <li>
     
      
       Self-healing
      
     
    </li>
    <li>
     
      Secret and
     
     
      
       configuration management
      
     
    </li>
   </ul>
   <p>
    
     An oversimplified description of Kubernetes is that it is a tool used to
    
    
     
      manage containers.
     
    
   </p>
   <p>
    
     This recipe will serve as an introduction to Kubernetes, demonstrating how we can deploy a microservice, packaged into a Docker container,
    
    
     
      to Kubernetes.
     
    
   </p>
   <h2 id="_idParaDest-371">
    <a id="_idTextAnchor383">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     You should have Node.js 22 installed, and access to both an editor and browser of your choice.
    
    
     This recipe also relies on the
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image that we created in the
    
    <em class="italic">
     
      Building a Docker container
     
    </em>
    
     recipe in this chapter.
    
    
     If you haven’t completed that recipe, you can download the code from the Packt GitHub repository (
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     ) in the
    
    
     <strong class="source-inline">
      
       Chapter11/fastify-microservice
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     For this recipe, you will additionally need to have both Docker and Kubernetes installed.
    
    
     It’s possible to install
    
    <a id="_idIndexMarker916">
    </a>
    
     and enable Kubernetes via Docker for Desktop.
    
    
     It is recommended to install Docker for Desktop
    
    
     
      from
     
    
    <a href="https://docs.docker.com/engine/install/">
     
      
       https://docs.docker.com/engine/install/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     This recipe has been written based on using Docker for Desktop, which handles the setup of Kubernetes and installation of the
    
    <strong class="source-inline">
     
      kubectl
     
    </strong>
    
     CLI.
    
    
     However, Docker for Desktop is only available on macOS and Windows OSs.
    
    
     On Linux, an alternative is to use
    
    <strong class="bold">
     
      minikube
     
    </strong>
    
     , which is
    
    <a id="_idIndexMarker917">
    </a>
    
     a tool that runs a Kubernetes cluster in a virtual machine on your local device.
    
    
     Minikube has a more complicated setup compared to Docker for Desktop.
    
    
     First, you’ll need to manually install the
    
    <strong class="source-inline">
     
      kubectl
     
    </strong>
    
     CLI (
    
    <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">
     
      https://kubernetes.io/docs/tasks/tools/install-kubectl/
     
    </a>
    
     ), and then follow the installation instructions for Minikube
    
    
     
      at
     
    
    <a href="https://kubernetes.io/docs/tasks/tools/install-minikube">
     
      
       https://kubernetes.io/docs/tasks/tools/install-minikube
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To enable Kubernetes in Docker for Desktop, perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Click the
     
     <strong class="bold">
      
       Docker
      
     </strong>
     
      icon in your
     
     
      
       menu bar.
      
     
    </li>
    <li>
     
      Navigate to the
     
     <strong class="bold">
      
       Preferences/Settings
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Kubernetes
      
     </strong>
     
      tab (as shown in the
     
     
      
       following screenshot):
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 11.13 – The Docker for Desktop Kubernetes tab" src="img/Figure_11.13_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.13 – The Docker for Desktop Kubernetes tab
    
   </p>
   <ol>
    <li value="3">
     
      Check the
     
     <strong class="bold">
      
       Enable
      
     </strong>
     
      <strong class="bold">
       
        Kubernetes
       
      </strong>
     
     
      
       checkbox.
      
     
    </li>
    <li>
     
      Click
     
     <strong class="bold">
      
       Apply &amp;
      
     </strong>
     
      <strong class="bold">
       
        restart
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     It will take a short while for
    
    <a id="_idIndexMarker918">
    </a>
    
     Kubernetes to install.
    
    
     The installation process will instantiate all of the images that are required to run a Kubernetes cluster on your laptop.
    
    
     The
    
    <strong class="source-inline">
     
      kubectl
     
    </strong>
    
     CLI will also be installed at
    
    <strong class="source-inline">
     
      /usr/local/bin/kubectl
     
    </strong>
    
     .
    
    
     We will be using the
    
    <strong class="source-inline">
     
      kubectl
     
    </strong>
    
     CLI to interact with our
    
    
     
      Kubernetes cluster.
     
    
   </p>
   <p>
    
     If you already use Kubernetes, ensure that you are configured to use the
    
    <strong class="source-inline">
     
      docker-desktop
     
    </strong>
    
     context.
    
    
     To do so, perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Click the Docker icon in your
     
     
      
       menu bar.
      
     
    </li>
    <li>
     
      Click
     
     <strong class="bold">
      
       Kubernetes
      
     </strong>
     
      and select the
     
     
      <strong class="source-inline">
       
        docker-desktop
       
      </strong>
     
     
      
       context.
      
     
    </li>
    <li>
     
      Open a new terminal window and verify that both Docker and the
     
     <strong class="source-inline">
      
       kubectl
      
     </strong>
     
      CLI are present by entering the following commands.
     
     
      Expect to see output similar to
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">$ docker --version</strong>
Docker version 26.1.4, build 5650f9b
<strong class="bold">$ kubectl version</strong>
Client Version: v1.29.2
Kustomize Version: v5.0.4-0.20230601165947-6ce0bf390ce3
Server Version: v1.29.2</pre>
    </li>
   </ol>
   <p>
    
     Should any issues arise, refer to the official Docker for Desktop installation and the
    
    <em class="italic">
     
      Getting Started
     
    </em>
    
     guides
    
    
     
      at
     
    
    <a href="https://docs.docker.com/desktop/#get-started">
     
      
       https://docs.docker.com/desktop/#get-started
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that we have Docker
    
    <a id="_idIndexMarker919">
    </a>
    
     and Kubernetes installed and started, we can move to our
    
    
     
      recipe steps.
     
    
   </p>
   <h2 id="_idParaDest-372">
    <a id="_idTextAnchor384">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to deploy our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to Kubernetes.
    
    
     We’ll be using the
    
    <strong class="source-inline">
     
      kubectl
     
    </strong>
    
     CLI to interact with our
    
    
     
      Kubernetes cluster:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s test out some
     
     <strong class="source-inline">
      
       kubectl
      
     </strong>
     
      commands.
     
     
      Enter the following commands to list the Kubernetes nodes and services present on
     
     
      
       our cluster:
      
     
     <pre class="source-code">
<strong class="bold">$ kubectl get nodes</strong>
NAME             STATUS   ROLES           AGE    VERSION
docker-desktop   Ready    control-plane   109s   v1.29.2
<strong class="bold">$ kubectl get services</strong>
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP    PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   110s</pre>
    </li>
    <li>
     
      Now, we can proceed to deploy our
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      image.
     
     
      Let’s start by ensuring we have our Docker image built.
     
     
      To do so, run the following command within the
     
     
      <strong class="source-inline">
       
        fastify-microservice
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
<strong class="bold">$ docker build --tag fastify-microservice .</strong></pre>
    </li>
    <li>
     
      Next, we’ll create our deployment files.
     
     
      The deployment files will be a set of YAML files that are used to configure Kubernetes.
     
     
      We’ll create a subdirectory named
     
     <strong class="source-inline">
      
       deployment
      
     </strong>
     
      to hold the
     
     
      
       deployment files:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir deployment</strong>
<strong class="bold">$ touch deployment/fastify-app.yml deployment/fastify-app-svc.yml</strong></pre>
    </li>
    <li>
     
      We’re going to create
     
     <a id="_idIndexMarker920">
     </a>
     
      a Kubernetes deployment.
     
     
      We can configure a Kubernetes deployment with a YAML file.
     
     
      To create a deployment YAML file, add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        deployment/fastify-app.yml
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastify-app
  labels:
    app: fastify
spec:
  replicas: 3
  selector:
    matchLabels:
      app: fastify
  template:
    metadata:
      labels:
        app: fastify
    spec:
      containers:
      - name: fastify-app
        image: fastify-microservice:latest
        imagePullPolicy: Never
        ports:
        - containerPort: 3000</pre>
    </li>
    <li>
     
      To create the Kubernetes deployment, we need to apply our YAML file that describes the deployment.
     
     
      We can confirm that the deployment has been created by asking our
     
     <a id="_idIndexMarker921">
     </a>
     
      Kubernetes cluster to list its deployments.
     
     
      Do this by entering the following
     
     
      
       two commands:
      
     
     <pre class="source-code">
<strong class="bold">$ kubectl apply --filename deployment/fastify-app.yml</strong>
deployment.apps/fastify-app created
<strong class="bold">$ kubectl get deployments</strong>
NAME          READY   UP-TO-DATE   AVAILABLE   AGE
fastify-app   3/3     3            3           7m19s</pre>
    </li>
    <li>
     
      In our YAML file, we instructed Kubernetes to create three replicas.
     
     
      This means three Kubernetes pods will be created.
     
     
      A Kubernetes pod is a group of one or more containers that are deployed together on the same host and share the same network namespace and
     
     
      
       storage volumes.
      
     
     <p class="list-inset">
      
       We can confirm that these have been created by listing all of the pods in our Kubernetes cluster by means of the
      
      
       
        following command:
       
      
     </p>
     <pre class="source-code">
<strong class="bold">$ kubectl get pods</strong>
NAME                           READY   STATUS    RESTARTS   AGE
fastify-app-749687fd5f-2vxcb   1/1     Running   0          6s
fastify-app-749687fd5f-94rlc   1/1     Running   0          6s
fastify-app-749687fd5f-rvx6n   1/1     Running   0          6s</pre>
    </li>
    <li>
     
      Now, let’s move on to how we can expose the instances of our
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      image running in the pods.
     
     
      We do this by creating a Kubernetes Service.
     
     
      Add the
     
     <a id="_idIndexMarker922">
     </a>
     
      following to
     
     <strong class="source-inline">
      
       fastify-app-svc.yml
      
     </strong>
     
      to create the
     
     
      
       Kubernetes Service:
      
     
     <pre class="source-code">
apiVersion: v1
kind: Service
metadata:
  name: fastify-app-svc
  labels:
    run: fastify
spec:
  selector:
    app: fastify
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
  type: NodePort</pre>
    </li>
    <li>
     
      To create the Kubernetes Service defined in the previous step, we need to apply the Service YAML file with the following commands.
     
     
      We can confirm that the Kubernetes Service was created by supplying the
     
     <strong class="source-inline">
      
       kubectl get service
      
     </strong>
     
      command.
     
     
      Enter the following in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ kubectl apply --filename deployment/fastify-app-svc.yml</strong>
service/fastify-app-svc created
<strong class="bold">$ kubectl get service</strong>
NAME              TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)          AGE
fastify-app-svc   NodePort    10.97.82.33   &lt;none&gt;        3000:31815/TCP   15m
kubernetes        ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP          65d</pre>
    </li>
   </ol>
   <p>
    
     Now that we have created a Kubernetes Service, we should be able to access the application in our browser.
    
    
     You
    
    <a id="_idIndexMarker923">
    </a>
    
     will need to access the application via the external port, which is the port number detailed in the output of the previous step.
    
    
     In the preceding example, the application is located at
    
    <strong class="source-inline">
     
      https://localhost:31815/example
     
    </strong>
    
     , but you will need to substitute the port, as it is randomly assigned by Kubernetes.
    
    
     The external port, by default, will be in the range of
    
    <strong class="source-inline">
     
      30000
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      32767
     
    </strong>
    
     as this is the default range
    
    <a id="_idIndexMarker924">
    </a>
    
     assigned to
    
    <strong class="bold">
     
      NodePort services
     
    </strong>
    
     by Kubernetes.
    
    
     Expect to see the
    
    
     
      following output:
     
    
   </p>
   <div><div><img alt="Figure 11.14 – Browser showing the this is an example string" src="img/Figure_11.14_B19212.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.14 – Browser showing the this is an example string
    
   </p>
   <p>
    
     We’ve now pushed our containerized
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to our local
    
    
     
      Kubernetes cluster.
     
    
   </p>
   <h2 id="_idParaDest-373">
    <a id="_idTextAnchor385">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we
    
    <a id="_idIndexMarker925">
    </a>
    
     deployed our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image to the local Kubernetes cluster running under Docker for Desktop.
    
    
     Many of the leading cloud providers have commercial Kubernetes offerings that can be used should you not wish to manage a Kubernetes cluster.
    
    
     These commercial offerings extend the Kubernetes open source project, meaning the underlying Kubernetes technology remains consistent across cloud providers.
    
    
     Most of the providers offer CLIs to interact with their Kubernetes offering; however, the APIs provided by these CLIs tend to just be wrappers or shortcuts for
    
    
     <strong class="source-inline">
      
       kubectl
      
     </strong>
    
    
     
      commands.
     
    
   </p>
   <p>
    
     The following is a selection of the commercial Kubernetes Services available from leading
    
    
     
      cloud providers:
     
    
   </p>
   <ul>
    <li>
     
      Amazon Elastic Kubernetes
     
     
      
       Service:
      
     
     <a href="https://aws.amazon.com/eks/">
      
       
        https://aws.amazon.com/eks/
       
      
     </a>
    </li>
    <li>
     
      Azure Kubernetes
     
     
      
       Service:
      
     
     <a href="https://azure.microsoft.com/en-gb/services/kubernetes-service/">
      
       
        https://azure.microsoft.com/en-gb/services/kubernetes-service/
       
      
     </a>
    </li>
    <li>
     
      Google Kubernetes
     
     
      
       Engine:
      
     
     <a href="https://cloud.google.com/kubernetes-engine">
      
       
        https://cloud.google.com/kubernetes-engine
       
      
     </a>
    </li>
    <li>
     
      IBM Cloud Kubernetes
     
     
      
       Service:
      
     
     <a href="https://www.ibm.com/products/kubernetes-service">
      
       
        https://www.ibm.com/products/kubernetes-service
       
      
     </a>
    </li>
   </ul>
   <p>
    
     The recipe relied on our
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     image being built and available on the
    
    
     
      local machine.
     
    
   </p>
   <p>
    
     We declared a Kubernetes deployment in the
    
    <strong class="source-inline">
     
      deployment/fastify-app.yml
     
    </strong>
    
     file.
    
    
     A Kubernetes deployment is a resource object in Kubernetes.
    
    
     A Kubernetes deployment allows you to define the life cycle of your application.
    
    
     The life cycle definition includes
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      The image to use
     
     <a id="_idIndexMarker926">
     </a>
     
      for the deployment is included.
     
     
      In the recipe, the deployment YAML referenced the local
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      image that we created in the
     
     <em class="italic">
      
       Building a Docker container
      
     </em>
     
      recipe of this chapter.
     
     
      Note that we could have supplied an external image, such as one from Docker Hub, or referenced an image in a
     
     
      
       private registry.
      
     
    </li>
    <li>
     
      The number of replicas or pods that should be available
     
     
      
       are included.
      
     
    </li>
    <li>
     
      How the replicas or pods should be updated
     
     
      
       is detailed.
      
     
    </li>
   </ul>
   <p>
    
     In
    
    <strong class="source-inline">
     
      deployment/fastify-app.yml
     
    </strong>
    
     , we declared that there should be three replicas, and therefore three pods were created by Kubernetes.
    
    
     We set three replicas so that if one pod crashes, then the other two pods can handle the load.
    
    
     The number of replicas required will depend on the typical load of a given application.
    
    
     Having multiple instances available is part of what provides Kubernetes’ “high-availability” behaviors; having other pods available that can handle the load in the case where one pod crashes can reduce downtime.
    
    
     If we were to manually kill a pod with
    
    <strong class="source-inline">
     
      docker delete pod &lt;podname&gt;
     
    </strong>
    
     , Kubernetes would automatically try to restart and spin up a new pod in its place.
    
    
     This demonstrates Kubernetes’ “
    
    
     
      auto-restart” behavior.
     
    
   </p>
   <p>
    
     To access our application, we needed to define a Kubernetes Service.
    
    
     This Service is used to expose an application running on a set of pods.
    
    
     In the case of the recipe, we created a Kubernetes Service to expose
    
    <strong class="source-inline">
     
      fastify-microservice
     
    </strong>
    
     , which was running in three pods.
    
    
     Kubernetes creates a single DNS name for a group of Kubernetes pods, enabling load balancing
    
    
     
      between them.
     
    
   </p>
   <p>
    
     This recipe has only touched upon Kubernetes in the context of deploying a simple Node.js microservice.
    
    
     A full introduction to Kubernetes is beyond the scope of this book.
    
    
     For more detailed information on Kubernetes, you can refer to the
    
    
     
      following guides:
     
    
   </p>
   <ul>
    <li>
     
      Kubernetes
     
     
      
       overview:
      
     
     <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/">
      
       
        https://kubernetes.io/docs/tutorials/kubernetes-basics/
       
      
     </a>
    </li>
    <li>
     
      Kubernetes setup
     
     
      
       guide:
      
     
     <a href="https://kubernetes.io/docs/setup/">
      
       
        https://kubernetes.io/docs/setup/
       
      
     </a>
    </li>
   </ul>
   <h2 id="_idParaDest-374">
    <a id="_idTextAnchor386">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Kubernetes is focused on
    
    <a id="_idIndexMarker927">
    </a>
    
     enabling the high availability of applications to minimize downtime.
    
    
     When deploying an updated version of your microservice, Kubernetes will conduct a rolling update.
    
    
     Rolling updates aim for zero downtime by incrementally updating individual pod instances with the new version of
    
    
     
      the microservice.
     
    
   </p>
   <p>
    
     We can demonstrate Kubernetes rolling updates by updating our microservice and instructing Kubernetes to deploy the updated version of
    
    
     
      the microservice:
     
    
   </p>
   <ol>
    <li>
     
      We can start by making a small change to
     
     <strong class="source-inline">
      
       fastify-microservice
      
     </strong>
     
      .
     
     
      Open
     
     <strong class="source-inline">
      
       routes/example/index.js
      
     </strong>
     
      and change the response that is returned on line 5 to
     
     
      
       the following:
      
     
     <pre class="source-code">
<strong class="bold">    return 'this is an updated example'</strong></pre>
    </li>
    <li>
     
      Now we need to rebuild our container for our microservice.
     
     
      We’ll tag this image with version
     
     <strong class="source-inline">
      
       2.0.0
      
     </strong>
     
      .
     
     
      Enter the following command to rebuild and tag
     
     
      
       the image:
      
     
     <pre class="source-code">
<strong class="bold">$ docker build --tag fastify-microservice:2.0.0 .</strong></pre>
    </li>
    <li>
     
      Now we need to update our Kubernetes deployment.
     
     
      Open
     
     <strong class="source-inline">
      
       deployment/fastify-app.yml
      
     </strong>
     
      and change the image to reference our new
     
     
      
       image tag:
      
     
     <pre class="source-code">
        image: fastify-microservice:2.0.0</pre>
    </li>
    <li>
     
      Now we need to reapply our Kubernetes deployment configuration with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ kubectl apply --filename deployment/fastify-app.yml</strong>
deployment.apps/fastify-app configured</pre>
    </li>
    <li>
     
      Enter the following to obtain the
     
     <strong class="source-inline">
      
       NodePort
      
     </strong>
     
      for our Kubernetes Service.
     
     
      We need this port to access the application from
     
     
      
       our browser:
      
     
     <pre class="source-code">
<strong class="bold">$ kubectl describe service fastify-app-svc | grep NodePort:</strong>
NodePort:                 &lt;unset&gt;  <strong class="bold">31815</strong>/TCP</pre>
    </li>
    <li>
     
      Navigate to
     
     <strong class="source-inline">
      
       http://localhost:&lt;NodePort&gt;/example
      
     </strong>
     
      , where
     
     <strong class="source-inline">
      
       NodePort
      
     </strong>
     
      is the port output from the
     
     
      
       previous command.
      
     
    </li>
   </ol>
   <p>
    
     The
    
    <strong class="bold">
     
      this is an updated example
     
    </strong>
    
     string should be returned in your browser, indicating that the rolling update has
    
    
     
      taken
     
    
    
     <a id="_idIndexMarker928">
     </a>
    
    
     
      place.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Once you’ve completed this recipe, including the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section, you should delete the Kubernetes resources you have created to avoid an unnecessary load on your system.
    
    
     To delete the deployment, use the
    
    <strong class="source-inline">
     
      $ kubectl delete deployment fastify-app
     
    </strong>
    
     command.
    
    
     Similarly, to delete the Kubernetes Service, use the
    
    <strong class="source-inline">
     
      $ kubectl delete service
     
    </strong>
    
     <strong class="source-inline">
      
       fastify-app-svc
      
     </strong>
    
    
     
      command.
     
    
   </p>
   <h2 id="_idParaDest-375">
    <a id="_idTextAnchor387">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building a Docker container
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Publishing a Docker image
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
   </ul>
  </div>
 </body></html>