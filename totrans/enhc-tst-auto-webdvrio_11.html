<html><head></head><body>
		<div id="_idContainer104">
			<h1 id="_idParaDest-167" class="chapter-number"><a id="_idTextAnchor218"/>11</h1>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor219"/>Echo Location – Skipping the Page Object Model</h1>
			<p>So far, we have used the <strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) to encapsulate the UI elements and interactions <a id="_idIndexMarker444"/>with a page within an object. We can usually see our target objective <em class="italic">clearly</em> with the XPath or CSS locator, but consider the superheroes who get the job done blindly in the dark. While the POM has many merits, there are scenarios where finding objects by text alone, in the dark, based on some clues, can <span class="No-Break">offer advantages:</span></p>
			<ul>
				<li><strong class="bold">Quick prototyping and simplified test creation</strong>: For quick and dirty testing or prototyping, it might be overkill to establish a full-fledged POM of thousands of objects. In such cases, directly locating elements can speed up the initial test <span class="No-Break">development process.</span></li>
				<li><strong class="bold">Handling elements with dynamic content</strong>: In modern web applications, the content can be highly dynamic. Elements may not have fixed IDs, classes, or other attributes. Text content is often more stable in later releases behind the scenes in <span class="No-Break">the DOM.</span></li>
				<li><strong class="bold">Code readability</strong>: Tests written with direct text queries can sometimes be more readable and self-explanatory. Anyone reading the test can understand the user interactions being mimicked, without needing to dive into the page objects to understand what each <span class="No-Break">method does.</span></li>
			</ul>
			<p>In this chapter, we'll cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>A reduced <span class="No-Break">code base</span></li>
				<li>Automation in <span class="No-Break">plain English</span></li>
				<li>Getting a visible button, field, and list <span class="No-Break">by name</span></li>
				<li>Getting a visible element from <span class="No-Break">a collection</span></li>
			</ul>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor220"/>A reduced code base</h1>
			<p>Skipping the POM <a id="_idIndexMarker445"/>reduces the amount of code you have to maintain. This can be particularly beneficial in smaller projects or proof-of-concept implementations, where quick development is more important than <span class="No-Break">long-term maintainability.</span></p>
			<p>While a “text-based” approach has its merits, it’s crucial to note that this is not a one-size-fits-all solution. It is intended to remain highly reliable, reducing the amount of <span class="No-Break">maintenance required.</span></p>
			<p>In this chapter, we will enhance our element location by passing just text. Which method is used <a id="_idIndexMarker446"/>will provide a clue as to the node types to return for consideration. What does it mean if we can just click <strong class="bold">Add To Cart</strong>, enter <strong class="source-inline">setValueAdv("First name", "Paul")</strong> into the <strong class="bold">First Name</strong> field, or even select <strong class="bold">2</strong> from the <strong class="bold">Number of </strong><span class="No-Break"><strong class="bold">Guests</strong></span><span class="No-Break"> list?</span></p>
			<p>We will enhance our three custom functions, allowing them to identify elements only based on a string. In addition to passing an object, a simple text string will be passed to the <strong class="source-inline">clickAdv()</strong>, <strong class="source-inline">setValueAdv()</strong>, and <strong class="source-inline">selectAdv()</strong> methods. This way, we can eliminate some of the page <span class="No-Break">objects entirely.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Automation in <span class="No-Break">plain English</span></li>
				<li>Clicking a named button <span class="No-Break">or link</span></li>
				<li>Entering text into a <span class="No-Break">named field</span></li>
				<li>Selecting an item from a <span class="No-Break">named list</span></li>
				<li>Chasing a rabbit hole more than three <span class="No-Break">layers deep</span></li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor221"/>Automation in plain English</h1>
			<p>We will continue <a id="_idIndexMarker447"/>to further modify our custom methods by allowing two different types of classes to be passed. Our methods still support a <strong class="source-inline">WebdriverIO WebElement</strong>, but now, we will enhance them with a string. For example, let’s say we want to click the <strong class="bold">HALLOWEEN PARTY</strong> button at the top of the CandyMapper site. Consider <span class="No-Break">this code:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B19395_11_1.jpg" alt="Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link</p>
			<p>Here is the <a id="_idIndexMarker448"/>POM approach to find <span class="No-Break">the link:</span></p>
			<pre class="source-code">
public get btnHalloweenParty () {
   return $(`#nav-55206 &gt; li:nth-child(2) &gt; a`);
}
Helpers.clickAdv (btnHalloweenParty);</pre>			<p>By using the echo location superpower, this line of code could be smart enough to find the proper link with <span class="No-Break">just this:</span></p>
			<pre class="source-code">
Helpers.clickAdv ("Halloween Party");</pre>			<p>Alternatively, you could enter an email into <span class="No-Break">a field:</span></p>
			<pre class="source-code">
Helpers.setValueAdv ("Email", "me@mydomain.com");</pre>			<p>You could also add a total of two guests to accompany you to <span class="No-Break">the party:</span></p>
			<pre class="source-code">
Helpers.selectAdv ("Guests","2");</pre>			<p>Now, we can enhance the method to split along a path that is either an object or a string; in this case, we can use our <strong class="source-inline">getValidObject()</strong> to return a collection of visible elements that contain the string. In addition, we can deduce the type of elements to seek, based on <a id="_idIndexMarker449"/>the verb of the action being called. <strong class="source-inline">ClickAdv()</strong> will look for buttons, links, and similar elements. <strong class="source-inline">SetValue()</strong> will look for input fields or <strong class="source-inline">textarea</strong> nodes. <strong class="source-inline">SelectAdv()</strong> will interact <span class="No-Break">with lists.</span></p>
			<p class="callout-heading">Quick tip</p>
			<p class="callout">While we could extend this to our <strong class="source-inline">assertAdv()</strong> function, it is not recommended. The problem is that the <strong class="source-inline">assertAdv()</strong> function with a string would need a lot more context. It would be nearly impossible to determine whether we are validating a button state, a field value, a list item, or some displayed text. It is better to keep this simple and just confirm that the text we seek is visible on the page and highlight all potential matches. For anything else, just pass the <span class="No-Break"><strong class="source-inline">WebElement</strong></span><span class="No-Break"> class.</span></p>
			<p>Our first step is to extend a code path that will interact with both <strong class="source-inline">WebElement</strong> and a string in the <strong class="source-inline">clickAdv()</strong> method. This same process will apply to the <strong class="source-inline">getValidElement()</strong> function, which we’ll do in the following section. Lastly, the <strong class="source-inline">SetValueAdv()</strong> and <strong class="source-inline">Selectadv()</strong> functions will be modified with their relative sections <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">getValidElement()</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor222"/>Getting a named button</h2>
			<p>In each of <a id="_idIndexMarker450"/>the three custom functions, we will extend the element <a id="_idIndexMarker451"/>types that are passed to include strings <span class="No-Break">like this:</span></p>
			<pre class="source-code">
export async function clickAdv(
element: WebdriverIO.Element | string,
text: string ) {</pre>			<p>If a string is passed, we will use it to identify a valid element of the <span class="No-Break">type passed:</span></p>
			<pre class="source-code">
// If button element is a string, find the elements using the string
if (typeof element === 'string') {
element = await getValidElement(element, "button");
}</pre>			<p>In this <a id="_idIndexMarker452"/>example, we provide a clue that this element will be <a id="_idIndexMarker453"/>a button. The same will be done next for returning a field to set <span class="No-Break">a value.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor223"/>Getting a named input field</h2>
			<p>The same <a id="_idIndexMarker454"/>will be modified for <strong class="source-inline">setValueAdv</strong> in a similar fashion. However, we will <a id="_idIndexMarker455"/>instruct <strong class="source-inline">getValidElement</strong> to seek out an input or <strong class="source-inline">textarea</strong> <span class="No-Break">field class:</span></p>
			<pre class="source-code">
export async function setValueAdv(
inputField: WebdriverIO.Element | string,
text: string ) {
// If inputField is a string, find the elements using the string
if (typeof inputField === 'string') {
inputField = await getValidElement(element, "field");
}</pre>			<p>As with the last two functions, we will extend <strong class="source-inline">selectAdv()</strong> with a final <span class="No-Break">clue string.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor224"/>Getting a named list</h2>
			<p>Finally, <strong class="source-inline">selectAdv()</strong> will be <a id="_idIndexMarker456"/>modified as well. The types of <a id="_idIndexMarker457"/>elements that might match will <span class="No-Break">be listed:</span></p>
			<pre class="source-code">
export async function selectAdv(
inputField: WebdriverIO.Element | string,
text: string ) {
// If inputField is a string, find the elements using the string
if (typeof inputField === 'string') {
inputField = await getValidElement(inputField, "list") as Element;
}</pre>			<p>Now that <a id="_idIndexMarker458"/>these three <a id="_idIndexMarker459"/>methods are updated, we need to enhance the <strong class="source-inline">getValidElement()</strong> method to return an element that fits each <span class="No-Break">verb type.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor225"/>Getting a visible button by name</h1>
			<p>The first enhancement in the <strong class="source-inline">getValidElement()</strong> method is to allow a string to be passed, as with <a id="_idIndexMarker460"/>the three <span class="No-Break">preceding methods:</span></p>
			<pre class="source-code">
export async function getValidElement(
  element: WebdriverIO.Element | String,
  elementType: string
): Promise&lt;WebdriverIO.Element&gt; {</pre>			<p>The first check that we can perform is to see whether there are <em class="italic">any</em> elements that might match what we seek. In this case, we can leverage both an XPath and a CSS locator for a second time. This XPath locator will seek any node that contains the text passed to <span class="No-Break">the method:</span></p>
			<pre class="source-code">
if (typeof element == "string") {
    // Try finding "Halloween Party" element by xPath text
    elements = await browser.$$(`//*[contains(normalize-space(),'${eleText}')]`)</pre>			<p>If there are no elements returned, a second attempt will be done with a CSS selector using the <strong class="source-inline">href</strong> property. This property often contains the text string in a lowercase set, oriented <span class="No-Break">by dashes:</span></p>
			<pre class="source-code">
    // No such elements by element
    if (elements.length == 0) {
      //Try finding CSS href contains "halloween-party"
     const elements = await browser.$$(`[href*='${eleText}.toLowerCase().replaceAll(" ", "-")}']`)
    }</pre>			<p>Now, we have <a id="_idIndexMarker461"/>three types of elements to sort through. Let us deal with each one separately, starting with a button for <span class="No-Break">a click:</span></p>
			<pre class="source-code">
If (elements.length &gt; 0 and elementType === "button"{
let buttonElements = await browser.$$(`(//a|//button)[contains(normalize-space(),'${element}')]`)
    }</pre>			<p>If this returns no matching element, we can try this <span class="No-Break">case-insensitive approach:</span></p>
			<pre class="source-code">
 if (elements.length === 0) {
let buttonElements = await browser.$$(` (//a|//button)[contains(translate(normalize-space(text()), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${element}')]
`)
}</pre>			<p>Now, we have a good shot at finding a button based solely on a string passed into the function. Let us do the same for input fields and <span class="No-Break">text areas.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor226"/>Getting a visible field by name</h1>
			<p>Next, we have <a id="_idIndexMarker462"/>to gather a collection <span class="No-Break">of fields:</span></p>
			<pre class="source-code">
If (elements.length &gt; 0 and elementType === "field"{
elements = await browser.$$(`//label[
normalize-space()='${element}']//preceding::input `)
    }</pre>			<p>If there are no matches, we will take a second shot at finding text areas relative to <span class="No-Break">a label:</span></p>
			<pre class="source-code">
If (fieldElements.length === 0 and elementType === "field"{
elements = await browser.$$(`//label[normalize-space()='${element}']//preceding::textarea`)
}</pre>			<p>Finally, we will do the same for a collection <span class="No-Break">of lists.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor227"/>Getting a visible list by name</h1>
			<p>Next, we will <a id="_idIndexMarker463"/>try to find a list element based on <span class="No-Break">the text:</span></p>
			<pre class="source-code">
If (lelements.length &gt; 0 and elementType === "list"{
elements = await browser.$$(`//select[@id='${element}'] `)
    }
If no Select element matches that we take a second chance by searching for by the name attribute.
If (elements.length === 0 and elementType === "list"{
elements = await browser.$$(`//select[@name='${element}'] `)
    }
///</pre>			<p>If no <strong class="source-inline">Select</strong> element matches either of these, then we take a final shot by searching for a combo box relative to <span class="No-Break">a label:</span></p>
			<pre class="source-code">
If (elements.length === 0 and elementType === "list"{
listElements = await browser.$$(`//label[contains(@for,'#{element}')]/following::select`)
    }</pre>			<p>We are <a id="_idIndexMarker464"/>not done quite yet. The collection of elements returned must be filtered <span class="No-Break">for visibility.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor228"/>Getting a visible element from a collection</h1>
			<p>Now that <a id="_idIndexMarker465"/>we have a collection of potential elements, we will parse through them to find the first one that <span class="No-Break">is visible:</span></p>
			<pre class="source-code">
for (let element of elements) {
const tagName = await element.getTagName();
// const tagName = await element.getAttribute('class'); // Alternate class match
await element.waitForDisplayed({ timeout: 0 });
const isVisible = await element.isDisplayed();
// const isVisible = await highlight(element);
// Alternate visible validation.
If (isVisible)
//Found a matching button or an element with anchor class. Exiting loop
break;
}</pre>			<p>At this point, we have made an educated guess as to which element is being referenced. All we need to do is return the element to be interacted with from the <span class="No-Break">calling method:</span></p>
			<pre class="source-code">
return element;
}</pre>			<p>At this point, you might <a id="_idIndexMarker466"/>see ways to further identify collections, We encourage you to modify the two or three sample locators to work with your particular <span class="No-Break">framework, but...</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor229"/>Beware the endless rabbit hole!</h1>
			<p>As we come to the end of this section, you may have noticed that we have given no more than three examples to dynamically locate multiple nodes by text. And for good reason. You might spend hours trying to find a fifth or sixth template that will return the perfect collection of elements. We recommend limiting the search to just three attempts. It is just not worth the time to go deeper down this rabbit hole, reducing accuracy and slowing the result <span class="No-Break">search time.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor230"/>Summary</h1>
			<p>In this chapter, we demonstrated how to dynamically locate elements using just a string, much like how a superhero uses their keen senses to pinpoint villains just by their silhouette. We employed a clue from each action, narrowing down the pool of potential elements to those pertinent to the requested action, akin to a superhero zeroing in on their target. Lastly, we established a boundary on the number of attempts to identify a valid element, similar to how a superhero might limit their efforts in a search before changing tactics. </p>
			<p>In the next chapter, we will explore expanding our testing to multiple environments, paralleling how a superhero adapts to different challenges in various suburbs <span class="No-Break">of Metropolis.</span></p>
		</div>
	</body></html>