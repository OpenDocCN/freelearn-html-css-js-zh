<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Building an Advanced Profile Search Widget</h1></div></div></div><p>The best way to master FRP using Bacon.js is by building a real world application, which is what we will do in this chapter. We will build an advanced profile search widget, just like the ones you would usually find on social networking or dating sites. To keep the chapter short and to the point, we will work with some sample data instead of building registration functionality. We will also learn some more advanced concepts of functional programming and Bacon.js.</p><p>In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Error events in Bacon.js</li><li class="listitem" style="list-style-type: disc">Handling exceptions in FRP</li><li class="listitem" style="list-style-type: disc">Lazy evaluation</li><li class="listitem" style="list-style-type: disc">Buses in Bacon.js</li><li class="listitem" style="list-style-type: disc">Join patterns</li><li class="listitem" style="list-style-type: disc">Finally, we will build an advanced profile search widget</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Errors in Bacon.js</h1></div></div></div><p>Bacon <a id="id298" class="indexterm"/>provides the <code class="literal">Bacon.Error</code> constructor to explicitly mark events or <a id="id299" class="indexterm"/>values of EventStreams or properties respectively as errors so that Bacon can identify them and open up a wide variety of other APIs to work with those errors specifically.</p><p>Depending on how we create a stream, Bacon.js can sometimes identify whether an event is a success or error event, and if it's an error event, then it can convert it to <code class="literal">Bacon.Error</code>. For example, if we use <code class="literal">Bacon.fromPromise</code> to create an EventStream, then Bacon can identify an error easily, since when an error occurs in a promise pattern, the second callback of the <code class="literal">then()</code> method or the callback passed to the <code class="literal">catch()</code> method is executed.</p><p>In case <a id="id300" class="indexterm"/>Bacon cannot identify whether an event is an error or success event <a id="id301" class="indexterm"/>while creating a stream, then we need to explicitly create instances of <code class="literal">Bacon.Error</code> and replace the error events with them. For example, when using <code class="literal">Bacon.fromCallback</code>, there is no way for Bacon.js to know whether an event is a success or error event, so we need to explicitly convert error events to instances of <code class="literal">Bacon.Error</code>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Subscribing to errors</h2></div></div></div><p>A callback <a id="id302" class="indexterm"/>passed to <code class="literal">onValue</code> is not invoked for <code class="literal">Bacon.Error</code> events or values; instead, we need to use <code class="literal">onError</code>.</p><p>To see it in action, open the <code class="literal">index.js</code> file that we created in our previous chapter, and add this code:</p><div><pre class="programlisting">response.onError(function(error){
  console.log("An error occured while fetching the page", error);
})</pre></div><p>Now, if you enter an URL that cannot be fetched, a custom error message is displayed on the console.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Mapping errors</h2></div></div></div><p>The<code class="literal"> map()</code> function <a id="id303" class="indexterm"/>doesn't map <code class="literal">Bacon.Error</code> instances; therefore, Bacon provides us with <code class="literal">mapError ()</code>, which works the same way as <code class="literal">map</code> but maps only <code class="literal">Bacon.Error</code> instances.</p><p>Similarly, <code class="literal">flapMap()</code> doesn't map <code class="literal">Bacon.Error</code> instances. Therefore, Bacon provides us with <code class="literal">flatMapError()</code>, which works the same way as <code class="literal">flatMap</code> but maps only <code class="literal">Bacon.Error</code> instances.</p><p>Aside from <code class="literal">flatMap</code> and <code class="literal">map</code>, <code class="literal">Bacon.Error</code> instances can pass through everything.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Retrying a function call</h2></div></div></div><p>Sometimes, we <a id="id304" class="indexterm"/>might want to retry an operation if it fails. For example, if we fail to retrieve a web page using AJAX due to a server timeout error, then we might want to try retrieving it again after some time.</p><p>Bacon provides the <code class="literal">Bacon.retry</code> function, using which we can make a function call again and again as long as we want to.</p><p>
<code class="literal">Bacon.retry</code> returns an EventStream, and it takes an object with four properties, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">source</code>: This is a <a id="id305" class="indexterm"/>function that is to be reinvoked. This function must return a property or EventStream.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retries</code>: This is a <a id="id306" class="indexterm"/>number representing the total number of times to retry the source function for in addition to the initial attempt. When a <code class="literal">Bacon.Error</code> instance is pushed to the property or stream returned by the source function, then an attempt to retry is made.</li><li class="listitem" style="list-style-type: disc"><code class="literal">isRetryable</code>: This is an <a id="id307" class="indexterm"/>optional property. It needs to be assigned to a function. The function should return either <code class="literal">true</code> or <code class="literal">false</code>. When something is pushed into the property or EventStream returned by the source function, then <code class="literal">isRetryable</code> is invoked to find our whether an attempt to retry should be made.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delay</code>: This is an <a id="id308" class="indexterm"/>optional property. It's assigned to a function that returns the time in milliseconds to wait for before retrying. The default value is <code class="literal">0</code>.</li></ul></div><p>The EventStream <a id="id309" class="indexterm"/>returned by <code class="literal">Bacon.retry</code> has the event or value that was present in the last EventStream or property returned by the last call to the source function.</p><p>Let's see the <code class="literal">Bacon.retry</code> function in action. Find this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var response = url.flatMap(function(value){
 return Bacon.fromPromise($.ajax({url:value}));
}).toProperty();</pre></div><p>Replace it with this code:</p><div><pre class="programlisting">var response = url.flatMap(function(value){
  return Bacon.retry({
    source: function(){ return Bacon.fromPromise($.ajax({url:value})); },
    retries: 5,
    isRetryable: function (error) { return error.status !== 404; },
    delay: function(context) { return 2000; }
  })
}).toProperty();</pre></div><p>Here, we are retrying the AJAX request <code class="literal">5</code> times after every <code class="literal">2</code> seconds for any error other than <code class="literal">404</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Ending an EventStream or property on error</h2></div></div></div><p>An EventStream <a id="id310" class="indexterm"/>or property is said to <a id="id311" class="indexterm"/>have ended when you cannot push anything to it.</p><p>If you want to end an EventStream or property when a <code class="literal">Bacon.Error</code> instance is pushed, then you need to call the <code class="literal">endOnError</code> method of the EventStream or property. The <code class="literal">endOnError</code> method returns a new EventStream or property, which is ended when a <code class="literal">Bacon.Error</code> instance is pushed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Handling exceptions</h1></div></div></div><p>If an <a id="id312" class="indexterm"/>exception is encountered inside a callback passed to a Bacon helper function, then it's not caught automatically; rather, we have to use a <code class="literal">try…catch</code> statement to handle it. A common practice is to return a <code class="literal">Bacon.Error</code> instance after catching an exception so that we can handle it just like an error.</p><p>Here is an example of how to handle exceptions. In the <code class="literal">index.js</code> file, find the following code:</p><div><pre class="programlisting">var response = url.flatMap(function(value){
  return Bacon.retry({
    source: function(){ return Bacon.fromPromise($.ajax({url:value})); },
    retries: 5,
    isRetryable: function (error) { return error.status !== 404; },
    delay: function(context) { return 2000; }
  })
}).toProperty();</pre></div><p>Replace it with this:</p><div><pre class="programlisting">var response = url.flatMap(function(value){
  try
  {
    return Bacon.retry({
      source: function(){ return Bacon.fromPromise($.ajax({url:value})); },
      retries: 5,
      isRetryable: function (error) { return error.status !== 404; },
      delay: function(context) { return 2000; }
    })
  }
  catch(e)
  {
    return new Bacon.Error(e);
  }
  
}).toProperty();</pre></div><p>Here, we <a id="id313" class="indexterm"/>are catching exceptions and creating a new <code class="literal">Bacon.Error</code> instance with the exception as the details of the error, that is, we are passing the exception as an argument to the constructor.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Constant properties</h1></div></div></div><p>Bacon also <a id="id314" class="indexterm"/>provides us ways to create constant properties. Constant properties are initialized at the time of creation and cannot be reinitialized, that is, new values cannot be pushed.</p><p>A constant property is created using the <code class="literal">Bacon.constant()</code> constructer. We need to pass the value of the property to the constructor. A constant property can be merged, concatenated, combined, zipped, sampled, filtered, and transformed.</p><p>Here is an example of how to create a constant property. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var script_start_time = Bacon.constant(Date.now()).map(function(value){
  var date = new Date(value);
  return (date).getHours() + ":" + (date).getMinutes() + ":" + (date).getSeconds();
});

script_start_time.onValue(function(value){
  console.log("This script started running at : " + value);
})</pre></div><p>Here, the <code class="literal">constant</code> property stores the time at which the script was started and prints the time.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec42"/>An overview of buses</h1></div></div></div><p>A <strong>bus</strong> is <a id="id315" class="indexterm"/>just like an EventStream, but it lets us push values into the stream manually instead of attaching it to a source, and it also allows plugging other EventStreams and properties into the bus on the fly.</p><p>Here is an example that demonstrates how to create a bus and various methods provided by a <code class="literal">Bacon.Bus</code> instance. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var bus1 = new Bacon.Bus();

bus1.onValue(function(event){
  console.log(event);
})

bus1.push(1);
bus1.push(2);
var bus2 = new Bacon.Bus();
bus1.plug(bus2);
bus2.push(3); 
bus1.error("Unknown Error"); //pushed an Bacon.Error
bus1.end();
bus2.push(4); //this will not be pushed as bus has ended</pre></div><p>The <a id="id316" class="indexterm"/>code is self explanatory. The output of the above code is as follows:</p><div><pre class="programlisting">1
2
3</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec43"/>Subscribing to the end of EventStreams and properties</h1></div></div></div><p>Bacon <a id="id317" class="indexterm"/>provides the <code class="literal">onEnd</code> method to subscribe to callbacks that will be executed when an EventStream or property ends.</p><p>Here is <a id="id318" class="indexterm"/>some example code, which shows you how to use the <code class="literal">onEnd</code> callback. Place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">script_start_time.onEnd(function(){
  console.log("Script start time has been successfully calculated and logged");
})</pre></div><p>Here, we are attaching an <code class="literal">onEnd</code> callback to the constant property, which we created previously. After initialization, the property is ended; therefore, the <code class="literal">onEnd</code> callback is invoked. We can register multiple subscribers as well.</p><p>Actually, to end an EventStream or property, Bacon internally pushes an instance of the <code class="literal">Bacon.End</code> constructor. So, we can also use the <code class="literal">Bacon.End</code> constructor to end an EventStream or property.</p><p>Let's look at an example of how to use <code class="literal">Bacon.End</code>. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var custom_stream = Bacon.fromBinder(function(sink) {
  sink(10);
  sink(20);
  sink(new Bacon.End()); //event stream ends here
  sink(30); //this will not be pushed
});

custom_stream.onValue(function(event){
  console.log(event);
});</pre></div><p>The <a id="id319" class="indexterm"/>output <a id="id320" class="indexterm"/>of the code is this:</p><div><pre class="programlisting">10
20</pre></div><p>A <code class="literal">Bacon.End</code> instance doesn't pass through helper functions.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Unplugging subscribers</h1></div></div></div><p>We saw <a id="id321" class="indexterm"/>how to subscribe to an EventStream and property using <code class="literal">onValue</code>, <code class="literal">onError</code>, and <code class="literal">onEnd</code>. We can also unsubscribe the subscribers if we don't need them anymore.</p><p>These functions return a function for unsubscribing. To unsubscribe, we need to call the function returned by the subscriber function.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Combining and zipping</h1></div></div></div><p>Bacon <a id="id322" class="indexterm"/>provides certain methods to combine and zip properties <a id="id323" class="indexterm"/>and EventStreams. There is a significant difference between combining and zipping.</p><p>When we combine properties, we always get a property, which will have an array of all source <a id="id324" class="indexterm"/>properties as its value. If we try to combine EventStreams, then <a id="id325" class="indexterm"/>they are first converted to properties before combining takes place. When there is a push in any one of the source properties, a new value is pushed into the resultant property. <strong>Combining</strong> <a id="id326" class="indexterm"/>starts after each of the source properties has a value pushed.</p><p>Here is an example to demonstrate combining. Place this code in the <code class="literal">index.js</code> file.</p><div><pre class="programlisting">var x1 = new Bacon.Bus();
var x2 = new Bacon.Bus();
var x3 = new Bacon.Bus();

Bacon.combineAsArray(x1, x2, x3).onValue(function(value){
  console.log(value);
})

x1.push(0);
x1.push(1);
x2.push(2);
x3.push(3);
x3.push(4);
x1.push(5);</pre></div><p>Here is the output of the code:</p><div><pre class="programlisting">[1, 2, 3]
[1, 2, 4]
[5, 2, 4]</pre></div><p>Zipping is <a id="id327" class="indexterm"/>different from combining. <strong>Zipping</strong> means that events from <a id="id328" class="indexterm"/>each source are combined pairwise so that the first event <a id="id329" class="indexterm"/>from each source is published first, then the second event, and so on. The results will be published as soon as there is a value from each source. When <a id="id330" class="indexterm"/>we zip properties and EventStreams, we always get an EventStream.</p><p>Here is an <a id="id331" class="indexterm"/>example to demonstrate zipping. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var y1 = new Bacon.Bus();
var y2 = new Bacon.Bus();
var y3 = new Bacon.Bus();

Bacon.zipAsArray(y1, y2, y3).onValue(function(value){
  console.log(value);
})

y1.push(0);
y1.push(1);
y2.push(2);
y3.push(3);
y3.push(4);
x1.push(5);</pre></div><p>Here is the output of the code:</p><div><pre class="programlisting">[0, 2, 3]</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Lazy evaluation</h1></div></div></div><p>In programming, <strong>lazy evaluation</strong> <a id="id332" class="indexterm"/>is a strategy that delays the evaluation of values until they're needed. There are two means by which lazy evaluation is implemented by Bacon.js.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Type 1</h2></div></div></div><p>A stream or <a id="id333" class="indexterm"/>property will not be attached to its data source <a id="id334" class="indexterm"/>until it has subscribers. Let's look at an example to understand this. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var myButton_click_stream1 = $("#myButton").asEventStream("click").map(function(event){
  console.log(event);
  return event;
});</pre></div><p>Here, when you click on the <code class="literal">myButton</code> button, nothing will be logged. Now, place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">myButton_click_stream1.onValue(function(event){})</pre></div><p>Now when you click on the button, the event will be logged.</p><p>The <code class="literal">log</code> method is also considered as a subscriber.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Type 2</h2></div></div></div><p>Methods such <a id="id335" class="indexterm"/>as <code class="literal">map</code> and <code class="literal">combine*</code> use lazy evaluation to <a id="id336" class="indexterm"/>avoid evaluating events and values that aren't actually needed. Lazy evaluation results in huge performance benefits in some cases.</p><p>But how do <code class="literal">map</code> and <code class="literal">combine*</code> know whether an event or value is not needed? Well, there are a few methods that give a hint about this to <code class="literal">map</code> and <code class="literal">combine*</code>, for example, <code class="literal">sampledBy</code>.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>What is the <code class="literal">sampledBy</code> method?</p><p>The<strong> </strong>
<code class="literal">sampledBy</code> method is used for sampling a property based on a property or EventStream. It returns a property or EventStream, respectively, by sampling the property value at each event from the given property or EventStream. The returned property or EventStream will contain the property value at each push in the source property or EventStream.</p></div></div><p>Let's look at an example of how <code class="literal">map</code> implements lazy evaluation. Place this code in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var myBus_1 = Bacon.Bus();
var myBus_2 = Bacon.Bus();

var myProperty_1 = myBus_1.map(function(event){
  console.log(""Executing 1"");
  return event;
}).toProperty();

var myStream_1 = myProperty_1.sampledBy(myBus_2);

myStream_1.onValue(function(event){
  console.log(""Logged"", event);
})

myBus_1.push(1);</pre></div><p>Here is <a id="id337" class="indexterm"/>what we are doing in the previous code:</p><div><ol class="orderedlist arabic"><li class="listitem">We first create two buses.</li><li class="listitem">Then, we map events in the first bus using the <code class="literal">map</code> method, and it is then transformed into a property.</li><li class="listitem">We then create an EventStream by sampling the property value at each event in the second bus.</li><li class="listitem">We then add a subscriber to the EventStream.</li><li class="listitem">Finally, we push a value to the first bus.</li></ol></div><p>The previous code looks like it should log the following output:</p><div><pre class="programlisting">Executing 1
Logged 1</pre></div><p>Unfortunately, it doesn't log anything. That's because lazy evaluation is taking place here. The <code class="literal">sampledBy</code> function takes the current value of the property, not the ones that were generated from previous events. Therefore, <code class="literal">map</code> decides to generate the property value when an event occurs in the second bus, therefore preventing unnecessary calls to the callback passed to the <code class="literal">map</code> function. In short, here, <code class="literal">map</code> simply prevents calculating property values until it's actually needed. Now, add this code to the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">myBus_1.push(2);
myBus_2.push();</pre></div><p>Now, when you run the code, you will get this output:</p><div><pre class="programlisting">Executing 1
Logged 2</pre></div><p>Here, you can see that <code class="literal">map</code> prevented calculating for the first event pushed inside the first bus. It calculated the property value for second event because sampling was done after that.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>If you want to prevent lazy evaluation when using the <code class="literal">map()</code> method, then use <code class="literal">flatMap</code> instead of <code class="literal">map</code>. The <code class="literal">flatMap</code> method doesn't use lazy evaluation. There is no way to prevent lazy evaluation when using <code class="literal">combine*</code> methods, but if you need it badly, then you can try to rewrite the code using other methods, which may or may not be possible depending on what you are trying to achieve.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Building the profile search widget</h1></div></div></div><p>We've covered <a id="id338" class="indexterm"/>almost all the important APIs and concepts of Bacon.js. Now, it's time to build the profile search widget. We will also learn some more APIs and concepts in the process.</p><p>We will build the profile search widget to learn how to write reactive code using Bacon for both the frontend and backend in real-world projects. Let's get started.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Understanding project directories and files</h2></div></div></div><p>In the <a id="id339" class="indexterm"/>exercise files of this chapter, you <a id="id340" class="indexterm"/>will find a directory named <code class="literal">profile-search</code>-<code class="literal">widget</code>. Inside that directory, you will find two other directories named <code class="literal">final</code> and <code class="literal">initial</code>. The <code class="literal">final</code> directory contains the final code for the profile search widget whereas the <code class="literal">initial</code> directory contains the files and code for you to quickly get started with building the profile search widget. You will now work with the <code class="literal">initial</code> directory.</p><p>You are supposed to put the server-side code inside the <code class="literal">app.js</code> file and the frontend code inside the <code class="literal">public/js/index.js</code> file. Currently, the <code class="literal">app.js</code> file imports Bacon, Express, and filesystem modules and also has basic code to run the web server and serve static files.</p><p>Inside the <code class="literal">public/html/index.html</code> file, you will find HTML code. We will not be writing any HTML or CSS.</p><p>Let's first build the backend and then the frontend.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Converting Express.js routes to a functional reactive pattern</h2></div></div></div><p>
<strong>Express.js</strong> routes <a id="id341" class="indexterm"/>are written using a callback pattern. We need a wrapper <a id="id342" class="indexterm"/>to convert the callback pattern to a functional reactive pattern.</p><p>Bacon <a id="id343" class="indexterm"/>doesn't provide any direct method for doing this—there are various other custom methods. The easiest and shortest way to do this is by creating a bus for every route, and whenever a request to a route is made, pushing an event into its respective bus. Let's create a route this way for serving the <code class="literal">index.html</code> file for requests to the root URL. Place this code in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">function route_eventstream(path)
{
    var bus = new Bacon.Bus();

    app.get(path, function(req, res) {
      bus.push({
          req: req,
          res: res
      });
    });

    return bus;
}

var root_stream = route_eventstream("/");

root_stream.onValue(function(event){
  event.res.sendFile(__dirname + ""/public/html/index.html"");
})</pre></div><p>This <a id="id344" class="indexterm"/>is how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we <a id="id345" class="indexterm"/>define a function named <code class="literal">route_eventstream</code>, which acts as a wrapper to convert callback patterns to EventStream patterns. It takes a path and returns a bus. Whenever a request is made to the route, an event is pushed into the bus. The event is a connection object, that is, it holds the request and response objects for that client request.</li><li class="listitem">Then, we create an EventStream for root path requests.</li><li class="listitem">Finally, we register a subscriber that returns the <code class="literal">index.html</code> file whenever an event is pushed into the root EventStream.</li></ol></div><p>Now, run the <code class="literal">node app.js</code> command and visit <code class="literal">localhost:8080</code> in your browser. This is the output you will see:</p><div><img src="img/B05154_08_01.jpg" alt="Converting Express.js routes to a functional reactive pattern"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Making the user experience better</h2></div></div></div><p>In the <a id="id346" class="indexterm"/>previous screenshot, you can see that there are eight fields based on which a user can perform a search.</p><p>Instead of a user just filling some of the fields and clicking on the <strong>Search</strong> button to get the result, we can add some more features to make the user experience better. Here are the extra things we are going to add:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whenever a user uses the <em>Enter</em> key in any of the fields, we need fetch the search result</li><li class="listitem" style="list-style-type: disc">While a user types the company name, we will show a drop-down menu with suggestions</li><li class="listitem" style="list-style-type: disc">At least one of the fields except the gender field should have some value in order for us to fetch a search result.</li><li class="listitem" style="list-style-type: disc">If the entered e-mail is of invalid format, then we should display an error message.</li></ul></div><p>These features will make the frontend code more complex, which will give us a chance to explore how to write complex logic using Bacon.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec59"/>The company suggestions route</h2></div></div></div><p>Let's create <a id="id347" class="indexterm"/>a route that responds with an array of company name suggestions based on a given value. Later on, to populate the company name text field drop-down menu, we will make a request to this route.</p><p>We will not build functionality to add profiles; instead, we will simply retrieve profiles from a JSON file that has some random profiles. In the <code class="literal">initial</code> directory, you will find a file named <code class="literal">data.json</code>, which has some profiles in it.</p><p>Let's first read the data from the <code class="literal">data.json</code> file. Here is the code for this. Place it in the <code class="literal">app.js</code> file.</p><div><pre class="programlisting">var data = Bacon.fromNodeCallback(fs.readFile, "data.json", "utf8").map(function(event){
  return JSON.parse(event);
}).toProperty();</pre></div><p>Here, we are reading the data in functional reactive style and then converting the EventStream to a property, which represents the data.</p><p>Here is the code for the company suggestion route. Place it in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">function findMatchingCompanyName(list, companyName)
{
  return list.filter(function(value){
    return companyName != "" &amp;&amp; value.company.toLowerCase().indexOf(companyName.toLowerCase()) == 0;
  })
}

var company_dropdown_list_stream = route_eventstream(""/company/dropdown"");

var company_dropdown_list_data_stream = Bacon.combineAsArray([data, company_dropdown_list_stream]).map(function(event){
  return findMatchingCompanyName(event[0], event[1].req.query.companyName);
}).toEventStream();

Bacon.zipAsArray(company_dropdown_list_stream, company_dropdown_list_data_stream).onValues(function(event1, event2) {
  event1.res.send(event2);
});</pre></div><p>Here is how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we define a method that takes an array of profiles and a company name. It <a id="id348" class="indexterm"/>checks for the profiles that have the same company and returns the filtered list. We are using the ES6 filter method, as Bacon doesn't provide any filter method for arrays. If the company name string is empty, then it returns an empty array.</li><li class="listitem">Then, we create an EventStream for <code class="literal">/company/dropdown</code> path requests.</li><li class="listitem">Then, we combine <code class="literal">company_dropdown_list_stream</code> and the <code class="literal">data</code> property. The resultant property is then mapped, and the filtered result is the transformed value.</li><li class="listitem">We cannot simply use a subscriber here for <code class="literal">company_dropdown_list_stream</code> to respond to, as we have lost the reference to the connection object. Therefore, we zip <code class="literal">company_dropdown_list_stream</code> and <code class="literal">company_dropdown_list_data_stream</code> so that we get the reference to the connection object as well as the final result. We then attach a subscriber to the zipped EventStream, which sends the response.</li><li class="listitem">One more thing to notice here is that we are using <code class="literal">onValues</code> instead of <code class="literal">onValue</code>. The difference between them is that <code class="literal">onValues</code> splits the value (assuming it's an array) as function arguments.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec60"/>The search result route</h2></div></div></div><p>Let's create a <a id="id349" class="indexterm"/>route that responds with an array of profiles based on a given parameter. This will be used to find the search result. Later on, from the frontend, we will make a request to this route.</p><p>Here is the code for this route. Place it in the <code class="literal">app.js</code> file:</p><div><pre class="programlisting">function findMatchingProfilesForEmail(list, email)
{
  return list.filter(function(value){
    return value.email == email;
  })
}

function findMatchingProfiles(list, firstName, lastName, gender, skill, company, dob, address)
{
  var firstName_matches = list.filter(function(value){
    return firstName == "" || value.first_name.toLowerCase() == firstName.toLowerCase();
  })

  var lastName_matches = firstName_matches.filter(function(value){
    return lastName == "" || value.last_name.toLowerCase() == lastName.toLowerCase();
  })

  var gender_matches = lastName_matches.filter(function(value){
    return gender == "" || value.gender.toLowerCase() == gender.toLowerCase();
  })

  var skill_matches = gender_matches.filter(function(value){
    return skill == "" || value.skill.toLowerCase() == skill.toLowerCase();
  })

  var company_matches = skill_matches.filter(function(value){
    return company == "" || value.company.toLowerCase() == company.toLowerCase();
  })

  var dob_matches = company_matches.filter(function(value){
    return dob == "" || value.dob == dob;
  })

  var address_matches = dob_matches.filter(function(value){
    return address == "" || value.address.toLowerCase() == address.toLowerCase();
  })

  return address_matches;
}

var profile_search_stream = route_eventstream("/search");

var profile_search_data_stream_for_email = Bacon.combineAsArray([data, profile_search_stream.filter(function(event){
  return event.req.query.email != "";
})]).map(function(event){
  return findMatchingProfilesForEmail(event[0], event[1].req.query.email);
}).toEventStream();

var profile_search_data_stream_for_others = Bacon.combineAsArray([data, profile_search_stream.filter(function(event){
  return event.req.query.email == "";
})]).map(function(event){
  return findMatchingProfiles(event[0], event[1].req.query.firstName, event[1].req.query.lastName, event[1].req.query.gender, event[1].req.query.skill, event[1].req.query.company, event[1].req.query.dob, event[1].req.query.address);
}).toEventStream();

Bacon.zipAsArray(profile_search_stream, Bacon.mergeAll([profile_search_data_stream_for_email, profile_search_data_stream_for_others])).onValues(function(event1, event2) {
  event1.res.send(event2);
});</pre></div><p>This is <a id="id350" class="indexterm"/>how the code works:</p><div><ol class="orderedlist arabic"><li class="listitem">At first, we define two methods, which take a list of profiles and search data and filter based on the data. The first one only filters based on e-mail whereas the second one filters based on other search data. We have done it this way because e-mail is unique for every profile, and if a user provides an e-mail ID, then we don't need to use other data and waste computation. When there is a lot of data, you will get a big performance advantage this way.</li><li class="listitem">Then, we create an EventStream for the <code class="literal">/search</code> path.</li><li class="listitem">After that, we create two streams, namely, <code class="literal">profile_search_data_stream_form_email</code> and <code class="literal">profile_search_data_stream_form_others</code>. The <code class="literal">profile_search_data_stream_form_email</code> stream is the final result if an e-mail is provided, and <code class="literal">profile_search_data_stream_form_others</code> is the final result if an e-mail is not provided. </li><li class="listitem">Finally, we merge <code class="literal">profile_search_data_stream_form_email</code> and <code class="literal">profile_search_data_stream_form_others</code>, zip that with <code class="literal">profile_search_stream</code>, and return the response.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Building the frontend</h2></div></div></div><p>We are done <a id="id351" class="indexterm"/>building the backend part of our profile search widget. Now, we need to write the frontend part.</p><p>Before we get into it, it's worth looking at the code in the <code class="literal">index.html</code> file:</p><div><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Advanced Profile Search Widget&lt;/title&gt;

    &lt;link rel="stylesheet" type="text/css" href="css/style.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class="container"&gt;
      &lt;div class="section-1"&gt;
        &lt;h3&gt;Provide search information&lt;/h3&gt;
        &lt;hr&gt;
        &lt;div class="form-style"&gt;
            &lt;form action="" method="post"&gt;
                &lt;label&gt;&lt;span&gt;First Name&lt;/span&gt;&lt;input type="text" class="input-field" id="first-name" value="" /&gt;&lt;/label&gt;
                &lt;label&gt;&lt;span&gt;Last Name &lt;/span&gt;&lt;input type="text" 
                class="input-field" id="last-name" value="" /&gt;&lt;/label&gt;
                &lt;label&gt;
                  &lt;span&gt;Email&lt;/span&gt;
                  &lt;input type="email" class="input-field" id="email" value="" /&gt;
                  &lt;br&gt;&lt;small class="hide" id="email-error"&gt;Email address is invalid&lt;/small&gt;
                &lt;/label&gt;
                &lt;label&gt;
                    &lt;span&gt;Gender&lt;/span&gt;
                    &lt;select id="gender" class="select-field"&gt;
                        &lt;option value="male"&gt;Male&lt;/option&gt;
                        &lt;option value="female"&gt;Female&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/label&gt;
                &lt;label&gt;&lt;span&gt;Company&lt;/span&gt;&lt;input list="companies" type="text" class="input-field" value="" id="company" /&gt;&lt;/label&gt;
                &lt;label&gt;&lt;span&gt;Address&lt;/span&gt;&lt;input type="address" class="input-field" value="" id="address" /&gt;&lt;/label&gt;
                &lt;label&gt;&lt;span&gt;Skill&lt;/span&gt;&lt;input type="text" class="input-field" value="" id="skill" /&gt;&lt;/label&gt;
                &lt;label&gt;&lt;span&gt;DOB&lt;/span&gt;&lt;input placeholder="mm/dd/yyyy" type="text" class="input-field" value="" id="dob" /&gt;&lt;/label&gt;
                &lt;label&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;input type="button" value="Search" id="search" /&gt;&lt;/label&gt;

                &lt;datalist id="companies"&gt;&lt;/datalist&gt;
            &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class="section-2"&gt;
        &lt;h3&gt;Search Result&lt;/h3&gt;
        &lt;hr&gt;
        &lt;ul id="search-result"&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class="clear"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;script type="text/javascript" src="img/jquery-2.2.0.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="img/Bacon.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="img/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Most of <a id="id352" class="indexterm"/>the code is self-explanatory. Here are a few things you need to pay special attention to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Here, every input element has an <code class="literal">id</code> value attached to it. We will use the <code class="literal">id</code> value to create an EventStream.</li><li class="listitem" style="list-style-type: disc">We have displayed an error message below the e-mail field. It has a class <code class="literal">hide</code>, which hides it. Removing the class will unhide it.</li><li class="listitem" style="list-style-type: disc">We also have a <code class="literal">datalist</code> element, which is the drop-down menu for the <code class="literal">company</code> field. We just need to add <code class="literal">option</code> tags to the <code class="literal">datalist</code> element to show the drop-down menu.</li><li class="listitem" style="list-style-type: disc">Finally, we have a section to display the search result.</li></ul></div><p>Now, let's create EventStreams for <code class="literal">keyup</code> events on the input fields and store the current value of the fields in properties. Here is the code for this. Place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var first_name_keypress_stream = $("#first-name").asEventStream("keyup");

var first_name = first_name_keypress_stream.scan("", function(value){
  return $("#first-name").val();
});

var last_name_keypress_stream = $("#last-name").asEventStream("keyup");

var last_name = last_name_keypress_stream.scan("", function(value){
  return $("#last-name").val();
});

var email_keypress_stream = $("#email").asEventStream("keyup");

var is_email_valid = email_keypress_stream.scan("", function(value){
  return $("#email").val();
}).map(function(value){
  var re = /^(([^&lt;&gt;()[\]\\.,;:\s@"]+(\.[^&lt;&gt;()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-
9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(value);
});

var email = Bacon.mergeAll(is_email_valid.filter(function(value){
  return value == true;
}).map(function(value){
  $("#email-error").addClass("hide");
  return $("#email").val();
}), is_email_valid.filter(function(value){
  return value == false;
}).map(function(value){
  $("#email-error").removeClass("hide");
  return "";
}))

var gender_select_stream = $("#gender").asEventStream("change");

var gender = gender_select_stream.scan("male", function(value){
  return $("#gender option:selected").val()
})

var company_keypress_stream  = $("#company").asEventStream("keyup");

var company = company_keypress_stream.scan("", function(value){
  return $("#company").val();
});

var address_keypress_stream  = $("#address").asEventStream("keyup");

var address = address_keypress_stream.scan("", function(value){
  return $("#address").val();
});

var skill_keypress_stream  = $("#skill").asEventStream("keyup");

var skill = skill_keypress_stream.scan("", function(value){
  return $("#skill").val();
});

var dob_keypress_stream  = $("#dob").asEventStream("keyup");

var dob = dob_keypress_stream.scan("", function(value){
  return $("#dob").val();
});</pre></div><p>Most of <a id="id353" class="indexterm"/>the above code is self-explanatory. The only thing that you need to understand is that instead of directly assign the e-mail field value to the e-mail property, we first validate whether the e-mail is valid. If the e-mail is invalid, then we display the error message and don't assign anything to the e-mail property. If the e-mail is valid, then we hide the error message and assign the current value of the e-mail field to the e-mail property.</p><p>Now, let's write code to display the suggestions drop-down menu for the company field. Here is the code for this. Place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">company.flatMap(function(event){
  return Bacon.fromPromise($.ajax({url:"/company/dropdown?companyName=" + encodeURIComponent(event)}));
}).flatMap(function(event){
  $("#companies").empty();
  return Bacon.fromArray(event);
}).onValue(function(event){
  $("#companies").append("&lt;option value=''" + event.company + "''&gt;");
});</pre></div><p>Here, whenever the value of company property changes, we make a request to the <code class="literal">/company/dropdown</code> path, retrieve the suggestions, and append them to the <code class="literal">datalist</code>.</p><p>Finally, we need to make a <code class="literal">search</code> request whenever a user clicks on the <strong>Search</strong> button or hits <em>Enter</em> while in any of the input fields. Here is the code for this. Place it in the <code class="literal">index.js</code> file:</p><div><pre class="programlisting">var search_button_click_stream = $("#search").asEventStream("click");

var search_result_request_stream = Bacon.mergeAll(Bacon.mergeAll([first_name_keypress_stream, last_name_keypress_stream, email_keypress_stream, company_keypress_stream, address_keypress_stream, skill_keypress_stream, search_button_click_stream, dob_keypress_stream]).filter(function(event){
  return event.keyCode == 13;
}), search_button_click_stream);


var search_result_request_data = Bacon.combineAsArray([first_name, last_name, email, gender, company, skill, dob, address]).sampledBy(search_result_request_stream).flatMap(function(event){
  return event;
});
var search_result_request_cancel = search_result_request_data.filter(function(event){
  return event[0] == "" &amp;&amp; event[1] == "" &amp;&amp; event[2] == "" &amp;&amp; event[4] == "" &amp;&amp; event[5] == "" &amp;&amp; event[6] == "" &amp;&amp; event[7] == "";
}).onValue(function(){
  $("#search-result").empty();
  alert("Enter enter some data");
});

var search_result_response = search_result_request_data.filter(function(event){
  return event[0] != "" || event[1] != "" || event[2] != "" || event[4] != "" || event[5] != "" || event[6] != "" || event[7] != "";
}).flatMap(function(event){
  return Bacon.fromPromise($.ajax({url:"/search?firstName=" + encodeURIComponent(event[0]) + "&amp;lastName=" + encodeURIComponent(event[1]) + "&amp;email=" + encodeURIComponent(event[2]) + "&amp;gender=" + encodeURIComponent(event[3]) + "&amp;company=" + encodeURIComponent(event[4]) + "&amp;address=" + encodeURIComponent(event[7]) + "&amp;skill=" + encodeURIComponent(event[5]) + "&amp;dob=" + encodeURIComponent(event[6]) }));
}).toProperty();

search_result_response.onError(function(){
  $("#search-result").empty();
  alert("An error occured");
})

search_result_response.flatMap(function(value){
  $("#search-result").empty();
  return Bacon.fromArray(value);
}).onValue(function(value){
  var html = "&lt;li&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;Name: &lt;/b&gt; &lt;span&gt;" + value.first_name + " " + value.last_name + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;Email: &lt;/b&gt; &lt;span&gt;" + value.email + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;Gender: &lt;/b&gt; &lt;span&gt;" + value.gender + "&lt;/span&gt;&lt;/p&gt;";
  htmt = html + "&lt;p&gt;&lt;b&gt;Company: &lt;/b&gt; &lt;span&gt;" + value.company + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;Address: &lt;/b&gt; &lt;span&gt;" + value.address + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;DOB: &lt;/b&gt; &lt;span&gt;" + value.dob + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;p&gt;&lt;b&gt;Skill: &lt;/b&gt; &lt;span&gt;" + value.skill + "&lt;/span&gt;&lt;/p&gt;";
  html = html + "&lt;/li&gt;";

  $("#search-result").append(html);  
});

search_result_response.filter(function(value){
  return value.length == 0;
}).onValue(function(value){
  $("#search-result").empty();
  alert("Nothing found")
})</pre></div><p>Here is <a id="id354" class="indexterm"/>how the code works:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">At first, we create a click stream for the <strong>Search</strong> button.</li><li class="listitem" style="list-style-type: disc">Then, we create the <code class="literal">search_result_request_stream</code> stream, in which an event is pushed whenever we click on the <strong>Search</strong> button or press the <em>Enter</em> key inside any of the fields.</li><li class="listitem" style="list-style-type: disc">Then, we make a request to the <code class="literal">/search</code> path if any of the fields along with the gender field has a value; otherwise, we display an alert message asking the user to enter some data.</li><li class="listitem" style="list-style-type: disc">And then, if the we get an AJAX error, then we display an alert with the error message; if the AJAX response isn't empty, then we display the result; and finally, if the AJAX request is empty, we displaying an alert with a message stating that nothing was found.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Testing the widget</h2></div></div></div><p>To test the <a id="id355" class="indexterm"/>widget, rerun the <code class="literal">node app.js</code> command. Now, refresh the <code class="literal">localhost:8080</code> URL.</p><p>To test whether the search widget is working, enter <code class="literal">Robert</code>
<strong> </strong>in the <strong>First</strong> <strong>Name</strong> field and press <em>Enter</em>. You will see this output:</p><div><img src="img/B05154_08_02.jpg" alt="Testing the widget"/></div><p>To <a id="id356" class="indexterm"/>test the company suggestions drop-down menu, enter <code class="literal">a</code> in the <strong>Company</strong> field, and you will see this output:</p><div><img src="img/B05154_08_03.jpg" alt="Testing the widget"/></div><p>So <a id="id357" class="indexterm"/>now, we have finished building and testing our advanced profile search widget.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we explored the advanced APIs and concepts of Bacon.js and built a real-world project using them. You should now be comfortable with writing reactive code in a functional manner using Bacon.js and should try integrating Bacon.js into your existing and future projects.</p><p>You can also learn more about Bacon.js APIs at <a class="ulink" href="https://baconjs.github.io/api.html">https://baconjs.github.io/api.html</a>.</p></div></body></html>