- en: Universal Web Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用 Web 组件
- en: In the last chapter, we talked about the various life cycle callback methods
    of Web Components. In this chapter, we will look into the styling of Web Components,
    with a lot of examples. Styling plays a vital role in the look and feel of a Web
    Component. We will also be taking a look at what accessibility does to our Web
    Components and understand the meaning of the Gold Standard Checklist and how this
    Gold Standard Checklist makes a Web Component extremely usable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 Web 组件的各种生命周期回调方法。在本章中，我们将探讨 Web 组件的样式化，并给出很多示例。样式在 Web 组件的外观和感觉中起着至关重要的作用。我们还将探讨可访问性对
    Web 组件的影响，并理解金标准清单的意义以及这个金标准清单如何使 Web 组件极其易用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Styling Web Components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 组件的样式化
- en: Accessibility for Web Components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 组件的可访问性
- en: Gold Standard Checklist
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金标准清单
- en: Styling Web Components
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 组件的样式化
- en: In the previous chapters, we looked at custom elements that use a shadow DOM
    for encapsulation and custom elements that do not use a shadow DOM. We will be
    styling our Web Component for both of these types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了使用 shadow DOM 进行封装的定制元素和不使用 shadow DOM 的定制元素。我们将为这两种类型的 Web 组件添加样式。
- en: Let's say, we have a Web Component called `<company-header>`. For the sake of
    simplicity, this header component needs to have an icon on the left-hand side
    with a circular border and this icon needs to be a link; the name of the page
    should be right next to the icon, and then there should be two other links on
    the extreme right-hand side, say home and about us.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `<company-header>` 的 Web 组件。为了简化，这个头部组件需要在左侧有一个图标，并且这个图标需要有一个圆形的边框；这个图标需要是一个链接；页面的名称应该紧挨着图标，然后应该在最右侧再有两个其他链接，比如主页和关于我们。
- en: '![](img/a0d805b8-26db-4d38-9caf-b4a4d2193a64.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a0d805b8-26db-4d38-9caf-b4a4d2193a64.png)'
- en: 'This is how it should be used inside the `index.html` file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `index.html` 文件中的使用方式：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are being a little bit adventurous, I would like you to stop reading
    for a while and write the completed code for this component based on the knowledge
    you have achieved in the previous chapters. Once you have done so, feel free to
    continue reading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有点冒险精神，我希望你暂时停止阅读，并根据你在前几章中获得的知识编写这个组件的完整代码。一旦你完成了，请随意继续阅读。
- en: 'Now, based on the information provided as a requirement for the component,
    our `index.html` file would look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据为组件提供的要求信息，我们的 `index.html` 文件可能看起来像这样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we have done nothing different other than the way we are calling
    the `<company-header>` component. Let''s take a look at the `CompanyHeader.js`
    file. Note that we are going to use the Web Component without a shadow DOM in
    this example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们除了调用 `<company-header>` 组件的方式外，没有做任何不同的事情。让我们看看 `CompanyHeader.js` 文件。请注意，在这个例子中，我们将不使用
    shadow DOM 来使用 Web 组件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `constructor()` interface is responsible for making sure that `icon` is
    set to a default file and the component renders properly without any issue. We
    also learned in the previous section about `attributeChangedCallback()`, so `get
    observedAttributes()` is simply creating a list of attributes to listen to for
    changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor()` 接口负责确保 `icon` 被设置为默认文件，并且组件能够无任何问题地正确渲染。我们也在上一节中学习了 `attributeChangedCallback()`，所以
    `get observedAttributes()` 简单地创建了一个用于监听变化的属性列表。'
- en: Furthermore `attributeChangedCallback()` is making sure that the changed attribute
    values are being used properly. The `getTemplate()` method simply returns an ES6
    template string, which can be set as `innerHTML` of the Web Component.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`attributeChangedCallback()` 确保更改后的属性值被正确使用。`getTemplate()` 方法简单地返回一个 ES6
    模板字符串，它可以被设置为 Web 组件的 `innerHTML`。
- en: 'Now that our Web Component is working fine, let''s add the style for this component.
    Inside the `index.html` file, we can create a `<style>` tag and add our styles
    inside it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的 Web 组件运行良好，让我们为这个组件添加样式。在 `index.html` 文件中，我们可以创建一个 `<style>` 标签并在其中添加我们的样式：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, we can have the style attached directly to the `<company-header>`
    element.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以将样式直接附加到 `<company-header>` 元素上。
- en: 'However, now we may have a problem. There might be some other `div` with the
    class name `.heading`, and this CSS might bleed out to that other class. You may
    argue that we should namespace our CSS by adding `company-header` in front of
    the CSS used, making it look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们可能遇到了一个问题。可能存在一些其他带有`.heading`类名的`div`，并且这个CSS可能会扩散到那个其他类。您可能会争辩说我们应该通过在CSS前添加`company-header`来对CSS进行命名空间，使其看起来像下面这样：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This may fix the problem a little bit, but does not fix it completely. It still
    doesn't fix the part where the `.heading` class CSS bleeds out to the `.heading`
    class in `company-header` and then gets overwritten by the `company-header` namespaced
    heading class. Hence, comes our shadow DOM specification.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能稍微解决了问题，但并没有完全解决。它仍然没有解决`.heading`类CSS扩散到`company-header`中的`.heading`类，然后被`company-header`命名空间标题类覆盖的问题。因此，出现了我们的阴影DOM规范。
- en: 'Let us try to write the Web Component with a shadow DOM:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编写一个带有阴影DOM的Web组件：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, most of the code is the same, other than the part where we create
    a shadow root and add our HTML inside this shadow root.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分代码是相同的，除了我们创建一个阴影根并在其中添加我们的HTML的部分。
- en: 'If you run the code now, you will see that our styles do not apply inside the
    Web Component. So, the CSS is not bleeding anymore. But, in order to get back
    our CSS, we will need to add it as the part of the template, making it look like
    this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行代码，你会看到我们的样式在Web组件内部不适用。所以，CSS不再扩散。但是，为了恢复我们的CSS，我们需要将其作为模板的一部分添加，使其看起来像这样：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, our component looks beautiful with all the CSS, but what is `:host` ?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的组件有了所有的CSS看起来很漂亮，但`:host`是什么？
- en: While we can add CSS inside the shadow root with the help of selectors, we do
    not have a selector associated with the shadow root itself, which acts as a container
    for the HTML. So, we can have CSS attached to this shadow root with the help of
    the `:host` selector.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过选择器在阴影根内部添加CSS，但我们没有与阴影根本身关联的选择器，它充当HTML的容器。因此，我们可以通过`:host`选择器将CSS附加到这个阴影根。
- en: 'Let''s try another example with styling. Let''s say we have a requirement to
    design a Web Component that lets you log in with the help of a login form. It
    needs to have a bluish background, and when the login is successful, it should
    turn this background to a greenish shade. Also, for the sake of simplicity, the
    username-password check will simply perform a `Math.random()` operation and, if
    this value is greater than *0.5*, then the login is successful:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个带有样式的示例。假设我们有一个设计Web组件的需求，让您通过登录表单登录。它需要一个蓝色的背景，当登录成功时，它应该变成绿色调。为了简单起见，用户名-密码检查将简单地执行`Math.random()`操作，如果这个值大于*0.5*，则登录成功：
- en: '![](img/e8ff7e8f-0c31-40bb-9093-77fd8c121ce6.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8ff7e8f-0c31-40bb-9093-77fd8c121ce6.png)'
- en: 'Let''s jump into the code. There are no changes to our `index.html` other than
    us including this new component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看代码。除了包括这个新组件之外，我们的`index.html`没有其他变化：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The definition of this `CompanyLogin` class is shown in the preceding code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CompanyLogin`类的定义在上面的代码中显示。
- en: 'Let''s take a look at our HTML template. We want a username text field, a password
    text field, and a button that can be clicked:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的HTML模板。我们想要一个用户名文本字段，一个密码文本字段，以及一个可以点击的按钮：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we need to add this template HTML to our shadow root:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将这个模板HTML添加到我们的阴影根中：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need a way to notify our Web Component as to when the button is being
    clicked:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来通知我们的Web组件何时按钮被点击：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We chose `connectedCallback()` for event handling here since we need to bind
    events only when HTML is on the page. We can handle our click event inside the `handleLogin()`
    method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择了`connectedCallback()`来处理事件，因为我们只需要在HTML在页面上时绑定事件。我们可以在`handleLogin()`方法内部处理我们的点击事件：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are simply printing the values of username and password.
    I chose to add a print example so that you have an idea about how it is very easy
    to read these values. We are also changing the class name of the actual Web Component
    based on the `Math.random()` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是打印了用户名和密码的值。我选择添加一个打印示例，以便您了解这些值非常容易阅读。我们还在根据`Math.random()`函数更改实际Web组件的类名。
- en: 'Now that we have a working component, we can start working on the CSS. We can
    add our CSS inside our template:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的组件，我们可以开始工作在CSS上了。我们可以在我们的模板中添加我们的CSS：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are again using the `:host` selector as a way to add CSS to the shadow root
    of our Web Component. In the `handleLogin()` function, we are adding CSS classes
    to our Web Component. We can target those classes from inside our CSS by using
    `:host(<selector>)` just like we used it in the preceding code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `:host` 选择器作为向我们的 Web 组件的 shadow root 添加 CSS 的方式。在 `handleLogin()` 函数中，我们向我们的
    Web 组件添加 CSS 类。我们可以通过使用 `:host(<selector>)` 来定位这些类，就像我们在前面的代码中所做的那样。
- en: 'When we run our Web Component on a browser, it looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器上运行我们的 Web 组件时，它看起来是这样的：
- en: '![](img/4e333b13-70f4-486a-b83d-b624038493ab.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e333b13-70f4-486a-b83d-b624038493ab.png)'
- en: Based on the `random()` function, we can get either a greenish background, indicating
    that it is a successful login, or the one with a red background.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `random()` 函数，我们可以得到一个带有绿色背景的背景，表示登录成功，或者带有红色背景的背景。
- en: Accessibility for Web Components
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 组件的可访问性
- en: Accessibility plays a vital role in web development. Our users can be limited
    to a keyboard, they might be using a screen reader, or could be color-blind. Making
    sure that our users are comfortable in all scenarios is the key to making a good
    site. Similarly, creating a good Web Component also includes making a Web Component
    accessible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性在 Web 开发中起着至关重要的作用。我们的用户可能只能使用键盘，他们可能在使用屏幕阅读器，或者可能是色盲。确保我们的用户在所有情况下都感到舒适是制作一个良好网站的关键。同样，创建一个良好的
    Web 组件也包括使其可访问。
- en: When you are creating a Web Component, you need to make sure that your Web Components
    are accessible at least up to a certain extent. For example, an image should always
    have `alt` text. A link should always have `alt` text. Input fields should have
    proper aria-labels. There should be sufficient color contrasts. Tab orders should
    be in the correct order, and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 Web 组件时，你需要确保你的 Web 组件至少在某种程度上是可访问的。例如，图片应该始终有 `alt` 文本。链接应该始终有 `alt`
    文本。输入字段应该有适当的 aria-labels。应该有足够的颜色对比度。Tab 顺序应该是正确的，等等。
- en: Now that we know what can be done to make a component accessible, let's take
    a look at a small example. Let's say the requirement is to create a `<header-image>`
    component that shows a full-width image. In order to make sure that this component
    is accessible, the image used should have `alt` text.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道如何使组件可访问，让我们看看一个小例子。假设要求是创建一个 `<header-image>` 组件，它显示一个全宽图片。为了确保这个组件是可访问的，使用的图片应该有
    `alt` 文本。
- en: 'Let''s take a look at our `getTemplate()` function for this component:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个组件的 `getTemplate()` 函数：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we are adding an `alt` attribute to the image tag, and we are grabbing
    this `alt` text from the Web Component itself:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向图片标签添加一个 `alt` 属性，并且我们从 Web 组件本身获取这个 `alt` 文本：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also have an error handler function called `handleErrors()`, which makes
    sure to tell the user that the component is missing `alt` text:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `handleErrors()` 的错误处理函数，它确保告诉用户组件缺少 `alt` 文本：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will show a Missing Alt Text error message in red, when the component is
    missing the alt text. We can solve other accessibility issues in the same way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件缺少 alt 文本时，这将在红色中显示“缺少 Alt 文本”错误消息。我们可以以同样的方式解决其他可访问性问题。
- en: Gold Standard Checklist
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金标准清单
- en: We have been creating Web Components in the previous sections, but, other than
    the accessibility, no other sections tell us what defines a good component. So,
    let's talk about it. The Gold Standard Checklist is a working draft (see [https://github.com/webcomponents/gold-standard/wiki](https://github.com/webcomponents/gold-standard/wiki))
    that tells the creators of a Web Component what things should be taken care of
    in order to create a good, reusable component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经创建了 Web 组件，但除了可访问性之外，没有其他章节告诉我们什么定义了一个好的组件。所以，让我们来谈谈它。金标准清单是一个工作草案（见
    [https://github.com/webcomponents/gold-standard/wiki](https://github.com/webcomponents/gold-standard/wiki)），它告诉
    Web 组件的创建者为了创建一个良好且可重用的组件应该注意哪些事情。
- en: 'Let''s talk about some of the points that I personally feel are important:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我个人认为重要的几点：
- en: Web components should be accessible. In order to make the Web Components work
    on all screens, we need to make sure that the component covers all aspects of
    accessibility.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 组件应该是可访问的。为了确保 Web 组件在所有屏幕上都能工作，我们需要确保组件覆盖所有可访问性方面。
- en: Binding of events should be done in `connectedCallback()`. This makes sure that
    the DOM to which events are bound will always be present, thus reducing the number
    of bugs.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定应该在`connectedCallback()`中进行。这确保了绑定事件的DOM始终存在，从而减少了错误数量。
- en: Event bindings should be removed in `disconnectedCallback()`, thus freeing up
    the memory that is not required anymore.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定应该在`disconnectedCallback()`中移除，从而释放不再需要的内存。
- en: Components should have default styling with good contrasting colors. This will
    make sure that components can be seen properly at all times.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件应该具有默认样式，并且具有良好的对比颜色。这将确保组件在所有时候都能被正确地看到。
- en: Components should also follow responsive designs. In order to make our component
    work on all screen sizes without any layout issues, we should make sure that we
    have responsive CSS associated with the Web Component.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件还应遵循响应式设计。为了确保我们的组件能够在所有屏幕尺寸上工作而不会出现布局问题，我们应该确保我们为Web组件关联了响应式CSS。
- en: Components should be able to expose events. We will be talking about events
    in [Chapter 5](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml), *Managing States and
    Props*, but the main takeaway from this point is that, if you are building a component
    that needs to tell other components the change in state, it should tell them by
    exposing an event callback.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件应该能够暴露事件。我们将在[第5章](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml)中讨论事件，*管理状态和属性*，但这个要点的主要收获是，如果你正在构建一个需要通知其他组件状态变化的组件，它应该通过暴露事件回调来通知它们。
- en: Even though the Gold Standard Checklist contains a lot of very good points,
    I feel that these six points should be able to make a component pretty good in
    terms of reusability. In case you are curious about the other points, here is
    the link to the full Gold Standard Checklist:[ https://github.com/webcomponents/gold-standard/wiki](https://github.com/webcomponents/gold-standard/wiki).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管黄金标准清单包含了许多非常好的观点，但我认为这六个观点足以使组件在可重用性方面相当不错。如果你对其他观点感兴趣，这里是可以查看完整黄金标准清单的链接：[https://github.com/webcomponents/gold-standard/wiki](https://github.com/webcomponents/gold-standard/wiki)。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked into different ways we can style a Web Component,
    learned about accessibility and how it can be used in creating a more complete
    Web Component, and then looked into the Gold Standard Checklist, which provides
    guidelines for creating a good Web Component.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了不同的样式化Web组件的方法，了解了可访问性以及如何在创建更完整的Web组件中使用它，然后探讨了黄金标准清单，它为创建良好的Web组件提供了指南。
- en: In the next chapter, we will be looking into reusability and how it can used
    in Web Components, along with how these Web Components are published on the web
    for maximum reusability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可重用性以及如何在Web组件中使用它，以及这些Web组件如何发布到网络上以实现最大程度的可重用性。
