<html><head></head><body>
		<div><h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor050"/>Chapter 3</em>: Navigating through a website</h1>
			<p>We have already laid the foundations for the rest of the book. In <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>, we learned about browser automation and headless browsers. <a href="B16113_02_Final_SK_ePub.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Automated Testing and Test runners</em>, was about automated testing and test runners. Now it's time to get more practical. In this chapter, we will learn about UI testing, but in the real world.</p>
			<p>In the following chapters, we will pick an open-source website made with Vue.js to test, but we are also going to navigate through many other public websites. I want you to learn techniques that help you test websites no matter the framework they use.</p>
			<p>I also want to share some tools with you, so you can finish this book with a complete toolbox. In this chapter, we will learn how to ship our code to GitHub and run our tests using GitHub Actions.</p>
			<p>In the previous chapter, we created a test project, and we ran a few tests without paying too much attention to the Puppeteer APIs we were using. In this chapter, we will create a test project again, but this time we will go deeper and see what Puppeteer has to offer on each API.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing the test site for this chapter</li>
				<li>Creating a Puppeteer browser</li>
				<li>Navigating through a site</li>
				<li>Using the Response object</li>
				<li>Introduction to Continuous Integration</li>
			</ul>
			<p>By the end of this chapter, we will have tested a real website, pushed it to GitHub, and run our tests automatically, learning many new APIs. Let's see what test sites we can use in this chapter.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Technical requirements</h1>
			<p>You will find all the code of this chapter in the GitHub repository (<a href="https://github.com/PacktPublishing/ui-testing-with-puppeteer">https://github.com/PacktPublishing/ui-testing-with-puppeteer</a>) under the <code>Chapter3</code> directory. We will consider <code>Chapter3</code> as the base path for all the demos. Inside the <code>Chapter3</code> directory, you will find three directories:</p>
			<ul>
				<li><code>vuejs-firebase-shopping-cart</code> contains the test site.</li>
				<li><code>init</code> is the directory you can use to follow this chapter.</li>
				<li><code>demo</code> contains the final code from this chapter.</li>
			</ul>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Introducing the tests sites for this chapter</h1>
			<p>In this chapter, we will test a site <a id="_idIndexMarker116"/>made with Vue.js. Thang Minh Vu (<a href="https://me.coddeine.com/">https://me.coddeine.com/</a>) wrote a great Vue.js example: <strong class="bold">vuejs-firebase-shopping-cart</strong> (<a href="https://github.com/ittus/vuejs-firebase-shopping-cart">https://github.com/ittus/vuejs-firebase-shopping-cart</a>).</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When you look for projects on GitHub or any other site like GitHub, you need to pay attention to the license the project uses. The fact that the code is open source doesn't mean that you can use it as you wish. This project uses the <strong class="bold">MIT License</strong>, which is one of the most permissive licenses. This license basically states that you can use the code <em class="italic">without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so.</em></p>
			<p>As we don't want you to deal with firebase setup, I forked this project (made a copy on GitHub), removing all the firebase code. You can find the base structure of the code used in this chapter inside the <code>init</code> directory. You just need to run <code>npm install</code> in the base folder and then run the following commands on the <code>vuejs-firebase-shopping-cart</code> folder.</p>
			<pre>&gt; cd init
&gt; npm install
&gt; cd vuejs-firebase-shopping-cart/
&gt; npm install
&gt; npm run build
&gt; npm run serve</pre>
			<p>In the terminal, you should<a id="_idIndexMarker117"/> have got a success message and the URL the site is now running:</p>
			<div><div><img src="img/Figure_3.01_B16113.jpg" alt="Site running&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Site running</p>
			<p>Now we should have a nice site running on port <code>8080</code>.</p>
			<div><div><img src="img/Figure_3.02_B16113.jpg" alt="Demo site running&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Demo site running</p>
			<p>We'll need two terminals to work on this project. In one terminal, we are going to run the website. In the second, we are going to launch our tests.</p>
			<p>If you are<a id="_idIndexMarker118"/> using VS Code, notice that the <strong class="bold">TERMINAL</strong> tab has a plus button. If you click on that button, a new terminal will be created. You can switch between terminals using the selection list to the left of that button.</p>
			<div><div><img src="img/Figure_3.03_B16113.jpg" alt="New terminal option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">New terminal option</p>
			<p>Let's run the site in one terminal using the same commands we used before:</p>
			<pre>&gt; cd vuejs-firebase-shopping-cart 
&gt; npm run build
&gt; npm run serve</pre>
			<p>You should get something like this:</p>
			<pre>DONE  Compiled successfully in 5523ms                     
1:42:33 PM
  App running at:
  - Local:   http://localhost:8080/ 
  - Network: http://192.168.86.64:8080/
  Note that the development build is not optimized.
  To create a production build, run npm run build.</pre>
			<p>Now let's run the tests in another terminal:</p>
			<pre>npm test</pre>
			<p>And here, you should be getting something like this:</p>
			<pre>&gt; mocha --timeout 30000 --reporter=list
  <img src="img/Tick_Main.png" alt=""/> Login Page Should have the right title: 3ms
  1 passing (875ms)</pre>
			<p>In the previous chapter, we didn't pay much attention to how we were using Puppeteer.  We just knew that if we did <code>browser = await puppeteer.launch();</code> we would get a new<a id="_idIndexMarker119"/> browser. How? No idea. Well, it's time to understand a little bit more about how Puppeteer works.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Creating a Puppeteer browser</h1>
			<p>The signature of the <code>launch</code> function is not <code>launch()</code>, but <code>launch(options)</code>. Thanks to the freedom we <a id="_idIndexMarker120"/>have in JavaScript, we can just avoid passing that argument, and the <code>launch</code> function will get <code>options</code> as <code>undefined</code>.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Using the Puppeteer.launch function</h2>
			<p>These are all the<a id="_idIndexMarker121"/> options <code>Puppeteer.launch</code> supports in Puppeteer 7 according to the official docs (<a href="https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions">https://github.com/puppeteer/puppeteer/blob/v7.0.0/docs/api.md#puppeteerlaunchoptions</a>):</p>
			<ul>
				<li><code>product</code>: Which browser to launch. At this time, this is either <code>chrome</code> or <code>firefox</code>.</li>
				<li><code>ignoreHTTPSErrors</code>: Whether to ignore HTTPS errors during navigation. This option will become handy when you want to automate websites with invalid or missing SSL certificates. This will prevent Chromium from returning an invalid certificate page in those cases.</li>
				<li><code>headless</code>: Whether to run the browser in headless mode. Defaults to <code>true</code> unless the <code>devtools</code> option is <code>true</code>.</li>
				<li><code>executablePath</code>: Path to a browser executable to run instead of the bundled Chromium.</li>
				<li><code>slowMo</code>: Slows down Puppeteer operations by the specified number of milliseconds. Useful so that you can see what is going on.</li>
				<li><code>defaultViewport</code>: Sets a<a id="_idIndexMarker122"/> consistent viewport for each page. Defaults to an 800x600 viewport. <code>null</code> disables the default viewport. A viewport is an object with the following properties:<p>a) <code>width</code>: page width in pixels.</p><p>b) <code>height</code>: page height in pixels.</p><p>c) <code>deviceScaleFactor</code>: Specify device scale factor.</p><p>d) <code>isMobile</code>: Whether the <code>meta viewport</code> tag is taken into account.</p><p>e) <code>hasTouch</code>: Specifies whether the viewport supports touch events.</p><p>f) <code>isLandscape</code>: Specifies whether the viewport is in landscape mode.</p></li>
				<li><code>args</code>: Additional arguments to pass to the browser instance.</li>
				<li><code>ignoreDefaultArgs</code>: If <code>true</code>, then do not use <code>puppeteer.defaultArgs()</code>. If an array is given, then filter out the given default arguments.</li>
				<li><code>handleSIGINT</code>: Close the browser process on <em class="italic">Ctrl +C</em>.</li>
				<li><code>handleSIGTERM</code>: Close the browser process on <code>SIGTERM</code>.</li>
				<li><code>handleSIGHUP</code>: Close the browser process on <code>SIGHUP</code>.</li>
				<li><code>timeout</code>: Maximum time in milliseconds to wait for the browser instance to <code>start</code>. Defaults to <code>30000</code> (30 seconds). Passing <code>0</code> disables the timeout.</li>
				<li><code>dumpio</code>: Whether to pipe the browser process <code>stdout</code> and <code>stderr</code> into <code>process.stdout</code> and <code>process.stderr</code>.</li>
				<li><code>userDataDir</code>: Path to a user data directory.</li>
				<li><code>env</code>: Specify environment variables that will be visible to the browser.</li>
				<li><code>devtools</code>: Whether to auto-open a DevTools panel for each tab. If this option is <code>true</code>, the <code>headless</code> option will be set to <code>false</code>.</li>
				<li><code>pipe</code>: Connects to the browser over a pipe instead of a WebSocket. Defaults to <code>false</code>.</li>
				<li><code>extraPrefsFirefox</code>: Additional preferences that can be passed to Firefox.</li>
			</ul>
			<p>That's a long list, I know. But I didn't want to<a id="_idIndexMarker123"/> just write about the features I think are interesting. I want you to have the full picture of the <code>launch</code> option. Now, let's talk about about the options you do need to know.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Headless</h2>
			<p>I think<a id="_idIndexMarker124"/> the <code>headless</code> option is the<a id="_idIndexMarker125"/> most used. Remember I told you we were going to use headless browsers? I won't say that I lied, but I lied. Headless mode is the default mode, but in fact, you could launch a browser with <code>headless</code> in <code>false</code>, also known as <em class="italic">"headful mode."</em> Headful mode is useful while debugging automation code because<a id="_idIndexMarker126"/> you will see what is going on in the browser. I bet that will be the default local setting. This is how you can launch the browser in headful mode:</p>
			<pre>const browser = await puppeteer.launch({ headless: false });</pre>
			<p>This line of code will launch a browser that will almost look like a normal browser.</p>
			<div><div><img src="img/Figure_3.04_B16113.jpg" alt="A browser in headful mode&#13;&#10;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A browser in headful mode</p>
			<p>As you can see, that's a full working browser. The only difference is that you will get that banner saying that <em class="italic">"Chrome is being controlled by automated test software."</em> If someone asks you, no, you<a id="_idIndexMarker127"/> can't remove that banner. I believe that with so much phishing and hacking around the internet, it's important to tell a potential user of the browser that there is an app behind it controlling and monitoring the browser activity.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>The user data directory</h2>
			<p>The <code>userDataDir</code>, Puppeteer will create a new directory <a id="_idIndexMarker129"/>before launching the browser. Then it will delete it when the browser is closed. That would mean that sessions or anything we store in cookies won't be preserved across test runs.</p>
			<p>In UI testing, we might want to use this option to check whether the site uses the local storage (for example, cookies) as expected. Does the site remember the logged-in user? Is the cart being preserved?</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Executable Path</h2>
			<p>The <code>executablePath</code> option is not<a id="_idIndexMarker130"/> common on UI testing. Most <a id="_idIndexMarker131"/>tests will run using the browser downloaded by Puppeteer. Still, this option is used a lot in task automation or scraping, when you want to use the browser you would normally use, or in some continuous integration environments, where you want to run an already downloaded browser.</p>
			<p>As we saw in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>, Puppeteer is guaranteed to work with a specific version of Chromium. In the case of Puppeteer 7.0.0, the Chromium version is 90.0.4403.0. That doesn't mean that it will not work with any other version, but it's not guaranteed.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are a macOS user, the Chrome executable will be inside the application bundle <code>Google Chrome.app</code>. For example, <code>/Applications/Google Chrome.app/Contents/MacOS/Google Chrome</code>.</p>
			<p>Using the <code>executablePath</code> option won't be enough if we want to use the exact same browser we would normally use. Remember that Puppeteer will create a new user data directory if we don't pass one. We need to pass the user data directory our browser uses. It should be <code>%LOCALAPPDATA%\Google\Chrome\User Data</code> in Windows, <code>~/Library/Application Support/Google/Chrome</code> in Mac, or <code>~/.config/google-chrome</code> in Linux. If you want to double-check that value, you can navigate to <code>chrome://version/</code> using your browser. There you will see the current <strong class="bold">Profile Path</strong>. You need to remove the<a id="_idIndexMarker132"/> Default directory in macOS.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are going to use your own browser, you can install puppeteer-core instead of Puppeteer. puppeteer-core won't download a browser, speeding up your install time and saving disk space.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Default Viewport</h2>
			<p>If you tried the headful<a id="_idIndexMarker133"/> mode, you might have seen <a id="_idIndexMarker134"/>something like this:</p>
			<div><div><img src="img/Figure_3.05_B16113.jpg" alt="Headful mode with no default viewport&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Headful mode with no default viewport</p>
			<p>No, the site is not broken. If we don't pass a <code>defaultViewport</code>, Puppeteer will default to a viewport of 800x600. If you were wondering what a viewport is, according to Wikipedia, <em class="italic">a viewport is the visible portion of the entire document</em>. </p>
			<p>The viewport is an important piece of UI testing. UX experts and designers make a significant effort trying to give the user the best experience for the device they are using. Frontend developers use CSS breakpoints to determine which layout to show based on the viewport size. Rico Sta. Cruz, on his blog post <em class="italic">What media query breakpoints should I use?</em> (<a href="https://ricostacruz.com/til/css-media-query-breakpoints">https://ricostacruz.com/til/css-media-query-breakpoints</a>), posted <a id="_idIndexMarker135"/>this excellent list of breakpoints:</p>
			<ul>
				<li>Mobile devices in portrait: From 320px to 414px.</li>
				<li>Mobile devices in landscape: From 568px to 812px.</li>
				<li>Table in portrait: From 768px to 834px.</li>
				<li>Table in landscape: From 1024px to 1112px.</li>
				<li>Laptops: From 1366px to 1440px.</li>
				<li>Desktop displays: 1680px to 1920px.</li>
			</ul>
			<p>You don't need to have many devices to test this. Just open a browser and change the size of the window.</p>
			<div><div><img src="img/Figure_3.06_B16113.jpg" alt="Different breakpoints Packtpub.com uses&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Different breakpoints Packtpub.com uses</p>
			<p>If you look at that <a id="_idIndexMarker136"/>screenshot, you will see that the site shows or hides different elements based on the viewport. It would show a big search bar in a big viewport, assuming a desktop experience. When it detects a small viewport, assuming a mobile device, it will hide the search bar and show a hamburger button.</p>
			<p>We need to consider all these changes when writing our tests.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Instead of trying to guess viewports, ask your frontend team what breakpoints they are using. But keep in mind that many bugs emerge on those precise breakpoints, test the breakpoints, and check whether they are appropriate.</p>
			<p>We will go deeper into this topic in <a href="B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137"><em class="italic">Chapter 8</em></a>, <em class="italic">Environments emulation</em>, when we talk about mobile emulation. One last trick here. If we pass <code>null</code>, the viewport will adapt to the window size, as you would expect in a normal browser.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Product</h2>
			<p>Are you saying that we can automate Firefox with Puppeteer? Yes, we can. Although it is still experimental. This is the <a id="_idIndexMarker137"/>official definition of "experimental": <em class="italic">Official Firefox support is currently experimental. The ongoing collaboration with Mozilla aims to support common end-to-end testing use cases, for which developers expect cross-browser coverage. The Puppeteer team needs input from users to stabilize Firefox support and to bring missing APIs to our attention.</em> My unofficial definition would be: <em class="italic">It uses a nightly build of Firefox, and the long-term support doesn't seem guaranteed.</em></p>
			<p>Disclaimers aside, if you want to launch a Firefox browser, you need first to install Puppeteer setting the <code>PUPPETEER_PRODUCT</code> variable:</p>
			<pre>PUPPETEER_PRODUCT=firefox npm install puppeteer@7.0.0</pre>
			<p>And then you can set Firefox as a product:</p>
			<pre>browser = await puppeteer.launch({ product: 'firefox' });</pre>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Browser Arguments</h2>
			<p>The <code>args</code> option<a id="_idIndexMarker138"/> is an array of arguments or <strong class="bold">flags</strong> you can pass to the browser. There are over 1,400 flags (<a href="https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags">https://www.hardkoded.com/ui-testing-with-puppeteer/chrome-flags</a>). It would be<a id="_idIndexMarker139"/> impossible to cover all 1,400 flags. </p>
			<p><code>--no-sandbox</code> is the most common flag. From the official documentation: <em class="italic">In order to protect the host environment from untrusted web content, Chrome uses multiple layers of sandboxing. For this to work properly, the host should be configured first.</em></p>
			<p>The key phrase here is <em class="italic">"the host should be configured first."</em> You might need to create a user with the right permissions to use Puppeteer in a more restricted context, such as <code>–no-sandbox</code> flag, which would bypass the sandboxing system.</p>
			<p>Other common flags are the following:</p>
			<ul>
				<li><code>--window-size</code> to set the window size.</li>
				<li><code>--proxy-server</code> and <code>--proxy-bypass-list</code> to set up proxy settings.</li>
			</ul>
			<p>There is another option called <code>extraPrefsFirefox</code>. You can use this property to set Firefox flags. Hopefully, you won't need to deal with these flags much.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Mobile options</h2>
			<p><code>deviceScaleFactor</code>, <code>isMobile</code>, <code>hasTouch</code>, and <code>isLandscape</code> will help us set up mobile emulation. We will cover these <a id="_idIndexMarker140"/>options more deeply in <a href="B16113_08_Final_SK_ePub.xhtml#_idTextAnchor137"><em class="italic">Chapter 8</em></a>, <em class="italic">Environments emulation</em>.</p>
			<p>As you can see, <code>puppeteer.launch()</code> is way more than that, and there are many others for you to keep digging.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Options in practice</h2>
			<p>Now let's see how we can apply these new features in the real world. The first thing we can do now, and you should do from now on, is to load the options object from the config file. Remember that the config class we have is JavaScript code. We can add a property there called <code>launchOptions</code> and pass that to the <code>launch</code> function. You don't even need to populate it if you don't want to, but it will be there, ready to be used.</p>
			<p>Your config file will look like this:</p>
			<pre>module.exports = ({
    local: {
        baseURL: 'http://localhost:8080/',
        launchOptions: { headless: false }
    },
})[process.env.TESTENV || 'local'];</pre>
			<p>Now, when we run these tests using the <code>local</code> config, it will launch the browser in headful mode. The next step is passing this option to the <code>launch</code> function:</p>
			<pre>before(async() =&gt; {
    browser = await puppeteer.launch(config.launchOptions);
});</pre>
			<p>Now let's try to code a real-life test. We want to test that the login action is being persisted after closing a browser.</p>
			<p>These are the steps:</p>
			<ol>
				<li>Open a browser using a user data directory.</li>
				<li>Check that we are logged out (checking that the login button says <strong class="bold">Login</strong>).</li>
				<li>Log in.</li>
				<li>Check that we are logged in (checking that the logout button says <strong class="bold">Logout</strong>).</li>
				<li>Close the browser.</li>
				<li>Open the browser.</li>
				<li>We should be logged in.</li>
			</ol>
			<p>We won't be able to reuse the browser we <a id="_idIndexMarker141"/>are using in other tests because we will need to create our own user data directory:</p>
			<pre>it('It should persist the user', async() =&gt; {
    const userDataDir = fs.mkdtempSync('profile');
    const options = config.launchOptions;
    options.userDataDir = userDataDir;
    let persistentBrowser = await puppeteer.launch(options);
    let persistentPage = await persistentBrowser.newPage();
    let loginModel = new LoginPageModel(persistentPage, config);
    await loginModel.go();
    (await loginModel.logState()).should.equal('Login');
    await loginModel.login(config.username, config.password);
    (await loginModel.logState()).should.equal('Logout');
    await persistentBrowser.close();
    persistentBrowser = await puppeteer.launch(options);
    persistentPage = await persistentBrowser.newPage();
    loginModel = new LoginPageModel(persistentPage, config);
    await loginModel.go();
    (await loginModel.logState()).should.equal('Logout');
    
    await persistentBrowser.close();
    deleteFolderRecursive(userDataDir);
});</pre>
			<p>This test is longer than the others because we need to create a browser, a page, and a model twice. Ignore how the <code>loginState</code> and <code>login</code> functions work. We will cover those functions in the following chapters.</p>
			<p>It's impressive, all the<a id="_idIndexMarker142"/> functionality that can be hidden inside a single line. Now let's see how we can improve our navigation skills.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Navigating through a site</h1>
			<p>If you look at how you <a id="_idIndexMarker143"/>navigate through different pages on a browser, there are basically four ways:</p>
			<ul>
				<li>You type a URL in the address bar or using a bookmark.</li>
				<li>You use the browser functions to go back, forward, or reload a page.</li>
				<li>You click on elements on a page.</li>
				<li>The site you are browsing redirects to another page.</li>
			</ul>
			<p>The <code>goto</code> function emulates the first option, navigating to a site. We use that to navigate to the page we want to test:</p>
			<pre>await this.page.goto(this.config.baseURL + 'login');</pre>
			<p>Now, guess what? The <code>goto</code> signature isn't <code>goto(url)</code> but <code>goto(url, options)</code>. You will see this pattern being repeated over and over – a function with one or more required arguments (or none), and then a set of extra options.</p>
			<p>Luckily for us, the options <code>goto</code> expects is not as <a id="_idIndexMarker144"/>big as the one we saw in the <code>launch</code> options. It only has three options:</p>
			<ul>
				<li><code>timeout</code>: Maximum navigation time in milliseconds.</li>
				<li><code>waitUntil</code>: When to consider navigation succeeded.</li>
				<li><code>referrer</code>: Referrer header value.</li>
			</ul>
			<p>Let's unpack these options.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Timeouts</h2>
			<p>You will see the <code>timeout</code> argument in many functions. Puppeteer groups timeouts in two groups: <strong class="bold">navigation timeouts</strong> and <strong class="bold">generic timeouts</strong> (this is not the official name; I named them in this way just to make these <a id="_idIndexMarker145"/>concepts easier to understand).</p>
			<p>If we wanted to<a id="_idIndexMarker146"/> set a default timeout in all<a id="_idIndexMarker147"/> our navigation calls, we could create a property in our config file and use it in every place. That sounds like a great idea, but there is an even better solution. We can use a property in our config file, but instead of passing that to every function we use, we can call <code>page.setDefaultTimeout(timeout)</code> or <code>page.setDefaultNavigationTimeout(timeout)</code>. </p>
			<p>The <code>page</code> object will store the timeout you pass to these functions and use them as a default value.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you don't pass a timeout to a function, nor set a default timeout, Puppeteer will set the timeout to 30 seconds (30,000 milliseconds).</p>
			<p>If we are testing a site locally, waiting 30 seconds for a page to load sounds like a lot. Let's reduce that time to 5 seconds. We can add a new property in our config file:</p>
			<pre>local: {
    baseURL: 'http://localhost:8080/',
    timeout: 5000,
},</pre>
			<p>And then, we can set that value using the default timeout:</p>
			<pre>page.setDefaultTimeout(config.timeout);</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">You don't need to <code>await</code> <code>setDefaultTimeout</code> or <code>setDefaultNavigationTimeout</code> because they are not <code>async</code>.</p>
			<p>The next option is the<a id="_idIndexMarker148"/> most interesting option in <code>goto</code>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>waitUntil</h2>
			<p>You might be thinking, "Wait until what?". Imagine if, when you do something like <code>await page.goto('https://www.packtpub.com/')</code>, Puppeteer resolves the <code>promise</code> as soon as the<a id="_idIndexMarker149"/> command is sent to the browser. The next command you run will get an empty page because it takes some time to be ready to be used. I bet you experience watching a white screen while waiting for a page to load. You have to <strong class="bold">wait until</strong> the page is ready.</p>
			<div><div><img src="img/Figure_3.07_B16113.jpg" alt="Empty page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Empty page</p>
			<p>Waiting for the page to<a id="_idIndexMarker150"/> be ready is key in browser automation. Many of the questions I see on Stack Overflow are related to this question: How do you know the page is ready? I hope when you finish this book, you can master this topic. In <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>, we will walk through many techniques to answer this question, but <code>page.goto</code> gives us this first tool: the <code>waitUntil</code> option.</p>
			<p><code>waitUntil</code> supports four options: </p>
			<p>The first option, and the default option, is <code>load</code>. If you pass <code>load</code> (or no option), the <code>promise</code> will be resolved then the <code>load</code> event is fired. According to Mozilla, the load event is fired <em class="italic">when the whole page has loaded, including all dependent resources such as stylesheets and images</em>.</p>
			<p>The second option is <code>domcontentloaded</code>, which relies on the <code>DOMContentLoaded</code> event. According to Mozilla, the <code>DOMContentLoaded</code> is fired <em class="italic">when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.</em></p>
			<p>The last two options are network-related. <code>networkidle0</code> will resolve the promise <em class="italic">when there are no more network connections for the past 500ms</em>. On the other hand, <code>networkidle2</code> will resolve the promise <em class="italic">when there are no more than 2 network connections for the past 500ms</em>.</p>
			<p>Which one is better? Generally <a id="_idIndexMarker151"/>speaking, the default is good enough and pretty safe. You might need to switch to the network ones if you have many <strong class="bold">AJAX</strong> calls after the <strong class="bold">DOM</strong> is loaded, and you want to wait for the page to stop loading data from the server. We will see more about this in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>.</p>
			<h3>What is an AJAX call?</h3>
			<p>AJAX calls became so popular that <a id="_idIndexMarker152"/>many developers stopped calling them AJAX calls. You might also hear this referred to as "calling an endpoint" or "calling a (REST) API."</p>
			<p>But, basically, it is an asynchronous call made to a server by the page to fetch more data or send data to the server. Don't worry, we'll go way deeper in <a href="B16113_05_Final_SK_ePub.xhtml#_idTextAnchor087"><em class="italic">Chapter 5</em></a>, <em class="italic">Waiting for elements and network calls</em>.</p>
			<h3>What is the DOM?</h3>
			<p>The <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) is the object representation that the browser built based on the HTML sent by the server or created in JavaScript. </p>
			<p>Remember that an HTML page is no<a id="_idIndexMarker153"/> more than a text file sent through the network. The browser loads that text, builds the model (DOM) representation, and then the browser engine renders that DOM. At that moment, the browser can say that <code>load</code> event.</p>
			<p>This takes us to the last option: the referrer.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Referrer</h2>
			<p>The referrer is an HTTP header that the<a id="_idIndexMarker154"/> browser sends to the server to inform it what page is requesting that resource.</p>
			<p>You can see that if you go to <a href="https://www.packtpub.com/">https://www.packtpub.com/</a>, open the developer tools, and check any CSS file under the network tab.</p>
			<div><div><img src="img/Figure_3.08_B16113.jpg" alt="Referrer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Referrer</p>
			<p>Fun fact, the HTTP header is called <code>referer</code> due to a typo in the HTTP specification.</p>
			<p>When would you use this? Well, this option is not so common, but some pages could change the behavior based on the referrer. Some sites might use them as a validation: <em class="italic">"This page only can be navigated when coming from this site."</em> You force that scenario using the <code>referer</code> option. </p>
			<p>Early in this section, we mentioned that other types of navigation were the browser functions to go back, forward, and reload. Puppeteer provides an API for all those actions:</p>
			<ul>
				<li><code>page.goBack(options)</code></li>
				<li><code>page.goForward(options)</code></li>
				<li><code>page.reload(options)</code></li>
			</ul>
			<p>These functions have the same behavior as <code>page.goto</code>. You don't need to pass a URL because it can be inferred from the action itself. <code>goBack</code> and <code>goForward</code> are based on the browsing history, and <code>reload</code> will use the same URL.</p>
			<p>Another difference is that they don't support the <code>referer</code> option because it will use the same referrer used in the first navigation because these actions are repeating navigation performed in the past.</p>
			<p>But that's not all; <code>goto</code> hides a nice surprise. Well, it's not hidden; it is documented. The next thing we need to know <a id="_idIndexMarker155"/>about <code>goto</code> is that it has a return value. It returns a <code>response</code> object.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Using the response object</h1>
			<p>The response is an important <a id="_idIndexMarker156"/>concept on the web. There is a corresponding <strong class="bold">response</strong> for every <strong class="bold">request</strong> the browser sends to the server.</p>
			<p>It makes sense that the <code>goto</code> returns a <code>response</code>. It makes a <code>request</code>, and the result is the corresponding <code>response</code>.</p>
			<p>There are many things we can do with the response. We won't cover all the functionality in this chapter. But these are the most relevant functions we can use as a response to a <code>goto</code> action.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Getting the response URL</h2>
			<p>Why would I want to<a id="_idIndexMarker157"/> know the URL if I know the URL I want to go to?</p>
			<p>The server could redirect you to another page. For instance, if you open the browser in incognito/private mode and navigate to <a href="https://mail.google.com/">https://mail.google.com/</a>, you will see that the server redirects you to <a href="https://accounts.google.com/signin">https://accounts.google.com/signin</a>. </p>
			<p>I'm not saying that you should always check the response URL just in case, but you have to know that the site you are testing might behave like that. One common scenario is the login check. You navigate to a page, and if the response URL is the login page, you perform the login action, and then you can go back to the previous page and resume your test.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Getting the response status code</h2>
			<p>Every response has an HTTP status <a id="_idIndexMarker158"/>code. It tells you how the server reacted to your request. Status codes are grouped into five categories. These are the definitions<a id="_idIndexMarker159"/> according to Wikipedia (<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>):</p>
			<p><strong class="bold">1xx informational response</strong>: <em class="italic"> the request was received, continuing process</em>. You won't need to deal with these.</p>
			<p><strong class="bold">2xx successful</strong>: <em class="italic">the request was successfully received, understood, and accepted.</em> There are some differences between all the 2xx codes, but what you have to know is that a 2xx code means that everything went well. The status code <strong class="bold">200</strong> is the most common. </p>
			<p><strong class="bold">3xx redirection</strong>: <em class="italic">further action needs to be taken in order to complete the request.</em></p>
			<p>When the server wants to redirect the user, that's not a server action but something that the browser needs to do. The server tells the browser: "You asked for <a href="https://mail.google.com/">https://mail.google.com/</a>, but you have to go to https://accounts.google.com/signin." The browser needs to take the new URL and perform another request.</p>
			<p>The most common status codes are <strong class="bold">301 – Permanent Redirect</strong> and <strong class="bold">302 –Temporary Redirect</strong>. <strong class="bold">301</strong> tells the browser that the old URL shouldn't be used anymore, and the browser should always use the new URL. <strong class="bold">302</strong> is the most commonly used. It tells the browser that it should temporarily go to the new URL. That's the case of the login scenario.</p>
			<p><strong class="bold">4xx client error</strong>: <em class="italic">the request contains bad syntax or cannot be fulfilled.</em></p>
			<p>4xx codes are known as <em class="italic">"it was your fault"</em> errors. There was something wrong with the request. The list of 4xx codes is huge. For these scenarios, the most common code that I think everybody<a id="_idIndexMarker160"/> knows is the world-famous <strong class="bold">404</strong>, which tells you that the resource was<strong class="bold"> not found</strong>. The other errors you might face are <strong class="bold">401 – Unauthorized</strong> and <strong class="bold">403 – Forbidden</strong>, which are related to security issues.</p>
			<p><strong class="bold">5xx server error</strong>: <em class="italic">the server failed to fulfill an apparently valid request.</em></p>
			<p>5xx codes are known as <em class="italic">"it was the server's fault"</em> errors. The most common is the <strong class="bold">500</strong>, which means that the server has failed. I hope you never see this, but if you try to scrape a site and you get a <strong class="bold">503</strong>, that means that the <strong class="bold">server is unavailable</strong>, which means that the server started to reject your requests or that you took the server down.</p>
			<p>The function <code>response.status()</code> will return the status code associated with the response.</p>
			<p>If you just want to know whether the response was successful, there is a shortcut for that: <code>response.ok()</code>. This function will return true if the status code is between 200 and 299.</p>
			<p>Let's test some of these features by implementing the following test: <em class="italic">"The admin page should redirect you to the login page"</em>. In the <code>test</code> directory you will find that we have an <code>admin.tests.js</code> file, where we can put our admin page tests. To test the redirection, we can do something like this:</p>
			<pre>it('Should redirect to the login page', async() =&gt; {
  const response = await pageModel.go();
  response.status().should.oneOf([200, 304]);
  response.url().should.contain('login');
});</pre>
			<p>The final status could be <code>response.url()</code> to get the URL of that response.</p>
			<p>What if I wanted to <a id="_idIndexMarker161"/>check that I was effectively redirected from the admin page?</p>
			<p>Well, that's trickier. We mentioned that every response is tied to a request. Puppeteer exposes that using the <code>response.request()</code> function. We won't get into the <code>request</code> object yet, but one thing you need to know now is that the request contains the list of all the redirections a request went through. Puppeteer represents them with the <code>redirectChain()</code> function. With this, we have the entire redirect map.</p>
			<div><div><img src="img/Figure_3.09_B16113.jpg" alt="Redirect chain&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Redirect chain</p>
			<p>It might sound <a id="_idIndexMarker162"/>complex, but you will get the idea once you start playing with it. The final code will look like this:</p>
			<pre>it('Should redirect to the login page', async() =&gt; {
  const response = await pageModel.go();
  response.status().should.equal(200);
  response.url().should.contain('login');
  response.request().redirectChain()[0].response().status().should.equal(302);
  response.request().redirectChain()[0].response().url().should.contain('admin');
});</pre>
			<p>We learned a lot about the <code>launch</code> function and navigation with Puppeteer. As I mentioned at the<a id="_idIndexMarker163"/> beginning of this chapter, I also want to share some tools to add to your toolbox. Let's talk about continuous integration.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Introduction to continuous integration</h1>
			<p>Wouldn't it be great if a tool would guarantee that not <a id="_idIndexMarker164"/>a single line of code would break the functionality you are testing?</p>
			<p>That's what <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) is about. CI is the practice of running test code before introducing a change into the code base. Atlassian wrote a great definition of CI (<a href="https://www.atlassian.com/continuous-delivery/continuous-integration">https://www.atlassian.com/continuous-delivery/continuous-integration</a>): <strong class="bold">Continuous integration</strong> (<strong class="bold">CI</strong>)<em class="italic"> is the practice of automating the integration of code changes from multiple contributors into a single software project. It's a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where builds and tests then run. Automated tools are used to assert the new code's correctness before integration.</em></p>
			<p>Let's review an ideal workflow:</p>
			<ol>
				<li value="1">We have our code base in a source control repository. It could be GitHub, Gitlab, Bitbucket, or a local server hosting a Git server.</li>
				<li>A developer creates a new branch from that main code base.</li>
				<li>We make some changes in that branch.</li>
				<li>And then, it creates a Pull Request or Merge Request. The developer requests that their changes are reviewed and incorporated into the main code base.</li>
				<li>Other developers will review the change, but the CI process will also run the tests on that branch.</li>
				<li>If the developers approve the change and the CI runs successfully, the code will be ready to be merged into the main code base.</li>
			</ol>
			<p>It sounds like an ideal world, right? Although life won't be that perfect all the time, we can achieve that. If you can implement this workflow when you start a new project, it will be easy to follow. Implementing all this in an ongoing project will be more challenging. My advice would be to make these changes little by little, not to affect productivity too much.</p>
			<p>There are many CIs available on<a id="_idIndexMarker165"/> the market. Most of them have an entry-level free tier and then some paid tiers. The main differences you will see between them are the following:</p>
			<ul>
				<li>Support for private repositories: Some CIs offer free tiers only for public repositories.</li>
				<li>The number of parallel runs: This will be quite important if you have quite a big team with many Pull Requests opened simultaneously.</li>
				<li>Compute power: They could give you better virtual machines on higher tiers.</li>
				<li>Reporting: You will find different types of reports.</li>
			</ul>
			<p>These are the most popular CIs in 2021; there are many others, but these are the ones you will see around:</p>
			<ul>
				<li>Travis CI</li>
				<li>Circle CI</li>
				<li>AppVeyor</li>
				<li>Jenkins</li>
				<li>GitHub Actions</li>
			</ul>
			<p>We will test our code using GitHub Actions, just because we would only need a GitHub account, and we can do everything from our repository.</p>
			<p>First, let's create a new <a id="_idIndexMarker166"/>repository on GitHub. If you don't have a GitHub account, you can create one at <a href="https://github.com/join">https://github.com/join</a>. Once you have an account, you can create a repository at https://github.com/new.</p>
			<div><div><img src="img/Figure_3.10_B16113.jpg" alt="Creating a new repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Creating a new repository</p>
			<p>One important<a id="_idIndexMarker167"/> thing here is to pick <code>.gitignore</code> template, so we don't commit the <code>node_modules</code> folder.</p>
			<p>Once you create the repository, you can get the Git URL using the <strong class="bold">Code</strong> button:</p>
			<div><div><img src="img/Figure_3.11_B16113.jpg" alt="Git remote URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Git remote URL</p>
			<p>We will now clone this Git repository into a new folder, copy our working code there, and <strong class="bold">push</strong> it to GitHub:</p>
			<pre>&gt; git clone https://github.com/kblok/ch3-demo.git
&gt; cd ch3-demo</pre>
			<p>Notice that you need to use <strong class="bold">your</strong> Git URL, not mine.</p>
			<p>Next, we need to<a id="_idIndexMarker168"/> copy our current code to that folder. Make sure you delete any extra <code>git</code> folders when you copy these projects. After that, we need to run these three commands to commit our code and push it to GitHub:</p>
			<pre>&gt; git add .
&gt; git commit -m "First commit"
&gt; git push origin</pre>
			<p>Now it's time to set up the CI. CI tasks in GitHub actions are YAML files inside the <code>. github/workflows</code> directory. This is what we need to do:</p>
			<ul>
				<li>Checkout the branch.</li>
				<li>Build the site.</li>
				<li>Build the tests package.</li>
				<li>Launch the site.</li>
				<li>Run tests.</li>
			</ul>
			<p>The following example doesn't pretend to be the canonical way to run Puppeteer tests in GitHub actions. There many different <a id="_idIndexMarker169"/>ways to implement this. Let's create a YAML file inside the <code>.github/workflows</code> directory called <code>test.yml</code> (you can pick any name). The file will look like this:</p>
			<pre>name: CI
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@master
    - name: Install Web Dependencies
      working-directory: ./vuejs-firebase-shopping-cart
      run: npm install
    - name: Install Test Dependencies
      env:
        PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: 'true'
      run: npm install
    - name: Run Site Test Code
      uses: mujo-code/puppeteer-headful@master
      env:
        TESTENV: 'CI'
        CI: 'true'
      with:
        args: sh ./.github/workflows/test.sh</pre>
			<ul>
				<li>First, we are saying when we want to run this action. Then, we are setting up this action to run on every <code>master</code> branch. But <a id="_idIndexMarker170"/>also, it will run on every <code>master</code> branch. This means that it will also run after the Pull Request is merged.</li>
				<li><code>- uses: actions/checkout@master</code> will check out our code.</li>
				<li>Under <code>- name: Install Web Dependencies</code>, we build the site.</li>
				<li>Under <code>- name: Install Test Dependencies</code>, we build the test project.</li>
				<li>Under <code>- name: Run Site Test Code</code>, we run the site and the tests using the shell file <code>test.sh</code>, which is as simple as this:<pre>cd ./vuejs-firebase-shopping-cart
npm run serve &amp; npx wait-on http://localhost:8080
cd ..
npm test</pre></li>
			</ul>
			<p>As you can see, I'm waiting for <code>npm run serve</code> to print an http://localhost:8080 before running the tests.</p>
			<p>You will find that we are using <code>uses: mujo-code/puppeteer-headful@master</code>. Running a browser in a VM can be challenging. These VMs have many restrictions. You will need to find recipes that can help you launch a browser in a VM.</p>
			<p>In this case, <code>mujo-code/puppeteer-headful</code> leaves us a browser ready to be used. That's why we use the environment variable <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: 'true'</code>, so when we run <code>npm install</code>, Puppeteer won't download a browser because we are going to use an existing one.</p>
			<p>As we're going to use an <a id="_idIndexMarker171"/>existing browser, and we are going to run this in a restricted environment, we will need a new set of launch options. That's why a set the environment variable <code>TESTENV: 'CI'</code>, and I added a new setting in the config file:</p>
			<pre>CI: {
        baseURL : 'http://localhost:8080/',
        username: 'admin@gmail.com',
        password: 'admin',
        launchOptions: { 
            executablePath: process.env.PUPPETEER_EXEC_PATH,
            headless: true,
            args: ['--no-sandbox'],
        },
        timeout: 5000,
    },</pre>
			<p>I'm setting as the executable path the environment variable <code>PUPPETEER_EXEC_PATH</code>, which is set by <code>mujo-code/puppeteer-headful</code>.</p>
			<p>After setting up all this, you will start getting builds in your pull requests. Let's say that a developer comes and creates a Pull Request changing a color.</p>
			<div><div><img src="img/Figure_3.12_B16113.jpg" alt="A Pull request changing a piece of code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A Pull request changing a piece of code</p>
			<p>If you go to the <strong class="bold">Checks</strong> tab, you will <a id="_idIndexMarker172"/>see all the actions and their status. In this case, we can see that our test runs correctly:</p>
			<div><div><img src="img/Figure_3.13_B16113.jpg" alt="Build result in Pull Requests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Build result in Pull Requests</p>
			<p>There, you will find<a id="_idIndexMarker173"/> all the build details, with all the test results. But these results also propagate to other pages on GitHub. You will be able to see the build results on the main page of the Pull Request and even in the Pull Requests list.</p>
			<div><div><img src="img/Figure_3.14_B16113.jpg" alt="Build result on the Pull Request main page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Build result on the Pull Request main page</p>
			<p>There, you are not going to see the full details, but it will give you a quick view so you can know whether the Pull Request is ready to be merged or not.</p>
			<p>I know that this<a id="_idIndexMarker174"/> might feel overwhelming. Take this as an idea about how that looks, what is possible, and the challenges you might find while setting up all this. It's not easy, but it is worth the effort.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Summary</h1>
			<p>As you can see, we started to go deeper into the Puppeteer API. We learned about all the different options we can use when launching a browser. We also learned how to navigate through a site and the different options we have to go from one page to another. We also saw new objects that weren't mentioned before, such as the <code>Response</code> and the <code>Request</code> class.</p>
			<p>I hope you found the continuous integration section valuable. There are many tools and many different ways to run tests automatically in the cloud. This is an essential tool to add to your toolbox.</p>
			<p>In the next chapter, we will get even more practical. We will see how to interact with the page, from CSS selectors to mouse and keyboard emulation.</p>
		</div>
	</body></html>