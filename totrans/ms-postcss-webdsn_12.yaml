- en: Chapter 12. Mixing Preprocessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we've explored using PostCSS, and seen how we can build
    a more efficient preprocessor that meets our needs, without the extra baggage
    of standard preprocessors. Hold on though—doesn't it take time to build a processor?
    How do we manage the transition?
  prefs: []
  type: TYPE_NORMAL
- en: No problem, enter the Pleeease library! Throughout this chapter, we'll use the
    power of Pleeease to combine both preprocessors and postprocessors into one process,
    mixing existing systems such as SASS, Less, and Stylus. Over the next few pages
    we take a look at some examples, and show you how easy it is to harness the power
    of Pleeease.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following technical topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the benefits of using the Pleeease library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring the library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring some of the features of Pleeease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling code using Node or the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a WordPress installation and testing the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start!
  prefs: []
  type: TYPE_NORMAL
- en: Taking the first steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a site, developers will nearly always have the opportunity to
    design and build it from the ground up; we can make decisions regarding the color
    scheme to use, the structure of the site, and its general appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, though, there will be occasions when we want to use a new technology,
    but have to use an existing site. A question on the minds of many in this position
    will likely be: where does one start? It will, of course, depend on many factors,
    of which one is likely to be whether existing processors such as SASS or Less
    are being used on the site.'
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility and power of PostCSS allows us to transition easily from the
    likes of Less or SASS to using PostCSS—throughout this chapter, we're going to
    go on a journey to explore some of the tricks we can use to begin that transition
    process. We'll explore some of the plugin options available, then finish with
    a look at converting a CMS system such as WordPress to using PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any reason why WordPress was chosen? It is compiled from SASS, but also uses
    PostCSS to handle vendor prefixes, we'll build on this with additional plugins
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin that journey, our first step is to explore some of the plugins we
    can use to begin that transition process from using SASS to PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the conversion process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cast your mind back to [Chapter 10](ch10.html "Chapter 10. Building a Custom
    Processor"), *Building a Custom Processor*, for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The key theme of that chapter was bringing together a number of plugins we covered
    throughout the preceding chapters, to create what would become our processor.
    So far, all of the plugins used were based around pure PostCSS, so they wouldn't
    be able to compile raw SASS code.
  prefs: []
  type: TYPE_NORMAL
- en: We took a brief look at the CSStyle library, as a possible means of getting
    around this—it's a great library for producing clean code using BEM principles,
    but it requires that code is written using a specific format. Ordinarily, there
    is nothing wrong with this at all—every developer's utopia should be to produce
    clean, efficient code, right?
  prefs: []
  type: TYPE_NORMAL
- en: Yet there is just one small problem, reality! It wouldn't be practical to rewrite
    a large, complex e-commerce site to use CSStyle without an enormous amount of
    work; it would require a lengthy transition period to effect such a change. It's
    not impossible, but using BEM-style notation is better done from ground up, or
    at least in defined chunks, if your site has multiple style sheets in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if using CSStyle isn''t a practical solution for our needs, how can we make
    that change? There is a more practical solution available to us—it may take longer,
    but the disruption should be reduced, and allow us to make smaller changes to
    our code in a more manageable transition process:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by introducing a task runner to compile existing processor code—plugins
    exist for using libraries such as SASS or Less within runners such as Gulp or
    Broccoli, to allow us to compile code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we've transitioned to using a task runner, we can then introduce plugins
    to handle core processes, such as managing vendor prefixes, creating source maps,
    and minifying our style sheets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then break down our existing style sheet into smaller chunks and import
    each into a master file during compilation. Each can then be converted to use
    PostCSS plugins that replicate existing processor functionality—for example, we
    might use `postcss-simple-vars` to create new variables to replace existing SASS-based
    examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter step in this process should be iterative, at least until everything
    has been converted, and allows us to remove any dependency on existing processors.
    We''ve used a fair number of Gulp task files to date, so we should be reasonably
    familiar with the basic use of one by now—here''s what a task file might look
    like, if we were using SASS and Gulp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the Gulp plugins for SASS and PostCSS—SASS code
    is compiled first, before vendor prefixes are added by PostCSS, and the code is
    minified into the final article.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of this process, though, mean that we can control the rate of conversion—we
    are not forced to have to convert everything in one go, and can be selective about
    what is converted at each point in the process. There will still be a dependency
    on an external library, but this is temporary; we can remove that dependency when
    everything has been converted to using PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing our plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming that we've made the transition process to using a task runner, then
    where do we go from here?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it''s time to choose the plugins we need to use, based on the functionality
    offered by our site. Some of the more useful plugins to get you started are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plugin | Purpose of plugin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| postcss-mixins | If your code contains SASS mixins, then this will be essential—the
    format is very similar, so changes can be made using a search and replace in your
    editor. The plugin is available from [https://github.com/postcss/postcss-mixins](https://github.com/postcss/postcss-mixins).
    |'
  prefs: []
  type: TYPE_TB
- en: '| postcss-nested | Nesting code in SASS is a key concept—the `postcss-nested`
    plugin from [https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)
    is a good choice for replicating this functionality within SASS.Coupled with this,
    the `postcss-nested-props` and `postcss-nested-vars` plugins can be used to unwrap
    any properties or variables that are in nested code. |'
  prefs: []
  type: TYPE_TB
- en: '| postcss-sassy-mixins | There are occasions when we might have blocks of reusable
    code; we can use mixins to help reduce the amount of code written in our style
    sheets.A key concept borrowed from SASS, this plugin replicates the same functionality,
    and allows us to easily convert from using SASS to PostCSS. The plugin source
    is available from [https://github.com/andyjansson/postcss-sassy-mixins](https://github.com/andyjansson/postcss-sassy-mixins).
    |'
  prefs: []
  type: TYPE_TB
- en: '| postcss-simple-extend | If we have styles that share common elements, then
    we can remove some of this duplication by extending existing styles. This is a
    common practice when using SASS; the postcss-simple-extend plugin from [https://github.com/davidtheclark/postcss-simple-extend](https://github.com/davidtheclark/postcss-simple-extend)
    is perfect for replicating this within PostCSS. |'
  prefs: []
  type: TYPE_TB
- en: Other plugins are available, depending on your needs. The majority of plugins
    available are for SASS, but that is simply due to its maturity; others will no
    doubt become available for processors such as Less or Stylus over time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a look at the PostCSS plugins catalog available from [http://postcss.parts](http://postcss.parts)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Adding single plugins is a perfectly acceptable option, but what if we're adding
    more than just a couple of plugins to mimic SASS code? There are two options that
    would be useful here, and which we've not covered in our list—using the PreCSS
    or Pleeease libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Pleeease library was designed to handle some of the more menial tasks that
    are a necessary evil when compiling our code. Although not all of the supported
    tasks will apply, there will be at least three that do—minifying code, adding
    vendor prefixes, and generating source maps.
  prefs: []
  type: TYPE_NORMAL
- en: In stark contrast, the PreCSS library is likely to be more useful, as it is
    a collection of plugins that emulate SASS features. The beauty, though, is that
    we only need to install one plugin to handle changes; PreCSS abstracts the manual
    conversion of PostCSS styles into valid CSS using a single interface. We will
    explore using it in more detail a little later on in this chapter, but for now,
    let's turn our attention to putting the Pleeease library through its paces.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Pleeease library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pleeease library, available from [http://pleeease.io/](http://pleeease.io/),
    is designed to simplify the use of preprocessors, and combine the benefits of
    using multiple tools in one library. It means we can configure it to any one of
    three processors, such as SASS, Less, or Stylus, in addition to PostCSS, when
    compiling our code. The compilation can also include all of the typical tasks
    we might otherwise have to do, such as generating source maps, adding vendor prefixes,
    and minifying the results.
  prefs: []
  type: TYPE_NORMAL
- en: The library is easy to install—in its simplest format, we can use a configuration
    file to compile at the command line. Alternatively, we can use any one of several
    plugins to hook into a task runner, such as Gulp or Grunt. Let's take a moment
    to explore this in more detail, beginning with installing and configuring the
    plugin for use.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the Pleeease library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pleeease library is based on Node.js; it is a cinch to install, either
    for use manually at the command line, or via a task runner such as Gulp. Let''s
    make a start on getting everything set up for use:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by installing the Pleeease library—for this, go ahead and fire up
    a Node.js command prompt session, then change the working folder to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `npm install -g pleeease-cli`, then press *Enter*—wait
    for Node to complete the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the Pleeease library is installed and configured for use from
    the command line—if Node complains of elements that need to be updated, then it
    may be necessary to run `npm update –g n` to bring your version up to date. If
    you are a Windows user, then there is a handy PowerShell script available at [https://github.com/felixrieseberg/npm-windows-upgrade](https://github.com/felixrieseberg/npm-windows-upgrade)
    to help with this process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may get a couple of warnings about deprecated modules for `graceful-fs`
    and `lodash`: these can be ignored for the purposes of the demo.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we did not encounter any issues with installing Pleeease (over and
    above some deprecation warnings, as already mentioned), then we are now ready
    to use Pleeease in anger. Over the next few pages, we will take a look at compiling
    manually as well as using Gulp as our favored task runner. Let's begin by exploring
    how easy it is to perform a basic compilation at the command line using a `.pleeeaserc`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this chapter, we will concentrate on using SASS; if your
    preference is to use Less, you can use the `gulp-less` plugin as an alternative.
    Likewise, if your desire is to use Stylus, then the `gulp-stylus` plugin will
    work equally well with Pleeease.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling code manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to compile code using the Pleeease library is with a `.pleeeaserc`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This resembles a (simplified) JSON file, and will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Looks pretty straightforward, doesn't it? We simply need to specify our source
    files (`in`), and what we should get (`out`). In this example, we've gone one
    step further, to specify the level of browser support needed—this is mainly to
    ensure that the right vendor prefixes have been applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setting uses the same configuration as Autoprefixer: we can equally pass
    it a valid query from the Browserslist query list at [https://github.com/ai/browserslist#queries](https://github.com/ai/browserslist#queries).'
  prefs: []
  type: TYPE_NORMAL
- en: This is a useful method for compiling if our requirements do not stretch to
    using a task runner, or we want to keep our processes simple. The only downside
    is that we can't tie in any other tasks that could be automated, such as renaming
    the compiled style sheet with a `.min.css` extension—for this, we will need to
    use a task runner such as Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do use a task runner, this opens up all kinds of possibilities, such
    as automating processes to resize images, renaming compiled style sheets, and
    checking our code for consistency. Before we do so, let''s just cover a useful
    tip—the Pleeease site includes an online playground (available at [http://pleeease.io/play/](http://pleeease.io/play/)).
    We can use this to help familiarize ourselves with using the library before committing
    ourselves to compiling code for a production site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling code manually](img/BO5194_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, enough chitchat: it''s time to get practical, so to speak! For some,
    compiling at the command line might be enough, but in this modern age of automation,
    why spend time performing manual processes that can easily be automated?'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling using a task runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already guessed by now, I'm a big fan of using Node.js—my task
    runner of choice is Gulp. It used to be Grunt, but there is something about Gulp
    that I find is easier to use—I'm not sure why! Anyway, either can be used with
    Pleeease, so if your preference isn't Gulp, then please feel free to alter the
    code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work through the steps needed to use Gulp to run our compilation process:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt session, then change the working folder to
    our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter these commands, pressing *Enter* after each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep the Node.js command prompt session open—we will need it shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Extract a copy of the `T65 – using gulp-pleeease` folder from the code download
    that accompanies this book to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `package.json` and `gulpfile.js` files to the root of our project area,
    then copy `example.css` from the `src` folder under `T65 – using gulp-pleeease`
    to the `src` folder at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert to the Node.js command prompt session, then at the prompt enter `gulp`
    and press *Enter*:![Compiling using a task runner](img/BO5194_12_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming compilation is successful, Gulp will produce the now familiar files
    within the `dest` folder at the root of our project area. If we take a look at
    the results, we should see that it has minified the file, added vendor prefixes,
    and converted the `blue` and `red` color attributes to their equivalent HEX values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put this technique to good use and create a simple web page as an example
    of how we can use Pleeease. When checking our Gulp file, we will see that we don't
    need to use half of the plugins we've used in previous exercises, as Pleeease
    adds that support from within its plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Building an example using Pleeease
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout many of the demos in this book, we've had to import a series of plugins
    to manage different tasks such as minifying code, or checking it for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing technically wrong with this approach, but it is inefficient—after
    all, why use six tools when one will suffice, so to speak? We've tried to maintain
    a one plugin—one job rule throughout the book, so why are we breaking with convention?
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about using Pleeease is that it already contains support for
    some of these tasks that would otherwise require separate plugins; this means
    we can remove some of the plugins referenced in the Gulp task file. Pleeease is
    simply a layer that abstracts support for six other plugins through one common
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put that to use in the form of compiling styles for a simple web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an example using Pleeease](img/B05194_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start, as always, by extracting a copy of the `TXX – creating a page using
    pleeease` folder from the code download that accompanies this book; save it to
    the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `css – completed version` folder, copy the `styles – pre compile.css`
    file to the `src` folder at the root of our project area; rename it `styles.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `gulpfile.js` and `package.json` files from the root of the `tutorial`
    folder to the root of the project area—these should replace any already present
    at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt session, then change the working folder to
    the project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, type `gulp` then press *Enter*—Pleeease will now go away and
    compile our code, and spit out valid style sheet files in the `dest` folder at
    the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once completed, copy the contents of the `dest` folder to the `css` folder within
    the `tutorial` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we try previewing the results of our work by double-clicking on `webpage.html`,
    we should see a web page appear, similar to the screenshot at the start of this
    demo. The real proof, though, is in the Gulp task file—in comparison to other
    examples we've created in earlier demos, we've managed to remove one task completely,
    and reduce the number of plugins referenced by over half!
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with other preprocessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yet there is one problem—so far, all of our work using Pleeease is PostCSS-based;
    what if we had been using a processor such as SASS as the basis for producing
    our code?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is where Pleeease falls down—although it does include support
    for SASS, Stylus, and Less, it is still very experimental. An example of where
    this causes an issue is in nesting; Pleeease has yet to support nesting when configured
    to use SASS. This reduces the appeal of using Pleeease—after all, one of the key
    reasons for using PostCSS is to remove any dependency on libraries such as SASS!
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this means using the `gulp-sass` plugin. This is a wrapper for
    the `libsass` library. To achieve this, we would add a task such as this to our
    Gulp task file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling with other preprocessors](img/BO5194_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using this method, we can pre-compile our SASS code to valid CSS before
    transforming it with PostCSS plugins. The trouble is, it seems an inefficient
    way to compile our code—there is a better alternative, in the form of the PreCSS
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PreCSS library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Okay…so why is it better, I hear you ask?*'
  prefs: []
  type: TYPE_NORMAL
- en: The simple answer to this is that we can compile SASS-like code directly without
    using an external library such as libsass. The distinction here, though, is that
    it works on SASS-*like* code, not direct SASS.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't an issue though—we can easily perform a search and replace using
    a text editor to make the minor formatting changes required to make it compatible
    for PreCSS. The library source is available at [https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss);
    the developer has even provided an online playground for our use, at [https://jonathantneal.github.io/precss/](https://jonathantneal.github.io/precss/),
    so that we can try out changes before committing to code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we''re going to break with convention—rather than produce a
    simple web page, let''s push the boat out and use a content management system
    such as WordPress. Why? Well, for two reasons: WordPress already uses both PostCSS
    and SASS—it makes perfect sense to continue using the same tools! On this basis,
    let''s dive in and take a look at using both in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a WordPress installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our existing examples have so far been based around single pages; many
    developers are likely to use content management systems such as WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we can apply many of the same principles we've used so far to styling
    WordPress—in fact, there are some plugins we can use that mimic SASS, which is
    used to create core style sheets for themes that come as part of each WordPress
    download. The theme we will use is Twenty Sixteen, which comes with current versions
    of WordPress downloaded since December 2015; it can also be downloaded from [https://wordpress.org/themes/twentysixteen/](https://wordpress.org/themes/twentysixteen/).
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this chapter, we're going to explore some of the tips and
    tricks we can use to incorporate PostCSS into a WordPress theme. A key point of
    note here, is that we've already covered some of the tasks that can be used—with
    care and planning, some can easily be reused when creating style sheets for CMS
    applications. We'll explore some of the tips and tricks we can use—although these
    will be geared towards the Twenty Sixteen theme, they can equally be used in other
    themes that are developed for WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This next example does assume a certain amount of knowledge of WordPress, and
    ideally some of the basics around using SASS or Less—I would recommend reading
    around these topics if you are new to either application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started. Our first task is to set up our environment, ready for use.
    Before we set up our environment, though, I would strongly recommend you have
    a copy of the code download for this chapter handy—much of what will be discussed
    will make reference to the code!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the best out of this chapter, we need to set up an installation of WordPress—for
    the uninitiated, there are two ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: We can install WordPress as a locally hosted application using a web server
    such as WAMPSever ([http://www.wampserver.com/en](http://www.wampserver.com/en))
    or Apache ([http://www.apachefriends.org](http://www.apachefriends.org)—if you
    are a Linux or Mac user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a version of WordPress installed on our own web space online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of this book, we will use the former—to get hold of WordPress,
    head over to [http://www.wordpress.org](http://www.wordpress.org) and hit the
    blue **Download WordPress** button on the right side of the screen (near the top).
  prefs: []
  type: TYPE_NORMAL
- en: I will assume our version of WordPress has been installed locally under `C:\wamp\www\wordpress`,
    using your local web server of choice, following the instructions available at
    [https://codex.wordpress.org/Installing_WordPress](https://codex.wordpress.org/Installing_WordPress).
    My preference is to use WAMPServer (available from [http://www.wampserver.com/en](http://www.wampserver.com/en)),
    but if you would like to use a different web server or folder, then please adjust
    the steps accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, with WordPress installed, configured, and ready to go, let's crack on.
    The next step is to take a look at the options available to us for beginning the
    transition process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The steps given throughout the remainder of this chapter will be geared towards
    Windows, as this is the platform normally used by the author; please adjust accordingly,
    if you use Linux or Mac devices.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the conversion process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where does one start, when working with an average WordPress style sheet, I
    hear you ask?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the first thing we should not do is be put off by its size. Yes, I know
    this might sound crazy (after all, the Twenty Sixteen theme weighs in at 3920
    lines!), but with some planning, we can easily break this into something more
    manageable.
  prefs: []
  type: TYPE_NORMAL
- en: If we only achieve one task with PostCSS, then that task must be to make use
    of the `postcss-import` plugin to help break our code into more manageable principles.
    If you happen to have used processors such as SASS or Less, then it's the same
    principle—in our master `style.css`, we can create a series of import statements,
    and hive off each block into separate files.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've broken the style sheet into more manageable chunks, there are a fair
    few things we can implement in our code; we should always consider it an iterative
    process, until such time as we exhaust all possible alternatives, the site is
    no longer required, or we migrate to a different solution. Over the next few pages,
    we'll cover some of the ideas and considerations that are likely to crop up—this
    should help get you started with making the changes to your theme. So without
    further ado, where do we start?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the obvious one is using Autoprefixer; WordPress makes good use of CSS3
    styles, of which a fair number still require vendor prefixes. A consideration
    here, though, is that as we will be working backwards from the original style
    sheet, we will need to strip out existing vendor prefixes and set our task runner
    to add these in automatically. It's a necessary evil of working with existing
    style sheets in WordPress, but at least we should only have to do it once! There
    may be a temptation to create a mixin to manage vendor prefixes, but this is not
    considered best practice—Autoprefixer will update styles at each compilation.
  prefs: []
  type: TYPE_NORMAL
- en: We're already familiar with using Autoprefixer from earlier examples—in the
    same vein, we can also consider minifying our code, which will help reduce bandwidth
    usage. Adding such a facility should be a cinch—we can use the same tasks from
    earlier demos, as long as we set the right order of tasks. We will need to alter
    it to compile `style.css` directly (this is the main file for WordPress style
    sheets), but as our processor will be geared towards using WordPress, this won't
    be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Another area we can look at is rem unit support, with pixel fallback. Many developers
    have their own views on using rem as a unit of measure; some say pixel values
    work just as well, but its suitability will depend on where it is being applied.
    This aside, Gulp has a suitable plugin we can use to help provide this functionality,
    if we need it.
  prefs: []
  type: TYPE_NORMAL
- en: One way to really make an impact on our code is to use nesting—this is a common
    technique for preprocessors such as SASS, and involves writing code in a nested
    format. The key benefit is to remove code that is duplicated—consider it a form
    of shorthand (in a manner of speaking), which will be transformed into valid CSS
    at compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful technique to also look at is the use of variables; these work in much
    the same way as scripting or programming languages. Now before you go running
    for the hills, don''t worry: they are easy to use. We need to provide a list of
    placeholder names, and the values they represent; we can then do a search and
    replace throughout our code for each value, and replace it with the appropriate
    variable. Why do this, I hear you ask? Well, it''s simple: if you change a color
    in the future, you only need to change it in one place; PostCSS will automatically
    change all other instances for you at the compilation stage.'
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to really get stuck into the core code for WordPress, then
    it's always worth exploring the code repository at [https://core.trac.wordpress.org/browser/trunk/](https://core.trac.wordpress.org/browser/trunk/).
    If you look carefully, you should even see where PostCSS is being used!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, enough chitchat: let''s get stuck into some code! The changes we will
    make as part of our next demo are just some of the ways in which we can incorporate
    the use of PostCSS plugins (or Gulp, for that matter), into our process. We''ll
    begin by exploring the changes we need to make, and follow this with some ideas
    for you to try out as part of using PostCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we've only covered a few ideas, there are nevertheless a fair few steps
    to go through; the key to this (and keeping your sanity!) is to complete each
    in blocks, and not all in one go.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of our changes will use existing tasks we've created in earlier demos;
    to this we will add the PreCSS library (from [https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss)),
    along with postcss-import and gulp-pixrem plugins. With this in mind, we'll make
    a start—our first task is to split the code into more manageable style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting our style sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The critical part of this process is to split our style sheet—for this, we
    will use the `postcss-import` plugin, from [https://github.com/postcss/postcss-import](https://github.com/postcss/postcss-import):'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start, as always, by firing up a Node.js command prompt, then changing
    the working folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Wait for Gulp to complete the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to split our style sheet into separate blocks; the most convenient
    way to do this is split it into sections according to the list at the top of `style.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `src` folder at the root of our project area, create a new folder called
    `css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and open up a copy of `style.css` from within the Twenty Sixteen folder—it's
    located at `C:\wamp\www\wordpress\wp-content\themes\twentysixteen\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this to the `src` folder at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On or around line 53, add this line: `@import "css/variables.css";`. Don''t
    worry for now what it will be for—this will become clear later in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find lines 54 to 252, then copy them to a new file—save this as `normalize.css`
    in the `css` folder within the root `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `style.css` file within the `src` folder, add these import statements,
    as indicated:![Splitting our style sheet](img/BO5194_12_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process until you have extracted all sections into their own files
    (1 to 15). Save them with the same names as each main section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note, when saving the files, you *don't* need to split sections 11 to 15 into
    their sub-sections—keep these within their respective files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have one last step to perform: we need our Gulp task file! From the code
    download that accompanies this book, go ahead and extract a copy of `gulpfile.js`
    and `package.json` from the `T68 - converting a WordPress theme` folder, then
    save both to the root of our project area.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a quick look at the `gulpfile.js` file, in particular, at lines 31 to 35:![Splitting
    our style sheet](img/BO5194_12_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how we are compiling directly to `style.css`, unlike previous exercises?
    It's not ideal, but as WordPress themes use `style.css` by default, this is something
    we can live with as part of our compilation process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for vendor prefixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next task is to install support for adding vendor prefixes—in a sense, we've
    already covered how to achieve this. Most, if not all, of our previous demos already
    include support for vendor prefixes, using the Autoprefixer plugin.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, Autoprefixer is available from [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer);
    there is an online version we can use to test changes at [https://autoprefixer.github.io/](https://autoprefixer.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the Gulp task file we downloaded in the previous example,
    we can see the autoprefixer plugin has been called as part of firing PostCSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding support for vendor prefixes](img/BO5194_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are, however, a couple of key points we should note at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: When using the Autoprefixer plugin, it uses data from the Can I Use site ([http://www.caniuse.com](http://www.caniuse.com))
    to update any vendor prefixes it finds that are out of date. It is worth spending
    time going through your style sheet to ensure that it does not already include
    vendor prefixes—if it does, these need to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: We can remove them manually, or a more effective route is to use the `postcss-remove-prefixes`
    plugin, available from [https://github.com/johnotander/postcss-remove-prefixes](https://github.com/johnotander/postcss-remove-prefixes).
    We can add it to our Gulp task file, or run it directly from the command line.
    The key here is to complete the removal first, so that Autoprefixer can then be
    used to manage vendor prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress already uses Autoprefixer to manage vendor prefixes—you can see evidence
    of it in the `Grunt` file at [https://core.trac.wordpress.org/browser/trunk/Gruntfile.js](https://core.trac.wordpress.org/browser/trunk/Gruntfile.js).
    Granted, it is using Grunt, but the process is very similar for those of you using
    Gulp or one of the other task runners available that are compatible with PostCSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding support for vendor prefixes](img/BO5194_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although setting up Autoprefixer in our Gulp task file is very easy—at least
    the basics—it will only be successful if we spend time removing any vendor prefixes
    that can then be added automatically at compilation. The `postcss-remove-prefixes`
    plugin will remove simple examples such as the following one, so that we are left
    with unprefixed versions that Autoprefixer can then update during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding support for vendor prefixes](img/BO5194_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final core task we should perform is to check our code for consistency—by
    now, this should be an all-too familiar task, as we've already set up a suitable
    task from earlier demos that can easily be reused for compiling WordPress themes.
    It's time to revisit this task. To ensure it works correctly, we will need to
    amend the settings slightly, so let's cover that now.
  prefs: []
  type: TYPE_NORMAL
- en: Checking our code for consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we take a look at the Gulp task file we saved at the start of these changes,
    we should see this configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking our code for consistency](img/BO5194_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A little further down is the task, there are two changes here: we''ve hardcoded
    the `destination` file, and the order which has been adjusted, to allow for the
    presence of the `pxrem` task. The indentation setting has also been changed within
    the configuration object—when compiled, the style sheet uses tabs for indentation.'
  prefs: []
  type: TYPE_NORMAL
- en: This will throw up a host of warnings, we can either manually alter 3000+ entries,
    or alter how the indentation is checked. Hopefully it's a no-brainer as to which
    we would prefer to do, at least in the short term!
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaving aside these two changes, the remainder of the linting task has not
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking our code for consistency](img/BO5194_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, let''s change tack: there is one more core task which we should run,
    which is to minify our code. We''ve already used it in a number of demos, but
    let''s take a moment to just revisit it within the context of compiling WordPress
    themes.'
  prefs: []
  type: TYPE_NORMAL
- en: Minifying our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we had to rank the top four key tasks that could be performed using PostCSS,
    then this next task should definitely be at the top of that list. Minifying our
    code is key to conserving bandwidth usage—WordPress themes are no lightweights!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Gulp file already has this built in: the `package.json` file will have
    the appropriate reference set. If we take a look at the task file in more detail,
    we should see something akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Minifying our code](img/BO5194_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looks familiar? It should—it's an almost direct copy of the existing task we've
    used from earlier demos. We've switched off `autoprefixer`, as this is being used
    elsewhere in our Gulp file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on. WordPress uses SASS as its main pre-processor; we could use the
    Pleeease library to compile both SASS and PostCSS code, but a cleaner option is
    to use the PreCSS library. This abstracts support for a number of plugins that
    emulate SASS code (but without the SASS baggage, so to speak). Let's dive in and
    take a look at this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key features of SASS (and other processors) is the ability to use
    variables as placeholders for values—these are transformed into valid CSS styles
    at compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why use them, I hear you ask? Simple, if you decide to change a font family,
    or color, do you want to wade through thousands of lines of code to update any
    instance where it has been used? I would hope the answer is no—and quite rightly
    so: we have better things to do! One of those, is to install the plugin that will
    add variable support in the form of PreCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already installed PreCSS from an earlier demo, so all that remains to
    do is to ensure it is added to our Gulp task file accordingly (it''s already in
    ours, and in the accompanying `package.json` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating variables](img/BO5194_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The real work comes in changing our style sheet—let''s take a look at what
    is required:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a file to store our variables—go ahead and create a
    blank file in the `css` subfolder under the `src` folder at the root of our project
    area, and label it `variables.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up the `variables.css` file. Go ahead and add these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file, if we take a look back at *Splitting our style sheet*, you will
    notice that we've already included a link to it from our master style sheet:![Creating
    variables](img/BO5194_12_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Values from this file will replace placeholders within our code, to produce
    valid CSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next task is a necessary evil, we have to work our way through each style
    sheet to be imported, and replace existing values with the variable equivalents.
    This screenshot shows a part example—here, the `font-family` value has been updated,
    but the `border` value has yet to be changed:![Creating variables](img/BO5194_12_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once each file has been changed, then save each, ready for the next exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no easy way to get around it, but altering WordPress theme style sheets
    can require lots of patience! The best way to manage it is to use your editor's
    search and replace function— editors such as Sublime Text 3 (the author's editor
    of preference) have a very useful facility to replace text in multiple files;
    making use of this will help reduce the manual effort required to update each
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for rem units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This next task is one that is likely to cause debate—altering our code to use
    rem units, with pixel fallback added automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers claim that pixel values work just as well; others say that
    it all depends on where you need to specify a value, as to which unit of measure
    to use. Either way, we can use PostCSS to add pixel fall-back support automatically.
    The source for this plugin is available from `https://github.com/gummesson/gulp-pixrem`.
    Let''s explore what is needed to add support for rem units:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Node.js command prompt session, or if the one from the previous session
    is still available, then revert to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the working folder is set to the root of our project folder, then
    at the prompt enter this command and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Gulp will go away and install the plugin—wait for it to complete before continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already have our Gulp task file in place—if we look at it in detail, we can
    see it being called at line 39:![Adding support for rem units](img/BO5194_12_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we have everything in place - the next task is to work our way
    through the various style sheets that we've created, and replace any instance
    of pixel values with rem equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: This is a thankless but necessary task—the plugin works by adding pixel fallback
    values for any instances of rem units that it finds within our code. It is up
    to us to do as much or as little as we want, in terms of changing values—it is
    worth making some changes to ensure that the code compiles, but the remaining
    changes can be done over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When compiling the code, we will end up with code similar to this example—this
    extract comes from the Widgets section (section 10):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding support for rem units](img/BO5194_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's easy to simply convert our style sheet to use pixel fallback support—the
    key here is that we need to decide where we want to be using rem unit support,
    and where existing values such as pixels or em units would be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, there are two more tasks we can set up as part of our compilation
    process—how about mimicking the ability to nest styles from SASS, or creating
    mini loops to automate generating certain styles? Don't worry if this is not something
    that you're familiar with—let's dive in and see what these mean in action.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting rules in our style sheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nesting of styles is a common feature when using processors such as SASS—if
    we have a bunch of styles that have very similar selectors, then it creates a
    degree of unwanted duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could stick with this duplication, but a more sensible option is to take
    the core part of the selector, then nest descendants within that block—this example
    is taken from the `typography.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nesting rules in our style sheet](img/BO5194_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea is to avoid having to write the same duplicated parent styles—we can
    concentrate on the children instead! While the code may look longer, it is definitely
    easier to read; we can group together styles that have a common parent.
  prefs: []
  type: TYPE_NORMAL
- en: The technique is easy to pick up, but can be deceptively hard to get right;
    if you are not familiar with it, then I would recommend taking a look at my two
    books on SASS *SASS Essentials* and *SASS CSS How-to*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once compiled, the code will appear as normal CSS. There''s one thing to note,
    though: resist the temptation to nest everything; nesting is really best kept
    to where you can see a real difference in the amount of code used!'
  prefs: []
  type: TYPE_NORMAL
- en: Looping through styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more change we can make to our code—take a look at the `media.css`
    file that we created earlier in this chapter, in particular around lines 158 to
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping through styles](img/BO5194_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I can already hear the next questions coming, what is that meant to be, and
    why are we using what looks like a programming loop in our code? In this instance,
    we're borrowing a principle from SASS, namely creating loops; this, coupled with
    string interpolation allows us to create the rules automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: String interpolation is creating a placeholder in our code, which will be transformed
    with values at compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the code is compiled, this is how the code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looping through styles](img/BO5194_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's a more advanced principle to grasp, but certainly one worth spending time
    getting up to speed—if applied correctly, it can save a lot of time with creating
    styles!
  prefs: []
  type: TYPE_NORMAL
- en: Let's change tack at this point—we've covered a number of concepts that will
    help get you started; there are a few more ideas that we can follow up at a later
    date, once the basics are in place. Let's take a moment to consider these in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Considering future possible ideas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the last few pages, we've covered a number of areas where PostCSS can be
    used to help better manage our WordPress style sheets. It's important to bear
    in mind that there are no hard and fast rules on what should be used, but that
    each style sheet will have its own requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options we''ve covered only scratch the surface of what is possible—for
    those of you who are familiar with SASS, you may well be asking why we didn''t
    use SASS mixins, for example. The simple reason is that there is nothing stopping
    us from doing so: it was all about providing options that give us a quick and
    easy win at the conversion stage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pause for a moment and consider some other ideas that will help get
    you started on updating our style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding mixins**: This is the obvious choice, but one that needs planning;
    this will be all about creating blocks of code that can be reused at will throughout
    our code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color fallback**: Although not part of the PreCSS package we''ve been using
    to date, color fallback is another option to consider. The core WordPress themes
    use standard HEX notation; we can update it to use RGB equivalents and use a PostCSS
    plugin to add in HEX values. If we prefer, we can even use a plugin such as postcss-rgba-hex
    to convert from using RGBA colors to plain HEX—you may prefer working with the
    former, or have processes that require the use of the former format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Font support**: How about incorporating the font-magician plugin for PostCSS?
    If we look at the `variables` file created earlier, it will contain a number of
    fonts that are not standard (at least to Windows); it means that our WordPress
    theme will look a little plain, to say the least! Fortunately, we can use the
    font-magician plugin to provide font-face support for the non-standard fonts;
    most, such as Inconsolata, Open Sans, and Merriweather, are available from the
    Font Squirrel website at [http://www.fontsquirrel.com](http://www.fontsquirrel.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've picked on just three ways to help extend your theme—with the use of a
    task runner such as Gulp, we are really only limited by the extent of what is
    available as plugins for Gulp. We don't have to limit ourselves to PostCSS plugins
    only; this will restrict what we can do, and mean that we're missing out on useful
    functionality. The key here is to consider what changes you want to make, and
    plan how and when you will make them—the process should be iterative, which will
    help with managing the changes!
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing the changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last few pages, we've covered a number of key tasks that would be perfect
    for compiling WordPress themes.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, we would automate as much as possible, or at least tasks
    where it would make sense—to remove tasks that give little value when done manually,
    for example. The key, though, is to give plenty of thought as to which order these
    tasks should be carried out; getting the order right can be the difference between
    receiving a valid style sheet file ready for use, and getting…well, what can only
    be classed as rubbish! Yes, that might seem a little extreme, but if the task
    order isn't right, then you can get compiled files that break your theme.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving this aside, let's take a look at compiling our code—for the purposes
    of this exercise, we will use a copy of the pre-edited files that are available
    in the code download that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before continuing, you may like to save copies of the source files you've created
    in the `src` folder that sits at the root of our project area, for safe keeping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a feel for what we will be discussing, this is a screenshot excerpt
    of the Twenty Sixteen theme in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling and testing the changes](img/BO5194_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by downloading and extracting a copy of the `src` folder that is
    under `T68 - converting a WordPress theme` in the code download; save this to
    the root of our project area. Make sure there are *no* other files present in
    this folder first!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, make sure that the `gulpfile.js` and `package.json` files that we downloaded
    earlier are still present—we will need both during compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and fire up a Node.js command prompt session, then change the working
    folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `gulp` then press *Enter*; Gulp will run through each task
    and spit out a compiled theme file in the `dest` folder at the root of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy this to the root of the `Twenty Sixteen` folder, which can be found at
    `C:\wamp\www\wordpress\wp-content\themes\twentysixteen`—if you use Linux or OSX,
    then please alter the path accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have a fully compiled style sheet! There are some points of note though—for
    example, the order of tasks that we covered earlier in this section doesn''t match
    the order shown in the `gulpfile.js` file. Let''s cover these points now:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of tasks you include can be split into two groups—those that I would
    describe as core, such as minifying files or providing source maps; these can
    be done for any sites. The second ones are custom tasks—these will be specific
    for each site, and might include requests to compile variables or nested code.
    It's up to you to plan how these are created, so that you can reuse them for future
    projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no right or wrong answer as to what should be included in a Gulp task
    file; the tasks you want to include, and the order they are called, will ultimately
    be determined by your own requirements. In our example, we used this order, from
    top to bottom:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Name of task | Purpose |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `styles` | This compiled the raw code—merging the rules into one file, running
    PreCSS through the code, and updating vendor prefixes where needed. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `pxrem` | With the base code in place, we can now run through it and add
    pixel fallback for rem units, where appropriate. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `lint` | In this task, we''re checking the compiled code for consistency.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `rename` | We then rename our base compiled file to have a `.min.css` extension;
    this is in preparation for minifying our code. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `sourcemap` | At this stage, we want to produce a source map, so this task
    kicks in to create a suitable map file for us. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `minifyCSS` | The final task is to minify the CSS style sheet file—it already
    has the right extension in place. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: We've done the hard work—it's time to see the fruits of our labor in action.
    The style sheet is now in the `theme` folder within our WordPress installation—all
    that remains is to test it! We could get into using automated testing facilities
    such as Quixote (available from [http://www.quixote-css.com/](http://www.quixote-css.com/)),
    but this would fall outside of the scope of this book. Instead, we can simply
    launch our local WordPress installation and check to see what it looks like—this
    is a useful way to gauge if there is anything amiss with our theme.
  prefs: []
  type: TYPE_NORMAL
- en: For our demo, we used the Twenty Sixteen theme. Out of the box, this is a very
    bare theme. Although this may not seem much, we've done most of the hard work
    needed to implement a PostCSS workflow when working with WordPress. A key measure
    of success is that the base theme should be identical to the original version
    that came with WordPress. If this is the case, it then means we can now concentrate
    on manipulating our style sheet over a period of time to further develop the styles
    within this (or any other) theme.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of using PostCSS will be partially determined by how well your code
    comes across from existing processors such as SASS—this will come from planning
    and taking an iterative approach to converting code. We've covered a lot of tips
    and ideas to help with the process, so let's take a moment to review what we've
    learnt.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with a look at exploring the conversion process, and covered some
    of the plugins we might use to help with the process. We then moved on to covering
    the Pleeease library, with a look at installing and configuring it before using
    it in a quick demo.
  prefs: []
  type: TYPE_NORMAL
- en: Next up came a quick discussion about why Pleeease may not be as useful as we
    first thought; we then covered using the PreCSS library as a better alternative
    for transitioning to PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored using PreCSS in some depth by working through making changes
    to a standard theme for WordPress—we discovered some of the tips and tricks we
    can use to score quick wins when making the initial changes. We then rounded out
    the chapter with a look at compiling our code, and checking it in a standard WordPress
    installation to ensure it is still working as we would expect to see it operating.
  prefs: []
  type: TYPE_NORMAL
- en: Phew, we've covered a lot! With careful planning and using an iterative approach,
    we can transition from using processors such as SASS, and move to using PostCSS.
    However, sometimes our code may not work as expected—there are a few places where
    our code may trip up, so we'll cover them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
