- en: Chapter 12. Mixing Preprocessors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。混合预处理器
- en: Throughout the book, we've explored using PostCSS, and seen how we can build
    a more efficient preprocessor that meets our needs, without the extra baggage
    of standard preprocessors. Hold on though—doesn't it take time to build a processor?
    How do we manage the transition?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们探讨了使用PostCSS，并看到了我们如何构建一个更高效的满足我们需求的预处理器，而不需要标准预处理器带来的额外负担。但是等等——构建处理器不是需要时间吗？我们如何管理过渡？
- en: No problem, enter the Pleeease library! Throughout this chapter, we'll use the
    power of Pleeease to combine both preprocessors and postprocessors into one process,
    mixing existing systems such as SASS, Less, and Stylus. Over the next few pages
    we take a look at some examples, and show you how easy it is to harness the power
    of Pleeease.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题，进入Pleeease库！在本章中，我们将利用Pleeease的力量将预处理器和后处理器结合成一个过程，混合现有的系统如SASS、Less和Stylus。在接下来的几页中，我们将查看一些示例，并展示如何轻松地利用Pleeease的力量。
- en: 'This chapter will cover the following technical topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下技术主题：
- en: Examining the benefits of using the Pleeease library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查使用Pleeease库的好处
- en: Installing and configuring the library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置库
- en: Exploring some of the features of Pleeease
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Pleeease的一些功能
- en: Compiling code using Node or the command line
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node或命令行编译代码
- en: Setting up a configuration file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置配置文件
- en: Converting a WordPress installation and testing the results
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换WordPress安装并测试结果
- en: Let's make a start!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Taking the first steps
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始第一步
- en: When developing a site, developers will nearly always have the opportunity to
    design and build it from the ground up; we can make decisions regarding the color
    scheme to use, the structure of the site, and its general appearance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网站时，开发者几乎总是有机会从头开始设计和构建它；我们可以做出有关要使用的配色方案、网站结构和外观的一般外观的决定。
- en: 'Sometimes, though, there will be occasions when we want to use a new technology,
    but have to use an existing site. A question on the minds of many in this position
    will likely be: where does one start? It will, of course, depend on many factors,
    of which one is likely to be whether existing processors such as SASS or Less
    are being used on the site.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，尽管如此，我们可能会想要使用新技术，但不得不使用现有的网站。处于这种位置的大多数人的心中可能会提出一个问题：从哪里开始？当然，这将取决于许多因素，其中之一可能是网站上是否正在使用现有的处理器，如SASS或Less。
- en: The flexibility and power of PostCSS allows us to transition easily from the
    likes of Less or SASS to using PostCSS—throughout this chapter, we're going to
    go on a journey to explore some of the tricks we can use to begin that transition
    process. We'll explore some of the plugin options available, then finish with
    a look at converting a CMS system such as WordPress to using PostCSS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PostCSS的灵活性和强大功能使我们能够轻松地从Less或SASS等过渡到使用PostCSS——在本章中，我们将继续探索我们可以用来开始这个转换过程的技巧。我们将探索一些可用的插件选项，然后结束于将CMS系统如WordPress转换为使用PostCSS的转换过程。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any reason why WordPress was chosen? It is compiled from SASS, but also uses
    PostCSS to handle vendor prefixes, we'll build on this with additional plugins
    later in the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么原因选择WordPress吗？它是用SASS编译的，但也使用PostCSS来处理供应商前缀，我们将在本章后面通过额外的插件在此基础上进行构建。
- en: Let's begin that journey, our first step is to explore some of the plugins we
    can use to begin that transition process from using SASS to PostCSS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段旅程，我们的第一步是探索一些可以帮助我们从使用SASS过渡到PostCSS的插件。
- en: Exploring the conversion process
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索转换过程
- en: Cast your mind back to [Chapter 10](ch10.html "Chapter 10. Building a Custom
    Processor"), *Building a Custom Processor*, for a moment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时回顾一下[第10章](ch10.html "第10章。构建自定义处理器")，*构建自定义处理器*。
- en: The key theme of that chapter was bringing together a number of plugins we covered
    throughout the preceding chapters, to create what would become our processor.
    So far, all of the plugins used were based around pure PostCSS, so they wouldn't
    be able to compile raw SASS code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那一章的关键主题是将我们在前几章中介绍的一些插件整合在一起，以创建我们将会使用的处理器。到目前为止，我们使用的所有插件都是基于纯PostCSS的，因此它们无法编译原始的SASS代码。
- en: We took a brief look at the CSStyle library, as a possible means of getting
    around this—it's a great library for producing clean code using BEM principles,
    but it requires that code is written using a specific format. Ordinarily, there
    is nothing wrong with this at all—every developer's utopia should be to produce
    clean, efficient code, right?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地看了看 CSStyle 库，作为绕过这个问题的可能方法——这是一个使用 BEM 原则生成干净代码的出色库，但它要求代码使用特定的格式。通常，这根本没有任何问题——每个开发者的乌托邦应该是生成干净、高效的代码，对吧？
- en: Yet there is just one small problem, reality! It wouldn't be practical to rewrite
    a large, complex e-commerce site to use CSStyle without an enormous amount of
    work; it would require a lengthy transition period to effect such a change. It's
    not impossible, but using BEM-style notation is better done from ground up, or
    at least in defined chunks, if your site has multiple style sheets in use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个小问题，现实！在没有进行大量工作的前提下，重写一个大型、复杂的电子商务网站以使用 CSStyle 是不切实际的；这将需要一个漫长的过渡期来实现这样的变化。虽然不是不可能，但如果你网站上有多个样式表在使用，使用
    BEM 风格的注释最好是从头开始，或者至少在定义的块中进行。
- en: 'So if using CSStyle isn''t a practical solution for our needs, how can we make
    that change? There is a more practical solution available to us—it may take longer,
    but the disruption should be reduced, and allow us to make smaller changes to
    our code in a more manageable transition process:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们使用 CSStyle 对我们的需求来说不是一个实际的解决方案，我们如何实现这个变化？有一个更实际的解决方案可供我们选择——这可能需要更长的时间，但破坏应该会减少，并允许我们在更可管理的过渡过程中对代码进行更小的更改：
- en: We start by introducing a task runner to compile existing processor code—plugins
    exist for using libraries such as SASS or Less within runners such as Gulp or
    Broccoli, to allow us to compile code.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先引入一个任务运行器来编译现有的处理器代码——存在插件可以在 Gulp 或 Broccoli 等运行器中使用库，如 SASS 或 Less，以允许我们编译代码。
- en: Once we've transitioned to using a task runner, we can then introduce plugins
    to handle core processes, such as managing vendor prefixes, creating source maps,
    and minifying our style sheets.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们过渡到使用任务运行器，我们就可以引入插件来处理核心过程，例如管理供应商前缀、创建源映射以及压缩我们的样式表。
- en: We can then break down our existing style sheet into smaller chunks and import
    each into a master file during compilation. Each can then be converted to use
    PostCSS plugins that replicate existing processor functionality—for example, we
    might use `postcss-simple-vars` to create new variables to replace existing SASS-based
    examples.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以将现有的样式表分解成更小的块，并在编译期间将每个块导入到主文件中。每个块都可以转换为使用 PostCSS 插件来复制现有处理器功能——例如，我们可能会使用
    `postcss-simple-vars` 来创建新的变量来替换现有的基于 SASS 的示例。
- en: 'The latter step in this process should be iterative, at least until everything
    has been converted, and allows us to remove any dependency on existing processors.
    We''ve used a fair number of Gulp task files to date, so we should be reasonably
    familiar with the basic use of one by now—here''s what a task file might look
    like, if we were using SASS and Gulp:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程的最后一步应该是迭代的，至少直到所有内容都已被转换，并且允许我们消除对现有处理器的任何依赖。到目前为止，我们已经使用了相当数量的 Gulp 任务文件，因此我们应该已经对其中一个的基本使用相当熟悉了——如果我们使用
    SASS 和 Gulp，一个任务文件可能看起来是这样的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we're using the Gulp plugins for SASS and PostCSS—SASS code
    is compiled first, before vendor prefixes are added by PostCSS, and the code is
    minified into the final article.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是 Gulp 插件用于 SASS 和 PostCSS——SASS 代码首先被编译，然后由 PostCSS 添加供应商前缀，代码被压缩成最终的文档。
- en: The benefits of this process, though, mean that we can control the rate of conversion—we
    are not forced to have to convert everything in one go, and can be selective about
    what is converted at each point in the process. There will still be a dependency
    on an external library, but this is temporary; we can remove that dependency when
    everything has been converted to using PostCSS.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的优点意味着我们可以控制转换的速度——我们不必一次性转换所有内容，并且可以在过程的每个点上选择性地转换内容。仍然会对外部库有依赖，但这是临时的；当所有内容都转换为使用
    PostCSS 时，我们可以消除这个依赖。
- en: Choosing our plugins
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择我们的插件
- en: Assuming that we've made the transition process to using a task runner, then
    where do we go from here?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经过渡到使用任务运行器，那么接下来我们该做什么呢？
- en: 'Well, it''s time to choose the plugins we need to use, based on the functionality
    offered by our site. Some of the more useful plugins to get you started are as
    follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是时候选择我们需要的插件了，基于我们网站提供的功能。以下是一些有用的插件，可以帮助你开始：
- en: '| Plugin | Purpose of plugin |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 插件 | 插件用途 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| postcss-mixins | If your code contains SASS mixins, then this will be essential—the
    format is very similar, so changes can be made using a search and replace in your
    editor. The plugin is available from [https://github.com/postcss/postcss-mixins](https://github.com/postcss/postcss-mixins).
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| postcss-mixins | 如果您的代码包含SASS混入（mixins），那么这将变得至关重要——格式非常相似，因此您可以使用编辑器中的搜索和替换来做出更改。该插件可在[https://github.com/postcss/postcss-mixins](https://github.com/postcss/postcss-mixins)获取。|'
- en: '| postcss-nested | Nesting code in SASS is a key concept—the `postcss-nested`
    plugin from [https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)
    is a good choice for replicating this functionality within SASS.Coupled with this,
    the `postcss-nested-props` and `postcss-nested-vars` plugins can be used to unwrap
    any properties or variables that are in nested code. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| postcss-nested | 在SASS中嵌套代码是一个关键概念——来自[https://github.com/postcss/postcss-nested](https://github.com/postcss/postcss-nested)的`postcss-nested`插件是复制这一功能在SASS中的好选择。与此相结合，`postcss-nested-props`和`postcss-nested-vars`插件可以用来展开嵌套代码中的任何属性或变量。|'
- en: '| postcss-sassy-mixins | There are occasions when we might have blocks of reusable
    code; we can use mixins to help reduce the amount of code written in our style
    sheets.A key concept borrowed from SASS, this plugin replicates the same functionality,
    and allows us to easily convert from using SASS to PostCSS. The plugin source
    is available from [https://github.com/andyjansson/postcss-sassy-mixins](https://github.com/andyjansson/postcss-sassy-mixins).
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| postcss-sassy-mixins | 有时候我们可能会有一些可重用的代码块；我们可以使用混入（mixins）来帮助减少样式表中编写的代码量。这是从SASS借用的一个关键概念，这个插件复制了相同的功能，并允许我们轻松地将使用SASS转换为PostCSS。插件源代码可在[https://github.com/andyjansson/postcss-sassy-mixins](https://github.com/andyjansson/postcss-sassy-mixins)获取。|'
- en: '| postcss-simple-extend | If we have styles that share common elements, then
    we can remove some of this duplication by extending existing styles. This is a
    common practice when using SASS; the postcss-simple-extend plugin from [https://github.com/davidtheclark/postcss-simple-extend](https://github.com/davidtheclark/postcss-simple-extend)
    is perfect for replicating this within PostCSS. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| postcss-simple-extend | 如果我们有共享公共元素的风格，那么我们可以通过扩展现有风格来减少一些这种重复。这是使用SASS时的常见做法；来自[https://github.com/davidtheclark/postcss-simple-extend](https://github.com/davidtheclark/postcss-simple-extend)的postcss-simple-extend插件非常适合在PostCSS中复制这一功能。|'
- en: Other plugins are available, depending on your needs. The majority of plugins
    available are for SASS, but that is simply due to its maturity; others will no
    doubt become available for processors such as Less or Stylus over time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 其他插件可供选择，具体取决于您的需求。大多数可用的插件都是针对SASS的，但这仅仅是因为它的成熟度；随着时间的推移，其他针对Less或Stylus等处理器的插件无疑也会变得可用。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take a look at the PostCSS plugins catalog available from [http://postcss.parts](http://postcss.parts)
    for more details.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看来自[http://postcss.parts](http://postcss.parts)的PostCSS插件目录以获取更多详细信息。
- en: Adding single plugins is a perfectly acceptable option, but what if we're adding
    more than just a couple of plugins to mimic SASS code? There are two options that
    would be useful here, and which we've not covered in our list—using the PreCSS
    or Pleeease libraries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 添加单个插件是一个完全可接受的选择，但如果我们添加的不仅仅是几个插件来模拟SASS代码呢？这里有两个有用的选项，而且我们还没有在我们的列表中涵盖——使用PreCSS或Pleeease库。
- en: The Pleeease library was designed to handle some of the more menial tasks that
    are a necessary evil when compiling our code. Although not all of the supported
    tasks will apply, there will be at least three that do—minifying code, adding
    vendor prefixes, and generating source maps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Pleeease库被设计用来处理在编译我们的代码时一些必要的繁琐任务。尽管并非所有支持的任务都适用，但至少会有三个任务适用——代码压缩、添加供应商前缀和生成源映射。
- en: In stark contrast, the PreCSS library is likely to be more useful, as it is
    a collection of plugins that emulate SASS features. The beauty, though, is that
    we only need to install one plugin to handle changes; PreCSS abstracts the manual
    conversion of PostCSS styles into valid CSS using a single interface. We will
    explore using it in more detail a little later on in this chapter, but for now,
    let's turn our attention to putting the Pleeease library through its paces.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与之形成鲜明对比的是，PreCSS库可能更有用，因为它是一组模拟SASS功能的插件。然而，美中不足的是，我们只需要安装一个插件来处理更改；PreCSS通过单个接口将PostCSS风格的手动转换抽象为有效的CSS。我们将在本章稍后更详细地探讨它的使用，但现在，让我们将注意力转向测试Pleeease库。
- en: Introducing the Pleeease library
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Pleeease库
- en: The Pleeease library, available from [http://pleeease.io/](http://pleeease.io/),
    is designed to simplify the use of preprocessors, and combine the benefits of
    using multiple tools in one library. It means we can configure it to any one of
    three processors, such as SASS, Less, or Stylus, in addition to PostCSS, when
    compiling our code. The compilation can also include all of the typical tasks
    we might otherwise have to do, such as generating source maps, adding vendor prefixes,
    and minifying the results.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可从 [http://pleeease.io/](http://pleeease.io/) 获取的 Pleeease 库旨在简化预处理器使用，并结合使用多个工具的优点在一个库中。这意味着我们可以将其配置为三个处理器之一，如
    SASS、Less 或 Stylus，以及 PostCSS，在编译我们的代码时。编译还可以包括我们可能必须执行的典型任务，例如生成源映射、添加供应商前缀和最小化结果。
- en: The library is easy to install—in its simplest format, we can use a configuration
    file to compile at the command line. Alternatively, we can use any one of several
    plugins to hook into a task runner, such as Gulp or Grunt. Let's take a moment
    to explore this in more detail, beginning with installing and configuring the
    plugin for use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆安装简单——在其最简单的格式中，我们可以使用配置文件在命令行中进行编译。或者，我们可以使用几个插件中的任何一个来连接到任务运行器，例如 Gulp
    或 Grunt。让我们花点时间更详细地探讨这个问题，从安装和配置插件以供使用开始。
- en: Installing and configuring the Pleeease library
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Pleeease 库
- en: 'The Pleeease library is based on Node.js; it is a cinch to install, either
    for use manually at the command line, or via a task runner such as Gulp. Let''s
    make a start on getting everything set up for use:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Pleeease 库基于 Node.js；它易于安装，无论是手动在命令行使用，还是通过 Gulp 这样的任务运行器。让我们开始设置一切以供使用：
- en: We'll begin by installing the Pleeease library—for this, go ahead and fire up
    a Node.js command prompt session, then change the working folder to our project
    area.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始安装 Pleeease 库——为此，请启动一个 Node.js 命令提示符会话，然后更改工作文件夹到我们的项目区域。
- en: At the prompt, enter `npm install -g pleeease-cli`, then press *Enter*—wait
    for Node to complete the installation.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入 `npm install -g pleeease-cli`，然后按 *Enter* 键——等待 Node 完成安装。
- en: At this point, the Pleeease library is installed and configured for use from
    the command line—if Node complains of elements that need to be updated, then it
    may be necessary to run `npm update –g n` to bring your version up to date. If
    you are a Windows user, then there is a handy PowerShell script available at [https://github.com/felixrieseberg/npm-windows-upgrade](https://github.com/felixrieseberg/npm-windows-upgrade)
    to help with this process.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Pleeease 库已经安装并配置好，可以从命令行使用。如果 Node 抱怨需要更新的元素，那么可能需要运行 `npm update –g
    n` 来更新你的版本。如果你是 Windows 用户，那么有一个方便的 PowerShell 脚本可以在 [https://github.com/felixrieseberg/npm-windows-upgrade](https://github.com/felixrieseberg/npm-windows-upgrade)
    上找到，以帮助完成这个过程。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may get a couple of warnings about deprecated modules for `graceful-fs`
    and `lodash`: these can be ignored for the purposes of the demo.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到关于 `graceful-fs` 和 `lodash` 弃用模块的几个警告：对于演示目的，可以忽略这些警告。
- en: Assuming we did not encounter any issues with installing Pleeease (over and
    above some deprecation warnings, as already mentioned), then we are now ready
    to use Pleeease in anger. Over the next few pages, we will take a look at compiling
    manually as well as using Gulp as our favored task runner. Let's begin by exploring
    how easy it is to perform a basic compilation at the command line using a `.pleeeaserc`
    file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在安装 Pleeease（除了已经提到的某些弃用警告之外）时没有遇到任何问题，那么我们现在就可以开始使用 Pleeease 了。在接下来的几页中，我们将查看手动编译以及使用
    Gulp 作为我们首选的任务运行器。让我们首先探索如何使用 `.pleeeaserc` 文件在命令行上轻松执行基本编译。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this chapter, we will concentrate on using SASS; if your
    preference is to use Less, you can use the `gulp-less` plugin as an alternative.
    Likewise, if your desire is to use Stylus, then the `gulp-stylus` plugin will
    work equally well with Pleeease.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于使用 SASS；如果你更喜欢使用 Less，可以使用 `gulp-less` 插件作为替代。同样，如果你希望使用 Stylus，那么
    `gulp-stylus` 插件也可以与 Pleeease 一样很好地工作。
- en: Compiling code manually
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动编译代码
- en: The simplest way to compile code using the Pleeease library is with a `.pleeeaserc`
    configuration file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pleeease 库编译代码的最简单方法是使用 `.pleeeaserc` 配置文件。
- en: 'This resembles a (simplified) JSON file, and will look something like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于一个（简化的）JSON 文件，看起来可能像这样：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looks pretty straightforward, doesn't it? We simply need to specify our source
    files (`in`), and what we should get (`out`). In this example, we've gone one
    step further, to specify the level of browser support needed—this is mainly to
    ensure that the right vendor prefixes have been applied.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，不是吗？我们只需要指定我们的源文件（`in`），以及我们应该得到什么（`out`）。在这个例子中，我们更进一步，指定所需的浏览器支持级别——这主要是为了确保已经应用了正确的供应商前缀。
- en: 'This setting uses the same configuration as Autoprefixer: we can equally pass
    it a valid query from the Browserslist query list at [https://github.com/ai/browserslist#queries](https://github.com/ai/browserslist#queries).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置使用与 Autoprefixer 相同的配置：我们可以同样传递来自 Browserslist 查询列表的有效查询，该列表可在 [https://github.com/ai/browserslist#queries](https://github.com/ai/browserslist#queries)
    找到。
- en: This is a useful method for compiling if our requirements do not stretch to
    using a task runner, or we want to keep our processes simple. The only downside
    is that we can't tie in any other tasks that could be automated, such as renaming
    the compiled style sheet with a `.min.css` extension—for this, we will need to
    use a task runner such as Gulp.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的需求不需要使用任务运行器，或者我们希望保持我们的流程简单，这是一个有用的编译方法。唯一的缺点是我们不能将任何其他可以自动化的任务绑定进来，例如使用
    `.min.css` 扩展名重命名编译后的样式表——为此，我们需要使用像 Gulp 这样的任务运行器。
- en: 'If we do use a task runner, this opens up all kinds of possibilities, such
    as automating processes to resize images, renaming compiled style sheets, and
    checking our code for consistency. Before we do so, let''s just cover a useful
    tip—the Pleeease site includes an online playground (available at [http://pleeease.io/play/](http://pleeease.io/play/)).
    We can use this to help familiarize ourselves with using the library before committing
    ourselves to compiling code for a production site:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任务运行器，这会打开各种可能性，例如自动化调整图像大小、重命名编译后的样式表以及检查代码的一致性。在我们这样做之前，让我们先介绍一个有用的技巧——Pleeease
    网站包含一个在线沙盒（可在 [http://pleeease.io/play/](http://pleeease.io/play/) 找到）。我们可以使用这个沙盒来熟悉使用该库，在为我们生产网站编译代码之前：
- en: '![Compiling code manually](img/BO5194_12_01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![手动编译代码](img/BO5194_12_01.jpg)'
- en: 'Okay, enough chitchat: it''s time to get practical, so to speak! For some,
    compiling at the command line might be enough, but in this modern age of automation,
    why spend time performing manual processes that can easily be automated?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，闲话不多说：现在是时候实际操作了！对于一些人来说，在命令行中编译可能就足够了，但在这个自动化时代，为什么要把时间花在执行可以轻松自动化的手动流程上？
- en: Compiling using a task runner
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务运行器编译
- en: If you haven't already guessed by now, I'm a big fan of using Node.js—my task
    runner of choice is Gulp. It used to be Grunt, but there is something about Gulp
    that I find is easier to use—I'm not sure why! Anyway, either can be used with
    Pleeease, so if your preference isn't Gulp, then please feel free to alter the
    code accordingly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到现在你还没有猜到，我是一个 Node.js 的忠实粉丝——我选择的任务运行器是 Gulp。以前是 Grunt，但我发现 Gulp 的使用起来更容易——我不确定为什么！无论如何，两者都可以与
    Pleeease 一起使用，所以如果你的首选不是 Gulp，那么请随意相应地修改代码。
- en: 'Let''s work through the steps needed to use Gulp to run our compilation process:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步完成使用 Gulp 运行编译过程的步骤：
- en: Fire up a Node.js command prompt session, then change the working folder to
    our project area.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个 Node.js 命令提示符会话，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, enter these commands, pressing *Enter* after each:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，每输入一个命令后按 *Enter*：
- en: '[PRE2]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep the Node.js command prompt session open—we will need it shortly.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持 Node.js 命令提示符会话开启——我们很快就会需要它。
- en: Extract a copy of the `T65 – using gulp-pleeease` folder from the code download
    that accompanies this book to the root of our project area.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中提取 `T65 – using gulp-pleeease` 文件夹的副本到我们的项目区域根目录。
- en: Copy the `package.json` and `gulpfile.js` files to the root of our project area,
    then copy `example.css` from the `src` folder under `T65 – using gulp-pleeease`
    to the `src` folder at the root of our project area.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `package.json` 和 `gulpfile.js` 文件复制到我们的项目区域根目录，然后将 `src` 文件夹下的 `example.css`
    复制到项目区域根目录的 `src` 文件夹。
- en: Revert to the Node.js command prompt session, then at the prompt enter `gulp`
    and press *Enter*:![Compiling using a task runner](img/BO5194_12_02.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符会话，然后在提示符下输入 `gulp` 并按 *Enter*：![使用任务运行器编译](img/BO5194_12_02.jpg)
- en: Assuming compilation is successful, Gulp will produce the now familiar files
    within the `dest` folder at the root of our project area. If we take a look at
    the results, we should see that it has minified the file, added vendor prefixes,
    and converted the `blue` and `red` color attributes to their equivalent HEX values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设编译成功，Gulp将在我们项目区域根目录下的`dest`文件夹中生成现在熟悉的文件。如果我们查看结果，我们应该看到它已经压缩了文件，添加了供应商前缀，并将`blue`和`red`颜色属性转换为它们的等效十六进制值。
- en: Let's put this technique to good use and create a simple web page as an example
    of how we can use Pleeease. When checking our Gulp file, we will see that we don't
    need to use half of the plugins we've used in previous exercises, as Pleeease
    adds that support from within its plugin.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们好好利用这项技术，创建一个简单的网页，作为我们如何使用Pleeease的示例。当我们检查Gulp文件时，我们会看到我们不需要使用之前练习中一半的插件，因为Pleeease在其插件内部添加了这些支持。
- en: Building an example using Pleeease
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pleeease构建示例
- en: Throughout many of the demos in this book, we've had to import a series of plugins
    to manage different tasks such as minifying code, or checking it for consistency.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多演示中，我们不得不导入一系列插件来管理不同的任务，例如压缩代码或检查其一致性。
- en: There is nothing technically wrong with this approach, but it is inefficient—after
    all, why use six tools when one will suffice, so to speak? We've tried to maintain
    a one plugin—one job rule throughout the book, so why are we breaking with convention?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在技术上没有错误，但效率不高——毕竟，为什么需要六种工具，而一种工具就足够了，对吧？我们试图在整个书中保持一个插件对应一个任务的规则，那么为什么我们要打破这个惯例呢？
- en: The great thing about using Pleeease is that it already contains support for
    some of these tasks that would otherwise require separate plugins; this means
    we can remove some of the plugins referenced in the Gulp task file. Pleeease is
    simply a layer that abstracts support for six other plugins through one common
    interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pleeease的好处是它已经包含了对一些任务的内置支持，否则这些任务可能需要单独的插件；这意味着我们可以从Gulp任务文件中删除一些插件。Pleeease只是一个通过一个通用接口抽象支持六个其他插件的层。
- en: 'Let''s put that to use in the form of compiling styles for a simple web page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其用于编译简单网页的样式：
- en: '![Building an example using Pleeease](img/B05194_12_21.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![使用Pleeease构建示例](img/B05194_12_21.jpg)'
- en: 'Let''s make a start:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: We'll start, as always, by extracting a copy of the `TXX – creating a page using
    pleeease` folder from the code download that accompanies this book; save it to
    the root of our project area.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，从本书附带的代码下载中提取`TXX – creating a page using pleeease`文件夹的副本；将其保存到我们项目区域的根目录。
- en: From the `css – completed version` folder, copy the `styles – pre compile.css`
    file to the `src` folder at the root of our project area; rename it `styles.css`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`css – completed version`文件夹中，将`styles – pre compile.css`文件复制到我们项目区域根目录下的`src`文件夹；将其重命名为`styles.css`。
- en: Copy the `gulpfile.js` and `package.json` files from the root of the `tutorial`
    folder to the root of the project area—these should replace any already present
    at the root of our project area.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gulpfile.js`和`package.json`文件从`tutorial`文件夹的根目录复制到项目区域的根目录——这些文件应该替换掉我们项目区域根目录下已有的文件。
- en: Fire up a Node.js command prompt session, then change the working folder to
    the project area.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个Node.js命令提示符会话，然后更改工作文件夹到项目区域。
- en: At the prompt, type `gulp` then press *Enter*—Pleeease will now go away and
    compile our code, and spit out valid style sheet files in the `dest` folder at
    the root of our project area.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入`gulp`然后按*Enter*——Pleeease现在将编译我们的代码，并在我们项目区域根目录下的`dest`文件夹中输出有效的样式表文件。
- en: Once completed, copy the contents of the `dest` folder to the `css` folder within
    the `tutorial` folder.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将`dest`文件夹的内容复制到`tutorial`文件夹内的`css`文件夹。
- en: If we try previewing the results of our work by double-clicking on `webpage.html`,
    we should see a web page appear, similar to the screenshot at the start of this
    demo. The real proof, though, is in the Gulp task file—in comparison to other
    examples we've created in earlier demos, we've managed to remove one task completely,
    and reduce the number of plugins referenced by over half!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试通过双击`webpage.html`来预览我们工作的结果，我们应该看到一个网页出现，类似于这个演示开始时的截图。然而，真正的证明是在Gulp任务文件中——与我们在早期演示中创建的其他示例相比，我们已经完全删除了一个任务，并且将引用的插件数量减少了超过一半！
- en: Compiling with other preprocessors
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他预处理器编译
- en: Yet there is one problem—so far, all of our work using Pleeease is PostCSS-based;
    what if we had been using a processor such as SASS as the basis for producing
    our code?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题——到目前为止，我们使用Pleeease所做的所有工作都是基于PostCSS的；如果我们使用SASS作为生成代码的基础呢？
- en: Unfortunately, this is where Pleeease falls down—although it does include support
    for SASS, Stylus, and Less, it is still very experimental. An example of where
    this causes an issue is in nesting; Pleeease has yet to support nesting when configured
    to use SASS. This reduces the appeal of using Pleeease—after all, one of the key
    reasons for using PostCSS is to remove any dependency on libraries such as SASS!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这正是Pleeease的不足之处——尽管它包括对SASS、Stylus和Less的支持，但它仍然非常实验性。一个导致问题的例子是在嵌套方面；当配置为使用SASS时，Pleeease尚未支持嵌套。这降低了使用Pleeease的吸引力——毕竟，使用PostCSS的一个关键原因就是消除对SASS等库的任何依赖！
- en: 'To get around this means using the `gulp-sass` plugin. This is a wrapper for
    the `libsass` library. To achieve this, we would add a task such as this to our
    Gulp task file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，意味着使用`gulp-sass`插件。这是一个`libsass`库的包装器。为了实现这一点，我们会在我们的Gulp任务文件中添加一个这样的任务：
- en: '![Compiling with other preprocessors](img/BO5194_12_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用其他预处理器编译](img/BO5194_12_03.jpg)'
- en: When using this method, we can pre-compile our SASS code to valid CSS before
    transforming it with PostCSS plugins. The trouble is, it seems an inefficient
    way to compile our code—there is a better alternative, in the form of the PreCSS
    library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种方法时，我们可以在使用PostCSS插件转换之前，预先编译我们的SASS代码为有效的CSS。问题是，这似乎是一种编译代码的低效方式——有一个更好的替代方案，那就是PreCSS库。
- en: Using the PreCSS library
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PreCSS库
- en: '*Okay…so why is it better, I hear you ask?*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*好的……那么为什么它更好，你可能会问？*'
- en: The simple answer to this is that we can compile SASS-like code directly without
    using an external library such as libsass. The distinction here, though, is that
    it works on SASS-*like* code, not direct SASS.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的回答是，我们可以直接编译类似SASS的代码，而不需要使用像libsass这样的外部库。然而，这里的区别在于它适用于类似SASS的代码，而不是直接的SASS。
- en: This isn't an issue though—we can easily perform a search and replace using
    a text editor to make the minor formatting changes required to make it compatible
    for PreCSS. The library source is available at [https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss);
    the developer has even provided an online playground for our use, at [https://jonathantneal.github.io/precss/](https://jonathantneal.github.io/precss/),
    so that we can try out changes before committing to code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是一个问题——我们可以轻松地使用文本编辑器进行搜索和替换，以进行必要的格式更改，使其与PreCSS兼容。库源代码可在[https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss)找到；开发者甚至为我们提供了一个在线沙盒[https://jonathantneal.github.io/precss/](https://jonathantneal.github.io/precss/)，以便我们在提交代码前尝试更改。
- en: 'At this point, we''re going to break with convention—rather than produce a
    simple web page, let''s push the boat out and use a content management system
    such as WordPress. Why? Well, for two reasons: WordPress already uses both PostCSS
    and SASS—it makes perfect sense to continue using the same tools! On this basis,
    let''s dive in and take a look at using both in more detail.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们将打破常规——而不是制作一个简单的网页，让我们大胆一些，使用像WordPress这样的内容管理系统。为什么？好吧，有两个原因：WordPress已经使用了PostCSS和SASS——继续使用相同的工具是完美的！基于这一点，让我们深入探讨并更详细地查看如何使用这两个工具。
- en: Converting a WordPress installation
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换WordPress安装
- en: All of our existing examples have so far been based around single pages; many
    developers are likely to use content management systems such as WordPress.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止的所有示例都基于单页；许多开发者可能会使用像WordPress这样的内容管理系统。
- en: Thankfully, we can apply many of the same principles we've used so far to styling
    WordPress—in fact, there are some plugins we can use that mimic SASS, which is
    used to create core style sheets for themes that come as part of each WordPress
    download. The theme we will use is Twenty Sixteen, which comes with current versions
    of WordPress downloaded since December 2015; it can also be downloaded from [https://wordpress.org/themes/twentysixteen/](https://wordpress.org/themes/twentysixteen/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以将迄今为止使用的许多相同原则应用于WordPress的样式——事实上，有一些插件我们可以使用，它们模仿SASS，这是用于创建作为每个WordPress下载部分的核心样式表的SASS。我们将使用的主题是Twenty
    Sixteen，自2015年12月以来的WordPress当前版本都包含这个主题；它也可以从[https://wordpress.org/themes/twentysixteen/](https://wordpress.org/themes/twentysixteen/)下载。
- en: For the remainder of this chapter, we're going to explore some of the tips and
    tricks we can use to incorporate PostCSS into a WordPress theme. A key point of
    note here, is that we've already covered some of the tasks that can be used—with
    care and planning, some can easily be reused when creating style sheets for CMS
    applications. We'll explore some of the tips and tricks we can use—although these
    will be geared towards the Twenty Sixteen theme, they can equally be used in other
    themes that are developed for WordPress.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将探讨一些我们可以使用的技巧和窍门，以将PostCSS集成到WordPress主题中。这里的一个关键点是，我们已经介绍了一些可以使用的任务——通过谨慎规划和设计，一些可以很容易地重用于为CMS应用程序创建样式表。我们将探讨一些我们可以使用的技巧和窍门——尽管这些将针对Twenty
    Sixteen主题，但它们同样可以用于为WordPress开发的其它主题。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This next example does assume a certain amount of knowledge of WordPress, and
    ideally some of the basics around using SASS or Less—I would recommend reading
    around these topics if you are new to either application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例假设您对WordPress有一定的了解，以及使用SASS或Less的一些基础知识——如果您是这两个应用程序的新手，我建议您阅读相关主题。
- en: Let's get started. Our first task is to set up our environment, ready for use.
    Before we set up our environment, though, I would strongly recommend you have
    a copy of the code download for this chapter handy—much of what will be discussed
    will make reference to the code!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们的第一个任务是设置我们的环境，以便使用。不过，在我们设置环境之前，我强烈建议您手头备有本章代码的副本——将要讨论的许多内容都将参考代码！
- en: Setting up our environment
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: 'To get the best out of this chapter, we need to set up an installation of WordPress—for
    the uninitiated, there are two ways to achieve this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我们需要设置一个WordPress的安装环境——对于初学者来说，有两种实现方式：
- en: We can install WordPress as a locally hosted application using a web server
    such as WAMPSever ([http://www.wampserver.com/en](http://www.wampserver.com/en))
    or Apache ([http://www.apachefriends.org](http://www.apachefriends.org)—if you
    are a Linux or Mac user)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Web服务器（如WAMPSever [http://www.wampserver.com/en](http://www.wampserver.com/en)）或Apache
    ([http://www.apachefriends.org](http://www.apachefriends.org)——如果您是Linux或Mac用户)将WordPress作为本地托管应用程序安装
- en: We can use a version of WordPress installed on our own web space online
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用安装在个人在线空间上的WordPress版本
- en: For the purposes of this book, we will use the former—to get hold of WordPress,
    head over to [http://www.wordpress.org](http://www.wordpress.org) and hit the
    blue **Download WordPress** button on the right side of the screen (near the top).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将使用前者——要获取WordPress，请访问[http://www.wordpress.org](http://www.wordpress.org)，然后在屏幕右侧（靠近顶部）点击蓝色的**下载WordPress**按钮。
- en: I will assume our version of WordPress has been installed locally under `C:\wamp\www\wordpress`,
    using your local web server of choice, following the instructions available at
    [https://codex.wordpress.org/Installing_WordPress](https://codex.wordpress.org/Installing_WordPress).
    My preference is to use WAMPServer (available from [http://www.wampserver.com/en](http://www.wampserver.com/en)),
    but if you would like to use a different web server or folder, then please adjust
    the steps accordingly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设我们的WordPress版本已经在本地的`C:\wamp\www\wordpress`下安装，使用您选择的本地Web服务器，按照[https://codex.wordpress.org/Installing_WordPress](https://codex.wordpress.org/Installing_WordPress)中提供的说明进行操作。我的首选是使用WAMPServer（可在[http://www.wampserver.com/en](http://www.wampserver.com/en)获取），但如果您想使用不同的Web服务器或文件夹，请相应调整步骤。
- en: Okay, with WordPress installed, configured, and ready to go, let's crack on.
    The next step is to take a look at the options available to us for beginning the
    transition process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，WordPress安装、配置并准备就绪后，让我们继续前进。下一步是查看我们开始转换过程可用的选项。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The steps given throughout the remainder of this chapter will be geared towards
    Windows, as this is the platform normally used by the author; please adjust accordingly,
    if you use Linux or Mac devices.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分给出的步骤将针对Windows平台，因为这是作者通常使用的平台；如果您使用Linux或Mac设备，请相应调整。
- en: Considering the conversion process
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑转换过程
- en: Where does one start, when working with an average WordPress style sheet, I
    hear you ask?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理一个普通的WordPress样式表时，您可能会问从哪里开始？
- en: Well, the first thing we should not do is be put off by its size. Yes, I know
    this might sound crazy (after all, the Twenty Sixteen theme weighs in at 3920
    lines!), but with some planning, we can easily break this into something more
    manageable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们首先不应该做的事情就是被其大小所吓倒。是的，我知道这听起来可能有些疯狂（毕竟，Twenty Sixteen主题有3920行！），但只要有些规划，我们就可以轻松地将它分解成更易于管理的部分。
- en: If we only achieve one task with PostCSS, then that task must be to make use
    of the `postcss-import` plugin to help break our code into more manageable principles.
    If you happen to have used processors such as SASS or Less, then it's the same
    principle—in our master `style.css`, we can create a series of import statements,
    and hive off each block into separate files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只通过PostCSS完成一个任务，那么这个任务必须是利用`postcss-import`插件来帮助我们将代码分解成更易于管理的原则。如果你恰好使用过SASS或Less这样的处理器，那么原理是相同的——在我们的主`style.css`文件中，我们可以创建一系列导入语句，并将每个块分离到单独的文件中。
- en: Once we've broken the style sheet into more manageable chunks, there are a fair
    few things we can implement in our code; we should always consider it an iterative
    process, until such time as we exhaust all possible alternatives, the site is
    no longer required, or we migrate to a different solution. Over the next few pages,
    we'll cover some of the ideas and considerations that are likely to crop up—this
    should help get you started with making the changes to your theme. So without
    further ado, where do we start?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将样式表分解成更易于管理的块，我们可以在代码中实现相当多的事情；我们应该始终将其视为一个迭代过程，直到我们用尽所有可能的替代方案，网站不再需要，或者我们迁移到不同的解决方案。在接下来的几页中，我们将介绍一些可能出现的想法和考虑因素——这应该有助于你开始对你的主题进行更改。所以，无需多言，我们从哪里开始呢？
- en: Well, the obvious one is using Autoprefixer; WordPress makes good use of CSS3
    styles, of which a fair number still require vendor prefixes. A consideration
    here, though, is that as we will be working backwards from the original style
    sheet, we will need to strip out existing vendor prefixes and set our task runner
    to add these in automatically. It's a necessary evil of working with existing
    style sheets in WordPress, but at least we should only have to do it once! There
    may be a temptation to create a mixin to manage vendor prefixes, but this is not
    considered best practice—Autoprefixer will update styles at each compilation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，显而易见的一个选择是使用Autoprefixer；WordPress很好地利用了CSS3样式，其中相当一部分仍然需要供应商前缀。不过，这里有一个考虑因素，那就是我们将从原始样式表反向工作，我们需要移除现有的供应商前缀，并将任务运行器设置为自动添加这些前缀。这是在WordPress中处理现有样式表的一个必要之恶，但至少我们只需要做一次！可能会有创建一个mixin来管理供应商前缀的诱惑，但这并不是最佳实践——Autoprefixer会在每次编译时更新样式。
- en: We're already familiar with using Autoprefixer from earlier examples—in the
    same vein, we can also consider minifying our code, which will help reduce bandwidth
    usage. Adding such a facility should be a cinch—we can use the same tasks from
    earlier demos, as long as we set the right order of tasks. We will need to alter
    it to compile `style.css` directly (this is the main file for WordPress style
    sheets), but as our processor will be geared towards using WordPress, this won't
    be an issue.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了从之前的例子中使用Autoprefixer——同样，我们还可以考虑压缩我们的代码，这有助于减少带宽使用。添加这样的功能应该轻而易举——我们可以使用之前演示中的相同任务，只要我们设置正确的任务顺序。我们需要将其更改为直接编译`style.css`（这是WordPress样式表的主要文件），但由于我们的处理器将针对WordPress使用，这不会成为问题。
- en: Another area we can look at is rem unit support, with pixel fallback. Many developers
    have their own views on using rem as a unit of measure; some say pixel values
    work just as well, but its suitability will depend on where it is being applied.
    This aside, Gulp has a suitable plugin we can use to help provide this functionality,
    if we need it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以关注的领域是rem单位支持，带有像素回退。许多开发者对使用rem作为度量单位有自己的看法；有些人说像素值效果一样好，但它的适用性将取决于应用的位置。抛开这一点，Gulp有一个合适的插件可以帮助我们提供这项功能，如果我们需要的话。
- en: One way to really make an impact on our code is to use nesting—this is a common
    technique for preprocessors such as SASS, and involves writing code in a nested
    format. The key benefit is to remove code that is duplicated—consider it a form
    of shorthand (in a manner of speaking), which will be transformed into valid CSS
    at compilation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 真正对我们代码产生影响的一种方式是使用嵌套——这是SASS等预处理器中的一种常见技术，涉及以嵌套格式编写代码。关键好处是移除重复的代码——可以将其视为一种简写（从某种意义上说），它将在编译时转换为有效的CSS。
- en: 'A useful technique to also look at is the use of variables; these work in much
    the same way as scripting or programming languages. Now before you go running
    for the hills, don''t worry: they are easy to use. We need to provide a list of
    placeholder names, and the values they represent; we can then do a search and
    replace throughout our code for each value, and replace it with the appropriate
    variable. Why do this, I hear you ask? Well, it''s simple: if you change a color
    in the future, you only need to change it in one place; PostCSS will automatically
    change all other instances for you at the compilation stage.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得一看的技术是变量的使用；它们的工作方式与脚本或编程语言非常相似。现在在你跑向山丘之前，别担心：它们很容易使用。我们需要提供一个占位符名称列表，以及它们代表的值；然后我们可以在代码中对每个值进行搜索和替换，并用适当的变量替换它。你可能会问为什么这样做？嗯，很简单：如果你将来更改颜色，你只需要在一个地方更改它；PostCSS将在编译阶段自动为你更改所有其他实例。
- en: If you would like to really get stuck into the core code for WordPress, then
    it's always worth exploring the code repository at [https://core.trac.wordpress.org/browser/trunk/](https://core.trac.wordpress.org/browser/trunk/).
    If you look carefully, you should even see where PostCSS is being used!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想深入WordPress的核心代码，那么探索[https://core.trac.wordpress.org/browser/trunk/](https://core.trac.wordpress.org/browser/trunk/)的代码仓库总是值得的。如果你仔细观察，甚至可以看到PostCSS的使用情况！
- en: 'Okay, enough chitchat: let''s get stuck into some code! The changes we will
    make as part of our next demo are just some of the ways in which we can incorporate
    the use of PostCSS plugins (or Gulp, for that matter), into our process. We''ll
    begin by exploring the changes we need to make, and follow this with some ideas
    for you to try out as part of using PostCSS.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，别再闲聊了：让我们开始写代码吧！我们将在下一个演示中进行的修改只是我们如何将PostCSS插件（或者Gulp）的使用纳入我们流程的一些方法之一。我们将首先探索我们需要进行的修改，然后提供一些使用PostCSS的尝试想法。
- en: Making changes to our code
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们的代码进行修改
- en: Although we've only covered a few ideas, there are nevertheless a fair few steps
    to go through; the key to this (and keeping your sanity!) is to complete each
    in blocks, and not all in one go.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只介绍了一些想法，但仍然有许多步骤需要完成；这个问题的关键（以及保持你的理智！）是分块完成每个步骤，而不是一次性完成所有。
- en: The bulk of our changes will use existing tasks we've created in earlier demos;
    to this we will add the PreCSS library (from [https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss)),
    along with postcss-import and gulp-pixrem plugins. With this in mind, we'll make
    a start—our first task is to split the code into more manageable style sheets.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分更改将使用我们在早期演示中创建的现有任务；我们将添加PreCSS库（来自[https://github.com/jonathantneal/precss](https://github.com/jonathantneal/precss)），以及postcss-import和gulp-pixrem插件。考虑到这一点，我们将开始——我们的第一个任务是分割代码成更易于管理的样式表。
- en: Splitting our style sheet
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割我们的样式表
- en: 'The critical part of this process is to split our style sheet—for this, we
    will use the `postcss-import` plugin, from [https://github.com/postcss/postcss-import](https://github.com/postcss/postcss-import):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的关键部分是将我们的样式表分割开——为此，我们将使用来自[https://github.com/postcss/postcss-import](https://github.com/postcss/postcss-import)的`postcss-import`插件：
- en: We'll start, as always, by firing up a Node.js command prompt, then changing
    the working folder to the root of our project area.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，启动一个Node.js命令提示符，然后更改工作文件夹到项目区域的根目录。
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，然后按*Enter*：
- en: '[PRE3]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Wait for Gulp to complete the installation process.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Gulp完成安装过程。
- en: 'Next, we need to split our style sheet into separate blocks; the most convenient
    way to do this is split it into sections according to the list at the top of `style.css`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将样式表分割成单独的块；最方便的方法是按照`style.css`顶部的列表将其分割成部分：
- en: In the `src` folder at the root of our project area, create a new folder called
    `css`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目区域的根目录下的`src`文件夹中，创建一个名为`css`的新文件夹。
- en: Go ahead and open up a copy of `style.css` from within the Twenty Sixteen folder—it's
    located at `C:\wamp\www\wordpress\wp-content\themes\twentysixteen\`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`C:\wamp\www\wordpress\wp-content\themes\twentysixteen\`的Twenty Sixteen文件夹中的`style.css`副本。
- en: Save this to the `src` folder at the root of our project area.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此保存到项目区域的根目录下的`src`文件夹中。
- en: 'On or around line 53, add this line: `@import "css/variables.css";`. Don''t
    worry for now what it will be for—this will become clear later in this chapter.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第53行或附近，添加以下行：`@import "css/variables.css";`。现在不用担心它将用于什么——这将在本章的后面变得清楚。
- en: Find lines 54 to 252, then copy them to a new file—save this as `normalize.css`
    in the `css` folder within the root `src` folder.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第54至252行，然后将它们复制到一个新文件中——将其保存为`normalize.css`，位于根`src`文件夹内的`css`文件夹中。
- en: In the `style.css` file within the `src` folder, add these import statements,
    as indicated:![Splitting our style sheet](img/BO5194_12_04.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹内的`style.css`文件中，添加这些导入语句，如指示：![分割我们的样式表](img/BO5194_12_04.jpg)
- en: Repeat the process until you have extracted all sections into their own files
    (1 to 15). Save them with the same names as each main section.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到您已将所有部分提取到各自的文件中（1至15）。使用与每个主要部分相同的名称保存它们。
- en: Note
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note, when saving the files, you *don't* need to split sections 11 to 15 into
    their sub-sections—keep these within their respective files.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在保存文件时，您*不需要*将第11至15节分割成子部分——保持这些部分在其各自的文件中。
- en: 'We have one last step to perform: we need our Gulp task file! From the code
    download that accompanies this book, go ahead and extract a copy of `gulpfile.js`
    and `package.json` from the `T68 - converting a WordPress theme` folder, then
    save both to the root of our project area.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要执行最后一步：我们需要我们的Gulp任务文件！从伴随本书的代码下载中，请从`T68 - converting a WordPress theme`文件夹中提取`gulpfile.js`和`package.json`的副本，然后将它们都保存到项目区域的根目录下。
- en: Take a quick look at the `gulpfile.js` file, in particular, at lines 31 to 35:![Splitting
    our style sheet](img/BO5194_12_05.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速查看`gulpfile.js`文件，特别是第31至35行：![分割我们的样式表](img/BO5194_12_05.jpg)
- en: Notice how we are compiling directly to `style.css`, unlike previous exercises?
    It's not ideal, but as WordPress themes use `style.css` by default, this is something
    we can live with as part of our compilation process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何直接编译到`style.css`的，这与之前的练习不同？这并不理想，但鉴于WordPress主题默认使用`style.css`，这是我们可以在编译过程中容忍的部分。
- en: Adding support for vendor prefixes
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加供应商前缀支持
- en: Our next task is to install support for adding vendor prefixes—in a sense, we've
    already covered how to achieve this. Most, if not all, of our previous demos already
    include support for vendor prefixes, using the Autoprefixer plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是安装添加供应商前缀的支持——从某种意义上说，我们已经在之前的示例中介绍了如何实现这一点。我们之前的多数，如果不是所有，演示已经包括了对供应商前缀的支持，使用了Autoprefixer插件。
- en: As a reminder, Autoprefixer is available from [https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer);
    there is an online version we can use to test changes at [https://autoprefixer.github.io/](https://autoprefixer.github.io/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，Autoprefixer可以从[https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)获取；我们有一个在线版本可以用来测试更改，在[https://autoprefixer.github.io/](https://autoprefixer.github.io/)。
- en: 'If we take a look at the Gulp task file we downloaded in the previous example,
    we can see the autoprefixer plugin has been called as part of firing PostCSS:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看之前示例中下载的Gulp任务文件，我们可以看到Autoprefixer插件已经被作为触发PostCSS的一部分调用：
- en: '![Adding support for vendor prefixes](img/BO5194_12_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![添加供应商前缀支持](img/BO5194_12_06.jpg)'
- en: There are, however, a couple of key points we should note at this stage.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个阶段，我们应该注意几个关键点。
- en: When using the Autoprefixer plugin, it uses data from the Can I Use site ([http://www.caniuse.com](http://www.caniuse.com))
    to update any vendor prefixes it finds that are out of date. It is worth spending
    time going through your style sheet to ensure that it does not already include
    vendor prefixes—if it does, these need to be removed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Autoprefixer插件时，它会使用来自Can I Use网站([http://www.caniuse.com](http://www.caniuse.com))的数据来更新它找到的任何过时的供应商前缀。花时间检查您的样式表以确保它尚未包含供应商前缀是很值得的——如果包含，这些前缀需要被删除。
- en: We can remove them manually, or a more effective route is to use the `postcss-remove-prefixes`
    plugin, available from [https://github.com/johnotander/postcss-remove-prefixes](https://github.com/johnotander/postcss-remove-prefixes).
    We can add it to our Gulp task file, or run it directly from the command line.
    The key here is to complete the removal first, so that Autoprefixer can then be
    used to manage vendor prefixes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动删除它们，或者更有效的方法是使用来自[https://github.com/johnotander/postcss-remove-prefixes](https://github.com/johnotander/postcss-remove-prefixes)的`postcss-remove-prefixes`插件。我们可以将其添加到我们的Gulp任务文件中，或者直接从命令行运行它。这里的关键是首先完成删除，这样Autoprefixer就可以用来管理供应商前缀。
- en: 'WordPress already uses Autoprefixer to manage vendor prefixes—you can see evidence
    of it in the `Grunt` file at [https://core.trac.wordpress.org/browser/trunk/Gruntfile.js](https://core.trac.wordpress.org/browser/trunk/Gruntfile.js).
    Granted, it is using Grunt, but the process is very similar for those of you using
    Gulp or one of the other task runners available that are compatible with PostCSS:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress已经使用Autoprefixer来管理供应商前缀——你可以在[https://core.trac.wordpress.org/browser/trunk/Gruntfile.js](https://core.trac.wordpress.org/browser/trunk/Gruntfile.js)的`Grunt`文件中看到它的证据。当然，它使用的是Grunt，但对于使用Gulp或其他与PostCSS兼容的任务运行器的人来说，这个过程非常相似：
- en: '![Adding support for vendor prefixes](img/BO5194_12_07.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![添加对供应商前缀的支持](img/BO5194_12_07.jpg)'
- en: 'Although setting up Autoprefixer in our Gulp task file is very easy—at least
    the basics—it will only be successful if we spend time removing any vendor prefixes
    that can then be added automatically at compilation. The `postcss-remove-prefixes`
    plugin will remove simple examples such as the following one, so that we are left
    with unprefixed versions that Autoprefixer can then update during compilation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的Gulp任务文件中设置Autoprefixer非常简单——至少是基础设置——但它只有在花费时间移除任何可以自动在编译时添加的供应商前缀的情况下才会成功。`postcss-remove-prefixes`插件将移除如下简单示例，这样我们就可以留下不带前缀的版本，Autoprefixer可以在编译时更新它们：
- en: '![Adding support for vendor prefixes](img/BO5194_12_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![添加对供应商前缀的支持](img/BO5194_12_08.jpg)'
- en: The final core task we should perform is to check our code for consistency—by
    now, this should be an all-too familiar task, as we've already set up a suitable
    task from earlier demos that can easily be reused for compiling WordPress themes.
    It's time to revisit this task. To ensure it works correctly, we will need to
    amend the settings slightly, so let's cover that now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该执行的最后一个核心任务是检查代码的一致性——到目前为止，这应该是一个非常熟悉的任务，因为我们已经从早期的演示中设置了一个合适的任务，可以很容易地用于编译WordPress主题。现在是时候重新审视这个任务了。为了确保它能够正确工作，我们需要稍微修改一下设置，现在就让我们来谈谈这一点。
- en: Checking our code for consistency
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查代码一致性
- en: 'If we take a look at the Gulp task file we saved at the start of these changes,
    we should see this configuration object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这些更改开始时保存的Gulp任务文件，我们应该看到这个配置对象：
- en: '![Checking our code for consistency](img/BO5194_12_09.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码一致性](img/BO5194_12_09.jpg)'
- en: 'A little further down is the task, there are two changes here: we''ve hardcoded
    the `destination` file, and the order which has been adjusted, to allow for the
    presence of the `pxrem` task. The indentation setting has also been changed within
    the configuration object—when compiled, the style sheet uses tabs for indentation.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点更往下是任务，这里有两个更改：我们硬编码了`destination`文件，并调整了顺序，以便允许`pxrem`任务的存在。配置对象中的缩进设置也发生了变化——当编译时，样式表使用制表符进行缩进。
- en: This will throw up a host of warnings, we can either manually alter 3000+ entries,
    or alter how the indentation is checked. Hopefully it's a no-brainer as to which
    we would prefer to do, at least in the short term!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发大量警告，我们可以手动更改3000多个条目，或者更改检查缩进的方式。希望这很容易就能明白我们更愿意做哪一种，至少在短期内是这样！
- en: 'Leaving aside these two changes, the remainder of the linting task has not
    changed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个更改之外，linting任务的其余部分没有变化：
- en: '![Checking our code for consistency](img/BO5194_12_10.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![检查代码一致性](img/BO5194_12_10.jpg)'
- en: 'Okay, let''s change tack: there is one more core task which we should run,
    which is to minify our code. We''ve already used it in a number of demos, but
    let''s take a moment to just revisit it within the context of compiling WordPress
    themes.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们换个方向：还有一个核心任务我们应该运行，那就是压缩我们的代码。我们已经在多个演示中使用了它，但现在让我们花点时间在编译WordPress主题的上下文中重新审视它。
- en: Minifying our code
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩我们的代码
- en: If we had to rank the top four key tasks that could be performed using PostCSS,
    then this next task should definitely be at the top of that list. Minifying our
    code is key to conserving bandwidth usage—WordPress themes are no lightweights!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须对使用PostCSS可以执行的前四项关键任务进行排名，那么接下来的这个任务肯定应该排在最前面。压缩我们的代码对于节省带宽使用至关重要——WordPress主题可不是轻量级的！
- en: 'Our Gulp file already has this built in: the `package.json` file will have
    the appropriate reference set. If we take a look at the task file in more detail,
    we should see something akin to this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Gulp文件已经内置了这个：`package.json`文件将设置适当的引用。如果我们更详细地查看任务文件，我们应该看到类似以下的内容：
- en: '![Minifying our code](img/BO5194_12_11.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![压缩我们的代码](img/BO5194_12_11.jpg)'
- en: Looks familiar? It should—it's an almost direct copy of the existing task we've
    used from earlier demos. We've switched off `autoprefixer`, as this is being used
    elsewhere in our Gulp file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来熟悉吗？应该是的——它几乎是我们之前演示中使用的现有任务的直接复制。我们已经关闭了`autoprefixer`，因为我们在Gulp文件的其他地方使用了它。
- en: Let's move on. WordPress uses SASS as its main pre-processor; we could use the
    Pleeease library to compile both SASS and PostCSS code, but a cleaner option is
    to use the PreCSS library. This abstracts support for a number of plugins that
    emulate SASS code (but without the SASS baggage, so to speak). Let's dive in and
    take a look at this in more detail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。WordPress使用SASS作为其主要预处理器；我们可以使用Pleeease库来编译SASS和PostCSS代码，但一个更干净的选择是使用PreCSS库。这个库抽象了对许多模拟SASS代码的插件的支持（但可以说没有SASS的负担）。让我们深入探讨并更详细地看看这一点。
- en: Creating variables
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建变量
- en: One of the key features of SASS (and other processors) is the ability to use
    variables as placeholders for values—these are transformed into valid CSS styles
    at compilation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: SASS（以及其他处理器）的一个关键特性是能够使用变量作为值的占位符——这些在编译时被转换为有效的CSS样式。
- en: 'Why use them, I hear you ask? Simple, if you decide to change a font family,
    or color, do you want to wade through thousands of lines of code to update any
    instance where it has been used? I would hope the answer is no—and quite rightly
    so: we have better things to do! One of those, is to install the plugin that will
    add variable support in the form of PreCSS.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么使用它们？简单来说，如果你决定更改字体家族或颜色，你希望翻遍数千行代码来更新所有使用过的地方吗？我希望答案是“不”——这是完全正确的：我们还有更重要的事情要做！其中之一就是安装那个将添加变量支持的插件，形式为PreCSS。
- en: 'We''ve already installed PreCSS from an earlier demo, so all that remains to
    do is to ensure it is added to our Gulp task file accordingly (it''s already in
    ours, and in the accompanying `package.json` file):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从之前的演示中安装了PreCSS，所以剩下的只是确保将其添加到我们的Gulp任务文件中相应的地方（它已经在我们的文件中，并且在附带的`package.json`文件中）：
- en: '![Creating variables](img/BO5194_12_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![创建变量](img/BO5194_12_12.jpg)'
- en: 'The real work comes in changing our style sheet—let''s take a look at what
    is required:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的工作在于更改我们的样式表——让我们看看需要做什么：
- en: First, we need to create a file to store our variables—go ahead and create a
    blank file in the `css` subfolder under the `src` folder at the root of our project
    area, and label it `variables.css`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个文件来存储我们的变量——请在项目区域的根目录下的`src`文件夹中的`css`子文件夹中创建一个空白文件，并将其命名为`variables.css`。
- en: 'Open up the `variables.css` file. Go ahead and add these values:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`variables.css`文件。继续添加这些值：
- en: '[PRE4]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the file, if we take a look back at *Splitting our style sheet*, you will
    notice that we've already included a link to it from our master style sheet:![Creating
    variables](img/BO5194_12_13.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，如果我们回顾一下*拆分我们的样式表*，你会注意到我们已经从我们的主样式表中包含了对其的链接：![创建变量](img/BO5194_12_13.jpg)
- en: Values from this file will replace placeholders within our code, to produce
    valid CSS.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自此文件的值将替换我们代码中的占位符，以生成有效的CSS。
- en: The next task is a necessary evil, we have to work our way through each style
    sheet to be imported, and replace existing values with the variable equivalents.
    This screenshot shows a part example—here, the `font-family` value has been updated,
    but the `border` value has yet to be changed:![Creating variables](img/BO5194_12_14.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个任务是必要的恶行，我们必须逐个处理要导入的每个样式表，并将现有值替换为变量等效值。这个截图显示了部分示例——在这里，`font-family`值已经更新，但`border`值尚未更改：![创建变量](img/BO5194_12_14.jpg)
- en: Once each file has been changed, then save each, ready for the next exercise.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦每个文件都进行了更改，然后保存每个文件，为下一个练习做好准备。
- en: There is no easy way to get around it, but altering WordPress theme style sheets
    can require lots of patience! The best way to manage it is to use your editor's
    search and replace function— editors such as Sublime Text 3 (the author's editor
    of preference) have a very useful facility to replace text in multiple files;
    making use of this will help reduce the manual effort required to update each
    file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法可以绕过这个问题，但修改WordPress主题样式表可能需要大量的耐心！最好的办法是使用你编辑器的搜索和替换功能——例如Sublime Text
    3（作者的偏好编辑器）有一个非常有用的功能，可以在多个文件中替换文本；利用这个功能将有助于减少手动更新每个文件所需的工作量。
- en: Adding support for rem units
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对rem单位的支持
- en: This next task is one that is likely to cause debate—altering our code to use
    rem units, with pixel fallback added automatically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务可能会引起争议——将我们的代码更改为使用rem单位，并自动添加像素回退。
- en: 'Some developers claim that pixel values work just as well; others say that
    it all depends on where you need to specify a value, as to which unit of measure
    to use. Either way, we can use PostCSS to add pixel fall-back support automatically.
    The source for this plugin is available from `https://github.com/gummesson/gulp-pixrem`.
    Let''s explore what is needed to add support for rem units:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者声称像素值效果一样好；其他人说，这完全取决于你需要在哪里指定值，以及使用哪种度量单位。无论如何，我们可以使用PostCSS自动添加像素回退支持。此插件的源代码可在`https://github.com/gummesson/gulp-pixrem`找到。让我们探索添加对rem单位支持所需的内容：
- en: Open up a Node.js command prompt session, or if the one from the previous session
    is still available, then revert to it.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Node.js命令提示符会话，或者如果上一个会话的命令提示符仍然可用，则切换到它。
- en: 'Ensure that the working folder is set to the root of our project folder, then
    at the prompt enter this command and press *Enter*:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保工作文件夹设置为我们的项目文件夹的根目录，然后在提示符中输入此命令并按*Enter*：
- en: '[PRE5]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Gulp will go away and install the plugin—wait for it to complete before continuing.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gulp将移除并安装插件——等待它完成后再继续。
- en: We already have our Gulp task file in place—if we look at it in detail, we can
    see it being called at line 39:![Adding support for rem units](img/BO5194_12_15.jpg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经有了我们的Gulp任务文件——如果我们仔细查看，我们可以看到它在第39行被调用：![添加对rem单位的支持](img/BO5194_12_15.jpg)
- en: At this point, we have everything in place - the next task is to work our way
    through the various style sheets that we've created, and replace any instance
    of pixel values with rem equivalents.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好了所有东西——下一个任务是逐一处理我们创建的各种样式表，并将任何像素值替换为rem等效值。
- en: This is a thankless but necessary task—the plugin works by adding pixel fallback
    values for any instances of rem units that it finds within our code. It is up
    to us to do as much or as little as we want, in terms of changing values—it is
    worth making some changes to ensure that the code compiles, but the remaining
    changes can be done over time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项不受欢迎但必要的任务——插件通过在我们的代码中找到的任何rem单位的实例添加像素回退值来工作。至于改变值，我们想改变多少就改变多少——确保代码可以编译是值得做一些改变的，但剩余的改变可以逐步进行。
- en: 'When compiling the code, we will end up with code similar to this example—this
    extract comes from the Widgets section (section 10):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译代码时，我们最终会得到类似这个示例的代码——这个摘录来自小部件部分（第10部分）：
- en: '![Adding support for rem units](img/BO5194_12_16.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![添加对rem单位的支持](img/BO5194_12_16.jpg)'
- en: It's easy to simply convert our style sheet to use pixel fallback support—the
    key here is that we need to decide where we want to be using rem unit support,
    and where existing values such as pixels or em units would be preferable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的样式表简单地转换为使用像素回退支持很容易——关键是我们需要决定在哪里想要使用rem单位支持，以及在哪里使用像素或em单位等现有值会更合适。
- en: Moving on, there are two more tasks we can set up as part of our compilation
    process—how about mimicking the ability to nest styles from SASS, or creating
    mini loops to automate generating certain styles? Don't worry if this is not something
    that you're familiar with—let's dive in and see what these mean in action.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在编译过程中设置两个更多任务——模仿SASS嵌套样式的功能，或者创建迷你循环来自动生成某些样式怎么样？如果你不熟悉这些，不要担心——让我们深入看看这些在实际操作中的意义。
- en: Nesting rules in our style sheet
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们样式表中的嵌套规则
- en: The nesting of styles is a common feature when using processors such as SASS—if
    we have a bunch of styles that have very similar selectors, then it creates a
    degree of unwanted duplication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用处理器如SASS时，样式的嵌套是一个常见功能——如果我们有一堆具有非常相似选择器的样式，那么它就会产生一定程度的无用的重复。
- en: 'We could stick with this duplication, but a more sensible option is to take
    the core part of the selector, then nest descendants within that block—this example
    is taken from the `typography.css` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这种重复，但更合理的选项是取选择器的核心部分，然后在那个块内嵌套后代——这个例子是从`typography.css`文件中取的：
- en: '![Nesting rules in our style sheet](img/BO5194_12_17.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![我们的样式表中嵌套规则](img/BO5194_12_17.jpg)'
- en: The idea is to avoid having to write the same duplicated parent styles—we can
    concentrate on the children instead! While the code may look longer, it is definitely
    easier to read; we can group together styles that have a common parent.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是避免不得不写相同的重复父级样式——我们可以专注于子级！虽然代码看起来更长，但确实更容易阅读；我们可以将具有共同父级的样式组合在一起。
- en: The technique is easy to pick up, but can be deceptively hard to get right;
    if you are not familiar with it, then I would recommend taking a look at my two
    books on SASS *SASS Essentials* and *SASS CSS How-to*, available at [https://www.packtpub.com/](https://www.packtpub.com/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术很容易掌握，但可能具有欺骗性的难以正确应用；如果你不熟悉它，那么我建议你看看我的两本关于 SASS 的书《SASS Essentials》和《SASS
    CSS How-to》，可在 [https://www.packtpub.com/](https://www.packtpub.com/) 购买。
- en: 'Once compiled, the code will appear as normal CSS. There''s one thing to note,
    though: resist the temptation to nest everything; nesting is really best kept
    to where you can see a real difference in the amount of code used!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，代码将显示为正常的 CSS。但有一点需要注意：抵制嵌套一切的诱惑；嵌套最好保留在你能看到代码使用量真正有差异的地方！
- en: Looping through styles
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环样式
- en: 'There is one more change we can make to our code—take a look at the `media.css`
    file that we created earlier in this chapter, in particular around lines 158 to
    the end:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对我们的代码进行一项更改——看看我们在本章早期创建的 `media.css` 文件，特别是从第 158 行到末尾：
- en: '![Looping through styles](img/BO5194_12_18.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![循环样式](img/BO5194_12_18.jpg)'
- en: I can already hear the next questions coming, what is that meant to be, and
    why are we using what looks like a programming loop in our code? In this instance,
    we're borrowing a principle from SASS, namely creating loops; this, coupled with
    string interpolation allows us to create the rules automatically.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经能听到接下来可能的问题了，这是什么意思，为什么我们在代码中使用看起来像编程循环的东西？在这个例子中，我们借鉴了 SASS 的一个原则，即创建循环；结合字符串插值，这使我们能够自动创建规则。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: String interpolation is creating a placeholder in our code, which will be transformed
    with values at compilation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值是在我们的代码中创建一个占位符，该占位符将在编译时用值替换。
- en: 'When the code is compiled, this is how the code will look:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码编译时，代码将呈现如下：
- en: '![Looping through styles](img/BO5194_12_19.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![循环样式](img/BO5194_12_19.jpg)'
- en: It's a more advanced principle to grasp, but certainly one worth spending time
    getting up to speed—if applied correctly, it can save a lot of time with creating
    styles!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更高级的概念，但确实值得花时间去掌握——如果应用得当，它可以在创建样式时节省大量时间！
- en: Let's change tack at this point—we've covered a number of concepts that will
    help get you started; there are a few more ideas that we can follow up at a later
    date, once the basics are in place. Let's take a moment to consider these in more
    detail.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变一下方向——我们已经介绍了一些帮助你入门的概念；还有一些想法我们可以在基础知识建立后，稍后再跟进。让我们花点时间更详细地考虑这些。
- en: Considering future possible ideas
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑未来的可能想法
- en: Over the last few pages, we've covered a number of areas where PostCSS can be
    used to help better manage our WordPress style sheets. It's important to bear
    in mind that there are no hard and fast rules on what should be used, but that
    each style sheet will have its own requirements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，我们介绍了一些可以使用 PostCSS 来帮助更好地管理我们的 WordPress 样式表的领域。重要的是要记住，并没有一成不变的规则来决定应该使用什么，但每个样式表都会有它自己的需求。
- en: 'The options we''ve covered only scratch the surface of what is possible—for
    those of you who are familiar with SASS, you may well be asking why we didn''t
    use SASS mixins, for example. The simple reason is that there is nothing stopping
    us from doing so: it was all about providing options that give us a quick and
    easy win at the conversion stage.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的选项只是触及了可能性的表面——对于那些熟悉 SASS 的你，你可能想知道为什么我们没有使用 SASS 混合，例如。简单的原因是，没有任何阻止我们这样做：一切都是关于提供在转换阶段快速且容易获胜的选项。
- en: 'Let''s pause for a moment and consider some other ideas that will help get
    you started on updating our style sheet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，考虑一些其他可以帮助我们开始更新样式表的思路：
- en: '**Adding mixins**: This is the obvious choice, but one that needs planning;
    this will be all about creating blocks of code that can be reused at will throughout
    our code.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加混合**：这是一个显而易见的选择，但需要规划；这将涉及到创建可以在我们代码中随意重用的代码块。'
- en: '**Color fallback**: Although not part of the PreCSS package we''ve been using
    to date, color fallback is another option to consider. The core WordPress themes
    use standard HEX notation; we can update it to use RGB equivalents and use a PostCSS
    plugin to add in HEX values. If we prefer, we can even use a plugin such as postcss-rgba-hex
    to convert from using RGBA colors to plain HEX—you may prefer working with the
    former, or have processes that require the use of the former format.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色回退**：尽管这并不是我们迄今为止使用的PreCSS包的一部分，但颜色回退是另一个可以考虑的选项。核心WordPress主题使用标准的HEX表示法；我们可以将其更新为使用RGB等效值，并使用PostCSS插件添加HEX值。如果我们愿意，甚至可以使用如postcss-rgba-hex之类的插件将RGBA颜色转换为纯HEX——你可能更喜欢使用前者，或者有需要使用该格式的流程。'
- en: '**Font support**: How about incorporating the font-magician plugin for PostCSS?
    If we look at the `variables` file created earlier, it will contain a number of
    fonts that are not standard (at least to Windows); it means that our WordPress
    theme will look a little plain, to say the least! Fortunately, we can use the
    font-magician plugin to provide font-face support for the non-standard fonts;
    most, such as Inconsolata, Open Sans, and Merriweather, are available from the
    Font Squirrel website at [http://www.fontsquirrel.com](http://www.fontsquirrel.com).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字体支持**：我们是否可以整合PostCSS的字体魔法师插件？如果我们查看之前创建的`variables`文件，它将包含一些非标准字体（至少对Windows来说是这样）；这意味着我们的WordPress主题看起来可能有点单调，至少可以说！幸运的是，我们可以使用字体魔法师插件为非标准字体提供font-face支持；大多数，如Inconsolata、Open
    Sans和Merriweather，都可以在Font Squirrel网站上找到，网址为[http://www.fontsquirrel.com](http://www.fontsquirrel.com)。'
- en: We've picked on just three ways to help extend your theme—with the use of a
    task runner such as Gulp, we are really only limited by the extent of what is
    available as plugins for Gulp. We don't have to limit ourselves to PostCSS plugins
    only; this will restrict what we can do, and mean that we're missing out on useful
    functionality. The key here is to consider what changes you want to make, and
    plan how and when you will make them—the process should be iterative, which will
    help with managing the changes!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只挑选了三种方法来帮助扩展你的主题——使用像Gulp这样的任务运行器，我们实际上只受Gulp插件可用性的限制。我们不必仅限于PostCSS插件；这将限制我们能做什么，意味着我们错过了有用的功能。这里的关键是考虑你想要做出哪些更改，并计划如何以及何时进行这些更改——这个过程应该是迭代的，这将有助于管理这些更改！
- en: Compiling and testing the changes
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试更改
- en: Over the last few pages, we've covered a number of key tasks that would be perfect
    for compiling WordPress themes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，我们介绍了一些非常适合编译WordPress主题的关键任务。
- en: In an ideal world, we would automate as much as possible, or at least tasks
    where it would make sense—to remove tasks that give little value when done manually,
    for example. The key, though, is to give plenty of thought as to which order these
    tasks should be carried out; getting the order right can be the difference between
    receiving a valid style sheet file ready for use, and getting…well, what can only
    be classed as rubbish! Yes, that might seem a little extreme, but if the task
    order isn't right, then you can get compiled files that break your theme.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们会尽可能地自动化，或者至少是那些有意义的任务——例如，移除手动执行时价值不大的任务。然而，关键是要充分考虑这些任务应该按照什么顺序执行；正确的顺序可能是得到一个有效样式表文件用于使用，和得到……好吧，只能称之为垃圾！是的，这听起来可能有些极端，但如果任务顺序不正确，那么你可能会得到破坏你主题的编译文件。
- en: Leaving this aside, let's take a look at compiling our code—for the purposes
    of this exercise, we will use a copy of the pre-edited files that are available
    in the code download that accompanies this book.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个放在一边，让我们来看看如何编译我们的代码——为了这个练习，我们将使用这本书附带的代码下载中可用的预编辑文件副本。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before continuing, you may like to save copies of the source files you've created
    in the `src` folder that sits at the root of our project area, for safe keeping.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想保存你创建在项目区域根目录下的`src`文件夹中的源文件副本，以备安全之需。
- en: 'To get a feel for what we will be discussing, this is a screenshot excerpt
    of the Twenty Sixteen theme in action:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家对我们将要讨论的内容有一个感性的认识，这是Twenty Sixteen主题实际应用的截图摘录：
- en: '![Compiling and testing the changes](img/BO5194_12_20.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![编译和测试更改](img/BO5194_12_20.jpg)'
- en: 'Let''s make a start:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: We'll start by downloading and extracting a copy of the `src` folder that is
    under `T68 - converting a WordPress theme` in the code download; save this to
    the root of our project area. Make sure there are *no* other files present in
    this folder first!
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先下载并解压`src`文件夹的副本，该文件夹位于代码下载中的`T68 - 转换WordPress主题`下；将其保存到我们的项目区域根目录。首先确保这个文件夹中没有任何其他文件！
- en: Next, make sure that the `gulpfile.js` and `package.json` files that we downloaded
    earlier are still present—we will need both during compilation.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请确保我们之前下载的`gulpfile.js`和`package.json`文件仍然存在——在编译过程中我们需要这两个文件。
- en: Go ahead and fire up a Node.js command prompt session, then change the working
    folder to the root of our project area.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请继续启动一个Node.js命令提示符会话，然后将工作文件夹更改为我们的项目区域根目录。
- en: At the prompt, enter `gulp` then press *Enter*; Gulp will run through each task
    and spit out a compiled theme file in the `dest` folder at the root of our project
    area.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入`gulp`然后按*Enter*键；Gulp将运行每个任务，并在我们的项目区域根目录的`dest`文件夹中输出一个编译后的主题文件。
- en: Copy this to the root of the `Twenty Sixteen` folder, which can be found at
    `C:\wamp\www\wordpress\wp-content\themes\twentysixteen`—if you use Linux or OSX,
    then please alter the path accordingly.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此复制到`Twenty Sixteen`文件夹的根目录，该文件夹位于`C:\wamp\www\wordpress\wp-content\themes\twentysixteen`——如果你使用Linux或OSX，请相应地更改路径。
- en: 'We now have a fully compiled style sheet! There are some points of note though—for
    example, the order of tasks that we covered earlier in this section doesn''t match
    the order shown in the `gulpfile.js` file. Let''s cover these points now:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全编译了样式表！但也有一些需要注意的点——例如，我们在这部分前面提到的任务顺序与`gulpfile.js`文件中显示的顺序不匹配。现在让我们来讨论这些点：
- en: The type of tasks you include can be split into two groups—those that I would
    describe as core, such as minifying files or providing source maps; these can
    be done for any sites. The second ones are custom tasks—these will be specific
    for each site, and might include requests to compile variables or nested code.
    It's up to you to plan how these are created, so that you can reuse them for future
    projects.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以包含的任务可以分为两组——我将其描述为核心任务，例如压缩文件或提供源映射；这些任务可以对任何网站执行。第二组是自定义任务——这些任务将针对每个网站特定，可能包括编译变量或嵌套代码的请求。如何规划这些任务的创建取决于你，这样你就可以在未来的项目中重复使用它们。
- en: 'There is no right or wrong answer as to what should be included in a Gulp task
    file; the tasks you want to include, and the order they are called, will ultimately
    be determined by your own requirements. In our example, we used this order, from
    top to bottom:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于一个Gulp任务文件应该包含什么，没有正确或错误答案；你想要包含的任务以及它们的调用顺序最终将由你的需求决定。在我们的例子中，我们使用了以下顺序，从上到下：
- en: '| Name of task | Purpose |'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 任务名称 | 目的 |'
- en: '| --- | --- |'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `styles` | This compiled the raw code—merging the rules into one file, running
    PreCSS through the code, and updating vendor prefixes where needed. |'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `styles` | 这个任务编译了原始代码——将规则合并到一个文件中，通过PreCSS处理代码，并在需要的地方更新供应商前缀。 |'
- en: '| `pxrem` | With the base code in place, we can now run through it and add
    pixel fallback for rem units, where appropriate. |'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `pxrem` | 在设置好基本代码后，我们现在可以运行它，并为rem单位添加适当的像素回退。 |'
- en: '| `lint` | In this task, we''re checking the compiled code for consistency.
    |'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `lint` | 在这个任务中，我们正在检查编译后的代码的一致性。 |'
- en: '| `rename` | We then rename our base compiled file to have a `.min.css` extension;
    this is in preparation for minifying our code. |'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `rename` | 然后，我们将我们的基本编译文件重命名为具有`.min.css`扩展名；这是为了准备压缩我们的代码。 |'
- en: '| `sourcemap` | At this stage, we want to produce a source map, so this task
    kicks in to create a suitable map file for us. |'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `sourcemap` | 在这个阶段，我们想要生成一个源映射，因此这个任务会启动以为我们创建一个合适的映射文件。 |'
- en: '| `minifyCSS` | The final task is to minify the CSS style sheet file—it already
    has the right extension in place. |'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `minifyCSS` | 最后的任务是压缩CSS样式表文件——它已经具有正确的扩展名。 |'
- en: We've done the hard work—it's time to see the fruits of our labor in action.
    The style sheet is now in the `theme` folder within our WordPress installation—all
    that remains is to test it! We could get into using automated testing facilities
    such as Quixote (available from [http://www.quixote-css.com/](http://www.quixote-css.com/)),
    but this would fall outside of the scope of this book. Instead, we can simply
    launch our local WordPress installation and check to see what it looks like—this
    is a useful way to gauge if there is anything amiss with our theme.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了艰苦的工作——现在是时候看到我们劳动成果的实际效果了。样式表现在位于我们WordPress安装的`theme`文件夹中——剩下的只是测试它！我们可以使用自动化测试工具，如Quixote（可在[http://www.quixote-css.com/](http://www.quixote-css.com/)找到），但这将超出本书的范围。相反，我们可以简单地启动我们的本地WordPress安装，查看它看起来如何——这是一种有用的方法来评估我们的主题是否有任何问题。
- en: For our demo, we used the Twenty Sixteen theme. Out of the box, this is a very
    bare theme. Although this may not seem much, we've done most of the hard work
    needed to implement a PostCSS workflow when working with WordPress. A key measure
    of success is that the base theme should be identical to the original version
    that came with WordPress. If this is the case, it then means we can now concentrate
    on manipulating our style sheet over a period of time to further develop the styles
    within this (or any other) theme.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的演示，我们使用了Twenty Sixteen主题。这个主题默认情况下非常简洁。虽然这看起来可能不多，但我们已经完成了在WordPress中实现PostCSS工作流程所需的大部分艰苦工作。成功的关键衡量标准是基础主题应该与WordPress附带的原版完全相同。如果是这样，那么这意味着我们现在可以集中精力在一段时间内操纵我们的样式表，以进一步开发这个（或任何其他）主题中的样式。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The success of using PostCSS will be partially determined by how well your code
    comes across from existing processors such as SASS—this will come from planning
    and taking an iterative approach to converting code. We've covered a lot of tips
    and ideas to help with the process, so let's take a moment to review what we've
    learnt.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PostCSS的成功将部分取决于你的代码从现有的处理器（如SASS）转换得有多好——这需要规划和采用迭代的方法来转换代码。我们已经介绍了很多技巧和想法来帮助这个过程，所以让我们花点时间回顾一下我们已经学到的内容。
- en: We kicked off with a look at exploring the conversion process, and covered some
    of the plugins we might use to help with the process. We then moved on to covering
    the Pleeease library, with a look at installing and configuring it before using
    it in a quick demo.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从探讨转换过程开始，并介绍了一些可能用到的插件来帮助这个过程。然后我们转向介绍Pleeease库，在快速演示中使用它之前，我们查看如何安装和配置它。
- en: Next up came a quick discussion about why Pleeease may not be as useful as we
    first thought; we then covered using the PreCSS library as a better alternative
    for transitioning to PostCSS.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简要讨论了为什么Pleeease可能不像我们最初认为的那么有用；然后我们介绍了使用PreCSS库作为过渡到PostCSS的更好替代方案。
- en: We then explored using PreCSS in some depth by working through making changes
    to a standard theme for WordPress—we discovered some of the tips and tricks we
    can use to score quick wins when making the initial changes. We then rounded out
    the chapter with a look at compiling our code, and checking it in a standard WordPress
    installation to ensure it is still working as we would expect to see it operating.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入探讨了使用PreCSS，通过为WordPress的标准主题进行修改来工作——我们发现了我们可以在初始更改时使用的一些技巧和窍门来快速取得成效。然后，我们通过查看编译我们的代码，并在标准WordPress安装中检查它以确保它仍然按预期工作来结束这一章。
- en: Phew, we've covered a lot! With careful planning and using an iterative approach,
    we can transition from using processors such as SASS, and move to using PostCSS.
    However, sometimes our code may not work as expected—there are a few places where
    our code may trip up, so we'll cover them in the next chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸，我们已经覆盖了很多内容！通过仔细规划和采用迭代的方法，我们可以从使用处理器如SASS过渡到使用PostCSS。然而，有时我们的代码可能不会按预期工作——我们的代码可能在几个地方出现问题，所以我们将在下一章中介绍它们。
