- en: Functional Programming Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning how to work with functions in detail, mastering asynchronous
    programming, and going through the main characteristics of the JavaScript runtime,
    we are now fully ready to focus on functional programming. In this chapter, we
    are going to focus on the most fundamental functional programming techniques and
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try to avoid using external libraries and we are going to implement
    some of these techniques and patterns from scratch. This will be slightly more
    tedious, but it will help us to fully understand how these techniques work internally.
    Please note that some of these implementations have been simplified and do not
    cover all the potential edge cases. In an actual production system, using a well-tested
    functional programming library  is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following functional programming
    techniques and patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-free style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about some functional programming techniques
    that are very closely linked to function composition. We are going to learn about
    composition, partial application, currying, and pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional composition** is a technique or pattern that allows us to combine
    multiple functions to create a more complex function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares two simple functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That two simple functions declared by the preceding code snippet are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A function used to trim a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function used to transform a piece of text into uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a function that performs both of the preceding operations by
    composing them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`trimAndCapitalize` is a function that invokes the `trim` function (using `s`
    as its argument) and passes its return to the capitalize function. We can invoke
    the `trimAndCapitalize` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The composition of two functions, `f(x)` and `g(x)`, is defined as `f(g(x))`,
    and that is exactly what we have done in the implementation of the `trimAndCapitalize`
    function. However, such a behavior can be abstracted using a higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the preceding function to compose two given functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke the `trimAndCapitalize` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to note is that the return of the `g` function is passed
    as the argument of the `f` function. This means that `f` can only take one argument
    (it must be a unary function). The type of the only argument of `f` must match
    the return type of the `g` function. These limitations can be expressed in a more
    correct definition of the `compose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compose in functions generated with the `compose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can declare a higher-order function to compose three functions in a single
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a helper that allows us to compose an unlimited number of
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Functional composition is an extremely powerful technique, but it can be hard
    to put into practice in certain scenarios, for example, when our functions are
    not unary functions. However, there are other techniques, such as functional partial
    application, that can help in those scenarios, as we will see in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Partial application** is a functional programming technique that allows us
    to pass the arguments required by a function at different points in time.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique can feel like a weird idea at first glance, because most software
    engineers are used to the idea of applying or invoking a function at a unique
    point in time (complete application), as opposed to applying a function at multiple
    points in time (partial application).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet implements a function that doesn''t support partial
    application and invokes it (providing all the required arguments) at a single
    point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet implements the preceding function using a higher-order
    function to allow us to provide the required arguments at different points in
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the first and second arguments
    are provided at a different point in time. However, the preceding cannot be considered
    an example of functional partial application because the two functions are unary
    functions and we have provided one argument at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write a function that allows both its complete and partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be considered an example of partial application because
    we can apply a function with all its arguments (complete application), or just
    some of them (partial application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how functional partial application works, let''s focus on
    why it is useful. In the preceding section on function composition, we learned
    how to compose two functions, named `trim` and `capitalize`, into a third function,
    named `trimAndCapitalize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Function composition works very well with unary functions, but not so well
    with binary, ternary, or variadic functions. We are going to declare the following
    function to demonstrate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function can be used to replace a substring in a given string.
    Unfortunately, the function cannot be easily used with the `compose ` function
    because it is not a unary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can implement the function in a way that allows us to apply the
    function partially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `compose` function without any difficulties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to our knowledge of functional partial application, we can easily use
    the `compose` function without having to worry about the arity of the functions.
    However, enabling partial application requires a significant amount of manual
    boilerplate. In the next section, we will learn how a functional programming technique,
    known as **currying**, can help us to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currying is a functional programming technique that allows us to partially
    apply a function without having to worry about the way in which we implement our
    functions. Currying is the process of taking a function that takes multiple arguments
    and transforming it into a chain of unary functions. The following function allows
    us to transform a function, `fn`, which takes two arguments, `a` and `b`, into
    a function that takes one argument, `a`, and returns another function that takes
    one argument, `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The above function is a higher-order function that allows our functions to be
    partially applied while keeping their implementation agnostic of this concern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `curry2` function allows us to transform a binary function into two unary
    functions. The `curry2` function is a higher-order function and can be used with
    any binary function. For example, in the preceding code snippet, we passed the
    `add` function to the `curry2` function, but the following example passes the
    `multiply` function to the `curry2` function instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding section on functional partial application, we learned how
    to use partial application to use `compose` with functions that are not unary.
    We declared the following function named `replace` and then passed it to the `compose`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare a function named `curry3`, which transforms a ternary function
    into a chain of three unary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `curry3` function to rewrite the `replace` function in
    a way that is agnostic of the functional partial application implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: strictBindCallApply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We explored a few potential ways to implement partial application earlier in
    this chapter. However, we avoided an alternative implementation that uses the
    `function.prototype.bind` method. We have done this because the `bind` method
    was unsafe in TypeScript versions prior to the 3.2 release. If we install TypeScript
    version 3.2 or higher, and we enable the `strictBindCallApply` compilation flag
    in the `tsconfig.json` file, we will be able to use `bind` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `bind` method allows us to apply the function partially.
    We can rewrite the currying example that we implemented earlier in this chapter
    and use the `bind` method instead of the currying function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `strictBindCallApply` compilation flag ensures that the return as a result
    of invoking the `bind` method will have the correct type. In versions of TypeScript
    prior to 3.2, the return of the `bind` method was of the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `pipe` is a function or operator that allows us to pass the output of a function
    as the input of another. JavaScript and TypeScript don''t support pipes natively
    (as an operator), but we can implement our pipes using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `curry3`, `trim`, `capitalize`, and `replace` functions
    that we declared previously in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `pipe` function to declare a new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `pipe` function ensures that the output of the `trim` function is passed
    to the `capitalize` function. The return of the `capitalize` function is then
    passed to the `replace` function, which has already been applied in part.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an official proposal to add a new operator to JavaScript known as
    the pipeline operator (`|>`). This operator will allow us to use pipes natively
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to the pipeline operator proposal ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take a look at other functional programming
    techniques that are not directly related to  function composition.
  prefs: []
  type: TYPE_NORMAL
- en: Point-free style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Point-free style**, also known as **Tacit** programming, is a programming
    style in which function declarations do not declare the arguments (or *points*)
    on which they operate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet declares a few functions that are used to determine
    whether a person is eligible to vote in elections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet didn''t use any of the functional programming techniques
    that we have already learned in this chapter. The following code snippet implements
    an alternative solution for the same problem using techniques such as partial
    application. This code snippet declares two functions, named `both` and `either`,
    that can be used to determine whether a variable matches the requirements specified
    by some or both functions provided to these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `either` and `both` functions are simplified implementations of some real
    algebraic data types. We will learn more about algebraic data types and category
    theory in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `isCitizen` and `isElegibleToVote` functions take some functions
    as arguments, but they don''t mention which data types they expect as arguments.
    For example, instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This style, in which we avoid referencing function arguments, is known as the
    point-free style, and it has a number of advantages over the more conventional
    function declaration style:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes programs simpler and more concise. This isn't always a good thing,
    but it can be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes algorithms easier to understand by focusing only on the functions being
    combined. We get a better sense of what's going on without the data arguments
    getting in the way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forces us to think more about how data is used than about which data is being
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps us think about our functions as generic building blocks that can work
    with different kinds of data, rather than thinking about them as operations on
    one kind of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the entire example is included in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function that calls itself is known as a recursive function. The following
    function is a recursive function and allows us to calculate the factorial of a
    given number, `n`. The factorial is the product of all positive integers less
    than, or equal to, a given number, `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can invoke the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In general, you should try to implement functions without recursion. Using recursion
    should be considered carefully because the JavaScript runtime is not very efficient
    at handling it since, in a recursive function call, a frame is added to the stack
    with each function call.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching allows you to match a value (or an object) against some patterns
    to select a branch of the code. In functional languages, pattern matching can
    be used to match on standard primitive values such as strings. TypeScript allows
    us to implement pattern matching using literal types and control flow analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define three types, named `Circle`, `Square`, and `Rectangle`.
    We can then define a new type, named `Shape`, which is the union of the `Circle`,
    `Square`, and `Rectangle` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then implement functions that take an argument of the `Shape` type and
    use pattern matching to identify whether the `Shape` is a `Circle`, a `Square`,
    or a `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching was impossible in versions of TypeScript prior to 2.0 because
    control flow analysis and literal types were not available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned some of the main functional programming techniques
    and patterns, including functional composition, functional partial application,
    and currying.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about category theory. We will learn
    how to work with some algebraic data types and how they can help make our TypeScript
    applications more robust.
  prefs: []
  type: TYPE_NORMAL
