- en: Functional Programming Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程技术
- en: After learning how to work with functions in detail, mastering asynchronous
    programming, and going through the main characteristics of the JavaScript runtime,
    we are now fully ready to focus on functional programming. In this chapter, we
    are going to focus on the most fundamental functional programming techniques and
    patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细学习了如何处理函数、掌握了异步编程以及了解了JavaScript运行时的主要特性之后，我们现在完全准备好专注于函数式编程。在本章中，我们将关注最基础的函数式编程技术和模式。
- en: We are going to try to avoid using external libraries and we are going to implement
    some of these techniques and patterns from scratch. This will be slightly more
    tedious, but it will help us to fully understand how these techniques work internally.
    Please note that some of these implementations have been simplified and do not
    cover all the potential edge cases. In an actual production system, using a well-tested
    functional programming library  is recommended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽量避免使用外部库，并从头实现一些这些技术和模式。这将稍微有些繁琐，但将帮助我们完全理解这些技术是如何在内部工作的。请注意，以下实现已经简化，并不涵盖所有潜在的边缘情况。在实际的生产系统中，建议使用经过良好测试的函数式编程库。
- en: 'In this chapter, we are going to learn about the following functional programming
    techniques and patterns:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下函数式编程技术和模式：
- en: Composition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Partial application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用
- en: Currying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Pipes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Point-free style
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无参数风格
- en: Recursion
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Pattern matching
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Composition techniques
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合技术
- en: In this section, we are going to learn about some functional programming techniques
    that are very closely linked to function composition. We are going to learn about
    composition, partial application, currying, and pipes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些与函数组合非常紧密相关的函数式编程技术。我们将学习组合、部分应用、柯里化和管道。
- en: Composition
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成
- en: '**Functional composition** is a technique or pattern that allows us to combine
    multiple functions to create a more complex function.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数组合**是一种技术或模式，它允许我们将多个函数组合成一个更复杂的函数。'
- en: 'The following code snippet declares two simple functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了两个简单函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That two simple functions declared by the preceding code snippet are the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中声明的两个简单函数如下：
- en: A function used to trim a string
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于修剪字符串的函数
- en: A function used to transform a piece of text into uppercase
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于将文本转换为上档的函数
- en: 'We can create a function that performs both of the preceding operations by
    composing them as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式组合前两个操作来创建一个执行这两个操作的函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`trimAndCapitalize` is a function that invokes the `trim` function (using `s`
    as its argument) and passes its return to the capitalize function. We can invoke
    the `trimAndCapitalize` function as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`trimAndCapitalize`是一个函数，它调用`trim`函数（使用`s`作为其参数）并将返回值传递给`capitalize`函数。我们可以这样调用`trimAndCapitalize`函数：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The composition of two functions, `f(x)` and `g(x)`, is defined as `f(g(x))`,
    and that is exactly what we have done in the implementation of the `trimAndCapitalize`
    function. However, such a behavior can be abstracted using a higher-order function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数`f(x)`和`g(x)`的组合定义为`f(g(x))`，这正是我们在`trimAndCapitalize`函数实现中所做的。然而，这种行为可以使用高阶函数进行抽象：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can then use the preceding function to compose two given functions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的函数来组合两个给定的函数：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then invoke the `trimAndCapitalize` function as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式调用`trimAndCapitalize`函数：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One important thing to note is that the return of the `g` function is passed
    as the argument of the `f` function. This means that `f` can only take one argument
    (it must be a unary function). The type of the only argument of `f` must match
    the return type of the `g` function. These limitations can be expressed in a more
    correct definition of the `compose` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要事项是`g`函数的返回值被传递为`f`函数的参数。这意味着`f`只能接受一个参数（它必须是一元函数）。`f`的唯一参数的类型必须与`g`函数的返回类型相匹配。这些限制可以用`compose`函数的更正确的定义来表示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also compose in functions generated with the `compose` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`compose`函数生成的函数进行组合：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: 'Or we can declare a higher-order function to compose three functions in a single
    call:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以声明一个高阶函数，在单个调用中组合三个函数：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can then invoke it as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式调用它：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also create a helper that allows us to compose an unlimited number of
    functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个辅助函数，允许我们组合无限数量的函数：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then invoke it as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式调用它：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Functional composition is an extremely powerful technique, but it can be hard
    to put into practice in certain scenarios, for example, when our functions are
    not unary functions. However, there are other techniques, such as functional partial
    application, that can help in those scenarios, as we will see in the following
    section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是一个非常强大的技术，但在某些场景中可能很难实施，例如，当我们的函数不是一元函数时。然而，有其他技术，如函数式部分应用，可以帮助在这些场景中，正如我们将在下一节中看到的那样。
- en: Partial application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: '**Partial application** is a functional programming technique that allows us
    to pass the arguments required by a function at different points in time.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分应用**是一种函数式编程技术，它允许我们在不同时间点传递函数所需的参数。'
- en: This technique can feel like a weird idea at first glance, because most software
    engineers are used to the idea of applying or invoking a function at a unique
    point in time (complete application), as opposed to applying a function at multiple
    points in time (partial application).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在第一眼看起来可能像是一个奇怪的想法，因为大多数软件工程师习惯于在唯一的时间点应用或调用一个函数（完整应用），而不是在多个时间点应用一个函数（部分应用）。
- en: 'The following code snippet implements a function that doesn''t support partial
    application and invokes it (providing all the required arguments) at a single
    point in time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段实现了一个不支持部分应用的函数，并在一个时间点调用它（提供所有所需的参数）：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following code snippet implements the preceding function using a higher-order
    function to allow us to provide the required arguments at different points in
    time:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用高阶函数实现前面的函数，允许我们在不同时间点提供所需的参数：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see in the preceding code snippet, the first and second arguments
    are provided at a different point in time. However, the preceding cannot be considered
    an example of functional partial application because the two functions are unary
    functions and we have provided one argument at a time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，第一和第二个参数是在不同时间提供的。然而，前面的例子不能被视为函数式部分应用的例子，因为这两个函数是一元函数，我们一次提供了一个参数。
- en: 'We can also write a function that allows both its complete and partial application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写一个允许其完整和部分应用的函数：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example can be considered an example of partial application because
    we can apply a function with all its arguments (complete application), or just
    some of them (partial application).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以被视为部分应用的例子，因为我们既可以应用带有所有参数的函数（完整应用），也可以只应用其中的一些（部分应用）。
- en: 'Now that we know how functional partial application works, let''s focus on
    why it is useful. In the preceding section on function composition, we learned
    how to compose two functions, named `trim` and `capitalize`, into a third function,
    named `trimAndCapitalize`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数式部分应用是如何工作的，让我们关注一下为什么它是有用的。在前面的函数组合部分，我们学习了如何将名为`trim`和`capitalize`的两个函数组合成一个名为`trimAndCapitalize`的第三个函数：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Function composition works very well with unary functions, but not so well
    with binary, ternary, or variadic functions. We are going to declare the following
    function to demonstrate it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合与一元函数配合得非常好，但与二元、三元或可变参数函数配合得不是很好。我们将声明以下函数来演示这一点：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding function can be used to replace a substring in a given string.
    Unfortunately, the function cannot be easily used with the `compose ` function
    because it is not a unary function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数可以用作替换给定字符串中的子串。不幸的是，由于它不是一元函数，因此该函数不能轻易与`compose`函数一起使用：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, we can implement the function in a way that allows us to apply the
    function partially:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以以允许我们在不同时间点应用函数参数的方式实现该函数：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then use the `compose` function without any difficulties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以无困难地使用`compose`函数：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thanks to our knowledge of functional partial application, we can easily use
    the `compose` function without having to worry about the arity of the functions.
    However, enabling partial application requires a significant amount of manual
    boilerplate. In the next section, we will learn how a functional programming technique,
    known as **currying**, can help us to solve this problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们掌握了函数式部分应用的知识，我们可以轻松地使用 `compose` 函数，而无需担心函数的arity（元数）。然而，启用部分应用需要大量的手动样板代码。在下一节中，我们将学习一种名为
    **柯里化** 的函数式编程技术，它可以帮助我们解决这个问题。
- en: Currying
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Currying is a functional programming technique that allows us to partially
    apply a function without having to worry about the way in which we implement our
    functions. Currying is the process of taking a function that takes multiple arguments
    and transforming it into a chain of unary functions. The following function allows
    us to transform a function, `fn`, which takes two arguments, `a` and `b`, into
    a function that takes one argument, `a`, and returns another function that takes
    one argument, `b`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一种函数式编程技术，它允许我们在不担心函数实现方式的情况下部分应用一个函数。柯里化是将接受多个参数的函数转换为一系列一元函数的过程。以下函数允许我们将接受两个参数
    `a` 和 `b` 的函数 `fn` 转换为接受一个参数 `a` 的函数，并返回另一个接受一个参数 `b` 的函数：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The above function is a higher-order function that allows our functions to be
    partially applied while keeping their implementation agnostic of this concern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数是一个高阶函数，它允许我们的函数在部分应用的同时，保持其实现与这一关注点无关。
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `curry2` function allows us to transform a binary function into two unary
    functions. The `curry2` function is a higher-order function and can be used with
    any binary function. For example, in the preceding code snippet, we passed the
    `add` function to the `curry2` function, but the following example passes the
    `multiply` function to the `curry2` function instead:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry2` 函数允许我们将二元函数转换为两个一元函数。`curry2` 函数是一个高阶函数，可以与任何二元函数一起使用。例如，在前面的代码片段中，我们将
    `add` 函数传递给 `curry2` 函数，但以下示例将 `multiply` 函数传递给 `curry2` 函数：'
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding section on functional partial application, we learned how
    to use partial application to use `compose` with functions that are not unary.
    We declared the following function named `replace` and then passed it to the `compose`
    function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面关于函数式部分应用的章节中，我们学习了如何使用部分应用来与不是一元的函数一起使用 `compose`。我们声明了一个名为 `replace` 的函数，并将其传递给
    `compose` 函数：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can declare a function named `curry3`, which transforms a ternary function
    into a chain of three unary functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明一个名为 `curry3` 的函数，它将三元函数转换为一系列三个一元函数：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then use the `curry3` function to rewrite the `replace` function in
    a way that is agnostic of the functional partial application implementation details:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `curry3` 函数以与函数式部分应用实现细节无关的方式重写 `replace` 函数：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Please note that the entire example is included in the companion source code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: strictBindCallApply
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: strictBindCallApply
- en: 'We explored a few potential ways to implement partial application earlier in
    this chapter. However, we avoided an alternative implementation that uses the
    `function.prototype.bind` method. We have done this because the `bind` method
    was unsafe in TypeScript versions prior to the 3.2 release. If we install TypeScript
    version 3.2 or higher, and we enable the `strictBindCallApply` compilation flag
    in the `tsconfig.json` file, we will be able to use `bind` as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们探索了几种实现部分应用的方法。然而，我们避免了一种使用 `Function.prototype.bind` 方法的替代实现。我们这样做是因为在
    TypeScript 3.2 版本之前的 TypeScript 中，`bind` 方法是不安全的。如果我们安装 TypeScript 3.2 或更高版本，并在
    `tsconfig.json` 文件中启用 `strictBindCallApply` 编译标志，我们就可以像下面这样使用 `bind`：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see, the `bind` method allows us to apply the function partially.
    We can rewrite the currying example that we implemented earlier in this chapter
    and use the `bind` method instead of the currying function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`bind` 方法允许我们部分应用函数。我们可以重写本章前面实现的柯里化示例，并用 `bind` 方法代替柯里化函数：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `strictBindCallApply` compilation flag ensures that the return as a result
    of invoking the `bind` method will have the correct type. In versions of TypeScript
    prior to 3.2, the return of the `bind` method was of the `any` type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictBindCallApply` 编译标志确保调用 `bind` 方法返回的结果将具有正确的类型。在 TypeScript 3.2 版本之前的版本中，`bind`
    方法的返回类型是 `any`。'
- en: Pipes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'A `pipe` is a function or operator that allows us to pass the output of a function
    as the input of another. JavaScript and TypeScript don''t support pipes natively
    (as an operator), but we can implement our pipes using the following function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一个函数或操作符，它允许我们将一个函数的输出作为另一个函数的输入。JavaScript和TypeScript本身不支持管道操作符（作为一个操作符），但我们可以使用以下函数来实现我们的管道：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are going to use the `curry3`, `trim`, `capitalize`, and `replace` functions
    that we declared previously in this chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在本章中先前声明的`curry3`、`trim`、`capitalize`和`replace`函数：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then use the `pipe` function to declare a new function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pipe`函数来声明一个新的函数：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `pipe` function ensures that the output of the `trim` function is passed
    to the `capitalize` function. The return of the `capitalize` function is then
    passed to the `replace` function, which has already been applied in part.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`函数确保`trim`函数的输出被传递给`capitalize`函数。然后，`capitalize`函数的返回值被传递给`replace`函数，该函数已经部分应用。'
- en: 'There is an official proposal to add a new operator to JavaScript known as
    the pipeline operator (`|>`). This operator will allow us to use pipes natively
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 已有官方提案建议为JavaScript添加一个新操作符，称为管道操作符（`|>`）。此操作符将允许我们以如下方式原生化地使用管道：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Please refer to the pipeline operator proposal ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))
    to learn more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅管道操作符提案（[https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)）以了解更多信息。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例都包含在配套源代码中。
- en: Other techniques
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技术
- en: In this section, we are going to take a look at other functional programming
    techniques that are not directly related to  function composition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些与函数组合不直接相关的其他函数式编程技术。
- en: Point-free style
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无参数风格
- en: '**Point-free style**, also known as **Tacit** programming, is a programming
    style in which function declarations do not declare the arguments (or *points*)
    on which they operate.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**无参数风格**，也称为**隐式编程**，是一种编程风格，其中函数声明不声明它们操作的参数（或*点*）。'
- en: 'The following code snippet declares a few functions that are used to determine
    whether a person is eligible to vote in elections:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一些用于确定一个人是否有资格参加选举的函数：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code snippet didn''t use any of the functional programming techniques
    that we have already learned in this chapter. The following code snippet implements
    an alternative solution for the same problem using techniques such as partial
    application. This code snippet declares two functions, named `both` and `either`,
    that can be used to determine whether a variable matches the requirements specified
    by some or both functions provided to these functions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段没有使用本章我们已经学到的任何函数式编程技术。以下代码片段使用部分应用等技术为相同问题实现了一个替代解决方案。此代码片段声明了两个函数，分别命名为`both`和`either`，可用于确定变量是否匹配由提供给这些函数的某些或所有函数指定的要求：
- en: The `either` and `both` functions are simplified implementations of some real
    algebraic data types. We will learn more about algebraic data types and category
    theory in the next chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`either`和`both`函数是某些实际代数数据类型的简化实现。我们将在下一章中了解更多关于代数数据类型和范畴论的内容。'
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, the `isCitizen` and `isElegibleToVote` functions take some functions
    as arguments, but they don''t mention which data types they expect as arguments.
    For example, instead of writing the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`isCitizen`和`isElegibleToVote`函数接受一些函数作为参数，但它们没有说明期望的参数数据类型。例如，我们不必写以下内容：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can write the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写出以下内容：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This style, in which we avoid referencing function arguments, is known as the
    point-free style, and it has a number of advantages over the more conventional
    function declaration style:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种避免引用函数参数的风格被称为无参数风格，它比更传统的函数声明风格具有许多优点：
- en: It makes programs simpler and more concise. This isn't always a good thing,
    but it can be.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使程序更简单、更简洁。这并不总是好事，但有时是。
- en: It makes algorithms easier to understand by focusing only on the functions being
    combined. We get a better sense of what's going on without the data arguments
    getting in the way.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过仅关注组合的函数来简化算法的理解。我们可以在数据参数干扰的情况下更好地理解正在发生的事情。
- en: It forces us to think more about how data is used than about which data is being
    used.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它迫使我们更多地思考数据的使用方式，而不是使用的数据类型。
- en: It helps us think about our functions as generic building blocks that can work
    with different kinds of data, rather than thinking about them as operations on
    one kind of data.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它帮助我们以通用构建块的方式思考我们的函数，这些构建块可以与不同类型的数据一起工作，而不是将它们视为对一种数据类型的操作。
- en: Please note that the entire example is included in the companion source code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整个示例包含在配套源代码中。
- en: Recursion
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'A function that calls itself is known as a recursive function. The following
    function is a recursive function and allows us to calculate the factorial of a
    given number, `n`. The factorial is the product of all positive integers less
    than, or equal to, a given number, `n`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调用自身的函数被称为递归函数。以下是一个递归函数，它允许我们计算给定数字`n`的阶乘。阶乘是所有小于或等于给定数字`n`的正整数的乘积：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can invoke the preceding function as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下调用前面的函数：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In general, you should try to implement functions without recursion. Using recursion
    should be considered carefully because the JavaScript runtime is not very efficient
    at handling it since, in a recursive function call, a frame is added to the stack
    with each function call.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该尝试不使用递归来实现函数。使用递归应该仔细考虑，因为JavaScript运行时在处理递归时并不非常高效，因为在递归函数调用中，每次函数调用都会在栈上添加一个帧。
- en: Pattern matching
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching allows you to match a value (or an object) against some patterns
    to select a branch of the code. In functional languages, pattern matching can
    be used to match on standard primitive values such as strings. TypeScript allows
    us to implement pattern matching using literal types and control flow analysis.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配允许你将一个值（或一个对象）与一些模式进行匹配，以选择代码的某个分支。在函数式语言中，模式匹配可以用来匹配标准原始值，如字符串。TypeScript允许我们使用字面量类型和控制流分析来实现模式匹配。
- en: 'For example, we can define three types, named `Circle`, `Square`, and `Rectangle`.
    We can then define a new type, named `Shape`, which is the union of the `Circle`,
    `Square`, and `Rectangle` types:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义三个类型，分别命名为`Circle`、`Square`和`Rectangle`。然后，我们可以定义一个新的类型，命名为`Shape`，它是`Circle`、`Square`和`Rectangle`类型的并集：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then implement functions that take an argument of the `Shape` type and
    use pattern matching to identify whether the `Shape` is a `Circle`, a `Square`,
    or a `Rectangle`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现接受`Shape`类型参数的函数，并使用模式匹配来识别`Shape`是`Circle`、`Square`还是`Rectangle`：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Pattern matching was impossible in versions of TypeScript prior to 2.0 because
    control flow analysis and literal types were not available.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript 2.0之前的版本中，模式匹配是不可能的，因为控制流分析和字面量类型不可用。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned some of the main functional programming techniques
    and patterns, including functional composition, functional partial application,
    and currying.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些主要的函数式编程技术和模式，包括函数式组合、函数式部分应用和柯里化。
- en: In the next chapter, we are going to learn about category theory. We will learn
    how to work with some algebraic data types and how they can help make our TypeScript
    applications more robust.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于范畴论的内容。我们将学习如何处理一些代数数据类型以及它们如何帮助我们使TypeScript应用程序更加健壮。
