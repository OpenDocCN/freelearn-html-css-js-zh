<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Functional Reactive Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Functional Reactive Programming</h1></div></div></div><p>If you are a frontend or backend JavaScript developer who works on large and complex JavaScript applications and deals with a lot of code that responds to asynchronous data updates, user activities, and system activities, then it's perhaps the best time to <a id="id238" class="indexterm"/>explore <span class="strong"><strong>functional reactive programming</strong></span> (<span class="strong"><strong>FRP</strong></span>), as it's a time-saving, bug-preventing, easy-to-read, and modularized style of writing code. You don't need to know any functional programming language or be a hardcore functional language programmer; rather, you just need to know the basics of functional programming. In this chapter, we will learn how to use FRP using <code class="literal">Bacon.js</code>, which is an FRP library for both frontend and backend JavaScript.</p><p>We'll cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reactive programming in a nutshell</li><li class="listitem" style="list-style-type: disc">Problems with writing reactive code in JavaScript</li><li class="listitem" style="list-style-type: disc">Introduction to functional programming</li><li class="listitem" style="list-style-type: disc">What FRP is</li><li class="listitem" style="list-style-type: disc">The building blocks of FRP</li><li class="listitem" style="list-style-type: disc">The advantages of FRP</li><li class="listitem" style="list-style-type: disc">All the APIs provided by Bacon.js</li></ul></div><div class="section" title="Introduction to reactive programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec34"/>Introduction to reactive programming</h1></div></div></div><p>Before we get into FRP, we need to understand what it is. I will be explaining reactive programming <a id="id239" class="indexterm"/>with respect to JavaScript. The concept of reactive programming is the same in every programming language.</p><p>
<span class="strong"><strong>Reactive programming</strong></span> is writing code to look for asynchronous data updates, user activities, and system activities and propagate changes onto the dependent parts of the application. Reactive programming is not something new; believe it or not, you have already been doing reactive programming without realizing it. For example, the code you write to <a id="id240" class="indexterm"/>handle a button's click event is reactive code. There are various approaches to reactive programming, such as event-driven, callback, promise patterns and FRP.</p><p>Not every snippet of asynchronous code we write is reactive code. For example, uploading analytics data to a server asynchronously after a page load is not reactive code. But uploading a file to a server asynchronously and displaying a message to the user after the upload is complete is reactive code because we are reacting to the completion of the file upload.</p><p>A more complex example of reactive programming is in the MVC architecture, where reactive programming is what reacts to a change in the model and updates the view accordingly, and vice versa.</p><div class="section" title="Problems with writing reactive code"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>Problems with writing reactive code</h2></div></div></div><p>There are <a id="id241" class="indexterm"/>basically three patterns natively supported by JavaScript for <a id="id242" class="indexterm"/>writing reactive code: <span class="strong"><strong>event-driven</strong></span>, <span class="strong"><strong>callback</strong></span>,<span class="strong"><strong> </strong></span>and <span class="strong"><strong>promise</strong></span>.</p><p>Anyone <a id="id243" class="indexterm"/>who knows a bit of JavaScript is familiar with event-driven and callback patterns. Although these two patterns are the most popular way of writing <a id="id244" class="indexterm"/>reactive code, they make it difficult to catch exceptions and result in nested function calls, which makes the code harder to read and debug.</p><p>Due to the problems caused by event-driven and callback patterns, ES6 (<a class="ulink" href="https://www.packtpub.com/web-development/learning-ecmascript-6">https://www.packtpub.com/web-development/learning-ecmascript-6</a>) introduced the promise pattern. The promise pattern makes the code look more like synchronous code, therefore making it easy to read and debug. The pattern also makes exception handling easier. A promise represents an asynchronous operation.</p><p>But the promise pattern has a problem, that is, a promise can be resolved only once. The promise pattern can only respond to a single activity or data update of an asynchronous operation. For example, if we make an AJAX request using a promise pattern, then we can handle only <span class="emphasis"><em>request success</em></span> and <span class="emphasis"><em>failure</em></span> activities and not the states of the request and response cycle, such as weather server connections that have been established and response headers received. Similarly, if we handle a user click activity using a promise pattern, then we can handle only the first click, not the ones occurring after it, because the promise gets resolved in the first click.</p><p>You may or may not be familiar with the promise pattern, so let's look at some sample code of what a promise pattern looks like:</p><div class="informalexample"><pre class="programlisting">$http("http://example.com/data.json").then(function(){
  //do something
}).then(function(){
  //do something more here
}).then(function(){
  //do something more here
}).catch(function(){
  //handle error
})</pre></div><p>Here, the <code class="literal">$http()</code> method <a id="id245" class="indexterm"/>makes an HTTP request asynchronously and returns a promise. The promise is resolved if the request is successful, and the callback passed to the first <code class="literal">then()</code> method is invoked, that is, the promise is resolved. If the request fails, then the callback is passed to the <code class="literal">catch()</code> method, which is invoked, and the promise is rejected. The <code class="literal">then()</code> method always returns a promise, making it possible to run multiple asynchronous operations one after another. In the code, you can see how asynchronous operations are chained. What's important here is that the <code class="literal">then()</code> methods are invoked only once, that is, the promise returned by the <code class="literal">$http()</code> method can be resolved only once, and multiple attempts to resolve a promise will be ignored. Therefore, we cannot use promise patterns to write reactive code when we have to deal with multiple activities or data updates of an asynchronous operation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Some developers create a new promise for every activity and data update. This technique may seem fine since you are able to write reactive code involving multiple activities and data updates using promise patterns, but it's an anti-pattern.</p></div></div><p>Due to the problems with the event-driven, callback, and promise patterns, there was a need for another pattern, and functional reactive programming came to the rescue.</p><p>FRP is simply reactive programming using functional programming style. We will learn more about functional programming in the next section. Actually, the drawbacks of the event-driven, callback, and promise patterns weren't the real reason for the invention of FRP; rather, FRP was actually invented because there were demands for a functional pattern for reactive programming, as functional code is easy to write, test, debug, reuse, update, and read. But as FRP solves the problems caused by the event-driven, callback, and promise patterns, we can say that FRP is an alternative to the other patterns.</p><p>In this chapter, we will learn about FRP, which is considered the modern way of writing reactive code.</p></div></div></div>
<div class="section" title="Functional programming in a nutshell"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Functional programming in a nutshell</h1></div></div></div><p>Before <a id="id246" class="indexterm"/>we get into FRP, it's necessary to have basic knowledge about functional programming.</p><p>In a nutshell, functional programming <a id="id247" class="indexterm"/>is a style of writing code in which we use only pure function calls (including recursion) instead of loops and conditionals, and data is immutable.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Functional programming falls under the criterion of declarative programming. Declarative programming is a style of writing code where we write code to tell the system what we would like to happen instead of how to do it. Some other examples of declarative programming are SQL and regular expressions.</p></div></div><p>So what is a <a id="id248" class="indexterm"/>pure function? A <span class="strong"><strong>pure function</strong></span> is a function that depends only on its input arguments and that always provides the same output for a particular input. If it reads anything else outside of its scope, including global variables, then it's not a pure function.</p><p>Obviously, it's not always possible to make all the functions pure. For example, a function that fetches a web page or reads from the filesystem cannot guarantee the same return value. We should try to make as many as functions as pure as possible. So, we can say that 100% purity is impossible to achieve, but 85% purity is still very productive.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Functions without side effects, stateless functions, and pure functions are terms used interchangeably.</p></div></div><p>As data is immutable in functional programming, you must be wondering how it is possible to write code without modifying data. Well, in practice, we simply create new data structures instead of modifying existing ones. For example, if we have an array with four values and we want to remove the last one, then we simply create a new array, which doesn't have the last value.</p><div class="section" title="The advantages of immutable data"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>The advantages of immutable data</h2></div></div></div><p>There are <a id="id249" class="indexterm"/>several advantages of immutable data. Here are a few of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They are <a id="id250" class="indexterm"/>thread-safe, that is, multiple threads operating on them cannot modify/corrupt their state. Learn more about thread safety at <a class="ulink" href="https://en.wikipedia.org/wiki/Thread_safety">https://en.wikipedia.org/wiki/Thread_safety</a>.</li><li class="listitem" style="list-style-type: disc">They object copying can be shared easily. One doesn't have to employ a strategy such as defensive copying, like in mutable data structures. Learn more about object copying at <a class="ulink" href="https://en.wikipedia.org/wiki/Object_copying">https://en.wikipedia.org/wiki/Object_copying</a>.</li><li class="listitem" style="list-style-type: disc">They <a id="id251" class="indexterm"/>help avoid temporal coupling. More <a id="id252" class="indexterm"/>about temporal coupling can be found at <a class="ulink" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming">https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming</a>.</li></ul></div></div><div class="section" title="Functional data structures"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Functional data structures</h2></div></div></div><p>As data is <a id="id253" class="indexterm"/>immutable, there are several problems you are likely to face. Here are a few:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If an immutable array has millions of values, then creating a new array and copying all the values from the previous array is CPU and memory intensive</li><li class="listitem" style="list-style-type: disc">If two threads need to write to the same variable, coordinating the final value of the variable will be difficult</li></ul></div><p>There are many other issues. These issues led to the idea of functional data structures. Functional data structures are a different type of data structure that aim to solve these kinds of issue. But you don't need to know about functional data structures to follow this chapter or write functional reactive code in JavaScript.</p></div><div class="section" title="The advantages of pure functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>The advantages of pure functions</h2></div></div></div><p>Here are <a id="id254" class="indexterm"/>a few advantages of pure functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They increase reusability and maintainability, as each function is independent</li><li class="listitem" style="list-style-type: disc">Easier testing and debugging is possible, as each function can be tested and debugged separately</li><li class="listitem" style="list-style-type: disc">Functional programs are easy to understand as they are written in a declarative manner, that is, the code says what is to be done instead of how it's done.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The style of writing code using loops, conditionals, and function calls is called imperative programming. Imperative programming and functional programming are considered opposites of each other. JavaScript, C++, Java, Python, Ruby, are examples of imperative programming languages.</p></div></div></div><div class="section" title="Functional programming with JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Functional programming with JavaScript</h2></div></div></div><p>You don't have <a id="id255" class="indexterm"/>to use a functional programming language such as Erlang, Haskell, and so on to write functional code. Most imperative programming languages allow us to write functional code.</p><p>Due to the fact that functions in JavaScript are first-class (we will learn more about first-class functions later), it is possible to write functional code in JavaScript.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>"First-class" and "high-order" are terms used interchangeably.</p></div></div><p>A function is said to be first-class when it can be passed as an argument to another function, can return another function, and be assigned to a variable.</p><p>In JavaScript, functions are first-class because they are objects. Because an object can be passed as an argument to another function, a function can return an object, and an object can be assigned to a variable, functions can be first-class.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<span class="strong"><strong>What is the difference between a closure and a first-class function?</strong></span>
</p><p>
<span class="strong"><strong>Closures</strong></span> are <a id="id256" class="indexterm"/>the most misunderstood topic in JavaScript. In a nutshell, a closure is a function returned by another function, and when the function is invoked, it has access to the lexical scope in which it was defined. A function returned by a first-class function may or may not be a closure. Here is an example to demonstrate closures:</p><div class="informalexample"><pre class="programlisting">function a()
{
  var b = 12;
  function c()
  {
    console.log(b);
  }
  
  return c;
}

var d = a();

d(); //Output "12"</pre></div><p>Here, the function named <code class="literal">c</code> is a closure as it's returned by <code class="literal">a</code>, and when invoked, it has access to the variables declared inside <code class="literal">a</code>.</p></div></div></div><div class="section" title="Functional programming helper functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Functional programming helper functions</h2></div></div></div><p>
<span class="strong"><strong>Functional programming languages</strong></span> <a id="id257" class="indexterm"/>provide a <a id="id258" class="indexterm"/>lot of in-built functions called helper functions to make it easy to write functional code. For example, as we cannot use loops for iteration in functional code, we need some sort of function to take a collection and map each value of the collection to a function. Functional programming languages provide the <code class="literal">map</code> helper function for this purpose. Similarly, there are a lot of other helper functions for different purposes.</p><p>As JavaScript is not a functional programming language, it doesn't come with functional helper functions. However, ES6 introduced some helper functions, such as <code class="literal">Array.from()</code>, <code class="literal">Array.prototype.from()</code>, and <code class="literal">Array.prototype.find()</code>. Still, this list is not enough to write functional code. Therefore, developers use libraries such as <code class="literal">Underscore.js</code> to write functional code. </p></div></div>
<div class="section" title="Getting started with FRP"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>Getting started with FRP</h1></div></div></div><p>FRP is <a id="id259" class="indexterm"/>simply reactive programming using functional programming style.</p><p>EventStreams and properties (don't get these confused with object properties) are the building blocks of FRP. Let's look at an overview of what both these terms mean.</p><div class="section" title="EventStreams"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>EventStreams</h2></div></div></div><p>An EventStream <a id="id260" class="indexterm"/>represents a stream of events. Events in an EventStream may happen at any time and need not occur synchronously.</p><p>Let's understand <a id="id261" class="indexterm"/>EventStreams by comparing them to events in an event-driven pattern. Just like we subscribe to events in an event-driven pattern, we subscribe to EventStreams in FRP. Unlike events in event-driven programming, the power of EventStreams is that they can be merged, concatenated, combined, zipped, filtered, or transformed in any number of ways before you handle and act on the events.</p><p>In functional programming, data is immutable, so merging, concatenating, combining, zipping, filtering, or transforming an EventStream creates a new EventStream instead of modifying the existing one.</p><p>Here is a diagram that shows how an EventStream representing the click event of a UI element <a id="id262" class="indexterm"/>would <a id="id263" class="indexterm"/>look:</p><div class="mediaobject"><img src="graphics/B05154_07_01.jpg" alt="EventStreams"/></div><p>This EventStream can be merged with any other stream. Here is a diagram that shows how it looks when two EventStreams are merged:</p><div class="mediaobject"><img src="graphics/B05154_07_02.jpg" alt="EventStreams"/></div><p>Merging <a id="id264" class="indexterm"/>can be useful when <a id="id265" class="indexterm"/>we want to apply the same action when an event occurs to two different EventStreams. Instead of subscribing and attaching a callback to two different EventStreams, we can now subscribe to a single EventStream, eliminating duplicate code and making it easy to update code. Merging can be useful in various other cases as well.</p></div><div class="section" title="Properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Properties</h2></div></div></div><p>A property <a id="id266" class="indexterm"/>represents a value that changes <a id="id267" class="indexterm"/>over time. Properties can be used as an alternative to JavaScript variables whose values change in response to asynchronous activities and data updates. For example, you can use properties to represent the total number of times a button was clicked, the total number of logged-in users, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Properties are also called signals or behaviors.</p></div></div><p>The <a id="id268" class="indexterm"/>advantage of using properties instead of JavaScript variables is that you can subscribe to properties, that is, whenever <a id="id269" class="indexterm"/>the value of a property changes, a callback is fired to update the parts of the system that depend on it. This prevents code duplication and has many other benefits.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>You can create a property from another property as well as merge, combine, zip, sample, filter, or transform properties.</p></div></div><p>We've just looked at the basics of FRP. Creating EventStreams and properties, their methods, and other things to work with them differ depending on the library we use to write functional reactive code. Now, let's explore how to write functional reactive code using the Bacon.js library.</p></div></div>
<div class="section" title="FRP using Bacon.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>FRP using Bacon.js</h1></div></div></div><p>
<span class="strong"><strong>Bacon.js</strong></span> is a <a id="id270" class="indexterm"/>JavaScript library that helps us write functional reactive code in JavaScript. It can be <a id="id271" class="indexterm"/>used for both frontend and backend JavaScript. The official website of Bacon.js library<a id="id272" class="indexterm"/> is <a class="ulink" href="https://baconjs.github.io/">https://baconjs.github.io/</a>.</p><p>Let's create a basic website project to demonstrate FRP with Bacon.js.</p><div class="section" title="Setting up the project"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec48"/>Setting up the project</h2></div></div></div><p>Let's learn <a id="id273" class="indexterm"/>how to download and install Bacon.js for use with frontend and backend JavaScript. On the frontend, Bacon.js depends on jQuery.</p><p>Create a directory named <code class="literal">baconjs-example</code>. Inside it, create files called <code class="literal">package.json</code> and <code class="literal">app.js</code> and a directory called <code class="literal">public</code>. Inside the <code class="literal">public</code> directory, create directories called <code class="literal">html</code> and <code class="literal">js</code>. Inside the <code class="literal">html</code> directory, create a file called <code class="literal">index.html</code>. Finally, inside the <code class="literal">js</code> directory, create a file called <code class="literal">index.js</code>.</p><p>Download the frontend Bacon.js library<a id="id274" class="indexterm"/> from <a class="ulink" href="http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js">http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js</a> and jQuery from <a class="ulink" href="https://code.jquery.com/jquery-2.2.0.min.js">https://code.jquery.com/jquery-2.2.0.min.js</a>, and place them in the <code class="literal">js</code> directory.</p><p>At <a id="id275" class="indexterm"/>the time <a id="id276" class="indexterm"/>of writing this book, 0.7.73 was the latest version of the frontend Bacon.js library, and 2.2.0 was the latest version of jQuery.</p><p>In the <code class="literal">index.html</code> file, place this code to enqueue jQuery and the frontend Bacon.js library:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Bacon.js Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type="text/javascript" src="js/jquery-2.2.0.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="js/Bacon.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>In the <code class="literal">package.json</code> file, place this code:</p><div class="informalexample"><pre class="programlisting">{
  "name": "Baconjs-Example",
  "dependencies": {
    "express": "4.13.3",
    "baconjs": "0.7.83"
  }
}</pre></div><p>Now, run <code class="literal">npm install</code> inside the <code class="literal">baconjs-example</code> directory to download the npm packages.</p><p>At the time of writing this book, 0.7.83 was the latest version of backend Bacon.js library.</p><p>In the <code class="literal">app.js</code> file, place the following code to import the backend Bacon.js and Express modules. It also starts our webserver in order to serve the web page and static files:</p><div class="informalexample"><pre class="programlisting">var Bacon = require("baconjs").Bacon;
var express = require("express");
var app = express();

app.use(express.static(__dirname + "/public"));

app.get("/", function(httpRequest, httpResponse, next){
  httpResponse.sendFile(__dirname + "/public/html/index.html");
})

app.listen(8080);</pre></div><p>We have now set up a basic Bacon.js project. Run <code class="literal">node app.js</code> to start the web server. Now, let's explore Bacon.js APIs.</p></div><div class="section" title="Bacon.js APIs"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec49"/>Bacon.js APIs</h2></div></div></div><p>Bacon.js <a id="id277" class="indexterm"/>provides APIs to do almost anything that's possible using EventStreams and properties. The method of importing and downloading Bacon.js for the backend and frontend is different, but the APIs are the same for both. Let's look at the most important APIs provided by Bacon.js.</p><div class="section" title="Creating EventStreams"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec20"/>Creating EventStreams</h3></div></div></div><p>There are <a id="id278" class="indexterm"/>various ways of creating EventStreams, depending on how an asynchronous API is designed, that is, which pattern an asynchronous API follows. An asynchronous API follows the event-driven, promise, or callback pattern. We need to wrap these patterns with Bacon-provided APIs to connect their data updates or activity updates to event streams, that is, convert them to functional reactive patterns.</p><p>If we want to create an EventStream for a UI element on a web page, we can use the <code class="literal">$.asEventStream()</code> method. Let's look at an example of how it works. Place the following code in the <code class="literal">&lt;body&gt;</code> tag of the <code class="literal">index.html</code> file to create a button:</p><div class="informalexample"><pre class="programlisting">&lt;button id="myButton"&gt;Click me!!!&lt;/button&gt;</pre></div><p>In an event-driven pattern, to print something whenever a button is clicked, we would write something like this:</p><div class="informalexample"><pre class="programlisting">document.getElementById("myButton").addEventListener("click", function(){
  console.log("Button Clicked");
}, false)</pre></div><p>But in Bacon.js, we will write it this way. Place this code in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var myButton_click_stream = $("#myButton").asEventStream("click");
myButton_click_stream.onValue(function(e){
  console.log("Button Clicked");
})</pre></div><p>Here, we use a jQuery selector to point to the button, and we then use the <code class="literal">$.asEventStream</code> method to connect its click events to an EventStream. The <code class="literal">$.asEventStream</code> method takes the name of the event as its first parameter.</p><p>The <code class="literal">onValue</code> method is used to add subscribers to an EventStream. The <code class="literal">onValue</code> method of an EventStream takes a callback, which is executed every time a new event is added <a id="id279" class="indexterm"/>to the EventStream. The callback has a single parameter, which represents the current event that has been added to the EventStream. In this case, it's of the event interface. We can call the <code class="literal">onValue</code> method multiple times to add multiple callbacks.</p><p>A subscriber can be used to update the UI, perform logging, and so on. But the logic code for handling the event should be written using the helper functions and not be inside the subscriber. This is how functional reactive code is supposed to be written.</p><p>The subscriber callback will not be invoked for events that occurred before the subscriber was registered.</p><p>Similarly, there are lots of other APIs provided by Bacon.js to create EventStreams. Here are a few of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Bacon.fromPromise</code>: This is used to create an EventStream from a promise object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bacon.fromEvent</code>: This is used to create an EventStream from events of an EventTarget or Node.js EventEmitter object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bacon.fromCallback</code>: This is used to create an EventStream from a function that accepts a callback.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bacon.fromNodeCallback</code>: This is the same as <code class="literal">Bacon.fromCallback</code>, but it requires the callback to be called in Node.js convention.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Bacon.fromBinder</code>: If none of the previous APIs are fitting well, then you can use this one.</li></ul></div></div><div class="section" title="Creating properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec21"/>Creating properties</h3></div></div></div><p>A property is <a id="id280" class="indexterm"/>created from an EventStream, that is, a stream whose events the value of the property depends on. Whenever an event occurs in the EventStream, a callback is executed to update the property value.</p><p>You can create a property for an EventStream using either the <code class="literal">toProperty</code> or <code class="literal">scan</code> methods. The <code class="literal">scan</code> method is used instead of <code class="literal">toProperty</code> when we want to give an initial value as well as an accumulator function to the property. You may or may not provide an initial value when creating a property using <code class="literal">toProperty</code>().</p><p>Calling <code class="literal">scan</code> or <code class="literal">toProperty</code> multiple times create multiple properties.</p><p>Let's create a property to hold the total number of times a button is clicked. Here is the code to do this; place it in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var button_click_counter = myButton_click_stream.scan(0, function(value, e){
  return ++value;
})

button_click_counter.onValue(function(value){
  console.log("Button is clicked " + value + " number of times");
})</pre></div><p>Here, we created a property using the <code class="literal">scan</code> method and initialized it to <code class="literal">0</code>. The second argument is a callback, which is invoked to update the property value whenever an event happens <a id="id281" class="indexterm"/>in the EventStream to which the property is attached. This callback should return the new property value. The callback has two parameters, that is, the current value of the property and the event.</p><p>The <code class="literal">onValue</code> method of a property takes a callback that is executed every time the property value changes. We can call the <code class="literal">onValue</code> method multiple times to register multiple callbacks.</p><p>When we register a subscriber for a property, the subscriber is executed with the current value as soon as it's registered, but not for the values that occurred before it had been registered. If the property has not yet been assigned to anything, then the callback is not executed.</p><p>Here, whenever the property value changes, we log a statement informing us about the total number of times the button was clicked.</p><p>A property can also be created from another property. This is useful when a property's value depends on another property. Let's create a property from the previous property, which holds the time at which the property was last clicked and the button click count at that time. Here is the code to do this; place it in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var button_click_time = button_click_counter.scan({}, function(value, count){
  return {time: Date.now(), clicks: count};
})

button_click_time.onValue(function(value){
  console.log(value);
})</pre></div><p>Everything here is self-explanatory. The only thing you need to know is that the second parameter of the second argument passed to the <code class="literal">scan</code> method represents the value of the property we used to create this property.</p><p>A property holds a stream that has all of its previous and current values internally; therefore, we can also merge, combine, zip, sample, filter, and transform properties. Merging, combining, zipping, sampling, filtering, or transforming properties gives us new properties. This feature is useful for writing code for the more complex situation of a property's value depending on another property. For example, if we want to ignore some values of a property while calculating the value of another property based on it, then we can use filter feature.</p><p>Bacon.js <a id="id282" class="indexterm"/>also allows us to create EventStreams based on properties, that is, the events of an EventStream represent the values of a property. Events in these EventStreams occur when their respective property value is changed. This feature has many benefits, one of which is that it can prevent code duplication when we have to trigger the same action in response to several properties changing their values.</p><p>To create EventStreams based on properties, we can use the <code class="literal">toEventStream</code> method of a property.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>Retrieving the latest value of a property</strong></span>
</p><p>There is no method to obtain the latest value of a property, and there will be. You obtain the value by subscribing to the property and handling the values in your callback. If you need the value of more than one source, use one of the <code class="literal">combine</code> methods. This is how functional reactive code using Bacon.js is supposed to be written.</p></div></div></div><div class="section" title="Merging, filtering, and transforming EventStreams and properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec22"/>Merging, filtering, and transforming EventStreams and properties</h3></div></div></div><p>Bacon.js provides various helper functions to work with EventStreams and properties. Let's look at some of the most useful helper functions.</p><div class="section" title="Merging"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec06"/>Merging</h4></div></div></div><p>
<span class="strong"><strong>Merging</strong></span> streams <a id="id283" class="indexterm"/>or properties gives us a new stream or property that delivers all <a id="id284" class="indexterm"/>the events or values of all the streams <a id="id285" class="indexterm"/>or properties. To merge EventStreams or properties, we can use their <code class="literal">Bacon.mergeAll </code>method instances. Here is some example code to demonstrate this. Place it in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var merged_property = Bacon.mergeAll([button_click_counter, button_click_time]);

merged_property.onValue(function(e){
  console.log(e);
})</pre></div><p>Here, we merge two properties. <code class="literal">Bacon.mergeAll</code> takes an array of either EventStreams or properties. Whenever the value of either of the two properties changes, the value is made the current value of the resultant property.</p><p>There are various other helper functions available for merging properties and EventStreams.</p></div><div class="section" title="Filtering"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec07"/>Filtering</h4></div></div></div><p>
<span class="strong"><strong>Filtering</strong></span> is <a id="id286" class="indexterm"/>removing specific events or values from EventStreams or properties, respectively, that we don't need.</p><p>Bacon.js <a id="id287" class="indexterm"/>provides a lot of helper functions to filter <a id="id288" class="indexterm"/>EventStreams and properties, depending on what you want to filter. Let's look at the <code class="literal">filter</code> method for EventStreams and properties that lets us filter based on a predicate function; that is, if the function returns <code class="literal">true</code>, then the value is accepted; otherwise, it is rejected.</p><p>Let's look at example code to demonstrate this. In the <code class="literal">index.js</code> file, find this code:</p><div class="informalexample"><pre class="programlisting">var myButton_click_stream = $("#myButton").asEventStream("click");
myButton_click_stream.onValue(function(e){
  console.log(e);
  console.log("Button Clicked");
})</pre></div><p>Replace that with this code:</p><div class="informalexample"><pre class="programlisting">var myButton_click_stream = $("#myButton").asEventStream("click").filter(function(e){
  return e.shiftKey === true;
});

myButton_click_stream.onValue(function(e){
  console.log(e);
  console.log("Button Clicked");
})</pre></div><p>Here, we are filtering all those click events in which we didn't press the <span class="emphasis"><em>Shift</em></span> key. So, for the click event to be accepted, we need to press the <span class="emphasis"><em>Shift</em></span> key while clicking on the button.</p><p>You can think of filtering as an alternative to using the <code class="literal">if…else</code> conditional.</p></div><div class="section" title="Transforming"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec08"/>Transforming</h4></div></div></div><p>
<span class="strong"><strong>Transforming</strong></span> is <a id="id289" class="indexterm"/>creating an EventStream or property from another EventStream or property, respectively, whose <a id="id290" class="indexterm"/>events are <a id="id291" class="indexterm"/>transformed to something else. For example, a property whose value represents a URL can be transformed to another property, whose value represents the response of the URL. Transforming EventStreams and properties actually creates new EventStreams and properties, respectively.</p><p>You can think of transforming as an alternative to loops, that is, to using <code class="literal">for</code> loops.</p><p>There <a id="id292" class="indexterm"/>are several helper functions provided by Bacon.js for transformation depending on how and what you want to transform.</p><p>One <a id="id293" class="indexterm"/>popular transformation function is <code class="literal">map()</code>, which maps events or values of EventStreams or properties to a function. Let's look at a code sample to demonstrate this. Find this code in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var button_click_time = button_click_counter.scan({}, function(value, count){
  return {time: Date.now(), clicks: count};
})</pre></div><p>Replace it with this code:</p><div class="informalexample"><pre class="programlisting">var button_click_time = button_click_counter.scan({}, function(value, count){
  return {time: Date.now(), clicks: count};
}).map(function(value){
  var date = new Date(value.time);
  return (date).getHours() + ":" + (date).getMinutes();
})</pre></div><p>Here, we are using <code class="literal">map()</code> to transform the Unix timestamp to the HH:MM format, which is easy to understand.</p><p>There is another, vital transformation helper function provided by Bacon.js called <code class="literal">flatMap</code>. There are basically two differences between <code class="literal">flatMap</code> and <code class="literal">map</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">flatMap</code> function always returns an EventStream regardless of whether it was called on a EventStream or property.</li><li class="listitem" style="list-style-type: disc">If the callback passed to <code class="literal">flatMap</code> returns an EventStream or property, then the events of the EventStream returned by the <code class="literal">flatMap</code> function are events and values of the streams and properties returned by the callback passed to <code class="literal">flatMap</code>. Whenever an event or value is added to the streams and properties returned by the callback passed to <code class="literal">flatMap</code>, the event and value will automatically be added to the EventStream returned by the <code class="literal">flatMap</code> function.</li></ul></div><p>You need to use <code class="literal">flatMap</code> instead of <code class="literal">map</code> when retrieving the return value of a callback passed to a network, disk drive, or somewhere else asynchronous. For example, in the previous example, where I talked about transforming a URL to a URL response, we need to use <code class="literal">flatMap</code> instead of <code class="literal">map</code> as instead of a callback, we need to make an AJAX request, and its response will be captured as a stream, and the stream will be returned. When the AJAX request completes, the event will be put inside the stream returned by the <code class="literal">flatMap</code> function.</p><p>Let's look at an implementation of this example. First, create an input text field and place it in the <code class="literal">index.html</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;input id="url" type="url"&gt;</pre></div><p>Now, let's write <a id="id294" class="indexterm"/>code using Bacon.js to log <a id="id295" class="indexterm"/>the output of the URL entered in the field when a user hits the <span class="emphasis"><em>Enter</em></span> key. Here is the code to do this. Place it in the <code class="literal">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var enter_key_click_stream = $("#url").asEventStream("keyup").filter(function(e){
  return e.keyCode == 13;
})

var url = enter_key_click_stream.scan("", function(value, e){
  return e.currentTarget.value;
})

var response = url.flatMap(function(value){
 return Bacon.fromPromise($.ajax({url:value}));
}).toProperty();

response.onValue(function(value){
  console.log(value);
})</pre></div><p>This is how the code works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, we create an EventStream for the <code class="literal">keyup</code> event.</li><li class="listitem" style="list-style-type: disc">Then, we filter only <span class="emphasis"><em>Enter</em></span>-key events because we will take action only if the <span class="emphasis"><em>Enter</em></span> key is pressed.</li><li class="listitem" style="list-style-type: disc">Then, we create a variable to hold the value of the text field.</li><li class="listitem" style="list-style-type: disc">Then, we use <code class="literal">flatMap</code> to fetch the response of the URL using jQuery AJAX. We are using <code class="literal">Bacon.fromPromise</code> to create an EventStream from a promise.</li><li class="listitem" style="list-style-type: disc">When the AJAX request finishes, it adds the response to the EventStream returned by the callback passed to <code class="literal">flatMap</code>. Then, <code class="literal">flatMap</code> adds the same response to the EventStream returned by the <code class="literal">flatMap</code> function itself. As soon as it's added, we log the response using <code class="literal">onValue</code>.</li></ul></div><p>Here, if we had used <code class="literal">map</code> instead of <code class="literal">flatMap</code>, then we would have ended up logging EventStream objects instead of the events of the EventStream returned by the <code class="literal">map</code> function.</p><p>Although we can have both <code class="literal">url</code> and <code class="literal">response</code> properties directly created from the <code class="literal">enter_key_click_stream</code>, it <a id="id296" class="indexterm"/>is likely <a id="id297" class="indexterm"/>to cause code repetition and make the code difficult to understand.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>When you call a method to transform, filter, or do something else with EventStreams, then the events that occurred before the method call are not taken into account. However, in the case of a property, the current value is taken into account, but not the values that occurred before the method call. If the property has not yet been assigned to anything, nothing is taken into account.</p></div></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Summary</h1></div></div></div><p>We looked at reactive programming, functional programming, FRP, and finally an overview of Bacon.js. You should now be comfortable with writing basic functional reactive code and have a clear idea of its benefits.</p><p>We will learn about more of the APIs provided by Bacon.js and build a real-world project using Bacon.js in the next chapter.</p></div></body></html>