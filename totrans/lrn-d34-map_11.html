<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Shaping Maps with Data - Hexbin Maps</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Different pieces of data afford different visualizations. </span><span class="koboSpan" id="kobo.2.2">When you want to show a timeline, you rarely build a vertical bar chart. </span><span class="koboSpan" id="kobo.2.3">You would more likely use a horizontal line chart. </span><span class="koboSpan" id="kobo.2.4">You should, of course, give yourself some freedom of expression when encoding data to position, shape, or color. </span><span class="koboSpan" id="kobo.2.5">However, the data at hand, the meaning you want to convey, and the cognitive decoding processes at play are important guides when deciding how to encode your data.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will focus on a specific map-visualization technique: </span><strong><span class="koboSpan" id="kobo.4.1">hexagonal binning</span></strong> <strong><span class="koboSpan" id="kobo.5.1">maps</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong><span class="koboSpan" id="kobo.7.1">hexbin maps</span></strong><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">We will start with a brief journey through various map visualization techniques before focusing on hexbin maps. </span><span class="koboSpan" id="kobo.8.3">You will learn the conceptual and cognitive benefits of hexbin maps, what hexagons are useful for in comparison to other shapes, and how they are calculated.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Most of the chapter will, however, be hands on, building a hexbin map from scratch. </span><span class="koboSpan" id="kobo.9.2">Most of the attention will go into data preparation and shaping. </span><span class="koboSpan" id="kobo.9.3">D3 will make the actual visualization a breeze with the </span><strong><span class="koboSpan" id="kobo.10.1">D3-hexbin</span></strong><span class="koboSpan" id="kobo.11.1"> module. </span><span class="koboSpan" id="kobo.11.2">We will focus on a pipeline of data preparation and visualization tasks that aim to be easy to follow. </span><span class="koboSpan" id="kobo.11.3">Let’s go!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Reviewing map visualization techniques</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are many ways to represent geographical data. </span><span class="koboSpan" id="kobo.2.2">Not surprisingly, maps are often involved. </span><span class="koboSpan" id="kobo.2.3">While maps are a compelling way to present data that can be deciphered effortlessly by most people, they can be overused. </span><span class="koboSpan" id="kobo.2.4">If you want to show which country has the highest percentage of forest cover, you might decide to show a globe and use color saturation to encode forest ratio. </span><span class="koboSpan" id="kobo.2.5">Alternatively, you could show a sorted vertical bar chart displaying the country with the highest forest cover on top and the country with the lowest at the bottom. </span><span class="koboSpan" id="kobo.2.6">The map version might look nicer and give your users a good intuition about locations of forest lack or riches. </span><span class="koboSpan" id="kobo.2.7">However, the bar chart gives a more concise overview over the distribution and country comparison of forest cover.</span></p>
<p><span class="koboSpan" id="kobo.3.1">So, let’s assume that you have decided to use a map as the fundamental representation of your visual. </span><span class="koboSpan" id="kobo.3.2">What options are there?</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Choropleth maps</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Widely known and potentially overused choropleth maps are a good choice if you need to compare standardized ratios across geographical units such as states, counties, or countries. </span><span class="koboSpan" id="kobo.2.2">You built a choropleth map in </span><a href="c22382c6-84d9-411f-b795-681df2321005.xhtml"><span class="koboSpan" id="kobo.3.1">chapter 4</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Creating a Map</span></em><span class="koboSpan" id="kobo.6.1"> and </span><span><span class="koboSpan" id="kobo.7.1">in</span></span> <a href="328cc9b5-a87f-4492-b7ce-fa4c07cff7a1.xhtml"><span class="koboSpan" id="kobo.8.1">chapter 10</span></a><span class="koboSpan" id="kobo.9.1">, </span><em><span class="koboSpan" id="kobo.10.1">Adding Interactivity to Your Canvas Map</span></em><span class="koboSpan" id="kobo.11.1"> comparing forest cover ratio per country</span></p>
<p><span class="koboSpan" id="kobo.12.1">The only visual channel you can encode your measure of choice with is color. </span><span class="koboSpan" id="kobo.12.2">The areas of the units are already given by the size of these units. </span><span class="koboSpan" id="kobo.12.3">This can draw the user’s attention away from the smaller, and toward, the larger units. </span><span class="koboSpan" id="kobo.12.4">Looking at our forest example, larger countries such as the US, Russia, or Brazil might get more initial attention than smaller countries, such as Luxembourg, Haiti, or Belize.</span></p>
<p><span class="koboSpan" id="kobo.13.1">To alleviate this attention problem, you should be fair to each country in the measure you visualize. </span><span class="koboSpan" id="kobo.13.2">The key rule is to not visualize absolute numbers, but standardized ratios related to the country. </span><span class="koboSpan" id="kobo.13.3">We adhered to this rule in our forest example by visualizing the percentage of forested area of the total country area. </span><span class="koboSpan" id="kobo.13.4">This measure has the same range for each country, independent of the country’s area (0 to 100%). </span><span class="koboSpan" id="kobo.13.5">It’s a standardized, and hence, fair measure. </span><span class="koboSpan" id="kobo.13.6">The absolute number of trees would be an unfair measure. </span><span class="koboSpan" id="kobo.13.7">A large country with a few trees could still have more trees than a small country full of trees, rendering our comparison problematic to pointless.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Furthermore, the geographical unit should define the measure you visualize. </span><span class="koboSpan" id="kobo.14.2">Tax rates, for example, are made by countries and make perfect sense to compare across countries. </span><span class="koboSpan" id="kobo.14.3">Forest cover is not (entirely) informed by a country’s actions and policies, and makes less sense to show in a choropleth. </span><span class="koboSpan" id="kobo.14.4">The countries’ actions still influence their forest cover, so I wouldn’t disregard it (the Dominican Republic, for example, has a much more conservative approach to its forests than neighboring Haiti), but this should be a conscious part of your choice of visualization technique.</span></p>
<p><span class="koboSpan" id="kobo.15.1">As choropleths are so omnipresent, let’s take a look at another example with different data: farmers' markets in the US. </span><span class="koboSpan" id="kobo.15.2">They will accompany us for the rest of the chapter, so this is a good time to dive into it.</span></p>
<div class="packt_infobox">
<p><span class="koboSpan" id="kobo.16.1">The </span><em><span class="koboSpan" id="kobo.17.1">farmers' markets</span></em><span class="koboSpan" id="kobo.18.1"> data we will use is published by the USDA at </span><a href="https://www.ams.usda.gov/local-food-directories/farmersmarkets"><span class="koboSpan" id="kobo.19.1">https://www.ams.usda.gov/local-food-directories/farmersmarkets</span></a><span class="koboSpan" id="kobo.20.1">. </span><span class="koboSpan" id="kobo.20.2">After a bit of a clean up, we have a dataset of 8,475 markets on mainland US. </span><span class="koboSpan" id="kobo.20.3">Each market has a number of interesting variables, starting with longitude and latitude values we can use for the mapping, as well as name, state, and city they are located in. </span><span class="koboSpan" id="kobo.20.4">It also has 29 binary variables (as in yes/no) indicating the products that each market is selling. </span><span class="koboSpan" id="kobo.20.5">We will use this later to visualize subsets of markets.</span></p>
</div>
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.21.1">Here’s a choropleth of the US states (only mainland to keep it simple). </span><span class="koboSpan" id="kobo.21.2">It shows the number of farmers' markets per 100,000 people. </span><span class="koboSpan" id="kobo.21.3">Light blue means few markets; dark blue means many markets per 100k people:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="442" width="562" src="assets/e17f4ec6-542b-4fec-a8a2-f2376a5a50a5.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.23.1">A choropleth map of farmers' markets</span></div>
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.24.1">One question here has to be whether a state-wise comparison of farmers' markets makes much sense. </span><span class="koboSpan" id="kobo.24.2">Do the state-policies or cultures play a role in promoting or objecting to farmers' markets? </span><span class="koboSpan" id="kobo.24.3">Maybe. </span><span class="koboSpan" id="kobo.24.4">However, once we decided to go for a state-wise comparison of it, are we able to compare well? </span><span class="koboSpan" id="kobo.24.5">Texas with its size gets a lot of weight in the visual, suggesting southern farmers' market deprivation. </span><span class="koboSpan" id="kobo.24.6">We can see Vermont has the highest ratio (it helps that we’re pointing a red line at it), but what about Washington, D.C.? </span><span class="koboSpan" id="kobo.24.7">There are 8.5 markets per 100k people? </span><span class="koboSpan" id="kobo.24.8">We can’t even see it on the map.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Cartograms</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Cartograms do away with the area problem, by encoding your values to area size. </span><span class="koboSpan" id="kobo.2.2">A cartogram of our farmers' markets mapping the ratio to color and area size would look as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="442" width="562" src="assets/153f9633-e05f-4bee-9d06-35fd343e9cc9.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">A contiguous cartogram of farmers' markets</span></div>
<p><span class="koboSpan" id="kobo.5.1">The area— and consequently the shape</span><span><span class="koboSpan" id="kobo.6.1">—</span></span><span class="koboSpan" id="kobo.7.1">of your map gets distorted in such a way that the area represents the value you want to visualize. </span><span class="koboSpan" id="kobo.7.2">It's great for Washington, D.C. </span><span class="koboSpan" id="kobo.7.3">which has been sized up significantly to be recognized as a farmers' markets heavyweight. </span><span class="koboSpan" id="kobo.7.4">In short, they solve the choropleth problem of attention theft, but create a new problem in that our geographical units are often hardly recognizable. </span><span class="koboSpan" id="kobo.7.5">Your users will be fine with this reality bend for counties, states, and countries they know well, but they will struggle to make sense of areas they don’t know the shape of. </span><span class="koboSpan" id="kobo.7.6">It’ll look too cryptic and reduce readability to a potential full loss of interest.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.8.1">The contiguous cartogram has been produced with </span><a href="https://github.com/shawnbot/topogram"><span class="koboSpan" id="kobo.9.1">https://github.com/shawnbot/topogram</span></a><span class="koboSpan" id="kobo.10.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dot density maps</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Dot density maps are great if you want to show </span><strong><span class="koboSpan" id="kobo.3.1">counts of things</span></strong><span class="koboSpan" id="kobo.4.1"> rather than ratios. </span><span class="koboSpan" id="kobo.4.2">Each thing is a dot displayed on the map. </span><span class="koboSpan" id="kobo.4.3">Here’s a dot density map of all farmers' markets in the US:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="319" width="479" src="assets/51ee6872-ae5c-4e3d-a9a5-b303571679a9.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1">A dot density map of farmers' markets</span></div>
<p><span class="koboSpan" id="kobo.7.1">The benefit of this visualization technique is obvious: it shows all the data. </span><span class="koboSpan" id="kobo.7.2">You can easily see where they all are and detect clusters of farmers' markets across the country. </span><span class="koboSpan" id="kobo.7.3">The problem is that in fact it doesn’t show all the data. </span><span class="koboSpan" id="kobo.7.4">Some of the dots are overlapping in small, busy areas. </span><span class="koboSpan" id="kobo.7.5">A second potential problem is that many absolute measures in spatial analysis correlate highly with population distribution. </span><span class="koboSpan" id="kobo.7.6">So while you want to say </span><em><span class="koboSpan" id="kobo.8.1">Look where all the farmers' markets are</span></em><span class="koboSpan" id="kobo.9.1"> you are actually saying </span><em><span class="koboSpan" id="kobo.10.1">Look where all the people are</span></em><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">This doesn't mean you shouldn't show it, but you should be aware of it. </span><span class="koboSpan" id="kobo.11.3">By the way, our hexbin map will have the same problem, so be aware. </span><span class="koboSpan" id="kobo.11.4">Another caveat of showing all the data is that it might appear confusing for users to look at that amount of data and elements. </span><span class="koboSpan" id="kobo.11.5">We might want to focus the eye in a more orderly way to the clusters. </span><span class="koboSpan" id="kobo.11.6">This is where hexbin maps come in handy.</span></p>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.12.1">Note that this list of map visualization techniques is not complete. </span><span class="koboSpan" id="kobo.12.2">There are, of course, other map visualization techniques, such as heat maps, cluster maps, graduated circle, proportional symbol, or bubble maps, and non-contiguous cartograms. </span><span class="koboSpan" id="kobo.12.3">A good place to see what people visualize with and on maps is </span><a href="https://flowingdata.com/category/visualization/mapping/"><span class="koboSpan" id="kobo.13.1">https://flowingdata.com/category/visualization/mapping/</span></a><span class="koboSpan" id="kobo.14.1">.</span><a href="https://flowingdata.com/category/visualization/mapping/"/></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Value and use of the hexagon</span></h1>
                </header>
            
            <article>
                
<p class="NormalPACKT"><span><span class="koboSpan" id="kobo.2.1">Hexagons can solve some of the problems we mentioned in the preceding section. </span><span class="koboSpan" id="kobo.2.2">They can help the unequal area problems of choropleth maps and can bring ordered focus to point clusters. </span><span class="koboSpan" id="kobo.2.3">Let’s look at a few first:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="193" width="286" src="assets/6006bc7d-d194-456a-bb3f-b7ab796a6924.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Hexagonal tiling</span></div>
<p><span class="koboSpan" id="kobo.5.1">As you can see, hexagons have equal length sides and fit nicely next to each other. </span><span class="koboSpan" id="kobo.5.2">However, they’re not just a pretty face, they also have properties we can leverage well in data visualization:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Hexagons divide a given area into equal-sized hexagons. </span><span class="koboSpan" id="kobo.6.2">This is called </span><strong><span class="koboSpan" id="kobo.7.1">tiling</span></strong><span class="koboSpan" id="kobo.8.1"> and can also be done with other shapes such as circles, triangles, rectangles, or other polygons.</span></li>
<li><span class="koboSpan" id="kobo.9.1">However, if you tile your wall with circles, you will end up with gaps between the circles. </span><span class="koboSpan" id="kobo.9.2">Covering a plane gap-free with repeating symmetric shapes is called a </span><strong><span class="koboSpan" id="kobo.10.1">regular</span></strong> <strong><span class="koboSpan" id="kobo.11.1">tessellation</span></strong><span class="koboSpan" id="kobo.12.1"> and is, in fact, only possible with squares, triangles, and hexagons.</span></li>
<li><span class="koboSpan" id="kobo.13.1">Of these three shapes, hexagons are the highest-sided shape closest to a circle. </span><span class="koboSpan" id="kobo.13.2">Hence, they are best to represent</span><span><span class="koboSpan" id="kobo.14.1">—</span></span><span class="koboSpan" id="kobo.15.1">to </span><strong><span class="koboSpan" id="kobo.16.1">bin</span></strong><span><span class="koboSpan" id="kobo.17.1">—</span></span><span class="koboSpan" id="kobo.18.1">a cluster of points. </span><span class="koboSpan" id="kobo.18.2">Corner points of triangles or squares are further away from their center than corner points in hexagons, which make hexagons predestined for grouping dot data. </span><span class="koboSpan" id="kobo.18.3">Circles are optimal for binning, but then again, they can’t be tessellated.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1">Let’s consider binning for an extra moment. </span><strong><span class="koboSpan" id="kobo.20.1">Binning</span></strong><span class="koboSpan" id="kobo.21.1"> means grouping data together into equally sized categories. </span><span class="koboSpan" id="kobo.21.2">When we have a dataset of 100 people with varying ages, we can look at the frequency of each age, or we bin the data to more digestible age groups, such as 20-39, 40-69, and 70-99. </span><span class="koboSpan" id="kobo.21.3">We take individual data points and aggregate them in larger and</span><span><span class="koboSpan" id="kobo.22.1">—</span></span><span class="koboSpan" id="kobo.23.1">usually</span><span><span class="koboSpan" id="kobo.24.1">—</span></span><span class="koboSpan" id="kobo.25.1">equally sized groups.</span></p>
<p><span class="koboSpan" id="kobo.26.1">In a mapping context, we can bin point location data to equally sized areas. </span><span class="koboSpan" id="kobo.26.2">Hexagons are well suited for this task as they group points well and also tessellate regularly across the plane. </span><span class="koboSpan" id="kobo.26.3">This is what a hexbin map as implemented with D3 can do for you. </span><span class="koboSpan" id="kobo.26.4">Instead of potentially piling points on top of each other as we do in dot density maps, we can define hexagonal areas of equal size, aggregating the points to a summary measure encoded with color. </span><span class="koboSpan" id="kobo.26.5">As such, </span><strong><span class="koboSpan" id="kobo.27.1">binning</span></strong><span class="koboSpan" id="kobo.28.1"> represents the data for each hexagon area potentially better than individual points would do. </span><span class="koboSpan" id="kobo.28.2">The </span><strong><span class="koboSpan" id="kobo.29.1">hexagonal</span></strong> <strong><span class="koboSpan" id="kobo.30.1">tessellation</span></strong><span class="koboSpan" id="kobo.31.1"> supports the binning in that it creates the best possible, gap-free, and comparably fair bin shapes.</span></p>
<p><span class="koboSpan" id="kobo.32.1">In the coming sections, we will very much focus on these </span><strong><span class="koboSpan" id="kobo.33.1">hexbin maps</span></strong><span class="koboSpan" id="kobo.34.1">, where each hexagon represents an equal area. </span><span class="koboSpan" id="kobo.34.2">Before we dive into hexbins, let’s quickly look at another use of hexagons you might have come across: </span><strong><span class="koboSpan" id="kobo.35.1">hexagonal choropleth maps</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">The problem the classic choropleth map, as shown above poses, is that smaller states such as Vermont or Washington D.C can easily be overlooked, as they have such low visual weight. </span><span class="koboSpan" id="kobo.36.3">Other area-states such as Texas or Montana attract the eye through sheer size. </span><span class="koboSpan" id="kobo.36.4">To alleviate this, we can replace the state polygons with hexagons:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.37.1"><img height="400" width="509" src="assets/cb4c1771-d420-4f9f-8e18-7aac5ac4dca5.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.38.1">Size emancipated US states in a hexagonal choropleth map</span></div>
<p><span class="koboSpan" id="kobo.39.1">Let's be clear, hexagons in a </span><em><span class="koboSpan" id="kobo.40.1">hexbin map</span></em><span class="koboSpan" id="kobo.41.1"> as described in the preceding diagram and in the following sections represent equal areas. </span><span class="koboSpan" id="kobo.41.2">Hexagons in a </span><em><span class="koboSpan" id="kobo.42.1">hexagonal choropleth map</span></em><span class="koboSpan" id="kobo.43.1"> as shown in this figure represent vastly different areas. </span><span class="koboSpan" id="kobo.43.2">However, in this case, we don’t want to focus on the spatial area of our chosen unit (US mainland states); we want to focus on the measure that is merely categorized by our chosen unit.</span></p>
<p><span class="koboSpan" id="kobo.44.1">Be aware that this comes with the cost of removing the area information entirely, as the US states differ greatly in area and no state looks like a hexagon. </span><span class="koboSpan" id="kobo.44.2">However, unlike the preceding classic choropleth example, this hexagonal choropleth allows us, for example, to easily identify Washington D.C. </span><span class="koboSpan" id="kobo.44.3">as a farmers' market hub and that might be the message we want to bring across above all.</span></p>
<p><span class="koboSpan" id="kobo.45.1">Enough theory. </span><span class="koboSpan" id="kobo.45.2">Let’s make a hexbin map.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Making a hexbin map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Having improved our US state choropleth map with hexagons, let’s now use hexagons to alter our dot density map. </span><span class="koboSpan" id="kobo.2.2">There are benefits to a dot density map as we have seen previously, so the changes we are about to make are more alterations than clear improvements. </span><span class="koboSpan" id="kobo.2.3">Here’s what we will build:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="338" width="510" src="assets/1afbac36-728f-4032-8a1e-bb517d45dd17.png"/></span></div>
<div style="text-align: center" class="NormalPACKT packt_figref"><span><span class="koboSpan" id="kobo.4.1">A map of many hexagons in color</span></span></div>
<p><span class="koboSpan" id="kobo.5.1">It’s a hexbin map showing the farmers' markets hotspots. </span><span class="koboSpan" id="kobo.5.2">Areas with no farmers' markets are shown as white hexagons, areas with many farmers' markets are shown in blue to dark purple. </span><span class="koboSpan" id="kobo.5.3">Lighter and less saturated yellow and green hexagons represent areas with fewer markets.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Reviewing the hexbin algorithm</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">What do we want to achieve? </span><span class="koboSpan" id="kobo.2.2">There are two major steps we want to cover. </span><span class="koboSpan" id="kobo.2.3">First, we want to show the US as a hexagon tiling. </span><span class="koboSpan" id="kobo.2.4">Next, we want to highlight hexagons with farmers' markets, color encoding the number of markets within each hexagon.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Alternatively, we could be content with showing a map of the US and only display the hexagons where farmers' markets reside. </span><span class="koboSpan" id="kobo.3.2">This would be less involved; however, it seems worthwhile to go the extra mile for esthetics and clarity.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The actual drawing of the hexbin is simple, thanks to the </span><kbd><span class="koboSpan" id="kobo.5.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.6.1"> module doing the hardwork of drawing the hexagons. </span><span class="koboSpan" id="kobo.6.2">More attention will be required when producing the hexagonal grid of the US. </span><span class="koboSpan" id="kobo.6.3">However, don’t worry; the process is straightforward and right here:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.7.1">Draw a map.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Overlay the entire map with a symmetric grid of points.</span></li>
<li><span class="koboSpan" id="kobo.9.1">Only keep the grid points that are within the bounds of the map.</span></li>
<li><span class="koboSpan" id="kobo.10.1">Merge the grid points data with the location data we want to visualize.</span></li>
<li><span class="koboSpan" id="kobo.11.1">Calculate the hexbin positions with the D3</span><em><span class="koboSpan" id="kobo.12.1">-</span></em><span class="koboSpan" id="kobo.13.1">hexbin module.</span></li>
<li><span class="koboSpan" id="kobo.14.1">For each hexagon, aggregate the summary statistic you want to visualize.</span></li>
<li><span class="koboSpan" id="kobo.15.1">Visualize the summary statistic (for example, by color encoding the hexagons):</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img src="assets/544ca0f5-3a1e-436b-b15c-a34183826271.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1">The hexbin map evolution</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Setting it up</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The setup is simple. </span><span class="koboSpan" id="kobo.2.2">You have a single </span><kbd><span class="koboSpan" id="kobo.3.1">&lt;div&gt;</span></kbd><span class="koboSpan" id="kobo.4.1"> with the </span><kbd><span class="koboSpan" id="kobo.5.1">id="vis"</span></kbd><span class="koboSpan" id="kobo.6.1"> in the HTML for the visualization. </span><span class="koboSpan" id="kobo.6.2">In the JavaScript, you set up a global </span><kbd><span class="koboSpan" id="kobo.7.1">projection</span></kbd><span class="koboSpan" id="kobo.8.1"> variable to fill soon and create an </span><kbd><span class="koboSpan" id="kobo.9.1">svg</span></kbd><span class="koboSpan" id="kobo.10.1"> element:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">var projection;</span><br/><br/><span class="koboSpan" id="kobo.12.1">var margin = { top: 30, right: 30, bottom: 30, left: 30 },</span><br/><span class="koboSpan" id="kobo.13.1">    width = 900 - margin.left - margin.right,</span><br/><span class="koboSpan" id="kobo.14.1">    height = 600 - margin.top - margin.bottom;</span><br/><br/><span class="koboSpan" id="kobo.15.1">var svg = d3.select('#vis')</span><br/><span class="koboSpan" id="kobo.16.1">  .append('svg')</span><br/><span class="koboSpan" id="kobo.17.1">    .attr('width', width + margin.left + margin.top)</span><br/><span class="koboSpan" id="kobo.18.1">    .attr('height', height + margin.top + margin.bottom)</span><br/><span class="koboSpan" id="kobo.19.1">  .append('g')</span><br/><span class="koboSpan" id="kobo.20.1">    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As usual, the first thing we do is to get your data into the app. </span><span class="koboSpan" id="kobo.2.2">So far, you only have the US data; however, in anticipation of the farmers' markets point data, we will haul in a little later</span><span><span class="koboSpan" id="kobo.3.1">—let's use</span></span> <kbd><span class="koboSpan" id="kobo.4.1">d3.queue()</span></kbd><span class="koboSpan" id="kobo.5.1"> to load our data:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">d3.queue()</span><br/><span class="koboSpan" id="kobo.7.1">  .defer(d3.json, 'data/us.json')</span><br/><span class="koboSpan" id="kobo.8.1">  .await(ready);</span></pre>
<p><span class="koboSpan" id="kobo.9.1">The </span><kbd><span class="koboSpan" id="kobo.10.1">ready()</span></kbd><span class="koboSpan" id="kobo.11.1"> function gets called asynchronously as soon as the data is loaded:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">function ready(error, us) {</span><br/><span class="koboSpan" id="kobo.13.1">  if (error) throw error;</span><br/><br/><span class="koboSpan" id="kobo.14.1">  var us = prepData(us);</span><br/><span class="koboSpan" id="kobo.15.1">  drawGeo(us);</span><br/><br/><span class="koboSpan" id="kobo.16.1">}</span></pre>
<p><span class="koboSpan" id="kobo.17.1">In there, you check for errors, prepare the US data, and draw it. </span><span class="koboSpan" id="kobo.17.2">The data preparation is a one-liner, converting the </span><kbd><span class="koboSpan" id="kobo.18.1">topo</span></kbd><span class="koboSpan" id="kobo.19.1"> to an array of GeoJSON polygons:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">function prepData(topo) {</span><br/><span class="koboSpan" id="kobo.21.1">  var geo = topojson.feature(topo, topo.objects.us);</span><br/><span class="koboSpan" id="kobo.22.1">  return geo;</span><br/><span class="koboSpan" id="kobo.23.1">}</span></pre>
<p><span class="koboSpan" id="kobo.24.1">The drawing function takes the GeoJSON as its only argument. </span><span class="koboSpan" id="kobo.24.2">Create the projection and the path generator and draw the US. </span><kbd><span class="koboSpan" id="kobo.25.1">projection</span></kbd><span class="koboSpan" id="kobo.26.1"> is a global variable as we will use it in other places later:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">function drawGeo(data) {</span><br/><span class="koboSpan" id="kobo.28.1">  projection = d3.geoAlbers() // note: global</span><br/><span class="koboSpan" id="kobo.29.1">    .scale(1000).translate([width/2, height/2]);</span><br/><br/><span class="koboSpan" id="kobo.30.1">  var geoPath = d3.geoPath()</span><br/><span class="koboSpan" id="kobo.31.1">    .projection(projection);</span><br/><br/><span class="koboSpan" id="kobo.32.1">  svg</span><br/><span class="koboSpan" id="kobo.33.1">    .append('path').datum(data)</span><br/><span class="koboSpan" id="kobo.34.1">      .attr('d', geoPath)</span><br/><span class="koboSpan" id="kobo.35.1">      .attr('fill', '#ccc')</span><br/><span class="koboSpan" id="kobo.36.1">}</span></pre>
<p><span class="koboSpan" id="kobo.37.1">Note that we are using the </span><kbd><span class="koboSpan" id="kobo.38.1">d3.geoAlbers()</span></kbd><span class="koboSpan" id="kobo.39.1"> projection here. </span><span class="koboSpan" id="kobo.39.2">The </span><em><span class="koboSpan" id="kobo.40.1">Albers</span></em><span class="koboSpan" id="kobo.41.1"> projection is a so-called </span><strong><span class="koboSpan" id="kobo.42.1">equal area-conic projection</span></strong><span class="koboSpan" id="kobo.43.1">, which distorts scale and shape but preserves area. </span><span class="koboSpan" id="kobo.43.2">This is essential when producing dot density or hexbin maps to not distort the perceived density of the dots across distorted areas. </span><span class="koboSpan" id="kobo.43.3">To put it differently, our hexbins represent equal areas on the projected plane, hence we need to make sure that the projected plane honors equal areas with an appropriate projection. </span><span class="koboSpan" id="kobo.43.4">Note that equal area-conic projections require the map maker to pick two parallels (circles of latitude) on which the projection is based. </span><kbd><span class="koboSpan" id="kobo.44.1">d3.geoAlbers</span></kbd><span class="koboSpan" id="kobo.45.1"> has been already preconfigured, picking the two parallels </span><em><span class="koboSpan" id="kobo.46.1">[</span><span class="pl-c1"><span class="koboSpan" id="kobo.47.1">29.5</span></span><span class="koboSpan" id="kobo.48.1">,</span></em> <span class="pl-c1"><em><span class="koboSpan" id="kobo.49.1">45.5]</span></em><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">This produces an optimized projection for the US. </span><span class="koboSpan" id="kobo.50.3">When visualizing other countries or map areas, you can overwrite this with the </span><kbd><span class="koboSpan" id="kobo.51.1">.parallels()</span></kbd><span class="koboSpan" id="kobo.52.1"> method or set it up yourself with the </span><kbd><span class="koboSpan" id="kobo.53.1">d3.geoConicEqualArea()</span></kbd><span class="koboSpan" id="kobo.54.1"> projection.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The result is not too surprising:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.56.1"><img height="349" width="519" src="assets/6eff3b4a-b820-4834-a7ff-235be296018e.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.57.1">The US mainland</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span class="koboSpan" id="kobo.58.1">You can view this step in the browser at </span><a href="https://larsvers.github.io/learning-d3-mapping-11-1"><span class="koboSpan" id="kobo.59.1">https://larsvers.github.io/learning-d3-mapping-11-1</span></a><span class="koboSpan" id="kobo.60.1">. </span><span><span class="koboSpan" id="kobo.61.1">Code example ;</span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_01.html"><span class="koboSpan" id="kobo.62.1">11_01.html</span></a><span class="koboSpan" id="kobo.63.1">.</span></span></div>
<div class="packt_tip"><span class="koboSpan" id="kobo.64.1">At the conclusion of each step, you will find two links in an info box close to the relevant image. </span><span class="koboSpan" id="kobo.64.2">The first link brings you to a working implementation of this step that you can view in the browser. </span><span class="koboSpan" id="kobo.64.3">The second </span><em><span class="koboSpan" id="kobo.65.1">code example</span></em><span class="koboSpan" id="kobo.66.1"> link brings you to the full code. </span><span class="koboSpan" id="kobo.66.2">If you're reading the print version, you can find all code examples at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.67.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span class="koboSpan" id="kobo.68.1"> in their relevant chapter.</span></div>
<p><span class="koboSpan" id="kobo.69.1">Before we move on, let's take one step back and look at how we produced the </span><em><span class="koboSpan" id="kobo.70.1">TopoJSON</span></em><span class="koboSpan" id="kobo.71.1"> data on the command line. </span><span class="koboSpan" id="kobo.71.2">The original US map data comes in a shapefile from </span><a href="https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html"><span class="koboSpan" id="kobo.72.1">https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html</span></a><span class="koboSpan" id="kobo.73.1"> and is converted from shapefile to TopoJSON in six steps as follows:</span></p>
<ol>
<li class="mce-root"><span><span class="koboSpan" id="kobo.74.1">Install</span></span> <kbd><span class="koboSpan" id="kobo.75.1">shapefile</span></kbd><span><span class="koboSpan" id="kobo.76.1">, if you haven’t yet:</span></span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.77.1">npm install -g shapefile</span></strong> </pre>
<ol start="2">
<li><span><span class="koboSpan" id="kobo.78.1">Install </span><kbd><span class="koboSpan" id="kobo.79.1">topojson</span></kbd></span><span class="koboSpan" id="kobo.80.1">, if you haven’t yet:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.81.1">npm install -g topojson</span></strong></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.82.1">Convert the shapefile to GeoJSON:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.83.1">shp2json cb_2016_us_nation_20m.shp --out us-geo.json</span></strong> </pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.84.1">Convert the Geo to TopoJSON:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.85.1">geo2topo us-geo.json &gt; us-topo.json </span></strong></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.86.1">Compress number precision:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.87.1">topoquantize 1e5 &lt; us-topo.json &gt; us-quant.json </span></strong></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.88.1">Simplify the geometry:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.89.1">toposimplify -s 1e-5 -f &lt; us-quant.json &gt; us.json </span></strong></pre>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.90.1">You can read more on command-line cartography at </span><a href="http://bit.do/cl-carto"><span class="koboSpan" id="kobo.91.1">http://bit.do/cl-carto</span></a><span class="koboSpan" id="kobo.92.1">.</span></span><a href="http://bit.do/cl-carto"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing a point grid for our hexagons</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Our aim is to draw a hexagon grid across the US map. </span><span class="koboSpan" id="kobo.2.2">D3-hexbin will do this for us later, but it can only draw a hexagon where there are points. </span><span class="koboSpan" id="kobo.2.3">So, we need to feed points to it. </span><span class="koboSpan" id="kobo.2.4">These points won’t have any information value for our users. </span><span class="koboSpan" id="kobo.2.5">They will only be used to produce the layout. </span><span class="koboSpan" id="kobo.2.6">As such, we can distinguish two types of points we will need:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Layout points</span></strong><span class="koboSpan" id="kobo.4.1"> to produce the hexbin tiling</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Datapoints</span></strong><span class="koboSpan" id="kobo.6.1"> to render the color-scaled information</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">We’ll get to the datapoints soon, but at this stage, we’re only concerned with our layout points. </span><span class="koboSpan" id="kobo.7.2">Once done, you will have produced this wonderfully regular pattern of points stretching across our entire drawing area:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="505" width="749" src="assets/3b810be4-f9ec-4357-a621-5257a95a216e.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1">A grid of many points over the US</span></div>
<div class="packt_infobox"><span><span class="koboSpan" id="kobo.10.1">You can view this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-2"><span class="koboSpan" id="kobo.11.1">https://larsvers.github.io/learning-d3-mapping-11-2</span></a> <span><span class="koboSpan" id="kobo.12.1">and the c</span></span><span><span class="koboSpan" id="kobo.13.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_02.html"><span class="koboSpan" id="kobo.14.1">11_02.html</span></a><span class="koboSpan" id="kobo.15.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.16.1">In the next step, we will cut this grid to shape to fit the US silhouette, but let’s lay it out first. </span><span class="koboSpan" id="kobo.16.2">Note that this will be the most involved bit of the calculations. </span><span class="koboSpan" id="kobo.16.3">No rocket science, but don’t worry if it doesn’t click immediately. </span><span class="koboSpan" id="kobo.16.4">Things often become clearer once stepping through the code in the debugger and/or using a few </span><kbd><span class="koboSpan" id="kobo.17.1">console.log()</span></kbd><span class="koboSpan" id="kobo.18.1">’s. </span><span class="koboSpan" id="kobo.18.2">Anyway, here we go:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">var points = getPointGrid(160);</span></pre>
<p><kbd><span class="koboSpan" id="kobo.20.1">getPointGrid()</span></kbd><span class="koboSpan" id="kobo.21.1"> takes </span><span><span class="koboSpan" id="kobo.22.1">only</span></span><span class="koboSpan" id="kobo.23.1"> one argument: the number of columns of points we want. </span><span class="koboSpan" id="kobo.23.2">That’s enough for us to calculate the grid. </span><span class="koboSpan" id="kobo.23.3">First, we will get the distance in pixels between each dot. </span><span class="koboSpan" id="kobo.23.4">The distance between each dot stands in for the distance between the hexagon centers. </span><kbd><span class="koboSpan" id="kobo.24.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.25.1"> will calculate this for us precisely later, but, for now, we want to get a good approximation. </span><span class="koboSpan" id="kobo.25.2">So, if we decide to have 160 columns of dots and our width is 840, the maximum distance will be </span><em><span class="koboSpan" id="kobo.26.1">840 / 160 = 5.25</span></em><span class="koboSpan" id="kobo.27.1"> pixels. </span><span class="koboSpan" id="kobo.27.2">We then calculate the number of rows. </span><span class="koboSpan" id="kobo.27.3">The height is 540, so we can fit in </span><em><span class="koboSpan" id="kobo.28.1">540 / 5.25</span></em><span class="koboSpan" id="kobo.29.1"> rows, which equals 108 rows of dots if we round it down:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">function getPointGrid(cols) {</span><br/><span class="koboSpan" id="kobo.31.1">  var hexDistance = width / cols;</span><br/><span class="koboSpan" id="kobo.32.1">  var rows = Math.floor(height / hexDistance);</span><br/><br/><span class="koboSpan" id="kobo.33.1">  hexRadius = hexDistance/1.5;</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.34.1">Next, we will calculate the </span><kbd><span class="koboSpan" id="kobo.35.1">hexRadius</span></kbd><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">This might look funny. </span><span class="koboSpan" id="kobo.36.3">Why divide the distance by </span><em><span class="koboSpan" id="kobo.37.1">1.5</span></em><span class="koboSpan" id="kobo.38.1">? </span><span><span class="koboSpan" id="kobo.39.1">The D3-hexbin module will produce hexbins for us if we feed it </span><strong><span class="koboSpan" id="kobo.40.1">points</span></strong><span class="koboSpan" id="kobo.41.1"> and a desired hexbin </span><strong><span class="koboSpan" id="kobo.42.1">radius</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">The</span></span> <span><span class="koboSpan" id="kobo.44.1">hexagon</span></span> <span><span class="koboSpan" id="kobo.45.1">radius we set here should guarantee that the resulting hexagons are large enough to include at least one point of the grid we produce. </span><span class="koboSpan" id="kobo.45.2">We want a gap-free hexagon tiling after all. </span><span class="koboSpan" id="kobo.45.3">So,</span></span><span class="koboSpan" id="kobo.46.1"> a tight grid should have a small radius, and a wide grid should have a wider radius. </span><span class="koboSpan" id="kobo.46.2">If we had a wide grid and a small radius, we wouldn’t get a hexagon for each point. </span><span class="koboSpan" id="kobo.46.3">There would be gaps.</span></p>
<p><span class="koboSpan" id="kobo.47.1">Luckily, hexagons are regular shapes, and their dimensions and properties are nicely interconnected. </span><span class="koboSpan" id="kobo.47.2">The vertical distance between hexagon centers is 1.5 times its radius, the horizontal distance is √3 (roughly 1.73):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.48.1"><img height="440" width="870" src="assets/f9b5bd24-0c14-4ba9-a787-650c1def453c.png"/></span></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.49.1">How hexagon distance and radius relate to each other</span></div>
<p><span class="koboSpan" id="kobo.50.1">Our grid points work as a proxy of hexagon centers. </span><span class="koboSpan" id="kobo.50.2">As such they are not 'perfectly' laid out in the sense that their vertical distance is the exact same as their horizontal distance with </span><em><span class="koboSpan" id="kobo.51.1">5.25</span></em><span class="koboSpan" id="kobo.52.1"> pixels. </span><span class="koboSpan" id="kobo.52.2">In a perfect hexagon grid the vertical distance would be a little shorter than the horizontal distance as you can see in above figure. </span><span class="koboSpan" id="kobo.52.3">In order to get a relatively tight mesh of hexagons on the base of our proxy grid, we should chose a safe</span><span><span class="koboSpan" id="kobo.53.1">—</span></span><span class="koboSpan" id="kobo.54.1">meaning </span><strong><span class="koboSpan" id="kobo.55.1">wide</span><span><span class="koboSpan" id="kobo.56.1">—</span></span></strong><span class="koboSpan" id="kobo.57.1">radius to pass to the D3-hexbin module which indeed will deliver a perfect hexagon grid. </span><span class="koboSpan" id="kobo.57.2">We can calculate this radius with the formulae in the preceding figure as well as our distance (5.25 pixel) by solving for </span><em><span class="koboSpan" id="kobo.58.1">Radius</span></em><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">When re-shuffling the equation for the vertical distance </span><em><span class="koboSpan" id="kobo.60.1">Distance = 1.5 * Radius</span></em> <span><span class="koboSpan" id="kobo.61.1">becomes</span></span> <em><span class="koboSpan" id="kobo.62.1">Radius = Distance / 1.5</span></em><span><span class="koboSpan" id="kobo.63.1">. </span><span class="koboSpan" id="kobo.63.2">In our case the distance is </span><em><span class="koboSpan" id="kobo.64.1">5.25 / 1.5 =</span></em><span class="koboSpan" id="kobo.65.1"> a radius of </span><em><span class="koboSpan" id="kobo.66.1">3.5</span></em><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">Using the horizontal distance would have given us a less safe—meaning tighter—radius with</span></span> <em><span class="koboSpan" id="kobo.68.1">5.25 / √3 = 3.03</span></em><span><span class="koboSpan" id="kobo.69.1">, which in fact would produce a few gaps in our final tiling.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Next, we will create and return the grid immediately</span><span><span class="koboSpan" id="kobo.71.1">—</span></span><span class="koboSpan" id="kobo.72.1">well, the coordinates for the grid that is:</span></p>
<pre><span class="koboSpan" id="kobo.73.1">return d3.range(rows * cols).map(function(el, i) {</span><br/><span class="koboSpan" id="kobo.74.1">    return {</span><br/><span class="koboSpan" id="kobo.75.1">      x: Math.floor(i % cols * hexDistance),</span><br/><span class="koboSpan" id="kobo.76.1">      y: Math.floor(i / cols) * hexDistance,</span><br/><span class="koboSpan" id="kobo.77.1">      datapoint: 0</span><br/><span class="koboSpan" id="kobo.78.1">    }</span><br/><span class="koboSpan" id="kobo.79.1">  });</span><br/><span class="koboSpan" id="kobo.80.1">} // end of getPointGrid() function</span></pre>
<p><kbd><span class="koboSpan" id="kobo.81.1">d3.range(rows * columns)</span></kbd><span class="koboSpan" id="kobo.82.1"> creates an array with one element per dot. </span><span class="koboSpan" id="kobo.82.2">We then iterate through each dot with </span><kbd><span class="koboSpan" id="kobo.83.1">.map()</span></kbd><span class="koboSpan" id="kobo.84.1"> returning an object with three properties: </span><kbd><span class="koboSpan" id="kobo.85.1">x</span></kbd><span class="koboSpan" id="kobo.86.1">, </span><kbd><span class="koboSpan" id="kobo.87.1">y</span></kbd><span class="koboSpan" id="kobo.88.1">, and </span><kbd><span class="koboSpan" id="kobo.89.1">datapoint</span></kbd><span class="koboSpan" id="kobo.90.1">. </span><span class="koboSpan" id="kobo.90.2">These properties will define each of our grid points. </span><span class="koboSpan" id="kobo.90.3">The </span><em><span class="koboSpan" id="kobo.91.1">x</span></em><span class="koboSpan" id="kobo.92.1"> coordinate will increase by the </span><kbd><span class="koboSpan" id="kobo.93.1">hexDistance</span></kbd><span class="koboSpan" id="kobo.94.1"> every point and reset to </span><em><span class="koboSpan" id="kobo.95.1">0</span></em><span class="koboSpan" id="kobo.96.1"> for each row (or put differently, after it runs through all columns). </span><span class="koboSpan" id="kobo.96.2">The </span><em><span class="koboSpan" id="kobo.97.1">y</span></em><span class="koboSpan" id="kobo.98.1"> coordinate will increase by the </span><kbd><span class="koboSpan" id="kobo.99.1">hexDistance</span></kbd><span class="koboSpan" id="kobo.100.1"> for each new row.</span></p>
<p><span class="koboSpan" id="kobo.101.1">Equally important, each of these grid points will get a property called </span><kbd><span class="koboSpan" id="kobo.102.1">datapoints</span></kbd><span class="koboSpan" id="kobo.103.1">, which we will set to </span><em><span class="koboSpan" id="kobo.104.1">0</span></em><span class="koboSpan" id="kobo.105.1">. </span><span class="koboSpan" id="kobo.105.2">This property will distinguish all the layout points (</span><em><span class="koboSpan" id="kobo.106.1">0</span></em><span class="koboSpan" id="kobo.107.1">) from the data points (</span><em><span class="koboSpan" id="kobo.108.1">1</span></em><span class="koboSpan" id="kobo.109.1">) later, allowing us to focus on the latter.</span></p>
<p><span class="koboSpan" id="kobo.110.1">Congratulations! </span><span class="koboSpan" id="kobo.110.2">This was the most difficult bit, and you’re still here proudly lifting a square grid of tomato-colored dots into the air.</span></p>
<div>
<p><span class="koboSpan" id="kobo.111.1">Note that not crucial but extremely helpful is visualizing the grids and points we make on the way. </span><span class="koboSpan" id="kobo.111.2">Here’s a little function that draws points if they are stored in an array of objects with </span><kbd><span class="koboSpan" id="kobo.112.1">x</span></kbd><span class="koboSpan" id="kobo.113.1"> and </span><kbd><span class="koboSpan" id="kobo.114.1">y</span></kbd><span class="koboSpan" id="kobo.115.1"> properties:</span></p>
<pre><span class="koboSpan" id="kobo.116.1">function drawPointGrid(data) {</span><br/><span class="koboSpan" id="kobo.117.1">  svg.append('g').attr('id', 'circles')</span><br/><span class="koboSpan" id="kobo.118.1">    .selectAll('.dot').data(data)</span><br/><span class="koboSpan" id="kobo.119.1">    .enter().append('circle')</span><br/><span class="koboSpan" id="kobo.120.1">      .attr('cx', function(d) { return d.x; })</span><br/><span class="koboSpan" id="kobo.121.1">      .attr('cy', function(d) { return d.y; })</span><br/><span class="koboSpan" id="kobo.122.1">      .attr('r', 1)</span><br/><span class="koboSpan" id="kobo.123.1">      .attr('fill', 'tomato');</span><br/><span class="koboSpan" id="kobo.124.1">}</span></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Keeping only the points within the map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The square grid of points is still reasonably far away from the shape of the US. </span><span class="koboSpan" id="kobo.2.2">Let’s change that. </span><span class="koboSpan" id="kobo.2.3">Thanks to D3’s own </span><kbd><span class="koboSpan" id="kobo.3.1">d3.polygonContains()</span></kbd><span class="koboSpan" id="kobo.4.1"> method, this is rather simple. </span><span class="koboSpan" id="kobo.4.2">The method takes screen coordinates of a polygon and a point, and for each point returns </span><kbd><span class="koboSpan" id="kobo.5.1">true</span></kbd><span class="koboSpan" id="kobo.6.1"> if the point is in the polygon and </span><kbd><span class="koboSpan" id="kobo.7.1">false</span></kbd><span class="koboSpan" id="kobo.8.1"> if it isn’t. </span><span class="koboSpan" id="kobo.8.2">It couldn’t be more helpful.</span></p>
<p><span class="koboSpan" id="kobo.9.1">To get the polygon of our US map, we write a small function called </span><kbd><span class="koboSpan" id="kobo.10.1">getPolygonPoints()</span></kbd><span class="koboSpan" id="kobo.11.1"> and use it as a next step in our </span><kbd><span class="koboSpan" id="kobo.12.1">ready()</span></kbd><span class="koboSpan" id="kobo.13.1"> function, which so far looks like this:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">function ready(error, us) {</span><br/><span class="koboSpan" id="kobo.15.1">  var us = prepData(us);</span><br/><span class="koboSpan" id="kobo.16.1">  drawGeo(us);</span><br/><span class="koboSpan" id="kobo.17.1">  var points = getPointGrid(160);</span><br/><strong><span class="koboSpan" id="kobo.18.1">  var polygonPoints = getPolygonPoints(us);</span><br/></strong><span class="koboSpan" id="kobo.19.1">}</span></pre>
<p><span class="koboSpan" id="kobo.20.1">The only argument we pass in is the array of GeoJSON objects for our map called </span><kbd><span class="koboSpan" id="kobo.21.1">us</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">For simplicity reasons, we decided to only look at the mainland US. </span><span class="koboSpan" id="kobo.22.3">So, the first thing we need to do is focus our data on the US mainland:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">function getPolygonPoints(data) {</span><br/><span class="koboSpan" id="kobo.24.1">  var features = data.features[0].geometry.coordinates[7][0];</span><br/><br/><span class="koboSpan" id="kobo.25.1">  var polygonPoints = []</span><br/><span class="koboSpan" id="kobo.26.1">  features.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.27.1">    polygonPoints.push(projection(el));</span><br/><span class="koboSpan" id="kobo.28.1">  });</span><br/><br/><span class="koboSpan" id="kobo.29.1">  return polygonPoints;</span><br/><span class="koboSpan" id="kobo.30.1">}</span></pre>
<p><kbd><span class="koboSpan" id="kobo.31.1">data.features[0].geometry.coordinates</span></kbd><span class="koboSpan" id="kobo.32.1"> holds 11 arrays of polygon point pairs, describing mainland US as well as Alaska, Hawaii, and further offshore areas. </span><span class="koboSpan" id="kobo.32.2">We want to focus on mainland US, whose outline is represented by the first element in the </span><strong><span class="koboSpan" id="kobo.33.1">seventh</span></strong><span class="koboSpan" id="kobo.34.1"> array. </span><span class="koboSpan" id="kobo.34.2">Note that this might be different if your data comes from a different source or is being assembled differently.</span></p>
<p><span class="koboSpan" id="kobo.35.1">Then, we will loop through all </span><kbd><span class="koboSpan" id="kobo.36.1">polygonPoints</span></kbd><span class="koboSpan" id="kobo.37.1">, which are in longitude and latitude, and convert them into </span><em><span class="koboSpan" id="kobo.38.1">x</span></em><span class="koboSpan" id="kobo.39.1"> and </span><em><span class="koboSpan" id="kobo.40.1">y</span></em><span class="koboSpan" id="kobo.41.1"> coordinates for further use.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Now, we have both the polygon boundaries of the US and our grid points in pixel coordinates. </span><span class="koboSpan" id="kobo.42.2">All we need to do now is to identify the grid points that lie within mainland US:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">var usPoints = keepPointsInPolygon(points, polygonPoints);</span></pre>
<p><span class="koboSpan" id="kobo.44.1">We pass the two arrays to a function we boldly name </span><kbd><span class="koboSpan" id="kobo.45.1">keepPointsInPolygon()</span></kbd><span class="koboSpan" id="kobo.46.1">:</span></p>
<pre><span class="koboSpan" id="kobo.47.1">function keepPointsInPolygon(points, polygon) {</span><br/><span class="koboSpan" id="kobo.48.1">  var pointsInPolygon = [];</span><br/><span class="koboSpan" id="kobo.49.1">  points.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.50.1">    var inPolygon = d3.polygonContains(polygon, [el.x, el.y]);</span><br/><span class="koboSpan" id="kobo.51.1">    if (inPolygon) pointsInPolygon.push(el);</span><br/><span class="koboSpan" id="kobo.52.1">  });</span><br/><span class="koboSpan" id="kobo.53.1">  return pointsInPolygon;</span><br/><span class="koboSpan" id="kobo.54.1">}</span></pre>
<p><span class="koboSpan" id="kobo.55.1">In here, we create an empty array called </span><kbd><span class="koboSpan" id="kobo.56.1">pointsInPolygon</span></kbd><span class="koboSpan" id="kobo.57.1">, which will hold our US-exclusive points. </span><span class="koboSpan" id="kobo.57.2">We then loop through our grid points and check for each whether it’s within the US polygon or not. </span><span class="koboSpan" id="kobo.57.3">If it is, we wave it through into </span><kbd><span class="koboSpan" id="kobo.58.1">pointsInPolygon.</span></kbd></p>
<p><span class="koboSpan" id="kobo.59.1">If we were to draw these points, we would see a pointy US:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.60.1"><img height="291" width="438" src="assets/8318924b-196e-4f81-941e-7ef0bf4f3085.png"/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.61.1">The US in points</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.62.1">You can view this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-3"><span class="koboSpan" id="kobo.63.1">https://larsvers.github.io/learning-d3-mapping-11-3</span></a> <span><span class="koboSpan" id="kobo.64.1">the and c</span></span><span><span class="koboSpan" id="kobo.65.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_03.html"><span class="koboSpan" id="kobo.66.1">11_03.html</span></a><span class="koboSpan" id="kobo.67.1">.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Making the hex tile</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Points are nice and do look pretty, but we’re here for hexagons. </span><span class="koboSpan" id="kobo.2.2">So, let’s finally draw them and introduce the D3-hexbin plugin.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It needs the following two things from us and returns two, surely more valuable, things:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.4.1">We need to provide a </span><strong><span class="koboSpan" id="kobo.5.1">set of points</span></strong><span class="koboSpan" id="kobo.6.1"> in screen coordinates and the </span><strong><span class="koboSpan" id="kobo.7.1">radius</span></strong><span class="koboSpan" id="kobo.8.1"> we would like to see.</span></li>
<li><span class="koboSpan" id="kobo.9.1">It returns a grid of </span><strong><span class="koboSpan" id="kobo.10.1">hexagon center points</span></strong><span class="koboSpan" id="kobo.11.1"> (one for each hexagon) and a </span><strong><span class="koboSpan" id="kobo.12.1">hexagon path generator</span></strong><span class="koboSpan" id="kobo.13.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">We then take the new center points and the path generator and</span><span><span class="koboSpan" id="kobo.15.1">—</span></span><span class="koboSpan" id="kobo.16.1">as is custom with D3</span><span><span class="koboSpan" id="kobo.17.1">—</span></span><span class="koboSpan" id="kobo.18.1">draw it ourselves with the renderer of our choice. </span><span class="koboSpan" id="kobo.18.2">Let’s first get the hexagon center points and then draw them with SVG. </span><span class="koboSpan" id="kobo.18.3">In our </span><kbd><span class="koboSpan" id="kobo.19.1">ready()</span></kbd><span class="koboSpan" id="kobo.20.1"> function, we will add the following two lines:</span></p>
<pre class="NormalPACKT"><span><span class="koboSpan" id="kobo.21.1">function ready(error, us) {</span><br/></span><span><span class="koboSpan" id="kobo.22.1">  //previous steps</span><br/><br/></span><span class="koboSpan" id="kobo.23.1">  var hexPoints = getHexPoints(usPoints);</span><br/><span class="koboSpan" id="kobo.24.1">  drawHexmap(hexPoints);</span><br/><br/><span class="koboSpan" id="kobo.25.1">}</span></pre>
<p><kbd><span class="koboSpan" id="kobo.26.1">getHexPoints()</span></kbd><span class="koboSpan" id="kobo.27.1"> retrieves the center points and </span><kbd><span class="koboSpan" id="kobo.28.1">drawHexmap()</span></kbd><span class="koboSpan" id="kobo.29.1"> draws them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Retrieving the hexagon center points</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As mentioned fleetingly previously, </span><kbd><span class="koboSpan" id="kobo.3.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.4.1"> has two heads. </span><span class="koboSpan" id="kobo.4.2">Its first use is as a D3 </span><strong><span class="koboSpan" id="kobo.5.1">layout function</span></strong><span class="koboSpan" id="kobo.6.1"> such as the force-layout, the tree-layout, or the circle-pack-layout functions D3 offers. </span><span class="koboSpan" id="kobo.6.2">Data in, augmented data out. </span><span class="koboSpan" id="kobo.6.3">We pass our data and the desired hexagon radius to it, and, for each set of data points it can wrap its shape around, it will return the center coordinate of that hexagon.</span></p>
<p><span class="koboSpan" id="kobo.7.1">If we only gave it one data point, it would return one hexagon. </span><span class="koboSpan" id="kobo.7.2">If we gave it two data points close together so it fits into the hexagon’s width and height defined by the radius, it would also just return a single hexagon. </span><span class="koboSpan" id="kobo.7.3">If the second data point were far off the first one so that the hexagon couldn’t cover it with the given radius, </span><kbd><span class="koboSpan" id="kobo.8.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.9.1"> would produce a second hexagon, embracing that second point.</span><br/><span class="koboSpan" id="kobo.10.1">
Here we use its layouting powers:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">function getHexPoints(points) {</span><br/><span class="koboSpan" id="kobo.12.1">  hexbin = d3.hexbin() // note: global</span><br/><span class="koboSpan" id="kobo.13.1">    .radius(hexRadius)</span><br/><span class="koboSpan" id="kobo.14.1">    .x(function(d) { return d.x; })</span><br/><span class="koboSpan" id="kobo.15.1">    .y(function(d) { return d.y; });</span><br/><br/><span class="koboSpan" id="kobo.16.1">  var hexPoints = hexbin(points);</span><br/><span class="koboSpan" id="kobo.17.1">    return hexPoints;</span><br/><span class="koboSpan" id="kobo.18.1">}</span></pre>
<p><span class="koboSpan" id="kobo.19.1">First, we configure the layout. </span><span class="koboSpan" id="kobo.19.2">We add our radius of 3.5 (the Distance of 5.25 / 1.5) to it and guide its attention to where it can find the </span><kbd><span class="koboSpan" id="kobo.20.1">x</span></kbd><span class="koboSpan" id="kobo.21.1"> and </span><kbd><span class="koboSpan" id="kobo.22.1">y</span></kbd><span class="koboSpan" id="kobo.23.1"> coordinates. </span><span class="koboSpan" id="kobo.23.2">In the next row, we use it on our grid </span><kbd><span class="koboSpan" id="kobo.24.1">points</span></kbd><span class="koboSpan" id="kobo.25.1"> and return the resulting array of objects that looks as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="312" width="313" src="assets/ae453779-74aa-4d3c-8ffd-9edfe2f68e37.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1">Our hexPoints as returned by d3.hexbin()</span></div>
<div>
<p><span class="koboSpan" id="kobo.28.1">Our grid points are represented by 5,996 hexagonal center points, which we will just call </span><strong><span class="koboSpan" id="kobo.29.1">hex points</span></strong><span class="koboSpan" id="kobo.30.1"> from now on. </span><span class="koboSpan" id="kobo.30.2">Let’s briefly go through this. </span><span class="koboSpan" id="kobo.30.3">The hexbin layout returns an array. </span><span class="koboSpan" id="kobo.30.4">Each element represents a single hexagon. </span><span class="koboSpan" id="kobo.30.5">In each element, each object represents a point the hexagon covers. </span><span class="koboSpan" id="kobo.30.6">Additionally, </span><kbd><span class="koboSpan" id="kobo.31.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.32.1"> adds two keys to the array: </span><kbd><span class="koboSpan" id="kobo.33.1">x</span></kbd><span class="koboSpan" id="kobo.34.1"> and </span><kbd><span class="koboSpan" id="kobo.35.1">y</span></kbd><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">Their values represent the hexagon’s center. </span><span class="koboSpan" id="kobo.36.3">So, for each hexagon, we have all point data as well as the hexagon’s center coordinates.</span></p>
<p><span class="koboSpan" id="kobo.37.1">As you can see in the preceding screenshot, the first two hexagons cover only one grid point, whereas the third covers two grid points. </span><span class="koboSpan" id="kobo.37.2">You can also see how the center points in the array keys are slightly different from the layout points in the objects. </span><span class="koboSpan" id="kobo.37.3">Let’s visualize it.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the hex tiles</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have our hexagons and now just need to draw them. </span><span class="koboSpan" id="kobo.2.2">We do this with a new function we call </span><kbd><span class="koboSpan" id="kobo.3.1">drawHexmap(hexPoints)</span></kbd><span class="koboSpan" id="kobo.4.1"> in our </span><kbd><span class="koboSpan" id="kobo.5.1">ready()</span></kbd><span class="koboSpan" id="kobo.6.1"> function. </span><span class="koboSpan" id="kobo.6.2">It does what it says on the tin:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">function drawHexmap(points) {</span><br/><span class="koboSpan" id="kobo.8.1">  var hexes = svg.append('g').attr('id', 'hexes')</span><br/><span class="koboSpan" id="kobo.9.1">    .selectAll('.hex').data(points)</span><br/><span class="koboSpan" id="kobo.10.1">    .enter().append('path')</span><br/><span class="koboSpan" id="kobo.11.1">      .attr('class', 'hex')</span><br/><span class="koboSpan" id="kobo.12.1">      .attr('transform', function(d) { </span><br/><span class="koboSpan" id="kobo.13.1">        return 'translate(' + d.x + ', ' + d.y + ')'; })</span><br/><span class="koboSpan" id="kobo.14.1">      .attr('d', hexbin.hexagon())</span><br/><span class="koboSpan" id="kobo.15.1">      .style('fill', '#fff')</span><br/><span class="koboSpan" id="kobo.16.1">      .style('stroke', '#ccc')</span><br/><span class="koboSpan" id="kobo.17.1">      .style('stroke-width', 1);</span><br/><span class="koboSpan" id="kobo.18.1">}</span></pre>
<p><span class="koboSpan" id="kobo.19.1">We join the data (passed in as </span><kbd><span class="koboSpan" id="kobo.20.1">points)</span></kbd><span class="koboSpan" id="kobo.21.1"> with our as yet virtual selection of </span><kbd><span class="koboSpan" id="kobo.22.1">.hex</span></kbd><span class="koboSpan" id="kobo.23.1"> hexagons and use </span><kbd><span class="koboSpan" id="kobo.24.1">d.x</span></kbd><span class="koboSpan" id="kobo.25.1"> and </span><kbd><span class="koboSpan" id="kobo.26.1">d.y</span></kbd><span class="koboSpan" id="kobo.27.1"> to move to each hexagon’s center. </span><span class="koboSpan" id="kobo.27.2">At each center, we unwrap the second use of our hexbin instance: the </span><strong><span class="koboSpan" id="kobo.28.1">hexagon path generator</span></strong><span class="koboSpan" id="kobo.29.1">. </span><kbd><span class="koboSpan" id="kobo.30.1">hexbin.hexagon()</span></kbd><span class="koboSpan" id="kobo.31.1"> will return the string the path’s </span><kbd><span class="koboSpan" id="kobo.32.1">d</span></kbd><span class="koboSpan" id="kobo.33.1"> attribute requires to draw the shape. </span><span class="koboSpan" id="kobo.33.2">The dimensions of the hexagon will be based on the radius we have passed to it during configuration. </span><span class="koboSpan" id="kobo.33.3">The rest is basic styling.</span></p>
<div class="packt_tip">
<p><kbd><span class="koboSpan" id="kobo.34.1">hexbin.hexagon()</span></kbd><span class="koboSpan" id="kobo.35.1"> can also take a radius as an argument. </span><span class="koboSpan" id="kobo.35.2">Using an accessor function, we can even pass through a hexagon point-specific argument, meaning that we can change the size of each hexagon based on a data value. </span><span class="koboSpan" id="kobo.35.3">Yay! </span><span class="koboSpan" id="kobo.35.4">However, we haven’t got the time or the data for this now, so let’s get back to this later.</span></p>
</div>
<p><span class="koboSpan" id="kobo.36.1">Okay, then. </span><span class="koboSpan" id="kobo.36.2">Here’s your hex tiling; you deserve it:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.37.1"><img height="504" width="750" src="assets/a29c8a40-31ab-48f7-92b4-1779ed48d5ee.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.38.1">A hextile map</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.39.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-4"><span class="koboSpan" id="kobo.40.1">https://larsvers.github.io/learning-d3-mapping-11-4</span></a> <span><span class="koboSpan" id="kobo.41.1">the and c</span></span><span><span class="koboSpan" id="kobo.42.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_04.html"><span class="koboSpan" id="kobo.43.1">11_04.html</span></a><span class="koboSpan" id="kobo.44.1">.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Joining data points to the layout points</span></h1>
                </header>
            
            <article>
                
<div>
<p><span class="koboSpan" id="kobo.2.1">So far, we only had eyes for the base layer setup, </span><span><span class="koboSpan" id="kobo.3.1">visualising our layout points as hexagons</span></span><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Now, we’ll finally add some real data to it. </span><span class="koboSpan" id="kobo.4.3">First, we need to load it to our </span><kbd><span class="koboSpan" id="kobo.5.1">d3.queue()</span></kbd><span class="koboSpan" id="kobo.6.1">:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">d3.queue()</span><br/><span class="koboSpan" id="kobo.8.1">  .defer(d3.json, 'data/us.json')</span><br/><span class="koboSpan" id="kobo.9.1">  .defer(d3.json, 'data/markets_overall.json')</span><br/><span class="koboSpan" id="kobo.10.1">  .await(ready);</span></pre>
<p><span class="koboSpan" id="kobo.11.1">In the </span><kbd><span class="koboSpan" id="kobo.12.1">ready()</span></kbd><span class="koboSpan" id="kobo.13.1"> function, we just add another line to our visualization pipeline, triggering a function that will prepare the data for us:</span></p>
<pre class="NormalPACKT"><span><span class="koboSpan" id="kobo.14.1">function ready(error, us) {</span><br/></span><span><span class="koboSpan" id="kobo.15.1">  // … previous steps</span><br/></span><span class="koboSpan" id="kobo.16.1">  var dataPoints = getDatapoints(markets)</span><br/><span class="koboSpan" id="kobo.17.1">}</span></pre>
<p><kbd><span class="koboSpan" id="kobo.18.1">getDatapoints()</span></kbd><span class="koboSpan" id="kobo.19.1"> simply takes in the loaded CSV data and returns a more concise object boasting </span><em><span class="koboSpan" id="kobo.20.1">x</span></em><span class="koboSpan" id="kobo.21.1"> and </span><em><span class="koboSpan" id="kobo.22.1">y</span></em><span class="koboSpan" id="kobo.23.1"> screen coordinates as well as the </span><kbd><span class="koboSpan" id="kobo.24.1">datapoint</span></kbd><span class="koboSpan" id="kobo.25.1"> flag, indicating that this is not a layout point but an actual data point. </span><span class="koboSpan" id="kobo.25.2">The rest is market-specific data, such as </span><kbd><span class="koboSpan" id="kobo.26.1">name</span></kbd><span class="koboSpan" id="kobo.27.1">, </span><kbd><span class="koboSpan" id="kobo.28.1">state</span></kbd><span class="koboSpan" id="kobo.29.1">, </span><kbd><span class="koboSpan" id="kobo.30.1">city</span></kbd><span class="koboSpan" id="kobo.31.1">, and </span><kbd><span class="koboSpan" id="kobo.32.1">url</span></kbd><span class="koboSpan" id="kobo.33.1">, we can use to add as info to each hexagon:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">function getDatapoints(data) {</span><br/><br/><span class="koboSpan" id="kobo.35.1">  return data.map(function(el) {</span><br/><span class="koboSpan" id="kobo.36.1">    var coords = projection([+el.lng, +el.lat]);</span><br/><span class="koboSpan" id="kobo.37.1">    return {</span><br/><span class="koboSpan" id="kobo.38.1">      x: coords[0],</span><br/><span class="koboSpan" id="kobo.39.1">      y: coords[1],</span><br/><span class="koboSpan" id="kobo.40.1">      datapoint: 1,</span><br/><span class="koboSpan" id="kobo.41.1">      name: el.MarketName,</span><br/><span class="koboSpan" id="kobo.42.1">      state: el.State,</span><br/><span class="koboSpan" id="kobo.43.1">      city: el.city,</span><br/><span class="koboSpan" id="kobo.44.1">      url: el.Website</span><br/><span class="koboSpan" id="kobo.45.1">    }</span><br/><span class="koboSpan" id="kobo.46.1">  });</span><br/><br/><span class="koboSpan" id="kobo.47.1">}</span></pre>
<p><span class="koboSpan" id="kobo.48.1">Back in the </span><kbd><span class="koboSpan" id="kobo.49.1">ready()</span></kbd><span class="koboSpan" id="kobo.50.1"> function, you just concatenate these data points to the layout points for the complete dataset you will use for your final hexbin map:</span></p>
<pre class="NormalPACKT"><span><span class="koboSpan" id="kobo.51.1">function ready(error, us) {</span><br/></span><span><span class="koboSpan" id="kobo.52.1">  // … previous steps</span><br/></span><span><br/><span class="koboSpan" id="kobo.53.1">  var dataPoints = getDatapoints(markets)</span><br/></span><span><strong><span class="koboSpan" id="kobo.54.1">  var mergedPoints = usPoints.concat(dataPoints)</span></strong><br/></span><span><span class="koboSpan" id="kobo.55.1">}</span></span></pre>
<p><span><span class="koboSpan" id="kobo.56.1">Here’s the markets data visualized as a classic dot density map in blue as well as together with the grid layout data in red:</span></span></p>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.57.1"><img src="assets/61b608af-681b-4e39-b645-756290bc4f96.png"/></span></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.58.1">The left image shows the farmers' markets points; the right image shows the farmers' markets points in blue and layout points in red.</span></div>
<div class="mce-root packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.59.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-5"><span class="koboSpan" id="kobo.60.1">https://larsvers.github.io/learning-d3-mapping-11-5</span></a> <span><span class="koboSpan" id="kobo.61.1">the and c</span></span><span><span class="koboSpan" id="kobo.62.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_05.html"><span class="koboSpan" id="kobo.63.1">11_05.html</span></a><span class="koboSpan" id="kobo.64.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.65.1">Great! </span><span class="koboSpan" id="kobo.65.2">We’re one final step away from our hexmap. </span><span class="koboSpan" id="kobo.65.3">We need to create a value we can visualize: the number of markets.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dressing our data for the final act</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You have some real data about farmer's markets joined with the hexagons, but you can’t use it yet. </span><span class="koboSpan" id="kobo.2.2">All your data is still tucked away in the array of objects per hexagon. </span><span class="koboSpan" id="kobo.2.3">Let’s roll this data up.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The measure we want to visualize is the number of farmer's markets in each hexagonal area. </span><span class="koboSpan" id="kobo.3.2">Hence, all we need to do is to count the objects that have their </span><kbd><span class="koboSpan" id="kobo.4.1">datapoint</span></kbd><span class="koboSpan" id="kobo.5.1"> value set to </span><em><span class="koboSpan" id="kobo.6.1">1</span></em><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">While we’re at it, let’s also remove the layout point objects, that is, the objects with </span><kbd><span class="koboSpan" id="kobo.8.1">datapoint</span></kbd><span class="koboSpan" id="kobo.9.1"> value </span><em><span class="koboSpan" id="kobo.10.1">0</span></em><span class="koboSpan" id="kobo.11.1">; we won’t need them anymore.</span></p>
<p><span class="koboSpan" id="kobo.12.1">We will add our task to the </span><kbd><span class="koboSpan" id="kobo.13.1">ready()</span></kbd><span class="koboSpan" id="kobo.14.1"> function:</span></p>
<pre class="NormalPACKT"><span><span class="koboSpan" id="kobo.15.1">function ready(error, us) {</span><br/></span><span><span class="koboSpan" id="kobo.16.1">  // … previous steps</span><br/><br/></span><span class="koboSpan" id="kobo.17.1">  var hexPointsRolledup = rollupHexPoints(hexPoints);</span><br/><span class="koboSpan" id="kobo.18.1">}</span></pre>
<p><span class="koboSpan" id="kobo.19.1">Primarily, </span><kbd><span class="koboSpan" id="kobo.20.1">rollupHexPoints()</span></kbd><span class="koboSpan" id="kobo.21.1"> will roll up the number of markets per hex point. </span><span class="koboSpan" id="kobo.21.2">It will turn the upper hexagon data into the lower hexagon data of the following figure:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="300" width="859" src="assets/fc65ca7e-4756-4dbf-a7ad-30153417b962.png"/></span></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.23.1">The hexagon data before and after roll-up</span></div>
<p><kbd><span class="koboSpan" id="kobo.24.1">rollupHexPoints()</span></kbd><span class="koboSpan" id="kobo.25.1"> will perform the following things in an order:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.26.1">Remove the layout grid points.</span></li>
<li><span class="koboSpan" id="kobo.27.1">Count the number of datapoints and add the count as a new property called </span><kbd><span class="koboSpan" id="kobo.28.1">datapoints</span></kbd><span class="koboSpan" id="kobo.29.1">.</span></li>
<li><span class="koboSpan" id="kobo.30.1">Collect key markets data in single array called </span><kbd><span class="koboSpan" id="kobo.31.1">markets</span></kbd><span class="koboSpan" id="kobo.32.1"> for easy interaction access.</span></li>
<li><span class="koboSpan" id="kobo.33.1">Finally, it will produce a color scale we so dearly need for the hexagon coloring.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.34.1">Here we go:</span></p>
<pre><span class="koboSpan" id="kobo.35.1">function rollupHexPoints(data) {</span><br/><span class="koboSpan" id="kobo.36.1">  var maxCount = 0;</span></pre>
<p><span class="koboSpan" id="kobo.37.1">We start by initializing a </span><kbd><span class="koboSpan" id="kobo.38.1">maxCount</span></kbd><span class="koboSpan" id="kobo.39.1"> variable that will later have the maximum number of farmers' markets in a single hexagon. </span><span class="koboSpan" id="kobo.39.2">We’ll need this for the color scale.</span></p>
<p><span class="koboSpan" id="kobo.40.1">Next, we’ll loop through all the layout and data points:</span></p>
<pre><span class="koboSpan" id="kobo.41.1">  data.forEach(function(el) {</span><br/><br/><span class="koboSpan" id="kobo.42.1">    for (var i = el.length - 1; i &gt;= 0; --i) {</span><br/><span class="koboSpan" id="kobo.43.1">      if (el[i].datapoint === 0) {</span><br/><span class="koboSpan" id="kobo.44.1">        el.splice(i, 1);</span><br/><span class="koboSpan" id="kobo.45.1">      }</span><br/><span class="koboSpan" id="kobo.46.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.47.1">First, we will get rid of all the layout point objects with </span><kbd><span class="koboSpan" id="kobo.48.1">splice()</span></kbd><span class="koboSpan" id="kobo.49.1"> if the </span><kbd><span class="koboSpan" id="kobo.50.1">datapoint</span></kbd><span class="koboSpan" id="kobo.51.1"> property holds a </span><kbd><span class="koboSpan" id="kobo.52.1">0</span></kbd><span class="koboSpan" id="kobo.53.1">.</span></p>
<p><span class="koboSpan" id="kobo.54.1">Next, we will create the rolled-up data. </span><span class="koboSpan" id="kobo.54.2">There will be two rolled-up data elements: an integer representing the total count of farmers' markets within the hexagon and an array of market data we can use for later interaction. </span><span class="koboSpan" id="kobo.54.3">First, we will set up the variables:</span></p>
<pre><span class="koboSpan" id="kobo.55.1">    var count = 0,</span><br/><span class="koboSpan" id="kobo.56.1">        markets = [];</span><br/>  <br/><span class="koboSpan" id="kobo.57.1">    el.forEach(function(elt) {</span><br/><span class="koboSpan" id="kobo.58.1">      count++;</span><br/><span class="koboSpan" id="kobo.59.1">      var obj = {};</span><br/><span class="koboSpan" id="kobo.60.1">      obj.name = elt.name;</span><br/><span class="koboSpan" id="kobo.61.1">      obj.state = elt.state;</span><br/><span class="koboSpan" id="kobo.62.1">      obj.city = elt.city;</span><br/><span class="koboSpan" id="kobo.63.1">      obj.url = elt.url;</span><br/><span class="koboSpan" id="kobo.64.1">      markets.push(obj);</span><br/><span class="koboSpan" id="kobo.65.1">    });</span><br/><br/><span class="koboSpan" id="kobo.66.1">    el.datapoints = count;</span><br/><span class="koboSpan" id="kobo.67.1">    el.markets = markets;</span></pre>
<p><span class="koboSpan" id="kobo.68.1">We loop through each object within the hexagon array of objects, and once we’ve collected the data, we add it as keys to the array. </span><span class="koboSpan" id="kobo.68.2">This data is now on the same level as the </span><em><span class="koboSpan" id="kobo.69.1">x</span></em><span class="koboSpan" id="kobo.70.1"> and </span><em><span class="koboSpan" id="kobo.71.1">y</span></em><span class="koboSpan" id="kobo.72.1"> coordinates for the hex points.</span></p>
<p><span class="koboSpan" id="kobo.73.1">Note that we could have taken a shortcut to summarize the count of markets. </span><span class="koboSpan" id="kobo.73.2">Our </span><kbd><span class="koboSpan" id="kobo.74.1">datapoints</span></kbd><span class="koboSpan" id="kobo.75.1"> property just counts the number of elements in the array. </span><span class="koboSpan" id="kobo.75.2">This is exactly the same as what the in-built </span><kbd><span class="koboSpan" id="kobo.76.1">Array.length</span></kbd><span class="koboSpan" id="kobo.77.1"> property does. </span><span class="koboSpan" id="kobo.77.2">However, this is a more conscious and descriptive way of doing it without adding much more complexity.</span></p>
<p><span><span class="koboSpan" id="kobo.78.1">The last thing we do in the loop is to update</span></span> <kbd><span class="koboSpan" id="kobo.79.1">maxCount</span></kbd> <span><span class="koboSpan" id="kobo.80.1">if the count value of this particular hexagon is higher than the</span></span> <kbd><span class="koboSpan" id="kobo.81.1">maxCount</span></kbd> <span><span class="koboSpan" id="kobo.82.1">value of all previous hexagons we looped through:</span></span></p>
<pre><span class="koboSpan" id="kobo.83.1">    maxCount = Math.max(maxCount, count);</span><br/><br/><span class="koboSpan" id="kobo.84.1">  }); // end of loop through hexagons</span><br/><br/><span class="koboSpan" id="kobo.85.1">  colorScale = d3.scaleSequential(d3.interpolateViridis)</span><br/><span class="koboSpan" id="kobo.86.1">    .domain([maxCount, 1]);</span><br/><br/><span class="koboSpan" id="kobo.87.1">  return data;</span><br/><br/><span class="koboSpan" id="kobo.88.1">} // end of rollupHexPoints()</span></pre>
<p><span class="koboSpan" id="kobo.89.1">The last thing we do in our roll-up function is to create our </span><kbd><span class="koboSpan" id="kobo.90.1">colorScale</span></kbd><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">We’re using the </span><em><span class="koboSpan" id="kobo.92.1">Viridis</span></em><span class="koboSpan" id="kobo.93.1"> color scale, which has great properties for visualizing count data. </span><span class="koboSpan" id="kobo.93.2">Note that </span><em><span class="koboSpan" id="kobo.94.1">Viridis</span></em><span class="koboSpan" id="kobo.95.1"> maps low numbers to purple and high numbers to yellow. </span><span class="koboSpan" id="kobo.95.2">However, we want high numbers to be darker (more purple) and low numbers to be lighter (more yellow). </span><span class="koboSpan" id="kobo.95.3">We will achieve this by just flipping our domain mapping.</span></p>
<p><span class="koboSpan" id="kobo.96.1">The way scales work internally is that each value we feed from our domain will be normalized to a value between </span><em><span class="koboSpan" id="kobo.97.1">0</span></em><span class="koboSpan" id="kobo.98.1"> and </span><em><span class="koboSpan" id="kobo.99.1">1</span></em><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">The first number we set in the array we pass to </span><kbd><span class="koboSpan" id="kobo.101.1">.domain()</span></kbd><span class="koboSpan" id="kobo.102.1"> will be normalized to </span><em><span class="koboSpan" id="kobo.103.1">0—</span></em><span class="koboSpan" id="kobo.104.1">that's </span><kbd><span class="koboSpan" id="kobo.105.1">maxCount</span></kbd><span class="koboSpan" id="kobo.106.1"> or 169 in our case. </span><span class="koboSpan" id="kobo.106.2">The second number (1) will be normalized to </span><em><span class="koboSpan" id="kobo.107.1">1</span></em><span class="koboSpan" id="kobo.108.1">. </span><span><span class="koboSpan" id="kobo.109.1">The output range will also be mapped to the range from </span><em><span class="koboSpan" id="kobo.110.1">0</span></em><span class="koboSpan" id="kobo.111.1"> to </span><em><span class="koboSpan" id="kobo.112.1">1</span></em><span class="koboSpan" id="kobo.113.1">, which for </span><em><span class="koboSpan" id="kobo.114.1">Viridis</span></em><span class="koboSpan" id="kobo.115.1"> means </span><em><span class="koboSpan" id="kobo.116.1">0 = purple</span></em><span class="koboSpan" id="kobo.117.1"> and </span><em><span class="koboSpan" id="kobo.118.1">1 = yellow</span></em><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">When we send a value to our scale, it will normalize the value and return the corresponding range value between </span><em><span class="koboSpan" id="kobo.120.1">0</span></em><span class="koboSpan" id="kobo.121.1"> and </span><em><span class="koboSpan" id="kobo.122.1">1</span></em><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">Here is what happens when we</span></span> <span><span class="koboSpan" id="kobo.124.1">feed it the number 24:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.125.1">The scale receives </span><em><span class="koboSpan" id="kobo.126.1">24</span></em><span class="koboSpan" id="kobo.127.1"> as an input (as in </span><kbd><span class="koboSpan" id="kobo.128.1">colorScale(24)</span></kbd><span class="koboSpan" id="kobo.129.1">).</span></li>
<li><span class="koboSpan" id="kobo.130.1">According to the </span><kbd><span class="koboSpan" id="kobo.131.1">.domain()</span></kbd><span class="koboSpan" id="kobo.132.1"> input (</span><kbd><span class="koboSpan" id="kobo.133.1">[max, min]</span></kbd><span class="koboSpan" id="kobo.134.1"> rather than </span><kbd><span class="koboSpan" id="kobo.135.1">[min, max]</span></kbd><span class="koboSpan" id="kobo.136.1">), the scale normalizes </span><em><span class="koboSpan" id="kobo.137.1">24</span></em><span class="koboSpan" id="kobo.138.1"> to </span><em><span class="koboSpan" id="kobo.139.1">0.84.</span></em></li>
<li><span class="koboSpan" id="kobo.140.1">Next, the scale queries the </span><em><span class="koboSpan" id="kobo.141.1">Viridis</span></em><span class="koboSpan" id="kobo.142.1"> interpolator about which color corresponds to the value of </span><em><span class="koboSpan" id="kobo.143.1">0.84</span></em><span class="koboSpan" id="kobo.144.1"> on the </span><em><span class="koboSpan" id="kobo.145.1">Viridis</span></em><span class="koboSpan" id="kobo.146.1"> color scale. </span><span class="koboSpan" id="kobo.146.2">The interpolator comes back with the color </span><span><kbd><span class="koboSpan" id="kobo.147.1">#a2da37</span></kbd><span class="koboSpan" id="kobo.148.1">, which is a light green. </span><span class="koboSpan" id="kobo.148.2">This makes sense, as 0.84 is closer to 1, which represents yellow. </span><span class="koboSpan" id="kobo.148.3">Light green is obviously closer to yellow than to dark purple, which is encoded as </span><em><span class="koboSpan" id="kobo.149.1">0</span></em><span class="koboSpan" id="kobo.150.1"> by the interpolator.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.151.1">That was is it!</span></p>
<p><span class="koboSpan" id="kobo.152.1">Nearly. </span><span class="koboSpan" id="kobo.152.2">The very last thing we have to do is to jump into our </span><kbd><span class="koboSpan" id="kobo.153.1">drawHexmap()</span></kbd><span class="koboSpan" id="kobo.154.1"> function and change the hexagon coloring to our </span><kbd><span class="koboSpan" id="kobo.155.1">colorScale:</span></kbd></p>
<pre><span class="koboSpan" id="kobo.156.1">function drawHexmap(points) {</span><br/><span class="koboSpan" id="kobo.157.1">  var hexes = svg.append('g').attr('id', 'hexes')</span><br/><span class="koboSpan" id="kobo.158.1">   .selectAll('.hex').data(points)</span><br/><span class="koboSpan" id="kobo.159.1">   .enter().append('path')</span><br/><span class="koboSpan" id="kobo.160.1">     .attr('class', 'hex')</span><br/><span class="koboSpan" id="kobo.161.1">     .attr('transform', function(d) { </span><br/><span class="koboSpan" id="kobo.162.1">        return 'translate(' + d.x + ', ' + d.y +')'; </span><br/><span class="koboSpan" id="kobo.163.1">     })</span><br/><span class="koboSpan" id="kobo.164.1">     .attr('d', hexbin.hexagon())</span><br/><strong><span class="koboSpan" id="kobo.165.1">     .style('fill', function(d) { </span><br/><span class="koboSpan" id="kobo.166.1">        return d.datapoints === 0 ? </span><span class="koboSpan" id="kobo.166.2">'none' : colorScale(d.datapoints); </span><br/><span class="koboSpan" id="kobo.167.1">     })</span><br/></strong><span class="koboSpan" id="kobo.168.1">     .style('stroke', '#ccc')</span><br/><span class="koboSpan" id="kobo.169.1">     .style('stroke-width', 1);</span><br/><span class="koboSpan" id="kobo.170.1">}</span></pre>
<p><span class="koboSpan" id="kobo.171.1">If the hexagons don’t cover any markets, their data points property will be 0 and we won’t color it. </span><span class="koboSpan" id="kobo.171.2">Otherwise, we pick the appropriate Viridis color.</span></p>
<p><span class="koboSpan" id="kobo.172.1">Here it is:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.173.1"><img height="504" width="750" src="assets/8b646bfc-a4db-4f86-b792-babd53d1d1b6.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.174.1">A very yellow hexbin map</span></div>
<p><span class="koboSpan" id="kobo.175.1">Looks pretty yellow, doesn’t it? </span><span class="koboSpan" id="kobo.175.2">The problem is that we have a few outliers in our data. </span><span class="koboSpan" id="kobo.175.3">That single dark purple dot on the East Coast is New York, which has significantly more farmers' markets than any other area (169). </span><span class="koboSpan" id="kobo.175.4">Washington and Boston are busy as well. </span><span class="koboSpan" id="kobo.175.5">However, that makes our visual less interesting. </span><span class="koboSpan" id="kobo.175.6">Looking at the distribution of numbers tells us that most hexagons enclose 20 or less markets:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.176.1"><img height="370" width="604" src="assets/ba805ff6-779c-4391-8b98-363890f4abfb.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.177.1">Number of farmers' markets per hexagon</span></div>
<p><span class="koboSpan" id="kobo.178.1">The highest number of markets per hexagon, however, is currently 169. </span><span class="koboSpan" id="kobo.178.2">We can do two things here. </span><span class="koboSpan" id="kobo.178.3">We can either choose a lower value as our maximum color scale value, say 20. </span><span class="koboSpan" id="kobo.178.4">That would only scale our values from 1 to 20 to the </span><em><span class="koboSpan" id="kobo.179.1">Viridis</span></em><span class="koboSpan" id="kobo.180.1"> spectrum. </span><span class="koboSpan" id="kobo.180.2">A</span><span><span class="koboSpan" id="kobo.181.1">ll hexagons with higher values would receive the maximum colour (purple) by default.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">A more elegant alternative is to use an </span><strong><span class="koboSpan" id="kobo.183.1">exponential interpolator</span></strong><span class="koboSpan" id="kobo.184.1"> for the color scale. </span><span class="koboSpan" id="kobo.184.2">Our domain would map not linearly but exponentially to our color output, effectively reaching the end of our color spectrum (purple) with much lower values. </span><span class="koboSpan" id="kobo.184.3">To achieve this, we just need a new color scale with a custom interpolator. </span><span class="koboSpan" id="kobo.184.4">Let's take a look at the code first:</span></p>
<pre><span class="koboSpan" id="kobo.185.1">colorScale = d3.scaleSequential(function(t) {</span><br/><br/><span class="koboSpan" id="kobo.186.1">    var tNew = Math.pow(t,10);</span><br/><span class="koboSpan" id="kobo.187.1">    return d3.interpolateViridis(tNew)</span><br/><br/><span class="koboSpan" id="kobo.188.1">}).domain([maxCount, 1]);</span></pre>
<p><span class="koboSpan" id="kobo.189.1">What exactly are we doing here? </span><span class="koboSpan" id="kobo.189.2">Let's reconsider the scaling steps we went through in the preceding code:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.190.1">The scale receives a number </span><em><span class="koboSpan" id="kobo.191.1">24</span></em><span class="koboSpan" id="kobo.192.1"> (as in </span><kbd><span class="koboSpan" id="kobo.193.1">colorScale(24)</span></kbd><span class="koboSpan" id="kobo.194.1">).</span></li>
<li><span class="koboSpan" id="kobo.195.1">According to the </span><kbd><span class="koboSpan" id="kobo.196.1">.domain()</span></kbd><span class="koboSpan" id="kobo.197.1"> input (</span><kbd><span class="koboSpan" id="kobo.198.1">[max, min]</span></kbd><span class="koboSpan" id="kobo.199.1"> rather than </span><kbd><span class="koboSpan" id="kobo.200.1">[min, max]</span></kbd><span class="koboSpan" id="kobo.201.1">), the scale normalizes </span><em><span class="koboSpan" id="kobo.202.1">24</span></em><span class="koboSpan" id="kobo.203.1"> to 0.84. </span><span class="koboSpan" id="kobo.203.2">No change for points </span><em><span class="koboSpan" id="kobo.204.1">1</span></em><span class="koboSpan" id="kobo.205.1"> and </span><em><span class="koboSpan" id="kobo.206.1">2</span></em><span class="koboSpan" id="kobo.207.1">.</span></li>
<li><span class="koboSpan" id="kobo.208.1">With the old </span><kbd><span class="koboSpan" id="kobo.209.1">colorScale</span></kbd><span class="koboSpan" id="kobo.210.1">, we just waved through this </span><em><span class="koboSpan" id="kobo.211.1">linearly normalized value</span></em><span class="koboSpan" id="kobo.212.1"> between </span><em><span class="koboSpan" id="kobo.213.1">1</span></em><span class="koboSpan" id="kobo.214.1"> and </span><em><span class="koboSpan" id="kobo.215.1">0</span></em><span class="koboSpan" id="kobo.216.1"> without us interfering. </span><span class="koboSpan" id="kobo.216.2">Now, we catch it as an argument to a callback. </span><span class="koboSpan" id="kobo.216.3">Convention lets us call this </span><kbd><span class="koboSpan" id="kobo.217.1">t</span></kbd><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">Now, we can use and transform this however we desire. </span><span class="koboSpan" id="kobo.218.3">As we saw previously, many hexagons encircle 1 to 20 markets, very few encircle more. </span><span class="koboSpan" id="kobo.218.4">So we want to traverse the majority of the Viridis color space in the lower range of our values so that the color scale encodes the interesting part of our data. </span><span class="koboSpan" id="kobo.218.5">How do we do this?</span></li>
<li><span class="koboSpan" id="kobo.219.1">Before we pass </span><kbd><span class="koboSpan" id="kobo.220.1">t</span></kbd><span class="koboSpan" id="kobo.221.1"> to our color interpolator, we set it to the </span><em><span class="koboSpan" id="kobo.222.1">power of 10</span></em><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">We can use a different exponent, but </span><em><span class="koboSpan" id="kobo.224.1">10</span></em><span class="koboSpan" id="kobo.225.1"> works fine. </span><span class="koboSpan" id="kobo.225.2">In general, taking the power of a number between </span><em><span class="koboSpan" id="kobo.226.1">0</span></em><span class="koboSpan" id="kobo.227.1"> and </span><em><span class="koboSpan" id="kobo.228.1">1</span></em><span class="koboSpan" id="kobo.229.1"> returns a smaller number. </span><span class="koboSpan" id="kobo.229.2">The higher the power, the smaller the output will be. </span><span class="koboSpan" id="kobo.229.3">Our linear </span><kbd><span class="koboSpan" id="kobo.230.1">t</span></kbd><span class="koboSpan" id="kobo.231.1"> was </span><em><span class="koboSpan" id="kobo.232.1">0.84</span></em><span class="koboSpan" id="kobo.233.1">; our exponential </span><kbd><span class="koboSpan" id="kobo.234.1">tNew</span></kbd><span class="koboSpan" id="kobo.235.1"> equals </span><em><span class="koboSpan" id="kobo.236.1">0.23</span></em><span class="koboSpan" id="kobo.237.1">.</span></li>
<li><span class="koboSpan" id="kobo.238.1">Finally, we pass </span><kbd><span class="koboSpan" id="kobo.239.1">tNew</span></kbd><span class="koboSpan" id="kobo.240.1"> to the </span><em><span class="koboSpan" id="kobo.241.1">Viridis</span></em><span class="koboSpan" id="kobo.242.1"> interpolator, which spits out the respective—much darker</span><span><span class="koboSpan" id="kobo.243.1">—</span></span><span class="koboSpan" id="kobo.244.1">color.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.245.1">Let's graph this transformation to clarify:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.246.1"><img src="assets/2c99ded5-f9ee-434e-9985-91e0df2bce73.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.247.1">Linear versus exponential color interpolation</span></div>
<p><span class="koboSpan" id="kobo.248.1">The </span><em><span class="koboSpan" id="kobo.249.1">x axis</span></em><span class="koboSpan" id="kobo.250.1"> shows the input values, the </span><em><span class="koboSpan" id="kobo.251.1">y axis</span></em><span class="koboSpan" id="kobo.252.1"> shows our scale-normalized value </span><kbd><span class="koboSpan" id="kobo.253.1">t</span></kbd><span class="koboSpan" id="kobo.254.1"> that we send to the interpolator to retrieve a corresponding color. </span><span class="koboSpan" id="kobo.254.2">The </span><strong><span class="koboSpan" id="kobo.255.1">left graph</span></strong><span class="koboSpan" id="kobo.256.1"> shows what a linear interpolation does. </span><span class="koboSpan" id="kobo.256.2">It linearly translates the increase of values to the decrease in </span><kbd><span class="koboSpan" id="kobo.257.1">t</span></kbd><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">The curve in the </span><strong><span class="koboSpan" id="kobo.259.1">right graph</span></strong><span class="koboSpan" id="kobo.260.1"> shows us how our adjusted </span><kbd><span class="koboSpan" id="kobo.261.1">tNew</span></kbd><span class="koboSpan" id="kobo.262.1"> behaves after setting </span><kbd><span class="koboSpan" id="kobo.263.1">t</span></kbd><span class="koboSpan" id="kobo.264.1"> to the </span><em><span class="koboSpan" id="kobo.265.1">power of 10</span></em><span class="koboSpan" id="kobo.266.1">: we enter the lower regions of </span><kbd><span class="koboSpan" id="kobo.267.1">t</span></kbd><span class="koboSpan" id="kobo.268.1"> (the more purple regions) with much smaller input values. </span><span class="koboSpan" id="kobo.268.2">Put differently, we traverse the color space from yellow to purple in a much smaller range of domain values. </span><span class="koboSpan" id="kobo.268.3">Piping our example value of 24 through a </span><em><span class="koboSpan" id="kobo.269.1">linear interpolation</span></em><span class="koboSpan" id="kobo.270.1"> would return a yellowish green; piping it through our </span><em><span class="koboSpan" id="kobo.271.1">exponential interpolation</span></em><span class="koboSpan" id="kobo.272.1"> already returns a </span><span><span class="koboSpan" id="kobo.273.1">purple value</span></span><span class="koboSpan" id="kobo.274.1"> from the end of the color spectrum.</span></p>
<p><span class="koboSpan" id="kobo.275.1">The main win this brings is that color differences can be seen where the data is rather than where the gap between the main data cluster and the outlier is. </span><span class="koboSpan" id="kobo.275.2">Here is our hexbin map with an exponential scale:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.276.1"><img height="450" width="670" src="assets/87e8893d-023b-44c8-aedb-ba89420c07ac.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.277.1">A more interestingly colored hexbin map</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.278.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-6"><span class="koboSpan" id="kobo.279.1">https://larsvers.github.io/learning-d3-mapping-11-6</span></a> <span><span class="koboSpan" id="kobo.280.1">the and c</span></span><span><span class="koboSpan" id="kobo.281.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_06.html"><span class="koboSpan" id="kobo.282.1">11_06.html</span></a><span class="koboSpan" id="kobo.283.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.284.1">Let’s just revel in our achievement for a moment, but are we done? </span><span class="koboSpan" id="kobo.284.2">We’re itching to explore this map a little more. </span><span class="koboSpan" id="kobo.284.3">After all, people are used to playing with maps, trying to locate themselves in them or move from one area to the other with ease. </span><span class="koboSpan" id="kobo.284.4">That’s what we will allow for in our last step.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Turning our visual into an interactive app</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You have officially built a hexbin map, and that was indeed the key focus of this chapter. </span><span class="koboSpan" id="kobo.2.2">However, in this last section, let’s leisurely consider how we might make this more engaging and informative for ourselves and our users. </span><span class="koboSpan" id="kobo.2.3">We won’t go into as much detail as in the previous sections, but will go through general steps about how to improve the app.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Here’s a list of what we can do:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.4.1">Show the markets in a list on hover.</span></li>
<li><span class="koboSpan" id="kobo.5.1">Let the user change the hexagon size.</span></li>
<li><span class="koboSpan" id="kobo.6.1">Let the user change the exponent for the color scale interpolator.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Show which markets sell specific products, e.g. </span><span class="koboSpan" id="kobo.7.2">cheese, wine, seafood, etc.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Encode a second variable as hexagon size.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.9.1">The first is standard. </span><span class="koboSpan" id="kobo.9.2">The second and third point would be very helpful for exploration of the data. </span><span class="koboSpan" id="kobo.9.3">The fourth point is indeed possible, as the data also covers variables specifying what products each market sells. </span><span class="koboSpan" id="kobo.9.4">The last point would be good for our own practice with the </span><kbd><span class="koboSpan" id="kobo.10.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.11.1"> module.</span></p>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.12.1">We won’t go into detail of each of these points, but do take a look at the finished app at </span><a href="https://larsvers.github.io/learning-d3-mapping-11-8"><span class="koboSpan" id="kobo.13.1">https://larsvers.github.io/learning-d3-mapping-11-8</span></a><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">The code is commented and available as </span><span><span class="koboSpan" id="kobo.15.1">example</span></span> <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html"><span class="koboSpan" id="kobo.16.1">11_08.html</span></a> <span><span class="koboSpan" id="kobo.17.1">in the </span><kbd><span class="koboSpan" id="kobo.18.1">Chapter 11</span></kbd><span class="koboSpan" id="kobo.19.1"> folder</span></span> <span><span class="koboSpan" id="kobo.20.1">at</span></span> <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.21.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span class="koboSpan" id="kobo.22.1">.</span><a href="https://github.com/larsvers/ld3m_ch4ex8"/></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Adding additional information on hover and click</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Tooltips are a helpful exploration technique for most visualizations in order to give the user details on a certain data point or area. </span><span class="koboSpan" id="kobo.2.2">In this case, the smallest data units of the app are the hexagons. </span><span class="koboSpan" id="kobo.2.3">However, some of the hexagons contain more information that would fit on a tooltip—up to 169 as we’ve seen above. </span><span class="koboSpan" id="kobo.2.4">To allow the user to browse the markets per area, we will add a side panel listing all the markets in the hovered hexagon. </span><span class="koboSpan" id="kobo.2.5">This is how it could look:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="445" width="870" src="assets/1ba70117-040b-469b-81c9-515964e91d8b.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Interactive hexbin map with title, tooltip, and list of markets per hexagon</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.5.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-8"><span class="koboSpan" id="kobo.6.1">https://larsvers.github.io/learning-d3-mapping-11-8</span></a><span><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">the and c</span></span><span><span class="koboSpan" id="kobo.8.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html"><span class="koboSpan" id="kobo.9.1">11_08.html</span></a><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">Please use a recent version of the Chrome browser to view or work along these examples.</span></span></div>
<p><span class="koboSpan" id="kobo.11.1">The list changes rapidly when the user moves around, so a click on a hexagon would lock the list view so that the user can explore and potentially use the links to get to the markets' websites.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Changing the hexagon size</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A key advantage of hexbin maps compared to dot density maps is that interaction is easier. </span><span class="koboSpan" id="kobo.2.2">If you have many dots on a map, you might have to keep them small (1-3 pixels) to convey a good sense of the data. </span><span class="koboSpan" id="kobo.2.3">Such small targets are hard to catch with the mouse. </span><span class="koboSpan" id="kobo.2.4">Furthermore, some dots will inevitably overlap, so you can’t get to them at all. </span><span class="koboSpan" id="kobo.2.5">In a hexbin map, each hexagon is reachable, if it’s not too small. </span><span class="koboSpan" id="kobo.2.6">I would even argue that our choice of hexagon size might be a little small with </span><strong><span class="koboSpan" id="kobo.3.1">3.5</span></strong><span class="koboSpan" id="kobo.4.1"> pixels. </span><span class="koboSpan" id="kobo.4.2">Let’s add a drop-down control, allowing the user to change the size of area. </span><span class="koboSpan" id="kobo.4.3">Here are some hexagon size variants:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img src="assets/e27fd0fc-880f-403a-8b4c-61c813abb740.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1">Different hex radii</span></div>
<p><span class="koboSpan" id="kobo.7.1">Two notes of caution here: when building a regularly tessellated hexbin map as we do, you might run into the </span><strong><span class="koboSpan" id="kobo.8.1">border problem</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">Imagine a large hexagon just touching the tip of Florida. </span><span class="koboSpan" id="kobo.9.3">5% of the hexagon is over land, 95% is over sea. </span><span class="koboSpan" id="kobo.9.4">However, the map readers can’t see the real coastal line. </span><span class="koboSpan" id="kobo.9.5">They assume the hexagon represents the coastal line, covering 100% land area. </span><span class="koboSpan" id="kobo.9.6">If that corner of Florida has a high point density, this hexagon should encode it. </span><span class="koboSpan" id="kobo.9.7">However, as it only covers 5% of the land, and maybe around 5% of the dot density, it appears to the reader as though the coast of Florida is void of dots.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Another problem that becomes apparent when you look at the different sized hexagons above is the so-called </span><strong><span class="koboSpan" id="kobo.11.1">modifiable areal unit problem</span></strong><span class="koboSpan" id="kobo.12.1"> (MAUD). </span><span class="koboSpan" id="kobo.12.2">The summary values we encode are highly dependent on the shape and the scale of our aggregation units. </span><span class="koboSpan" id="kobo.12.3">This is a problem, as the results might differ when the same analysis is applied to the same data. </span><span class="koboSpan" id="kobo.12.4">You can see the </span><em><span class="koboSpan" id="kobo.13.1">scale effect</span></em><span class="koboSpan" id="kobo.14.1"> above; changing hexagon size results in a different perception of farmers markets’ density. </span><span class="koboSpan" id="kobo.14.2">The </span><em><span class="koboSpan" id="kobo.15.1">shape</span></em><span class="koboSpan" id="kobo.16.1"> or </span><em><span class="koboSpan" id="kobo.17.1">zone effect</span></em><span class="koboSpan" id="kobo.18.1"> can be more problematic. </span><span class="koboSpan" id="kobo.18.2">Using a different shape at the same scale, for example, 10-mile squares instead of 10-mile hexagons can change the aggregate and hence analysis. </span><span class="koboSpan" id="kobo.18.3">It then becomes an analysis of different bins rather than of the underlying data. </span><span class="koboSpan" id="kobo.18.4">This effect is particularly problematic when representing non-arbitrary units such as counties or census tracts, which might change in shape over time but remain consistent in the readers’ minds.</span></p>
<p><span class="koboSpan" id="kobo.19.1">You could solve the border problem by overlaying the country outline, but the key step to alleviate any of these problems is your awareness, explaining potential issues to readers.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Changing the color scale interpolator</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In exploratory displays, it can be beneficial for users to change the scale in order to discover data areas of interest. </span><span class="koboSpan" id="kobo.2.2">By allowing our users to adjust the interpolator, they can focus on value ranges of their interest. </span><span class="koboSpan" id="kobo.2.3">The parameter we want to expose is the exponent our exponential interpolator uses:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img src="assets/bbacf15b-4f7b-4172-b953-df84a6d96839.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Changing the color scale interpolator</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Browsing different datasets</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The farmers' market data we are using here also offers over 29 binary variables, indicating what products or facilities markets offer. </span><span class="koboSpan" id="kobo.2.2">Multiple datasets showing the geographical distribution of markets with different produce would be a good option. </span><span class="koboSpan" id="kobo.2.3">Alternatively, we can add a drop-down menu for the users to choose what products they are most interested in. </span><span class="koboSpan" id="kobo.2.4">Here are some examples:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="414" width="635" src="assets/128c37e6-c557-41f9-aeaf-6100359ecf15.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">Hexbin maps of different datasets (we chose 20 of the 29 binary variables available for the app)</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Encoding data as hexagon size</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far, we have encoded data only as color. </span><kbd><span class="koboSpan" id="kobo.3.1">d3.hexbin()</span></kbd><span class="koboSpan" id="kobo.4.1"> makes it very easy to encode data by hexagon size. </span><span class="koboSpan" id="kobo.4.2">Theoretically, you just have to go to your </span><kbd><span class="koboSpan" id="kobo.5.1">drawHexmap()</span></kbd><span class="koboSpan" id="kobo.6.1"> function and change a single line:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">  .attr('d', function(d) { return hexbin.hexagon(d.datapoints); })</span></pre>
<p><span class="koboSpan" id="kobo.8.1">You just add a hexagon-specific radius to your </span><kbd><span class="koboSpan" id="kobo.9.1">hexbin</span></kbd><span class="koboSpan" id="kobo.10.1"> path generator (as an optional argument to the </span><kbd><span class="koboSpan" id="kobo.11.1">.hexagon()</span></kbd><span class="koboSpan" id="kobo.12.1"> method), which in our case above makes sure that each hexagon gets a radius as little or large as this hexagon’s count of farmers' markets. </span><span class="koboSpan" id="kobo.12.2">However, that would look excessive as most would get a radius of </span><em><span class="koboSpan" id="kobo.13.1">0</span></em><span class="koboSpan" id="kobo.14.1"> and some would get a radius of over </span><em><span class="koboSpan" id="kobo.15.1">100</span></em><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">I’ll spare you the visual.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Instead, we will add the variable </span><kbd><span class="koboSpan" id="kobo.18.1">radiusScale</span></kbd><span class="koboSpan" id="kobo.19.1"> to the mix (in </span><kbd><span class="koboSpan" id="kobo.20.1">rollUpHexPoints()</span></kbd><span class="koboSpan" id="kobo.21.1">), which will scale sizes from between </span><kbd><span class="koboSpan" id="kobo.22.1">3.5</span></kbd><span class="koboSpan" id="kobo.23.1"> to </span><kbd><span class="koboSpan" id="kobo.24.1">15</span></kbd><span class="koboSpan" id="kobo.25.1"> pixels:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">radiusScale = d3.scaleSqrt().domain([0, maxCount]).range([3.5, 15]);</span></pre>
<p><span class="koboSpan" id="kobo.27.1">You can now use it when you draw the hexagons, which you should also sort ascendingly so that the larger ones aren’t covered by the many small hexagons around them:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">function drawHexmap(points) {</span><br/><span class="koboSpan" id="kobo.29.1">  var hexes = svg.append('g').attr('id', 'hexes')</span><br/><span class="koboSpan" id="kobo.30.1">    .selectAll('.hex')</span><br/><strong><span class="koboSpan" id="kobo.31.1">    .data(points.sort(function(a,b) { </span><br/><span class="koboSpan" id="kobo.32.1">        return a.datapoints - b.datapoints;        </span><br/><span class="koboSpan" id="kobo.33.1">    }))</span><br/></strong><span class="koboSpan" id="kobo.34.1">    .enter().append('path')</span><br/><span class="koboSpan" id="kobo.35.1">      .attr('class', 'hex')</span><br/><span class="koboSpan" id="kobo.36.1">      .attr('transform', function(d) { </span><br/><span class="koboSpan" id="kobo.37.1">        return 'translate(' + d.x + ', ' + d.y + ')'; </span><br/><span class="koboSpan" id="kobo.38.1">      })</span><br/><strong><span class="koboSpan" id="kobo.39.1">      .attr('d', function(d) { </span><br/><span class="koboSpan" id="kobo.40.1">        return hexbin.hexagon(radiusScale(d.datapoints)); </span><br/><span class="koboSpan" id="kobo.41.1">      })</span><br/></strong><span class="koboSpan" id="kobo.42.1">      .style('fill', function(d) { return </span><br/><span class="koboSpan" id="kobo.43.1">        d.datapoints === 0 ? </span><span class="koboSpan" id="kobo.43.2">'none' : colorScale(d.datapoints); </span><br/><span class="koboSpan" id="kobo.44.1">      })</span><br/><span class="koboSpan" id="kobo.45.1">      .style('stroke', '#ccc')</span><br/><span class="koboSpan" id="kobo.46.1">      .style('stroke-width', 1);</span><br/><span class="koboSpan" id="kobo.47.1">}</span></pre>
<p><span class="koboSpan" id="kobo.48.1">You get hexagons not only colored, but also sized by the number of markets within the hexagon:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.49.1"><img height="476" width="709" src="assets/0e892f98-f863-496a-b7aa-4a1a57c309f1.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.50.1">Number of markets encoded as color AND radius size</span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.51.1">View this step in the browser at</span></span> <a href="https://larsvers.github.io/learning-d3-mapping-11-7"><span class="koboSpan" id="kobo.52.1">https://larsvers.github.io/learning-d3-mapping-11-7</span></a> <span><span class="koboSpan" id="kobo.53.1">and the c</span></span><span><span class="koboSpan" id="kobo.54.1">ode example at </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_07.html"><span class="koboSpan" id="kobo.55.1">11_07.html</span></a><span class="koboSpan" id="kobo.56.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.57.1">We double encode the number of markets as color and size here. </span><span class="koboSpan" id="kobo.57.2">That’s sometimes useful, but you have two encoding channels at your disposal here, which you can use for two variables to produce a </span><strong><span class="koboSpan" id="kobo.58.1">bi-variate hexbin map</span></strong><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">It's your choice.</span></p>
<p><span><span class="koboSpan" id="kobo.60.1">We’ve covered a few options to improve and add to our hexbin map. </span><span class="koboSpan" id="kobo.60.2">There are certainly more options to have fun with. </span><span class="koboSpan" id="kobo.60.3">For example, we haven’t touched on zooming and panning, which is, of course, a standard map interaction technique and would be a good addition for people to dive into smaller hexagons. </span><span class="koboSpan" id="kobo.60.4">I’m sure that you can think of more ways to build on it.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We started by comparing a few map visualization techniques. </span><span class="koboSpan" id="kobo.2.2">We covered the uses, benefits, and caveats of choropleth maps, cartograms, and dot density maps. </span><span class="koboSpan" id="kobo.2.3">We moved swiftly to the hexagon shape and explored how its geometrical properties can help choropleth and dot density maps.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Most of the chapter was, however, spent in the mapping workshop, building a hexbin map from scratch. </span><span class="koboSpan" id="kobo.3.2">We could have built a simple hexbin map, just covering areas with datapoints, but our goal was to shape a map entirely of hexagons for the kicks and the aesthetics. </span><span class="koboSpan" id="kobo.3.3">That meant a little more data preparation—creating a map-shaped layout grid, joining the datapoints, and eventually adding and color-encoding the hexagons</span><span><span class="koboSpan" id="kobo.4.1">—</span></span><span class="koboSpan" id="kobo.5.1">but doesn’t it look pretty?</span></p>
<p><span class="koboSpan" id="kobo.6.1">Finally, we turned our static map into an interactive application, handing significant control over shape and information gain to the user. </span><span class="koboSpan" id="kobo.6.2">A lot can be achieved with interaction, especially with maps!</span></p>
<p><span class="koboSpan" id="kobo.7.1">After having created a fully functional interactive visualization, you might want to show it to the world. </span><span class="koboSpan" id="kobo.7.2">There are many ways to claim some online real estate; in the next chapter, we'll look at a conveniently simple one: </span><em><span class="koboSpan" id="kobo.8.1">GitHub pages</span></em><span class="koboSpan" id="kobo.9.1">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>