<html><head></head><body>
        

                            
                    <h1 class="header-title">Shaping Maps with Data - Hexbin Maps</h1>
                
            
            
                
<p>Different pieces of data afford different visualizations. When you want to show a timeline, you rarely build a vertical bar chart. You would more likely use a horizontal line chart. You should, of course, give yourself some freedom of expression when encoding data to position, shape, or color. However, the data at hand, the meaning you want to convey, and the cognitive decoding processes at play are important guides when deciding how to encode your data.</p>
<p>In this chapter, we will focus on a specific map-visualization technique: <strong>hexagonal binning</strong> <strong>maps</strong> (<strong>hexbin maps</strong>). We will start with a brief journey through various map visualization techniques before focusing on hexbin maps. You will learn the conceptual and cognitive benefits of hexbin maps, what hexagons are useful for in comparison to other shapes, and how they are calculated.</p>
<p>Most of the chapter will, however, be hands on, building a hexbin map from scratch. Most of the attention will go into data preparation and shaping. D3 will make the actual visualization a breeze with the <strong>D3-hexbin</strong> module. We will focus on a pipeline of data preparation and visualization tasks that aim to be easy to follow. Let’s go!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reviewing map visualization techniques</h1>
                
            
            
                
<p>There are many ways to represent geographical data. Not surprisingly, maps are often involved. While maps are a compelling way to present data that can be deciphered effortlessly by most people, they can be overused. If you want to show which country has the highest percentage of forest cover, you might decide to show a globe and use color saturation to encode forest ratio. Alternatively, you could show a sorted vertical bar chart displaying the country with the highest forest cover on top and the country with the lowest at the bottom. The map version might look nicer and give your users a good intuition about locations of forest lack or riches. However, the bar chart gives a more concise overview over the distribution and country comparison of forest cover.</p>
<p>So, let’s assume that you have decided to use a map as the fundamental representation of your visual. What options are there?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choropleth maps</h1>
                
            
            
                
<p>Widely known and potentially overused choropleth maps are a good choice if you need to compare standardized ratios across geographical units such as states, counties, or countries. You built a choropleth map in <a href="c22382c6-84d9-411f-b795-681df2321005.xhtml">chapter 4</a>, <em>Creating a Map</em> and in <a href="328cc9b5-a87f-4492-b7ce-fa4c07cff7a1.xhtml">chapter 10</a>, <em>Adding Interactivity to Your Canvas Map</em> comparing forest cover ratio per country</p>
<p>The only visual channel you can encode your measure of choice with is color. The areas of the units are already given by the size of these units. This can draw the user’s attention away from the smaller, and toward, the larger units. Looking at our forest example, larger countries such as the US, Russia, or Brazil might get more initial attention than smaller countries, such as Luxembourg, Haiti, or Belize.</p>
<p>To alleviate this attention problem, you should be fair to each country in the measure you visualize. The key rule is to not visualize absolute numbers, but standardized ratios related to the country. We adhered to this rule in our forest example by visualizing the percentage of forested area of the total country area. This measure has the same range for each country, independent of the country’s area (0 to 100%). It’s a standardized, and hence, fair measure. The absolute number of trees would be an unfair measure. A large country with a few trees could still have more trees than a small country full of trees, rendering our comparison problematic to pointless.</p>
<p>Furthermore, the geographical unit should define the measure you visualize. Tax rates, for example, are made by countries and make perfect sense to compare across countries. Forest cover is not (entirely) informed by a country’s actions and policies, and makes less sense to show in a choropleth. The countries’ actions still influence their forest cover, so I wouldn’t disregard it (the Dominican Republic, for example, has a much more conservative approach to its forests than neighboring Haiti), but this should be a conscious part of your choice of visualization technique.</p>
<p>As choropleths are so omnipresent, let’s take a look at another example with different data: farmers' markets in the US. They will accompany us for the rest of the chapter, so this is a good time to dive into it.</p>
<div><p>The <em>farmers' markets</em> data we will use is published by the USDA at <a href="https://www.ams.usda.gov/local-food-directories/farmersmarkets">https://www.ams.usda.gov/local-food-directories/farmersmarkets</a>. After a bit of a clean up, we have a dataset of 8,475 markets on mainland US. Each market has a number of interesting variables, starting with longitude and latitude values we can use for the mapping, as well as name, state, and city they are located in. It also has 29 binary variables (as in yes/no) indicating the products that each market is selling. We will use this later to visualize subsets of markets.</p>
</div>
<p class="NormalPACKT">Here’s a choropleth of the US states (only mainland to keep it simple). It shows the number of farmers' markets per 100,000 people. Light blue means few markets; dark blue means many markets per 100k people:</p>
<div><img height="442" width="562" src="img/e17f4ec6-542b-4fec-a8a2-f2376a5a50a5.png"/></div>
<p>A choropleth map of farmers' markets</p>
<p class="NormalPACKT">One question here has to be whether a state-wise comparison of farmers' markets makes much sense. Do the state-policies or cultures play a role in promoting or objecting to farmers' markets? Maybe. However, once we decided to go for a state-wise comparison of it, are we able to compare well? Texas with its size gets a lot of weight in the visual, suggesting southern farmers' market deprivation. We can see Vermont has the highest ratio (it helps that we’re pointing a red line at it), but what about Washington, D.C.? There are 8.5 markets per 100k people? We can’t even see it on the map.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cartograms</h1>
                
            
            
                
<p>Cartograms do away with the area problem, by encoding your values to area size. A cartogram of our farmers' markets mapping the ratio to color and area size would look as follows:</p>
<div><img height="442" width="562" src="img/153f9633-e05f-4bee-9d06-35fd343e9cc9.png"/></div>
<p>A contiguous cartogram of farmers' markets</p>
<p>The area— and consequently the shape—of your map gets distorted in such a way that the area represents the value you want to visualize. It's great for Washington, D.C. which has been sized up significantly to be recognized as a farmers' markets heavyweight. In short, they solve the choropleth problem of attention theft, but create a new problem in that our geographical units are often hardly recognizable. Your users will be fine with this reality bend for counties, states, and countries they know well, but they will struggle to make sense of areas they don’t know the shape of. It’ll look too cryptic and reduce readability to a potential full loss of interest.</p>
<p>The contiguous cartogram has been produced with <a href="https://github.com/shawnbot/topogram">https://github.com/shawnbot/topogram</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dot density maps</h1>
                
            
            
                
<p>Dot density maps are great if you want to show <strong>counts of things</strong> rather than ratios. Each thing is a dot displayed on the map. Here’s a dot density map of all farmers' markets in the US:</p>
<div><img height="319" width="479" src="img/51ee6872-ae5c-4e3d-a9a5-b303571679a9.png"/></div>
<p>A dot density map of farmers' markets</p>
<p>The benefit of this visualization technique is obvious: it shows all the data. You can easily see where they all are and detect clusters of farmers' markets across the country. The problem is that in fact it doesn’t show all the data. Some of the dots are overlapping in small, busy areas. A second potential problem is that many absolute measures in spatial analysis correlate highly with population distribution. So while you want to say <em>Look where all the farmers' markets are</em> you are actually saying <em>Look where all the people are</em>. This doesn't mean you shouldn't show it, but you should be aware of it. By the way, our hexbin map will have the same problem, so be aware. Another caveat of showing all the data is that it might appear confusing for users to look at that amount of data and elements. We might want to focus the eye in a more orderly way to the clusters. This is where hexbin maps come in handy.</p>
<div><p>Note that this list of map visualization techniques is not complete. There are, of course, other map visualization techniques, such as heat maps, cluster maps, graduated circle, proportional symbol, or bubble maps, and non-contiguous cartograms. A good place to see what people visualize with and on maps is <a href="https://flowingdata.com/category/visualization/mapping/">https://flowingdata.com/category/visualization/mapping/</a>.<a href="https://flowingdata.com/category/visualization/mapping/"/></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Value and use of the hexagon</h1>
                
            
            
                
<p class="NormalPACKT">Hexagons can solve some of the problems we mentioned in the preceding section. They can help the unequal area problems of choropleth maps and can bring ordered focus to point clusters. Let’s look at a few first:</p>
<div><img height="193" width="286" src="img/6006bc7d-d194-456a-bb3f-b7ab796a6924.png"/></div>
<p>Hexagonal tiling</p>
<p>As you can see, hexagons have equal length sides and fit nicely next to each other. However, they’re not just a pretty face, they also have properties we can leverage well in data visualization:</p>
<ul>
<li>Hexagons divide a given area into equal-sized hexagons. This is called <strong>tiling</strong> and can also be done with other shapes such as circles, triangles, rectangles, or other polygons.</li>
<li>However, if you tile your wall with circles, you will end up with gaps between the circles. Covering a plane gap-free with repeating symmetric shapes is called a <strong>regular</strong> <strong>tessellation</strong> and is, in fact, only possible with squares, triangles, and hexagons.</li>
<li>Of these three shapes, hexagons are the highest-sided shape closest to a circle. Hence, they are best to represent—to <strong>bin</strong>—a cluster of points. Corner points of triangles or squares are further away from their center than corner points in hexagons, which make hexagons predestined for grouping dot data. Circles are optimal for binning, but then again, they can’t be tessellated.</li>
</ul>
<p>Let’s consider binning for an extra moment. <strong>Binning</strong> means grouping data together into equally sized categories. When we have a dataset of 100 people with varying ages, we can look at the frequency of each age, or we bin the data to more digestible age groups, such as 20-39, 40-69, and 70-99. We take individual data points and aggregate them in larger and—usually—equally sized groups.</p>
<p>In a mapping context, we can bin point location data to equally sized areas. Hexagons are well suited for this task as they group points well and also tessellate regularly across the plane. This is what a hexbin map as implemented with D3 can do for you. Instead of potentially piling points on top of each other as we do in dot density maps, we can define hexagonal areas of equal size, aggregating the points to a summary measure encoded with color. As such, <strong>binning</strong> represents the data for each hexagon area potentially better than individual points would do. The <strong>hexagonal</strong> <strong>tessellation</strong> supports the binning in that it creates the best possible, gap-free, and comparably fair bin shapes.</p>
<p>In the coming sections, we will very much focus on these <strong>hexbin maps</strong>, where each hexagon represents an equal area. Before we dive into hexbins, let’s quickly look at another use of hexagons you might have come across: <strong>hexagonal choropleth maps</strong>. The problem the classic choropleth map, as shown above poses, is that smaller states such as Vermont or Washington D.C can easily be overlooked, as they have such low visual weight. Other area-states such as Texas or Montana attract the eye through sheer size. To alleviate this, we can replace the state polygons with hexagons:</p>
<div><img height="400" width="509" src="img/cb4c1771-d420-4f9f-8e18-7aac5ac4dca5.png"/></div>
<p>Size emancipated US states in a hexagonal choropleth map</p>
<p>Let's be clear, hexagons in a <em>hexbin map</em> as described in the preceding diagram and in the following sections represent equal areas. Hexagons in a <em>hexagonal choropleth map</em> as shown in this figure represent vastly different areas. However, in this case, we don’t want to focus on the spatial area of our chosen unit (US mainland states); we want to focus on the measure that is merely categorized by our chosen unit.</p>
<p>Be aware that this comes with the cost of removing the area information entirely, as the US states differ greatly in area and no state looks like a hexagon. However, unlike the preceding classic choropleth example, this hexagonal choropleth allows us, for example, to easily identify Washington D.C. as a farmers' market hub and that might be the message we want to bring across above all.</p>
<p>Enough theory. Let’s make a hexbin map.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making a hexbin map</h1>
                
            
            
                
<p>Having improved our US state choropleth map with hexagons, let’s now use hexagons to alter our dot density map. There are benefits to a dot density map as we have seen previously, so the changes we are about to make are more alterations than clear improvements. Here’s what we will build:</p>
<div><img height="338" width="510" src="img/1afbac36-728f-4032-8a1e-bb517d45dd17.png"/></div>
<p>A map of many hexagons in color</p>
<p>It’s a hexbin map showing the farmers' markets hotspots. Areas with no farmers' markets are shown as white hexagons, areas with many farmers' markets are shown in blue to dark purple. Lighter and less saturated yellow and green hexagons represent areas with fewer markets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reviewing the hexbin algorithm</h1>
                
            
            
                
<p>What do we want to achieve? There are two major steps we want to cover. First, we want to show the US as a hexagon tiling. Next, we want to highlight hexagons with farmers' markets, color encoding the number of markets within each hexagon.</p>
<p>Alternatively, we could be content with showing a map of the US and only display the hexagons where farmers' markets reside. This would be less involved; however, it seems worthwhile to go the extra mile for esthetics and clarity.</p>
<p>The actual drawing of the hexbin is simple, thanks to the <kbd>d3.hexbin()</kbd> module doing the hardwork of drawing the hexagons. More attention will be required when producing the hexagonal grid of the US. However, don’t worry; the process is straightforward and right here:</p>
<ol>
<li>Draw a map.</li>
<li>Overlay the entire map with a symmetric grid of points.</li>
<li>Only keep the grid points that are within the bounds of the map.</li>
<li>Merge the grid points data with the location data we want to visualize.</li>
<li>Calculate the hexbin positions with the D3<em>-</em>hexbin module.</li>
<li>For each hexagon, aggregate the summary statistic you want to visualize.</li>
<li>Visualize the summary statistic (for example, by color encoding the hexagons):</li>
</ol>
<div><img src="img/544ca0f5-3a1e-436b-b15c-a34183826271.png"/></div>
<p>The hexbin map evolution</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting it up</h1>
                
            
            
                
<p>The setup is simple. You have a single <kbd>&lt;div&gt;</kbd> with the <kbd>id="vis"</kbd> in the HTML for the visualization. In the JavaScript, you set up a global <kbd>projection</kbd> variable to fill soon and create an <kbd>svg</kbd> element:</p>
<pre>var projection;<br/><br/>var margin = { top: 30, right: 30, bottom: 30, left: 30 },<br/>    width = 900 - margin.left - margin.right,<br/>    height = 600 - margin.top - margin.bottom;<br/><br/>var svg = d3.select('#vis')<br/>  .append('svg')<br/>    .attr('width', width + margin.left + margin.top)<br/>    .attr('height', height + margin.top + margin.bottom)<br/>  .append('g')<br/>    .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')');</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the map</h1>
                
            
            
                
<p>As usual, the first thing we do is to get your data into the app. So far, you only have the US data; however, in anticipation of the farmers' markets point data, we will haul in a little later—let's use <kbd>d3.queue()</kbd> to load our data:</p>
<pre>d3.queue()<br/>  .defer(d3.json, 'data/us.json')<br/>  .await(ready);</pre>
<p>The <kbd>ready()</kbd> function gets called asynchronously as soon as the data is loaded:</p>
<pre>function ready(error, us) {<br/>  if (error) throw error;<br/><br/>  var us = prepData(us);<br/>  drawGeo(us);<br/><br/>}</pre>
<p>In there, you check for errors, prepare the US data, and draw it. The data preparation is a one-liner, converting the <kbd>topo</kbd> to an array of GeoJSON polygons:</p>
<pre>function prepData(topo) {<br/>  var geo = topojson.feature(topo, topo.objects.us);<br/>  return geo;<br/>}</pre>
<p>The drawing function takes the GeoJSON as its only argument. Create the projection and the path generator and draw the US. <kbd>projection</kbd> is a global variable as we will use it in other places later:</p>
<pre>function drawGeo(data) {<br/>  projection = d3.geoAlbers() // note: global<br/>    .scale(1000).translate([width/2, height/2]);<br/><br/>  var geoPath = d3.geoPath()<br/>    .projection(projection);<br/><br/>  svg<br/>    .append('path').datum(data)<br/>      .attr('d', geoPath)<br/>      .attr('fill', '#ccc')<br/>}</pre>
<p>Note that we are using the <kbd>d3.geoAlbers()</kbd> projection here. The <em>Albers</em> projection is a so-called <strong>equal area-conic projection</strong>, which distorts scale and shape but preserves area. This is essential when producing dot density or hexbin maps to not distort the perceived density of the dots across distorted areas. To put it differently, our hexbins represent equal areas on the projected plane, hence we need to make sure that the projected plane honors equal areas with an appropriate projection. Note that equal area-conic projections require the map maker to pick two parallels (circles of latitude) on which the projection is based. <kbd>d3.geoAlbers</kbd> has been already preconfigured, picking the two parallels <em>[29.5,</em> <em>45.5]</em>. This produces an optimized projection for the US. When visualizing other countries or map areas, you can overwrite this with the <kbd>.parallels()</kbd> method or set it up yourself with the <kbd>d3.geoConicEqualArea()</kbd> projection.</p>
<p>The result is not too surprising:</p>
<div><img height="349" width="519" src="img/6eff3b4a-b820-4834-a7ff-235be296018e.png"/></div>
<p>The US mainland</p>
<p>You can view this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-1">https://larsvers.github.io/learning-d3-mapping-11-1</a>. Code example ;<a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_01.html">11_01.html</a>.</p>
<p>At the conclusion of each step, you will find two links in an info box close to the relevant image. The first link brings you to a working implementation of this step that you can view in the browser. The second <em>code example</em> link brings you to the full code. If you're reading the print version, you can find all code examples at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a> in their relevant chapter.</p>
<p>Before we move on, let's take one step back and look at how we produced the <em>TopoJSON</em> data on the command line. The original US map data comes in a shapefile from <a href="https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html">https://www.census.gov/geo/maps-data/data/cbf/cbf_nation.html</a> and is converted from shapefile to TopoJSON in six steps as follows:</p>
<ol>
<li class="mce-root">Install <kbd>shapefile</kbd>, if you haven’t yet:</li>
</ol>
<pre style="padding-left: 60px"><strong>npm install -g shapefile</strong> </pre>
<ol start="2">
<li>Install <kbd>topojson</kbd>, if you haven’t yet:</li>
</ol>
<pre style="padding-left: 60px"><strong>npm install -g topojson</strong></pre>
<ol start="3">
<li>Convert the shapefile to GeoJSON:</li>
</ol>
<pre style="padding-left: 60px"><strong>shp2json cb_2016_us_nation_20m.shp --out us-geo.json</strong> </pre>
<ol start="4">
<li>Convert the Geo to TopoJSON:</li>
</ol>
<pre style="padding-left: 60px"><strong>geo2topo us-geo.json &gt; us-topo.json </strong></pre>
<ol start="5">
<li>Compress number precision:</li>
</ol>
<pre style="padding-left: 60px"><strong>topoquantize 1e5 &lt; us-topo.json &gt; us-quant.json </strong></pre>
<ol start="6">
<li>Simplify the geometry:</li>
</ol>
<pre style="padding-left: 60px"><strong>toposimplify -s 1e-5 -f &lt; us-quant.json &gt; us.json </strong></pre>
<p>You can read more on command-line cartography at <a href="http://bit.do/cl-carto">http://bit.do/cl-carto</a>.<a href="http://bit.do/cl-carto"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a point grid for our hexagons</h1>
                
            
            
                
<p>Our aim is to draw a hexagon grid across the US map. D3-hexbin will do this for us later, but it can only draw a hexagon where there are points. So, we need to feed points to it. These points won’t have any information value for our users. They will only be used to produce the layout. As such, we can distinguish two types of points we will need:</p>
<ul>
<li><strong>Layout points</strong> to produce the hexbin tiling</li>
<li><strong>Datapoints</strong> to render the color-scaled information</li>
</ul>
<p>We’ll get to the datapoints soon, but at this stage, we’re only concerned with our layout points. Once done, you will have produced this wonderfully regular pattern of points stretching across our entire drawing area:</p>
<div><img height="505" width="749" src="img/3b810be4-f9ec-4357-a621-5257a95a216e.png"/></div>
<p>A grid of many points over the US</p>
<p>You can view this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-2">https://larsvers.github.io/learning-d3-mapping-11-2</a> and the code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_02.html">11_02.html</a>.</p>
<p>In the next step, we will cut this grid to shape to fit the US silhouette, but let’s lay it out first. Note that this will be the most involved bit of the calculations. No rocket science, but don’t worry if it doesn’t click immediately. Things often become clearer once stepping through the code in the debugger and/or using a few <kbd>console.log()</kbd>’s. Anyway, here we go:</p>
<pre>var points = getPointGrid(160);</pre>
<p><kbd>getPointGrid()</kbd> takes only one argument: the number of columns of points we want. That’s enough for us to calculate the grid. First, we will get the distance in pixels between each dot. The distance between each dot stands in for the distance between the hexagon centers. <kbd>d3.hexbin()</kbd> will calculate this for us precisely later, but, for now, we want to get a good approximation. So, if we decide to have 160 columns of dots and our width is 840, the maximum distance will be <em>840 / 160 = 5.25</em> pixels. We then calculate the number of rows. The height is 540, so we can fit in <em>540 / 5.25</em> rows, which equals 108 rows of dots if we round it down:</p>
<pre>function getPointGrid(cols) {<br/>  var hexDistance = width / cols;<br/>  var rows = Math.floor(height / hexDistance);<br/><br/>  hexRadius = hexDistance/1.5;</pre>
<p class="mce-root">Next, we will calculate the <kbd>hexRadius</kbd>. This might look funny. Why divide the distance by <em>1.5</em>? The D3-hexbin module will produce hexbins for us if we feed it <strong>points</strong> and a desired hexbin <strong>radius</strong>. The hexagon radius we set here should guarantee that the resulting hexagons are large enough to include at least one point of the grid we produce. We want a gap-free hexagon tiling after all. So, a tight grid should have a small radius, and a wide grid should have a wider radius. If we had a wide grid and a small radius, we wouldn’t get a hexagon for each point. There would be gaps.</p>
<p>Luckily, hexagons are regular shapes, and their dimensions and properties are nicely interconnected. The vertical distance between hexagon centers is 1.5 times its radius, the horizontal distance is √3 (roughly 1.73):</p>
<div><img height="440" width="870" src="img/f9b5bd24-0c14-4ba9-a787-650c1def453c.png"/></div>
<p>How hexagon distance and radius relate to each other</p>
<p>Our grid points work as a proxy of hexagon centers. As such they are not 'perfectly' laid out in the sense that their vertical distance is the exact same as their horizontal distance with <em>5.25</em> pixels. In a perfect hexagon grid the vertical distance would be a little shorter than the horizontal distance as you can see in above figure. In order to get a relatively tight mesh of hexagons on the base of our proxy grid, we should chose a safe—meaning <strong>wide—</strong>radius to pass to the D3-hexbin module which indeed will deliver a perfect hexagon grid. We can calculate this radius with the formulae in the preceding figure as well as our distance (5.25 pixel) by solving for <em>Radius</em>. When re-shuffling the equation for the vertical distance <em>Distance = 1.5 * Radius</em> becomes <em>Radius = Distance / 1.5</em>. In our case the distance is <em>5.25 / 1.5 =</em> a radius of <em>3.5</em>. Using the horizontal distance would have given us a less safe—meaning tighter—radius with <em>5.25 / √3 = 3.03</em>, which in fact would produce a few gaps in our final tiling.</p>
<p>Next, we will create and return the grid immediately—well, the coordinates for the grid that is:</p>
<pre>return d3.range(rows * cols).map(function(el, i) {<br/>    return {<br/>      x: Math.floor(i % cols * hexDistance),<br/>      y: Math.floor(i / cols) * hexDistance,<br/>      datapoint: 0<br/>    }<br/>  });<br/>} // end of getPointGrid() function</pre>
<p><kbd>d3.range(rows * columns)</kbd> creates an array with one element per dot. We then iterate through each dot with <kbd>.map()</kbd> returning an object with three properties: <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>datapoint</kbd>. These properties will define each of our grid points. The <em>x</em> coordinate will increase by the <kbd>hexDistance</kbd> every point and reset to <em>0</em> for each row (or put differently, after it runs through all columns). The <em>y</em> coordinate will increase by the <kbd>hexDistance</kbd> for each new row.</p>
<p>Equally important, each of these grid points will get a property called <kbd>datapoints</kbd>, which we will set to <em>0</em>. This property will distinguish all the layout points (<em>0</em>) from the data points (<em>1</em>) later, allowing us to focus on the latter.</p>
<p>Congratulations! This was the most difficult bit, and you’re still here proudly lifting a square grid of tomato-colored dots into the air.</p>
<div><p>Note that not crucial but extremely helpful is visualizing the grids and points we make on the way. Here’s a little function that draws points if they are stored in an array of objects with <kbd>x</kbd> and <kbd>y</kbd> properties:</p>
<pre>function drawPointGrid(data) {<br/>  svg.append('g').attr('id', 'circles')<br/>    .selectAll('.dot').data(data)<br/>    .enter().append('circle')<br/>      .attr('cx', function(d) { return d.x; })<br/>      .attr('cy', function(d) { return d.y; })<br/>      .attr('r', 1)<br/>      .attr('fill', 'tomato');<br/>}</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Keeping only the points within the map</h1>
                
            
            
                
<p>The square grid of points is still reasonably far away from the shape of the US. Let’s change that. Thanks to D3’s own <kbd>d3.polygonContains()</kbd> method, this is rather simple. The method takes screen coordinates of a polygon and a point, and for each point returns <kbd>true</kbd> if the point is in the polygon and <kbd>false</kbd> if it isn’t. It couldn’t be more helpful.</p>
<p>To get the polygon of our US map, we write a small function called <kbd>getPolygonPoints()</kbd> and use it as a next step in our <kbd>ready()</kbd> function, which so far looks like this:</p>
<pre>function ready(error, us) {<br/>  var us = prepData(us);<br/>  drawGeo(us);<br/>  var points = getPointGrid(160);<br/><strong>  var polygonPoints = getPolygonPoints(us);<br/></strong>}</pre>
<p>The only argument we pass in is the array of GeoJSON objects for our map called <kbd>us</kbd>. For simplicity reasons, we decided to only look at the mainland US. So, the first thing we need to do is focus our data on the US mainland:</p>
<pre>function getPolygonPoints(data) {<br/>  var features = data.features[0].geometry.coordinates[7][0];<br/><br/>  var polygonPoints = []<br/>  features.forEach(function(el) {<br/>    polygonPoints.push(projection(el));<br/>  });<br/><br/>  return polygonPoints;<br/>}</pre>
<p><kbd>data.features[0].geometry.coordinates</kbd> holds 11 arrays of polygon point pairs, describing mainland US as well as Alaska, Hawaii, and further offshore areas. We want to focus on mainland US, whose outline is represented by the first element in the <strong>seventh</strong> array. Note that this might be different if your data comes from a different source or is being assembled differently.</p>
<p>Then, we will loop through all <kbd>polygonPoints</kbd>, which are in longitude and latitude, and convert them into <em>x</em> and <em>y</em> coordinates for further use.</p>
<p>Now, we have both the polygon boundaries of the US and our grid points in pixel coordinates. All we need to do now is to identify the grid points that lie within mainland US:</p>
<pre>var usPoints = keepPointsInPolygon(points, polygonPoints);</pre>
<p>We pass the two arrays to a function we boldly name <kbd>keepPointsInPolygon()</kbd>:</p>
<pre>function keepPointsInPolygon(points, polygon) {<br/>  var pointsInPolygon = [];<br/>  points.forEach(function(el) {<br/>    var inPolygon = d3.polygonContains(polygon, [el.x, el.y]);<br/>    if (inPolygon) pointsInPolygon.push(el);<br/>  });<br/>  return pointsInPolygon;<br/>}</pre>
<p>In here, we create an empty array called <kbd>pointsInPolygon</kbd>, which will hold our US-exclusive points. We then loop through our grid points and check for each whether it’s within the US polygon or not. If it is, we wave it through into <kbd>pointsInPolygon.</kbd></p>
<p>If we were to draw these points, we would see a pointy US:</p>
<div><img height="291" width="438" src="img/8318924b-196e-4f81-941e-7ef0bf4f3085.png"/></div>
<p>The US in points</p>
<p>You can view this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-3">https://larsvers.github.io/learning-d3-mapping-11-3</a> the and code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_03.html">11_03.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making the hex tile</h1>
                
            
            
                
<p>Points are nice and do look pretty, but we’re here for hexagons. So, let’s finally draw them and introduce the D3-hexbin plugin.</p>
<p>It needs the following two things from us and returns two, surely more valuable, things:</p>
<ul>
<li>We need to provide a <strong>set of points</strong> in screen coordinates and the <strong>radius</strong> we would like to see.</li>
<li>It returns a grid of <strong>hexagon center points</strong> (one for each hexagon) and a <strong>hexagon path generator</strong>.</li>
</ul>
<p>We then take the new center points and the path generator and—as is custom with D3—draw it ourselves with the renderer of our choice. Let’s first get the hexagon center points and then draw them with SVG. In our <kbd>ready()</kbd> function, we will add the following two lines:</p>
<pre class="NormalPACKT">function ready(error, us) {<br/>  //previous steps<br/><br/>  var hexPoints = getHexPoints(usPoints);<br/>  drawHexmap(hexPoints);<br/><br/>}</pre>
<p><kbd>getHexPoints()</kbd> retrieves the center points and <kbd>drawHexmap()</kbd> draws them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Retrieving the hexagon center points</h1>
                
            
            
                
<p>As mentioned fleetingly previously, <kbd>d3.hexbin()</kbd> has two heads. Its first use is as a D3 <strong>layout function</strong> such as the force-layout, the tree-layout, or the circle-pack-layout functions D3 offers. Data in, augmented data out. We pass our data and the desired hexagon radius to it, and, for each set of data points it can wrap its shape around, it will return the center coordinate of that hexagon.</p>
<p>If we only gave it one data point, it would return one hexagon. If we gave it two data points close together so it fits into the hexagon’s width and height defined by the radius, it would also just return a single hexagon. If the second data point were far off the first one so that the hexagon couldn’t cover it with the given radius, <kbd>d3.hexbin()</kbd> would produce a second hexagon, embracing that second point.<br/>
Here we use its layouting powers:</p>
<pre>function getHexPoints(points) {<br/>  hexbin = d3.hexbin() // note: global<br/>    .radius(hexRadius)<br/>    .x(function(d) { return d.x; })<br/>    .y(function(d) { return d.y; });<br/><br/>  var hexPoints = hexbin(points);<br/>    return hexPoints;<br/>}</pre>
<p>First, we configure the layout. We add our radius of 3.5 (the Distance of 5.25 / 1.5) to it and guide its attention to where it can find the <kbd>x</kbd> and <kbd>y</kbd> coordinates. In the next row, we use it on our grid <kbd>points</kbd> and return the resulting array of objects that looks as follows:</p>
<div><img height="312" width="313" src="img/ae453779-74aa-4d3c-8ffd-9edfe2f68e37.png"/></div>
<p>Our hexPoints as returned by d3.hexbin()</p>
<div><p>Our grid points are represented by 5,996 hexagonal center points, which we will just call <strong>hex points</strong> from now on. Let’s briefly go through this. The hexbin layout returns an array. Each element represents a single hexagon. In each element, each object represents a point the hexagon covers. Additionally, <kbd>d3.hexbin()</kbd> adds two keys to the array: <kbd>x</kbd> and <kbd>y</kbd>. Their values represent the hexagon’s center. So, for each hexagon, we have all point data as well as the hexagon’s center coordinates.</p>
<p>As you can see in the preceding screenshot, the first two hexagons cover only one grid point, whereas the third covers two grid points. You can also see how the center points in the array keys are slightly different from the layout points in the objects. Let’s visualize it.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the hex tiles</h1>
                
            
            
                
<p>We have our hexagons and now just need to draw them. We do this with a new function we call <kbd>drawHexmap(hexPoints)</kbd> in our <kbd>ready()</kbd> function. It does what it says on the tin:</p>
<pre>function drawHexmap(points) {<br/>  var hexes = svg.append('g').attr('id', 'hexes')<br/>    .selectAll('.hex').data(points)<br/>    .enter().append('path')<br/>      .attr('class', 'hex')<br/>      .attr('transform', function(d) { <br/>        return 'translate(' + d.x + ', ' + d.y + ')'; })<br/>      .attr('d', hexbin.hexagon())<br/>      .style('fill', '#fff')<br/>      .style('stroke', '#ccc')<br/>      .style('stroke-width', 1);<br/>}</pre>
<p>We join the data (passed in as <kbd>points)</kbd> with our as yet virtual selection of <kbd>.hex</kbd> hexagons and use <kbd>d.x</kbd> and <kbd>d.y</kbd> to move to each hexagon’s center. At each center, we unwrap the second use of our hexbin instance: the <strong>hexagon path generator</strong>. <kbd>hexbin.hexagon()</kbd> will return the string the path’s <kbd>d</kbd> attribute requires to draw the shape. The dimensions of the hexagon will be based on the radius we have passed to it during configuration. The rest is basic styling.</p>
<div><p><kbd>hexbin.hexagon()</kbd> can also take a radius as an argument. Using an accessor function, we can even pass through a hexagon point-specific argument, meaning that we can change the size of each hexagon based on a data value. Yay! However, we haven’t got the time or the data for this now, so let’s get back to this later.</p>
</div>
<p>Okay, then. Here’s your hex tiling; you deserve it:</p>
<div><img height="504" width="750" src="img/a29c8a40-31ab-48f7-92b4-1779ed48d5ee.png"/></div>
<p>A hextile map</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-4">https://larsvers.github.io/learning-d3-mapping-11-4</a> the and code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_04.html">11_04.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Joining data points to the layout points</h1>
                
            
            
                
<div><p>So far, we only had eyes for the base layer setup, visualising our layout points as hexagons. Now, we’ll finally add some real data to it. First, we need to load it to our <kbd>d3.queue()</kbd>:</p>
<pre>d3.queue()<br/>  .defer(d3.json, 'data/us.json')<br/>  .defer(d3.json, 'data/markets_overall.json')<br/>  .await(ready);</pre>
<p>In the <kbd>ready()</kbd> function, we just add another line to our visualization pipeline, triggering a function that will prepare the data for us:</p>
<pre class="NormalPACKT">function ready(error, us) {<br/>  // … previous steps<br/>  var dataPoints = getDatapoints(markets)<br/>}</pre>
<p><kbd>getDatapoints()</kbd> simply takes in the loaded CSV data and returns a more concise object boasting <em>x</em> and <em>y</em> screen coordinates as well as the <kbd>datapoint</kbd> flag, indicating that this is not a layout point but an actual data point. The rest is market-specific data, such as <kbd>name</kbd>, <kbd>state</kbd>, <kbd>city</kbd>, and <kbd>url</kbd>, we can use to add as info to each hexagon:</p>
<pre>function getDatapoints(data) {<br/><br/>  return data.map(function(el) {<br/>    var coords = projection([+el.lng, +el.lat]);<br/>    return {<br/>      x: coords[0],<br/>      y: coords[1],<br/>      datapoint: 1,<br/>      name: el.MarketName,<br/>      state: el.State,<br/>      city: el.city,<br/>      url: el.Website<br/>    }<br/>  });<br/><br/>}</pre>
<p>Back in the <kbd>ready()</kbd> function, you just concatenate these data points to the layout points for the complete dataset you will use for your final hexbin map:</p>
<pre class="NormalPACKT">function ready(error, us) {<br/>  // … previous steps<br/><br/>  var dataPoints = getDatapoints(markets)<br/><strong>  var mergedPoints = usPoints.concat(dataPoints)</strong><br/>}</pre>
<p>Here’s the markets data visualized as a classic dot density map in blue as well as together with the grid layout data in red:</p>
</div>
<div><img src="img/61b608af-681b-4e39-b645-756290bc4f96.png"/></div>
<p>The left image shows the farmers' markets points; the right image shows the farmers' markets points in blue and layout points in red.</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-5">https://larsvers.github.io/learning-d3-mapping-11-5</a> the and code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_05.html">11_05.html</a>.</p>
<p>Great! We’re one final step away from our hexmap. We need to create a value we can visualize: the number of markets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dressing our data for the final act</h1>
                
            
            
                
<p>You have some real data about farmer's markets joined with the hexagons, but you can’t use it yet. All your data is still tucked away in the array of objects per hexagon. Let’s roll this data up.</p>
<p>The measure we want to visualize is the number of farmer's markets in each hexagonal area. Hence, all we need to do is to count the objects that have their <kbd>datapoint</kbd> value set to <em>1</em>. While we’re at it, let’s also remove the layout point objects, that is, the objects with <kbd>datapoint</kbd> value <em>0</em>; we won’t need them anymore.</p>
<p>We will add our task to the <kbd>ready()</kbd> function:</p>
<pre class="NormalPACKT">function ready(error, us) {<br/>  // … previous steps<br/><br/>  var hexPointsRolledup = rollupHexPoints(hexPoints);<br/>}</pre>
<p>Primarily, <kbd>rollupHexPoints()</kbd> will roll up the number of markets per hex point. It will turn the upper hexagon data into the lower hexagon data of the following figure:</p>
<div><img height="300" width="859" src="img/fc65ca7e-4756-4dbf-a7ad-30153417b962.png"/></div>
<p>The hexagon data before and after roll-up</p>
<p><kbd>rollupHexPoints()</kbd> will perform the following things in an order:</p>
<ol>
<li>Remove the layout grid points.</li>
<li>Count the number of datapoints and add the count as a new property called <kbd>datapoints</kbd>.</li>
<li>Collect key markets data in single array called <kbd>markets</kbd> for easy interaction access.</li>
<li>Finally, it will produce a color scale we so dearly need for the hexagon coloring.</li>
</ol>
<p>Here we go:</p>
<pre>function rollupHexPoints(data) {<br/>  var maxCount = 0;</pre>
<p>We start by initializing a <kbd>maxCount</kbd> variable that will later have the maximum number of farmers' markets in a single hexagon. We’ll need this for the color scale.</p>
<p>Next, we’ll loop through all the layout and data points:</p>
<pre>  data.forEach(function(el) {<br/><br/>    for (var i = el.length - 1; i &gt;= 0; --i) {<br/>      if (el[i].datapoint === 0) {<br/>        el.splice(i, 1);<br/>      }<br/>    }</pre>
<p>First, we will get rid of all the layout point objects with <kbd>splice()</kbd> if the <kbd>datapoint</kbd> property holds a <kbd>0</kbd>.</p>
<p>Next, we will create the rolled-up data. There will be two rolled-up data elements: an integer representing the total count of farmers' markets within the hexagon and an array of market data we can use for later interaction. First, we will set up the variables:</p>
<pre>    var count = 0,<br/>        markets = [];<br/>  <br/>    el.forEach(function(elt) {<br/>      count++;<br/>      var obj = {};<br/>      obj.name = elt.name;<br/>      obj.state = elt.state;<br/>      obj.city = elt.city;<br/>      obj.url = elt.url;<br/>      markets.push(obj);<br/>    });<br/><br/>    el.datapoints = count;<br/>    el.markets = markets;</pre>
<p>We loop through each object within the hexagon array of objects, and once we’ve collected the data, we add it as keys to the array. This data is now on the same level as the <em>x</em> and <em>y</em> coordinates for the hex points.</p>
<p>Note that we could have taken a shortcut to summarize the count of markets. Our <kbd>datapoints</kbd> property just counts the number of elements in the array. This is exactly the same as what the in-built <kbd>Array.length</kbd> property does. However, this is a more conscious and descriptive way of doing it without adding much more complexity.</p>
<p>The last thing we do in the loop is to update <kbd>maxCount</kbd> if the count value of this particular hexagon is higher than the <kbd>maxCount</kbd> value of all previous hexagons we looped through:</p>
<pre>    maxCount = Math.max(maxCount, count);<br/><br/>  }); // end of loop through hexagons<br/><br/>  colorScale = d3.scaleSequential(d3.interpolateViridis)<br/>    .domain([maxCount, 1]);<br/><br/>  return data;<br/><br/>} // end of rollupHexPoints()</pre>
<p>The last thing we do in our roll-up function is to create our <kbd>colorScale</kbd>. We’re using the <em>Viridis</em> color scale, which has great properties for visualizing count data. Note that <em>Viridis</em> maps low numbers to purple and high numbers to yellow. However, we want high numbers to be darker (more purple) and low numbers to be lighter (more yellow). We will achieve this by just flipping our domain mapping.</p>
<p>The way scales work internally is that each value we feed from our domain will be normalized to a value between <em>0</em> and <em>1</em>. The first number we set in the array we pass to <kbd>.domain()</kbd> will be normalized to <em>0—</em>that's <kbd>maxCount</kbd> or 169 in our case. The second number (1) will be normalized to <em>1</em>. The output range will also be mapped to the range from <em>0</em> to <em>1</em>, which for <em>Viridis</em> means <em>0 = purple</em> and <em>1 = yellow</em>. When we send a value to our scale, it will normalize the value and return the corresponding range value between <em>0</em> and <em>1</em>. Here is what happens when we feed it the number 24:</p>
<ol>
<li>The scale receives <em>24</em> as an input (as in <kbd>colorScale(24)</kbd>).</li>
<li>According to the <kbd>.domain()</kbd> input (<kbd>[max, min]</kbd> rather than <kbd>[min, max]</kbd>), the scale normalizes <em>24</em> to <em>0.84.</em></li>
<li>Next, the scale queries the <em>Viridis</em> interpolator about which color corresponds to the value of <em>0.84</em> on the <em>Viridis</em> color scale. The interpolator comes back with the color <kbd>#a2da37</kbd>, which is a light green. This makes sense, as 0.84 is closer to 1, which represents yellow. Light green is obviously closer to yellow than to dark purple, which is encoded as <em>0</em> by the interpolator.</li>
</ol>
<p>That was is it!</p>
<p>Nearly. The very last thing we have to do is to jump into our <kbd>drawHexmap()</kbd> function and change the hexagon coloring to our <kbd>colorScale:</kbd></p>
<pre>function drawHexmap(points) {<br/>  var hexes = svg.append('g').attr('id', 'hexes')<br/>   .selectAll('.hex').data(points)<br/>   .enter().append('path')<br/>     .attr('class', 'hex')<br/>     .attr('transform', function(d) { <br/>        return 'translate(' + d.x + ', ' + d.y +')'; <br/>     })<br/>     .attr('d', hexbin.hexagon())<br/><strong>     .style('fill', function(d) { <br/>        return d.datapoints === 0 ? 'none' : colorScale(d.datapoints); <br/>     })<br/></strong>     .style('stroke', '#ccc')<br/>     .style('stroke-width', 1);<br/>}</pre>
<p>If the hexagons don’t cover any markets, their data points property will be 0 and we won’t color it. Otherwise, we pick the appropriate Viridis color.</p>
<p>Here it is:</p>
<div><img height="504" width="750" src="img/8b646bfc-a4db-4f86-b792-babd53d1d1b6.png"/></div>
<p>A very yellow hexbin map</p>
<p>Looks pretty yellow, doesn’t it? The problem is that we have a few outliers in our data. That single dark purple dot on the East Coast is New York, which has significantly more farmers' markets than any other area (169). Washington and Boston are busy as well. However, that makes our visual less interesting. Looking at the distribution of numbers tells us that most hexagons enclose 20 or less markets:</p>
<div><img height="370" width="604" src="img/ba805ff6-779c-4391-8b98-363890f4abfb.png"/></div>
<p>Number of farmers' markets per hexagon</p>
<p>The highest number of markets per hexagon, however, is currently 169. We can do two things here. We can either choose a lower value as our maximum color scale value, say 20. That would only scale our values from 1 to 20 to the <em>Viridis</em> spectrum. All hexagons with higher values would receive the maximum colour (purple) by default.</p>
<p>A more elegant alternative is to use an <strong>exponential interpolator</strong> for the color scale. Our domain would map not linearly but exponentially to our color output, effectively reaching the end of our color spectrum (purple) with much lower values. To achieve this, we just need a new color scale with a custom interpolator. Let's take a look at the code first:</p>
<pre>colorScale = d3.scaleSequential(function(t) {<br/><br/>    var tNew = Math.pow(t,10);<br/>    return d3.interpolateViridis(tNew)<br/><br/>}).domain([maxCount, 1]);</pre>
<p>What exactly are we doing here? Let's reconsider the scaling steps we went through in the preceding code:</p>
<ol>
<li>The scale receives a number <em>24</em> (as in <kbd>colorScale(24)</kbd>).</li>
<li>According to the <kbd>.domain()</kbd> input (<kbd>[max, min]</kbd> rather than <kbd>[min, max]</kbd>), the scale normalizes <em>24</em> to 0.84. No change for points <em>1</em> and <em>2</em>.</li>
<li>With the old <kbd>colorScale</kbd>, we just waved through this <em>linearly normalized value</em> between <em>1</em> and <em>0</em> without us interfering. Now, we catch it as an argument to a callback. Convention lets us call this <kbd>t</kbd>. Now, we can use and transform this however we desire. As we saw previously, many hexagons encircle 1 to 20 markets, very few encircle more. So we want to traverse the majority of the Viridis color space in the lower range of our values so that the color scale encodes the interesting part of our data. How do we do this?</li>
<li>Before we pass <kbd>t</kbd> to our color interpolator, we set it to the <em>power of 10</em>. We can use a different exponent, but <em>10</em> works fine. In general, taking the power of a number between <em>0</em> and <em>1</em> returns a smaller number. The higher the power, the smaller the output will be. Our linear <kbd>t</kbd> was <em>0.84</em>; our exponential <kbd>tNew</kbd> equals <em>0.23</em>.</li>
<li>Finally, we pass <kbd>tNew</kbd> to the <em>Viridis</em> interpolator, which spits out the respective—much darker—color.</li>
</ol>
<p>Let's graph this transformation to clarify:</p>
<div><img src="img/2c99ded5-f9ee-434e-9985-91e0df2bce73.png"/></div>
<p>Linear versus exponential color interpolation</p>
<p>The <em>x axis</em> shows the input values, the <em>y axis</em> shows our scale-normalized value <kbd>t</kbd> that we send to the interpolator to retrieve a corresponding color. The <strong>left graph</strong> shows what a linear interpolation does. It linearly translates the increase of values to the decrease in <kbd>t</kbd>. The curve in the <strong>right graph</strong> shows us how our adjusted <kbd>tNew</kbd> behaves after setting <kbd>t</kbd> to the <em>power of 10</em>: we enter the lower regions of <kbd>t</kbd> (the more purple regions) with much smaller input values. Put differently, we traverse the color space from yellow to purple in a much smaller range of domain values. Piping our example value of 24 through a <em>linear interpolation</em> would return a yellowish green; piping it through our <em>exponential interpolation</em> already returns a purple value from the end of the color spectrum.</p>
<p>The main win this brings is that color differences can be seen where the data is rather than where the gap between the main data cluster and the outlier is. Here is our hexbin map with an exponential scale:</p>
<div><img height="450" width="670" src="img/87e8893d-023b-44c8-aedb-ba89420c07ac.png"/></div>
<p>A more interestingly colored hexbin map</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-6">https://larsvers.github.io/learning-d3-mapping-11-6</a> the and code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_06.html">11_06.html</a>.</p>
<p>Let’s just revel in our achievement for a moment, but are we done? We’re itching to explore this map a little more. After all, people are used to playing with maps, trying to locate themselves in them or move from one area to the other with ease. That’s what we will allow for in our last step.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Turning our visual into an interactive app</h1>
                
            
            
                
<p>You have officially built a hexbin map, and that was indeed the key focus of this chapter. However, in this last section, let’s leisurely consider how we might make this more engaging and informative for ourselves and our users. We won’t go into as much detail as in the previous sections, but will go through general steps about how to improve the app.</p>
<p>Here’s a list of what we can do:</p>
<ol>
<li>Show the markets in a list on hover.</li>
<li>Let the user change the hexagon size.</li>
<li>Let the user change the exponent for the color scale interpolator.</li>
<li>Show which markets sell specific products, e.g. cheese, wine, seafood, etc.</li>
<li>Encode a second variable as hexagon size.</li>
</ol>
<p>The first is standard. The second and third point would be very helpful for exploration of the data. The fourth point is indeed possible, as the data also covers variables specifying what products each market sells. The last point would be good for our own practice with the <kbd>d3.hexbin()</kbd> module.</p>
<div><p>We won’t go into detail of each of these points, but do take a look at the finished app at <a href="https://larsvers.github.io/learning-d3-mapping-11-8">https://larsvers.github.io/learning-d3-mapping-11-8</a>. The code is commented and available as example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html">11_08.html</a> in the <kbd>Chapter 11</kbd> folder at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a>.<a href="https://github.com/larsvers/ld3m_ch4ex8"/></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding additional information on hover and click</h1>
                
            
            
                
<p>Tooltips are a helpful exploration technique for most visualizations in order to give the user details on a certain data point or area. In this case, the smallest data units of the app are the hexagons. However, some of the hexagons contain more information that would fit on a tooltip—up to 169 as we’ve seen above. To allow the user to browse the markets per area, we will add a side panel listing all the markets in the hovered hexagon. This is how it could look:</p>
<div><img height="445" width="870" src="img/1ba70117-040b-469b-81c9-515964e91d8b.png"/></div>
<p>Interactive hexbin map with title, tooltip, and list of markets per hexagon</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-8">https://larsvers.github.io/learning-d3-mapping-11-8</a>. the and code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_08.html">11_08.html</a>. Please use a recent version of the Chrome browser to view or work along these examples.</p>
<p>The list changes rapidly when the user moves around, so a click on a hexagon would lock the list view so that the user can explore and potentially use the links to get to the markets' websites.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the hexagon size</h1>
                
            
            
                
<p>A key advantage of hexbin maps compared to dot density maps is that interaction is easier. If you have many dots on a map, you might have to keep them small (1-3 pixels) to convey a good sense of the data. Such small targets are hard to catch with the mouse. Furthermore, some dots will inevitably overlap, so you can’t get to them at all. In a hexbin map, each hexagon is reachable, if it’s not too small. I would even argue that our choice of hexagon size might be a little small with <strong>3.5</strong> pixels. Let’s add a drop-down control, allowing the user to change the size of area. Here are some hexagon size variants:</p>
<div><img src="img/e27fd0fc-880f-403a-8b4c-61c813abb740.png"/></div>
<p>Different hex radii</p>
<p>Two notes of caution here: when building a regularly tessellated hexbin map as we do, you might run into the <strong>border problem</strong>. Imagine a large hexagon just touching the tip of Florida. 5% of the hexagon is over land, 95% is over sea. However, the map readers can’t see the real coastal line. They assume the hexagon represents the coastal line, covering 100% land area. If that corner of Florida has a high point density, this hexagon should encode it. However, as it only covers 5% of the land, and maybe around 5% of the dot density, it appears to the reader as though the coast of Florida is void of dots.</p>
<p>Another problem that becomes apparent when you look at the different sized hexagons above is the so-called <strong>modifiable areal unit problem</strong> (MAUD). The summary values we encode are highly dependent on the shape and the scale of our aggregation units. This is a problem, as the results might differ when the same analysis is applied to the same data. You can see the <em>scale effect</em> above; changing hexagon size results in a different perception of farmers markets’ density. The <em>shape</em> or <em>zone effect</em> can be more problematic. Using a different shape at the same scale, for example, 10-mile squares instead of 10-mile hexagons can change the aggregate and hence analysis. It then becomes an analysis of different bins rather than of the underlying data. This effect is particularly problematic when representing non-arbitrary units such as counties or census tracts, which might change in shape over time but remain consistent in the readers’ minds.</p>
<p>You could solve the border problem by overlaying the country outline, but the key step to alleviate any of these problems is your awareness, explaining potential issues to readers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the color scale interpolator</h1>
                
            
            
                
<p>In exploratory displays, it can be beneficial for users to change the scale in order to discover data areas of interest. By allowing our users to adjust the interpolator, they can focus on value ranges of their interest. The parameter we want to expose is the exponent our exponential interpolator uses:</p>
<div><img src="img/bbacf15b-4f7b-4172-b953-df84a6d96839.png"/></div>
<p>Changing the color scale interpolator</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Browsing different datasets</h1>
                
            
            
                
<p>The farmers' market data we are using here also offers over 29 binary variables, indicating what products or facilities markets offer. Multiple datasets showing the geographical distribution of markets with different produce would be a good option. Alternatively, we can add a drop-down menu for the users to choose what products they are most interested in. Here are some examples:</p>
<div><img height="414" width="635" src="img/128c37e6-c557-41f9-aeaf-6100359ecf15.png"/></div>
<p>Hexbin maps of different datasets (we chose 20 of the 29 binary variables available for the app)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Encoding data as hexagon size</h1>
                
            
            
                
<p>So far, we have encoded data only as color. <kbd>d3.hexbin()</kbd> makes it very easy to encode data by hexagon size. Theoretically, you just have to go to your <kbd>drawHexmap()</kbd> function and change a single line:</p>
<pre>  .attr('d', function(d) { return hexbin.hexagon(d.datapoints); })</pre>
<p>You just add a hexagon-specific radius to your <kbd>hexbin</kbd> path generator (as an optional argument to the <kbd>.hexagon()</kbd> method), which in our case above makes sure that each hexagon gets a radius as little or large as this hexagon’s count of farmers' markets. However, that would look excessive as most would get a radius of <em>0</em> and some would get a radius of over <em>100</em>. I’ll spare you the visual.</p>
<p>Instead, we will add the variable <kbd>radiusScale</kbd> to the mix (in <kbd>rollUpHexPoints()</kbd>), which will scale sizes from between <kbd>3.5</kbd> to <kbd>15</kbd> pixels:</p>
<pre>radiusScale = d3.scaleSqrt().domain([0, maxCount]).range([3.5, 15]);</pre>
<p>You can now use it when you draw the hexagons, which you should also sort ascendingly so that the larger ones aren’t covered by the many small hexagons around them:</p>
<pre>function drawHexmap(points) {<br/>  var hexes = svg.append('g').attr('id', 'hexes')<br/>    .selectAll('.hex')<br/><strong>    .data(points.sort(function(a,b) { <br/>        return a.datapoints - b.datapoints;        <br/>    }))<br/></strong>    .enter().append('path')<br/>      .attr('class', 'hex')<br/>      .attr('transform', function(d) { <br/>        return 'translate(' + d.x + ', ' + d.y + ')'; <br/>      })<br/><strong>      .attr('d', function(d) { <br/>        return hexbin.hexagon(radiusScale(d.datapoints)); <br/>      })<br/></strong>      .style('fill', function(d) { return <br/>        d.datapoints === 0 ? 'none' : colorScale(d.datapoints); <br/>      })<br/>      .style('stroke', '#ccc')<br/>      .style('stroke-width', 1);<br/>}</pre>
<p>You get hexagons not only colored, but also sized by the number of markets within the hexagon:</p>
<div><img height="476" width="709" src="img/0e892f98-f863-496a-b7aa-4a1a57c309f1.png"/></div>
<p>Number of markets encoded as color AND radius size</p>
<p>View this step in the browser at <a href="https://larsvers.github.io/learning-d3-mapping-11-7">https://larsvers.github.io/learning-d3-mapping-11-7</a> and the code example at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2011%20-%20Hexbin%20Maps/11_07.html">11_07.html</a>.</p>
<p>We double encode the number of markets as color and size here. That’s sometimes useful, but you have two encoding channels at your disposal here, which you can use for two variables to produce a <strong>bi-variate hexbin map</strong>. It's your choice.</p>
<p>We’ve covered a few options to improve and add to our hexbin map. There are certainly more options to have fun with. For example, we haven’t touched on zooming and panning, which is, of course, a standard map interaction technique and would be a good addition for people to dive into smaller hexagons. I’m sure that you can think of more ways to build on it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We started by comparing a few map visualization techniques. We covered the uses, benefits, and caveats of choropleth maps, cartograms, and dot density maps. We moved swiftly to the hexagon shape and explored how its geometrical properties can help choropleth and dot density maps.</p>
<p>Most of the chapter was, however, spent in the mapping workshop, building a hexbin map from scratch. We could have built a simple hexbin map, just covering areas with datapoints, but our goal was to shape a map entirely of hexagons for the kicks and the aesthetics. That meant a little more data preparation—creating a map-shaped layout grid, joining the datapoints, and eventually adding and color-encoding the hexagons—but doesn’t it look pretty?</p>
<p>Finally, we turned our static map into an interactive application, handing significant control over shape and information gain to the user. A lot can be achieved with interaction, especially with maps!</p>
<p>After having created a fully functional interactive visualization, you might want to show it to the world. There are many ways to claim some online real estate; in the next chapter, we'll look at a conveniently simple one: <em>GitHub pages</em>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>