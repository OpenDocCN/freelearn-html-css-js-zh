- en: Chapter 4. Introducing Node.js Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we're up to speed with the syntax of the JavaScript language, we can
    start building up our application. To do this, we need to know how to structure
    our application to allow it to grow in a maintainable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring JavaScript code with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring and using our own modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing modules into files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an Express middleware module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing your codebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most programming platforms provide several mechanisms for structuring your
    code. Consider C#/.NET or Java: you can use classes, namespaces or packages, and
    compilation units (assemblies or JAR/WAR files). Notice the range from small-scale
    organizational units (classes) to large-scale ones (assemblies). This allows you
    to make a codebase more approachable by providing order at each level of detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Classic browser-based JavaScript development was quite unstructured. Functions
    were the only built-in language feature for organizing your code. You could split
    your code into separate script files, but these all share the same global context
    within a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, people have developed ways of organizing JavaScript code. The standard
    approach now is to use **modules**. There are a few different module systems available
    for JavaScript, but they all work in a similar way. Each module system includes
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: A way of declaring a module with a name and its own scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of defining functionality provided by the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way of importing a module into another script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each system, when you import a module, you get a plain JavaScript object
    that you can assign to a variable. For most modules, this will be an object with
    several properties containing functions. But it could be any valid JavaScript
    object, for example, a single function.
  prefs: []
  type: TYPE_NORMAL
- en: Most module systems expect or at least encourage you to define each module in
    a separate file, just as you would with classes in other languages. It is also
    common for large modules to be composed of other, smaller, modules. These would
    be grouped together under the same directory. In this way, modules act more like
    namespaces or packages.
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility of modules means that you can use them to structure your code
    at different scales. The lack of a built-in hierarchy of organizational units
    in JavaScript provides more flexibility. It also forces you to think more about
    how you structure your code.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript module systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ECMAScript 2015 introduces modules as a built-in feature of the language. They
    have been common practice for a while, though. For client-side programming, this
    practice has relied on using third-party libraries to provide a module system.
  prefs: []
  type: TYPE_NORMAL
- en: You may have seen RequireJS, which provides a way of using functions to define
    modules. RequireJS uses plain JavaScript and works in any environment. It is most
    useful in the browser, where additional modules may be loaded over the Internet.
    RequireJS addresses some of the pitfalls of loading additional scripts dynamically
    and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js environment has its own module system, which we will look at in
    the rest of this chapter. It makes use of the filesystem for organizing modules.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might come across the terms **AMD** or **CommonJS**. These are standards
    for defining modules. RequireJS is an implementation of AMD, and Node.js modules
    follow the CommonJS standard. ECMAScript 2015 modules define a new standard with
    new `export` and `import` language keywords. The syntax is quite similar, though,
    to the Node.js module system we'll be using in this book, and it is easy to switch
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Creating modules in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've actually already used several Node.js modules and created some of our
    own. Let's look again at our application from [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `routes/index.js and routes/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code from `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each of our routes (index and users) is a module. They expose their functionality
    using the built-in `module` object, which is defined by Node.js as a variable
    scoped to each module. In the preceding example, the object provided by each of
    our route modules is an Express router instance. The `app.js` script imports these
    modules using the built-in `require` function.
  prefs: []
  type: TYPE_NORMAL
- en: Observe that `app.js` also imports various `npm` packages using `require`. Note
    that it uses file paths to reference our own modules, whereas `npm` modules are
    referenced by name.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how Node.js modules satisfy the three aspects of JavaScript module
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a module with a name and its own scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Node.js, each separate JavaScript file is automatically treated as a new
    module. Unlike scripts loaded into a web page, each file has its own scope. The
    name of the module is the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining functionality provided by the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js provides two built-in variables for exporting functionality from a
    module. These are `module.exports` and `exports`. `module.exports` is initialized
    to an empty object. `exports` is just a reference to `module.exports`. It is equivalent
    to the following appearing before your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever is contained in the `module.exports` variable at the end of your script
    is the exported value of your module. This will be returned whenever your module
    is imported elsewhere. The following are all equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following is *not* the same as the previous examples. It just
    reassigns `exports`, but doesn''t alter `module.exports` at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Importing a module into another script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js provides another built-in variable for importing modules. This is the
    `require` function we saw in `app.js` earlier in the chapter. This function is
    provided by Node.js and always available. It takes a single argument, which is
    the name or path of the module you want to import. The following excerpts from
    `app.js` demonstrate loading a third-party module by name and one of our own modules
    by a file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to specify the `.js` file extension for our own module.
    Node.js will automatically add this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a directory-level module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, modules can also act more like
    namespaces. We can treat a whole directory as a module, consisting of smaller
    modules in individual files. The simplest way to do this is to create an `index.js`
    file in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: When calling `require('./directoryName')`, Node.js will attempt to load a file
    named `'./directoryName/index.js'` (relative to the current script). There is
    nothing special about `index.js` itself. This is just another script file that
    exposes an entry point to the module. If `directoryName` contains a `package.json`
    file, Node.js will load this file first and see if it specifies a `main` script,
    in which case Node.js will load this script instead of looking for `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: To import local modules, we use a file or directory path, that is, something
    starting with `'/'`, `'../'`, or `'./'` as in the preceding example. If we call
    `require` with a plain string, Node.js treats it as relative to the `node_modules`
    folder. The `npm` packages are just directory-level modules under this folder.
    We will look at defining our own `npm` packages in more detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Express middleware module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's return to the Node.js application we started in [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*. We're
    going to write an application where users can set puzzles for one another. First
    of all, we'll need a way of identifying the current user. We'll need to do this
    on most requests, making it a cross-cutting concern. This is a good use case for
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will implement users in the simplest way possible, just storing
    an ID in a cookie. We will look into more robust identification in a later chapter.
    Note, however, that our use of middleware means it will be easy to alter our approach
    later on. This concern is encapsulated in our user middleware, so we only need
    to change it in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a way of generating unique IDs. For this, we will use the UUID
    module from npm. We can add this to our project by running the following on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `--save` flag stores the name of this module in our `package.json` file
    so that it will be installed automatically by `npm install`. This is useful for
    restoring our application from a clean checkout of the source code (recall that
    people commonly exclude the `node_modules` directory from source control, precisely
    because it can easily be restored in this way).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to create our middleware, which will place under `middleware/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use the ES2015 `const` keyword for the `uuid` module because
    this reference never changes. But we use the `let` keyword for the `userId` variable
    because this can be reassigned. Also notice that we call `next()` rather than
    returning a response, so the next middleware can continue processing the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add this middleware to our application in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that this replaces the import and usage of the `./routes/users` module
    that was generated for us. This route wasn't particularly useful, but we will
    add more routes soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check that our middleware works by altering our index route and view
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code `views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Launch the application and visit `http://localhost:3000/`. You should see a
    randomly-generated user ID. Refresh the page and you should retain the same ID.
    Open the site in a different browser (or an incognito/private browsing window).
    This separate browser session should see a different ID.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to use Node.js modules to structure our codebase,
    and how to create an Express middleware module to implement cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way of structuring our codebase and a means of identifying
    users, we can get on with implementing our application's functionality. In the
    next chapter, we'll start adding some interactivity to our application.
  prefs: []
  type: TYPE_NORMAL
