<html><head></head><body><div><h1 class="header-title">Frontend Development with Angular and TypeScript</h1>
                
            
            
                
<p>In this chapter, we are going to learn how to develop a frontend web application with Angular and TypeScript. Just like in the previous chapter, we are going to try to use the backend Node.js application that we previously implemented. The application that we are going to develop is a clone of the frontend application that we developed in the previous chapter.</p>
<p>The features and styling of the application will be identical. However, the implementation will present some significant differences because we are going to use Angular instead of React as our frontend application development framework.</p>
<p>We are not going to go through the requirements of the application that we are going to implement in this chapter because we have covered them already in the preceding chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with Angular</h1>
                
            
            
                
<p>Angular is a library that allows us to implement web user interfaces. In this chapter, we are going to create a small frontend application using Angular.</p>
<p>As we learned in the preceding chapter, the JavaScript environment in Node.js and a web browser are quite different. The browser environment doesn't support modules natively and loading time is one of the major factors that influence the performance of a frontend application, which explains the need for a module bundler like webpack when we are working on a frontend web application.</p>
<p>In this chapter, we are going to use Webpack just as we have been doing throughout this book. We are going to use the following Webpack configuration. It is almost identical to the configuration used in the preceding chapter, but we have introduced a few modifications:</p>
<pre>const { CheckerPlugin } = require("awesome-typescript-loader"); 
const webpack = require("webpack"); 
const ExtractTextPlugin = require("extract-text-webpack-plugin"); 
const CopyWebpackPlugin = require("copy-webpack-plugin"); 
const path = require ("path"); 
 
const corePlugins = [ 
    new CheckerPlugin(), 
    new webpack.DefinePlugin({ 
        "process.env.NODE_ENV": JSON.stringify(process.env.NODE_ENV || "development") 
    }), 
    new ExtractTextPlugin({ 
        filename: "[name].css", 
        allChunks: true 
    }), 
    new CopyWebpackPlugin([ 
        { from: "./web/frontend/index.html", to: "index.html" } 
    ]), </pre>
<p>We have introduced the <kbd>CommonChunkPlugin</kbd>. This plugin is used to identify pieces of code that repeat or that match a given rule. When a piece of code matches a condition, it is extracted from the main application bundle and is added to a second bundle named <kbd>vendor</kbd>. In this case, we are going to move all the pieces of code located under the <kbd>node_modules</kbd> folder to the vendor bundle, which means that we are going to end up with two bundles, one for the application and one for the third-party libraries:</p>
<pre>    new webpack.optimize.CommonsChunkPlugin({ 
        name: "vendor", 
        minChunks: (module) =&gt; { 
            return module.context &amp;&amp; module.context.includes("node_modules"); 
        } 
    }) 
]; 
 
const devPlugins = []; 
 
const prodPlugins = [ 
    new webpack.optimize.UglifyJsPlugin({ output: { comments: false } }) 
]; 
 
const isProduction = process.env.NODE_ENV === "production"; 
const plugins = isProduction ? corePlugins.concat(prodPlugins) : corePlugins.concat(devPlugins); </pre>
<p>We have also introduced an additional application entry point. We import the <kbd>zone.js</kbd> module. This module is a polyfill for the Zones API, which is a mechanism for intercepting and keeping track of asynchronous work. Zones are defined as follows in the Zone.js documentation:</p>
<p>"A Zone is a global object which is configured with rules about how to intercept and keep track of the asynchronous callbacks. Zone has these responsibilities:<br/>
<br/>
Intercept asynchronous task scheduling<br/>Wrap callbacks for error-handling and zone tracking across async operations<br/>
Provide a way to attach data to zones<br/>Provide a context-specific last frame error handling<br/>(Intercept blocking methods)<br/><br/>
In its simplest form, a Zone allows one to intercept the scheduling and calling of asynchronous operations, and execute additional code before as well as after the asynchronous task."<br/></p>
<p>We need Zone.js because it is one of the dependencies of Angular. The rest of the Webpack configuration doesn't present any other major differences:</p>
<pre>module.exports = { 
    entry: [ 
        "zone.js/dist/zone", 
        "./web/frontend/main.ts" 
    ], 
    devServer: { 
        inline: true 
    }, 
    output: { 
        filename: "[name].js", 
        chunkFilename: "[name]-chunk.js", 
        publicPath: "/public/", 
        path: path.resolve(__dirname, "public") 
    }, 
    devtool: isProduction ? "source-map" : "eval-source-map", 
    resolve: { 
        extensions: [".webpack.js", ".ts", ".tsx", ".js"] 
    }, 
    module: { 
        rules: [ 
            { 
                enforce: "pre", 
                test: /.js$/, 
                loader: "source-map-loader", 
                exclude: [/node_modules/] 
            }, 
            { 
                test: /.(ts|tsx)$/, 
                loader: "awesome-typescript-loader", 
                exclude: [/node_modules/] 
            }, 
            { 
                test: /.scss$/, 
                use: ExtractTextPlugin.extract({ 
                    fallback: "style-loader", 
                    use: ["css-loader", "resolve-url-loader", "sass-loader"] 
                }) 
            } 
        ] 
    }, 
    plugins: plugins 
}; </pre>
<p>Please refer to <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>, <em>Automating Your Development Workflow</em>, to learn more about webpack.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">About the sample application</h1>
                
            
            
                
<p>In this chapter, we are going to implement the same application that we implemented in the preceding chapter one more time. However, we will use Angular instead of React and MobX as our application development framework. We will try to implement a copy of the application as close as possible, to enable us to compare both frameworks.</p>
<p>The application is included in the companion source code and it is a very small web application that allows us to manage a database of movies and actors. We will not explain the features of the application in detail here because we already explained them in the preceding chapter.</p>
<p>Please refer to <a href="b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml">Chapter 11</a>, <em>Frontend Development with React and TypeScript</em>, to learn more about the application features and requirements.
<p>Please refer to the companion source code to have access to the entire source code of the application as well as its configuration, including things like the entire <kbd>package.json</kbd> file.</p>
</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Serving an Angular application with Node.js</h1>
                
            
            
                
<p>Just like we did in the preceding chapter, we need to configure Node.js to server the files of our frontend web application. We use the Express static middleware to implement this feature just like we did in the preceding chapter.</p>
<p>Please refer to <a href="b3b736e7-2cff-46e9-aa78-87452a58afa8.xhtml">Chapter 11</a>, <em>Frontend Development with React and TypeScript</em>, to learn more about the Express static middleware. In particular, please refer to the <em>Serving React applications with Node.js</em> section.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Bootstrapping an Angular application</h1>
                
            
            
                
<p>The entry point of the frontend application is in the <kbd>web/frontend/main.ts</kbd> file:</p>
<pre>import { platformBrowserDynamic } from "@angular/platform-browser-dynamic"; 
import { AppModule } from "./app.module"; 
 
platformBrowserDynamic().bootstrapModule(AppModule).catch((err) =&gt; { 
  console.error(err); // tslint:disable-line 
}); </pre>
<p>We use the <kbd>platformBrowserDynamic</kbd> module to bootstrap our application. We do this by invoking the <kbd>bootstrapModule</kbd> method and passing the main module in our application as an argument. We will learn more about modules in the following section.</p>
<p>In this section, we are going to focus on the <kbd>platformBrowserDynamic</kbd> module. The <kbd>platform-browser-dynamic</kbd>Â module can be installed using <kbd>npm</kbd> as follows:</p>
<pre><strong>npm install --save platform-browser-dynamic</strong></pre>
<p>We use <kbd>platformBrowserDynamic</kbd> because we expect our application to be executed in a browser environment. An Angular application can also be executed in a server-side environment like Node.js, but it requires a slightly different bootstrapping configuration. Executing an Angular application in Node.js can be used to improve the initial loading time of the application. We will not cover this topic in this chapter because it is an advanced feature and the purpose of this chapter is just to introduce Angular.</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/universal">https://angular.io/guide/universal</a> if you wish to learn more about server-side rendering with Angular.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with NgModules</h1>
                
            
            
                
<p>In the preceding section, we used a module named <kbd>AppModule</kbd> to bootstrap our Angular application. The <kbd>AppModule</kbd> is in the <kbd>web/frontend/app.module.ts</kbd> file and its content looks as follows:</p>
<pre>import { NgModule } from "@angular/core"; 
import { BrowserModule } from "@angular/platform-browser"; 
import { CommonModule } from "@angular/common"; 
import { AppRoutingModule } from "./app-routing.module"; 
import { AppComponent } from "./app.component"; 
import { LayoutModule } from "./config/layout.module"; 
import "../../node_modules/bootstrap/scss/bootstrap.scss"; 
import "./app.scss"; 
 
@NgModule({ 
    bootstrap: [AppComponent], 
    declarations: [AppComponent], 
    imports: [ 
        BrowserModule, 
        CommonModule, 
        AppRoutingModule, 
        LayoutModule 
    ] 
}) 
export class AppModule { 
} </pre>
<p>The <kbd>AppModule</kbd> is the entry point of our application, and it provides access to every other element in the application. The Angular documentation defines a module as follows:</p>
<p>"An NgModule is a class marked by the @NgModule decorator. @NgModule takes a metadata object that describes how to compile a component's template and how to create an injector at runtime. It identifies the module's own components, directives, and pipes, making some of them public, through the exports property, so that external components can use them. @NgModule can also add service providers to the application dependency injectors.<br/>
<br/>
Modules are a great way to organize an application and extend it with capabilities from external libraries. Angular libraries are NgModules, such as FormsModule, HttpClientModule, and RouterModule. Many third-party libraries are available as NgModules. NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities."</p>
<p>A module allows us to group features; we can group all the elements (components, services, and so on) required for certain feature into a module.</p>
<p>The <kbd>@NgModule</kbd> decorator allows us to set up certain settings. The following list defines the purpose of some of the fields used by the application included in the companion source code:</p>
<ul>
<li>The <kbd>bootstrap</kbd> field is used to declare which component must be the root component during the bootstrapping process</li>
<li>The <kbd>declarations</kbd> field is used to declare which components are going to be used within the Angular templates</li>
<li>The <kbd>imports</kbd> field is used to make other components available within the module</li>
<li>The <kbd>exports</kbd> field is used to make components available to other modules</li>
<li>The <kbd>providers</kbd> field is used to configure the dependency injection bindings</li>
</ul>
<p>It is important to clarify that Angular's <kbd>@NgModule</kbd> imports/exports and ES6 import/export modules are entirely different concepts.</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/ngmodules">https://angular.io/guide/ngmodules</a> to learn more about modules.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with Angular components</h1>
                
            
            
                
<p>In this section, we are going to learn how to work with components. We are going to learn how to work to implement components and routing, as well as other concepts such as how to implement dependency injection in an Angular application.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Our first component</h1>
                
            
            
                
<p>In this section, we are going to look at our first Angular component. Earlier in this chapter, we learned how to bootstrap an Angular application, and we used the <kbd>AppModule</kbd>. Later, we learned that the <kbd>AppModule</kbd> uses the <kbd>AppComponent</kbd> as the root component of our application. We will now look at the <kbd>AppComponent</kbd>:</p>
<pre>import { Component } from "@angular/core"; 
 
@Component({ 
    selector: "app-root", 
    template: ` 
    &lt;app-layout&gt;&lt;/app-layout&gt;`, 
}) 
export class AppComponent { 
} </pre>
<p>As you can see, in Angular, a component is a class decorated with the <kbd>@Component</kbd> decorator. The <kbd>@Component</kbd> decorator takes some settings.</p>
<p>In this case, we use the <kbd>selector</kbd> setting to declare the name used to reference this component within a template. The <kbd>AppComponent</kbd> is the root component in our application; this means that it must be displayed as the root element in our <kbd>index.html</kbd> page. We can achieve this by adding a reference to the selector of our component in our <kbd>index.html</kbd> page:</p>
<pre>&lt;body&gt; 
    &lt;app-root&gt;Loading...&lt;/app-root&gt; 
    &lt;script src="img/vendor.js"&gt;&lt;/script&gt; 
    &lt;script src="img/main.js"&gt;&lt;/script&gt; 
  &lt;/body&gt; </pre>
<p>When the page loads it will display Loading... within the <kbd>&lt;app-root&gt;</kbd> DOM element at first. As soon as the vendor and main bundle files are loaded, the Angular application will be executed, and the <kbd>bootstrap</kbd> function will render the template of the <kbd>AppComponent</kbd> within the <kbd>&lt;app-root&gt;</kbd> DOM element, which will cause the <kbd>Loading...</kbd> label to disappear.</p>
<p>We use the <kbd>template</kbd> setting to define the output that we wish to be generated when the component is rendered. In this case, the template is rendering another component that uses <kbd>app-layout</kbd> as its selector. We defined the template in-line, but it is also possible to define the template in a separate HTML file and reference it by using the <kbd>templateUrl</kbd> setting.</p>
<p>It is important to note that we can only use a component in a template if both components have been configured correctly within an <kbd>NgModule</kbd>, as explained in the preceding section.</p>
<p>Sometimes the components will use additional settings; we will not explain all the available settings in this chapter because our goal is only to provide a basic introduction to Angular.</p>
<p>It is also interesting to mention that, in Angular, a component is always a class. In React, it was possible to implement a component as a function or as a class, but in Angular components are always classes, which means that there are no functional stateless components in Angular.</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/architecture-components">https://angular.io/guide/architecture-components</a> to learn more about Angular components.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Components and directives</h1>
                
            
            
                
<p>The existing Angular literature contains a lot of references to what are known as directives. Sometimes directives are mentioned as something that can be used together with components as if they were the same thing. The truth is that components are a kind of directive. The following has been extracted from the official Angular documentation:</p>
<p>There are three kinds of directives in Angular:</p>
<ul>
<li><em>Components-directives with a template.</em></li>
<li><em>Structural directives-change the DOM layout by adding and removing DOM elements.</em></li>
<li><em>Attribute directives-change the appearance or behavior of an element, component, or another directive.</em></li>
</ul>
<p>We are not going to learn how to create custom attribute directives in this chapter. However, is it important to understand that components are a kind of directive.</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/attribute-directives">https://angular.io/guide/attribute-directives</a> to learn more about directives.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Data binding</h1>
                
            
            
                
<p>In Angular, we use data binding to coordinate the application's state with the content rendered on screen. Angular supports three kinds of binding, distinguished by the direction of data flow:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Data direction</strong></p>
</td>
<td>
<p><strong>Syntax</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
</tr>
<tr>
<td>
<p>One-way<br/>
from data source<br/>
to view target</p>
</td>
<td>
<p><kbd>{{expression}} [target]="expression"</kbd></p>
</td>
<td>
<ul>
<li>Interpolation</li>
<li>Property</li>
<li>Attribute</li>
<li>Class</li>
<li>Style</li>
</ul>
</td>
</tr>
<tr>
<td>
<p>One-way<br/>
from view target<br/>
to data source</p>
</td>
<td>
<p><kbd>(target)="statement"</kbd></p>
</td>
<td>
<p>Event</p>
</td>
</tr>
<tr>
<td>
<p>Two-way</p>
</td>
<td>
<p><kbd>[(target)]="expression"</kbd></p>
</td>
<td>
<p>Two-way</p>
</td>
</tr>
</tbody>
</table>
<p>Binding types other than interpolation have a target name to the left of the equals sign, surrounded by punctuation (<kbd>[]</kbd> and <kbd>()</kbd>).</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/template-syntax">https://angular.io/guide/template-syntax</a> to learn more about the data binding syntax.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with @Attribute and @Input</h1>
                
            
            
                
<p>In the preceding section, we learned that the <kbd>AppComponent</kbd> renders the <kbd>AppLayout</kbd> component. In this section, we are going to look at the <kbd>AppLayout</kbd>:</p>
<pre>import { Component, OnInit } from "@angular/core"; 
import { Route } from "../components/header.component"; 
 
@Component({ 
  selector: "app-layout", 
  template: ` 
    &lt;div&gt; 
        &lt;app-header 
            bg="primary" 
            title="TsMovies" 
            rootPath="" 
            [links]="appRoutes" 
        &gt;&lt;/app-header&gt; 
        &lt;main&gt; 
            &lt;router-outlet&gt;&lt;/router-outlet&gt; 
        &lt;/main&gt; 
    &lt;/div&gt; 
  ` 
}) 
export class LayoutComponent { 
    public appRoutes: Route[] = [ 
        { label: "Movies", path: "movies" }, 
        { label: "Actors", path: "actors" } 
    ]; 
} </pre>
<p>The <kbd>Layout</kbd> component uses the <kbd>app-layout</kbd>Â selector and declares an inline template. The template uses two other components with the <kbd>app-header</kbd>Â and <kbd>router-outlet</kbd>Â selectors. We will ignore the component with theÂ <kbd>router-outlet</kbd>Â selectorÂ for now because we will learn more about it later, in the <em>Working with the Angular router</em> section.</p>
<p>Let's focus on the component with the selector <kbd>app-header</kbd>Â for now. As we can see in the preceding code snippet, some arguments are passed to the <kbd>HeaderComponent</kbd>. However, not all the arguments are passed in the same manner.</p>
<p>We have some arguments passed as follows (one-way data binding from data source to view target):</p>
<pre>bg="primary" </pre>
<p>In this case, we are passing the string value primary as what is known as an attribute. We also have some arguments passed as follows:</p>
<pre>[links]="appRoutes" </pre>
<p>In this case, we are binding the value of the property <kbd>appRoutes</kbd> and passing it to the <kbd>AppHeader</kbd> component. This means that any changes to the <kbd>appRoutes</kbd> value will trigger the <kbd>AppHeader</kbd> component to be re-rendered.</p>
<p>We will now look at the <kbd>AppHeader</kbd> component to see how attributes and inputs are defined:</p>
<pre>import { Component, Input, Attribute } from "@angular/core"; 
 
type BgColor = "primary" | "secondary" | "success" | 
               "danger" | "warning" | "info" | "light" | 
               "dark" | "white"; 
 
export interface Route { 
    label: string; 
    path: string; 
} 
 
@Component({ 
    selector: "app-header", 
    template: ` 
        &lt;nav [ngClass]="navClass"&gt; 
        &lt;a class="navbar-brand" [routerLink]="rootPath" routerLinkActive="active"&gt; 
            {{title}} 
        &lt;/a&gt; 
        &lt;ul class="navbar-nav"&gt; 
            &lt;li *ngFor="let link of links"&gt; 
                &lt;a class="navbar-brand" [routerLink]="link.path" routerLinkActive="active"&gt; 
                    {{link.label}} 
                &lt;/a&gt; 
            &lt;/li&gt; 
        &lt;/ul&gt; 
    &lt;/nav&gt;` 
}) 
export class HeaderComponent { 
 
    public navClass!: string; 
    public title!: string; 
    public rootPath!: string; 
    @Input() public links!: Route[]; 
 
    public constructor( 
        @Attribute("bg") bg: BgColor, 
        @Attribute("title") title: string, 
        @Attribute("rootPath") rootPath: string, 
    ) { 
        this.navClass = `navbar navbar-expand-lg navbar-light bg-${bg}`; 
        this.title = title; 
        this.rootPath = rootPath; 
    } 
} </pre>
<p>The <kbd>HeaderComponent</kbd> takes some attributes, which are defined with the <kbd>@Attribute</kbd> decorator. The <kbd>HeaderComponent</kbd> also takes one input, which is defined with the <kbd>@Input</kbd> decorator:</p>
<ul>
<li>The <kbd>@Input</kbd> decorator is used to pass values into the component or to pass data from one component to another (typically parent to child)</li>
<li>The <kbd>@Attribute</kbd> directory is used to retrieve the constant value of an attribute available in the host element of the component, and it must be used with a parameter of a component's constructor</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Using structural directives</h1>
                
            
            
                
<p>In the preceding section, we looked at the <kbd>HeaderComponent</kbd>. However, we skipped some details about its template. The <kbd>HeaderComponent</kbd> uses what is known as a structural directive:</p>
<pre>&lt;li *ngFor="let link of links"&gt; 
   // ... 
&lt;/li&gt; </pre>
<p>Structural directives are responsible for HTML layout. They shape or reshape the DOM's structure, typically by adding, removing, or manipulating elements.</p>
<p>Please refer to the documentation at <a href="https://angular.io/guide/structural-directives">https://angular.io/guide/structural-directives</a> to learn more about structural directives.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using the &lt;ng-content&gt; directive</h1>
                
            
            
                
<p>We can use the <kbd>ng-content</kbd> directive to &lt;indexentry content="Angular components: directive, using"&gt;render the child of a component. For example, the following component can be used to define a row in &lt;indexentry content=" directive:using"&gt;the application's layout. However, when we define the <kbd>RowComponent</kbd>, we don't know which content will be placed into the row. We use the <kbd>ng-content</kbd> directive to refer the yet to be known child component:</p>
<pre>@Component({ 
    selector: "app-row", 
    template: ` 
        &lt;div class="row"&gt; 
            &lt;ng-content&gt;&lt;/ng-content&gt; 
        &lt;/div&gt; 
    ` 
}) 
export class RowComponent {} </pre>
<p>The <kbd>RowComponent</kbd> can then be used within a template as follows:</p>
<pre>&lt;app-row&gt; 
    &lt;h1&gt;Title&lt;/h1&gt; 
&lt;/app-row&gt; 
&lt;app-row&gt; 
    &lt;h2&gt;Subtitle&lt;/h2&gt; 
&lt;/app-row&gt; </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with @Output and EventEmitter</h1>
                
            
            
                
<p>In Angular, we can handle user events using a property whose value is an event emitter. The property must be decorated with the <kbd>@Output</kbd> decorator as demonstrated by the following code snippet:</p>
<pre>import { Component, EventEmitter, Input, Output } from "@angular/core"; 
 
@Component({ 
    selector: "app-text-field", 
    template: ` 
        &lt;input 
            type="text" 
            className="form-control" 
            [id]="id" 
            [placeholder]="placeholder" 
            (input)="onEdit($event)" 
        /&gt; 
    ` 
}) 
export class TextFieldComponent { 
 
    @Input() public id!: string; 
    @Input() public placeholder!: string; 
    @Output() public onChange = new EventEmitter&lt;{k: string; v: string}&gt;(); 
 
    public onEdit(event: any) { 
        const value = (event.target as any).value; 
        const key = (event.target as any).id; 
        this.onChange.emit({ v: value, k: key }); 
    } 
 
} </pre>
<p>In our template, we have linked an event with one of the methods in the component as follows (one-way data binding from view target to data source):</p>
<pre>(input)="onEdit($event)" </pre>
<p>The <kbd>onEdit</kbd> method will receive an event object that allows access to the target (the DOM element that started the event). We can use the event target to access the attributes of the DOM element.</p>
<p>Finally, we invoke the <kbd>emit</kbd> method of our output to pass some data to the parent component as output:</p>
<pre>public onEdit(event: any) { 
    const value = (event.target as any).value; 
    const key = (event.target as any).id; 
    this.onChange.emit({ v: value, k: key }); 
} </pre>
<p>Finally, the parent component can set one of its methods as the event handler for the <kbd>onChange</kbd> output as follows:</p>
<pre>&lt;app-text-field 
    [id]="'title'" 
    [placeholder]="'Title'" 
    (onChange)="edit($event)" 
&gt;&lt;/app-text-field&gt; </pre>
<p>Please refer to the documentation at <a href="https://angular.io/guide/component-interaction">https://angular.io/guide/component-interaction</a> to learn more about event handlers in Angular.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with the component's host</h1>
                
            
            
                
<p>In this section, we are going to demonstrate how we can use the <kbd>host</kbd>Â setting in our components to control how the component host is rendered. When a component is rendered, Angular will always create a DOM element that matches the name of the component selector. This DOM element is known as the host. For example, take a look at the following component:</p>
<pre>@Component({ 
    selector: "app-row", 
    template: ` 
        &lt;div class="row"&gt; 
            &lt;ng-content&gt;&lt;/ng-content&gt; 
        &lt;/div&gt; 
    ` 
}) 
export class RowComponent {} </pre>
<p>It can be consumed by other components as:</p>
<pre>&lt;app-row&gt; 
    Hello! 
&lt;/app-row&gt; </pre>
<p>However, it will be rendered as:</p>
<pre>&lt;app-row&gt; 
    &lt;div class="row"&gt; 
        Hello! 
    &lt;/div&gt; 
&lt;/app-row&gt; </pre>
<p>As you can see, there is an additional DOM node. Sometimes, having an additional node can lead to some layout issues and it would be much better if we could control how the host is rendered to achieve the following output:</p>
<pre>&lt;app-row class="row"&gt; 
    Hello! 
&lt;/app-row&gt; </pre>
<p>We can achieve this by using the <kbd>host</kbd> setting when we declare a component:</p>
<pre>@Component({ 
    host: { 
        "[class]": "'row'" 
    }, 
    selector: "app-row", 
    template: ` 
        &lt;ng-content&gt;&lt;/ng-content&gt; 
    ` 
}) 
export class RowComponent {} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with the Angular router</h1>
                
            
            
                
<p>Earlier in this chapter, we mentioned a component known as the <kbd>router-outlet</kbd>. The component was used by the <kbd>Layout</kbd> component as follows:</p>
<pre>&lt;main&gt; 
    &lt;router-outlet&gt;&lt;/router-outlet&gt; 
&lt;/main&gt; </pre>
<p>However, this component was not defined by us because it is defined by the <kbd>@angular/router</kbd>Â npm module. In order to use the module, we must import it and declare a <kbd>NgModule</kbd> that exports <kbd>RouteModule</kbd>. We must also declare the configuration for the router. The configuration is a map or a dictionary that links a given path with a given component:</p>
<pre>import { NgModule } from "@angular/core"; 
import { Routes, RouterModule } from "@angular/router"; 
import { HomePageComponent } from "./pages/homepage.component"; 
import { MoviesPageComponent } from "./pages/moviespage.component"; 
import { ActorsPageComponent } from "./pages/actorspage.component"; 
 
export const appRoutes: Routes = [ 
    { path: "", component: HomePageComponent }, 
    { path: "movies", component: MoviesPageComponent }, 
    { path: "actors", component: ActorsPageComponent } 
]; 
 
@NgModule({ 
    exports: [RouterModule], 
    imports: [ 
        RouterModule.forRoot( 
          appRoutes, 
          { useHash: false } 
      ) 
    ] 
}) 
 
export class AppRoutingModule {} </pre>
<p>When the browser URL matches one of the paths in the router configuration, the corresponding component is rendered into the <kbd>router-outlet</kbd> component:</p>
<pre>&lt;main&gt; 
    &lt;router-outlet&gt;&lt;/router-outlet&gt; 
&lt;/main&gt; </pre>
<p>We can trigger a change in the URL using a <kbd>routerLink</kbd>:</p>
<pre>&lt;a class="navbar-brand" [routerLink]="link.path" routerLinkActive="active"&gt; 
    {{link.label}} 
&lt;/a&gt; </pre>
<p>We have provided the path that we wish to navigate to and the CSS class to be used when the link is active. When we click on a router link, the browser URL will change, and the router will render the matching component under the <kbd>router-outlet</kbd> component.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Angular component life cycle hooks</h1>
                
            
            
                
<p>Angular allows us to declare multiple component life cycle hooks. For example, in the companion source code, the <kbd>Movie</kbd> component extends the <kbd>OnInit</kbd> interface, which declares the <kbd>ngOnInit</kbd> method. The <kbd>ngOnInit</kbd> method is one of the available component life cycle hooks in Angular:</p>
<ul>
<li>The <kbd>constructor</kbd> of the component class is called before any other component life cycle hook. The constructor is the best place to inject dependencies.</li>
<li>The <kbd>ngOnInit</kbd> method is invoked immediately after the constructor and after the <kbd>ngOnChange</kbd> is triggered for the first time, which is the perfect time for initialization work.</li>
<li>The <kbd>ngOnChanges</kbd> method is invoked first when the value of a bound property changes. It executes every time the value of an input property changes.</li>
<li>The <kbd>ngDestroy</kbd> method is invoked just before the instance of the component is finally destroyed. It is the perfect place to clean a componentâ (for example, canceling background tasks).</li>
</ul>
<p>There are more life cycle hooks available, but they are out of the scope of this book.</p>
<p>Please refer to the Angular documentation at <a href="https://angular.io/guide/lifecycle-hooks">https://angular.io/guide/lifecycle-hooks</a> to learn more about all the available life cycle hooks.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with services</h1>
                
            
            
                
<p>In Angular, it is a common practice toÂ use a service to interact with a REST API or with other resources, such as the localStorage API. The class below defines a service named <kbd>MovieService</kbd>, which can be used to send HTTP requests to the backend Node.js application.</p>
<p>A service is just a class, and it doesn't require any special decorators. However, the following code snippet uses the <kbd>@Injectable</kbd> decorator because it is going to be injected into the <kbd>MovieComponent</kbd>. We will learn more about dependency injection later, in the <em>Dependency injection in Angular</em> section.</p>
<p>The following methods perform some HTTP requests to the server using the Fetch API. There is a method to fetch all movies from the movies REST API:</p>
<pre>import { Injectable } from "@angular/core"; 
import { MovieInterface } from "../../universal/entities/movie"; 
import * as interfaces from "../interfaces"; 
 
@Injectable() 
export class MovieService implements interfaces.MovieService { 
 
    public async getAll() { 
        return new Promise&lt;MovieInterface[]&gt;(async (res, rej) =&gt; { 
            try { 
                const response = await fetch("/api/v1/movies/", { method: "GET" }); 
                const movs: MovieInterface[] = await response.json(); 
                // We use setTimeout to simulate a slow request 
                // this should allow us to see the loading component 
                setTimeout( 
                    () =&gt; { 
                        res(movs); 
                    }, 
                    1500 
                ); 
            } catch (error) { 
                rej(error); 
            } 
        }); 
    } </pre>
<p>There is also a method to create a new movie:</p>
<pre>    public async create(movie: Partial&lt;MovieInterface&gt;) { 
        const response = await fetch( 
            "/api/v1/movies/", 
            { 
                body: JSON.stringify(movie), 
                headers: { 
                    "Accept": "application/json, text/plain, */*", 
                    "Content-Type": "application/json" 
                }, 
                method: "POST" 
            } 
        ); 
        const newMovie: MovieInterface = await response.json(); 
        return newMovie; 
    } </pre>
<p>There is also a method to delete a movie:</p>
<pre>    public async delete(id: number) { 
        const response = await fetch(`/api/v1/movies/${id}`, { method: "DELETE" }); 
        await response.json(); 
    } 
 
} </pre>
<p>In the following section, we will learn how the movie service is consumed by the <kbd>Movie</kbd> component.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Smart components and dumb components</h1>
                
            
            
                
<p>The Angular components don't draw a clear separation between properties and states like React does, but we can still use the same mental model. A component renders some data. If the data is mutated by the component, we are talking about a smart component. If the component only reads the data, we are talking about a dumb component.</p>
<p>Just like we did in the React example, we have organized our project using multiple directories in a way that allows us to have very clear differentiation between smart and dumb components. The <kbd>components</kbd> directory contains only dumb components while the <kbd>pages</kbd> directory contains smart components.</p>
<p>In Angular, the dumb components, most of the time, don't require life cycle hooks, and they also don't require services. On the other hand, the smart components will most likely require some services.</p>
<p>The following code snippet declares a smart component named <kbd>MoviePages</kbd>. In our Angular application, the pages are smart components and the components are simply dumb components:</p>
<pre>import { Component, OnInit, Inject } from "@angular/core"; 
import { MovieInterface } from "../../universal/entities/movie"; 
import * as interfaces from "../interfaces"; 
import { MOVIE_SERVICE } from "../config/types"; 
 
function isValidNewMovie(o: any) { 
    if ( 
        o === null || 
        o === undefined || 
        // new movies don't have ID 
        o.id !== undefined || 
        typeof o.title !== "string" || 
        isNaN(o.year) 
    ) { 
        return false; 
    } 
    return true; 
} </pre>
<p>The component renders a list of movies:</p>
<pre>@Component({ 
    selector: "movies-page", 
    template: ` 
        &lt;app-container&gt; 
            &lt;app-row&gt; 
                &lt;app-column width="12"&gt; 
                    &lt;div style="text-align: right; margin-bottom: 10px"&gt; 
                        &lt;app-button (clicked)="focusEditor()"&gt; 
                            Add Movie 
                        &lt;/app-button&gt; 
                    &lt;/div&gt; 
                &lt;/app-column&gt; 
            &lt;/app-row&gt; 
            &lt;app-row&gt; 
                &lt;app-column width="12"&gt; 
                    &lt;app-list-group [isLoaded]="isLoaded" [errorMsg]="fetchErrorMsg"&gt; 
                        &lt;app-list-group-item *ngFor="let movie of movies"&gt; 
                            &lt;app-row&gt; 
                                &lt;app-column width="8"&gt; 
                                    &lt;h5&gt;{{movie.title}}&lt;/h5&gt; 
                                    &lt;p&gt;{{movie.year}}&lt;/p&gt; 
                                &lt;/app-column&gt; 
                                &lt;app-column width="4" style="text-align: right"&gt; 
                                    &lt;app-button kind="danger" (clicked)="focusDeleteDialog(movie.id)"&gt; 
                                        Delete 
                                    &lt;/app-button&gt; 
                                &lt;/app-column&gt; 
                            &lt;/app-row&gt; 
                        &lt;/app-list-group-item&gt; 
                    &lt;/app-list-group&gt; 
                &lt;/app-column&gt; 
            &lt;/app-row&gt; </pre>
<p>This component also renders a modal window that allows us to create a movie:</p>
<pre>            &lt;div *ngIf="editorValue"&gt; 
                &lt;app-modal 
                    [title]="'Movie Editor'" 
                    [acceptLabel]="'Save'" 
                    [cancelLabel]="'Cancel'" 
                    [error]="saveStatus" 
                    (onCancel)="focusOutEditor()" 
                    (onAccept)="saveMovie()" 
                &gt; 
                    &lt;form&gt; 
                        &lt;app-text-field 
                            [id]="'title'" 
                            [title]="'Title'" 
                            [placeholder]="'Title'" 
                            [errorMsg]="isValidTitle" 
                            (onChange)="edit($event)" 
                        &gt;&lt;/app-text-field&gt; 
                        &lt;app-text-field 
                            [id]="'year'" 
                            [title]="'Year'" 
                            [placeholder]="'Year'" 
                            [errorMsg]="isValidYear" 
                            (onChange)="edit($event)" 
                        &gt;&lt;/app-text-field&gt; 
                    &lt;/form&gt; 
                &lt;/app-modal&gt; 
            &lt;/div&gt; </pre>
<p class="mce-root">This component also renders a modal window that allows us to confirm that we wish to delete a movie from the database:</p>
<pre>            &lt;div *ngIf="deleteMovieId !== null"&gt; 
                &lt;app-modal 
                    [title]="'Delete?'" 
                    [acceptLabel]="'Delete'" 
                    [cancelLabel]="'Cancel'" 
                    [error]="deleteStatus" 
                    (onCancel)="focusOutDeleteDialog()" 
                    (onAccept)="deleteMovie()" 
                &gt; 
                    Are you sure? 
                &lt;/app-modal&gt; 
            &lt;/div&gt; 
        &lt;/app-container&gt; 
    ` 
}) </pre>
<p>The <kbd>MoviesPageComponent</kbd> is a smart component. As we can see in the following code snippet, it holds and manages the entire state required for all the dumb components used in its template:</p>
<pre>export class MoviesPageComponent implements OnInit { 
 
    // Contains the movies that have been already loaded from the server 
    public movies: MovieInterface[]; 
 
    // Used to represent the status of the HTTP GET calls 
    public isLoaded!: boolean; 
 
    // Display error if loading fails 
    public fetchErrorMsg: null | string; 
 
    // Used to represent the status of the HTTP DELETE call 
    public deleteStatus: null | string; 
 
    // Used to represent the status of the HTTP POST and HTTP PUT calls 
    public saveStatus: null | string; 
 
    // Used to display the confirmation dialog before deleting a movie 
    // null hides the modal and number displays the modal 
    public deleteMovieId: null | number; 
 
    // Used to hold the values of the movie editor or null when nothing is being edited 
    public editorValue: null | Partial&lt;MovieInterface&gt;; 
    public isValidTitle!: null | string; 
    public isValidYear!: null | string; 
 
    public movieService!: interfaces.MovieService; </pre>
<p>The <kbd>MovieService</kbd> is injected into the component. We can ignore the details about this for now because it will be explained in the following section:</p>
<pre>    public constructor( 
        @Inject(MOVIE_SERVICE) movieService: interfaces.MovieService 
    ) { 
        this.movieService = movieService; 
        this.movies = []; 
        this.fetchErrorMsg = null; 
        this.isLoaded = false; 
        this.deleteStatus = null; 
        this.saveStatus = null; 
        this.deleteMovieId = null; 
        this.editorValue = null; 
        this.isValidTitle = null; 
        this.isValidYear = null; 
    } </pre>
<p>WeÂ thenÂ use the <kbd>ngOnInit</kbd> event hook to trigger the initial data fetching:</p>
<pre>    public async ngOnInit() { 
        this.isLoaded = false; 
        try { 
            this.movies = await this.movieService.getAll(); 
            this.isLoaded = true; 
            this.fetchErrorMsg = null; 
        } catch (err) { 
            this.isLoaded = true; 
            this.fetchErrorMsg = "Loading failed!"; 
        } 
    } </pre>
<p>After declaring the properties, the constructor, and the <kbd>ngOnInit</kbd> event of the component, we are going to declare some methods. As you can see in the following code snippet, these methods are used to mutate the state of the application:</p>
<pre>    public focusEditor() { 
        this.editorValue = {}; 
    } 
 
    public focusOutEditor() { 
        this.editorValue = null; 
    } 
 
    public focusDeleteDialog(id: number) { 
        this.deleteMovieId = id; 
    } 
 
    public focusOutDeleteDialog() { 
        this.deleteMovieId = null; 
    } 
    public edit(keyVal: any) { 
        const movie = { 
            ...(this.editorValue || {}), 
            ...{[keyVal.k]: keyVal.v} 
  }; 
        if (movie.title) { 
            this.isValidTitle = (movie.title &amp;&amp; movie.title.length) &gt; 0 ? null : "Title cannot be empty!"; 
        } 
        if (movie.year) { 
            this.isValidYear = isNaN(movie.year) === false ? null : "Year must be a number!"; 
        } 
        this.editorValue = movie; 
    } </pre>
<p>In the preceding chapter, we learned the basics about the MobX architecture. There are some significant differences between the MobX architecture and the Angular architecture:</p>
<ul>
<li>In MobX, the application state belongs to the <kbd>Store</kbd>. The smart component talks to the <kbd>Store</kbd> via actions. The <kbd>Store</kbd> is the entity that ultimately mutates the state, not the smart component.</li>
<li>In Angular, the application state belongs to the smart component, which is the entity that ultimately mutates the state.</li>
</ul>
<p>In Angular, we used a service to perform the Ajax calls; on the other hand, in MobX, we performed the Ajax calls inside the <kbd>Store</kbd>. This is a minor difference because we can create a service in MobX to perform the Ajax calls. The <kbd>Store</kbd> could then talk to the service. The key takeaway here is the difference in state management.</p>
<p>The following methods use the <kbd>MovieService</kbd> to perform some Ajax calls and to mutate the state of the <kbd>MovieComponent</kbd>:</p>
<pre>    public async saveMovie() { 
        if (isValidNewMovie(this.editorValue)) { 
            const newMovie = await this.movieService.create(this.editorValue as any); 
            this.movies.push(newMovie); 
            this.saveStatus = null; 
            this.editorValue = null; 
        } else { 
            this.saveStatus = "Invalid movie!"; 
        } 
    } 
 
    public async deleteMovie() { 
        try { 
            if (this.deleteMovieId) { 
                await this.movieService.delete(this.deleteMovieId); 
                this.movies = this.movies.filter((m) =&gt; m.id !== this.deleteMovieId); 
                this.deleteStatus = null; 
                this.deleteMovieId = null; 
            } 
        } catch (err) { 
            this.deleteStatus = "Cannot delete movie!"; 
        } 
    } 
 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Dependency injection in Angular</h1>
                
            
            
                
<p>Dependency injection in Angular requires us to define some unique identifiers using the <kbd>InjectionToken</kbd> class. Injection tokens are unique identifiers used to represent a type at runtime. The concept of <kbd>InjectionToken</kbd> in Angular is very similar to the concept of symbols in InversifyJS:</p>
<pre>import { InjectionToken } from "@angular/core"; 
import { MovieService, ActorService } from "../interfaces"; 
 
export const ACTOR_SERVICE = new InjectionToken&lt;MovieService&gt;("ActorService"); 
export const MOVIE_SERVICE = new InjectionToken&lt;MovieService&gt;("MovieService"); </pre>
<p>After creating an <kbd>InjectionToken</kbd>, we must decorate the class that we wish to inject with the <kbd>@injectable</kbd> decorator, as demonstrated by the following code snippet:</p>
<pre>import { InjectionToken } from "@angular/core"; 
// ... 
@Injectable() 
export class MovieService implements interfaces.MovieService { 
    // ... </pre>
<p>We also must declare a binding between the <kbd>InjectionToken</kbd> and an implementation of the type that it represents. This can be achieved using the <kbd>providers</kbd> setting when we declare an <kbd>NgModule</kbd> as follows:</p>
<pre>import { NgModule } from "@angular/core"; 
import { CommonModule } from "@angular/common"; 
import { MoviesPageComponent } from "./moviespage.component"; 
import { ComponentsModule } from "../components/components.module"; 
import { MovieService } from "../services/movie_service"; 
import { MOVIE_SERVICE } from "../config/types"; 
 
@NgModule({ 
    declarations: [ 
        MoviesPageComponent 
    ], 
    exports: [ 
        MoviesPageComponent 
    ], 
    imports: [CommonModule, ComponentsModule], 
    providers: [ 
        { provide: MOVIE_SERVICE, useClass: MovieService } 
    ] 
}) 
export class MoviesPageModule { 
} </pre>
<p>The preceding code snippet binds the <kbd>InjectionToken MOVIE_SERVICE</kbd> to the implementation <kbd>MovieService</kbd>. Finally, we can use the <kbd>@Inject</kbd> decorator to declare a dependency in one of our Angular components:</p>
<pre>import { Component, Inject } from "@angular/core"; 
// ... 
public constructor( 
        @Inject(MOVIE_SERVICE) movieService: interfaces.MovieService 
    ) { 
        this.movieService = movieService; 
        // ... 
    } </pre>
<p>Please refer to the documentation at <a href="https://angular.io/guide/dependency-injection">https://angular.io/guide/dependency-injection</a> to learn more about dependency injection in Angular.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have learned the basic principles of component-based web development and how to use Angular. We learned how to bootstrap an Angular application, how to implement routing, and how to create components.</p>
<p>We also learned how to implement dumb and smart components as well as how to work with services and implement dependency injection.</p>
<p>In the next chapter, we are going to learn about application performance.</p>


            

            
        
    </div>



  </body></html>