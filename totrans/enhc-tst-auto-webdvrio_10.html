<html><head></head><body>
		<div><h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor200"/>10</h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor201"/>Increased Flexibility – Writing Robust Selectors and Reducing Maintenance</h1>
			<p>Maintenance is the ever-growing villain of a test automation project. Each release has more tests and more elements that can go stale, causing a test to fail. If you are new to the test automation field, you may not realize just how much maintenance will increasingly impact your project release after release. I (Paul) would like to share with you this story that inspired several unique solutions.</p>
			<p>Several years ago, my client’s development team decided to change the entire underlying architecture supporting the application under test. My automation team only became aware of this change when we found nearly all 100 of our test cases suite failed to reach a passing state. In fact, the only test case that passed was the <code>LogIn</code> test we wrote on the first day of the project. We realized that hundreds of element objects had changed their tag name to different types and used different properties. We were faced with the daunting task of rewriting hundreds of element selectors one by one. We estimated the rework of the page objects might take 2 days to be returned to a working state.</p>
			<p>Add to this that the client had been used to receiving a detailed summary of the regression test suite results in under 2 hours, along with our smoke tests detecting issues within 15 minutes. We were faced with the task of explaining that release results would not be available for another 2 days or more. The manual team of six resources would likely complete their testing in that amount of time.</p>
			<p>My coworker set about the task of updating selectors in the page object tags. I had a different idea. From my analysis, I realized that just one element tag had changed. Many of the <code>&lt;a&gt;</code> link anchors were now <code>&lt;button&gt;</code> tags. Luckily, none of the strings used to locate elements had changed, they were just in different object properties. I proposed adding a thin layer to our framework that would search for alternate tag elements to the one that was no longer found.</p>
			<p>The code change was completed in under an hour. The number of test cases that were executed increased to 95% completion. Two test cases failed the release, and another three needed to be maintained by hand to get to a working state. This was in line with the maintenance work on the previous release iterations. Our client understood the challenge the architectural change presented, and she was overjoyed we could provide actionable results within 4 hours.</p>
			<p>On similar lines, we will cover the following main topics in this chapter:</p>
			<ul>
				<li>Reducing page object maintenance with generic selectors</li>
				<li>Anatomy of an XPath selector</li>
				<li>Leveraging <code>data-qa</code> and <strong class="bold">Accessible Rich Internet Applications</strong> (<strong class="bold">ARIA</strong>) attributes</li>
				<li>Writing an XPath element that contains a textual substring</li>
				<li>Second chances – getting valid objects from stale selector</li>
			</ul>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor202"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub repository: <a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</a></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor203"/>Reducing page object maintenance with generic selectors</h1>
			<p>Before <a id="_idIndexMarker398"/>we get into the advanced<a id="_idIndexMarker399"/> concepts of making our object flexible like plastic, let’s begin with several ways we can write better selectors. A robust selector is extremely important to reduce the maintenance of your test automation framework. We will move beyond exact matches to use substring matches to be sure that we can find an element even if it changes slightly.</p>
			<p>We <a id="_idIndexMarker400"/>begin with a simple <a id="_idIndexMarker401"/>question. Which is better—XPath or CSS? There is a common idea that CSS is the preferred method for writing a selector because it executes faster. While this may be true, the speed difference today is minimal. I would rather spend a few more milliseconds finding an element over the minutes spent repeatedly updating object selectors. In addition, CSS selectors are harder to write syntactically. Furthermore, CSS selectors are not as flexible when we need to find one element relative to another—for example, locating one of many generic <code>label</code> object:</p>
			<div><div><img src="img/B19395_10_1.jpg" alt="Figure 10.1 – A generic radio button relative to a Label element named “One” on the DOM"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – A generic radio button relative to a Label element named “One” on the DOM</p>
			<p>In the <a id="_idIndexMarker402"/>preceding example, there<a id="_idIndexMarker403"/> is no way to uniquely identify any of the radio buttons by their text. This is because the uniquely identifiable text is contained in a <code>Label</code> element relative to the <strong class="bold">Span </strong><strong class="bold">radio</strong> button.</p>
			<p>We must leverage the XPath axis of a parent and child element to uniquely locate these elements by relative location. We write a selector to the parent object that has the text <code>One</code>:</p>
			<pre class="source-code">
//label[text()='One']</pre>			<p>We then follow it with the generic child radio button:</p>
			<pre class="source-code">
span[@class='radiobtn']</pre>			<p>We then combine them:</p>
			<pre class="source-code">
//label[text()='One']/span[@class='radiobtn']</pre>			<p>That was an easy riddle to solve. But what if we have text that has extra spaces, forced carriage returns, or even a mix of quotes and single quotes, as in the following example? To solve issues such as this, we will take a deeper dive into more ways that we can locate and identify elements:</p>
			<div><div><img src="img/B19395_10_2.jpg" alt="Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage returns"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage returns</p>
			<p>Thus far, we<a id="_idIndexMarker404"/> have seen examples of <a id="_idIndexMarker405"/>XPath and CSS selectors. Let us take a moment to further explore the components to retrieve collections of elements in WebdriverIO.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor204"/>Anatomy of an XPath selector</h1>
			<p>Selectors<a id="_idIndexMarker406"/> are comprised of one or more node tag types followed by an optional <code>[predicate]</code> in square brackets. The predicates have operators and functions to filter certain node matches. Lastly, they include path separators with generic <em class="italic">axes</em> with double colons to further refine the path of the element. This makes it more likely to find an element regardless of its location in the DOM.</p>
			<p>XPath selectors<a id="_idIndexMarker407"/> are written as <em class="italic">absolute</em> or <em class="italic">relative</em>. This is an example of an absolute-style selector to the <strong class="bold">Find My Candy</strong> button on the <em class="italic">Candymapper</em> website:</p>
			<pre class="source-code">
public get myElement() {
  const selector: string = "/html[1]/body[1]/div[1]/div[1]/div[1]/div[13]/div[1]/div[1]/div[1]/div[2]/div[2]/a[1]";
  return $(selector);
}</pre>			<p>Now that you have seen an absolute selector, use it only as a red flag. The point of this exercise is the fluid nature of the numeric indexes inside the square brackets. The exact location will be dynamic from release to release, causing endless maintenance. If you see a lot of selectors with this format in your code base, it is all but certain your selector is not robust. Furthermore, it is a devilish riddle for another developer to figure out the intended element since the text “Find My Candy” does not appear in the selector string.  Let’s look for better ways to write selectors.</p>
			<p class="callout-heading">Rule of thumb</p>
			<p class="callout">Always take extra time to replace an absolute selector with a relative selector and use a descriptive element name. The <code>myElement</code> name in the preceding example is of no help and should be renamed <code>findMyCandy</code> or, better still, <code>btnFindMyCandy</code>.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor205"/>Relative selectors</h2>
			<p>Most<a id="_idIndexMarker408"/> relative selectors begin with a double slash (<code>//</code>) followed by a single slash indicating the next element in the path. Let’s look at this in a bit more detail:</p>
			<ul>
				<li><code>//</code> <code>//div</code> selects all <code>&lt;div&gt;</code> elements anywhere in the document.</p></li>
				<li><code>/</code> <code>/html/body/div</code> selects all <code>&lt;div&gt;</code> elements that are direct children of the <code>&lt;body&gt;</code> element inside the <code>&lt;</code><code>html&gt;</code> root.</p></li>
				<li><code>*</code> <strong class="bold">(star)</strong>: Denotes a wildcard match.</li>
			</ul>
			<p>To start, we will get a collection of all the elements on the page using the <code>*</code> wildcard matcher for all node types:</p>
			<pre class="console">
const allElementsByXPath: ElementArrayType = await browser.$$('//*');</pre>			<h2 id="_idParaDest-155"><a id="_idTextAnchor206"/>Node test functions – text() versus normalize-space()</h2>
			<p>Several <a id="_idIndexMarker409"/>of the element selector tags shown here, including anchors, buttons, and lists, can be matched with exact text using the <code>text()</code> Node test function:</p>
			<pre class="console">
//a[text()=`FIND MY CANDY!`]</pre>			<p>This is an easy sample, but what if there were some strange formatting embedded in the text?</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor207"/>Broken strings</h2>
			<p>There can <a id="_idIndexMarker410"/>be times when extraneous spaces or carriage returns make a selector match challenging. In such cases, it is recommended to use <code>normalize-space()</code> instead of <code>text()</code>:</p>
			<pre class="console">
//a[normalize-space()=`FIND MY CANDY!`]</pre>			<p>We can check if this selector is valid with the <code>SelectorsHub</code> Chrome extension:</p>
			<div><div><img src="img/B19395_10_3.jpg" alt="Figure 10.3 – SelectorsHub indicates more than one element will match the selector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – SelectorsHub indicates more than one element will match the selector</p>
			<p>The XPath selector is valid, but it matches four additional elements on the screen. Another way is to get the button element relative to the container page:</p>
			<pre class="console">
//*[contains(@class,"popup")]//following::a</pre>			<p>This element can be located with the parent class and converted to a CSS selector with a period (<code>.</code>) as a shortcut for a class name:</p>
			<pre class="console">
.widget-popup a</pre>			<p>Similarly, we can perform a close match with a <code>popup</code> on the class name to find an anchor link child using the CSS containing a <code>*=</code> shortcut in this way:</p>
			<pre class="console">
[class*="popup"] a</pre>			<p>We can also narrow down the parent element to a specific tag type:</p>
			<pre class="console">
div[class*="popup"] a</pre>			<p>There are five common web page elements we will seek: links, buttons, lists, fields, and text elements.</p>
			<p>Here are common ways to find these elements with an exact string as well as a substring match in XPath:</p>
			<ul>
				<li>Links:<pre class="source-code">
//a[normalize-space()='Link Text']
//a[contains(normalize-space(),'Link')]
//a[@href='https://example.com']</pre></li>				<li>Buttons:<pre class="source-code">
//button[normalize-space()='Click Me']
//button[contains(normalize-space(),'Click')]
//button[@id='submit-button']</pre></li>				<li>Lists (unordered and ordered):<pre class="source-code">
//ul/li[normalize-space()='Item']
//ul/li[contains(normalize-space(),'Item')]
//ol/li[position()=2]  // Not recommended</pre></li>				<li>Fields and <a id="_idIndexMarker411"/>multiline text areas:<pre class="source-code">
//input[@type='text']
//input[contains(@id,'input')]
//textarea[@placeholder='Enter text']</pre></li>				<li>Text:<pre class="source-code">
//span[normalize-space() ='Some Text']
//span[contains(normalize-space(),'Text')]
//*[starts-with(normalize-space(),'Hello')]</pre></li>			</ul>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor208"/>Leveraging data-qa and ARIA attributes</h1>
			<p>There <a id="_idIndexMarker412"/>have been two new<a id="_idIndexMarker413"/> developments in website design where developers can help SDETs maintain robust low-maintenance selectors. Consider this web page element snippet:</p>
			<pre class="source-code">
&lt;div data-qa="product-card" role="article" aria-label="Product Details"&gt;
      &lt;a href="#" data-qa="add-to-cart"&gt;Add to Cart &lt;/a&gt; &lt;/div&gt;</pre>			<p>This <a id="_idIndexMarker414"/>can be accomplished by adding the <code>data-qa</code> attribute, which is<a id="_idIndexMarker415"/> unique and static. Alternately, if the developer team follows the ARIA standard, many text elements can be identified by the <code>aria-label</code> attribute:</p>
			<pre class="source-code">
//div[contains(@aria-label, 'Product Details')]
//a[contains(@data-qa, 'Add to Cart')]</pre>			<p>Here is an example leveraging <code>data-qa</code> and ARIA attributes to ensure that your web application’s elements are accessible and interactable:</p>
			<pre class="source-code">
describe("Accessibility Testing", function () {
  // Simulate loading a web page or application
  beforeAll(function () {
    // Load your web page or application
  });
 it("should have proper ARIA attributes", function () {
    // Find an element by its data-qa attribute
    const buttonWithQA = element(by.css('[data-qa="login-button"]'));
   // Verify that the ARIA role is set to "button"
    expect(buttonWithQA.getAttribute('role')).toEqual('button');
   // You can also check other ARIA attributes like "aria-label", "aria-describedby", etc.
    // Example: expect(buttonWithQA.getAttribute('aria-label')).toBe('Login Button');
  });
 it("should be keyboard accessible", function () {
    // Find an element by its ARIA label
    const buttonWithARIA = element(by.css('[aria-label="Login Button"]'));
   // Trigger a click event using Protractor
    buttonWithARIA.click();
   // Verify that the element is focused after the click
    expect(browser.driver.switchTo().activeElement().getAttribute('aria-label')).toEqual('Login Button');
  });
});</pre>			<p>In the example, we<a id="_idIndexMarker416"/> have two test cases. The first one verifies that an <a id="_idIndexMarker417"/>element with a <code>data-qa</code> attribute has the correct ARIA role. The second test case checks the keyboard accessibility of an element with a specific ARIA label. This is just a basic example, and you can adapt it to your specific application’s needs to ensure that your elements are properly accessible and have the right attributes.</p>
			<p class="callout-heading">Rule of thumb – alternatives to CSS selectors</p>
			<p class="callout">Unfortunately, CSS selectors do not provide a direct way to filter elements based on their text content, like the <code>text()</code> and <code>normalize-space()</code> functions in XPath.</p>
			<p>So, while CSS<a id="_idIndexMarker418"/> selectors are hailed as being faster, they can be limited in <a id="_idIndexMarker419"/>functionality in test automation. The next example utilizes CSS to quickly gather all elements on the page:</p>
			<pre class="console">
const allElementsByCss: ElementArrayType = await browser.$$('*');</pre>			<p>For fetching particular types of elements, a combination of XPath and CSS can be employed. Here are some supplementary element selector types:</p>
			<ul>
				<li>Text:<pre class="source-code">
//span[text()='Vital Signs']</pre></li>				<li>Links:<pre class="source-code">
a[href='https://example.com']
//a[@href='https://example.com']</pre></li>				<li>Buttons:<pre class="source-code">
button#submit-button
//button[text()='Login']</pre></li>				<li>Lists:<pre class="source-code">
ol li:nth-child(2)</pre></li>				<li>Fields:<pre class="source-code">
input[type='text']
input[id*='input']
textarea[placeholder='Enter text']</pre></li>			</ul>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor209"/>Finding an element only by text</h2>
			<p>Elements can be <a id="_idIndexMarker420"/>found with an XPath selector with an exact matching string. For example, a <strong class="bold">Next</strong> button with an exact match would be formatted as such:</p>
			<pre class="console">
//a[text()='Next &gt;']</pre>			<p>However, while the text is likely to remain constant, the angle bracket and spacing could change. We can reduce our chance of future maintenance with a selector that has a substring.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor210"/>Writing an XPath element that contains a textual substring</h1>
			<p>By adding <code>contains()</code> to the<a id="_idIndexMarker421"/> selector, the object can be found with just a small part of the text:</p>
			<pre class="console">
//a[contains(text(),'Next']</pre>			<p>This works for many elements, but checkboxes and radio buttons are tricky.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor211"/>Finding an element relative to another element</h2>
			<p>In this next <a id="_idIndexMarker422"/>example, we want to click the checkbox next to the name <em class="italic">John Smith</em>. We have several checkboxes but none has a unique identifier by name:</p>
			<div><div><img src="img/B19395_10_4.jpg" alt="Figure 10.4 – The name John Smith and its associated checkbox are two separate elements"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The name John Smith and its associated checkbox are two separate elements</p>
			<p>This selector will identify all the checkboxes:</p>
			<pre class="source-code">
//input[contains(@name,'chkSelect')]</pre>			<p>To locate this <a id="_idIndexMarker423"/>checkbox element, we need to use the link and find the input checkbox preceding it. Here’s how we can do that:</p>
			<pre class="source-code">
//a[normalize-space()='John.Smith']//preceding::input[@id='ohrmList_chkSelectRecord_2']</pre>			<h2 id="_idParaDest-161"><a id="_idTextAnchor212"/>Case-insensitive partial matches</h2>
			<p>What if we learn a developer <a id="_idIndexMarker424"/>sometimes changes the case of the text? A solution to that is to add a <code>translate</code> option and convert the text to match either upper- or lowercase:</p>
			<pre class="source-code">
//a[translate(normalize-space(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')='john.smith']//preceding::input[@id='ohrmList_chkSelectRecord_2']</pre>			<p>The problem now is that the element the selector returns is not always visible. Here is how we handle that.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor213"/>Finding only visible elements</h2>
			<p>One of the biggest challenges in<a id="_idIndexMarker425"/> test automation is to return a collection of visible elements. This reminds us of a very famous quote delivered by Michael Keaton: “<em class="italic">Want to get nuts? Let’s </em><em class="italic">get nuts!</em>”</p>
			<p>This extensive selector is provided as one example. It will eliminate most objects that are not visible in multiple ways. We addressed the opacity being <code>0</code>, the overflow or visibility being hidden, the display being <code>none</code>, and the width or height being set to <code>0</code>:</p>
			<pre class="source-code">
(//a | //input | //select | //textarea)[
not (
contains(@style,'opacity: 0;') or contains(@style,'visibility: hidden;') or contains(@style,'display: none;') or contains(@style,'overflow: hidden;') or contains(@style,'width: 0') or
contains(@style,'height: 0')) and
not(ancestor::*[contains(@style,'opacity: 0;') or
contains(@style,'visibility: hidden;') or
contains(@style,'display: none;') or
contains(@style,'overflow: hidden;') or
contains(@style,'width: 0') or
contains(@style,'height: 0')])]</pre>			<p>This selector also eliminates any elements that have an ancestor that is hidden. Here is another place where the 80/20 rule applies. Even if this selector only eliminates about 80% of non-visible elements, we will still need to parse through a collection of elements to find the first one that is visible. So, why not let XPath or CSS handle more than half of the work <a id="_idIndexMarker426"/>getting our visible elements?</p>
			<p>The reason we want to do this is to give our methods a second chance at trying to find an element if it has been changed from its class. It’s never too late for a second or third chance to find an element.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor214"/>Second chances – getting valid objects from stale selectors</h1>
			<p>Now that we have our<a id="_idIndexMarker427"/> four primary method wrappers, let us<a id="_idIndexMarker428"/> make them more robust with self-healing code. The biggest drawback in automation is the maintenance to fix elements in the <strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) when <a id="_idIndexMarker429"/>selectors become stale. In this section, we look at self-healing techniques to find elements that have changed their node type.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor215"/>Self healing techniques</h2>
			<p>Let's go over some self-healing techniques in this sub-section.</p>
			<h3>Reducing code for case-insensitive matches</h3>
			<p>All<a id="_idIndexMarker430"/> these functions will require a conversion to case-insensitive matches. We start by creating two constants to reduce the repeated use of the upper- and lowercase alphabet:</p>
			<pre class="source-code">
const A_Z = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const a_z = 'abcdefghijklmnopqrstuvwxyz';</pre>			<p>Next, we will need a function that will extract unique text from a stale locator.</p>
			<h3>Extracting selector text</h3>
			<p>This <a id="_idIndexMarker431"/>function will try to return the first match of any unique text encased in double or single quotes. This will be injected into a close match locator:</p>
			<pre class="source-code">
function extractSelectorText(selector: string): string {
const singleQuoteCount = (selector.match(/'/g) || []).length;
  let newSelector = selector;</pre>			<p>First, we check for a single quote, such as a possessive apostrophe, embedded in the selector string. For example, <code>"Moe's Bar"</code> would result in an odd number of single quotes:</p>
			<pre class="source-code">
if (singleQuoteCount === 1 || singleQuoteCount === 3){
  const parts = selector.split("'");
  if (singleQuoteCount === 1) {</pre>			<p>Handle cases where there is one single quote by surrounding it with a <code>concat</code> function:</p>
			<pre class="source-code">
      newSelector = `concat('${parts[0]}', "'", '${parts[1]}')`;</pre>			<p>This converts <code>"Moe's bar"</code> to <code>"concat("Moe","'","'s bar")</code> to support a single-quote match.</p>
			<pre class="source-code">
    } else if (singleQuoteCount === 3) {</pre>			<p>In any other language, it would be impossible to have a locator with both a single quote and a quoted string in a single locator. But because JavaScript allows literal strings with backticks, there could be a string like this:</p>
			<pre class="source-code">
 `//*[text()=Meet Dwayne "The Rock" Johnson at Moe's Bar]`</pre>			<p>So, we handle the case where there are three single quotes and only the second single quote should be escaped like this:</p>
			<pre class="source-code">
      newSelector = `concat('${parts[0]}${parts[1]}', "'", '${parts[2]}')`;
    }
  }</pre>			<p>This extracts as the following:</p>
			<pre class="source-code">
`concat(Meet Dwayne "The Rock" Johnson at Moe","'"'s Bar"`</pre>			<p>Extract <a id="_idIndexMarker432"/>text between two double or single quotes as follows:</p>
			<pre class="source-code">
  let match = newSelector.match(/"([^"]+)"$/) || newSelector.match(/'([^']+)'$/);</pre>			<p>If no match is found, or the matched group is not valid, return the original selector. In fact, the locator string passed is likely not robust enough to be given a second chance. We return a string clearly identifying the issue, as returning a <code>Null</code> value would throw an error, and an empty string likely would match all elements:</p>
			<pre class="source-code">
  if (!match || match.length &lt; 2) {
    return "NO TEXT FOUND IN LOCATOR";
  }</pre>			<p>Otherwise, we <a id="_idIndexMarker433"/>return the captured group between single or double quotes modified if a single quote is detected:</p>
			<pre class="source-code">
return match[1];
}</pre>			<p>Now that we have extracted the text of a locator, we can inject it into a similar one for each class of elements.</p>
			<h3>From links to buttons</h3>
			<p>On the <a id="_idIndexMarker434"/>main page of the <em class="italic">Candymapper</em> sandbox website, there is exactly one <code>&lt;Button&gt;</code> element. It is the <code>&lt;A&gt;</code> anchor link like the other ones on the page. and it was in all caps. I’ve since fixed that, but do I need to spend time fixing the locator in my code?</p>
			<div><div><img src="img/B19395_10_5.jpg" alt="Figure 10.5 –The Send button element on the Candymapper website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 –The Send button element on the Candymapper website</p>
			<p>This was the original locator that used to work:</p>
			<pre class="source-code">
//a[text()='SEND']</pre>			<p>What if we could pull the text and inject it into a button class like this?</p>
			<pre class="source-code">
//button[normalize-space()='SEND']</pre>			<p>If it still did not work, we made a third attempt to make a case-insensitive match:</p>
			<pre class="source-code">
//button[translate (normalize-space(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = 'send']</pre>			<p>Now, we have a solution that allows us to find our elements regardless of case sensitivity. We can now move on to optimizing this with a mutant merge power.</p>
			<h3>Finding an element by text alone</h3>
			<p>This can be <a id="_idIndexMarker435"/>wrapped together as a function in use by <code>getValidElement()</code> to give our buttons a second chance to be identified without refactoring the code:</p>
			<pre class="source-code">
function transformLink(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//button[contains(translate (normalize-space(),'${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<p>Now, the <strong class="bold">Send</strong> button can be reached even if it changes case and class:</p>
			<pre class="source-code">
public get sendLink () {
    return $(`//a[text()='Send']`);
}
await helpers.clickAdv(await this.sendLink)</pre>			<h3>Fields and lists</h3>
			<p>Fields could<a id="_idIndexMarker436"/> change from <code>&lt;input&gt;</code> to <code>&lt;textarea&gt;</code> objects. To find them, this change can be done with the <code>@</code><code>placeholder</code> property:</p>
			<pre class="source-code">
function transformField(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//textarea [contains (@placeholder, '${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<p>And of course, <code>&lt;select&gt;</code> objects might change to a <code>&lt;</code><code>input&gt;</code> combobox:</p>
			<pre class="source-code">
function transformList(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//input[contains (@placeholder, '${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<h3>Short substrings</h3>
			<p>One last<a id="_idIndexMarker437"/> trick before we leave this rabbit hole. Sometimes, small text changes can still be located accurately. <code>"Select all active files"</code> becomes <code>"Select all activated files"</code>. Divide the text into thirds. If the remaining length is greater than five characters, there is a good chance of matching on the middle string, <code>"all activ"</code>, as long as it is a unique match:</p>
			<pre class="source-code">
function getMiddle(s: string): string {
  const len = s.length;
  // Return the string as it is if its length is less than or equal to 5
  if (len &lt;= 5) {
    return s;
  }
  // Divide the string into three parts
  const oneThird = Math.floor(len / 3);
  const twoThirds = 2 * oneThird;
  // Extract the middle part
  return s.substring(oneThird, twoThirds);
}
console.log(getMiddle("Select all active files")); // Output: "all active fi"
console.log(getMiddle("small")); // Output: "small"</pre>			<p>Statistically, this will return a unique element about 40% of the time.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor216"/>On thin ice</h2>
			<p>Scrolling <a id="_idIndexMarker438"/>elements pose a particularly difficult challenge. Occasionally, they will end up partially outside of the view area of the browser. Let’s take a look at this example:</p>
			<div><div><img src="img/B19395_10_6.jpg" alt="Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser view area; center of a second text area object located off the bottom of the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser view area; center of a second text area object located off the bottom of the browser</p>
			<p>And what if your<a id="_idIndexMarker439"/> site supports side-scrolling element animation? If your framework activates a sliding menu and immediately tries to click an element inside, there are bound to be some strange results:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19395_10_7.jpg" alt="Figure 10.7 – Example of clicking the center of a sliding menu item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Example of clicking the center of a sliding menu item</p>
			<p>What makes it more frustrating is that should this issue occur, the screen capture at the end of the test will likely occur once the slider animation has been completed. The only clue you might get is a message indicating the element was not clickable at point 2050, 250 which is just beyond the right edge of a display with a 1920 x 1080 pixel resolution.</p>
			<p>The intrinsic WebdriverIO <code>.click()</code> method should never have an issue interacting with an offscreen element. The major reason the <code>clickAdv()</code> wrapper function scrolls the element into the browser view area is to have a better chance of having the element appear in a screen capture if an error occurs.</p>
			<p>Attempting to <a id="_idIndexMarker440"/>use a fancy JavaScript click can throw errors if the element is not in the viewport. It depends if the click is being executed at the top-left corner of the object or at its calculated center. Here is an example of a JavaScript click call using the <code>browser.execute</code> method to execute the <code>arguments[0].click();</code> code string:</p>
			<pre class="source-code">
async function jsClick(element: WebdriverIO.Element): Promise&lt;void&gt; {
await browser.execute("arguments[0].click();", element); }
// Usage example
  await jsClick('#some-button-id');</pre>			<p>There is another good reason this approach can cause issues. In GUI automation, we always want to emulate the user as much as possible. What happens if we have a modal popup displayed over the desired element, as seen here?</p>
			<p class="IMG---Figure">  </p>
			<div><div><img src="img/B19395_10_8.jpg" alt="Figure 10.8 – Calling jsclick() to force interaction with an element below a modal popup will be problematic"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Calling jsclick() to force interaction with an element below a modal popup will be problematic</p>
			<p>If the element we are <a id="_idIndexMarker441"/>seeking is sliding in on a control from off-screen, you often might get an error that the element click is out of bounds. It can occur if the element is an item in an expanding list that is still animating. Occasionally, an error can occur when the object has scrolled a few pixels out of the viewport. To counter this, we need to know if the element is moving when the error is thrown and when the movement has stopped. Here’s how we can do that:</p>
			<pre class="source-code">
async function scrollOneClickUp(): Promise&lt;void&gt; {
await browser.execute(() =&gt; { const event = new
WheelEvent("wheel", { deltaY: -50 });
document.dispatchEvent(event); });
}</pre>			<p>Scroll down one mouse wheel and click, like so:</p>
			<pre class="source-code">
async function scrollOneClickDown(): Promise&lt;void&gt; {
await browser.execute(() =&gt; { const event = new
WheelEvent("wheel", { deltaY: 50 });
document.dispatchEvent(event); });
}</pre>			<h3>Writing the isMoving() method</h3>
			<p>The days of clicking on an <a id="_idIndexMarker442"/>element by an <em class="italic">x</em> or <em class="italic">y</em> coordinate are long past us. It does not mean the coordinates of an element are of no value. Surprisingly, in some instances, a click is sometimes performed relative to an element’s screen location. With coordinates, we can determine if an element is in motion to ensure there is a higher degree of accuracy in our framework. Consider this line of code:</p>
			<pre class="source-code">
const currentLocation: WebdriverIO.LocationReturn = await element.getLocation();</pre>			<p>This will return an object with the current <em class="italic">x</em> and <em class="italic">y</em> screen coordinate location of the element. By looping through with a brief pause of a few milliseconds, we can implement a dynamic wait that<a id="_idIndexMarker443"/> ensures our object scroll animation has been completed:</p>
			<pre class="source-code">
export async function waitForElementToStopMoving(element: WebdriverIO.Element, timeout: number): Promise&lt;void&gt;
  const initialLocation = await element.getLocation();
  return new Promise((resolve, reject) =&gt; {
    let intervalId: NodeJS.Timeout;
    const checkMovement = () =&gt; {
      element.getLocation().then((currentLocation) =&gt; {
        if (
            currentLocation.x === initialLocation.x &amp;&amp;
            currentLocation.y === initialLocation.y
        ) {
          clearInterval(intervalId);
          resolve();
        }
      });
    };
    intervalId = setInterval(checkMovement, 100);
    setTimeout(() =&gt; {
      clearInterval(intervalId);
      reject(new Error(`Timeout: Element did not stop moving within ${timeout}ms`));
    }, timeout);
  });
}</pre>			<p>The best practice is to implement this just after any <code>browser.execute</code> scroll and before any similar click-based method.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor217"/>Summary</h1>
			<p>In this thrilling installment of our superhero coding saga, we’ve journeyed through the enigmatic world of element targeting, mastering the art of locating elusive HTML entities in the wilds of the web. Our quest led us to conquer the shifting shapes of <code>&lt;a&gt;</code> anchors, transforming them into mighty <code>&lt;button&gt;</code> sentinels, and evolving simple <code>&lt;input&gt;</code> fields into vast expanses of <code>&lt;textarea&gt;</code> elements. We’ve navigated the morphing mazes of dropdowns metamorphosing into comboboxes, deploying our powers to match text with a disregard for case, and even to seek out the hidden meanings within the midst of strings.</p>
			<p>Our toolkit expanded, and we’ve embraced the arcane arts of self-healing locators, weaving spells to mend themselves when the digital winds change. We stood firm as elements danced and darted across the screen, phasing in with animations that would baffle a lesser Tech Mage.</p>
			<p>As we stand at the precipice of discovery, we pose a question that defies the very reality of our craft: What if the need for a page object locator were but a mere illusion? What if, in the shadowy recesses of the UI, we could summon a <strong class="bold">Send</strong> button with nothing but a whisper to the framework? The answer beckons us—dare we leap into the unknown? The next chapter awaits, promising wonders beyond the limits of our imagination.</p>
		</div>
	</body></html>