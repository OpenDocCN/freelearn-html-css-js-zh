<html><head></head><body>
		<div id="_idContainer102">
			<h1 id="_idParaDest-149" class="chapter-number"><a id="_idTextAnchor200"/>10</h1>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor201"/>Increased Flexibility – Writing Robust Selectors and Reducing Maintenance</h1>
			<p>Maintenance is the ever-growing villain of a test automation project. Each release has more tests and more elements that can go stale, causing a test to fail. If you are new to the test automation field, you may not realize just how much maintenance will increasingly impact your project release after release. I (Paul) would like to share with you this story that inspired several <span class="No-Break">unique solutions.</span></p>
			<p>Several years ago, my client’s development team decided to change the entire underlying architecture supporting the application under test. My automation team only became aware of this change when we found nearly all 100 of our test cases suite failed to reach a passing state. In fact, the only test case that passed was the <strong class="source-inline">LogIn</strong> test we wrote on the first day of the project. We realized that hundreds of element objects had changed their tag name to different types and used different properties. We were faced with the daunting task of rewriting hundreds of element selectors one by one. We estimated the rework of the page objects might take 2 days to be returned to a <span class="No-Break">working state.</span></p>
			<p>Add to this that the client had been used to receiving a detailed summary of the regression test suite results in under 2 hours, along with our smoke tests detecting issues within 15 minutes. We were faced with the task of explaining that release results would not be available for another 2 days or more. The manual team of six resources would likely complete their testing in that amount <span class="No-Break">of time.</span></p>
			<p>My coworker set about the task of updating selectors in the page object tags. I had a different idea. From my analysis, I realized that just one element tag had changed. Many of the <strong class="source-inline">&lt;a&gt;</strong> link anchors were now <strong class="source-inline">&lt;button&gt;</strong> tags. Luckily, none of the strings used to locate elements had changed, they were just in different object properties. I proposed adding a thin layer to our framework that would search for alternate tag elements to the one that was no <span class="No-Break">longer found.</span></p>
			<p>The code change was completed in under an hour. The number of test cases that were executed increased to 95% completion. Two test cases failed the release, and another three needed to be maintained by hand to get to a working state. This was in line with the maintenance work on the previous release iterations. Our client understood the challenge the architectural change presented, and she was overjoyed we could provide actionable results within <span class="No-Break">4 hours.</span></p>
			<p>On similar lines, we will cover the following main topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Reducing page object maintenance with <span class="No-Break">generic selectors</span></li>
				<li>Anatomy of an <span class="No-Break">XPath selector</span></li>
				<li>Leveraging <strong class="source-inline">data-qa</strong> and <strong class="bold">Accessible Rich Internet Applications</strong> (<span class="No-Break"><strong class="bold">ARIA</strong></span><span class="No-Break">) attributes</span></li>
				<li>Writing an XPath element that contains a <span class="No-Break">textual substring</span></li>
				<li>Second chances – getting valid objects from <span class="No-Break">stale selector</span></li>
			</ul>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor202"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO"><span class="No-Break">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</span></a></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor203"/>Reducing page object maintenance with generic selectors</h1>
			<p>Before <a id="_idIndexMarker398"/>we get into the advanced<a id="_idIndexMarker399"/> concepts of making our object flexible like plastic, let’s begin with several ways we can write better selectors. A robust selector is extremely important to reduce the maintenance of your test automation framework. We will move beyond exact matches to use substring matches to be sure that we can find an element even if it <span class="No-Break">changes slightly.</span></p>
			<p>We <a id="_idIndexMarker400"/>begin with a simple <a id="_idIndexMarker401"/>question. Which is better—XPath or CSS? There is a common idea that CSS is the preferred method for writing a selector because it executes faster. While this may be true, the speed difference today is minimal. I would rather spend a few more milliseconds finding an element over the minutes spent repeatedly updating object selectors. In addition, CSS selectors are harder to write syntactically. Furthermore, CSS selectors are not as flexible when we need to find one element relative to another—for example, locating one of many generic <strong class="bold">Span</strong> or <strong class="bold">Input radio</strong> button objects relative to a unique <span class="No-Break"><strong class="source-inline">label</strong></span><span class="No-Break"> object:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B19395_10_1.jpg" alt="Figure 10.1 – A generic radio button relative to a Label element named “One” on the DOM"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – A generic radio button relative to a Label element named “One” on the DOM</p>
			<p>In the <a id="_idIndexMarker402"/>preceding example, there<a id="_idIndexMarker403"/> is no way to uniquely identify any of the radio buttons by their text. This is because the uniquely identifiable text is contained in a <strong class="source-inline">Label</strong> element relative to the <strong class="bold">Span </strong><span class="No-Break"><strong class="bold">radio</strong></span><span class="No-Break"> button.</span></p>
			<p>We must leverage the XPath axis of a parent and child element to uniquely locate these elements by relative location. We write a selector to the parent object that has the <span class="No-Break">text </span><span class="No-Break"><strong class="source-inline">One</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
//label[text()='One']</pre>			<p>We then follow it with the generic child <span class="No-Break">radio button:</span></p>
			<pre class="source-code">
span[@class='radiobtn']</pre>			<p>We then <span class="No-Break">combine them:</span></p>
			<pre class="source-code">
//label[text()='One']/span[@class='radiobtn']</pre>			<p>That was an easy riddle to solve. But what if we have text that has extra spaces, forced carriage returns, or even a mix of quotes and single quotes, as in the following example? To solve issues such as this, we will take a deeper dive into more ways that we can locate and <span class="No-Break">identify elements:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B19395_10_2.jpg" alt="Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage returns"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Extra spaces, mixed single and double quotes, and embedded carriage returns</p>
			<p>Thus far, we<a id="_idIndexMarker404"/> have seen examples of <a id="_idIndexMarker405"/>XPath and CSS selectors. Let us take a moment to further explore the components to retrieve collections of elements <span class="No-Break">in WebdriverIO.</span></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor204"/>Anatomy of an XPath selector</h1>
			<p>Selectors<a id="_idIndexMarker406"/> are comprised of one or more node tag types followed by an optional <strong class="source-inline">[predicate]</strong> in square brackets. The predicates have operators and functions to filter certain node matches. Lastly, they include path separators with generic <em class="italic">axes</em> with double colons to further refine the path of the element. This makes it more likely to find an element regardless of its location in <span class="No-Break">the DOM.</span></p>
			<p>XPath selectors<a id="_idIndexMarker407"/> are written as <em class="italic">absolute</em> or <em class="italic">relative</em>. This is an example of an absolute-style selector to the <strong class="bold">Find My Candy</strong> button on the <span class="No-Break"><em class="italic">Candymapper</em></span><span class="No-Break"> website:</span></p>
			<pre class="source-code">
public get myElement() {
  const selector: string = "/html[1]/body[1]/div[1]/div[1]/div[1]/div[13]/div[1]/div[1]/div[1]/div[2]/div[2]/a[1]";
  return $(selector);
}</pre>			<p>Now that you have seen an absolute selector, use it only as a red flag. The point of this exercise is the fluid nature of the numeric indexes inside the square brackets. The exact location will be dynamic from release to release, causing endless maintenance. If you see a lot of selectors with this format in your code base, it is all but certain your selector is not robust. Furthermore, it is a devilish riddle for another developer to figure out the intended element since the text “Find My Candy” does not appear in the selector string.  Let’s look for better ways to <span class="No-Break">write selectors.</span></p>
			<p class="callout-heading">Rule of thumb</p>
			<p class="callout">Always take extra time to replace an absolute selector with a relative selector and use a descriptive element name. The <strong class="source-inline">myElement</strong> name in the preceding example is of no help and should be renamed <strong class="source-inline">findMyCandy</strong> or, better <span class="No-Break">still, </span><span class="No-Break"><strong class="source-inline">btnFindMyCandy</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor205"/>Relative selectors</h2>
			<p>Most<a id="_idIndexMarker408"/> relative selectors begin with a double slash (<strong class="source-inline">//</strong>) followed by a single slash indicating the next element in the path. Let’s look at this in a bit <span class="No-Break">more detail:</span></p>
			<ul>
				<li><strong class="source-inline">//</strong> <strong class="bold">(double slash)</strong>: Denotes any descendant relationship between elements. When you use a double slash between elements in an XPath expression, it selects all descendants of the preceding element, regardless of their depth in <span class="No-Break">the hierarchy.</span><p class="list-inset"><em class="italic">Example</em>: <strong class="source-inline">//div</strong> selects all <strong class="source-inline">&lt;div&gt;</strong> elements anywhere in <span class="No-Break">the document.</span></p></li>
				<li><strong class="source-inline">/</strong> <strong class="bold">(single slash)</strong>: Denotes the direct child relationship between elements. When you use a single slash between elements in an XPath expression, it selects the child elements of the <span class="No-Break">preceding element.</span><p class="list-inset"><em class="italic">Example</em>: <strong class="source-inline">/html/body/div</strong> selects all <strong class="source-inline">&lt;div&gt;</strong> elements that are direct children of the <strong class="source-inline">&lt;body&gt;</strong> element inside the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">html&gt;</strong></span><span class="No-Break"> root.</span></p></li>
				<li><strong class="source-inline">*</strong> <strong class="bold">(star)</strong>: Denotes a <span class="No-Break">wildcard match.</span></li>
			</ul>
			<p>To start, we will get a collection of all the elements on the page using the <strong class="source-inline">*</strong> wildcard matcher for all <span class="No-Break">node types:</span></p>
			<pre class="console">
const allElementsByXPath: ElementArrayType = await browser.$$('//*');</pre>			<h2 id="_idParaDest-155"><a id="_idTextAnchor206"/>Node test functions – text() versus normalize-space()</h2>
			<p>Several <a id="_idIndexMarker409"/>of the element selector tags shown here, including anchors, buttons, and lists, can be matched with exact text using the <strong class="source-inline">text()</strong> Node <span class="No-Break">test function:</span></p>
			<pre class="console">
//a[text()=`FIND MY CANDY!`]</pre>			<p>This is an easy sample, but what if there were some strange formatting embedded in <span class="No-Break">the text?</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor207"/>Broken strings</h2>
			<p>There can <a id="_idIndexMarker410"/>be times when extraneous spaces or carriage returns make a selector match challenging. In such cases, it is recommended to use <strong class="source-inline">normalize-space()</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">text()</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
//a[normalize-space()=`FIND MY CANDY!`]</pre>			<p>We can check if this selector is valid with the <strong class="source-inline">SelectorsHub</strong> <span class="No-Break">Chrome extension:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B19395_10_3.jpg" alt="Figure 10.3 – SelectorsHub indicates more than one element will match the selector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – SelectorsHub indicates more than one element will match the selector</p>
			<p>The XPath selector is valid, but it matches four additional elements on the screen. Another way is to get the button element relative to the <span class="No-Break">container page:</span></p>
			<pre class="console">
//*[contains(@class,"popup")]//following::a</pre>			<p>This element can be located with the parent class and converted to a CSS selector with a period (<strong class="source-inline">.</strong>) as a shortcut for a <span class="No-Break">class name:</span></p>
			<pre class="console">
.widget-popup a</pre>			<p>Similarly, we can perform a close match with a <strong class="source-inline">popup</strong> on the class name to find an anchor link child using the CSS containing a <strong class="source-inline">*=</strong> shortcut in <span class="No-Break">this way:</span></p>
			<pre class="console">
[class*="popup"] a</pre>			<p>We can also narrow down the parent element to a specific <span class="No-Break">tag type:</span></p>
			<pre class="console">
div[class*="popup"] a</pre>			<p>There are five common web page elements we will seek: links, buttons, lists, fields, and <span class="No-Break">text elements.</span></p>
			<p>Here are common ways to find these elements with an exact string as well as a substring match <span class="No-Break">in XPath:</span></p>
			<ul>
				<li><span class="No-Break">Links:</span><pre class="source-code">
//a[normalize-space()='Link Text']
//a[contains(normalize-space(),'Link')]
//a[@href='https://example.com']</pre></li>				<li><span class="No-Break">Buttons:</span><pre class="source-code">
//button[normalize-space()='Click Me']
//button[contains(normalize-space(),'Click')]
//button[@id='submit-button']</pre></li>				<li>Lists (unordered <span class="No-Break">and ordered):</span><pre class="source-code">
//ul/li[normalize-space()='Item']
//ul/li[contains(normalize-space(),'Item')]
//ol/li[position()=2]  // Not recommended</pre></li>				<li>Fields and <a id="_idIndexMarker411"/>multiline <span class="No-Break">text areas:</span><pre class="source-code">
//input[@type='text']
//input[contains(@id,'input')]
//textarea[@placeholder='Enter text']</pre></li>				<li><span class="No-Break">Text:</span><pre class="source-code">
//span[normalize-space() ='Some Text']
//span[contains(normalize-space(),'Text')]
//*[starts-with(normalize-space(),'Hello')]</pre></li>			</ul>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor208"/>Leveraging data-qa and ARIA attributes</h1>
			<p>There <a id="_idIndexMarker412"/>have been two new<a id="_idIndexMarker413"/> developments in website design where developers can help SDETs maintain robust low-maintenance selectors. Consider this web page <span class="No-Break">element snippet:</span></p>
			<pre class="source-code">
&lt;div data-qa="product-card" role="article" aria-label="Product Details"&gt;
      &lt;a href="#" data-qa="add-to-cart"&gt;Add to Cart &lt;/a&gt; &lt;/div&gt;</pre>			<p>This <a id="_idIndexMarker414"/>can be accomplished by adding the <strong class="source-inline">data-qa</strong> attribute, which is<a id="_idIndexMarker415"/> unique and static. Alternately, if the developer team follows the ARIA standard, many text elements can be identified by the <span class="No-Break"><strong class="source-inline">aria-label</strong></span><span class="No-Break"> attribute:</span></p>
			<pre class="source-code">
//div[contains(@aria-label, 'Product Details')]
//a[contains(@data-qa, 'Add to Cart')]</pre>			<p>Here is an example leveraging <strong class="source-inline">data-qa</strong> and ARIA attributes to ensure that your web application’s elements are accessible <span class="No-Break">and interactable:</span></p>
			<pre class="source-code">
describe("Accessibility Testing", function () {
  // Simulate loading a web page or application
  beforeAll(function () {
    // Load your web page or application
  });
 it("should have proper ARIA attributes", function () {
    // Find an element by its data-qa attribute
    const buttonWithQA = element(by.css('[data-qa="login-button"]'));
   // Verify that the ARIA role is set to "button"
    expect(buttonWithQA.getAttribute('role')).toEqual('button');
   // You can also check other ARIA attributes like "aria-label", "aria-describedby", etc.
    // Example: expect(buttonWithQA.getAttribute('aria-label')).toBe('Login Button');
  });
 it("should be keyboard accessible", function () {
    // Find an element by its ARIA label
    const buttonWithARIA = element(by.css('[aria-label="Login Button"]'));
   // Trigger a click event using Protractor
    buttonWithARIA.click();
   // Verify that the element is focused after the click
    expect(browser.driver.switchTo().activeElement().getAttribute('aria-label')).toEqual('Login Button');
  });
});</pre>			<p>In the example, we<a id="_idIndexMarker416"/> have two test cases. The first one verifies that an <a id="_idIndexMarker417"/>element with a <strong class="source-inline">data-qa</strong> attribute has the correct ARIA role. The second test case checks the keyboard accessibility of an element with a specific ARIA label. This is just a basic example, and you can adapt it to your specific application’s needs to ensure that your elements are properly accessible and have the <span class="No-Break">right attributes.</span></p>
			<p class="callout-heading">Rule of thumb – alternatives to CSS selectors</p>
			<p class="callout">Unfortunately, CSS selectors do not provide a direct way to filter elements based on their text content, like the <strong class="source-inline">text()</strong> and <strong class="source-inline">normalize-space()</strong> functions <span class="No-Break">in XPath.</span></p>
			<p>So, while CSS<a id="_idIndexMarker418"/> selectors are hailed as being faster, they can be limited in <a id="_idIndexMarker419"/>functionality in test automation. The next example utilizes CSS to quickly gather all elements on <span class="No-Break">the page:</span></p>
			<pre class="console">
const allElementsByCss: ElementArrayType = await browser.$$('*');</pre>			<p>For fetching particular types of elements, a combination of XPath and CSS can be employed. Here are some supplementary element <span class="No-Break">selector types:</span></p>
			<ul>
				<li><span class="No-Break">Text:</span><pre class="source-code">
//span[text()='Vital Signs']</pre></li>				<li><span class="No-Break">Links:</span><pre class="source-code">
a[href='https://example.com']
//a[@href='https://example.com']</pre></li>				<li><span class="No-Break">Buttons:</span><pre class="source-code">
button#submit-button
//button[text()='Login']</pre></li>				<li><span class="No-Break">Lists:</span><pre class="source-code">
ol li:nth-child(2)</pre></li>				<li><span class="No-Break">Fields:</span><pre class="source-code">
input[type='text']
input[id*='input']
textarea[placeholder='Enter text']</pre></li>			</ul>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor209"/>Finding an element only by text</h2>
			<p>Elements can be <a id="_idIndexMarker420"/>found with an XPath selector with an exact matching string. For example, a <strong class="bold">Next</strong> button with an exact match would be formatted <span class="No-Break">as such:</span></p>
			<pre class="console">
//a[text()='Next &gt;']</pre>			<p>However, while the text is likely to remain constant, the angle bracket and spacing could change. We can reduce our chance of future maintenance with a selector that has <span class="No-Break">a substring.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor210"/>Writing an XPath element that contains a textual substring</h1>
			<p>By adding <strong class="source-inline">contains()</strong> to the<a id="_idIndexMarker421"/> selector, the object can be found with just a small part of <span class="No-Break">the text:</span></p>
			<pre class="console">
//a[contains(text(),'Next']</pre>			<p>This works for many elements, but checkboxes and radio buttons <span class="No-Break">are tricky.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor211"/>Finding an element relative to another element</h2>
			<p>In this next <a id="_idIndexMarker422"/>example, we want to click the checkbox next to the name <em class="italic">John Smith</em>. We have several checkboxes but none has a unique identifier <span class="No-Break">by name:</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B19395_10_4.jpg" alt="Figure 10.4 – The name John Smith and its associated checkbox are two separate elements"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – The name John Smith and its associated checkbox are two separate elements</p>
			<p>This selector will identify all <span class="No-Break">the checkboxes:</span></p>
			<pre class="source-code">
//input[contains(@name,'chkSelect')]</pre>			<p>To locate this <a id="_idIndexMarker423"/>checkbox element, we need to use the link and find the input checkbox preceding it. Here’s how we can <span class="No-Break">do that:</span></p>
			<pre class="source-code">
//a[normalize-space()='John.Smith']//preceding::input[@id='ohrmList_chkSelectRecord_2']</pre>			<h2 id="_idParaDest-161"><a id="_idTextAnchor212"/>Case-insensitive partial matches</h2>
			<p>What if we learn a developer <a id="_idIndexMarker424"/>sometimes changes the case of the text? A solution to that is to add a <strong class="source-inline">translate</strong> option and convert the text to match either upper- <span class="No-Break">or lowercase:</span></p>
			<pre class="source-code">
//a[translate(normalize-space(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')='john.smith']//preceding::input[@id='ohrmList_chkSelectRecord_2']</pre>			<p>The problem now is that the element the selector returns is not always visible. Here is how we <span class="No-Break">handle that.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor213"/>Finding only visible elements</h2>
			<p>One of the biggest challenges in<a id="_idIndexMarker425"/> test automation is to return a collection of visible elements. This reminds us of a very famous quote delivered by Michael Keaton: “<em class="italic">Want to get nuts? Let’s </em><span class="No-Break"><em class="italic">get nuts!</em></span><span class="No-Break">”</span></p>
			<p>This extensive selector is provided as one example. It will eliminate most objects that are not visible in multiple ways. We addressed the opacity being <strong class="source-inline">0</strong>, the overflow or visibility being hidden, the display being <strong class="source-inline">none</strong>, and the width or height being set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
(//a | //input | //select | //textarea)[
not (
contains(@style,'opacity: 0;') or contains(@style,'visibility: hidden;') or contains(@style,'display: none;') or contains(@style,'overflow: hidden;') or contains(@style,'width: 0') or
contains(@style,'height: 0')) and
not(ancestor::*[contains(@style,'opacity: 0;') or
contains(@style,'visibility: hidden;') or
contains(@style,'display: none;') or
contains(@style,'overflow: hidden;') or
contains(@style,'width: 0') or
contains(@style,'height: 0')])]</pre>			<p>This selector also eliminates any elements that have an ancestor that is hidden. Here is another place where the 80/20 rule applies. Even if this selector only eliminates about 80% of non-visible elements, we will still need to parse through a collection of elements to find the first one that is visible. So, why not let XPath or CSS handle more than half of the work <a id="_idIndexMarker426"/>getting our <span class="No-Break">visible elements?</span></p>
			<p>The reason we want to do this is to give our methods a second chance at trying to find an element if it has been changed from its class. It’s never too late for a second or third chance to find <span class="No-Break">an element.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor214"/>Second chances – getting valid objects from stale selectors</h1>
			<p>Now that we have our<a id="_idIndexMarker427"/> four primary method wrappers, let us<a id="_idIndexMarker428"/> make them more robust with self-healing code. The biggest drawback in automation is the maintenance to fix elements in the <strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) when <a id="_idIndexMarker429"/>selectors become stale. In this section, we look at self-healing techniques to find elements that have changed their <span class="No-Break">node type.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor215"/>Self healing techniques</h2>
			<p>Let's go over some self-healing techniques in <span class="No-Break">this sub-section.</span></p>
			<h3>Reducing code for case-insensitive matches</h3>
			<p>All<a id="_idIndexMarker430"/> these functions will require a conversion to case-insensitive matches. We start by creating two constants to reduce the repeated use of the upper- and <span class="No-Break">lowercase alphabet:</span></p>
			<pre class="source-code">
const A_Z = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const a_z = 'abcdefghijklmnopqrstuvwxyz';</pre>			<p>Next, we will need a function that will extract unique text from a <span class="No-Break">stale locator.</span></p>
			<h3>Extracting selector text</h3>
			<p>This <a id="_idIndexMarker431"/>function will try to return the first match of any unique text encased in double or single quotes. This will be injected into a close <span class="No-Break">match locator:</span></p>
			<pre class="source-code">
function extractSelectorText(selector: string): string {
const singleQuoteCount = (selector.match(/'/g) || []).length;
  let newSelector = selector;</pre>			<p>First, we check for a single quote, such as a possessive apostrophe, embedded in the selector string. For example, <strong class="source-inline">"Moe's Bar"</strong> would result in an odd number of <span class="No-Break">single quotes:</span></p>
			<pre class="source-code">
if (singleQuoteCount === 1 || singleQuoteCount === 3){
  const parts = selector.split("'");
  if (singleQuoteCount === 1) {</pre>			<p>Handle cases where there is one single quote by surrounding it with a <span class="No-Break"><strong class="source-inline">concat</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
      newSelector = `concat('${parts[0]}', "'", '${parts[1]}')`;</pre>			<p>This converts <strong class="source-inline">"Moe's bar"</strong> to <strong class="source-inline">"concat("Moe","'","'s bar")</strong> to support a <span class="No-Break">single-quote match.</span></p>
			<pre class="source-code">
    } else if (singleQuoteCount === 3) {</pre>			<p>In any other language, it would be impossible to have a locator with both a single quote and a quoted string in a single locator. But because JavaScript allows literal strings with backticks, there could be a string <span class="No-Break">like this:</span></p>
			<pre class="source-code">
 `//*[text()=Meet Dwayne "The Rock" Johnson at Moe's Bar]`</pre>			<p>So, we handle the case where there are three single quotes and only the second single quote should be escaped <span class="No-Break">like this:</span></p>
			<pre class="source-code">
      newSelector = `concat('${parts[0]}${parts[1]}', "'", '${parts[2]}')`;
    }
  }</pre>			<p>This extracts as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
`concat(Meet Dwayne "The Rock" Johnson at Moe","'"'s Bar"`</pre>			<p>Extract <a id="_idIndexMarker432"/>text between two double or single quotes <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  let match = newSelector.match(/"([^"]+)"$/) || newSelector.match(/'([^']+)'$/);</pre>			<p>If no match is found, or the matched group is not valid, return the original selector. In fact, the locator string passed is likely not robust enough to be given a second chance. We return a string clearly identifying the issue, as returning a <strong class="source-inline">Null</strong> value would throw an error, and an empty string likely would match <span class="No-Break">all elements:</span></p>
			<pre class="source-code">
  if (!match || match.length &lt; 2) {
    return "NO TEXT FOUND IN LOCATOR";
  }</pre>			<p>Otherwise, we <a id="_idIndexMarker433"/>return the captured group between single or double quotes modified if a single quote <span class="No-Break">is detected:</span></p>
			<pre class="source-code">
return match[1];
}</pre>			<p>Now that we have extracted the text of a locator, we can inject it into a similar one for each class <span class="No-Break">of elements.</span></p>
			<h3>From links to buttons</h3>
			<p>On the <a id="_idIndexMarker434"/>main page of the <em class="italic">Candymapper</em> sandbox website, there is exactly one <strong class="source-inline">&lt;Button&gt;</strong> element. It is the <strong class="bold">Send</strong> button. But not too long ago, it was an <strong class="source-inline">&lt;A&gt;</strong> anchor link like the other ones on the page. and it was in all caps. I’ve since fixed that, but do I need to spend time fixing the locator in <span class="No-Break">my code?</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B19395_10_5.jpg" alt="Figure 10.5 –The Send button element on the Candymapper website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 –The Send button element on the Candymapper website</p>
			<p>This was the original locator that used <span class="No-Break">to work:</span></p>
			<pre class="source-code">
//a[text()='SEND']</pre>			<p>What if we could pull the text and inject it into a button class <span class="No-Break">like this?</span></p>
			<pre class="source-code">
//button[normalize-space()='SEND']</pre>			<p>If it still did not work, we made a third attempt to make a <span class="No-Break">case-insensitive match:</span></p>
			<pre class="source-code">
//button[translate (normalize-space(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz') = 'send']</pre>			<p>Now, we have a solution that allows us to find our elements regardless of case sensitivity. We can now move on to optimizing this with a mutant <span class="No-Break">merge power.</span></p>
			<h3>Finding an element by text alone</h3>
			<p>This can be <a id="_idIndexMarker435"/>wrapped together as a function in use by <strong class="source-inline">getValidElement()</strong> to give our buttons a second chance to be identified without refactoring <span class="No-Break">the code:</span></p>
			<pre class="source-code">
function transformLink(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//button[contains(translate (normalize-space(),'${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<p>Now, the <strong class="bold">Send</strong> button can be reached even if it changes case <span class="No-Break">and class:</span></p>
			<pre class="source-code">
public get sendLink () {
    return $(`//a[text()='Send']`);
}
await helpers.clickAdv(await this.sendLink)</pre>			<h3>Fields and lists</h3>
			<p>Fields could<a id="_idIndexMarker436"/> change from <strong class="source-inline">&lt;input&gt;</strong> to <strong class="source-inline">&lt;textarea&gt;</strong> objects. To find them, this change can be done with the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">placeholder</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
function transformField(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//textarea [contains (@placeholder, '${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<p>And of course, <strong class="source-inline">&lt;select&gt;</strong> objects might change to a <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">input&gt;</strong></span><span class="No-Break"> combobox:</span></p>
			<pre class="source-code">
function transformList(selector: string): string {
let extractedText = extractSelectorText(selector)
// Create the new selector string
const newSelector = `//input[contains (@placeholder, '${A_Z}','${a_z}'), '${extractedText.toLowerCase()}')]`;
return newSelector;
}</pre>			<h3>Short substrings</h3>
			<p>One last<a id="_idIndexMarker437"/> trick before we leave this rabbit hole. Sometimes, small text changes can still be located accurately. <strong class="source-inline">"Select all active files"</strong> becomes <strong class="source-inline">"Select all activated files"</strong>. Divide the text into thirds. If the remaining length is greater than five characters, there is a good chance of matching on the middle string, <strong class="source-inline">"all activ"</strong>, as long as it is a <span class="No-Break">unique match:</span></p>
			<pre class="source-code">
function getMiddle(s: string): string {
  const len = s.length;
  // Return the string as it is if its length is less than or equal to 5
  if (len &lt;= 5) {
    return s;
  }
  // Divide the string into three parts
  const oneThird = Math.floor(len / 3);
  const twoThirds = 2 * oneThird;
  // Extract the middle part
  return s.substring(oneThird, twoThirds);
}
console.log(getMiddle("Select all active files")); // Output: "all active fi"
console.log(getMiddle("small")); // Output: "small"</pre>			<p>Statistically, this will return a unique element about 40% of <span class="No-Break">the time.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor216"/>On thin ice</h2>
			<p>Scrolling <a id="_idIndexMarker438"/>elements pose a particularly difficult challenge. Occasionally, they will end up partially outside of the view area of the browser. Let’s take a look at <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B19395_10_6.jpg" alt="Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser view area; center of a second text area object located off the bottom of the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Text area object of upper-left corner 0,0 located above the browser view area; center of a second text area object located off the bottom of the browser</p>
			<p>And what if your<a id="_idIndexMarker439"/> site supports side-scrolling element animation? If your framework activates a sliding menu and immediately tries to click an element inside, there are bound to be some <span class="No-Break">strange results:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B19395_10_7.jpg" alt="Figure 10.7 – Example of clicking the center of a sliding menu item"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Example of clicking the center of a sliding menu item</p>
			<p>What makes it more frustrating is that should this issue occur, the screen capture at the end of the test will likely occur once the slider animation has been completed. The only clue you might get is a message indicating the element was not clickable at point 2050, 250 which is just beyond the right edge of a display with a 1920 x 1080 <span class="No-Break">pixel resolution.</span></p>
			<p>The intrinsic WebdriverIO <strong class="source-inline">.click()</strong> method should never have an issue interacting with an offscreen element. The major reason the <strong class="source-inline">clickAdv()</strong> wrapper function scrolls the element into the browser view area is to have a better chance of having the element appear in a screen capture if an <span class="No-Break">error occurs.</span></p>
			<p>Attempting to <a id="_idIndexMarker440"/>use a fancy JavaScript click can throw errors if the element is not in the viewport. It depends if the click is being executed at the top-left corner of the object or at its calculated center. Here is an example of a JavaScript click call using the <strong class="source-inline">browser.execute</strong> method to execute the <strong class="source-inline">arguments[0].click();</strong> <span class="No-Break">code string:</span></p>
			<pre class="source-code">
async function jsClick(element: WebdriverIO.Element): Promise&lt;void&gt; {
await browser.execute("arguments[0].click();", element); }
// Usage example
  await jsClick('#some-button-id');</pre>			<p>There is another good reason this approach can cause issues. In GUI automation, we always want to emulate the user as much as possible. What happens if we have a modal popup displayed over the desired element, as <span class="No-Break">seen here?</span></p>
			<p class="IMG---Figure">  </p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B19395_10_8.jpg" alt="Figure 10.8 – Calling jsclick() to force interaction with an element below a modal popup will be problematic"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Calling jsclick() to force interaction with an element below a modal popup will be problematic</p>
			<p>If the element we are <a id="_idIndexMarker441"/>seeking is sliding in on a control from off-screen, you often might get an error that the element click is out of bounds. It can occur if the element is an item in an expanding list that is still animating. Occasionally, an error can occur when the object has scrolled a few pixels out of the viewport. To counter this, we need to know if the element is moving when the error is thrown and when the movement has stopped. Here’s how we can <span class="No-Break">do that:</span></p>
			<pre class="source-code">
async function scrollOneClickUp(): Promise&lt;void&gt; {
await browser.execute(() =&gt; { const event = new
WheelEvent("wheel", { deltaY: -50 });
document.dispatchEvent(event); });
}</pre>			<p>Scroll down one mouse wheel and click, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
async function scrollOneClickDown(): Promise&lt;void&gt; {
await browser.execute(() =&gt; { const event = new
WheelEvent("wheel", { deltaY: 50 });
document.dispatchEvent(event); });
}</pre>			<h3>Writing the isMoving() method</h3>
			<p>The days of clicking on an <a id="_idIndexMarker442"/>element by an <em class="italic">x</em> or <em class="italic">y</em> coordinate are long past us. It does not mean the coordinates of an element are of no value. Surprisingly, in some instances, a click is sometimes performed relative to an element’s screen location. With coordinates, we can determine if an element is in motion to ensure there is a higher degree of accuracy in our framework. Consider this line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const currentLocation: WebdriverIO.LocationReturn = await element.getLocation();</pre>			<p>This will return an object with the current <em class="italic">x</em> and <em class="italic">y</em> screen coordinate location of the element. By looping through with a brief pause of a few milliseconds, we can implement a dynamic wait that<a id="_idIndexMarker443"/> ensures our object scroll animation has <span class="No-Break">been completed:</span></p>
			<pre class="source-code">
export async function waitForElementToStopMoving(element: WebdriverIO.Element, timeout: number): Promise&lt;void&gt;
  const initialLocation = await element.getLocation();
  return new Promise((resolve, reject) =&gt; {
    let intervalId: NodeJS.Timeout;
    const checkMovement = () =&gt; {
      element.getLocation().then((currentLocation) =&gt; {
        if (
            currentLocation.x === initialLocation.x &amp;&amp;
            currentLocation.y === initialLocation.y
        ) {
          clearInterval(intervalId);
          resolve();
        }
      });
    };
    intervalId = setInterval(checkMovement, 100);
    setTimeout(() =&gt; {
      clearInterval(intervalId);
      reject(new Error(`Timeout: Element did not stop moving within ${timeout}ms`));
    }, timeout);
  });
}</pre>			<p>The best practice is to implement this just after any <strong class="source-inline">browser.execute</strong> scroll and before any similar <span class="No-Break">click-based method.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor217"/>Summary</h1>
			<p>In this thrilling installment of our superhero coding saga, we’ve journeyed through the enigmatic world of element targeting, mastering the art of locating elusive HTML entities in the wilds of the web. Our quest led us to conquer the shifting shapes of <strong class="source-inline">&lt;a&gt;</strong> anchors, transforming them into mighty <strong class="source-inline">&lt;button&gt;</strong> sentinels, and evolving simple <strong class="source-inline">&lt;input&gt;</strong> fields into vast expanses of <strong class="source-inline">&lt;textarea&gt;</strong> elements. We’ve navigated the morphing mazes of dropdowns metamorphosing into comboboxes, deploying our powers to match text with a disregard for case, and even to seek out the hidden meanings within the midst <span class="No-Break">of strings.</span></p>
			<p>Our toolkit expanded, and we’ve embraced the arcane arts of self-healing locators, weaving spells to mend themselves when the digital winds change. We stood firm as elements danced and darted across the screen, phasing in with animations that would baffle a lesser <span class="No-Break">Tech Mage.</span></p>
			<p>As we stand at the precipice of discovery, we pose a question that defies the very reality of our craft: What if the need for a page object locator were but a mere illusion? What if, in the shadowy recesses of the UI, we could summon a <strong class="bold">Send</strong> button with nothing but a whisper to the framework? The answer beckons us—dare we leap into the unknown? The next chapter awaits, promising wonders beyond the limits of <span class="No-Break">our imagination.</span></p>
		</div>
	</body></html>