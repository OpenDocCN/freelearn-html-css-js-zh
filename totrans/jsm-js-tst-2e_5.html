<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Jasmine Spies"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Jasmine Spies</h1></div></div></div><p>A test double<a id="id175" class="indexterm"/> is a pattern on unit testing. It replaces a test dependent component with an equivalent implementation that is specific to the test scenario. These implementations are called <span class="strong"><strong>doubles</strong></span><a id="id176" class="indexterm"/> because although their behavior might be specific to the test, they act like, and have the same API as, the object they impersonate.</p><p>Spies are Jasmine's solution to test doubles. At its core, a Jasmine <span class="strong"><strong>spy</strong></span> is a special type of function that records all interactions that happen with it. Therefore, they are very useful when a returned value or change in an object's state can't be used to determine whether a test expectation was a success. In other words, Jasmine spies are perfect when a test success can only be determined by <span class="strong"><strong>behavior checking</strong></span>.</p><div class="section" title="The &quot;bare&quot; spy"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>The "bare" spy</h1></div></div></div><p>To understand the concept of<a id="id177" class="indexterm"/> behavior checking, let's revisit an example presented in <a class="link" href="ch03.html" title="Chapter 3. Testing Frontend Code">Chapter 3</a>, <span class="emphasis"><em>Testing Frontend Code</em></span>, and test the observable behavior of the <code class="literal">NewInvestmentView</code> test suite:</p><div class="informalexample"><pre class="programlisting"> describe("NewInvestmentView", function() {
  var view;

  // setup and other specs ...

  describe("with its inputs correctly filled", function() {

    // setup and other specs ...

    describe("and when an investment is created", function() {
      var callbackSpy;
      var investment;

      beforeEach(function() {
        callbackSpy = <span class="strong"><strong>jasmine.createSpy('callback')</strong></span>;
        view.onCreate(callbackSpy);

        investment = view.create();
      });

      it("should invoke the 'onCreate' callback with the created investment", function() {

<span class="strong"><strong>        expect(callbackSpy).toHaveBeenCalled();</strong></span>
<span class="strong"><strong>        expect(callbackSpy).toHaveBeenCalledWith(investment);</strong></span>
      });
    });
  });
});</pre></div><p>During the spec setup, it<a id="id178" class="indexterm"/> creates a new Jasmine spy using the <code class="literal">jasmine.createSpy</code> function while passing a name for it (<code class="literal">callback</code>). A Jasmine spy is a special kind of function that tracks calls and arguments made to it.</p><p>Then, it sets this spy as an observer of the View's create event using the <code class="literal">onCreate</code> function, and finally it invokes the <code class="literal">create</code> function to create a new investment.</p><p>Later on, at the expectations, the spec uses the <code class="literal">toHaveBeenCalled</code> and <code class="literal">toHaveBeenCalledWith</code> matchers to check whether the <code class="literal">callbackSpy</code> was called and with the right parameters (<code class="literal">investment</code>), thereby making a behavior check.</p></div></div>
<div class="section" title="Spying on an object's functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Spying on an object's functions</h1></div></div></div><p>A spy,<a id="id179" class="indexterm"/> by itself is very useful, but its true power comes with changing an object's original implementation<a id="id180" class="indexterm"/> using a counterpart spy.</p><p>Consider the following example, which is aimed at validating that when the form is submitted, the <code class="literal">create</code> function of <code class="literal">view</code> has to be called:</p><div class="informalexample"><pre class="programlisting">describe("NewInvestmentView", function() {
  var view;

  // setup and other specs ...

  describe("with its inputs correctly filled", function() {

    // setup and other specs ...

    describe("and when the form is submitted", function() {
      beforeEach(function() {
        <span class="strong"><strong>spyOn(view, 'create');</strong></span>
        view.$element.submit();
      });

      it("should create an investment", function() {
        <span class="strong"><strong>expect(view.create).toHaveBeenCalled();</strong></span>
      });
    });
  });
});</pre></div><p>Here, we make use of the global Jasmine function <code class="literal">spyOn</code> to change the <code class="literal">create</code> function of <code class="literal">view</code> with a spy.</p><p>Then, later in the spec, we <a id="id181" class="indexterm"/>use the <code class="literal">toHaveBeenCalled</code> Jasmine matcher to validate that the <code class="literal">view.create</code> function was called.</p><p>After the spec is done, Jasmine restores the object's original behavior.</p></div>
<div class="section" title="Testing DOM events"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Testing DOM events</h1></div></div></div><p>DOM events<a id="id182" class="indexterm"/> are used all the time while coding frontend applications, and sometimes we intend to write a spec that checks whether an event is being triggered.</p><p>An event could be something like a form submission or an input that has changed, so how can we use spies to do that?</p><p>We can write a new acceptance criterion to the <code class="literal">NewInvestmentView</code> test suite to check that its form is being submitted when we click on the add button:</p><div class="informalexample"><pre class="programlisting">describe("and when its add button is clicked", function() {
  beforeEach(function() {
    <span class="strong"><strong>spyOnEvent(view.$element, 'submit');</strong></span>
    view.20.18.find('input[type=submit]').click();
  });

  it("should submit the form", function() {
    <span class="strong"><strong>expect('submit').toHaveBeenTriggeredOn(view.20.18);</strong></span>
  });
});</pre></div><p>To write this spec, we use the <code class="literal">spyOnEvent</code> global function provided by the Jasmine jQuery plugin.</p><p>It works by accepting <code class="literal">view.20.18</code>, which is a DOM element, and the <code class="literal">submit</code> event we want to spy on. Then, later on, we<a id="id183" class="indexterm"/> use the jasmine jQuery matcher <code class="literal">toHaveBeenTriggeredOn</code> to check whether the event was triggered on the element.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, you were presented with the concept of test doubles and how you can use spies to perform behavior checking on your specs.</p><p>In the next chapter, we will take a look at how we can use fakes and stubs to replace real dependencies of our specs and speed up their execution.</p></div></body></html>