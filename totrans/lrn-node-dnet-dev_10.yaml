- en: Chapter 10. Creating Real-time Web Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web has offered an ever more dynamic and interactive user experience. Throughout
    the 90s, most of the web consisted of static pages or server-side rendered pages.
    Frames and iframes made it possible to reload parts of the page in a limited way.
    When Ajax appeared in the mid-2000s, it allowed pages to be much more engaging.
    Client-side JavaScript could now request data from the server on demand and update
    the page dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time web applications are the next step in this evolution. These are applications
    where the server pushes data to clients without the clients needing to initiate
    a request. This allows a user to be notified of new information or for users to
    interact with each other in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a two-way communication channel between the client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding real-time interactivity to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a backend to scale our real-time application across multiple servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding options for real-time communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time web applications need a bidirectional communication channel between
    the client and the server. This is any persistent connection that allows the server
    to push additional data to the client when needed. The WebSockets protocol is
    the modern standard for this kind of communication and is implemented by most
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket connections are initiated via HTTP, but otherwise do not depend on
    it. The WebSocket protocol defines a way of sending messages bi-directionally
    over a TCP connection. TCP is the low-level transport protocol that usually underlies
    HTTP. WebSockets are still a relatively new technology and not fully supported
    by all clients and servers. Most modern web browsers today do support WebSockets.
    However, intermediate servers (proxies, firewalls, and load-balancers) can prevent
    WebSocket connections from working (either through lack of support or intentionally
    blocking non-HTTP traffic). In these cases, there are alternative ways of achieving
    real-time communication.
  prefs: []
  type: TYPE_NORMAL
- en: The EventSource standard defines a way for a server to send events to clients
    over HTTP and defines a JavaScript API for handling these events. It is not as
    efficient or widely-supported as WebSockets, but is better supported by some older
    servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate fallback is **long-polling**. This is when the client initiates
    an ordinary (Ajax) request to the server, which stays open until the server has
    some data to send. As soon as the client receives any data, it makes another request
    to the server for the next message. This introduces additional bandwidth overheads
    and latency compared to WebSockets, but has the widest support as it just uses
    ordinary HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a client and server can negotiate to work out the best available type
    of connection to use. This can be quite a complicated process, though. Fortunately,
    there are libraries which can handle this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket.IO is a mature and well-established library with excellent cross-browser
    support. It aims to quickly and reliably establish a bidirectional communication
    channel in a cross-browser compatible way. It provides a consistent abstraction,
    based on idiomatic JavaScript events, for real-time communication between the
    client and the server over this channel. If you have ever used SignalR in .NET,
    you can think of Socket.IO as the JavaScript equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a chat room with Socket.IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s implement a chat lobby for users of our application to talk to one another.
    First, we need to install Socket.IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The server-side implementation for this is very simple. We just need to tell
    Socket.IO that, whenever a user sends a chat message, we want to broadcast this
    to all connected users as given here `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add a listener to Socket.IO's `connection` event. Our listener is fired
    whenever a new client connects to the application. The `socket` variable represents
    the connection to that specific client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `io` parameter shown previously will be a Socket.IO instance. To create
    one of these, we need to provide a reference to the HTTP server that will host
    our application, so that Socket.IO can add its own connection handling. To keep
    things tidier, we''ll add a new `server` module in `src/server.js` to set up our
    server, start our Express application, and initialize Socket.IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This also allows us to simplify the bootstrap script and our integration tests
    as in `bin/www`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '... and in `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the client-side code to communicate with this service. First,
    we''ll add a place for our chat lobby to the application home page as given here
    `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create the client-side script to connect this with the server as
    given here `src/public/scripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to include our new script in the page and include the Socket.IO
    client-side script that defines the preceding `io` function `src/view/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we haven''t created the `socket.io.js` script anywhere. This is served
    as a result of attaching Socket.IO to our server in `src/server.js`. Since we
    don''t define the `io` variable in our own script, we need to let ESLint know
    that it exists as a global variable as given in `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we open up our application in two browser windows, they can send chat
    messages to each other!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling real-time Node.js applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since our chat messages are being relayed via the server, clients can currently
    only communicate with other clients connected to the same server. This is a problem
    if we want to scale our application horizontally across many servers.
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to fix, but tricky to demonstrate. To do so, we need to have two
    separate instances of our application running. This will be more realistic and
    more useful if they are also using the same shared databases for persistence.
    So we need to start up MongoDB and Redis, then start two instances of our application
    on different ports (so that they don't collide).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means running all of the following commands (replacing the dbpath of MongoDB
    as appropriate for your setup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands that start the database or application servers also occupy the
    current console. So, to be able to run all of these commands, we need to execute
    them in separate windows or tell them to execute in the background. On Windows,
    this can be achieved with the following batch script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now you can connect separate browsers to a separate application instance at
    `http://localhost:3000` and `http://localhost:3001`. Notice that two clients connected
    to the same application instance can receive messages from each other, but not
    from clients on the other application instance.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this, we need a shared backend through which all the applications
    can communicate. Redis is a perfect candidate for this.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as a backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Socket.IO makes use of the **adapter** pattern to support different backends.
    An adapter is just a wrapper for converting one interface into another. Socket.IO
    has a standard backend interface and various adapters to allow different implementations
    to work with this interface. By default, it uses an in-memory adapter that is
    limited to a single process. However, the Socket.IO project also provides an adaptor
    for using Redis as a backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, using this is simply a matter of telling Socket.IO where to
    find our Redis instance (we skip this in test environments where we only have
    one application process) as given here `src/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! We don't require any other changes to our code to support scalability.
    If you restart your application instances now, you should find that clients can
    communicate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Socket.IO with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, apart from sharing the same server, the Socket.IO and Express parts
    of our application are completely independent. While it's good that they are loosely
    coupled, some cross-cutting concerns may be relevant to both.
  prefs: []
  type: TYPE_NORMAL
- en: For example, both parts of our application should have a mutually consistent
    way of identifying the current user. This is especially important if they are
    to come together to provide a single coherent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s extend our user middleware to provide the current user''s name
    as well as their ID, by looking them up in the user service as given here `src/middleware/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find updated tests for this middleware in the book's companion code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will mean injecting our user service as a dependency, like we do for the
    other middleware modules (that is, routes) in our application as given in `src/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part is allowing Socket.IO to make use of this middleware.
    Socket.IO has its own concept of middleware very similar to that of Express. Recall
    that Express middleware functions take parameters for the current request, response,
    and a `next` callback. Socket.IO middleware functions just take a communication
    socket and a `next` callback. However, we can access the original HTTP handshake
    that initiated the socket. This allows us to adapt our Express middleware to Socket.IO
    middleware and use it as follows, in `src/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the user middleware will run for Socket.IO as well as regular HTTP requests,
    making user data available to Socket.IO as well. Let''s use this to include usernames
    in our chat. First, we need to update our server as given in `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that Socket.IO allows us to send objects instead of simple strings as
    the event payload. Now we just need to make use of this in the client as given
    here `src/public/scripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you now open the application in separate browser sessions and specify different
    usernames, you will see these in the chat output.
  prefs: []
  type: TYPE_NORMAL
- en: Directing Socket.IO messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have access to usernames, we can also announce the arrival of users
    in the lobby. We can do this by extending our Socket.IO connection event handler
    as given here `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use `socket.broadcast.emit`, rather than `io.emit`, to send the event
    to all clients except for the current socket. Note that we also add extra data
    to the message. This time we add a `type` field (set to `''action''` for the arrival
    message) to allow different visual presentation of different types of message.
    We can achieve this by updating our client-side code to set additional CSS classes
    based on the message type as given here `src/public/scripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the CSS file for the example application in the companion code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also enforce that users have to choose a username before they can take
    part in the chat as given here `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `socket.emit` rather than `io.emit` to send a message to the client
    associated with the current socket.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Socket.IO applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s look at how we can test our chat module. To talk to it from our
    tests we''ll need a Socket.IO client. The Socket.IO project provides another package
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The infrastructure for our tests consists of setting up a server and multiple
    clients as given here `test/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create an HTTP server without specifying an address, so that the OS
    will assign us an available port. We then use this this server to host our chat
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re running the chat module in isolation, we don''t have our users
    middleware available, so will need an alternative way to provide usernames. We
    can do this with a stub middleware in our tests that reads usernames directly
    from a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to implement our tests. The first two, for messages initiated
    from the server, are quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing messages sent between clients requires a little more care to capture
    each client''s receipt of the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Organizing Socket.IO applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a chat lobby on the index page of our application, it's a bit
    odd that users have to reload the page (and lose the chat history) to find out
    about new games. We can use Socket.IO to update these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing real-time updates to the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll need our games service itself to expose events for when games
    are added or removed. Here we use the Mongoose-provided `post` method to hook
    into persistence operations on games as given here `src/services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We expose an **event emitter** to allow other modules to subscribe to events
    for when games are added or removed. Event emitters are a built-in feature of
    Node.js, which provide a simple way to expose custom events. Note that the Mongoose
    `Schema` class is itself an event emitter, so we could just expose this directly.
    However, this would be leaking details about the implementation of our games service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, you can find new tests for these changes in the companion code.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Socket.IO applications using namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real-time chat and real-time updates to the list of games are quite distinct
    functional areas of our application. Socket.IO provides **namespaces** to allow
    us to organise events. This allows us to still use a single connection between
    the client and the server, without having to worry about clashing event names
    between different functional areas. This is very useful as applications become
    larger and more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Putting our chat functionality under a namespace is a very simple change on
    the client and the server (and in our tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/public/scripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `test/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add a new Socket.IO module for exposing changes to games. This simply
    needs to forward events from our games service to connected Socket.IO clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the following code under `src/realtime/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We also need to include this module in the initialisation of our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding client just needs to connect to the `/games` namespace and
    update the list accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/public/scripts/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is added to `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, it would better to use a client-side MV* library such as Knockout
    or Backbone to update the page based on model changes, rather than manipulating
    the DOM like this, but that's outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you open the application in two separate browser sessions and create
    a new game in one browser window, it will immediately appear in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning Socket.IO clients using rooms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of functionality we're going to add in this chapter is the ability
    for users playing the same game to talk to one another. We can re-use the chat
    functionality we've already written for this. However, we want a separate chat
    for the lobby on the homepage and for each game.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO provides **rooms** for directing messages to different groups of clients.
    Remember that namespaces allow us to divide our application into different functional
    areas. Rooms allow us to divide up clients within the same functional area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rooms in Socket.IO are just string identifiers and we add clients to a room
    using the `socket.join` function. We''ll introduce a new `joinRoom` event to allow
    our clients to ask our server to add them to a particular room. We''ll respond
    to this event on the server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/realtime/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also announce when users leave a particular room, in the same way
    that we announce arrivals. Again, you can find the additional test for this functionality
    in the example code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add the chat functionality into the game page and specify the correct
    room using a data attribute on the chat form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/views/game.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `src/views/index.hjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then we need to update the client script to join the correct room when connecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/public/scripts/chat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to make sure that typing a chat message doesn't interfere with
    playing the game. We can do this by only treating keypresses as guesses for the
    game when the user isn't typing in the chat message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is from `src/public/javascript/game.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find new and updated tests for this functionality in the companion code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together, we can now have multiple clients talking to one
    another in separate rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Partitioning Socket.IO clients using rooms](img/image00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have created a real-time client/server communication channel
    using Socket.IO, used Redis as a backend to scale a real-time application horizontally,
    integrated Socket.IO with Express middleware, and organized our application using
    Socket.IO namespaces and rooms.
  prefs: []
  type: TYPE_NORMAL
- en: As the network connectivity of our application is becoming more complicated,
    it's more important to test the application on a web server outside of the development
    or CI environment. In the next chapter, we'll look at how to deploy our application
    to the web.
  prefs: []
  type: TYPE_NORMAL
