- en: Lights
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光源
- en: In the previous chapter, we covered WebGL's rendering pipeline, defining geometries,
    passing data to the GPU, drawing types, and leveraging AJAX to asynchronously
    load external assets. Although we briefly covered shaders and their role in creating
    a WebGL application, we will go into more detail in this chapter and leverage the
    vertex and fragment shaders to create a lighting model for our scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 WebGL 的渲染管线，定义了几何形状，将数据传递给 GPU，绘制类型，并利用 AJAX 异步加载外部资源。虽然我们简要介绍了着色器及其在创建
    WebGL 应用中的作用，但我们将在本章中更详细地介绍，并利用顶点和片段着色器为我们的场景创建光照模型。
- en: Shaders allow us to define a mathematical model that governs how our scene is
    lit. To learn how to implement shaders, we will study different algorithms and
    see examples of their application. A basic knowledge of linear algebra will be
    really useful to help you understand the contents of this chapter. We will use a
    JavaScript library that handles most of the vector and matrix operations, so you
    do not need to worry about the mathematical operations. Nonetheless, your overall
    success depends on a strong conceptual understanding of the linear algebra operations
    that we will discuss.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器允许我们定义一个数学模型，该模型控制我们的场景如何被照明。为了学习如何实现着色器，我们将研究不同的算法，并查看它们的示例应用。对线性代数的基本了解将非常有用，可以帮助你理解本章的内容。我们将使用一个
    JavaScript 库来处理大多数的向量和矩阵运算，因此你不需要担心数学运算。尽管如此，你的整体成功取决于对我们将要讨论的线性代数运算的强大概念理解。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about light sources, normals, and materials.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解光源、法线和材质。
- en: Learn the difference between shading and lighting.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习着色与光照之间的区别。
- en: Use the Goraud and Phong shading methods.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Goraud 和 Phong 着色方法。
- en: Use the Lambertian and Phong lighting models.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lambertian 和 Phong 光照模型。
- en: Define and use uniforms, attributes, and varyings.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用统一变量、属性和变量。
- en: Work with ESSL, the shading language for WebGL.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ESSL，WebGL 的着色语言。
- en: Discuss relevant WebGL API methods that relate to shaders.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论与着色器相关的相关 WebGL API 方法。
- en: Continue our analysis of WebGL as a state machine and describe the attributes
    relevant to shaders that can be set and retrieved from the state machine.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续分析 WebGL 作为状态机，并描述与着色器相关的可设置和从状态机检索的属性。
- en: Lights, Normals, and Materials
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光源、法线和材质
- en: 'In the real world, we see objects because they reflect light. The illumination
    of an object depends on its position relative to the light source, surface orientation,
    and its material composition. In this chapter, we will learn how to combine these
    three elements in WebGL to model different illumination schemes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们看到物体是因为它们反射光线。物体的照明取决于其相对于光源的位置、表面朝向以及其材料组成。在本章中，我们将学习如何在 WebGL 中结合这三个元素来模拟不同的照明方案：
- en: '![](img/09bf202d-a455-4a83-ab7d-c86e13ce91e1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09bf202d-a455-4a83-ab7d-c86e13ce91e1.png)'
- en: Positional Versus Directional Lights
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置光源与方向光源的比较
- en: 'Light sources can be **positional** or **directional**. A light source is called
    positional when its location will affect how the scene is lit. For instance, a
    lamp inside a room is a positional light source. Objects far from the lamp will
    receive very little light and may even appear obscure. In contrast, directional
    lights are lights that produce the same luminous result, regardless of their position.
    For example, the light from the sun will illuminate all objects in a terrestrial
    scene, regardless of their distance from the sun. This is because the sun is so
    far away that all light rays are considered parallel when they intersect the surface
    of an object. Directional lighting assumes that the light is coming uniformly
    from one direction:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 光源可以是**位置**的或**方向的**。当光源的位置会影响场景的照明时，称为位置光源。例如，房间内的灯是一个位置光源。远离灯的物体将接收到很少的光线，甚至可能看起来模糊。相比之下，方向光是指无论其位置如何都会产生相同发光效果的光。例如，太阳光将照亮地面场景中的所有物体，无论它们与太阳的距离如何。这是因为太阳非常遥远，当光线与物体的表面相交时，所有光线都被认为是平行的。方向光照假设光线从同一方向均匀地照射过来：
- en: '![](img/9fa02bc7-d762-4a9a-a955-8e34745c481e.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fa02bc7-d762-4a9a-a955-8e34745c481e.png)'
- en: A positional light is modeled by a point in space, while a directional light is
    modeled with a vector that indicates its direction. It is common to use a normalized
    vector for this purpose, given that this simplifies mathematical operations. Also,
    it is generally the case that computing directional lighting is actually simpler
    and less computationally expensive than positional lighting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置光线**通过空间中的一个点来建模，而**方向光线**则通过表示其方向的向量来建模。出于简化数学运算的目的，通常使用归一化向量，因为这样可以简化数学运算。此外，计算方向光通常比计算位置光更简单，计算成本也更低。'
- en: Normals
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 法线
- en: '**Normals** are vectors that are perpendicular to the surface we want to illuminate.
    Normals represent the orientation of the surface and are therefore critical to
    modeling the interaction between a light source and the object. Given that each
    vertex has an associated normal vector, we can use the cross product to calculate
    normals.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**法线**是与我们要照亮的表面垂直的向量。法线代表表面的方向，因此对于模拟光源与物体之间的相互作用至关重要。鉴于每个顶点都有一个相关的法线向量，我们可以使用叉积来计算法线。'
- en: Cross-ProductBy definition, the cross-product of vectors `A` and `B` will be
    a vector perpendicular to both vectors `A` and `B`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**叉积**根据定义，向量`A`和`B`的叉积将是一个垂直于向量`A`和`B`的向量。'
- en: 'Let''s break this down. If we have the triangle conformed by vertices `p0`, `p1`,
    and `p2`, we can define the `v1` vector as `p1 - p0` and the `v2` vector as `p2
    - p0`. The normal is then obtained by calculating the `v1 x v2` cross-product.
    Graphically, this procedure looks something like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。如果我们有一个由顶点`p0`、`p1`和`p2`构成的三角形，我们可以定义`v1`向量为`p1 - p0`，`v2`向量为`p2 - p0`。然后，通过计算`v1
    x v2`的叉积来获得法线。从图形上看，这个过程类似于以下内容：
- en: '![](img/cba4ae51-6cea-43a5-aa0e-9f6745103d12.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cba4ae51-6cea-43a5-aa0e-9f6745103d12.png)'
- en: We then repeat the same calculation for each vertex on each triangle. But, what
    about the vertices that are shared by more than one triangle? Each shared vertex
    normal will receive a contribution from each of the triangles in which the vertex
    appears.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对每个三角形上的每个顶点重复相同的计算。但是，对于被多个三角形共享的顶点怎么办？每个共享顶点的法线将接收每个出现该顶点的三角形的一个贡献。
- en: 'For example, say that the `p1` vertex is shared by the `#1` and `#2` triangles,
    and that we have already calculated the normals for the vertices of the `#1` triangle.
    Then, we need to update the `p1` normal by adding up the calculated normal for `p1` on
    the `#2` triangle. This is a **vector sum**. Graphically, this looks similar to
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设`p1`顶点被`#1`和`#2`三角形共享，并且我们已经计算了`#1`三角形顶点的法线。然后，我们需要通过将`#2`三角形上`p1`的法线计算结果相加来更新`p1`的法线。这是一个**向量求和**。从图形上看，这类似于以下内容：
- en: '![](img/7e742957-704e-4e2a-870a-71261fdb16c0.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e742957-704e-4e2a-870a-71261fdb16c0.png)'
- en: Similar to lights, normals are generally normalized to facilitate mathematical
    operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与光线类似，法线通常被归一化以简化数学运算。
- en: Materials
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材质
- en: In WebGL, the material of an object can be modeled by several parameters, including
    its color and texture. Material colors are usually modeled as triplets in the RGB (red,
    green, blue) space. Textures, on the other hand, correspond to images that are
    mapped onto the surface of the object. This process is usually called **texture
    mapping**. We will cover texture mapping in later chapters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebGL中，可以通过包括颜色和纹理在内的多个参数来模拟物体的材质。材质颜色通常在RGB（红色、绿色、蓝色）空间中建模为三元组。另一方面，纹理对应于映射到物体表面的图像。这个过程通常被称为**纹理映射**。我们将在后面的章节中介绍纹理映射。
- en: Using Lights, Normals, and Materials in the Pipeline
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在管线中使用光线、法线和材料
- en: 'In [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*, we
    discussed that WebGL buffers, attributes, and uniforms are used as input variables
    to the shaders, and that varyings are used to pass information between the vertex
    shader and the fragment shader. Let''s revisit the pipeline and see where lights,
    normals, and materials fit in:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](d2019a49-9e84-448c-8799-e296187476d1.xhtml)“渲染”中，我们讨论了WebGL缓冲区、属性和统一变量作为着色器的输入变量，以及变量用于在顶点着色器和片段着色器之间传递信息。现在让我们回顾一下管线，看看光线、法线和材料是如何融入其中的：
- en: '![](img/8e2b6c60-e7ac-4094-b712-f3785f985095.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e2b6c60-e7ac-4094-b712-f3785f985095.png)'
- en: Normals are defined on a vertex-per-vertex basis; therefore, normals are modeled
    as a VBO and are mapped using an attribute, as shown in the preceding diagram.
    Note that attributes cannot be directly passed to the fragment shader. To pass
    information from the vertex shader to the fragment shader, we must use varyings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 法线是在每个顶点的基础上定义的；因此，法线被建模为一个VBO，并使用属性映射，如前图所示。请注意，属性不能直接传递给片段着色器。为了将信息从顶点着色器传递到片段着色器，我们必须使用插值变量。
- en: Lights and materials are passed as uniforms. Uniforms are available to both
    the vertex shader and the fragment shader. This gives us a lot of flexibility
    to calculate our lighting model, because we can calculate how the light is reflected
    on a vertex-by-vertex basis (vertex shader) or on a fragment-per-fragment basis
    (fragment shader).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光和材质作为统一变量传递。统一变量对顶点着色器和片段着色器都是可用的。这为我们计算光照模型提供了很大的灵活性，因为我们可以在顶点级别（顶点着色器）或片段级别（片段着色器）计算光的反射。
- en: Program
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序
- en: Remember that the vertex shader and fragment shader together are referred to
    as a **program**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，顶点着色器和片段着色器一起被称为**程序**。
- en: Parallelism and the Difference Between Attributes and Uniforms
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行性和属性与统一变量之间的区别
- en: There is an important distinction to make between attributes and uniforms. When
    a draw call is invoked (using `drawArrays` or `drawElements`), the GPU will launch
    several copies of the vertex shader in parallel. Each copy will receive a different
    set of attributes. These attributes are drawn from the VBOs that are mapped onto
    the respective attributes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性和统一变量之间有一个重要的区别。当调用绘制命令（使用`drawArrays`或`drawElements`）时，GPU将并行启动多个顶点着色器的副本。每个副本将接收一组不同的属性。这些属性是从映射到相应属性的VBO中抽取的。
- en: 'On the other hand, all of the copies of the vertex shaders will receive the
    same uniforms – hence the name: uniform. In other words, uniforms can be seen
    as constants *per draw call*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，所有顶点着色器的副本都将接收相同的统一变量——这就是为什么叫统一变量的原因。换句话说，统一变量可以看作是每个绘制调用中的常量：
- en: '![](img/3903b1a6-0105-4377-bc3c-c3fcfb5e7fdc.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3903b1a6-0105-4377-bc3c-c3fcfb5e7fdc.png)'
- en: Once lights, normals, and materials are passed to the program, the next step
    is to determine which *shading* and *lighting* models we will implement. Let's
    investigate what this involves.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将灯光、法线和材质传递给程序，下一步就是确定我们将实现哪些**着色**和**光照**模型。让我们来调查这涉及到什么。
- en: Shading Methods and Light-Reflection Models
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色方法和光反射模型
- en: Although the terms *shading* and *lighting* are often ambiguously interchanged,
    they refer to two different concepts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语**着色**和**光照**经常模糊地互换使用，但它们指的是两个不同的概念。
- en: Shading refers to the type of *interpolation* that is performed to obtain the
    final color for every fragment in the scene. Later, we will explain how the type
    of shading determines where the final color is calculated – in the vertex shader
    or in the fragment shader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 着色指的是为了获得场景中每个片段的最终颜色所执行的**插值**类型。稍后，我们将解释着色类型如何决定最终颜色是在顶点着色器还是片段着色器中计算。
- en: Once the shading model is established, the lighting model determines *how* the
    normals, materials, and lights need to be combined to produce the final color.
    Since the equations for lighting models use the physical principles of light reflection,
    lighting models are also referred to as *reflection models*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了着色模型，光照模型就决定了如何将法线、材质和灯光结合起来以产生最终的颜色。由于光照模型的方程使用了光的反射物理原理，因此光照模型也被称为**反射模型**。
- en: Shading/Interpolation Methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色/插值方法
- en: In this section, we will analyze two basic types of interpolation methods: **Goraud** and **Phong** shading.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析两种基本的插值方法：**Goraud**和**Phong**着色。
- en: Goraud Interpolation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goraud插值
- en: The **Goraud** interpolation method calculates the final color in the *vertex
    shader*. The vertex normals are used to perform this calculation. Then, using
    a varying variable, the final color for the vertex is passed to the fragment shader.
    Due to the automatic interpolation of varyings provided by the rendering pipeline,
    each fragment will have a color that is the result of interpolating the colors
    of the enclosing triangle for each fragment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Goraud**插值方法在**顶点着色器**中计算最终颜色。使用顶点法线执行此计算。然后，使用插值变量，将顶点的最终颜色传递到片段着色器。由于渲染管道提供的自动插值变量，每个片段将具有一个颜色，它是通过插值包围三角形的颜色来得到的。'
- en: Varying Interpolation
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 插值变量
- en: The interpolation of varyings is automatic in the rendering pipeline. No programming
    is required.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管道中变元的插值是自动的。不需要编程。
- en: Phong Interpolation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phong插值
- en: The **Phong** method calculates the final color in the *fragment shader*. To
    do so, each vertex normal is passed from the vertex shader to the fragment shader
    using a varying. Because of the interpolation mechanism of varyings included in
    the pipeline, each fragment will have its own normal. Fragment normals are then
    used to calculate the final color in the fragment shader.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phong**方法在**片段着色器**中计算最终颜色。为此，每个顶点法线通过一个变元从顶点着色器传递到片段着色器。由于管道中包含的变元的插值机制，每个片段将有自己的法线。然后，使用片段法线在片段着色器中计算最终颜色。'
- en: 'The following diagram summarizes the two interpolation models:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了两种插值模型：
- en: '![](img/aebd4849-7f90-4747-942e-67d2bcc45f4c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aebd4849-7f90-4747-942e-67d2bcc45f4c.png)'
- en: The shading method does not specify how the final color for each fragment is
    calculated. It only specifies *where* (vertex or fragment shader) and the *type
    of interpolation* (vertex colors or vertex normals) to be used.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 着色方法不指定每个片段的最终颜色是如何计算的。它只指定要使用的地方（顶点着色器或片段着色器）以及要使用的**插值类型**（顶点颜色或顶点法线）。
- en: Goraud Versus Phong Shading
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goraud与Phong着色
- en: We now understand that Goraud shading performs the calculations inside the vertex
    shader and leverages the built-in rendering pipeline's interpolation. Phong shading,
    on the other hand, performs all of the calculations inside the fragment shader –
    that is, per fragment (or pixel). With these two details in mind, can you guess
    some of the advantages and disadvantages of these two shading techniques?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，Goraud着色在顶点着色器内部执行计算，并利用内置渲染管道的插值功能。另一方面，Phong着色在片段着色器内部执行所有计算——也就是说，对每个片段（或像素）进行计算。考虑到这两个细节，你能猜出这两种着色技术的优势和劣势吗？
- en: Goraud shading is considered to be faster since the performed calculations are
    computed per vertex, whereas Phong shading is calculated per fragment. The speed
    in performance does come at the cost of accurate or more realistic interpolation.
    This is most noticeable in cases where a light's intensity does not linearly degrade
    between two vertices. Later in this chapter, we will cover these two techniques
    in more detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Goraud着色被认为更快，因为执行的计算是按顶点计算的，而Phong着色是按片段计算的。性能上的速度确实是以准确或更逼真的插值为代价的。这在光线强度在两个顶点之间非线性衰减的情况下最为明显。在本章的后面部分，我们将更详细地介绍这两种技术。
- en: Light-Reflection Models
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光反射模型
- en: As we mentioned previously, the lighting model is independent from the shading/interpolation
    model. The shading model only determines where the final color is calculated.
    Now, it’s time to talk about how to perform such calculations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，光照模型与着色/插值模型是独立的。着色模型只决定最终颜色的计算位置。现在，我们来谈谈如何执行这些计算。
- en: The Lambertian Reflection Model
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉姆伯特反射模型
- en: '**Lambertian reflections** are commonly used in computer graphics as a model
    for *diffuse reflections*, which are the kinds of reflections where an incident
    light ray is reflected in many angles instead of just *one* angle, as is the case
    for *specular reflections:*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉姆伯特反射**在计算机图形学中常用作**漫反射**的模型，这种反射是入射光束在许多角度上反射，而不是像**镜面反射**那样只在**一个**角度上反射：'
- en: '![](img/9fefc2f3-a738-4958-aad9-e68189f583da.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fefc2f3-a738-4958-aad9-e68189f583da.png)'
- en: This lighting model is based on the **cosine emission law**, or **Lambert's
    emission law**. It is named after Johann Heinrich Lambert, from his *Photometria*,
    published in 1760.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个光照模型基于**余弦辐射定律**，或**拉姆伯特辐射定律**。它是以约翰·海因里希·拉姆伯特的名字命名的，他的著作《光度量学》于1760年出版。
- en: The Lambertian reflection is usually calculated as the dot product between the
    surface normal (vertex or fragment normal, depending on the interpolation method
    used) and the negative of the light-direction vector. Then, the number is multiplied
    by the material and light source colors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 拉姆伯特反射通常计算为表面法线（根据使用的插值方法，是顶点法线或片段法线）与光方向向量的负值的点积。然后，这个数值乘以材料和光源的颜色。
- en: Light-Direction VectorThe light-direction vector is the vector that starts on
    the surface and ends on the light source position. It is essentially the vector
    that maps the light's position to the surface of the geometry.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 光方向向量光方向向量是从表面开始并结束在光源位置上的向量。它本质上是将光的位置映射到几何表面上的向量。
- en: '![](img/d0d62439-0e80-4e28-a731-bfd297772d14.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0d62439-0e80-4e28-a731-bfd297772d14.png)'
- en: 'Where:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`![](img/393da706-dd4c-4ab4-a7e0-10f4652a34e3.png)` is the final diffuse color, `![](img/bd8a12b0-4188-47aa-8911-018975269e5a.png)` is
    the light diffuse color, and `![](img/425ac9cb-4da1-4c64-9644-b00c460f945a.png)` is
    the material diffuse color.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](img/393da706-dd4c-4ab4-a7e0-10f4652a34e3.png)` 是最终的漫反射颜色，`![图片](img/bd8a12b0-4188-47aa-8911-018975269e5a.png)`
    是光的漫反射颜色，`![图片](img/425ac9cb-4da1-4c64-9644-b00c460f945a.png)` 是材料的漫反射颜色。'
- en: 'That being said, we''d derive the final diffuse color with the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将使用以下方法推导出最终的漫反射颜色：
- en: 'If `*L*` and `*N*` are normalized, then:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*L*` 和 `*N*` 是归一化的，那么：
- en: Phong Reflection Model
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phong 反射模型
- en: 'The Phong reflection model describes the way a surface reflects the light as
    the sum of three types of reflection: ambient, diffuse, and specular. It was developed
    by Bui Tuong Phong, who published it in his 1973 PhD dissertation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Phong 反射模型描述了表面如何通过三种反射类型的总和来反射光：环境、漫反射和镜面反射。它是由 Bui Tuong Phong 开发的，他在1973年的博士论文中发表了它：
- en: '![](img/c6b4bb7f-75de-48f4-890a-920f4d158a3b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6b4bb7f-75de-48f4-890a-920f4d158a3b.png)'
- en: Let's cover these concepts individually.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个介绍这些概念。
- en: Ambient
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: The **ambient** term accounts for the scattered light present in the scene.
    This term is independent from any light source and is the same for all fragments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境**项考虑场景中存在的散射光。这个项与任何光源无关，并且对所有片段都是相同的。'
- en: Diffuse
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射
- en: The **diffuse** term corresponds to diffuse reflections. A Lambertian model
    is typically used for this component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**漫反射**项对应于漫反射。通常使用朗伯模型（Lambertian model）来表示这一部分。'
- en: Specular
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜面
- en: The **specular** term provides mirror-like reflections. Conceptually, the specular
    reflection reaches its maximum when we look at the object at an angle that is
    equal to the reflected light-direction vector.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**镜面**项提供类似镜面的反射。从概念上讲，当我们在与反射光方向向量相等的角度观察物体时，镜面反射达到最大。'
- en: The specular term is modeled by the dot product of two vectors, namely, the eye vector
    and the reflected light-direction vector. The eye vector originates in the fragment
    and terminates in the view position (camera). The reflected light-direction vector
    is obtained by reflecting the light-direction vector upon the surface normal vector.
    When this dot product equals `1` (by working with normalized vectors), our camera will
    capture the maximum specular reflection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面项通过两个向量的点积来建模，即视点向量（eye vector）和反射光方向向量。视点向量从片段开始，终止于视图位置（相机）。反射光方向向量是通过在表面法线向量上反射光方向向量得到的。当这个点积等于
    `1`（通过使用归一化向量）时，我们的相机将捕捉到最大的镜面反射。
- en: 'The dot product is then exponentiated by a number that represents the shininess
    of the surface. After that, the result is multiplied by the light and material
    specular components:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点积随后被一个表示表面光泽度的数字指数化。之后，结果乘以光和材料的镜面反射分量：
- en: '![](img/fb521d70-d2d3-4d53-a76d-7be0d17b45c6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb521d70-d2d3-4d53-a76d-7be0d17b45c6.png)'
- en: 'Where:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '![](img/48dc2c47-c0a4-483b-bb6c-191e544bf077.png) is the final specular color, `![](img/fbc93053-92d3-45dc-91f5-8cc0d34ceeda.png)` is
    the light specular color, `![](img/186f032b-3881-4e8b-adeb-a3950ba8b607.png)` is
    the material specular color, and *`n` *is the shininess factor.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](img/48dc2c47-c0a4-483b-bb6c-191e544bf077.png)` 是最终的镜面反射颜色，`![图片](img/fbc93053-92d3-45dc-91f5-8cc0d34ceeda.png)`
    是光的镜面反射颜色，`![图片](img/186f032b-3881-4e8b-adeb-a3950ba8b607.png)` 是材料的镜面反射颜色，*`n`*
    是光泽度因子。'
- en: 'That being said, we''d derive the final specular color with the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将使用以下方法推导出最终的镜面反射颜色：
- en: 'If `*R*` and `*E*` are normalized, then:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*R*` 和 `*E*` 是归一化的，那么：
- en: It's important to note that the specular reflection reaches its maximum when
    `*R*` and `*E*` have the same direction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当 `*R*` 和 `*E*` 方向相同时，镜面反射达到最大。
- en: Once we have the ambient, diffuse, and specular terms, we add them to find the
    final color of the fragment, which provides us with the Phong reflection model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了环境、漫反射和镜面反射项，我们将它们相加以找到片段的最终颜色，这为我们提供了 Phong 反射模型。
- en: Now, it’s time to learn about the language that will allow us to implement the
    shading and lighting strategies inside the vertex and fragment shaders. This language
    is called ESSL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候学习一种语言了，它将使我们能够在顶点和片段着色器中实现着色和光照策略。这种语言被称为 ESSL。
- en: OpenGL ES Shading Language (ESSL)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 着色语言（ESSL）
- en: The OpenGL ES Shading Language (ESSL) is the language we'll use to write our
    shaders. Its syntax and semantics are very similar to C/C++. However, it has types
    and built-in functions that make it easier to manipulate vectors and matrices.
    In this section, we will cover the basics of ESSL so that we can start using it
    right away.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 着色语言（ESSL）是我们编写着色器所使用的语言。它的语法和语义与 C/C++ 非常相似。然而，它有类型和内置函数，使得操作向量和矩阵更加容易。在本节中，我们将介绍
    ESSL 的基础知识，以便我们可以立即开始使用它。
- en: GLSL and ESSLIt’s quite common for developers to refer to the shading language
    used in WebGL as GLSL. However, it is technically ESSL. WebGl2 is built on the
    OpenGL ES 3.0 spec and therefore uses ESSL, which is a subset of GLSL (the shading
    language for OpenGL).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 和 ESSL 开发者通常将 WebGL 中使用的着色语言称为 GLSL。然而，从技术上讲它是 ESSL。WebGL2 建立在 OpenGL ES
    3.0 规范之上，因此使用 ESSL，它是 GLSL（OpenGL 的着色语言）的一个子集。
- en: This section summarizes the official GLSL ES specifications. You can find the
    complete reference at [https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf](https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了官方 GLSL ES 规范。您可以在[https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf](https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf)找到完整的参考。
- en: Storage Qualifier
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储限定符
- en: 'Variable declarations may have a storage qualifier specified in front of the
    type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明可以在类型之前指定存储限定符：
- en: '`attribute`: Data pulled from buffers that serve as the link between a vertex
    shader and a WebGL application for per-vertex data. This storage qualifier is
    only legal inside the vertex shader.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute`: 从缓冲区中提取的数据，作为顶点着色器和 WebGL 应用程序之间用于每个顶点数据的链接。此存储限定符仅在顶点着色器内有效。'
- en: '`uniform`: Value does not change across the object being processed. Uniforms
    form the link between a shader and a WebGL application. Uniforms are legal in
    both the vertex and fragment shaders. If a uniform is shared by the vertex and
    fragment shader, the respective declarations must match. Uniform values stay the
    same for all vertices of a single draw call.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniform`: 值在处理的对象之间不改变。统一变量构成了着色器和 WebGL 应用程序之间的链接。统一变量在顶点着色器和片段着色器中都是合法的。如果一个统一变量由顶点着色器和片段着色器共享，相应的声明必须匹配。统一变量的值对于单个绘制调用中的所有顶点都是相同的。'
- en: '`varying`: This is the link between a vertex shader and a fragment shader for
    interpolated data. By definition, varyings must be shared by the vertex shader
    and fragment shader. The declaration of varyings needs to match between the vertex
    and fragment shaders.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`varying`: 这是顶点着色器和片段着色器之间用于插值数据的链接。根据定义，插值变量必须由顶点着色器和片段着色器共享。插值变量的声明需要在顶点着色器和片段着色器之间匹配。'
- en: '`const`: A compile-time constant, or a function parameter that is read-only.
    They can be used anywhere in the code of an ESSL program.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`: 编译时常量，或只读的函数参数。它们可以在 ESSL 程序的代码中任何地方使用。'
- en: Types
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Here is a non-exhaustive list of the most common ESSL types:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个不完整的常见 ESSL 类型列表：
- en: '`void`: For functions that do not return a value or for an empty parameter
    list'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`: 用于不返回值的函数或空参数列表'
- en: '`bool`: A conditional type, taking on values of true or false'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`: 一个条件类型，取值为真或假'
- en: '`int`: A signed integer'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 一个有符号整数'
- en: '`float`: A single floating-point scalar'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`: 一个单浮点标量'
- en: '`vec2`: A two-component floating-point vector'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec2`: 一个两分量浮点向量'
- en: '`vec3`: A three-component floating-point vector'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec3`: 一个三分量浮点向量'
- en: '`vec4`: A four-component floating-point vector'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vec4`: 一个四分量浮点向量'
- en: '`bvec2`: A two-component Boolean vector'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bvec2`: 一个两分量布尔向量'
- en: '`bvec3`: A three-component Boolean vector'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bvec3`: 一个三分量布尔向量'
- en: '`bvec4`: A four-component Boolean vector'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bvec4`: 一个四分量布尔向量'
- en: '`ivec2`: A two-component integer vector'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ivec2`: 一个两分量整数向量'
- en: '`ivec3`: A three-component integer vector'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ivec3`: 一个三分量整数向量'
- en: '`ivec4`: A four-component integer vector'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ivec4`: 一个四分量整数向量'
- en: '`mat2`: A 2×2 floating-point matrix'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat2`: 一个 2×2 浮点矩阵'
- en: '`mat3`: A 3×3 floating-point matrix'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat3`: 一个 3×3 浮点矩阵'
- en: '`mat4`: A 4×4 floating-point matrix'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mat4`: 一个 4×4 浮点矩阵'
- en: '`sampler2D`: A handle for accessing a 2D texture'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampler2D`: 访问 2D 纹理的句柄'
- en: '`sampler3D`:  A handle for accessing a 3D texture'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sampler3D`: 访问 3D 纹理的句柄'
- en: '`samplerCube`: A handle for accessing a cube-mapped texture'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samplerCube`: 访问立方映射纹理的句柄'
- en: '`struct`: Used to declare custom data structures based on standard types'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`: 用于根据标准类型声明自定义数据结构'
- en: ESSL
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ESSL
- en: There are many other types and features that the OpenGL ES 3.0 shading language
    provides. Here is a useful guide that covers many of its core features: [https://www.khronos.org/files/opengles3-quick-reference-card.pdf](https://www.khronos.org/files/opengles3-quick-reference-card.pdf).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 着色语言提供了许多其他类型和功能。以下是一个有用的指南，涵盖了其许多核心功能：[https://www.khronos.org/files/opengles3-quick-reference-card.pdf](https://www.khronos.org/files/opengles3-quick-reference-card.pdf)。
- en: 'An input variable will have one of the qualifiers followed by one type. For
    example, we will declare our `uLightColor` variable as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量将有一个限定符后跟一个类型。例如，我们将声明我们的 `uLightColor` 变量如下：
- en: '[PRE0]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that the `uLightColor` variable is a `uniform` vector with four components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `uLightColor` 变量是一个具有四个分量的 `uniform` 向量。
- en: The GLSL and ESSL Naming ConventionConvention dictates that we prefix shader
    variables with their type. This makes for clear and readable shader code. For
    example, for a given color uniform, you would name the variable `uLightColor`.
    For a position varying, `vNormal`. For a normal attribute, `aVertexNormal`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 和 ESSL 命名约定规定我们在着色器变量前加上其类型的前缀。这使得着色器代码清晰易读。例如，对于一个给定的颜色均匀量，你会将变量命名为 `uLightColor`。对于一个位置变化量，`vNormal`。对于一个法线属性，`aVertexNormal`。
- en: Vector Components
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量分量
- en: 'We can refer to each one of the components of an ESSL vector by its index.
    For example, `uLightColor[3]` will refer to the fourth element of the vector (zero-based
    vectors). However, we can also refer to each component by a letter, as demonstrated
    in the following table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过其索引来引用 ESSL 向量的每个分量。例如，`uLightColor[3]` 将引用向量的第四个元素（基于零的向量）。然而，我们也可以通过字母来引用每个分量，如下表所示：
- en: '| `{ x, y, z, w }` | Useful when accessing vectors that represent points or
    vectors. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `{ x, y, z, w }` | 当访问表示点或向量的向量时很有用。|'
- en: '| `{ r, g, b, a }` | Useful when accessing vectors that represent colors. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `{ r, g, b, a }` | 当访问表示颜色的向量时很有用。|'
- en: '| `{ s, t, p, q }` | Useful when accessing vectors that represent texture coordinates.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `{ s, t, p, q }` | 当访问表示纹理坐标的向量时很有用。|'
- en: 'For example, if we want to set the *alpha channel* (fourth component) of our `uLightColor` variable
    to `1.0`, we can do so by writing in any of the following formats:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将 `uLightColor` 变量的 *alpha 通道*（第四个分量）设置为 `1.0`，我们可以通过以下任何一种格式来实现：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In all these of cases, we are referring to the same fourth component. However,
    given that `uLightColor` represents a color, it makes more sense to use the `r`, `g`, `b`, `a` notation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，我们都在引用相同的第四个分量。然而，鉴于 `uLightColor` 表示颜色，使用 `r`、`g`、`b`、`a` 表示法更为合理。
- en: 'It’s also possible to use the vector component notation to refer to subsets
    inside a vector. For example *(taken from GLSL ES specification)*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用向量分量表示法来引用向量内部的子集。例如（摘自 GLSL ES 规范）：
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Operators and Functions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符和函数
- en: 'One of the major advantages of GLSL and ESSL are the powerful built-in mathematical
    operators. ESSL provides many useful operators and functions that simplify vector
    and matrix operations. According to the specifications, the arithmetic binary
    operators add (`+`), subtract (`-`), multiply (`*`), and divide (`/`) operate
    on integer and floating-point typed expressions, including vectors and matrices.
    The two operands must be the same type, or one can be a scalar float and the other
    a float vector or matrix, or one can be a scalar integer and the other an integer
    vector. Additionally, for multiply (`*`), one can be a vector and the other a
    matrix with the same dimensional size as the vector. These result in the same
    fundamental types (integer or float) as the expressions they operate on. If one
    operand is a scalar and the other is a vector or a matrix, the scalar is applied
    component-wise to the vector or the matrix, with the final result being of the
    same type as the vector or the matrix. It''s important to note that dividing by
    zero does not cause an exception, but it does result in an unspecified value.
    Let''s see a few examples of these operations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL和ESSL的主要优势之一是强大的内置数学运算符。ESSL提供了许多有用的运算符和函数，简化了向量和矩阵操作。根据规范，算术二元运算符（加`+`、减`-`、乘`*`、除`/`）作用于整数和浮点类型表达式，包括向量和矩阵。两个操作数必须是相同类型，或者一个是标量浮点数，另一个是浮点向量或矩阵，或者一个是标量整数，另一个是整数向量。此外，对于乘法`*`，一个可以是向量，另一个是与向量具有相同维度的矩阵。这些结果与它们操作的表达式具有相同的基本类型（整数或浮点）。如果一个操作数是标量，另一个是向量或矩阵，则标量逐分量应用于向量或矩阵，最终结果与向量或矩阵具有相同类型。需要注意的是，除以零不会引发异常，但会导致一个未指定的值。让我们看看这些操作的几个示例：
- en: '`-x`: The negative of the `x` vector. It produces the same vector in the exact
    opposite direction.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`: `x`向量的负值。它产生与原向量方向完全相反的向量。'
- en: '`x + y`: Sum of the `x` and `y` vectors. Both vectors need to have the same
    number of components.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x + y`: `x`和`y`向量的和。这两个向量需要具有相同数量的分量。'
- en: '`x - y`: Subtraction of the `x` and `y` vectors. Both vectors need to have
    the same number of components.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x - y`: `x`和`y`向量的减法。这两个向量需要具有相同数量的分量。'
- en: '`x * y`: If `x` and `y` are both vectors, this operator yields a component-wise
    multiplication. Multiplication applied to two matrices returns a linear algebraic
    matrix multiplication, not a component-wise multiplication.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x * y`: 如果`x`和`y`都是向量，则此运算符产生逐元素乘法。应用于两个矩阵的乘法返回线性代数矩阵乘法，而不是逐元素乘法。'
- en: '`matrixCompMult(matX, matY)`: Component-wise multiplication of matrices. They
    need to have the same dimensions (`mat2`, `mat3`, or `mat4`).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrixCompMult(matX, matY)`: 矩阵的逐元素乘法。它们需要具有相同的维度（`mat2`、`mat3`或`mat4`）。'
- en: '`x / y`: The division operator behaves similarly to the multiplication operator.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x / y`: 除法运算符的行为与乘法运算符类似。'
- en: '`dot(x, y)`: Returns the dot product (scalar) of two vectors. They need to
    have the same dimensions.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dot(x, y)`: 返回两个向量的点积（标量）。它们需要具有相同的维度。'
- en: '`cross(vecX, vecY)`: Returns the cross product (vector) of two vectors. They
    must both be `vec3`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cross(vecX, vecY)`: 返回两个向量的叉积（向量）。它们都必须是`vec3`。'
- en: '`normalize(x)`: Returns a vector in the same direction but with a length of `1`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normalize(x)`: 返回一个与原向量方向相同但长度为`1`的向量。'
- en: '`reflect(t, n)`: Reflects the `t`vector along the `n` vector.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reflect(t, n)`: 沿着`n`向量反射`t`向量。'
- en: Shaders offer many more functions, including trigonometric and exponential functions.
    We will refer to them as needed in the development of different lighting models.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器提供了许多其他函数，包括三角函数和指数函数。在开发不同的光照模型时，我们将根据需要引用它们。
- en: 'Let''s see a quick example of the shader''s ESSL code for a scene with the
    following properties:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具有以下属性的场景的着色器ESSL代码的快速示例：
- en: '**Goraud shading**: We will interpolate vertex colors to obtain fragment colors.
    Therefore, we need one `varying` to pass the vertex color information from the
    vertex shader to the fragment shader.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高洛德着色法**：我们将插值顶点颜色以获得片段颜色。因此，我们需要一个`varying`来将顶点颜色信息从顶点着色器传递到片段着色器。'
- en: '**Lambertian reflection model**: We account for the diffuse interaction between
    one light source and our scene. This means that we will use uniforms to define
    the light properties that is, the material properties. We will follow *Lambert''s
    Emission Law *to calculate the final color for every vertex.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**朗伯反射模型**：我们考虑了单一光源与场景之间的漫反射交互。这意味着我们将使用统一变量来定义光属性，即材料属性。我们将遵循*朗伯辐射定律*来计算每个顶点的最终颜色。'
- en: First, let's dissect what the attributes, uniforms, and varyings will be.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析一下属性、统一变量和可变变量将是什么。
- en: Vertex Attributes
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点属性
- en: 'We will start by defining two attributes in the vertex shader. Every vertex
    will have the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在顶点着色器中定义两个属性。每个顶点将具有以下代码：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Attributes**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**'
- en: Remember that attributes are only available to use inside the vertex shader.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，属性仅在顶点着色器内部可用。
- en: If you're curious as to why `in` is used instead of the `attribute` qualifier,
    we will cover this shortly. Right after the `in` keyword, we find the type of
    the variable. In this case, it is `vec3`, as each vertex position is determined
    by three elements (`x`, `y`, `z`). Similarly, the normals are also determined
    by three elements (`x`, `y`, `z`). Please note that a position is a *point* in
    three-dimensional space that tells us where the vertex is, while a normal is a *vector* that
    gives us information about the orientation of the surface that passes along that
    vertex.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇为什么使用`in`而不是`attribute`限定符，我们将在稍后进行解释。在`in`关键字之后，我们找到变量的类型。在这种情况下，它是`vec3`，因为每个顶点位置由三个元素（`x`、`y`、`z`）确定。同样，法线也是由三个元素（`x`、`y`、`z`）确定的。请注意，位置是三维空间中的一个*点*，它告诉我们顶点的位置，而法线是一个*向量*，它提供了关于通过该顶点的表面的方向的信息。
- en: Uniforms
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一变量
- en: Uniforms are available to both the vertex shader and the fragment shader. While
    attributes differ every time the vertex shader is invoked, uniforms are constant
    throughout a rendering cycle – that is, during the `drawArrays` or `drawElements` WebGL
    call.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 统一变量对顶点着色器和片段着色器都可用。虽然属性在每次顶点着色器被调用时都会有所不同，但统一变量在整个渲染周期内是恒定的——即在`drawArrays`或`drawElements`
    WebGL调用期间。
- en: Parallel Processing
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理
- en: We process vertices in parallel; therefore, each copy/thread of the vertex shader
    processes a different vertex.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理
- en: 'We can use uniforms to pass along information about lights (such as diffuse
    color and direction), and materials (diffuse color):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用统一变量来传递有关光源（如漫反射颜色和方向）和材料（漫反射颜色）的信息：
- en: '[PRE4]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, the `uniform` keyword tells us that these variables are uniforms, and
    the `vec3` and `vec4` ESSL types tell us that these variables have three or four
    components. For the colors, these components are the red, blue, green, and alpha
    channels (RGBA), and for the light direction, these components are the `x`, `y`,
    and `z` coordinates that define the vector in which the light source is directed
    in the scene.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`uniform`关键字告诉我们这些变量是统一变量，而`vec3`和`vec4` ESSL类型告诉我们这些变量有三个或四个分量。对于颜色，这些分量是红色、蓝色、绿色和alpha通道（RGBA），而对于光方向，这些分量是定义光源在场景中指向的向量的`x`、`y`和`z`坐标。
- en: Varyings
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变变量
- en: 'As described earlier, varyings allow for the vertex shader to pass information
    to the fragment shader. For example, if we want to carry the vertex color from
    the vertex shader to the fragment shader, we would first update our vertex shader:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可变变量允许顶点着色器将信息传递给片段着色器。例如，如果我们想将顶点颜色从顶点着色器传递到片段着色器，我们首先更新我们的顶点着色器：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we would reference that varying inside of our fragment shader as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在片段着色器内部如下引用该可变变量：
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep in the mind that the *Storage Qualifier*, the declaration of varyings,
    needs to match between the vertex and fragment shaders.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，*存储限定符*、可变变量的声明需要在顶点和片段着色器之间匹配。
- en: The in and out variables
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入和输出变量
- en: These keywords describe the direction of the *input* and *output*. As seen with
    the *attribute* and *varying* declarations, when we use `in`, that variable is
    supplied to the shader. When we use `out`, the shader exposes that variable. Let's
    see how these keywords are used in earlier versions of WebGL within the vertex
    and fragment shader.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键词描述了*输入*和*输出*的方向。正如在*属性*和*可变*声明中看到的那样，当我们使用`in`时，该变量被提供给着色器。当我们使用`out`时，着色器暴露该变量。让我们看看这些关键词如何在WebGL的早期版本中的顶点和片段着色器中使用。
- en: Changing attribute to in
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性更改为`in`
- en: 'In WebGL 1 with *ESSL 100*, you might have this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 使用 *ESSL 100* 中，你可能会有这样的代码：
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In WebGL 2 with *ESSL 300*, this becomes the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 2 使用 *ESSL 300* 中，这变成了以下内容：
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changing varying to in / out
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将插值变量改为输入/输出
- en: 'WebGL 1 with *ESSL 100*, you declare a varying in both the vertex and fragment
    shaders, like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 使用 *ESSL 100* 中，你需要在顶点着色器和片段着色器中声明一个插值变量，如下所示：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In WebGL 2 with *ESSL 300*, in the vertex shader, the varyings become this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 2 使用 *ESSL 300* 中，在顶点着色器中，插值变量变成了这样：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And in the fragment shader, they become this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，它们变成了这样：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's plug the attributes, uniforms, and varyings into the code and see
    what the vertex shader and fragment shader look like.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将属性、统一变量和插值变量插入到代码中，看看顶点着色器和片段着色器是什么样的。
- en: Vertex Shader
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: 'Let''s cover a sample vertex shader:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例顶点着色器：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On first inspection, we can identify the attributes, uniforms, and varyings
    that we will use, along with some matrices that we will discuss later. We can
    also see that the vertex shader has a `main` function that does not accept parameters
    and instead returns `void`. Inside, we can see some ESSL functions, such as `normalize` and `dot`,
    along with some arithmetical operators.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 初步检查后，我们可以识别出我们将使用的属性、统一变量和插值变量，以及我们稍后将要讨论的一些矩阵。我们还可以看到顶点着色器有一个 `main` 函数，它不接受参数，而是返回
    `void`。在内部，我们可以看到一些 ESSL 函数，例如 `normalize` 和 `dot`，以及一些算术运算符。
- en: '`#version 300 es`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`#version 300 es`'
- en: This string must be the very first line of your shader. No comments or blank
    lines are allowed before it! `#version 300 es` tells WebGL that you want to use
    WebGL 2's shader language (GLSL ES 3.00). If that isn’t written as the first line,
    the shader language defaults to WebGL 1.0's GLSL ES 1.00, which has fewer features.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这行字符串必须是你的着色器的第一行。不允许在此之前有任何注释或空白行！`#version 300 es` 告诉 WebGL 你想要使用 WebGL 2
    的着色器语言（GLSL ES 3.00）。如果它不是作为第一行编写的，着色器语言将默认为 WebGL 1.0 的 GLSL ES 1.00，它具有较少的功能。
- en: 'There are three uniforms that we haven’t discussed yet:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个我们尚未讨论的统一变量：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that these three uniforms are `4x4` matrices. These matrices are
    required in the vertex shader to calculate the location for vertices and normals
    whenever we move the camera. There are a couple of operations here that involve
    using these matrices:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这三个统一变量是 `4x4` 矩阵。这些矩阵在顶点着色器中是必需的，用于计算移动相机时顶点和法线的位置。这里有几个涉及使用这些矩阵的操作：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous line of code calculates the *transformed normal*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码计算了 *变换后的法线*：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line calculates the *transformed vertex position*. `gl_Position` is a special
    output variable that stores the transformed vertex position.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码计算了 *变换后的顶点位置*。`gl_Position` 是一个特殊的输出变量，用于存储变换后的顶点位置。
- en: We will come back to these operations in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, we should acknowledge that these uniforms and operations deal
    with camera and world transformations (rotation, scale, and translation).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 4 章](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml) 中回到这些操作，*相机*。现在，我们应该承认这些统一变量和操作涉及相机和世界变换（旋转、缩放和平移）。
- en: 'Returning to the main function’s code, we can clearly see that the Lambertian
    reflection model is being implemented. The `dot` product of the normalized normal
    and light direction vector is obtained and then multiplied by the light and material
    diffuse components. Finally, this result is passed into the `vVertexColor` varying
    to be used in the fragment shader, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到主函数的代码，我们可以清楚地看到正在实现朗伯反射模型。通过将归一化法线和光方向向量的点积获得，然后乘以光和材料的漫反射分量。最后，将此结果传递到 `vVertexColor`
    插值变量中，以便在片段着色器中使用，如下所示：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also, as we are calculating the color in the vertex shader and then automatically
    interpolating it for the fragments of every triangle, we are using the Goraud
    interpolation method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们在顶点着色器中计算颜色，然后自动对每个三角形的片段进行插值，我们使用了 Goraud 插值方法。
- en: Fragment Shader
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器
- en: 'The fragment shader is very simple. The first three lines define the precision
    of the shader. This is mandatory according to the ESSL specification. Similarly,
    for the vertex shader, we define our input; in this case, just one varying variable,
    and then we have the main function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器非常简单。前三条线定义了着色器的精度。根据 ESSL 规范，这是强制性的。同样，对于顶点着色器，我们定义我们的输入；在这种情况下，只是一个插值变量，然后我们有主函数：
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We just need to assign the `vVertexColor` varying to the `fragColor` output
    variable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将 `vVertexColor` 插值变量赋值给 `fragColor` 输出变量。
- en: No More `gl_FragColor`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要 `gl_FragColor`
- en: In WebGL 1, your fragment shader would set the `gl_FragColor` special variable
    to compute the output of the shader: `gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 1 中，你的片段着色器会将`gl_FragColor`特殊变量设置为计算着色器的输出：`gl_FragColor = vec4(1.0,
    0.0, 0.0, 1.0);`。
- en: In WebGL 2, *ESSL 300* forces you to declare your own output variable and then
    set it. You can pick any name you want, but names cannot begin with `gl_`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebGL 2 中，*ESSL 300* 强制你声明自己的输出变量，然后设置它。你可以选择任何你想要的名称，但名称不能以 `gl_` 开头。
- en: Remember that the value of the `vVertexColor` varying will be different from
    the one calculated in the vertex shader since WebGL will interpolate it by taking
    the corresponding calculated colors for the vertices surrounding the correspondent
    fragment (pixel).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`vVertexColor`变化变量的值将不同于在顶点着色器中计算出的值，因为 WebGL 会通过取对应计算颜色周围的顶点颜色来插值它，以对应于相应的片段（像素）。
- en: Writing ESSL Programs
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 ESSL 程序
- en: 'Now, let''s take a moment to step back and look at the big picture. ESSL allows
    us to implement a lighting strategy, provided that we define a shading method
    and a light reflection model. In this section, we will take a sphere as the object
    that we want to illuminate, and we will see how the selection of a lighting strategy
    changes the scene:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们花一点时间回顾一下整体情况。ESSL允许我们实现一种照明策略，前提是我们定义了一种着色方法和一个光照反射模型。在本节中，我们将以球体作为我们想要照亮的对象，我们将看到照明策略的选择如何改变场景：
- en: '![](img/804a04e3-c218-43ac-84ed-132bf0d0f2d5.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/804a04e3-c218-43ac-84ed-132bf0d0f2d5.png)'
- en: 'We will see two scenarios for Goraud interpolation: one with Lambertian and
    one with Phong reflections. We will only see one case for Phong interpolation;
    under Phong shading, the Lambertian reflection model is no different from a Phong
    reflection model where the ambient and specular components are set to `0`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到两种 Goraud 插值场景：一个带有朗伯反射，另一个带有 Phong 反射。对于 Phong 插值，我们只会看到一个案例；在 Phong 着色下，朗伯反射模型与将环境光和镜面光分量设置为
    `0` 的 Phong 反射模型没有区别。
- en: Goraud Shading with Lambertian Reflections
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goraud 着色与朗伯反射
- en: 'The Lambertian reflection model only considers the interaction of diffuse material
    and diffuse light properties. In short, we assign the final color as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 朗伯反射模型只考虑漫反射材料和漫反射光属性之间的相互作用。简而言之，我们按照以下方式分配最终颜色：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following value is seen:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下值是可见的：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Under Goraud shading, the **Lambert coefficient** is obtained by calculating
    the dot product of the vertex normal and the inverse of the light-direction vector.
    Both vectors are normalized before finding the dot product.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Goraud 着色下，**朗伯系数**是通过计算顶点法向量和光照方向向量的点积获得的。在找到点积之前，这两个向量都被归一化。
- en: 'Let''s take a look at the vertex shader and the fragment shader from the provided
    example, `ch03_01_goraud_lambert.html`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看提供的示例`ch03_01_goraud_lambert.html`中的顶点着色器和片段着色器：
- en: '![](img/d615d810-3bf0-4d37-b061-56a63068af19.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d615d810-3bf0-4d37-b061-56a63068af19.png)'
- en: 'Here''s the vertex shader:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是顶点着色器：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s the fragment shader:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是片段着色器：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that the final vertex color that we processed in the vertex shader
    is carried into a varying variable to the fragment shader. Remember that the value
    that arrives to the fragment shader is *not* the original value that we calculated
    in the vertex shader. The fragment shader interpolates the `vVertexColor` variable
    to generate a final color for the respective fragment. This interpolation takes
    into account the vertices that enclose the current fragment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在顶点着色器中处理过的最终顶点颜色被传递到一个变化变量中，传递到片段着色器。记住，到达片段着色器的值**不是**我们在顶点着色器中计算出的原始值。片段着色器通过插值`vVertexColor`变量为相应的片段生成一个最终颜色。这种插值考虑了包围当前片段的顶点。
- en: 'Time for Action: Updating Uniforms in Real Time'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：实时更新统一变量
- en: 'Let''s cover an example of how we''d update shader uniforms interactively:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何交互式地更新着色器统一变量的一个例子：
- en: 'Open the `ch03_01_goraud_lambert.html` file in your browser:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch03_01_goraud_lambert.html`文件：
- en: '![](img/904b2bee-303a-4f77-8954-04c4a28e4002.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/904b2bee-303a-4f77-8954-04c4a28e4002.png)'
- en: Notice that in this example, the controlswidget is at the top right of the page.
    If you're curious about how it works, you can check the `initControls` function
    inside of the example code.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，控件部件位于页面的右上角。如果你对它是如何工作的感到好奇，你可以检查示例代码中的`initControls`函数。
- en: The Settings WidgetThe settings widget was created using **DatGui**, an open
    source library. While we won't cover the intuitive DatGui API, it may be useful
    to read the documentation and the code in the provided examples to see how it
    works. For more information, you can check out [https://github.com/dataarts/dat.gui.](https://github.com/dataarts/dat.gui)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 设置小部件设置小部件是使用**DatGui**创建的，这是一个开源库。虽然我们不会介绍直观的DatGui API，但阅读提供的示例中的文档和代码，了解它是如何工作的可能很有用。更多信息，你可以查看[https://github.com/dataarts/dat.gui.](https://github.com/dataarts/dat.gui)
- en: '**Translate X, Y, Z**: Thesecontrol the direction of the light. By changing
    these sliders, you will modify the `uLightDirection` uniform:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平移X, Y, Z**：这些控制光的方向。通过改变这些滑块，你将修改`uLightDirection`统一变量：'
- en: '![](img/4fb6fe04-13c9-46c9-bc4e-5d9b6f6582b3.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb6fe04-13c9-46c9-bc4e-5d9b6f6582b3.png)'
- en: '**Sphere Color**: This changes the `uMaterialDiffuse` uniform, which represents
    the diffuse color of the sphere. Here, you use the color selection widget, which
    allows you to try different colors. `onChange` of `Sphere Color` in the `initControls` function
    receives the updates from the widget and updates the `uMaterialDiffuse` uniform.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**球体颜色**：这会改变代表球体漫反射颜色的`uMaterialDiffuse`统一变量。在这里，你使用颜色选择小部件，这允许你尝试不同的颜色。`initControls`函数中的`Sphere
    Color`的`onChange`接收来自小部件的更新并更新`uMaterialDiffuse`统一变量。'
- en: '**Light Diffuse Color**: This changes the `uLightDiffuse` uniform, which represents
    the diffuse color of the light source. There is no reason why the light color
    must be white. We achieve this by assigning the slider value to the RGB components
    of `uLightDiffuse` while we keep the alpha channel set to `1.0`. We do this inside
    the `onChange` function under the lights settings, which receives the slider updates.'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**光漫反射颜色**：这会改变代表光源漫反射颜色的`uLightDiffuse`统一变量。没有理由说光的颜色必须是白色的。我们通过将滑块值分配给`uLightDiffuse`的RGB分量，同时将alpha通道设置为`1.0`来实现这一点。我们在灯光设置的`onChange`函数内部这样做，该函数接收滑块的更新。'
- en: Try different settings for the light source position, the diffuse material,
    and light properties.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的光源位置、漫反射材料和光属性设置。
- en: '***What just happened?***'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We’ve seen an example of a simple scene illuminated using Goraud interpolation
    and a Lambertian reflection model. We have also seen the immediate effects of
    changing uniform values for the Lambertian lighting model.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个使用Goraud插值和Lambertian反射模型照亮的简单场景的例子。我们还看到了改变Lambertian照明模型统一值时的即时效果。
- en: 'Have a Go: Moving Light'
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下：移动光源
- en: 'We mentioned before that we use matrices to move the camera around the scene.
    We can also use matrices to move lights. To do this, perform the following steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，我们使用矩阵在场景中移动相机。我们也可以使用矩阵来移动光源。为此，执行以下步骤：
- en: 'Open `ch03_02_moving-light.html` in your editor. The vertex shader is very
    similar to the previous diffuse model example. However, there is one extra line:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`ch03_02_moving-light.html`。顶点着色器与之前的漫反射模型示例非常相似。然而，多了一行：
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are transforming the `uLightDirection` vector and assigning it to
    the `light` variable. Notice that the `uLightDirection` uniform is a vector with
    three components (`vec3`) and that the `uModelViewMatrix` is a 4x4 matrix. In
    order to complete the multiplication, we need to transform this uniform into a
    four-component vector (`vec4`). We achieve this with the following construct:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在变换`uLightDirection`向量并将其赋值给`light`变量。注意，`uLightDirection`统一变量是一个有三个分量（`vec3`）的向量，而`uModelViewMatrix`是一个4x4矩阵。为了完成乘法，我们需要将这个统一变量转换成一个四分量向量（`vec4`）。我们通过以下结构实现这一点：
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `uModelViewMatrix` matrix contains the *Model-View transformation matrix*.
    We will see how all this works in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, suffice to say that this matrix allows us to update vertices’
    positions, and in this example, the light's position as well.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uModelViewMatrix`矩阵包含*模型-视图变换矩阵*。我们将在[第4章](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml)“相机”中看到所有这些是如何工作的。现在，只需说这个矩阵允许我们更新顶点的位置，在这个例子中，还有光源的位置。'
- en: 'Take another look at the vertex shader. In this example, we are rotating the
    sphere and the light. Every time the `draw` function is invoked, we rotate the `modelViewMatrix` matrix a
    little bit on the y-axis:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再看看顶点着色器。在这个例子中，我们正在旋转球体和光源。每次调用`draw`函数时，我们都会在y轴上稍微旋转一下`modelViewMatrix`矩阵：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you examine the code more closely, you will notice that the `modelViewMatrix` matrix is
    mapped to the `uModelViewMatrix` uniform:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更仔细地检查代码，你会注意到 `modelViewMatrix` 矩阵被映射到 `uModelViewMatrix` 常量：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the example in your browser. You will see a sphere and a light source rotating
    on the y-axis:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行示例。你会看到一个球体和一个光源在y轴上旋转：
- en: '![](img/ed0b6249-3e56-494e-9c35-c63ac7a41a89.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed0b6249-3e56-494e-9c35-c63ac7a41a89.png)'
- en: 'Look for the `initLights` function and change the light orientation so that
    the light is pointing in the negative z-axis direction:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initLights` 函数中查找并更改灯光方向，使灯光指向负z轴方向：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save the file and run it again. What happened? Change the light direction uniform
    so that it points to `[-1, 0, 0]`. Save the file and run it again on your browser.
    What happened? You should see that changing these values manipulates the light's
    orientation.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并再次运行。发生了什么？更改灯光方向常量，使其指向 `[-1, 0, 0]`。保存文件并在浏览器中再次运行。发生了什么？你应该看到改变这些值会操纵灯光的方向。
- en: 'Set the light back to the 45-degree angleby changing the `uLightDirection` uniform
    so that it returns to its initial value:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过改变 `uLightDirection` 常量将灯光恢复到45度角，使其返回初始值：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Go to `draw` and find the following line:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `draw` 并找到以下行：
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Change it to this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改成这个：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save the file and launch it again in your browser. What happens? You should
    notice that the light moves on a different axis.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中再次打开它。发生了什么？你应该注意到光线沿着不同的轴移动。
- en: '***What just happened?***'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: As you can see, the vector that is passed as the third argument to `mat4.rotate` determines
    the axis of the rotation. The first component corresponds to the x-axis, the second
    to the y-axis, and the third to the z-axis.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，传递给 `mat4.rotate` 的第三个参数决定了旋转的轴。第一个分量对应于x轴，第二个对应于y轴，第三个对应于z轴。
- en: Goraud Shading with Phong Reflections
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goraud着色与Phong反射
- en: 'Different from the Lambertian reflection model, the Phong reflection model
    considers three properties: the ambient, diffuse, and specular, and ultimately
    yields a more realistic reflection. Following the same analogy that we used in
    the previous section, consider the following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与Lambertian反射模型不同，Phong反射模型考虑了三个属性：环境色、漫反射色和镜面色，并最终产生更逼真的反射。遵循我们在上一节中使用的相同类比，考虑以下示例：
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Where:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: As we use Goraud interpolation, we still use vertex normals to calculate the
    diffuse term. This will change when using Phong interpolation, where we will use
    fragment normals.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用Goraud插值，我们仍然使用顶点法线来计算漫反射项。当使用Phong插值时，我们将使用片段法线，这将会改变。
- en: 'Both light and material have three properties: the ambient, diffuse, and specularcolors.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光和材料都有三个属性：环境色、漫反射色和镜面色。
- en: On these equations, we can see that `Ia`, `Id`, and `Is` receive contributions
    from their respective light and material properties.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这些方程中，我们可以看到 `Ia`、`Id` 和 `Is` 分别从它们各自的光和材料属性中接收贡献。
- en: 'Based on our knowledge of the Phong reflection model, let''s see how to calculate
    the specular coefficient in ESSL:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对Phong反射模型的知识，让我们看看如何在ESSL中计算镜面系数：
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Where:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里：
- en: '`eyeVector` is the view vector or camera vector'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eyeVector` 是视向量或相机向量'
- en: '`lightReflection` is the reflected light vector'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightReflection` 是反射光向量'
- en: '`shininess` is the specular exponential factor or shininess'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shininess` 是镜面指数因子或光泽度'
- en: '`lightReflection` is calculated as `lightReflection = reflect(lightDirection,
    normal);`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightReflection` 的计算方式为 `lightReflection = reflect(lightDirection, normal);`'
- en: '`normal` is the vertex normal, and `lightDirection` is the light direction
    that we have been using to calculate the Lambert coefficient'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normal` 是顶点法线，而 `lightDirection` 是我们用来计算Lambert系数的灯光方向'
- en: 'Let''s take a look at the ESSL implementation for the vertex and fragment shaders.
    Here''s the vertex shader:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看顶点和片段着色器的ESSL实现。这是顶点着色器：
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can obtain negative dot products for the Lambert term when the geometry
    of our objects is concave or when the object is in the way between the light source
    and our point of view. In either case, the negative of the light-direction vector
    and the normals will form an obtuse angle, producing a negative dot product, as
    shown in the following diagram:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的物体几何形状是凹面或物体位于光源和我们的视点之间时，我们可以获得Lambert项的负点积。在两种情况下，光方向向量和法线将形成一个钝角，产生负点积，如下面的图所示：
- en: '![](img/ad5df219-e71e-4fd6-8bfd-afe923d9f2d1.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad5df219-e71e-4fd6-8bfd-afe923d9f2d1.png)'
- en: For that reason, we are using the ESSL built-in clamp function to restrict the
    dot product to the positive range. If we obtain a negative dot product, the clamp
    function will set the lambert term to zero and the respective diffuse contribution
    will be discarded, generating the correct result.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用ESSL内置的clamp函数来限制点积在正范围内。如果我们得到一个负的点积，clamp函数将lambert项设置为0，相应的漫射贡献将被丢弃，从而生成正确的结果。
- en: 'Given that we are still using Goraud interpolation, the fragment shader is
    the same as before:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用Goraud插值，片段着色器与之前相同：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the next section, we will explore the scene to see what it looks like when
    we have negative Lambert coefficients that have been clamped to the `[0,1]` range.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索场景，看看当我们把被clamp到`[0,1]`范围的负Lambert系数应用到场景中时，它看起来会是什么样子。
- en: 'Time for Action: Goraud Shading'
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：Goraud着色
- en: 'Let''s cover an example where we implement lighting with Goraud shading:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个实现Goraud着色的示例：
- en: 'Open the `ch03_03_goraud_phong.html` file in your browser. You will see something
    similar to the following screenshot:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch03_03_goraud_phong.html`文件。您将看到以下截图类似的内容：
- en: '![](img/c2a15f52-eefd-4b83-bc06-f9a04d57fd49.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2a15f52-eefd-4b83-bc06-f9a04d57fd49.png)'
- en: 'The interface looks a little bit more elaborate than the diffuse lighting example.
    Let''s stop here for a moment to explain these widgets:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 界面看起来比漫射光照示例要复杂一些。让我们在这里稍作停留，解释一下这些小部件：
- en: 'Light Color (light diffuse term): As mentioned at the beginning of this chapter,
    we can have an example where our light is not white. We have included a color
    selector widget here for the light color so that you can experiment with different
    combinations.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光的颜色（光漫射项）：如本章开头所述，我们可以有一个例子，其中我们的光不是白色的。我们在这里包含了一个颜色选择器小部件，以便您可以尝试不同的光颜色组合。
- en: '**Light Ambient Term**: The light ambient property. In this example, this is
    a gray value: `r = g = b`.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光项**：光的环境属性。在这个例子中，这是一个灰度值：`r = g = b`。'
- en: 'Light Specular Term: The light specular property. This is a gray value: `r
    = g = b`.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜面反射项：光的镜面反射属性。这是一个灰度值：`r = g = b`。
- en: 'Translate X,Y,Z: The coordinates that define the light''s orientation.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: X,Y,Z坐标：定义光的方向的坐标。
- en: 'Sphere Color (material diffuse term): The material diffuse property. We have
    included a color selector so that you can try different combinations for the `r`,
    `g`, and `b` channels.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体颜色（材质漫射项）：材质的漫射属性。我们包含了一个颜色选择器，以便您可以尝试不同的`r`、`g`和`b`通道的组合。
- en: Material Ambient Term: The material ambient property. We have included it just
    for the sake of it. But as you might have noticed in the diffuse example, this
    vector is not always used.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质环境项：材质的环境属性。我们仅仅为了这个目的而包含它。但正如您在漫射示例中可能已经注意到的，这个向量并不总是被使用。
- en: 'Material Specular Term: The material specular property. This is a gray value :
    r = g = b.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质镜面反射项：材质的镜面反射属性。这是一个灰度值：r = g = b。
- en: Shininess: The specular exponential factor for the Goraud model.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亮度：Goraud模型的镜面反射指数因子。
- en: 'Background Color (`gl.clearColor`): This widget simply allows us to change
    the background color.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景颜色（`gl.clearColor`）：这个小部件仅仅允许我们更改背景颜色。
- en: 'The specular reflection in the Phong reflection model depends on the shininess,
    the specular property of the material, and the specular property of the light.
    When the specular property of the material is close to `0`, the material *loses *its
    specular property. Check this behavior with the widget provided:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Phong反射模型中的镜面反射取决于亮度、材质的镜面反射属性和光的镜面反射属性。当材质的镜面反射属性接近`0`时，材质*失去*其镜面反射属性。使用提供的小部件检查这种行为：
- en: What happens when the specularity of the material is low and the shininess is
    high?
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当材质的镜面反射低而亮度高时会发生什么？
- en: What happens when the specularity of the material is high and the shininess
    is low?
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当材质的镜面反射高而亮度低时会发生什么？
- en: Using the widgets, try different combinations for the light and material properties.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些小部件，尝试不同的光和材质属性组合。
- en: '***What just happened?***'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We saw how the different parameters of the Phong lighting model interact with
    each other.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了Phong光照模型的不同参数是如何相互作用的。
- en: We modified the light orientation, the properties of the light, and the material
    to observe different behaviors of the Phong lighting model.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了光的方向、光的属性和材质，以观察Phong光照模型的不同行为。
- en: 'Unlike the Lambertian reflection model, the Goraud lighting model has two extra
    terms: the ambient and specular components. We saw how these parameters affect
    the scene.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与朗伯反射模型不同，Goraud光照模型有两个额外的项：环境光和镜面分量。我们看到了这些参数如何影响场景。
- en: Just like the Lambertian reflection model, the Phong reflection model obtains
    the vertex color in the vertex shader. This color is interpolated in the fragment
    shader to obtain the final pixel color. This is because, in both cases, we are
    using Goraud interpolation. Let's now move the heavy processing to the fragment
    shader and study how we implement the Phong interpolation method.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像朗伯反射模型一样，Phong反射模型在顶点着色器中获取顶点颜色。这个颜色在片段着色器中插值以获得最终的像素颜色。这是因为，在这两种情况下，我们都在使用Goraud插值。现在，让我们将繁重的处理移到片段着色器，并研究我们如何实现Phong插值方法。
- en: Phong Shading
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phong着色
- en: Unlike the Goraud interpolation, where we calculated the final color for each
    vertex, the Phong interpolation calculates the final color for every fragment.
    This means that the calculation of the ambient, diffuse, and specular terms in
    the Phong model are performed in the fragment shader instead of the vertex shader.
    As you can imagine, this is computationally more intensive than performing a simple
    interpolation like in the two previous scenarios where we were using Goraud interpolation.
    However, we obtain a scene that seems more realistic.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与Goraud插值不同，在那里我们为每个顶点计算了最终颜色，Phong插值计算每个片段的最终颜色。这意味着Phong模型中环境、漫反射和镜面项的计算是在片段着色器中而不是在顶点着色器中进行的。正如你可以想象的那样，这比在前两个场景中使用Goraud插值进行简单插值计算要复杂得多。然而，我们得到了一个看起来更逼真的场景。
- en: After this translation, you may be wondering what is left for the vertex shader
    to do. Well, in this case, we will create varyings that will allow us to do all
    of the calculations in the fragment shader. For example, the vertex normals are
    a great fit.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次翻译之后，你可能想知道顶点着色器还剩下什么要做。嗯，在这种情况下，我们将创建变量，这将使我们能够在片段着色器中完成所有计算。例如，顶点法线是一个很好的选择。
- en: 'Whereas before we had a normal per vertex, now we need to generate a normal
    for every pixel so that we can calculate the Lambert coefficient for each fragment.
    We do so by interpolating the normals that we pass to the fragment shader. Nevertheless,
    the code is very simple. All we need to know is how to create a varying that stores
    the normal for the vertex we are processing in the vertex shader and to obtain
    the interpolated value in the fragment shader (courtesy of ESSL). That''s all!
    Conceptually, this is represented in the following diagram:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 而之前我们有一个每个顶点的法线，现在我们需要为每个像素生成一个法线，以便我们可以计算每个片段的朗伯系数。我们通过插值传递给片段着色器的法线来实现这一点。尽管如此，代码非常简单。我们只需要知道如何在顶点着色器中创建一个存储我们正在处理的顶点法线的变量，并在片段着色器中获取插值值（归功于ESSL）。就是这样！从概念上讲，这体现在以下图中：
- en: '![](img/4b90323c-0e88-4abf-b4c1-268eb87b2376.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b90323c-0e88-4abf-b4c1-268eb87b2376.png)'
- en: 'Now, let''s take a look at the vertex shader under Phong shading:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Phong着色下的顶点着色器：
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unlike our examples with the Goraud interpolation, the vertex shader looks
    really simple. There is no final color calculation and we are using two varyings
    to pass information to the fragment shader. The fragment shader will now look
    like the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用Goraud插值的例子不同，顶点着色器看起来非常简单。没有最终的色彩计算，我们使用两个变量将信息传递到片段着色器。现在片段着色器将看起来如下：
- en: '[PRE36]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we pass vectors as varyings, it is possible that they denormalize in the
    interpolation step. Therefore, you may have noticed that both `vNormal` and `vEyeVector` are
    normalized again in the fragment shader.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将向量作为变量传递时，它们在插值步骤中可能会反归一化。因此，你可能已经注意到，在片段着色器中，`vNormal`和`vEyeVector`都被再次归一化了。
- en: As we mentioned before, under Phong lighting, the Lambertian reflection model
    can be seen as a Phong reflection model where the ambient and specular components
    are set to `0`. Therefore, we will only cover the general case in the next section
    where we will see what the sphere scene looks like when using Phong shading and
    Phong lighting combined.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在Phong光照下，朗伯反射模型可以看作是一个Phong反射模型，其中环境光和镜面分量被设置为`0`。因此，在下一节中，我们将只介绍一般情况，我们将看到当使用Phong着色和Phong光照结合时球面场景看起来是什么样子。
- en: 'Time for Action: Phong Shading with Phong Lighting'
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：使用Phong光照的Phong着色
- en: 'Let''s cover an example of implementing lighting using Phong shading:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用Phong着色实现光照的例子：
- en: 'Open the `ch03_04_sphere_Phong.html` file in your browser. The page will look
    similar to the following screenshot:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch03_04_sphere_Phong.html`文件。页面将类似于以下截图：
- en: '![](img/55730d4f-55ca-408e-9829-021b13c0d1e8.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55730d4f-55ca-408e-9829-021b13c0d1e8.png)'
- en: The interface is very similar to the Goraud example's interface. As previously
    described, it is quite evident how the Phong shading combined with Phong lighting
    delivers a more realistic scene. Experiment with the controls widget to see the
    immediate result of this new lighting model.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 界面与Goraud示例的界面非常相似。正如之前所描述的，很明显Phong着色与Phong光照相结合可以产生更加逼真的场景。通过实验控制部件来查看这种新的光照模型的即时效果。
- en: '***What just happened?***'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: We have seen Phong shading and Phong lighting in action. We explored the source
    code for the vertex and fragment shaders. We also modified the different parameters
    of the model and observed the immediate effect of the changes on the scene.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Phong着色和Phong光照的实际应用。我们探索了顶点着色器和片段着色器的源代码。我们还修改了模型的不同参数，并观察了这些变化对场景的即时影响。
- en: Back to WebGL
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到WebGL
- en: It’s time to go back to our JavaScript code, but we now need to consider how
    to close the gap between our JavaScript code and our ESSL code. First, we need
    to take a look at how we create a **program** using our WebGL context. Please
    remember that we refer to both the vertex shader and fragment shader as the program.
    Second, we need to know how to initialize attributes and uniforms.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候回到我们的JavaScript代码了，但现在我们需要考虑如何弥合JavaScript代码和ESSL代码之间的差距。首先，我们需要看看我们如何使用WebGL上下文创建一个**程序**。请记住，我们将顶点着色器和片段着色器都称为程序。其次，我们需要知道如何初始化属性和统一变量。
- en: 'Let''s take a look at the structure of the web apps we have developed so far:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们迄今为止开发的Web应用程序的结构：
- en: '![](img/6a485ddc-b5d6-43af-a00a-db620262e0a0.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a485ddc-b5d6-43af-a00a-db620262e0a0.png)'
- en: Each application has a vertex shader and a fragment shader embedded in the web
    page. In addition, there is a script section where we write all of our WebGL code.
    Finally, we have the HTML code that defines the page components, such as titles
    and the location of the widgets and the `canvas`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都嵌入在网页中的顶点着色器和片段着色器。此外，还有一个脚本部分，我们在这里编写所有的WebGL代码。最后，我们有HTML代码定义页面组件，如标题、小部件的位置以及`canvas`的位置。
- en: In the JavaScript code, we are calling the `init` function on the `onload` event
    of the web page. This is the entry point for our application. The first thing
    that `init` does is obtain a WebGL context for the `canvas` within `initProgram`,
    and then calls a series of functions that initialize the program, the WebGL buffers,
    and the lights. Finally, it gets into a render loop where every time that the
    loop goes off, the `draw` function is invoked.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript代码中，我们在网页的`onload`事件上调用`init`函数。这是我们应用程序的入口点。`init`首先做的事情是为`initProgram`中的`canvas`获取一个WebGL上下文，然后调用一系列初始化程序、WebGL缓冲区和灯光的函数。最后，它进入一个渲染循环，每次循环结束时调用`draw`函数。
- en: In this section, we will take a closer look at the `initProgram` and `initLights`
    functions. `initProgram` allows us to create and compile an ESSL program while
    `initLights` allows us to initialize and pass values to the uniforms defined in
    the programs. It is inside `initLights` where we will define the light's position,
    direction, and color components (ambient, diffuse, and specular) as well as default
    values for material properties.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地查看`initProgram`和`initLights`函数。`initProgram`允许我们创建和编译一个ESSL程序，而`initLights`允许我们初始化并将值传递给程序中定义的统一变量。在`initLights`中，我们将定义光的位置、方向和颜色分量（环境、漫射和镜面）以及材料属性的默认值。
- en: Creating a Program
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个程序
- en: 'To start, open up `ch03_05_wall.html` in an editor. Let''s take a step-by-step
    look at `initProgram`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在一个编辑器中打开`ch03_05_wall.html`。让我们一步一步地看看`initProgram`：
- en: '[PRE37]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we retrieve a WebGL context, as we''ve seen in previous chapters. Then,
    we use the `utils.getShader` utility function to retrieve the contents of the
    vertex shader and the fragment shader:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索一个WebGL上下文，就像我们在前面的章节中看到的那样。然后，我们使用`utils.getShader`实用函数检索顶点着色器和片段着色器的内容：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The program''s creation occurs in the following lines:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的创建发生在以下几行：
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we have used several functions provided by the WebGL context. These include
    the ones shown in the following table:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了WebGL上下文提供的几个函数。以下表格显示了这些函数：
- en: '| **WebGL Function** | **Description** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **WebGL函数** | **描述** |'
- en: '| `createProgram()` | Creates a new program (*program*). |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `createProgram()` | 创建一个新的程序（*程序*）。 |'
- en: '| `attachShader(program, shader)` | Attaches a shader to the current program.
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `attachShader(program, shader)` | 将着色器附加到当前程序。 |'
- en: '| `linkProgram(program)` | Creates executable versions of the vertex and fragment
    shaders that are passed to the GPU. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `linkProgram(program)` | 创建传递给GPU的顶点和片段着色器的可执行版本。 |'
- en: '| `getProgramParameter(program, parameter)` | This is part of the WebGL state-machine
    query mechanism. It allows you to query the program parameters. We use this function
    to verify whether the program has been successfully linked. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `getProgramParameter(program, parameter)` | 这是WebGL状态机查询机制的一部分。它允许你查询程序参数。我们使用这个函数来验证程序是否已成功链接。
    |'
- en: '| `useProgram(program)` | It will load the program onto the GPU if the program
    contains valid code (that is, it has been successfully linked). |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `useProgram(program)` | 如果程序包含有效的代码（即，它已成功链接），则将程序加载到GPU上。 |'
- en: 'Finally, we create a **mapping** between JavaScript variables and the program
    attributes and uniforms:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在JavaScript变量和程序属性以及统一变量之间创建了一个**映射**：
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Instead of creating several JavaScript variables here (one per program `attribute`
    or `uniform`), we are attaching properties to the `program` object. This does
    not have anything to do with WebGL. It is just a convenience step to keep all
    of our JavaScript variables as part of the program object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在这里创建几个JavaScript变量（每个程序`属性`或`统一变量`一个），我们正在将属性附加到`program`对象上。这与WebGL无关。这只是将所有我们的JavaScript变量作为程序对象的一部分的一个方便步骤。
- en: WebGL ProgramsSince we are attaching many of the important variables to our
    WebGL program, you may be wondering why we don't attach it to our WebGL context
    rather than the program. In our example, we're using a single **program** because
    our example is small. As WebGL applications grow, you may find that you have several
    programs that you switch throughout your application with the `gl.useProgram` function.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL程序由于我们将许多重要变量附加到我们的WebGL程序中，你可能想知道为什么我们不将其附加到WebGL上下文而不是程序。在我们的示例中，我们使用单个**程序**，因为我们的示例很小。随着WebGL应用程序的增长，你可能会发现你有几个程序，你通过`gl.useProgram`函数在应用程序中切换。
- en: 'All of this information pertains to `initProgram`. Here, we have used the following
    WebGL API functions:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都与`initProgram`相关。在这里，我们使用了以下WebGL API函数：
- en: '| **WebGL Function** | **Description** |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **WebGL函数** | **描述** |'
- en: '| `getAttribLocation(program, name)` | This function receives the current program
    object and a string that contains the name of the attribute that needs to be retrieved.
    This function then returns a **reference** to the respective **attribute**. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `getAttribLocation(program, name)` | 这个函数接收当前的程序对象和一个包含需要检索的属性名称的字符串。然后，该函数返回相应的属性的**引用**。
    |'
- en: '| `getUniformLocation(program, name)` | This function receives the current
    program object and a string that contains the name of the uniform that needs to
    be retrieved. This function then returns a **reference** to the respective **uniform**.
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `getUniformLocation(program, name)` | 这个函数接收当前的程序对象和一个包含需要检索的统一变量名称的字符串。然后，该函数返回相应的统一变量的**引用**。
    |'
- en: Using this mapping, we can initialize the uniforms and attributes from our JavaScript
    code, as we will see in the next section.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种映射，我们可以从JavaScript代码中初始化统一变量和属性，正如我们将在下一节中看到的。
- en: Another addition to WebGL 2 is an increasingly optimized approach for getting
    item locations from the vertex shader. In our example, we use `getAttribLocation` and `getUniformLocation` for
    getting the locations of these items. If you inspect their return values, you'll
    see that they return *whole numbers*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL 2的另一个新增功能是从顶点着色器获取项目位置的越来越优化的方法。在我们的示例中，我们使用`getAttribLocation`和`getUniformLocation`来获取这些项目的位置。如果你检查它们的返回值，你会看到它们返回**整数**。
- en: Whole numbers are simply the numbers 0, 1, 2, 3, 4, 5, ... (and so on).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 整数仅仅是数字0, 1, 2, 3, 4, 5, ...（等等）。
- en: Convention dictates that with large 3D applications, you can leverage tested
    design patterns and data structures to organize your code, which may include organizing
    shader resources in a predetermined or programmatic order.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，对于大型3D应用程序，你可以利用经过测试的设计模式和数据结构来组织你的代码，这可能包括以预定的或程序化的顺序组织着色器资源。
- en: 'One example would be to leverage the **layout qualifier **to look up resource
    locations. Here''s a simplified example from [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml),
    *Rendering*, where we looked up and enabled both `aVertexPosition` and `aVertexColor` using `getAttribLocation`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And here is the associated vertex shader:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These would turn into the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here is the updated vertex shader:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, it's a subtle change where we define the locations using indices
    within the vertex shader and simply enable the items using those indices.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Performance HitsEvery time we need to look up or set shader values from the
    JavaScript context, it comes at a performance cost. Because of this, we should
    always be careful of how often we perform such operations.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Although the layout qualifier is optimal, we will continue leveraging the traditional
    variable and definition lookup throughout this book, given that it’s more readable
    and requires less overhead.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Layout QualifiersFor more information on layout and other qualifiers, please
    visit [https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)](https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Attributes and Uniforms
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have compiled and installed the program, the next step is to initialize
    the attributes and variables. We will initialize our uniforms using the `initLights` function:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, you can see that we’re using the references obtained with `getUniformLocation` (we
    did this in `initProgram`).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the functions that the WebGL API provides to set and get uniform
    values:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebGL Function** | **Description** |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: '| `uniform[1234][fi]` | Specifies 1-4 `float` or `int` values of a uniform
    variable. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| `uniform[1234][fi]v` | Specifies the value of a uniform variable as an array
    of 1-4 `float` or `int` values. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| `getUniform(program)` | Retrieves the contents of a uniform variable. The
    reference parameter has been previously obtained with `getUniformLocation`. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: 'In [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*, we
    learned that a four-step process is required to initialize and use attributes.
    Recall that we do the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Bind a VBO.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point an attribute to the currently-bound VBO.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the attribute.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbind the VBO.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The key piece here is step *2*. We do this with the following instruction:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you check out the `ch03_05_wall.html` example, you will see that we do this
    inside the `draw` function:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Bridging the Gap Between WebGL and ESSL
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now useful to test out how we integrate our ESSL program with our WebGL
    code by taking the code from `ch03_05_wall.html` and making some modifications.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a wall composed of the sections A, B, and C, and you are facing section
    B with a flashlight in your hand (frontal view). Intuitively, you know that section
    A and section C will be darker than section B. This fact can be modeled by starting
    at the color of the center of section B and darkening the color of the surrounding
    pixels as we move away from the center:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下由部分A、B和C组成的墙壁，而你手持手电筒面对部分B（正面视角）。直观上，你知道部分A和部分C会比部分B暗。这一事实可以通过从部分B的中心颜色开始，随着我们远离中心而逐渐变暗周围像素的颜色来模拟：
- en: '![](img/1e344c4e-1d5b-4f95-8d55-6eb1b1e69d09.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e344c4e-1d5b-4f95-8d55-6eb1b1e69d09.png)'
- en: 'Let''s summarize the code we need to cover:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们需要覆盖的代码：
- en: The ESSL program containing the vertex and fragment shaders. For the wall, we
    will select Goraud shading with a Diffuse/Lambertian reflection model.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含顶点和片段着色器的ESSL程序。对于墙壁，我们将选择Goraud着色，并使用漫反射/朗伯反射模型。
- en: 'The `initProgram` function. We need to make sure that we map all of the attributes
    and uniforms that we defined in the ESSL code, including the normals:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initProgram`函数。我们需要确保我们映射了在ESSL代码中定义的所有属性和uniforms，包括法线：'
- en: '[PRE48]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `initBuffers` function. Here, we need to create our geometry. We can represent
    the wall with eight vertices that define six triangles, such as the ones shown
    in the previous diagram. In `initBuffers`, we will apply what we learned in the
    previous chapters to set up the appropriate VAOs and buffers. This time, we need
    to set up an additional buffer: the VBO that contains information about normals.
    The code to set up the normals VBO looks like this:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initBuffers`函数。在这里，我们需要创建我们的几何形状。我们可以用定义六个三角形的八个顶点来表示墙壁，就像之前图中所示的那样。在`initBuffers`中，我们将应用之前章节中学到的知识来设置适当的VAOs和缓冲区。这次，我们需要设置一个额外的缓冲区：包含法线信息的VBO。设置法线VBO的代码如下所示：'
- en: '[PRE49]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To calculate the normals, we use the `calculateNormals(vertices, indices)` helper
    function. You can find this method in the `common/js/utils.js` file.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了计算法线，我们使用`calculateNormals(vertices, indices)`辅助函数。你可以在`common/js/utils.js`文件中找到这个方法。
- en: '`initLights`: We covered this function already and know how to do that.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initLights`：我们已经讨论过这个函数，并且知道如何操作。'
- en: 'There’s only one minor but important change to make inside the `draw` function.
    We need to make sure that the VBOs are bound before we use `drawElements`. The
    code to do that looks like this:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`draw`函数中，我们需要进行一个微小但重要的更改。我们需要确保在调用`drawElements`之前绑定VBOs。执行此操作的代码如下所示：
- en: '[PRE50]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the following section, we will explore the functions that we just described
    for building and illuminating the wall.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨我们刚刚描述的用于构建和照亮墙壁的功能。
- en: 'Time for Action: Working on the Wall'
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：处理墙壁
- en: 'Let''s cover an example showcasing the preceding concepts in action:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来展示前面概念的实际应用：
- en: 'Open the `ch03_05_wall.html` file in your browser. You will see something similar
    to the following screenshot:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch03_05_wall.html`文件。你会看到以下截图类似的内容：
- en: '![](img/74054bf4-6df6-458c-a4a4-159f4d9e1db1.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/74054bf4-6df6-458c-a4a4-159f4d9e1db1.png)'
- en: Open the `ch03_05_wall.html` file in a code editor.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开`ch03_05_wall.html`文件。
- en: Go to the vertex shader. Make sure that you identify the attributes, uniforms,
    and varyings that are declared there.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往顶点着色器。确保你识别出那里声明的属性、uniforms和varyings。
- en: Go to the fragment shader. Notice that there are no attributes here, because
    attributes are exclusive to the vertex shader.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往片段着色器。注意这里没有属性，因为属性仅限于顶点着色器。
- en: Vertex and Fragment Shaders
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点和片段着色器
- en: You can find these shaders inside the script tags with the appropriate ID names.
    For example, the vertex shader can be found inside `<script id="vertex-shader"
    type="x-shader/x-vertex">`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在带有适当ID名称的脚本标签内找到这些着色器。例如，顶点着色器可以在`<script id="vertex-shader" type="x-shader/x-vertex">`内找到。
- en: Go to the `init` function. Verify that we are calling `initProgram` and `initLights` there.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`init`函数。确保我们在那里调用`initProgram`和`initLights`。
- en: Go to `initProgram`. Make sure that you understand how the program is built
    and how we obtain references to attributes and uniforms.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`initProgram`。确保你理解程序是如何构建的，以及我们是如何获得属性和uniforms的引用的。
- en: 'Go to `initLights`. Update the values of the uniforms, as shown here:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`initLights`。更新uniforms的值，如下所示：
- en: '[PRE51]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that one of the updates consists of changing from `uniform4f` to `uniform4fv` for
    the `uMaterialDiffuse` uniform.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，其中一项更新是将`uniform4f`更改为`uniform4fv`，用于`uMaterialDiffuse`uniform。
- en: Save the file.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Open it again (or reload it) in your browser. What happened?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中再次打开它（或重新加载）。发生了什么？
- en: Let's do something a bit more interesting. We are going to create a key listener
    so that every time we hit a key, the light orientation changes.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们做一些更有趣的事情。我们将创建一个键监听器，以便每次我们按下键时，光线方向都会改变。
- en: 'Right after the `initLights` function, write the following code:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initLights`函数之后，编写以下代码：
- en: '[PRE52]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This function processes the arrow keys and changes the light direction accordingly.
    There’s a bit of trigonometry (`Math.cos`, `Math.sin`) involved, but we are simply
    converting the angles (azimuth and elevation) into Cartesian coordinates.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数处理箭头键并相应地改变光线方向。这里涉及到一点三角学（`Math.cos`，`Math.sin`），但我们只是将角度（方位角和仰角）转换为笛卡尔坐标。
- en: 'Please note that we get the current light direction by using the following
    function:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们通过以下函数获取当前的光线方向：
- en: '[PRE53]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After processing the key strokes, we can save the updated light direction with
    the following code:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完按键操作后，我们可以使用以下代码保存更新后的光线方向：
- en: '[PRE54]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the work and reload the web page:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存工作并重新加载网页：
- en: '![](img/b95d6df1-1a53-4f15-b512-2f428a4dd01c.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b95d6df1-1a53-4f15-b512-2f428a4dd01c.png)'
- en: Use the arrow keys to change the light direction.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键来改变光线方向。
- en: If you have any problems during the development of this exercise or just want
    to verify the final result, please check the `ch03_06_wall_final.html` file, which
    contains the completed exercise.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在开发这个练习过程中遇到任何问题或只是想验证最终结果，请检查`ch03_06_wall_final.html`文件，其中包含完成的练习。
- en: '***What just happened?***'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: In this exercise, we created a keyboard listener that allows us to update the
    light's orientation so that we can move it around the wall and see how it reacts
    to surface normals. We also saw how the vertex shader and fragment shader input
    variables are declared and used. We learned how to build a program by reviewing
    the `initProgram` function. We also learned about initializing uniforms in the `initLights` function.
    Finally, we studied the `getUniform` function to retrieve the current value of
    a uniform. Although we haven't covered the examples entirely, this exercise was
    intended to familiarize you with vertex and fragment shaders so that you can implement
    various light-shading and reflection models.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个键盘监听器，允许我们更新光线的方向，以便我们可以将其在墙上移动并观察它如何响应表面法线。我们还看到了如何声明和使用顶点着色器和片段着色器的输入变量。我们通过回顾`initProgram`函数学习了如何构建程序。我们还学习了在`initLights`函数中初始化统一变量的方法。最后，我们研究了`getUniform`函数来检索统一变量的当前值。尽管我们没有完全涵盖示例，但这个练习的目的是让你熟悉顶点着色器和片段着色器，以便你可以实现各种光照和反射模型。
- en: More on Lights: Positional Lights
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于光线更多内容：位置性光线
- en: 'Before finishing this chapter, let''s revisit the topic of lights. So far,
    for the purpose of our examples, we’ve assumed that our light source is infinitely
    far away from the scene. This assumption allows us to model the light rays as
    being parallel to each other. An example of this is sunlight. These lights are *directional
    lights*. Now, we are going to consider a case where the light source is relatively
    close to the object it needs to illuminate. Think, for example, of a desk lamp
    illuminating the document you’re reading. These lights are *positional lights*:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这一章之前，让我们回顾一下光线的话题。到目前为止，为了我们示例的目的，我们假设我们的光源距离场景无限远。这个假设允许我们将光线建模为相互平行。一个例子是阳光。这些光线是**方向性光线**。现在，我们将考虑一个光源相对靠近它需要照亮的对象的情况。例如，想象一下台灯照亮你正在阅读的文件。这些光线是**位置性光线**：
- en: '![](img/b25e6328-5f13-4c4f-a540-f094b2197840.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b25e6328-5f13-4c4f-a540-f094b2197840.png)'
- en: As we experienced before, when working with directional lights, only one variable
    is required. This is the light direction we represented in the `uLightDirection` uniform.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所经历的，当处理方向性光线时，只需要一个变量。这就是我们在`uLightDirection`统一变量中表示的光线方向。
- en: In contrast, when working with positional lights, we need to know the location
    of the light. We can represent it by using a uniform that we will name `uLightPosition`.
    As is the case when using positional lights, the light rays here are not parallel
    to each other; as a result, we need to calculate each light ray separately. We
    will do this by using a varying that we will name `vLightRay`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当处理位置性光线时，我们需要知道光线的位置。我们可以通过一个名为`uLightPosition`的统一变量来表示它。正如使用位置性光线时的情况一样，这里的射线不是平行的；因此，我们需要单独计算每条光线。我们将通过一个名为`vLightRay`的可变变量来完成这项工作。
- en: In the next section, we will investigate how a positional light interacts with
    a scene.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究位置光源如何与场景交互。
- en: 'Time for Action: Positional Lights in Action'
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：位置光源的实际应用
- en: 'Let''s cover an example of positional lights in action:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个位置光源在实际应用中的例子：
- en: 'Open the `ch03_07_positional_lighting.html` file in your browser. The page
    will look similar to the following screenshot:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`ch03_07_positional_lighting.html`文件。页面看起来将与以下截图类似：
- en: '![](img/c52b4a9d-4cd9-4133-9ff9-2a84444d671f.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c52b4a9d-4cd9-4133-9ff9-2a84444d671f.png)'
- en: The interface of this exercise is very simple. You can use the controls widget
    to interact with the scene. Unlike in previous exercises, the **Translate X**,
    **Y**, and **Z** sliders do not represent light direction here. Instead, they
    allow us to set the light source position. Go ahead and play with them.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本练习的接口非常简单。您可以使用控件小部件与场景进行交互。与之前的练习不同，**平移X**、**Y**和**Z**滑块在这里不代表光的方向。相反，它们允许我们设置光源位置。试试看吧。
- en: For clarity, a little sphere representing the position of the light source has
    been added to the scene to visualize the light source, but this is not generally
    required.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清晰起见，场景中添加了一个表示光源位置的球体，以可视化光源，但这通常不是必需的。
- en: What happens when the light source is located on the surface of the cone versus
    on the surface of the sphere?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当光源位于圆锥表面与球体表面相比时会发生什么？
- en: What happens when the light source is inside the sphere?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当光源位于球体内部时会发生什么？
- en: 'Let''s take a look at the way we calculate the light rays by inspecting the
    vertex shader in the source code. The light ray calculation is performed in the
    following two lines of code:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过检查源代码中的顶点着色器来了解我们计算光线的的方式。光线的计算在以下两行代码中执行：
- en: '[PRE55]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first line allows us to obtain a transformed light position by multiplying
    the Model-Viewmatrix by the `uLightPosition` uniform. If you review the code in
    the vertex shader, you’ll note that we also use this matrix for calculating transformed
    vertices and normals. We will discuss these matrix operations in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, we can just assume that this is necessary to obtain transformed
    vertices, normals, and light positions whenever we move the camera. To test this,
    modify this line by removing the matrix from the equation so that the line looks
    like the following:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行允许我们通过将模型视图矩阵乘以`uLightPosition`统一变量来获得变换后的光源位置。如果您回顾顶点着色器中的代码，您会注意到我们还将此矩阵用于计算变换后的顶点和法线。我们将在[第4章](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml)中讨论这些矩阵操作，*相机*。现在，我们只需假设这是在移动相机时获取变换后的顶点、法线和光源位置所必需的。为了测试这一点，修改这一行，从方程中删除矩阵，使其看起来像以下这样：
- en: '[PRE56]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Save the file and launch it in your browser. What is the effect of not transforming
    the light position? What you can see is that the camera is moving, but the light
    source position is not being updated!
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中运行它。不变换光源位置会有什么效果？您可以看到的是，相机在移动，但光源位置没有更新！
- en: We can see that the light ray is calculated as the vector that reaches from
    the transformed light position (light) to the vertex position.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到光线被计算为从变换后的光源位置（光源）到顶点位置的向量。
- en: 'Thanks to the interpolation of varyings that is provided by ESSL, we automatically
    obtain all the light rays per pixel in the fragment shader:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了ESSL提供的插值变量，我们在片段着色器中自动获得每个像素的所有光线：
- en: '![](img/763b7af0-fe64-4dd0-9675-e29998fac50d.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/763b7af0-fe64-4dd0-9675-e29998fac50d.png)'
- en: '***What just happened?***'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We studied the difference between directional lights and positional lights.
    We also investigated the importance of the Model-View matrix for the correct calculation
    of positional lights when the camera is moving. Finally, we modeled the procedure
    to obtain per-vertex light rays.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了方向光源和位置光源之间的区别。我们还调查了当相机移动时，模型视图矩阵对正确计算位置光源的重要性。最后，我们建模了获取每顶点光线的程序。
- en: Virtual Showroom Example
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟展厅示例
- en: 'In this chapter, we’ve included an example of the Nissan GTR exercise we saw
    in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*. This
    time, we’ve used a Phong lighting model with a positional light to illuminate
    the scene. You can find this example in `ch03_08_showroom.html`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们包括了我们在[第2章](d2019a49-9e84-448c-8799-e296187476d1.xhtml)中看到的Nissan GTR练习示例，*渲染*。这次，我们使用位置光源照亮场景的Phong光照模型。您可以在`ch03_08_showroom.html`中找到这个示例：
- en: '![](img/15af1d35-37ee-430c-b04b-f39dac44efed.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15af1d35-37ee-430c-b04b-f39dac44efed.png)'
- en: Here, you can experiment with different light positions. Pay special attention
    to the nice specular reflections you obtain thanks to the specularity property
    of the car and the shininess of the light.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以尝试不同的光照位置。特别注意由于汽车的光泽特性和光照的亮度，你将获得漂亮的镜面反射。
- en: Architecture Updates
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构更新
- en: 'Let''s cover some useful functions that we can refactor to use in later chapters:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一些有用的函数，这些函数我们可以重构以在后续章节中使用：
- en: 'We''ve seen how to create and compile a program using shaders. We''ve also
    covered how to load and reference attributes and uniforms. Let''s include a module
    that abstracts away this low-level functionality with a simpler API:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用着色器创建和编译程序，我们也介绍了如何加载和引用属性和统一变量。让我们包含一个模块，它通过一个更简单的API抽象出这种低级功能：
- en: '[PRE57]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Like we did previously, we will include this script tag in the `<head>` of the
    HTML document. Be sure to include it after the other module scripts, since they
    may use the libraries and earlier modules we've covered.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们将把这个脚本标签包含在HTML文档的`<head>`部分。确保在包含其他模块脚本之后包含它，因为它们可能使用我们已覆盖的库和早期模块。
- en: 'Let''s update our `initProgram` function inside of `ch03_08_showroom.html` so
    that we can use this module:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新`ch03_08_showroom.html`中的`initProgram`函数，以便我们可以使用这个模块：
- en: '[PRE58]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: All of the heavy lifting of creating a program, compiling shaders, and attaching
    uniforms and attributes to our program is done for us.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建程序、编译着色器以及将统一变量和属性附加到我们的程序的重任都由我们来完成。
- en: 'Let''s inspect the `Program` class source code. Most of the operations should
    look familiar to you:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查`Program`类的源代码。大部分操作应该对你来说都很熟悉：
- en: '[PRE59]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We initialize `Program` by passing in a reference to the `gl` context, the vertex,
    and the fragment shader `id`.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过传递对`gl`上下文、顶点和片段着色器`id`的引用来初始化`Program`。
- en: We load and reference the `attributes` and `uniforms` programs by supplying
    the `program` instance with the array of attributes and uniforms.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过向`program`实例提供属性和统一变量的数组来加载和引用`attributes`和`uniforms`程序。
- en: The other methods are helper functions that we'll use in later chapters.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他方法是我们将在后续章节中使用的辅助函数。
- en: You can find an example of these changes in `ch03_09_showroom-final.html`.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在`ch03_09_showroom-final.html`中找到一个这些更改的例子。
- en: 'You may have caught two additional utils methods used throughout this chapter:
    `normalizeColor` and `denormalizeColor`. These two methods simply normalize colors
    from range `[0-255]` to `[0-1]` or denormalize from `[0-1]` to `[0-255]`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能注意到了在本章中使用的两个额外的实用方法：`normalizeColor`和`denormalizeColor`。这两个方法只是将颜色从范围`[0-255]`归一化到`[0-1]`或从`[0-1]`反归一化到`[0-255]`：
- en: '[PRE60]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we learned in this chapter:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章我们学到了什么：
- en: We learned in detail what light sources, materials, and normals are, and how
    these elements interact to illuminate a WebGL scene.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们详细学习了光源、材料和法线是什么，以及这些元素如何相互作用来照亮WebGL场景。
- en: We covered the differences between a shading method and a lighting model.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了着色方法和光照模型之间的区别。
- en: We studied the basics of the Goraud and Phong shading methods, along with the
    Lambertian and Phong lighting models. With the help of several examples, we also
    covered how to implement these shading and lighting models in code using ESSL,
    and how to communicate between the WebGL code and the ESSL code through attributes
    and uniforms.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了Goraud和Phong着色方法以及Lambertian和Phong光照模型的基础知识。通过几个示例，我们还介绍了如何使用ESSL在代码中实现这些着色和光照模型，以及如何通过属性和统一变量在WebGL代码和ESSL代码之间进行通信。
- en: We can use the vertex shader and the fragment shader to define a lighting model
    for our 3D scene.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用顶点着色器和片段着色器来为我们的3D场景定义光照模型。
- en: We covered many of these operations through the lens of the latest and greatest
    techniques provided to us in WebGL 2's updated shading language.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过WebGL 2更新的着色语言提供的最新和最先进的技术，对这些操作进行了很多探讨。
- en: In the next chapter, we will expand on using matrices in ESSL so that we can
    learn how to use them to represent and move our viewpoint in a 3D scene.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展在ESSL中使用矩阵的内容，这样我们就可以学习如何使用它们在3D场景中表示和移动我们的视点。
