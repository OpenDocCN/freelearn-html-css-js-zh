- en: Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered WebGL's rendering pipeline, defining geometries,
    passing data to the GPU, drawing types, and leveraging AJAX to asynchronously
    load external assets. Although we briefly covered shaders and their role in creating
    a WebGL application, we will go into more detail in this chapter and leverage the
    vertex and fragment shaders to create a lighting model for our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders allow us to define a mathematical model that governs how our scene is
    lit. To learn how to implement shaders, we will study different algorithms and
    see examples of their application. A basic knowledge of linear algebra will be
    really useful to help you understand the contents of this chapter. We will use a
    JavaScript library that handles most of the vector and matrix operations, so you
    do not need to worry about the mathematical operations. Nonetheless, your overall
    success depends on a strong conceptual understanding of the linear algebra operations
    that we will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about light sources, normals, and materials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the difference between shading and lighting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Goraud and Phong shading methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Lambertian and Phong lighting models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define and use uniforms, attributes, and varyings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with ESSL, the shading language for WebGL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss relevant WebGL API methods that relate to shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue our analysis of WebGL as a state machine and describe the attributes
    relevant to shaders that can be set and retrieved from the state machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights, Normals, and Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the real world, we see objects because they reflect light. The illumination
    of an object depends on its position relative to the light source, surface orientation,
    and its material composition. In this chapter, we will learn how to combine these
    three elements in WebGL to model different illumination schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09bf202d-a455-4a83-ab7d-c86e13ce91e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Positional Versus Directional Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Light sources can be **positional** or **directional**. A light source is called
    positional when its location will affect how the scene is lit. For instance, a
    lamp inside a room is a positional light source. Objects far from the lamp will
    receive very little light and may even appear obscure. In contrast, directional
    lights are lights that produce the same luminous result, regardless of their position.
    For example, the light from the sun will illuminate all objects in a terrestrial
    scene, regardless of their distance from the sun. This is because the sun is so
    far away that all light rays are considered parallel when they intersect the surface
    of an object. Directional lighting assumes that the light is coming uniformly
    from one direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fa02bc7-d762-4a9a-a955-8e34745c481e.png)'
  prefs: []
  type: TYPE_IMG
- en: A positional light is modeled by a point in space, while a directional light is
    modeled with a vector that indicates its direction. It is common to use a normalized
    vector for this purpose, given that this simplifies mathematical operations. Also,
    it is generally the case that computing directional lighting is actually simpler
    and less computationally expensive than positional lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Normals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Normals** are vectors that are perpendicular to the surface we want to illuminate.
    Normals represent the orientation of the surface and are therefore critical to
    modeling the interaction between a light source and the object. Given that each
    vertex has an associated normal vector, we can use the cross product to calculate
    normals.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-ProductBy definition, the cross-product of vectors `A` and `B` will be
    a vector perpendicular to both vectors `A` and `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break this down. If we have the triangle conformed by vertices `p0`, `p1`,
    and `p2`, we can define the `v1` vector as `p1 - p0` and the `v2` vector as `p2
    - p0`. The normal is then obtained by calculating the `v1 x v2` cross-product.
    Graphically, this procedure looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cba4ae51-6cea-43a5-aa0e-9f6745103d12.png)'
  prefs: []
  type: TYPE_IMG
- en: We then repeat the same calculation for each vertex on each triangle. But, what
    about the vertices that are shared by more than one triangle? Each shared vertex
    normal will receive a contribution from each of the triangles in which the vertex
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that the `p1` vertex is shared by the `#1` and `#2` triangles,
    and that we have already calculated the normals for the vertices of the `#1` triangle.
    Then, we need to update the `p1` normal by adding up the calculated normal for `p1` on
    the `#2` triangle. This is a **vector sum**. Graphically, this looks similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e742957-704e-4e2a-870a-71261fdb16c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to lights, normals are generally normalized to facilitate mathematical
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL, the material of an object can be modeled by several parameters, including
    its color and texture. Material colors are usually modeled as triplets in the RGB (red,
    green, blue) space. Textures, on the other hand, correspond to images that are
    mapped onto the surface of the object. This process is usually called **texture
    mapping**. We will cover texture mapping in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lights, Normals, and Materials in the Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*, we
    discussed that WebGL buffers, attributes, and uniforms are used as input variables
    to the shaders, and that varyings are used to pass information between the vertex
    shader and the fragment shader. Let''s revisit the pipeline and see where lights,
    normals, and materials fit in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2b6c60-e7ac-4094-b712-f3785f985095.png)'
  prefs: []
  type: TYPE_IMG
- en: Normals are defined on a vertex-per-vertex basis; therefore, normals are modeled
    as a VBO and are mapped using an attribute, as shown in the preceding diagram.
    Note that attributes cannot be directly passed to the fragment shader. To pass
    information from the vertex shader to the fragment shader, we must use varyings.
  prefs: []
  type: TYPE_NORMAL
- en: Lights and materials are passed as uniforms. Uniforms are available to both
    the vertex shader and the fragment shader. This gives us a lot of flexibility
    to calculate our lighting model, because we can calculate how the light is reflected
    on a vertex-by-vertex basis (vertex shader) or on a fragment-per-fragment basis
    (fragment shader).
  prefs: []
  type: TYPE_NORMAL
- en: Program
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the vertex shader and fragment shader together are referred to
    as a **program**.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism and the Difference Between Attributes and Uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an important distinction to make between attributes and uniforms. When
    a draw call is invoked (using `drawArrays` or `drawElements`), the GPU will launch
    several copies of the vertex shader in parallel. Each copy will receive a different
    set of attributes. These attributes are drawn from the VBOs that are mapped onto
    the respective attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, all of the copies of the vertex shaders will receive the
    same uniforms – hence the name: uniform. In other words, uniforms can be seen
    as constants *per draw call*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3903b1a6-0105-4377-bc3c-c3fcfb5e7fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Once lights, normals, and materials are passed to the program, the next step
    is to determine which *shading* and *lighting* models we will implement. Let's
    investigate what this involves.
  prefs: []
  type: TYPE_NORMAL
- en: Shading Methods and Light-Reflection Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the terms *shading* and *lighting* are often ambiguously interchanged,
    they refer to two different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Shading refers to the type of *interpolation* that is performed to obtain the
    final color for every fragment in the scene. Later, we will explain how the type
    of shading determines where the final color is calculated – in the vertex shader
    or in the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Once the shading model is established, the lighting model determines *how* the
    normals, materials, and lights need to be combined to produce the final color.
    Since the equations for lighting models use the physical principles of light reflection,
    lighting models are also referred to as *reflection models*.
  prefs: []
  type: TYPE_NORMAL
- en: Shading/Interpolation Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze two basic types of interpolation methods: **Goraud** and **Phong** shading.
  prefs: []
  type: TYPE_NORMAL
- en: Goraud Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Goraud** interpolation method calculates the final color in the *vertex
    shader*. The vertex normals are used to perform this calculation. Then, using
    a varying variable, the final color for the vertex is passed to the fragment shader.
    Due to the automatic interpolation of varyings provided by the rendering pipeline,
    each fragment will have a color that is the result of interpolating the colors
    of the enclosing triangle for each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Varying Interpolation
  prefs: []
  type: TYPE_NORMAL
- en: The interpolation of varyings is automatic in the rendering pipeline. No programming
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Phong Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Phong** method calculates the final color in the *fragment shader*. To
    do so, each vertex normal is passed from the vertex shader to the fragment shader
    using a varying. Because of the interpolation mechanism of varyings included in
    the pipeline, each fragment will have its own normal. Fragment normals are then
    used to calculate the final color in the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the two interpolation models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aebd4849-7f90-4747-942e-67d2bcc45f4c.png)'
  prefs: []
  type: TYPE_IMG
- en: The shading method does not specify how the final color for each fragment is
    calculated. It only specifies *where* (vertex or fragment shader) and the *type
    of interpolation* (vertex colors or vertex normals) to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Goraud Versus Phong Shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now understand that Goraud shading performs the calculations inside the vertex
    shader and leverages the built-in rendering pipeline's interpolation. Phong shading,
    on the other hand, performs all of the calculations inside the fragment shader –
    that is, per fragment (or pixel). With these two details in mind, can you guess
    some of the advantages and disadvantages of these two shading techniques?
  prefs: []
  type: TYPE_NORMAL
- en: Goraud shading is considered to be faster since the performed calculations are
    computed per vertex, whereas Phong shading is calculated per fragment. The speed
    in performance does come at the cost of accurate or more realistic interpolation.
    This is most noticeable in cases where a light's intensity does not linearly degrade
    between two vertices. Later in this chapter, we will cover these two techniques
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Light-Reflection Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, the lighting model is independent from the shading/interpolation
    model. The shading model only determines where the final color is calculated.
    Now, it’s time to talk about how to perform such calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambertian Reflection Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lambertian reflections** are commonly used in computer graphics as a model
    for *diffuse reflections*, which are the kinds of reflections where an incident
    light ray is reflected in many angles instead of just *one* angle, as is the case
    for *specular reflections:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fefc2f3-a738-4958-aad9-e68189f583da.png)'
  prefs: []
  type: TYPE_IMG
- en: This lighting model is based on the **cosine emission law**, or **Lambert's
    emission law**. It is named after Johann Heinrich Lambert, from his *Photometria*,
    published in 1760.
  prefs: []
  type: TYPE_NORMAL
- en: The Lambertian reflection is usually calculated as the dot product between the
    surface normal (vertex or fragment normal, depending on the interpolation method
    used) and the negative of the light-direction vector. Then, the number is multiplied
    by the material and light source colors.
  prefs: []
  type: TYPE_NORMAL
- en: Light-Direction VectorThe light-direction vector is the vector that starts on
    the surface and ends on the light source position. It is essentially the vector
    that maps the light's position to the surface of the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0d62439-0e80-4e28-a731-bfd297772d14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`![](img/393da706-dd4c-4ab4-a7e0-10f4652a34e3.png)` is the final diffuse color, `![](img/bd8a12b0-4188-47aa-8911-018975269e5a.png)` is
    the light diffuse color, and `![](img/425ac9cb-4da1-4c64-9644-b00c460f945a.png)` is
    the material diffuse color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, we''d derive the final diffuse color with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `*L*` and `*N*` are normalized, then:'
  prefs: []
  type: TYPE_NORMAL
- en: Phong Reflection Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Phong reflection model describes the way a surface reflects the light as
    the sum of three types of reflection: ambient, diffuse, and specular. It was developed
    by Bui Tuong Phong, who published it in his 1973 PhD dissertation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6b4bb7f-75de-48f4-890a-920f4d158a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's cover these concepts individually.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **ambient** term accounts for the scattered light present in the scene.
    This term is independent from any light source and is the same for all fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Diffuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **diffuse** term corresponds to diffuse reflections. A Lambertian model
    is typically used for this component.
  prefs: []
  type: TYPE_NORMAL
- en: Specular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **specular** term provides mirror-like reflections. Conceptually, the specular
    reflection reaches its maximum when we look at the object at an angle that is
    equal to the reflected light-direction vector.
  prefs: []
  type: TYPE_NORMAL
- en: The specular term is modeled by the dot product of two vectors, namely, the eye vector
    and the reflected light-direction vector. The eye vector originates in the fragment
    and terminates in the view position (camera). The reflected light-direction vector
    is obtained by reflecting the light-direction vector upon the surface normal vector.
    When this dot product equals `1` (by working with normalized vectors), our camera will
    capture the maximum specular reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot product is then exponentiated by a number that represents the shininess
    of the surface. After that, the result is multiplied by the light and material
    specular components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb521d70-d2d3-4d53-a76d-7be0d17b45c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48dc2c47-c0a4-483b-bb6c-191e544bf077.png) is the final specular color, `![](img/fbc93053-92d3-45dc-91f5-8cc0d34ceeda.png)` is
    the light specular color, `![](img/186f032b-3881-4e8b-adeb-a3950ba8b607.png)` is
    the material specular color, and *`n` *is the shininess factor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, we''d derive the final specular color with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `*R*` and `*E*` are normalized, then:'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the specular reflection reaches its maximum when
    `*R*` and `*E*` have the same direction.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the ambient, diffuse, and specular terms, we add them to find the
    final color of the fragment, which provides us with the Phong reflection model.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to learn about the language that will allow us to implement the
    shading and lighting strategies inside the vertex and fragment shaders. This language
    is called ESSL.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES Shading Language (ESSL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenGL ES Shading Language (ESSL) is the language we'll use to write our
    shaders. Its syntax and semantics are very similar to C/C++. However, it has types
    and built-in functions that make it easier to manipulate vectors and matrices.
    In this section, we will cover the basics of ESSL so that we can start using it
    right away.
  prefs: []
  type: TYPE_NORMAL
- en: GLSL and ESSLIt’s quite common for developers to refer to the shading language
    used in WebGL as GLSL. However, it is technically ESSL. WebGl2 is built on the
    OpenGL ES 3.0 spec and therefore uses ESSL, which is a subset of GLSL (the shading
    language for OpenGL).
  prefs: []
  type: TYPE_NORMAL
- en: This section summarizes the official GLSL ES specifications. You can find the
    complete reference at [https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf](https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Storage Qualifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variable declarations may have a storage qualifier specified in front of the
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`attribute`: Data pulled from buffers that serve as the link between a vertex
    shader and a WebGL application for per-vertex data. This storage qualifier is
    only legal inside the vertex shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniform`: Value does not change across the object being processed. Uniforms
    form the link between a shader and a WebGL application. Uniforms are legal in
    both the vertex and fragment shaders. If a uniform is shared by the vertex and
    fragment shader, the respective declarations must match. Uniform values stay the
    same for all vertices of a single draw call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`varying`: This is the link between a vertex shader and a fragment shader for
    interpolated data. By definition, varyings must be shared by the vertex shader
    and fragment shader. The declaration of varyings needs to match between the vertex
    and fragment shaders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const`: A compile-time constant, or a function parameter that is read-only.
    They can be used anywhere in the code of an ESSL program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a non-exhaustive list of the most common ESSL types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`: For functions that do not return a value or for an empty parameter
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: A conditional type, taking on values of true or false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: A signed integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: A single floating-point scalar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vec2`: A two-component floating-point vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vec3`: A three-component floating-point vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vec4`: A four-component floating-point vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bvec2`: A two-component Boolean vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bvec3`: A three-component Boolean vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bvec4`: A four-component Boolean vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ivec2`: A two-component integer vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ivec3`: A three-component integer vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ivec4`: A four-component integer vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat2`: A 2×2 floating-point matrix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat3`: A 3×3 floating-point matrix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat4`: A 4×4 floating-point matrix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sampler2D`: A handle for accessing a 2D texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sampler3D`:  A handle for accessing a 3D texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`samplerCube`: A handle for accessing a cube-mapped texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`: Used to declare custom data structures based on standard types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESSL
  prefs: []
  type: TYPE_NORMAL
- en: There are many other types and features that the OpenGL ES 3.0 shading language
    provides. Here is a useful guide that covers many of its core features: [https://www.khronos.org/files/opengles3-quick-reference-card.pdf](https://www.khronos.org/files/opengles3-quick-reference-card.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'An input variable will have one of the qualifiers followed by one type. For
    example, we will declare our `uLightColor` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `uLightColor` variable is a `uniform` vector with four components.
  prefs: []
  type: TYPE_NORMAL
- en: The GLSL and ESSL Naming ConventionConvention dictates that we prefix shader
    variables with their type. This makes for clear and readable shader code. For
    example, for a given color uniform, you would name the variable `uLightColor`.
    For a position varying, `vNormal`. For a normal attribute, `aVertexNormal`.
  prefs: []
  type: TYPE_NORMAL
- en: Vector Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can refer to each one of the components of an ESSL vector by its index.
    For example, `uLightColor[3]` will refer to the fourth element of the vector (zero-based
    vectors). However, we can also refer to each component by a letter, as demonstrated
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `{ x, y, z, w }` | Useful when accessing vectors that represent points or
    vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| `{ r, g, b, a }` | Useful when accessing vectors that represent colors. |'
  prefs: []
  type: TYPE_TB
- en: '| `{ s, t, p, q }` | Useful when accessing vectors that represent texture coordinates.
    |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if we want to set the *alpha channel* (fourth component) of our `uLightColor` variable
    to `1.0`, we can do so by writing in any of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In all these of cases, we are referring to the same fourth component. However,
    given that `uLightColor` represents a color, it makes more sense to use the `r`, `g`, `b`, `a` notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to use the vector component notation to refer to subsets
    inside a vector. For example *(taken from GLSL ES specification)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Operators and Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the major advantages of GLSL and ESSL are the powerful built-in mathematical
    operators. ESSL provides many useful operators and functions that simplify vector
    and matrix operations. According to the specifications, the arithmetic binary
    operators add (`+`), subtract (`-`), multiply (`*`), and divide (`/`) operate
    on integer and floating-point typed expressions, including vectors and matrices.
    The two operands must be the same type, or one can be a scalar float and the other
    a float vector or matrix, or one can be a scalar integer and the other an integer
    vector. Additionally, for multiply (`*`), one can be a vector and the other a
    matrix with the same dimensional size as the vector. These result in the same
    fundamental types (integer or float) as the expressions they operate on. If one
    operand is a scalar and the other is a vector or a matrix, the scalar is applied
    component-wise to the vector or the matrix, with the final result being of the
    same type as the vector or the matrix. It''s important to note that dividing by
    zero does not cause an exception, but it does result in an unspecified value.
    Let''s see a few examples of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x`: The negative of the `x` vector. It produces the same vector in the exact
    opposite direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x + y`: Sum of the `x` and `y` vectors. Both vectors need to have the same
    number of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x - y`: Subtraction of the `x` and `y` vectors. Both vectors need to have
    the same number of components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x * y`: If `x` and `y` are both vectors, this operator yields a component-wise
    multiplication. Multiplication applied to two matrices returns a linear algebraic
    matrix multiplication, not a component-wise multiplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrixCompMult(matX, matY)`: Component-wise multiplication of matrices. They
    need to have the same dimensions (`mat2`, `mat3`, or `mat4`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x / y`: The division operator behaves similarly to the multiplication operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dot(x, y)`: Returns the dot product (scalar) of two vectors. They need to
    have the same dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cross(vecX, vecY)`: Returns the cross product (vector) of two vectors. They
    must both be `vec3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normalize(x)`: Returns a vector in the same direction but with a length of `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reflect(t, n)`: Reflects the `t`vector along the `n` vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders offer many more functions, including trigonometric and exponential functions.
    We will refer to them as needed in the development of different lighting models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example of the shader''s ESSL code for a scene with the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Goraud shading**: We will interpolate vertex colors to obtain fragment colors.
    Therefore, we need one `varying` to pass the vertex color information from the
    vertex shader to the fragment shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambertian reflection model**: We account for the diffuse interaction between
    one light source and our scene. This means that we will use uniforms to define
    the light properties that is, the material properties. We will follow *Lambert''s
    Emission Law *to calculate the final color for every vertex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's dissect what the attributes, uniforms, and varyings will be.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by defining two attributes in the vertex shader. Every vertex
    will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that attributes are only available to use inside the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: If you're curious as to why `in` is used instead of the `attribute` qualifier,
    we will cover this shortly. Right after the `in` keyword, we find the type of
    the variable. In this case, it is `vec3`, as each vertex position is determined
    by three elements (`x`, `y`, `z`). Similarly, the normals are also determined
    by three elements (`x`, `y`, `z`). Please note that a position is a *point* in
    three-dimensional space that tells us where the vertex is, while a normal is a *vector* that
    gives us information about the orientation of the surface that passes along that
    vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uniforms are available to both the vertex shader and the fragment shader. While
    attributes differ every time the vertex shader is invoked, uniforms are constant
    throughout a rendering cycle – that is, during the `drawArrays` or `drawElements` WebGL
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Processing
  prefs: []
  type: TYPE_NORMAL
- en: We process vertices in parallel; therefore, each copy/thread of the vertex shader
    processes a different vertex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use uniforms to pass along information about lights (such as diffuse
    color and direction), and materials (diffuse color):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `uniform` keyword tells us that these variables are uniforms, and
    the `vec3` and `vec4` ESSL types tell us that these variables have three or four
    components. For the colors, these components are the red, blue, green, and alpha
    channels (RGBA), and for the light direction, these components are the `x`, `y`,
    and `z` coordinates that define the vector in which the light source is directed
    in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Varyings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described earlier, varyings allow for the vertex shader to pass information
    to the fragment shader. For example, if we want to carry the vertex color from
    the vertex shader to the fragment shader, we would first update our vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And we would reference that varying inside of our fragment shader as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Keep in the mind that the *Storage Qualifier*, the declaration of varyings,
    needs to match between the vertex and fragment shaders.
  prefs: []
  type: TYPE_NORMAL
- en: The in and out variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These keywords describe the direction of the *input* and *output*. As seen with
    the *attribute* and *varying* declarations, when we use `in`, that variable is
    supplied to the shader. When we use `out`, the shader exposes that variable. Let's
    see how these keywords are used in earlier versions of WebGL within the vertex
    and fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Changing attribute to in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WebGL 1 with *ESSL 100*, you might have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In WebGL 2 with *ESSL 300*, this becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Changing varying to in / out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebGL 1 with *ESSL 100*, you declare a varying in both the vertex and fragment
    shaders, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In WebGL 2 with *ESSL 300*, in the vertex shader, the varyings become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the fragment shader, they become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's plug the attributes, uniforms, and varyings into the code and see
    what the vertex shader and fragment shader look like.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover a sample vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On first inspection, we can identify the attributes, uniforms, and varyings
    that we will use, along with some matrices that we will discuss later. We can
    also see that the vertex shader has a `main` function that does not accept parameters
    and instead returns `void`. Inside, we can see some ESSL functions, such as `normalize` and `dot`,
    along with some arithmetical operators.
  prefs: []
  type: TYPE_NORMAL
- en: '`#version 300 es`'
  prefs: []
  type: TYPE_NORMAL
- en: This string must be the very first line of your shader. No comments or blank
    lines are allowed before it! `#version 300 es` tells WebGL that you want to use
    WebGL 2's shader language (GLSL ES 3.00). If that isn’t written as the first line,
    the shader language defaults to WebGL 1.0's GLSL ES 1.00, which has fewer features.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three uniforms that we haven’t discussed yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that these three uniforms are `4x4` matrices. These matrices are
    required in the vertex shader to calculate the location for vertices and normals
    whenever we move the camera. There are a couple of operations here that involve
    using these matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous line of code calculates the *transformed normal*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This line calculates the *transformed vertex position*. `gl_Position` is a special
    output variable that stores the transformed vertex position.
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to these operations in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, we should acknowledge that these uniforms and operations deal
    with camera and world transformations (rotation, scale, and translation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the main function’s code, we can clearly see that the Lambertian
    reflection model is being implemented. The `dot` product of the normalized normal
    and light direction vector is obtained and then multiplied by the light and material
    diffuse components. Finally, this result is passed into the `vVertexColor` varying
    to be used in the fragment shader, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Also, as we are calculating the color in the vertex shader and then automatically
    interpolating it for the fragments of every triangle, we are using the Goraud
    interpolation method.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fragment shader is very simple. The first three lines define the precision
    of the shader. This is mandatory according to the ESSL specification. Similarly,
    for the vertex shader, we define our input; in this case, just one varying variable,
    and then we have the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We just need to assign the `vVertexColor` varying to the `fragColor` output
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: No More `gl_FragColor`
  prefs: []
  type: TYPE_NORMAL
- en: In WebGL 1, your fragment shader would set the `gl_FragColor` special variable
    to compute the output of the shader: `gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);`.
  prefs: []
  type: TYPE_NORMAL
- en: In WebGL 2, *ESSL 300* forces you to declare your own output variable and then
    set it. You can pick any name you want, but names cannot begin with `gl_`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the value of the `vVertexColor` varying will be different from
    the one calculated in the vertex shader since WebGL will interpolate it by taking
    the corresponding calculated colors for the vertices surrounding the correspondent
    fragment (pixel).
  prefs: []
  type: TYPE_NORMAL
- en: Writing ESSL Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a moment to step back and look at the big picture. ESSL allows
    us to implement a lighting strategy, provided that we define a shading method
    and a light reflection model. In this section, we will take a sphere as the object
    that we want to illuminate, and we will see how the selection of a lighting strategy
    changes the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/804a04e3-c218-43ac-84ed-132bf0d0f2d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will see two scenarios for Goraud interpolation: one with Lambertian and
    one with Phong reflections. We will only see one case for Phong interpolation;
    under Phong shading, the Lambertian reflection model is no different from a Phong
    reflection model where the ambient and specular components are set to `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Goraud Shading with Lambertian Reflections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lambertian reflection model only considers the interaction of diffuse material
    and diffuse light properties. In short, we assign the final color as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following value is seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Under Goraud shading, the **Lambert coefficient** is obtained by calculating
    the dot product of the vertex normal and the inverse of the light-direction vector.
    Both vectors are normalized before finding the dot product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the vertex shader and the fragment shader from the provided
    example, `ch03_01_goraud_lambert.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d615d810-3bf0-4d37-b061-56a63068af19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the final vertex color that we processed in the vertex shader
    is carried into a varying variable to the fragment shader. Remember that the value
    that arrives to the fragment shader is *not* the original value that we calculated
    in the vertex shader. The fragment shader interpolates the `vVertexColor` variable
    to generate a final color for the respective fragment. This interpolation takes
    into account the vertices that enclose the current fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Updating Uniforms in Real Time'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of how we''d update shader uniforms interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch03_01_goraud_lambert.html` file in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/904b2bee-303a-4f77-8954-04c4a28e4002.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in this example, the controlswidget is at the top right of the page.
    If you're curious about how it works, you can check the `initControls` function
    inside of the example code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Settings WidgetThe settings widget was created using **DatGui**, an open
    source library. While we won't cover the intuitive DatGui API, it may be useful
    to read the documentation and the code in the provided examples to see how it
    works. For more information, you can check out [https://github.com/dataarts/dat.gui.](https://github.com/dataarts/dat.gui)
  prefs: []
  type: TYPE_NORMAL
- en: '**Translate X, Y, Z**: Thesecontrol the direction of the light. By changing
    these sliders, you will modify the `uLightDirection` uniform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4fb6fe04-13c9-46c9-bc4e-5d9b6f6582b3.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Sphere Color**: This changes the `uMaterialDiffuse` uniform, which represents
    the diffuse color of the sphere. Here, you use the color selection widget, which
    allows you to try different colors. `onChange` of `Sphere Color` in the `initControls` function
    receives the updates from the widget and updates the `uMaterialDiffuse` uniform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Light Diffuse Color**: This changes the `uLightDiffuse` uniform, which represents
    the diffuse color of the light source. There is no reason why the light color
    must be white. We achieve this by assigning the slider value to the RGB components
    of `uLightDiffuse` while we keep the alpha channel set to `1.0`. We do this inside
    the `onChange` function under the lights settings, which receives the slider updates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try different settings for the light source position, the diffuse material,
    and light properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen an example of a simple scene illuminated using Goraud interpolation
    and a Lambertian reflection model. We have also seen the immediate effects of
    changing uniform values for the Lambertian lighting model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Moving Light'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned before that we use matrices to move the camera around the scene.
    We can also use matrices to move lights. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ch03_02_moving-light.html` in your editor. The vertex shader is very
    similar to the previous diffuse model example. However, there is one extra line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are transforming the `uLightDirection` vector and assigning it to
    the `light` variable. Notice that the `uLightDirection` uniform is a vector with
    three components (`vec3`) and that the `uModelViewMatrix` is a 4x4 matrix. In
    order to complete the multiplication, we need to transform this uniform into a
    four-component vector (`vec4`). We achieve this with the following construct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `uModelViewMatrix` matrix contains the *Model-View transformation matrix*.
    We will see how all this works in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, suffice to say that this matrix allows us to update vertices’
    positions, and in this example, the light's position as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take another look at the vertex shader. In this example, we are rotating the
    sphere and the light. Every time the `draw` function is invoked, we rotate the `modelViewMatrix` matrix a
    little bit on the y-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you examine the code more closely, you will notice that the `modelViewMatrix` matrix is
    mapped to the `uModelViewMatrix` uniform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the example in your browser. You will see a sphere and a light source rotating
    on the y-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed0b6249-3e56-494e-9c35-c63ac7a41a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look for the `initLights` function and change the light orientation so that
    the light is pointing in the negative z-axis direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and run it again. What happened? Change the light direction uniform
    so that it points to `[-1, 0, 0]`. Save the file and run it again on your browser.
    What happened? You should see that changing these values manipulates the light's
    orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the light back to the 45-degree angleby changing the `uLightDirection` uniform
    so that it returns to its initial value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to `draw` and find the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and launch it again in your browser. What happens? You should
    notice that the light moves on a different axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the vector that is passed as the third argument to `mat4.rotate` determines
    the axis of the rotation. The first component corresponds to the x-axis, the second
    to the y-axis, and the third to the z-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Goraud Shading with Phong Reflections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different from the Lambertian reflection model, the Phong reflection model
    considers three properties: the ambient, diffuse, and specular, and ultimately
    yields a more realistic reflection. Following the same analogy that we used in
    the previous section, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that:'
  prefs: []
  type: TYPE_NORMAL
- en: As we use Goraud interpolation, we still use vertex normals to calculate the
    diffuse term. This will change when using Phong interpolation, where we will use
    fragment normals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both light and material have three properties: the ambient, diffuse, and specularcolors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On these equations, we can see that `Ia`, `Id`, and `Is` receive contributions
    from their respective light and material properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on our knowledge of the Phong reflection model, let''s see how to calculate
    the specular coefficient in ESSL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eyeVector` is the view vector or camera vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightReflection` is the reflected light vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shininess` is the specular exponential factor or shininess'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightReflection` is calculated as `lightReflection = reflect(lightDirection,
    normal);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal` is the vertex normal, and `lightDirection` is the light direction
    that we have been using to calculate the Lambert coefficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the ESSL implementation for the vertex and fragment shaders.
    Here''s the vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain negative dot products for the Lambert term when the geometry
    of our objects is concave or when the object is in the way between the light source
    and our point of view. In either case, the negative of the light-direction vector
    and the normals will form an obtuse angle, producing a negative dot product, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad5df219-e71e-4fd6-8bfd-afe923d9f2d1.png)'
  prefs: []
  type: TYPE_IMG
- en: For that reason, we are using the ESSL built-in clamp function to restrict the
    dot product to the positive range. If we obtain a negative dot product, the clamp
    function will set the lambert term to zero and the respective diffuse contribution
    will be discarded, generating the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we are still using Goraud interpolation, the fragment shader is
    the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will explore the scene to see what it looks like when
    we have negative Lambert coefficients that have been clamped to the `[0,1]` range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Goraud Shading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example where we implement lighting with Goraud shading:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch03_03_goraud_phong.html` file in your browser. You will see something
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2a15f52-eefd-4b83-bc06-f9a04d57fd49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The interface looks a little bit more elaborate than the diffuse lighting example.
    Let''s stop here for a moment to explain these widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Light Color (light diffuse term): As mentioned at the beginning of this chapter,
    we can have an example where our light is not white. We have included a color
    selector widget here for the light color so that you can experiment with different
    combinations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Light Ambient Term**: The light ambient property. In this example, this is
    a gray value: `r = g = b`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Light Specular Term: The light specular property. This is a gray value: `r
    = g = b`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Translate X,Y,Z: The coordinates that define the light''s orientation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sphere Color (material diffuse term): The material diffuse property. We have
    included a color selector so that you can try different combinations for the `r`,
    `g`, and `b` channels.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Ambient Term: The material ambient property. We have included it just
    for the sake of it. But as you might have noticed in the diffuse example, this
    vector is not always used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material Specular Term: The material specular property. This is a gray value :
    r = g = b.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shininess: The specular exponential factor for the Goraud model.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Background Color (`gl.clearColor`): This widget simply allows us to change
    the background color.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The specular reflection in the Phong reflection model depends on the shininess,
    the specular property of the material, and the specular property of the light.
    When the specular property of the material is close to `0`, the material *loses *its
    specular property. Check this behavior with the widget provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when the specularity of the material is low and the shininess is
    high?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the specularity of the material is high and the shininess
    is low?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the widgets, try different combinations for the light and material properties.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the different parameters of the Phong lighting model interact with
    each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We modified the light orientation, the properties of the light, and the material
    to observe different behaviors of the Phong lighting model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike the Lambertian reflection model, the Goraud lighting model has two extra
    terms: the ambient and specular components. We saw how these parameters affect
    the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like the Lambertian reflection model, the Phong reflection model obtains
    the vertex color in the vertex shader. This color is interpolated in the fragment
    shader to obtain the final pixel color. This is because, in both cases, we are
    using Goraud interpolation. Let's now move the heavy processing to the fragment
    shader and study how we implement the Phong interpolation method.
  prefs: []
  type: TYPE_NORMAL
- en: Phong Shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the Goraud interpolation, where we calculated the final color for each
    vertex, the Phong interpolation calculates the final color for every fragment.
    This means that the calculation of the ambient, diffuse, and specular terms in
    the Phong model are performed in the fragment shader instead of the vertex shader.
    As you can imagine, this is computationally more intensive than performing a simple
    interpolation like in the two previous scenarios where we were using Goraud interpolation.
    However, we obtain a scene that seems more realistic.
  prefs: []
  type: TYPE_NORMAL
- en: After this translation, you may be wondering what is left for the vertex shader
    to do. Well, in this case, we will create varyings that will allow us to do all
    of the calculations in the fragment shader. For example, the vertex normals are
    a great fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas before we had a normal per vertex, now we need to generate a normal
    for every pixel so that we can calculate the Lambert coefficient for each fragment.
    We do so by interpolating the normals that we pass to the fragment shader. Nevertheless,
    the code is very simple. All we need to know is how to create a varying that stores
    the normal for the vertex we are processing in the vertex shader and to obtain
    the interpolated value in the fragment shader (courtesy of ESSL). That''s all!
    Conceptually, this is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b90323c-0e88-4abf-b4c1-268eb87b2376.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take a look at the vertex shader under Phong shading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike our examples with the Goraud interpolation, the vertex shader looks
    really simple. There is no final color calculation and we are using two varyings
    to pass information to the fragment shader. The fragment shader will now look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we pass vectors as varyings, it is possible that they denormalize in the
    interpolation step. Therefore, you may have noticed that both `vNormal` and `vEyeVector` are
    normalized again in the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, under Phong lighting, the Lambertian reflection model
    can be seen as a Phong reflection model where the ambient and specular components
    are set to `0`. Therefore, we will only cover the general case in the next section
    where we will see what the sphere scene looks like when using Phong shading and
    Phong lighting combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Phong Shading with Phong Lighting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of implementing lighting using Phong shading:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch03_04_sphere_Phong.html` file in your browser. The page will look
    similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55730d4f-55ca-408e-9829-021b13c0d1e8.png)'
  prefs: []
  type: TYPE_IMG
- en: The interface is very similar to the Goraud example's interface. As previously
    described, it is quite evident how the Phong shading combined with Phong lighting
    delivers a more realistic scene. Experiment with the controls widget to see the
    immediate result of this new lighting model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen Phong shading and Phong lighting in action. We explored the source
    code for the vertex and fragment shaders. We also modified the different parameters
    of the model and observed the immediate effect of the changes on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Back to WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to go back to our JavaScript code, but we now need to consider how
    to close the gap between our JavaScript code and our ESSL code. First, we need
    to take a look at how we create a **program** using our WebGL context. Please
    remember that we refer to both the vertex shader and fragment shader as the program.
    Second, we need to know how to initialize attributes and uniforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the structure of the web apps we have developed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a485ddc-b5d6-43af-a00a-db620262e0a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Each application has a vertex shader and a fragment shader embedded in the web
    page. In addition, there is a script section where we write all of our WebGL code.
    Finally, we have the HTML code that defines the page components, such as titles
    and the location of the widgets and the `canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript code, we are calling the `init` function on the `onload` event
    of the web page. This is the entry point for our application. The first thing
    that `init` does is obtain a WebGL context for the `canvas` within `initProgram`,
    and then calls a series of functions that initialize the program, the WebGL buffers,
    and the lights. Finally, it gets into a render loop where every time that the
    loop goes off, the `draw` function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at the `initProgram` and `initLights`
    functions. `initProgram` allows us to create and compile an ESSL program while
    `initLights` allows us to initialize and pass values to the uniforms defined in
    the programs. It is inside `initLights` where we will define the light's position,
    direction, and color components (ambient, diffuse, and specular) as well as default
    values for material properties.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, open up `ch03_05_wall.html` in an editor. Let''s take a step-by-step
    look at `initProgram`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we retrieve a WebGL context, as we''ve seen in previous chapters. Then,
    we use the `utils.getShader` utility function to retrieve the contents of the
    vertex shader and the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The program''s creation occurs in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used several functions provided by the WebGL context. These include
    the ones shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebGL Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `createProgram()` | Creates a new program (*program*). |'
  prefs: []
  type: TYPE_TB
- en: '| `attachShader(program, shader)` | Attaches a shader to the current program.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `linkProgram(program)` | Creates executable versions of the vertex and fragment
    shaders that are passed to the GPU. |'
  prefs: []
  type: TYPE_TB
- en: '| `getProgramParameter(program, parameter)` | This is part of the WebGL state-machine
    query mechanism. It allows you to query the program parameters. We use this function
    to verify whether the program has been successfully linked. |'
  prefs: []
  type: TYPE_TB
- en: '| `useProgram(program)` | It will load the program onto the GPU if the program
    contains valid code (that is, it has been successfully linked). |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, we create a **mapping** between JavaScript variables and the program
    attributes and uniforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Instead of creating several JavaScript variables here (one per program `attribute`
    or `uniform`), we are attaching properties to the `program` object. This does
    not have anything to do with WebGL. It is just a convenience step to keep all
    of our JavaScript variables as part of the program object.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL ProgramsSince we are attaching many of the important variables to our
    WebGL program, you may be wondering why we don't attach it to our WebGL context
    rather than the program. In our example, we're using a single **program** because
    our example is small. As WebGL applications grow, you may find that you have several
    programs that you switch throughout your application with the `gl.useProgram` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this information pertains to `initProgram`. Here, we have used the following
    WebGL API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebGL Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `getAttribLocation(program, name)` | This function receives the current program
    object and a string that contains the name of the attribute that needs to be retrieved.
    This function then returns a **reference** to the respective **attribute**. |'
  prefs: []
  type: TYPE_TB
- en: '| `getUniformLocation(program, name)` | This function receives the current
    program object and a string that contains the name of the uniform that needs to
    be retrieved. This function then returns a **reference** to the respective **uniform**.
    |'
  prefs: []
  type: TYPE_TB
- en: Using this mapping, we can initialize the uniforms and attributes from our JavaScript
    code, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Another addition to WebGL 2 is an increasingly optimized approach for getting
    item locations from the vertex shader. In our example, we use `getAttribLocation` and `getUniformLocation` for
    getting the locations of these items. If you inspect their return values, you'll
    see that they return *whole numbers*.
  prefs: []
  type: TYPE_NORMAL
- en: Whole numbers are simply the numbers 0, 1, 2, 3, 4, 5, ... (and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Convention dictates that with large 3D applications, you can leverage tested
    design patterns and data structures to organize your code, which may include organizing
    shader resources in a predetermined or programmatic order.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example would be to leverage the **layout qualifier **to look up resource
    locations. Here''s a simplified example from [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml),
    *Rendering*, where we looked up and enabled both `aVertexPosition` and `aVertexColor` using `getAttribLocation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the associated vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'These would turn into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the updated vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's a subtle change where we define the locations using indices
    within the vertex shader and simply enable the items using those indices.
  prefs: []
  type: TYPE_NORMAL
- en: Performance HitsEvery time we need to look up or set shader values from the
    JavaScript context, it comes at a performance cost. Because of this, we should
    always be careful of how often we perform such operations.
  prefs: []
  type: TYPE_NORMAL
- en: Although the layout qualifier is optimal, we will continue leveraging the traditional
    variable and definition lookup throughout this book, given that it’s more readable
    and requires less overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Layout QualifiersFor more information on layout and other qualifiers, please
    visit [https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)](https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)).
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Attributes and Uniforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have compiled and installed the program, the next step is to initialize
    the attributes and variables. We will initialize our uniforms using the `initLights` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you can see that we’re using the references obtained with `getUniformLocation` (we
    did this in `initProgram`).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the functions that the WebGL API provides to set and get uniform
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebGL Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform[1234][fi]` | Specifies 1-4 `float` or `int` values of a uniform
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform[1234][fi]v` | Specifies the value of a uniform variable as an array
    of 1-4 `float` or `int` values. |'
  prefs: []
  type: TYPE_TB
- en: '| `getUniform(program)` | Retrieves the contents of a uniform variable. The
    reference parameter has been previously obtained with `getUniformLocation`. |'
  prefs: []
  type: TYPE_TB
- en: 'In [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*, we
    learned that a four-step process is required to initialize and use attributes.
    Recall that we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind a VBO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point an attribute to the currently-bound VBO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbind the VBO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The key piece here is step *2*. We do this with the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check out the `ch03_05_wall.html` example, you will see that we do this
    inside the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Bridging the Gap Between WebGL and ESSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s now useful to test out how we integrate our ESSL program with our WebGL
    code by taking the code from `ch03_05_wall.html` and making some modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a wall composed of the sections A, B, and C, and you are facing section
    B with a flashlight in your hand (frontal view). Intuitively, you know that section
    A and section C will be darker than section B. This fact can be modeled by starting
    at the color of the center of section B and darkening the color of the surrounding
    pixels as we move away from the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e344c4e-1d5b-4f95-8d55-6eb1b1e69d09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s summarize the code we need to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The ESSL program containing the vertex and fragment shaders. For the wall, we
    will select Goraud shading with a Diffuse/Lambertian reflection model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `initProgram` function. We need to make sure that we map all of the attributes
    and uniforms that we defined in the ESSL code, including the normals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initBuffers` function. Here, we need to create our geometry. We can represent
    the wall with eight vertices that define six triangles, such as the ones shown
    in the previous diagram. In `initBuffers`, we will apply what we learned in the
    previous chapters to set up the appropriate VAOs and buffers. This time, we need
    to set up an additional buffer: the VBO that contains information about normals.
    The code to set up the normals VBO looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: To calculate the normals, we use the `calculateNormals(vertices, indices)` helper
    function. You can find this method in the `common/js/utils.js` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initLights`: We covered this function already and know how to do that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s only one minor but important change to make inside the `draw` function.
    We need to make sure that the VBOs are bound before we use `drawElements`. The
    code to do that looks like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will explore the functions that we just described
    for building and illuminating the wall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Working on the Wall'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example showcasing the preceding concepts in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch03_05_wall.html` file in your browser. You will see something similar
    to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74054bf4-6df6-458c-a4a4-159f4d9e1db1.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `ch03_05_wall.html` file in a code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the vertex shader. Make sure that you identify the attributes, uniforms,
    and varyings that are declared there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the fragment shader. Notice that there are no attributes here, because
    attributes are exclusive to the vertex shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vertex and Fragment Shaders
  prefs: []
  type: TYPE_NORMAL
- en: You can find these shaders inside the script tags with the appropriate ID names.
    For example, the vertex shader can be found inside `<script id="vertex-shader"
    type="x-shader/x-vertex">`.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `init` function. Verify that we are calling `initProgram` and `initLights` there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `initProgram`. Make sure that you understand how the program is built
    and how we obtain references to attributes and uniforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `initLights`. Update the values of the uniforms, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Notice that one of the updates consists of changing from `uniform4f` to `uniform4fv` for
    the `uMaterialDiffuse` uniform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open it again (or reload it) in your browser. What happened?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's do something a bit more interesting. We are going to create a key listener
    so that every time we hit a key, the light orientation changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right after the `initLights` function, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This function processes the arrow keys and changes the light direction accordingly.
    There’s a bit of trigonometry (`Math.cos`, `Math.sin`) involved, but we are simply
    converting the angles (azimuth and elevation) into Cartesian coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Please note that we get the current light direction by using the following
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After processing the key strokes, we can save the updated light direction with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the work and reload the web page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b95d6df1-1a53-4f15-b512-2f428a4dd01c.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the arrow keys to change the light direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have any problems during the development of this exercise or just want
    to verify the final result, please check the `ch03_06_wall_final.html` file, which
    contains the completed exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a keyboard listener that allows us to update the
    light's orientation so that we can move it around the wall and see how it reacts
    to surface normals. We also saw how the vertex shader and fragment shader input
    variables are declared and used. We learned how to build a program by reviewing
    the `initProgram` function. We also learned about initializing uniforms in the `initLights` function.
    Finally, we studied the `getUniform` function to retrieve the current value of
    a uniform. Although we haven't covered the examples entirely, this exercise was
    intended to familiarize you with vertex and fragment shaders so that you can implement
    various light-shading and reflection models.
  prefs: []
  type: TYPE_NORMAL
- en: More on Lights: Positional Lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before finishing this chapter, let''s revisit the topic of lights. So far,
    for the purpose of our examples, we’ve assumed that our light source is infinitely
    far away from the scene. This assumption allows us to model the light rays as
    being parallel to each other. An example of this is sunlight. These lights are *directional
    lights*. Now, we are going to consider a case where the light source is relatively
    close to the object it needs to illuminate. Think, for example, of a desk lamp
    illuminating the document you’re reading. These lights are *positional lights*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b25e6328-5f13-4c4f-a540-f094b2197840.png)'
  prefs: []
  type: TYPE_IMG
- en: As we experienced before, when working with directional lights, only one variable
    is required. This is the light direction we represented in the `uLightDirection` uniform.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, when working with positional lights, we need to know the location
    of the light. We can represent it by using a uniform that we will name `uLightPosition`.
    As is the case when using positional lights, the light rays here are not parallel
    to each other; as a result, we need to calculate each light ray separately. We
    will do this by using a varying that we will name `vLightRay`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will investigate how a positional light interacts with
    a scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Positional Lights in Action'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of positional lights in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch03_07_positional_lighting.html` file in your browser. The page
    will look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c52b4a9d-4cd9-4133-9ff9-2a84444d671f.png)'
  prefs: []
  type: TYPE_IMG
- en: The interface of this exercise is very simple. You can use the controls widget
    to interact with the scene. Unlike in previous exercises, the **Translate X**,
    **Y**, and **Z** sliders do not represent light direction here. Instead, they
    allow us to set the light source position. Go ahead and play with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For clarity, a little sphere representing the position of the light source has
    been added to the scene to visualize the light source, but this is not generally
    required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when the light source is located on the surface of the cone versus
    on the surface of the sphere?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when the light source is inside the sphere?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the way we calculate the light rays by inspecting the
    vertex shader in the source code. The light ray calculation is performed in the
    following two lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line allows us to obtain a transformed light position by multiplying
    the Model-Viewmatrix by the `uLightPosition` uniform. If you review the code in
    the vertex shader, you’ll note that we also use this matrix for calculating transformed
    vertices and normals. We will discuss these matrix operations in [Chapter 4](62d4de32-0b5b-4339-8fcc-80f739e80ec2.xhtml),
    *Cameras*. For now, we can just assume that this is necessary to obtain transformed
    vertices, normals, and light positions whenever we move the camera. To test this,
    modify this line by removing the matrix from the equation so that the line looks
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and launch it in your browser. What is the effect of not transforming
    the light position? What you can see is that the camera is moving, but the light
    source position is not being updated!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see that the light ray is calculated as the vector that reaches from
    the transformed light position (light) to the vertex position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thanks to the interpolation of varyings that is provided by ESSL, we automatically
    obtain all the light rays per pixel in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/763b7af0-fe64-4dd0-9675-e29998fac50d.png)'
  prefs: []
  type: TYPE_IMG
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We studied the difference between directional lights and positional lights.
    We also investigated the importance of the Model-View matrix for the correct calculation
    of positional lights when the camera is moving. Finally, we modeled the procedure
    to obtain per-vertex light rays.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Showroom Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve included an example of the Nissan GTR exercise we saw
    in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*. This
    time, we’ve used a Phong lighting model with a positional light to illuminate
    the scene. You can find this example in `ch03_08_showroom.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15af1d35-37ee-430c-b04b-f39dac44efed.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you can experiment with different light positions. Pay special attention
    to the nice specular reflections you obtain thanks to the specularity property
    of the car and the shininess of the light.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover some useful functions that we can refactor to use in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen how to create and compile a program using shaders. We''ve also
    covered how to load and reference attributes and uniforms. Let''s include a module
    that abstracts away this low-level functionality with a simpler API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Like we did previously, we will include this script tag in the `<head>` of the
    HTML document. Be sure to include it after the other module scripts, since they
    may use the libraries and earlier modules we've covered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s update our `initProgram` function inside of `ch03_08_showroom.html` so
    that we can use this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: All of the heavy lifting of creating a program, compiling shaders, and attaching
    uniforms and attributes to our program is done for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s inspect the `Program` class source code. Most of the operations should
    look familiar to you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We initialize `Program` by passing in a reference to the `gl` context, the vertex,
    and the fragment shader `id`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We load and reference the `attributes` and `uniforms` programs by supplying
    the `program` instance with the array of attributes and uniforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other methods are helper functions that we'll use in later chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find an example of these changes in `ch03_09_showroom-final.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may have caught two additional utils methods used throughout this chapter:
    `normalizeColor` and `denormalizeColor`. These two methods simply normalize colors
    from range `[0-255]` to `[0-1]` or denormalize from `[0-1]` to `[0-255]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned in detail what light sources, materials, and normals are, and how
    these elements interact to illuminate a WebGL scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the differences between a shading method and a lighting model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We studied the basics of the Goraud and Phong shading methods, along with the
    Lambertian and Phong lighting models. With the help of several examples, we also
    covered how to implement these shading and lighting models in code using ESSL,
    and how to communicate between the WebGL code and the ESSL code through attributes
    and uniforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the vertex shader and the fragment shader to define a lighting model
    for our 3D scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered many of these operations through the lens of the latest and greatest
    techniques provided to us in WebGL 2's updated shading language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will expand on using matrices in ESSL so that we can
    learn how to use them to represent and move our viewpoint in a 3D scene.
  prefs: []
  type: TYPE_NORMAL
