<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-39"><em class="italic"><a id="_idTextAnchor038"/>Chapter 2</em>: Automated Testing and Test runners</h1>
			<p>In <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>, we covered the first fundamental pillar of this book: browser automation and headless browsers. In this chapter, we are going to cover the second pillar: UI testing. We learned that Puppeteer is not just about testing, but that doesn't mean that it's not an excellent tool for the job. </p>
			<p>In this chapter, we are going to learn the fundamentals of Testing Automation. We are going to see the differences between UI Testing and End-to-End testing. If you have tried to write tests in Node.js before, you might have come across some weird names: Mocha, Jest, Jasmine, AVA, or Chai. That feels quite overwhelming if you are not used to these tools. We are going to see which are the right tools for us.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introduction to Automated Testing</li>
				<li>Test runner main features</li>
				<li>Available Test runners</li>
				<li>Creating our first test project</li>
				<li>Organizing our code</li>
			</ul>
			<p>Once we understand these foundational concepts and we learn how test runners work, we will be able to dive deep into the Puppeteer API.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter2</strong> directory.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Introduction to Automated Testing</h1>
			<p>Testing <a id="_idIndexMarker068"/>is a fundamental task in software development. Even if you consider yourself a bad tester, or even a bad developer, you do some testing when you code your app. At the very least, you open the app to see whether it works as expected.</p>
			<p>Maybe you are a little bit more methodical and you have a test plan, at least in your mind. You know that when you code a form, you have to validate some common scenarios:</p>
			<ul>
				<li>Try to save a form with empty fields.</li>
				<li>Try to save with good data.</li>
				<li>Try to enter bad data. You might enter text in numeric fields, invalid dates, and so on.</li>
			</ul>
			<p>More experienced developers will cover all the possible scenarios. They will write code based on those scenarios and then test accordingly.</p>
			<p>Then we get to the word that's driving this book: we <strong class="bold">automate</strong> stuff. We want to automate our tests. We don't want to forget any scenarios or have to test the same thing over and over.</p>
			<p>As you will notice, I haven't <a id="_idIndexMarker069"/>mentioned <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) analysts yet, because I want to highlight that testing is not something relegated to the QA team. Those who are involved in the testing process include the following:</p>
			<ul>
				<li>Backend developers</li>
				<li>Frontend developers</li>
				<li>QA analysts</li>
				<li>Managers (product or project managers)</li>
			</ul>
			<p>We need to know that there are different types of tests. Some types of tests will be performed by developers and QA analysts. Other tests will be specific to either developers or QA analysts.</p>
			<p>Mike Cohn, in his book <em class="italic">Succeeding with Agile</em> (Addison-Wesley Professional), introduced his very popular Testing Pyramid:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.01_B16113.jpg" alt="Mike Cohn’s Testing Pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Mike Cohn's Testing Pyramid</p>
			<p>Although Mike's book is <a id="_idIndexMarker070"/>more than 10 years old, this pyramid is still valid.</p>
			<p>This pyramid is based on three characteristics:</p>
			<ul>
				<li>Number of tests</li>
				<li>Isolation</li>
				<li>Speed</li>
			</ul>
			<p>I have only one thing against this pyramid: the word <strong class="bold">UI</strong>. Modern apps rely more and more on client code, "UI" code. Frameworks such as React, Angular, and Vue.js allow developers to write reusable components. Many apps now have most of their business rules running on the client.</p>
			<p>Frontend developers should not be limited to the top of this pyramid. They should be able to write unit tests and service tests for their UI code. This might look like a small change, but I think it's important. With this change in the paradigm, we get a pyramid that looks like this:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.02_B16113.jpg" alt="New Pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">New Pyramid</p>
			<p>Now that we have a better understanding, let's talk about the different levels of this pyramid.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Unit tests</h2>
			<p>Unit tests<a id="_idIndexMarker071"/> are the base of the pyramid. The more business logic you cover in unit tests, the less ground you will need to cover in service or UI tests.</p>
			<p>As we can see in the pyramid, unit tests need to be <strong class="bold">fast and isolated</strong>. That means that a good unit test shouldn't depend on the environment or any other function. Sometimes this is easier said than done. For instance, if you want to test that the total amount of an invoice is equal to the<a id="_idIndexMarker072"/> sum of its items, you should be able to test that specific functionality in the code, without launching a web server or getting data from a database.</p>
			<h3>What roles use Unit tests?</h3>
			<p><strong class="bold">Backend developers</strong>: For sure, Unit tests <a id="_idIndexMarker073"/>are for them. They follow the <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) process<a id="_idIndexMarker074"/> if possible. TDD is a technique in software development where tests are written even before any source code has been written. Once the tests have been written, the developer will program the source code to make them pass.</p>
			<p><strong class="bold">Frontend developers</strong>: Writing unit tests was almost impossible in the past. If you didn't have the right tools, you couldn't do your job correctly. But now, many modern libraries support unit testing. If you use React and Redux, you will find that Redux has a way to write unit tests for your components (https://www.hardkoded.com/ui-testing-with-puppeteer/redux-unit-tests).</p>
			<p>That's not all. In the same way that backend developers need to think about how to make their code testable, if frontend developers, using modern frameworks, start creating small and testable components, <strong class="bold">they should be able to use Puppeteer to write UI unit tests</strong>. And here is where the "UI" at the top of the testing pyramid stops making any sense. Now we can write <strong class="bold">UI unit tests</strong>.</p>
			<p>We can run a small test, rendering a component and testing, for instance, that it "<em class="italic">renders a textbox and when I enter a value, the label below changes</em>," or "<em class="italic">if I pass a list of 10 items, 10 elements are rendered</em>."</p>
			<p><em class="italic">We moved UI testing to the bottom of the testing pyramid.</em></p>
			<p><strong class="bold">QA Analysts</strong> are not involved yet. Unit tests are about testing the internal code.</p>
			<p>How about <strong class="bold">Managers</strong>? If you are a developer, I believe you are going to show this paragraph to your boss. Managers won't write unit tests, but they need to know the importance of writing unit tests and investing time in them. </p>
			<p>These are the four benefits you (or your boss) need to know about.</p>
			<h4>Unit tests show how the code works</h4>
			<p>Unit tests<a id="_idIndexMarker075"/> explain how the code works. When I review code, I start by reviewing unit tests. If I find unit tests saying, for instance, "<em class="italic">Create order should send email</em>". I could read that test first, and then, check how that rule was implemented.</p>
			<p>Business Analysts or project managers could read these tests and see whether there are any scenarios that haven't been covered or some missing validation.</p>
			<h4>Unit tests make refactoring possible</h4>
			<p>I took a risk using the word possible. But I believe that's true. You can't refactor your code if you don't have unit tests backing your changes. Remember, refactoring is changing the implementation of your code without changing the result given specific inputs. Unit tests guarantee that premise.</p>
			<h4>Unit tests prevent regressions</h4>
			<p><strong class="bold">Regression is an involuntary change in the expected behavior of an app</strong>. If we have a good set of tests, they will prevent us from breaking any behavior of the app while we implement new features or while fixing bugs.</p>
			<p>How can I make sure that some other developers won't come and break the precious function I just wrote? By writing unit tests. A unit test is a version of you in the future enforcing how a piece of code should work. "<em class="italic">Create an order should send an email</em>" – no one will be able to break that rule.</p>
			<p>When I review code, changes in unit tests are a red flag to me. I'm not saying that unit tests shouldn't change. But if a test changes, there must be an explanation. Now, the "<em class="italic">Create and order should send an email</em>" shows that the sent email count is 2. Is that right? Are we sending another email? Or do we have a regression? Pay attention to changes in unit tests.</p>
			<p>Time to go up in the test pyramid.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Service tests</h2>
			<p>Service tests are also <a id="_idIndexMarker076"/>known as <strong class="bold">Integration Tests</strong>. These tests will check how your code interacts with other components. When we talk about components, we are talking about the following:</p>
			<ul>
				<li>Databases</li>
				<li>Other components in the app</li>
				<li>External services</li>
			</ul>
			<p>Frontend developers would also need to integrate their code with the following:</p>
			<ul>
				<li>Other UI components</li>
				<li>CSS files</li>
				<li>REST APIs</li>
			</ul>
			<p>As we mentioned before, when we go up in the testing pyramid, tests become <strong class="bold">slower and less stable</strong>. And it's supposed to be like that. You will be connecting to a real database or interacting with a real REST API that would use real network calls. That would also mean that your tests would expect the environment to respond in a certain way. For instance, you would expect the database to have some set of data ready to be used, or a REST API to be available.</p>
			<p>That's why the more tests you have in the unit test layer, the fewer integration tests you will need to code.</p>
			<p>Let's take, for instance, the class that sends an email, could you code an integration test for that? Sure. You set up a local email server that would write emails in a temp folder, so after creating an order, you could check that folder and see whether the email server processed the email your app should have sent. But, as you can see, these kinds of orchestrations are harder to code than small unit tests.</p>
			<p>Why do we need integration tests? Why don't we code unit tests only?</p>
			<p>Well, you need to tests your integrations. Your code won't run in isolation. If you are testing the backend, you need to see how the database reacts to the data you are inserting, or whether a SQL query returns the data you expect.</p>
			<p>If you are a frontend developer, this is where you would invest most of your time, checking how your component interacts on a page or how the HTML being generated affects other elements in the DOM. You would need to test how your component is being rendered with a real REST endpoint, instead of using a dummy JSON file.</p>
			<h3>What roles use Integration tests?</h3>
			<p><strong class="bold">Backend developers</strong>: I've heard <a id="_idIndexMarker077"/>people say that these are the only tests that matter. Although I disagree with that strong opinion, I do believe these tests are essential. Say I created a unit test where, for instance, when I call <strong class="source-inline">CreateOrder</strong>, I get a new <strong class="source-inline">Order</strong> object. But now, I need to test that when I make a <strong class="source-inline">POST</strong> request to <strong class="source-inline">/orders</strong>, an order is created in the database.</p>
			<p><strong class="bold">Frontend developers</strong> will create tests to check how all the different components interact with each other on a page. Again, it's UI testing down in the testing pyramid.</p>
			<p><strong class="bold">QA Analysts</strong> will create tests similar to the tests backend and frontend developers create but with a different perspective.</p>
			<p><em class="italic">Developers and QA Analysts create the same kinds of tests but with a different perspective.</em></p>
			<p>Developers will create tests to back their job, so they can check whether they broke anything. And, as we mentioned before, they need tests to be able to refactor their code in the future.</p>
			<p><em class="italic">QA Analysts will create tests to guarantee the application quality to the stakeholders.</em></p>
			<p>There is one interesting type of test that QA Analysts can implement in this layer: the <strong class="bold">Visual Regression Test</strong>. These tests are used when we want to check whether there was any visual change regarding the style of the app. We don't want to check whether there is a button, or whether that button works. We want to check whether the button looks like how it was before. How can we achieve that? By comparing images. This technique is based on four steps:</p>
			<ol>
				<li>We take a screenshot as a baseline:<div id="_idContainer015" class="IMG---Figure"><img src="image/Figure_2.03_B16113.jpg" alt="Baseline image&#13;&#10;"/></div><p class="figure-caption">Baseline image</p></li>
				<li>We make a change in the code.</li>
				<li>We take another screenshot:<div id="_idContainer016" class="IMG---Figure"><img src="image/Figure_2.04_B16113.jpg" alt="Image after making a change&#13;&#10;"/></div><p class="figure-caption">Image after making a change</p></li>
				<li>We compare both images:</li>
			</ol>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.05_B16113.jpg" alt="Differences"/>
				</div>
			</div>
			<p class="figure-caption">Differences</p>
			<p>This type of test can be <a id="_idIndexMarker078"/>quite unstable. I bet you have seen that pages sometimes "move" when they are loading, so you have to be very sure when the page is ready for a screenshot. But it is doable. Another downside is that for every error you get, you have to analyze whether the change was a regression (a change made by mistake) or we are in the presence of a <strong class="bold">new baseline</strong>.</p>
			<p>The role of <strong class="bold">managers</strong> is still important. They need to provide the tools and the time for developers to implement the required integration tests. They will also help QA Analysts to determine what the integrations to test are.</p>
			<p>And so we come to the top of the pyramid, the <strong class="bold">end-to-end</strong> tests.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>End-to-end tests</h2>
			<p>You might also find these tests <a id="_idIndexMarker079"/>referred to as <strong class="bold">E2E</strong> tests. The goal of E2E tests is to guarantee that an application works as expected through the entire workflow. Most applications will have more than one workflow. That would mean that it will require a number of E2E tests to cover all the possible workflows or scenarios.</p>
			<p>Let's take a cart app as an example. These could be our tests:</p>
			<ul>
				<li>Unit tests:<p>a) Passing a cart object, the <strong class="source-inline">AddToCart</strong> component renders an <strong class="bold">Add to cart</strong> link if the product is not in the array.</p><p>b) Passing a cart object, the <strong class="source-inline">AddToCart</strong> component renders a "View cart" link if the product is in the array.</p></li>
				<li>Integration tests:<p>a) Go to a product page and click "Add to cart." The link changes to "View cart."</p><p>b) Go to the checkout page. After clicking on the <strong class="bold">Checkout</strong> button, it gets disabled.</p></li>
				<li>One E2E test testing the cart flow:<p>a) Go to a product page, click <strong class="bold">Add to cart</strong>, then click on <strong class="bold">View cart</strong>.</p><p>b) You should have got to the checkout page. Click <strong class="bold">Checkout</strong>.</p><p>c) You should have been redirected to the receipt page.</p><p>d) The receipt should show the product added to the cart.</p><p>e) The price should be the product price.</p></li>
			</ul>
			<p>We are at the top of the pyramid. That means that these will be the <strong class="bold">slowest and least stable</strong> tests.</p>
			<p>Why least stable? Check the workflow. Many<a id="_idIndexMarker080"/> bad things can happen there. The add to cart endpoint might take a little bit more than expected. The scroll to the <strong class="bold">Checkout</strong> button could have failed for just a few pixels. Your database might be in an unexpected state. Maybe your user already purchased that product, so the <strong class="bold">Add to cart</strong> button is not enabled.</p>
			<p>How about roles?</p>
			<p>This is the <strong class="bold">QA Analyst's</strong> land. This is where they need to take advantage of all the features Puppeteer provides to make reliable tests. But <strong class="bold">Developers</strong> play an important role, helping the QA team to do their job efficiently. As we are going to see in the next chapters, a developer can leave hints so that the QA team can find the components they need.</p>
			<p>I hope the picture of the pyramid makes more sense now. We need lots of small and isolated unit tests, many integration tests testing our pages, and finally, a good set of E2E tests, checking the workflow's health.</p>
			<p>This is the famous testing pyramid, but how do we write a test? Where do we write them? How do we run a test? </p>
			<p>First, we need to know what we need from a test runner.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Test runner features</h1>
			<p>What would the world be like<a id="_idIndexMarker081"/> without a test runner? Let's say you don't know what a test runner is, and you want to code a unit test. Would that be possible? I think it would. For instance, say we have this small <strong class="source-inline">Cart</strong> class:</p>
			<p class="source-code">class Cart {</p>
			<p class="source-code">    constructor() {</p>
			<p class="source-code">        this._cart = [];</p>
			<p class="source-code">    }</p>
			<p class="source-code">    total() {</p>
			<p class="source-code">        return this._cart.reduce((acc, v) =&gt; acc + v.price, 0);</p>
			<p class="source-code">    };</p>
			<p class="source-code">    addToCart(item) {</p>
			<p class="source-code">        this._cart.push(item);</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p class="source-code">module.exports = Cart;</p>
			<p>If we want to test it, we<a id="_idIndexMarker082"/> could run some code like this:</p>
			<p class="source-code">const Cart = require('./cart.js');</p>
			<p class="source-code">const c = new Cart();</p>
			<p class="source-code">c.addToCart({ productId: 10, price: 5.5});</p>
			<p class="source-code">c.addToCart({ productId: 15, price: 6.5});</p>
			<p class="source-code">if(c.total() !== 12)</p>
			<p class="source-code">    console.error('Nooo!!!');</p>
			<p class="source-code">else</p>
			<p class="source-code">    console.log('Yes!!!!!');</p>
			<p class="source-code"> </p>
			<p>A test is basically a piece of code testing our code. Will this work? Yes. Is this a unit test? Yes. Will this scale? Definitely not. This file will become massive and hard to maintain. Keeping track of what has failed would be an impossible task. We need a tool to help us scale and to help us keep our tests maintainable. We need a test runner.</p>
			<p>Before exploring possible test runners, I would like to review what we would expect from a test runner. What are the features we would need in a test runner?</p>
			<h4>Easy to learn and run</h4>
			<p>We have a lot of things to learn. We need to learn Node and React; we even have to buy a book about Puppeteer. We want a test runner that is simple and easy to use.</p>
			<h4>Group tests by functionality</h4>
			<p>We want to have our tests separated by functionality, component, or workflow. Most test runners have a <strong class="source-inline">describe</strong> function that helps us to group tests.</p>
			<h4>Ignore tests if needed</h4>
			<p>We want to skip a test if it <a id="_idIndexMarker083"/>becomes noisy, but we don't want to remove it.</p>
			<h4>Run only one test</h4>
			<p>Being able to run only one test is extremely important while debugging. Imagine you have over 1,000 tests (yes, you are going to have over 1,000 tests). If you want to fix only one test, you wouldn't want to run all of them. You would like to run only the one you are working on. </p>
			<h4>Assertions</h4>
			<p>Assertions are essential. An assertion<a id="_idIndexMarker084"/> is an expression to check whether the program we are testing worked as expected. Do you remember my <strong class="source-inline">console.log</strong> and <strong class="source-inline">console.error</strong> to check whether the cart worked as expected? Well, Assertions are way better than that. What do we want to check with Assertions? This is a possible list:</p>
			<ul>
				<li>Whether a value is equal to a test value.</li>
				<li>Whether a value is null or not null.</li>
				<li>Whether a string or a list contains a value. We might have a huge block of text, and we only want to check whether it has some string in it, or an item in an array.</li>
				<li>Whether we expected something to fail, because sometimes, we would expect some piece of code to fail.</li>
			</ul>
			<h4>Tools to set up and clean up the environment </h4>
			<p>Before starting the tests, we need our application to be in a certain state. For instance, in the cart test, we would like to make sure that the customer has not already purchased the product before starting the test.</p>
			<p>There are also technical setups that might need to be performed. In our case, we would need to have Puppeteer and a browser ready to be used before each test.</p>
			<p>Another important concept is that tests should be independent and detached from each other. This means that the result of one test must not affect other tests. This is why, very often, it is required to clean up after each or all tests.</p>
			<h4>Reports</h4>
			<p>We want to see which tests <a id="_idIndexMarker085"/>passed and which tests failed. We would expect a test runner to at least show a good report in the terminal. It could be even better if we can get results in other formats, such as JSON, XML, or HTML.</p>
			<p>There are many other features we could mention, but these are the most important features we need to know about before getting started. </p>
			<p>Let's now see what the test runners available on the market that can cover the features we are requesting.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Available test runners</h1>
			<p>There are many types of<a id="_idIndexMarker086"/> tennis racquets. Some racquets give you more control. Others give you more power. If you have just started learning how to play tennis, you won't feel any difference. You would if you compared a cheap racquet with a professional one. But you wouldn't be able to say why one is better than the other. You would say that it just <em class="italic">feels better</em>.</p>
			<p>It's the same with test runners. There are test runners that offer some features. Other runners offer other features. But what's important for us now is to get a test runner that provides us with all the required features to write our automated tests.</p>
			<p>Another<a id="_idIndexMarker087"/> important thing to mention is that this book is not about "using Puppeteer with X." We are going to pick a test runner after this chapter, but it doesn't need to be the test runner for you. The idea is that you can choose what's best for you, or what your team is using right now. It is also probable that by the time you read this book, a better test runner will have become popular. You should be able to apply the concepts you learned from this book to that test runner.</p>
			<p>These are the most common test runners in the market today.</p>
			<h3>Jest</h3>
			<p>According to the <a id="_idIndexMarker088"/>Jest site (<a href="https://jestjs.io/">https://jestjs.io/</a>), "<em class="italic">Jest is a delightful JavaScript Testing Framework with a focus on simplicity</em>." Pretty nice introduction. Facebook maintains <a id="_idIndexMarker089"/>this project, and it currently has over 32,000 stars on GitHub. I'm<a id="_idIndexMarker090"/> not saying this is what makes a project a good project, but knowing who is behind a project and its level of community support are some of the things to take into consideration.</p>
			<p>Jest has all the features we mentioned before, such as group tests with <strong class="source-inline">describe</strong>, and each test is an <strong class="source-inline">it</strong> or <strong class="source-inline">test</strong> function. You can skip tests with <strong class="source-inline">describe.skip</strong>, <strong class="source-inline">it.skip</strong>, or <strong class="source-inline">test.skip</strong>. You can run only one test with <strong class="source-inline">describe.only</strong>, <strong class="source-inline">it.only</strong>, or <strong class="source-inline">test.only</strong>. You also have <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">afterEach</strong>, <strong class="source-inline">beforeAll</strong>, and <strong class="source-inline">afterAll</strong>, to run setup and cleanup code.</p>
			<p>It also has some features that differentiate it from other runners. It has a <strong class="bold">Snapshot</strong> tool. The snapshot tool<a id="_idIndexMarker091"/> would process a React component and return some kind of DOM representation as JSON, which will allow us to test whether the DOM created by the component has changed. Is this a kind of UI test? Sure it is!</p>
			<p>Another thing to consider when evaluating a test runner is available plugins. For instance, there is a package called <strong class="bold">jest-puppeteer</strong>, which<a id="_idIndexMarker092"/> helps us integrate our tests with Puppeteer. You don't need to use <strong class="bold">jest-puppeteer</strong>. It's just a helper.</p>
			<p>There is also a package called <strong class="bold">jest-image-snapshot</strong>, maintained <a id="_idIndexMarker093"/>by American Express, which provides a set of tools to perform visual regression tests. In this case, if you want to code visual regression tests, I recommend you to use one of these packages. Managing all the screenshot baselines can be quite tedious.</p>
			<h3>Mocha</h3>
			<p>Mocha<a id="_idIndexMarker094"/> is another popular framework. It is a community project with over 19,000 stars. Something<a id="_idIndexMarker095"/> worth mentioning is that the Puppeteer team uses Mocha.</p>
			<p>Mocha also has functions like Jest. It has a <strong class="source-inline">describe</strong> function to group tests. Tests are <strong class="source-inline">it</strong> functions. You can skip functions using <strong class="source-inline">describe.skip</strong> or <strong class="source-inline">it.skip</strong>, and use <strong class="source-inline">describe.only</strong> or <strong class="source-inline">it.only</strong> to run only one test. You also have <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">afterEach</strong>, <strong class="source-inline">beforeAll</strong>, and <strong class="source-inline">afterAll</strong>, to run setup and cleanup code.</p>
			<p>You will also find many plugins for <a id="_idIndexMarker096"/>Mocha. You will <a id="_idIndexMarker097"/>find <strong class="bold">mocha-puppeteer</strong> and <strong class="bold">mocha-snapshots</strong>.</p>
			<p>A recipe you are going to see a lot on the web is Mocha + Chai. <strong class="bold">Chai</strong> is an assertion library that extends the assertions a test runner provides. It lets you express assertions in a pretty specific way:</p>
			<p class="source-code">foo.should.be.a('string');</p>
			<p class="source-code">foo.should.equal('bar');</p>
			<p class="source-code">foo.should.have.lengthOf(3);</p>
			<p class="source-code">tea.should.have.property('flavors').with.lengthOf(3);</p>
			<p>There are many other test runners, such as Jasmine by Pivotal Labs with over 15,000 stars, Karma by the AngularJS team with over 11,000 stars, AVA, a community project with over 18,000 stars, and the list goes on.</p>
			<p>As I mentioned at the beginning of this section, we just need a good tennis racquet, that is, a good test runner. When you become an expert, you will be able to move from one test runner to another that fits your needs. For the purpose of this book, we are going to use <strong class="bold">Mocha + Chai</strong>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Creating our first test project</h1>
			<p>We will create a Node application in the same way <a id="_idIndexMarker098"/>we created our first app in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>. We are going to create a folder called <strong class="source-inline">OurFirstTestProject</strong> (you will find this directory inside the <strong class="source-inline">Chapter2</strong> directory mentioned in the <em class="italic">Technical requirements</em> section) and then execute <strong class="source-inline">npm init -y</strong> inside that folder:</p>
			<p class="source-code">&gt; npm init -y</p>
			<p>The response should be something like this:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "name": "OurFirstTestProject",</p>
			<p class="source-code">  "version": "1.0.0",</p>
			<p class="source-code">  "description": "",</p>
			<p class="source-code">  "main": "index.js",</p>
			<p class="source-code">  "scripts": {</p>
			<p class="source-code">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "keywords": [],</p>
			<p class="source-code">  "author": "",</p>
			<p class="source-code">  "license": "ISC"</p>
			<p class="source-code">}</p>
			<p>Now it's time to install the packages we are going to use:</p>
			<ul>
				<li>Puppeteer 7</li>
				<li>Mocha (any version)</li>
				<li>Chai (any version)</li>
			</ul>
			<p>Let's run the following commands:</p>
			<p class="source-code">&gt; npm install puppeteer@"&gt;=7.0.0 &lt;8.0.0"</p>
			<p class="source-code">&gt; npm install mocha</p>
			<p class="source-code">&gt; npm install chai</p>
			<p>For this first demo, we are going to use the site <a href="https://www.packtpub.com/">https://www.packtpub.com/</a> as a test case. Let's keep our test simple. We want to test that the page title says <em class="italic">Packt | Programming Books, eBooks &amp; Videos for Developers.</em></p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The site we are using for this test might have changed over time. Before testing this code, go to <a href="https://www.packtpub.com/">https://www.packtpub.com/</a> and check whether the title is still the same. That's why, in the following chapters, we will be downloading sites locally, so we avoid these possible issues.</p>
			<p>We mentioned<a id="_idIndexMarker099"/> that we would use <strong class="source-inline">describe</strong> to group our tests. But separating tests into different files will also help us to get our code organized. You can choose between having one or many <strong class="source-inline">describe</strong> functions per file. Let's create a file called <strong class="source-inline">home.tests.js</strong>. We are going to put all tests related to the home page there.</p>
			<p>Although you can create the files anywhere you want, Mocha grabs all the tests in the <strong class="source-inline">test</strong> folder by default, so we will to create the <strong class="source-inline">test</strong> folder and then create the <strong class="source-inline">home.test.js</strong> file inside that folder.</p>
			<p>We are going to have the following:</p>
			<ul>
				<li><strong class="source-inline">home.tests.js</strong> with the home tests</li>
				<li>A <strong class="source-inline">describe</strong> function with the header tests</li>
				<li>An <strong class="source-inline">it</strong> function testing <em class="italic">"Title should have Packt name"</em></li>
				<li>Another <strong class="source-inline">it</strong> function testing <em class="italic">"Title mention the word Books"</em></li>
			</ul>
			<p>The structure should look like this:</p>
			<p class="source-code">const puppeteer = require('puppeteer');</p>
			<p class="source-code">const expect = require('chai').expect;</p>
			<p class="source-code">const should = require('chai').should();</p>
			<p class="source-code">describe('Home page header', () =&gt; {</p>
			<p class="source-code">    it('Title should have Packt name', async() =&gt; {</p>
			<p class="source-code">    });</p>
			<p class="source-code">    it('Title should mention Books', async() =&gt; {</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p>Let's unpack this code:</p>
			<ol>
				<li value="1">We are importing<a id="_idIndexMarker100"/> Puppeteer in line 1.</li>
				<li>Lines 2 are 3 are about importing the different types of assertion styles <strong class="bold">Chai</strong> provides. As you can see, <strong class="source-inline">expect</strong> is not being called with parentheses whereas <strong class="source-inline">should</strong> is. We don't need to know why now. But, just to be clear, that's not a mistake.</li>
				<li>How about Mocha? Are we missing Mocha? Well, Mocha is the test runner. It will be the executable we will call later in <strong class="source-inline">package.json</strong>. We don't need it in our code.</li>
				<li>It's interesting to see that both <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> are just simple functions that take two arguments: a string and a function. Can you pass a function as an argument? Yes, you can!</li>
				<li>The functions we are passing to the <strong class="source-inline">it</strong> functions are <strong class="source-inline">async</strong>. We can't use the <strong class="source-inline">await</strong> keyword in functions that are not marked as <strong class="source-inline">async</strong>. Remember that Puppeteer relies a lot on async programming.</li>
			</ol>
			<p>Now we need to launch a browser and set up everything these tests need to work. We could do something like this:</p>
			<p class="source-code">it('Title should have Packt name', async() =&gt; {</p>
			<p class="source-code">    const browser = await puppeteer.launch();</p>
			<p class="source-code">    const page = await browser.newPage();</p>
			<p class="source-code">    await page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">    // Our test code</p>
			<p class="source-code">    await browser.close();</p>
			<p class="source-code">});</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't try to learn the Puppeteer API now. We are going to explain how all of these commands work in <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>.</p>
			<p>This code will run<a id="_idIndexMarker101"/> perfectly. However, there are two things that could do with optimization:</p>
			<ul>
				<li>We would be repeating the same code over and over.</li>
				<li>If something fails in the middle of the test, the browser won't get closed, leaving lots of open browsers.</li>
			</ul>
			<p>To avoid these problems, we can use <strong class="source-inline">before</strong>, <strong class="source-inline">after</strong>, <strong class="source-inline">beforeEach</strong>, and <strong class="source-inline">afterEach</strong>. If we add these functions to our tests, this would be the execution order:</p>
			<ul>
				<li><strong class="source-inline">before</strong></li>
				<li><strong class="source-inline">beforeEach</strong></li>
				<li><strong class="source-inline">it('Title should have Packt name')</strong></li>
				<li><strong class="source-inline">afterEach</strong></li>
				<li><strong class="source-inline">beforeEach</strong></li>
				<li><strong class="source-inline">it('Title should mention Books')</strong></li>
				<li><strong class="source-inline">afterEach</strong></li>
				<li><strong class="source-inline">after</strong></li>
			</ul>
			<p>It's not a rule of thumb, but we can do something like this in our case:</p>
			<ol>
				<li value="1"><strong class="source-inline">before</strong>: Launch the browser.</li>
				<li><strong class="source-inline">beforeEach</strong>: Open a page and navigate to the URL.</li>
				<li>Run the test.</li>
				<li><strong class="source-inline">afterEach</strong>: Close the page.</li>
				<li><strong class="source-inline">after</strong>: Close the browser.</li>
			</ol>
			<p>These <strong class="bold">hooks</strong>, which is what<a id="_idIndexMarker102"/> Mocha calls these functions, would look like this:</p>
			<p class="source-code">let browser;</p>
			<p class="source-code">let page;</p>
			<p class="source-code">before(async () =&gt; {</p>
			<p class="source-code">    browser = await puppeteer.launch();</p>
			<p class="source-code">});</p>
			<p class="source-code">beforeEach(async () =&gt; {</p>
			<p class="source-code">    page = await browser.newPage();</p>
			<p class="source-code">    await page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">});</p>
			<p class="source-code">afterEach(async () =&gt; {</p>
			<p class="source-code">    await page.close();</p>
			<p class="source-code">});</p>
			<p class="source-code">after(async () =&gt; {</p>
			<p class="source-code">    await browser.close();</p>
			<p class="source-code">});</p>
			<p>One thing to mention here is that we<a id="_idIndexMarker103"/> could do what's called <strong class="bold">Fire and Forget</strong> when <a id="_idIndexMarker104"/>closing the page or the browser. Fire and forget means that we don't want to <strong class="source-inline">await</strong> the result of <strong class="source-inline">page.close()</strong> or <strong class="source-inline">browser.close()</strong>. So, we could do this:</p>
			<p class="source-code">afterEach(() =&gt; page.close());</p>
			<p class="source-code">after(() =&gt; browser.close());</p>
			<p>That's not something I love doing because if something fails, you would like to know where and why. But as this is just cleanup code for a test, it's not production code, we can afford that risk.</p>
			<p>Now our test has a browser opened, a page with the URL we want to test read. We just need to test the title:</p>
			<p class="source-code">it('Title should have Packt name', async() =&gt; {</p>
			<p class="source-code">    const title = await page.title();</p>
			<p class="source-code">    title.should.contain('Packt');</p>
			<p class="source-code">});</p>
			<p class="source-code">it('Title should should mention Books', async() =&gt; {</p>
			<p class="source-code">    expect((await page.title())).to.contain('Books');</p>
			<p class="source-code">});</p>
			<p>I used two different styles here.</p>
			<p>In the first case, I'm assigning the result of the <strong class="source-inline">title</strong> async function to a variable, and then using <strong class="source-inline">should.contain</strong> to check whether the title contains the word <em class="italic">"Packt"</em>. In the second case, I just evaluated <strong class="source-inline">((await page.title())</strong>. I added some extra parentheses there for clarification. You won't see them in the final example.</p>
			<p>The second difference is that in the first case, I'm using the <strong class="bold">should</strong> style, whereas in the second case, I'm using the <strong class="bold">expect</strong> style. The result will be the same. It's just about which style you feel more comfortable with or feels more natural to you. There is even a third style: <strong class="bold">assert</strong>.</p>
			<p>We have everything we need to<a id="_idIndexMarker105"/> run our tests. Remember how <strong class="source-inline">npm init</strong> created a <strong class="source-inline">package.json</strong> file for us? It's time to use it. Let's set the <strong class="source-inline">test</strong> command. You should have something like this:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</p>
			<p class="source-code">},</p>
			<p>We need to tell <strong class="source-inline">npm</strong> to run <strong class="bold">Mocha</strong> when we execute <strong class="source-inline">npm test</strong>:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "test": "mocha"</p>
			<p class="source-code">},</p>
			<p>Time to run our tests! Let's run <strong class="source-inline">npm test</strong> in the terminal:</p>
			<p class="source-code">npm test</p>
			<p>And we should have our first error:</p>
			<p class="source-code">  1) Home page header</p>
			<p class="source-code">       "before each" hook for "Title should have Packt name":</p>
			<p class="source-code">     Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves.</p>
			<p>That's bad, but not that bad. Mocha validates by default that our tests should take less than 2,000 ms. That sounds OK for an isolated unit test. But UI tests might take longer than 2 seconds. That doesn't mean that UI tests shouldn't have a timeout. <strong class="bold">Speed is a feature</strong>, so we should be able to enforce some expected timeout. We can change that by adding the <strong class="source-inline">--timeout</strong> command-line argument to the launch setting we set up in the <strong class="source-inline">package.config</strong> file. I think 30 seconds could be a reasonable timeout. As it expects the value in milliseconds, it <a id="_idIndexMarker106"/>should be <strong class="source-inline">30000</strong>. Let's make that change in our <strong class="source-inline">package.config</strong> file:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "test": "mocha --timeout 30000"</p>
			<p class="source-code">},</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The command-line argument is not the only way to set up the timeout. You can call <strong class="source-inline">this.Timeout (30000)</strong> inside the <strong class="source-inline">describe</strong> function or configure the timeout using a config file (<a href="https://mochajs.org/#configuring-mocha-nodejs">https://mochajs.org/#configuring-mocha-nodejs</a>).</p>
			<p>Once we set up the timeout, we can try our tests again by running <strong class="source-inline">npm test</strong>:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.06_B16113.jpg" alt="Test Result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Test Result</p>
			<p>Mocha not only ran our tests but also printed a pretty decent report. We have there all the tests Mocha ran, the final result, and the elapsed time. Here is where many test runners offer different options. For instance, Mocha has a <strong class="source-inline">--reporter</strong> flag. If you go to https://mochajs.org/, you will see all the <a id="_idIndexMarker107"/>available reporters. We could use the <strong class="source-inline">list</strong> reporter, which shows the elapsed time of each test. We can add it to our <strong class="source-inline">package.config</strong> file:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  "test": "mocha --timeout 30000 --reporter=list"</p>
			<p class="source-code">},</p>
			<p>With this change, we can get a better report:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.07_B16113.jpg" alt="Test Result using the list reporter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Test Result using the list reporter</p>
			<p>This project looks fine. If you had <a id="_idIndexMarker108"/>only a few tests, this would be enough. But if we are going to have lots of tests using many pages, this code won't scale. We need to organize our code so that we can be more productive and reuse more code.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Organizing our code</h1>
			<p>Our first test was quite simple: we <a id="_idIndexMarker109"/>were just checking the page title. But let's take a look at the home page:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.08_B16113.jpg" alt="Packtpub home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Packtpub home page</p>
			<p>There are many actions we would like to test there: </p>
			<ul>
				<li>Search for an existing book.</li>
				<li>Search for a non-existing book.</li>
				<li>Check the cart when it is empty.</li>
				<li>Check the cart when we add a product.</li>
			</ul>
			<p>Let's take, for <a id="_idIndexMarker110"/>example, <em class="italic">Search tests</em>. We would be doing the same steps every time:</p>
			<ol>
				<li value="1">Click on the search box.</li>
				<li>Enter the text.</li>
				<li>Click on the search button.</li>
			</ol>
			<p>We would be doing the same thing over and over in all our search tests. Sometimes there is a misconception that, as the test code is not production code, the code can be a mess. So, people go and copy/paste their tests over and over, duplicating code and hardcoding values. That ends up with hard-to-maintain tests. When tests are hard to maintain, they tend to be pushed down the priority list. Developers lose, QA analysts lose, and in the end, clients lose.</p>
			<p>We are going to see two techniques to improve our test code: the <strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) and the test data config. </p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Introducing the Page Object Model</h2>
			<p>The POM is a design<a id="_idIndexMarker111"/> pattern that will help us separate our test code from the implementation of the interaction our tests will perform.</p>
			<p>Let's build our <strong class="source-inline">HomePageModel</strong> together. What are the possible interactions on that page?</p>
			<ul>
				<li><strong class="bold">Go</strong> (to the page)<strong class="bold"> </strong></li>
				<li><strong class="bold">Get page title</strong></li>
				<li><strong class="bold">Search</strong></li>
				<li><strong class="bold">Sign In</strong></li>
				<li><strong class="bold">View Cart</strong></li>
				<li><strong class="bold">Go to Checkout</strong></li>
				<li><strong class="bold">Subscribe</strong></li>
			</ul>
			<p>Well done! We just <a id="_idIndexMarker112"/>created our first Page Model. This is how it will look:</p>
			<p class="source-code">module.exports = class HomePageModel {</p>
			<p class="source-code">    go() {}</p>
			<p class="source-code">    title() {}</p>
			<p class="source-code">    search(searchValue) {}</p>
			<p class="source-code">    signIn() {}</p>
			<p class="source-code">    viewCart(){}</p>
			<p class="source-code">    gotoCheckout(){}</p>
			<p class="source-code">    subscribe(){}</p>
			<p class="source-code">}</p>
			<p>Let's focus on the two first functions: the <strong class="source-inline">go</strong> function, which will navigate to the home page, and the <strong class="source-inline">title</strong> function, which will return the page title.</p>
			<p>We will reuse a lot of code here. If we want to start using this model, we would need to do two things: implement the title fetching here and pass a Puppeteer page to this model:</p>
			<p class="source-code">export default class HomePageModel {</p>
			<p class="source-code">    constructor(page) {</p>
			<p class="source-code">        this.page = page;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Unused functions…</p>
			<p class="source-code">    async go() {</p>
			<p class="source-code">        await this.page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">    }</p>
			<p class="source-code">    async title() {</p>
			<p class="source-code">        return await this.page.title();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now it's a matter of importing this class into our tests using <strong class="source-inline">require</strong>. I will put this class into a <strong class="bold">POM</strong> (<strong class="bold">Page Object Model</strong>) folder inside<a id="_idIndexMarker113"/> the test folder. Once we create the file, we import it:</p>
			<p class="source-code">const HomePageModel = require('./pom/HomePageModel.js');</p>
			<p>We declare a variable inside the describe:</p>
			<p class="source-code">let homePageModel;</p>
			<p>We create an instance of this class in the <strong class="source-inline">beforeEach</strong> hook:</p>
			<p class="source-code">beforeEach(async () =&gt; {</p>
			<p class="source-code">    page = await browser.newPage();</p>
			<p class="source-code">    homePageModel = new HomePageModel(page);</p>
			<p class="source-code">    await homePageModel.go();</p>
			<p class="source-code">});</p>
			<p>And now, we simply replace the <strong class="source-inline">page.title</strong> we are using with <strong class="source-inline">homePageModel.title</strong>:</p>
			<p class="source-code">(await homePageModel.title()).should.contain('Packt');</p>
			<p>As I mentioned earlier in the chapter, UI tests help us see whether our refactoring broke our code. Let's run <strong class="source-inline">npm test</strong> again to confirm that we didn't break anything:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.09_B16113.jpg" alt="Test result after the first refactor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Test result after the first refactor</p>
			<p>There's only one thing left to do so that we can be proud of our first project. We need to get rid of our hardcoded values. We only wrote two tests, and we have three hardcoded values: the site URL and the <strong class="source-inline">Packt</strong> and the <strong class="source-inline">Books</strong> words.</p>
			<p>For these tests, we can leave <a id="_idIndexMarker114"/>these hardcoded values. But what if you have different environments? You would need to make the URL dynamic. What if your site were a generic e-commerce site? The brand name would depend on the test you are navigating.</p>
			<p>There are many other use cases:</p>
			<ul>
				<li>Test users and passwords</li>
				<li>Product to test</li>
				<li>Keywords to use</li>
			</ul>
			<p>We can create a <strong class="source-inline">config.js</strong> file with all the environment settings and return only the one we get on an environment variable. If not set, we return the local version:</p>
			<p class="source-code">module.exports = ({</p>
			<p class="source-code">    local: {</p>
			<p class="source-code">        baseURL: 'https://www.packtpub.com/',</p>
			<p class="source-code">        brandName: 'Packt',</p>
			<p class="source-code">        mainProductName: 'Books'</p>
			<p class="source-code">    },</p>
			<p class="source-code">    test: {},</p>
			<p class="source-code">    prod: {},</p>
			<p class="source-code">})[process.env.TESTENV || 'local']</p>
			<p>If this looks a little bit scary, don't worry, it's not that complex:</p>
			<ul>
				<li>It returns an object with three properties: <strong class="source-inline">local</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">prod</strong>.</li>
				<li>In JavaScript, you can access a property by using <strong class="source-inline">object.property</strong> or by treating the object as a dictionary: <strong class="source-inline">object['local']</strong>.</li>
				<li><strong class="source-inline">process.env</strong> allows us to read environment variables. We won't be using environment variables in this book, but I wanted to show you the final solution.</li>
				<li>Finally, we are going to return only the <strong class="source-inline">local</strong>, <strong class="source-inline">test</strong>, or <strong class="source-inline">prod</strong> property based on the <strong class="source-inline">TESTENV</strong> variable or <strong class="source-inline">'local'</strong> if the environment variable was not set.</li>
			</ul>
			<p>I bet that by now, you will know that we will be able to access this object using a <strong class="source-inline">require</strong> call:</p>
			<p class="source-code">const config = require('./config');</p>
			<p>And from there, start <a id="_idIndexMarker115"/>using the <strong class="source-inline">config</strong> variable instead of hardcoded values. We would also need to pass this config to the page model because we have a hardcoded URL there.</p>
			<p>After making all these changes, this is what our tests should look like:</p>
			<p class="source-code">const puppeteer = require('puppeteer');</p>
			<p class="source-code">const expect = require('chai').expect;</p>
			<p class="source-code">const should = require('chai').should();</p>
			<p class="source-code">const HomePageModel = require('./pom/HomePageModel.js');</p>
			<p class="source-code">const config = require('./config');</p>
			<p class="source-code">describe('Home page header', () =&gt; {</p>
			<p class="source-code">    let browser;</p>
			<p class="source-code">    let page;</p>
			<p class="source-code">    let homePageModel;</p>
			<p class="source-code">    before(async () =&gt; browser = await puppeteer.launch());</p>
			<p class="source-code">    beforeEach(async () =&gt; {</p>
			<p class="source-code">        page = await browser.newPage();</p>
			<p class="source-code">        homePageModel = new HomePageModel(page, config);</p>
			<p class="source-code">        await homePageModel.go();</p>
			<p class="source-code">    });</p>
			<p class="source-code">    afterEach(() =&gt; page.close());</p>
			<p class="source-code">    after(() =&gt; browser.close());</p>
			<p class="source-code">    it('Title should have Packt name', async() =&gt; {</p>
			<p class="source-code">        (await homePageModel.title()).should.contain(config.brandName);</p>
			<p class="source-code">    });</p>
			<p class="source-code">    it('Title should mention Books', async() =&gt; {</p>
			<p class="source-code">        expect(await homePageModel.title()).to.contain(config.mainProductName);</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p>If we remove all the unused functions, our final page model would look like this:</p>
			<p class="source-code">module.exports = class HomePageModel {</p>
			<p class="source-code">    constructor(page, config) {</p>
			<p class="source-code">        this.page = page;</p>
			<p class="source-code">        this.config = config;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    async go() {</p>
			<p class="source-code">        await this.page.goto(this.config.baseURL);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    async title() {</p>
			<p class="source-code">        return await this.page.title();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>As you can see, we didn't need to implement complex design patterns to make our tests reusable and easy to maintain. I think it's time to get started with our tests, which we will do in <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Summary</h1>
			<p>In this chapter, we started with the foundations of automated testing. Mike Cohn's pyramid helped us to understand the different types of tests. We also gave this pyramid a new look, showing how it should be used from a Frontend developer perspective. We also made it clear that both developers and QA analysts are part of this pyramid, but with different perspectives.</p>
			<p>In the second part of the chapter, we got more practical, and we looked into test runners. A learning point here is that we used Mocha as a test runner, but everything you learned in this chapter should be possible with any test runner; that is, we used Mocha, but we could have used any other test runner.</p>
			<p>We use many Puppeteer APIs in our tests. In the next chapter, we are going to dive deep into these APIs and see how we can use Puppeteer in different scenarios.</p>
		</div>
	</body></html>