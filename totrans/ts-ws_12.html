<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-218">11. <a id="_idTextAnchor266"/>Higher-Order Functions and Callbacks</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces higher-order functions and callbacks in TypeScript. You will first understand what higher-order functions are, why they are useful, and how to type them correctly in TypeScript. Then, the chapter will teach you about what callbacks are, why they are used, and in what situations. You will also learn about why callbacks are so widely used, especially in Node.js.</p>
			<p class="callout">Additionally, the chapter will provide you with a basic introduction to the event loop. Not only will you learn about "callback hell," but also how you can avoid it. By the end of this chapter, you will be able to create a well-typed higher-order <code>pipe</code> function.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor267"/>Introduction</h1>
			<p>You have already covered the use of functions in TypeScript in <em class="italic">Chapter 3</em>, <em class="italic">Functions</em>. This chapter will introduce you to higher-order functions in TypeScript. Hitherto, with all the functions that you have used in this book, you either passed parameters or arguments into them. However, JavaScript and, by extension, TypeScript, has many ways of composing and writing code. In this chapter, we'll explore one such pattern â€“ higher-order functions/callbacks (hereinafter called HOCs) are functions that either take in another function as an argument or return a function (or both).</p>
			<p>Additionally, this chapter also explores the concept of callbacks. Callbacks are required in Node.js, as well as in other JavaScript runtimes, since the language is single-threaded and runs in an event loop, and so, in order to not hold up the main thread, we let other code run, and when needed it will call our code back. This chapter will also touch upon "callback hell" and equip you with the skills needed to avoid it. </p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor268"/>Introduction to HOCs â€“ Examples</h2>
			<p>HOCs are frequently used in JavaScript, and especially in Node.js, where even the simplest backend server application contains it. Here is an example:</p>
			<pre>const http = require("http");
http.createServer((req, res) =&gt; {
Â Â res.write("Hello World");
Â Â res.end();
}).listen(3000, () =&gt; {
Â Â console.log("ðŸš€ running on port 3000");
});</pre>
			<p>Notice that the <code>createServer</code> function takes in a request listener <em class="italic">function</em>, which will be used to handle any incoming requests. This function will take in two arguments, <code>req</code> and <code>res</code> â€“ the request object and the response object, respectively:</p>
			<div><div><img src="img/B14508_11_01.jpg" alt="Figure 11.1: Part of the http module in Node.js describing the callback &#13;&#10;structure of RequestListener&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1: Part of the http module in Node.js describing the callback structure of RequestListener</p>
			<p>In addition, the <code>listen</code> method also takes in an optional function that will run when the server is ready to listen for requests.</p>
			<p>Both <code>createServer</code> and <code>listen</code> are HOCs because they take in functions as arguments. These argument functions are usually called <em class="italic">callbacks</em>, since this is how our code can get "called back" (notified) when something happens, and, if needed, handle it appropriately. In the preceding example, the HTTP server needs to know how to handle incoming requests, so it calls our given <code>requestListener</code> function, which provides the logic for that. Later, the <code>listen</code> function wants to let us know when it's ready to accept requests, and it calls our given callback when it is.</p>
			<p>Another example is the <code>setTimeout</code> function, which takes in another <em class="italic">function</em> as an argument to call later â€“ after the timeout has passed:</p>
			<pre>setTimeout(() =&gt; {
Â Â Â Â console.log('5 seconds have passed');
},  5000);
function setTimeout(callback: (...args: any[]) =&gt; void, ms: number, ...args: any[]): NodeJS.Timeout;</pre>
			<p>A<a id="_idTextAnchor269"/>nother example of an HOC that does not take a callback function is the <code>memoize</code> function. This takes in a function to <code>memoize</code> as an argument and returns a function with the same signature:</p>
			<pre>function memoize&lt;Fn extends AnyFunction&gt;(fn: Fn, keyGetter?: KeyGetter&lt;Fn&gt;): Fn;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>memoize</code> function takes in a function and returns a function with the same type signature; however, the returned function caches the results of the original function. This is usually useful for expensive functions that take a long time to run and return the same output for the same arguments. <em class="italic">Chapter 9</em>, <em class="italic">Generics and Conditional Types</em>, <em class="italic">Exercise 9.01</em>, implements such a <code>memoize</code> function.</p>
			<p>In the following sections, we'll explore both kinds of HOCs in more detail and see how we can avoid some of the pitfalls they introduce.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor270"/>Higher-Order Functions</h1>
			<p>Higher-order functions are regular functions that follow at least one of these twoÂ principles:</p>
			<ol>
				<li>They take one or more functions as arguments.</li>
				<li>They return a function as a result.</li>
			</ol>
			<p>For example, let's say we want to write a <code>greet</code> function:</p>
			<pre>Example01.ts
1 function greet(name: string) {
2   console.log(`Hello ${name}`);
3 }
4
5 greet('John'); 
Link to the preceding example: <a href="https://packt.link/GCFjN">https://packt.link/GCFjN</a></pre>
			<p>The following is the output:</p>
			<pre>Hello John</pre>
			<p>This is a fine function, but it's very limited â€“ what if each person has a favorite greeting? Consider the following example:</p>
			<pre>Example02.ts
1 const favoriteGreetings: Record&lt;string, string&gt; = {
2   John: 'Hey',
3   Jane: 'Hello',
4   Doug: 'Howdy',
5   Sally: 'Hey there',
6 };
Link to this example: <a href="https://packt.link/CXBrV">https://packt.link/CXBrV</a></pre>
			<p>We could put that inside the <code>greet</code> function:</p>
			<pre>function greet(name: string) {
Â Â const greeting = favoriteGreetings[name] || 'Hello';
Â Â console.log(`${greeting} ${name}`);
}
greet('John'); </pre>
			<p>The following is the output:</p>
			<pre>Hey John</pre>
			<p>But that means that the <code>greet</code> function is no longer reusable by itself since, if we were to take it, we'd also need to bring along the <code>favoriteGreetings</code> mapping with it. Instead, we could pass it in as a parameter:</p>
			<pre>Example03.ts
1 function greet(name: string, mapper: Record&lt;string, string&gt;) {
2   const greeting = mapper[name] || 'Hello';
3   console.log(`${greeting} ${name}`);
4 }
5
6 greet('John', favoriteGreetings); // prints 'Hey John'
7 greet('Doug', favoriteGreetings); // prints 'Howdy Doug'
Link to this example: <a href="https://packt.link/bG0p7">https://packt.link/bG0p7</a></pre>
			<p>The following is the output:</p>
			<pre>Hey John
Howdy Doug</pre>
			<p>This works, but it's very cumbersome to pass in the <code>favoriteGreetings</code> object in every call.</p>
			<p>We can improve on this by making the <code>greet</code> function accept a function that will serve as a more generic solution to the favorite-greeting issue â€“ it will accept the name and return the greeting to use: </p>
			<pre>Example04.ts
1 function greet(name: string, getGreeting: (name: string) =&gt; string) {
2   const greeting = getGreeting(name);
3   console.log(`${greeting} ${name}`);
4 }
5 
6 function getGreeting(name: string) {
7   const greeting = favoriteGreetings[name];
8   return greeting || 'Hello';
9 }
10
11 greet('John', getGreeting); // prints 'Hey John'
12 greet('Doug', getGreeting); // prints 'Howdy Doug'
Link to this example: <a href="https://packt.link/uRe2r">https://packt.link/uRe2r</a></pre>
			<p>The following is the output:</p>
			<pre>Hey John
Howdy Doug</pre>
			<p>This may feel the same as our previous solution, which took the mapper object as an argument, but passing in a function is much more powerful. We can do a lot more with a function than with a static object. For example, we could base the greeting on the time of day:</p>
			<pre>Example05.ts
1  function getGreeting(name: string) {
2    const hours = new Date().getHours();
3   if (hours &lt; 12) {
4     return 'Good morning';
5   }
6   
7   if (hours === 12) {
8     return 'Good noon';
9   }
10  
11  if (hours &lt; 18) {
12    return 'Good afternoon';
13  }
14 
15  return 'Good night';
16  }
17 
18  greet('John', getGreeting); // prints 'Good morning John' if it's morning
19  greet('Doug', getGreeting); // prints 'Good morning Doug' if it's morning
Link to this example: <a href="https://packt.link/xSYDF">https://packt.link/xSYDF</a></pre>
			<p>An example output would be as follows:</p>
			<pre>Good afternoon John
Good afternoon Doug</pre>
			<p>We could even go further and make the function return a random greeting, get it from a remote server, and a lot more, something which we couldn't do without passing in a function to the <code>greet</code> function.</p>
			<p>By making <code>greet</code> accept a function, we opened up endless possibilities, while keeping <code>greet</code> reusable.</p>
			<p>This is great, but passing in the <code>getGreeting</code> function in each call still feels cumbersome. We can change this by changing the <code>greet</code> function to both accept a function, and return a function. Let's take a look at how that appears:</p>
			<pre>Example06.ts
1 function greet(getGreeting: (name: string) =&gt; string) {
2   return function(name: string) {
3     const greeting = getGreeting(name);
4     console.log(`${greeting} ${name}`);
5   };
6 }
Link to this example: <a href="https://packt.link/8nHeD">https://packt.link/8nHeD</a></pre>
			<p>You'll notice that the logic stays the same as in the previous solution, but we split up the function to first take in the <code>getGreeting</code> function, and then return another function that takes in the <code>name</code> argument. This allows us to call <code>greet</code> like so:</p>
			<pre>const greetWithTime = greet(getGreeting);
greetWithTime('John'); // prints 'Good morning John' if it's morning
greetWithTime('Doug'); // prints 'Good morning Doug' if it's morning</pre>
			<p>Splitting greet in this way allows us even more flexibility â€“ since we now only need the <code>getGreeting</code> function once we can inline it, if it doesn't make sense to use itÂ elsewhere:</p>
			<pre>8  const greetWithTime = greet(function(name: string) {
9   const hours = new Date().getHours();
10   if (hours &lt; 12) {
11     return 'Good morning';
12   }
13 
14   if (hours === 12) {
15     return 'Good noon';
16   }
17 
18   if (hours &lt; 18) {
19     return 'Good afternoon';
20   }
21 
22   return 'Good night';
23 });</pre>
			<p>We could also use it to greet an array of people (names), using the <code>forEach</code> method of <code>Array</code>:</p>
			<pre>const names = ['John', 'Jane', 'Doug', 'Sally'];
names.forEach(greetWithTime);</pre>
			<p>The following is the output:</p>
			<pre>Good afternoon John
Good afternoon Jane
Good afternoon Doug
Good afternoon Sally</pre>
			<p>Higher-order functions, especially ones that accept other functions, are very widespread and useful, especially for manipulating datasets. We've even used them in previous chapters. For instance, the <code>map</code>, <code>filter</code>, <code>reduce</code>, and <code>forEach</code> methods of <code>Array</code> accept functions as arguments.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor271"/>Exercise 11.01: Orchestrating Data Filtering and Manipulation Using Higher-Order Functions</h2>
			<p>In this exercise, we get a list of students and want to get the average score of the students who graduated in 2010. This exercise will make use of higher-order functions to complete this task.</p>
			<p>The list of students is given in the following form:</p>
			<pre>interface Student {
Â Â id: number;
Â Â firstName: string;
Â Â lastName: string;
Â Â graduationYear: number;
Â Â score: number;
}
const students: Student[] = [
Â Â { id: 1, firstName: 'Carma', lastName: 'Atwel', graduationYear: 2010, score: 88 },
Â Â { id: 2, firstName: 'Shaun', lastName: 'Knoller', graduationYear: 2011, score: 84 },
Â Â // ...
];</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to the following starter file to get the code for student interface: <a href="https://packt.link/6Jmeu">https://packt.link/6Jmeu</a>.</p>
			<p>Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/fm3O4">https://packt.link/fm3O4</a>. Make sure to begin with the code for the student interface, as mentionedÂ previously.</p>
			<ol>
				<li value="1">Create a function, <code>getAverageScore</code>, that will accept a <code>Student[]</code> argument, and return a <code>number</code>:<pre>function getAverageScoreOf2010Students(students: Student[]): number {
Â Â // TODO: implement
}</pre></li>
				<li>First, we want to get <em class="italic">only those students who graduated in 2010</em>. We can use the array's <code>filter</code> method for that â€“ a higher-order function that accepts a predicate, a function that accepts an item from the array and returns <code>true</code> or <code>false</code>, depending on whether the item should be included in the result. <code>filter</code> returns a new array comprising some of the original array items, depending on the predicate. The length of the new array is smaller or equal to the length of the original array.</li>
				<li>Update your function with the following code:<pre>function getAverageScoreOf2010Students(students: Student[]): number {
Â Â const relevantStudents = students.filter(student =&gt; student.graduationYear === 2010);
}</pre><p>Next, we only care about the score of each student. We can use the array's <code>map</code> method for that â€“ a higher-order function that accepts a mapping function, a function that accepts an item from the array and returns a new, transformed value (of a type of your choosing) for each item. <code>map</code> returns a new array comprising the transformed items.</p></li>
				<li>Use the <code>map</code> method as shown:<pre>function getAverageScoreOf2010Students(students: Student[]): number {
Â Â const relevantStudents = students.filter(student =&gt; student.graduationYear === 2010);
Â Â const relevantStudentsScores = relevantStudents.map(student =&gt; student.score);
}</pre><p>Lastly, we want to get the average from the array of scores. We can use the array's <code>reduce</code> method for that â€“ a higher-order function that accepts a reducer function and an initial value.</p></li>
				<li>Update the function with the <code>reduce</code> method as shown:<pre>function getAverageScoreOf2010Students(students: Student[]): number {
Â Â const relevantStudents = students.filter(student =&gt; student.graduationYear === 2010);
Â Â const relevantStudentsScores = relevantStudents.map(student =&gt; student.score);
Â Â const relevantStudentsTotalScore = relevantStudentsScores.reduce((acc, item) =&gt; acc + item, 0);
Â Â return relevantStudentsTotalScore / relevantStudentsScores.length;
}</pre><p>The reducer function accepts the accumulator and the current value and returns an accumulator. <code>reduce</code> iterates over the items in the array, calling the reducer function in each iteration with the current item and the previously returned accumulator (or the initial value, for the first run). Finally, it returns the resulting accumulator, after iterating through the entire array. In this case, we want to average out the numbers in the array, so our reducer function will sum all the items, which we'll then divide by the number of female students. We can then call the function with any dataset and get the average score.</p></li>
				<li>Run the file using <code>npx</code> <code>ts-node</code>. You should see the following output on yourÂ console:<pre>The average score of students who graduated in 2010 is: 78.5</pre><p class="callout-heading">Note</p><p class="callout">In this exercise, we could also extract each function given to <code>filter</code>, <code>map</code>, and <code>reduce</code> into a named, non-inlined function, if it made sense to use it outside of this context; for example, if we wanted to test the filtering logic outside of <code>getAverageScoreOf2010Students</code>.</p></li>
			</ol>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor272"/>Callbacks</h1>
			<p>Callbacks are functions that we pass into other functions, which, in turn, will be invoked when they are needed. For example, in the client, if you want to listen to clicks on a specific DOM element, you attach an event handler via <code>addEventListener</code>. The function you pass in is then called when clicks on that element occur:</p>
			<pre>const btnElement = document.querySelector&lt;HTMLButtonElement&gt;('.my-button');
function handleButtonClick(event: MouseEvent) {
Â Â console.log('.my-button was clicked!');
}
btnElement.addEventListener('click', handleButtonClick);</pre>
			<p>In this example, <code>handleButtonClick</code> is a <em class="italic">callback function</em> given to <code>addEventListener</code>. It will be called whenever someone clicks the <code>.my-button</code>Â element.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also inline the <code>handleButtonClick</code> function, but you won't be able to call <code>removeEventListener</code> later, which is required in certain cases, to avoid memory leaks.</p>
			<p>On the server, callbacks are widely used. Even the most basic request handler in Node.js' <code>http</code> module requires a callback function to be passed:</p>
			<pre>import http from 'http';
function requestHandler(req: http.IncomingMessage, res: http.ServerResponse) {
Â Â res.write('Hello from request handler');
Â Â res.end();
}
http
Â Â .createServer(requestHandler)
Â Â .listen(3000);</pre>
			<p>In this example, <code>requestHandler</code> is a callback function given to <code>createServer</code>. It will be called whenever a request reaches the server, and this is where we define what we want to do with it, and how we want to respond.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor273"/>The Event Loop</h1>
			<p>Since JavaScript is single-threaded, callbacks are required to keep the main thread free â€“ the basic idea is that you give the engine a function to call when something happens, where you can handle it, and then return the control to whatever other code needs to run.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In more recent versions of browsers and Node.js, you can create threads via <em class="italic">Web Workers</em> on the browser or via <em class="italic">Worker Threads</em> in Node.js. However, these are usually saved for CPU-intensive tasks, and they are not as easy to use as callbacks or other alternatives are (for example, Promises â€“ explored in more detail in <em class="italic">Chapter 13</em>, <em class="italic">Async Await in TypeScript</em>).</p>
			<p>To illustrate this, let's look at a version of some JavaScript code where there are no callbacks, and we want to create a simple server that greets the users by their name:</p>
			<pre>// server.ts
function logWithTime(message: string) {
Â Â console.log(`[${new Date().toISOString()}]: ${message}`);
}
http
Â Â .createServer((req, res) =&gt; {
Â Â Â Â logWithTime(`START: ${req.url}`);
Â Â Â Â const name = req.url!.split('/')[1]!;
Â Â Â Â const greeting = fetchGreeting(name);
Â Â Â Â res.write(greeting);
Â Â Â Â res.end();
Â Â Â Â logWithTime(`END: ${req.url}`);
Â Â })
Â Â .listen(3000);</pre>
			<p><code>fetchGreeting</code> is faking a network operation, which is done synchronously to illustrate the issue:</p>
			<pre>function fetchGreeting(name: string) {
Â Â const now = Date.now();
Â Â const fakeRequestTime = 5000;
Â Â logWithTime(`START: fetchGreeting for user: ${name}`);
Â Â 
Â Â while (Date.now() &lt; now + fakeRequestTime);
Â Â 
Â Â logWithTime(`END: fetchGreeting for user: ${name}`);
Â Â return `Hello ${name}`;
}</pre>
			<p>In a more real-world example, <code>fetchGreening</code> could be replaced by a call to get the user's data from the database.</p>
			<p>If we run the server and try to request a few greetings simultaneously, you'll notice that they each wait for the previous request to complete before starting requesting the data for the current one. We can simulate a few concurrent requests by calling fetch multiple times, without waiting for the previous request to finish first:</p>
			<pre>// client.ts
fetch('http://localhost:3000/john');
fetch('http://localhost:3000/jane');</pre>
			<p>The output you'll see on the server's console is this:</p>
			<div><div><img src="img/B14508_11_02.jpg" alt="Figure 11.2: Output of running the sync server while making multiple requestsÂ simultaneously"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2: Output of running the sync server while making multiple requestsÂ simultaneously</p>
			<p>As you can see, Jane had to wait for John's request to finish (5 seconds in this case) before the server even started handling her request. The total time to greet both users was 10 seconds. Can you imagine what would happen in a real server, serving hundreds or more requests at the same time?</p>
			<p>Let's see how callbacks solve this.</p>
			<p>We first change <code>fetchGreeting</code> to use callback APIs â€“ <code>setTimeout</code> in this case serves the same purpose as the <code>while</code> loop from before, while not holding up the main thread:</p>
			<pre>function fetchGreeting(name: string, cb: (greeting: string) =&gt; void) {
Â Â const fakeRequestTime = 5000;
Â Â logWithTime(`START: fetchGreeting for user: ${name}`);
Â Â setTimeout(() =&gt; {
Â Â Â Â logWithTime(`fetched greeting for user: ${name}`);
Â Â Â Â cb(`Hello ${name}`);
Â Â }, fakeRequestTime);
Â Â logWithTime(`END: fetchGreeting for user: ${name}`);
}</pre>
			<p>Then, change the request handler to use the new implementation:</p>
			<pre>// server.ts
http
Â Â .createServer((req, res) =&gt; {
Â Â Â Â logWithTime(`START: ${req.url}`);
Â Â Â Â const name = req.url!.split('/')[1]!;
Â Â Â Â fetchGreeting(name, greeting =&gt; {
Â Â Â Â Â Â logWithTime(`START: callback for ${name}`);
Â Â Â Â Â Â res.write(greeting);
Â Â Â Â Â Â res.end();
Â Â Â Â Â Â logWithTime(`END: callback for ${name}`);
Â Â Â Â });
Â Â Â Â logWithTime(`END: ${req.url}`);
Â Â })
Â Â .listen(3000);</pre>
			<p>And run the client code again. This results in the following output:</p>
			<div><div><img src="img/B14508_11_03.jpg" alt="Figure 11.3: Output of running the async server while making &#13;&#10;multiple requests simultaneously&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3: Output of running the async server while making multiple requests simultaneously</p>
			<p>As you can see, the server started handing John's request first, since that's the first one to arrive, but then immediately switched to handling Jane's request while waiting for John's greeting to be ready. When John's greeting was ready 5 seconds later, the server sent the greeting back, and then waited for Jane's greeting to be ready a few milliseconds later and sent that to her.</p>
			<p>To conclude, the <em class="italic">same flow</em> as before now took 5 seconds to respond to <em class="italic">both users</em> instead of the 10 seconds from before. In addition, most of that time was spent idle â€“ waiting to receive more requests to handle. This is instead of the flow prior to the callbacks, where the server was stuck and wasn't able to answer any requests for the majority of the time.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor274"/>Callbacks in Node.js</h2>
			<p>Since callbacks are very common in Node.js, and especially since the whole ecosystem relies on using external packages for a lot of things, there is a standard callback API structure for any async function:</p>
			<ol>
				<li value="1">The callback function will be the last parameter.</li>
				<li>The callback function will take <code>err</code> as the first parameter, which may be <code>null</code> (or <code>undefined</code>), and the response data as the second parameter.</li>
			</ol>
			<p>Further parameters are also allowed, but these two are mandatory. This results in a predictable structure for handling callbacks, illustrated by the following example for reading a file from the filesystem:</p>
			<pre>import fs from "fs";
fs.readFile("some-file", (err, file) =&gt; {
Â Â if (err) {
Â Â Â Â // handle error...
Â Â Â Â return;
Â Â }
Â Â // handle file...
});</pre>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor275"/>Callback Hell</h2>
			<p>Unfortunately, code that uses callbacks can make it very hard to follow, understand, and reason about very quickly. Every async operation requires another callback level, and if you want to run multiple async operations consecutively, you have to nest these callbacks.</p>
			<p>For example, let's say we want to build a social network, which has an endpoint where you can ask for a given user's friends, based on their username. Getting this list of friends requires multiple operations, each requiring an async operation that depends on the result of the previous one:</p>
			<ol>
				<li value="1">Get the requested user's ID from the database (given their username).</li>
				<li>Get the privacy settings of the user to make sure they allow others to view their list of friends.</li>
				<li>Get the user's friends (from an external service or otherwise).</li>
			</ol>
			<p>Here is some example code for how this could be done, using callbacks. We're using <code>express</code> here to set up a basic server, listening on port <code>3000</code>. The server can accept a <code>GET</code> request to <code>/:username/friends</code> (where <code>:username</code> will be replaced with the actual requested username). After accepting the request, we get the ID of the user from the database, then get the user privacy preferences using the user's ID (this can be in an external service, or otherwise) to check that they allow others to view their friends' list, then get the user's friends, and finally return the result:</p>
			<pre>import express from 'express';
import request from 'request';
import sqlite from 'sqlite3';
const db = new sqlite.Database('db.sql', err =&gt; {
Â Â if (err) {
Â Â Â Â console.error('Error opening database:', err.message);
Â Â }
});
const app = express();
app.get('/:username/friends', (req, res) =&gt; {
Â Â const username = req.params.username;
Â Â db.get(
Â Â Â Â `SELECT id
Â Â Â Â FROM users
Â Â Â Â WHERE username = username`,
Â Â Â Â [username],
Â Â Â Â (err, row) =&gt; {
Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â return res.status(500).end();
Â Â Â Â Â Â }
Â Â Â Â Â Â getUserPrivacyPreferences(row.id, (err, privacyPreferences) =&gt; {
Â Â Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â Â Â return res.status(500).end();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â if (!privacyPreferences.canOthersViewFriends) {
Â Â Â Â Â Â Â Â Â Â return res.status(403).end();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â getFriends(row.id, (err, friends) =&gt; {
Â Â Â Â Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â Â Â Â Â return res.status(500).end();
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â Â Â Â Â .status(200)
Â Â Â Â Â Â Â Â Â Â Â Â .send({ friends })
Â Â Â Â Â Â Â Â Â Â Â Â .end();
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â });
Â Â Â Â }
Â Â );
});
app.get('*', (req, res) =&gt; {
Â Â res.sendFile('index.html');
});
app.listen(3000);</pre>
			<p>Also note that in each callback, we got an <code>err</code> parameter and had to check whether it was true, and bail early if it wasn't accompanied by an appropriate error code.</p>
			<p>The preceding example is not unrealistic, and a lot of cases require more levels than this to get all the data they need in order to perform a task. And so, this "callback hell" becomes more apparent, and harder to understand and reason about very quickly, since, as discussed previously, a lot of APIs in Node.js work with callbacks, due to the nature of how JavaScript works, as explained in the event loop section.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor276"/>Avoiding Callback Hell</h2>
			<p>There are quite a few solutions to the callback hell problem. We'll take a look at the most prominent ones, demonstrating how the preceding code snippet would look in each variation:</p>
			<ol>
				<li value="1">Extract the callback functions to function declarations at the file level and then use them â€“ this means you only have one level of functions with business logic, and the callback hell functions become a lot shorter.</li>
				<li>Use a higher-order function to chain the callbacks, meaning only a single level of callbacks in practice.</li>
				<li>Use promises, when can be chained together, as explained in <em class="italic">Chapter 13</em>, <em class="italic">Async Await in TypeScript</em>.</li>
				<li>Use <code>async</code>/<code>await</code> (which is syntactic sugar on top of <code>Promise</code>), as explained in <em class="italic">Chapter 13</em>, <em class="italic">Async Await in TypeScript</em>.</li>
			</ol>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor277"/>Splitting the Callback Handlers into Function Declarations at the File Level</h2>
			<p>The simplest way to simplify callback hell is to extract some of the callbacks into their own top-level functions and let each one call the next in the logical chain.</p>
			<p>Our main endpoint handler will call the <code>get</code> of <code>db</code> as before, but then just call <code>handleDatabaseResponse</code> with the response, leaving it to handle any errors, and so on. This is why we also pass in the response object to the function, in case it needs to return the data, or an error, to the user:</p>
			<pre>app.get('/:username/friends', (req, res) =&gt; {
Â Â const username = req.params.username;
Â Â db.get(
Â Â Â Â `SELECT id
Â Â Â Â FROM users
Â Â Â Â WHERE username = username`,
Â Â Â Â [username],
Â Â Â Â (err, row) =&gt; {
Â Â Â Â Â Â handleDatabaseResponse(res, err, row);
Â Â Â Â }
Â Â );
});</pre>
			<p>The <code>handleDatabaseResponse</code> function will perform the same logic as before, but now pass the handling of the <code>getUserPrivacyPreferences</code> response to <code>handleGetUserPrivacyPreferences</code>:</p>
			<pre>function handleDatabaseResponse(res: express.Response, err: any, row: { id: string }) {
Â Â if (err) {
Â Â Â Â return res.status(500).end();
Â Â }
Â Â getUserPrivacyPreferences(row.id, (err, privacyPreferences) =&gt; {
Â Â Â Â handleGetUserPrivacyPreferences(res, row.id, err, privacyPreferences);
Â Â });
}</pre>
			<p><code>handleGetUserPrivacyPreferences</code> will again perform the same logic as before, and pass the handling of the <code>getFriends</code> response to <code>handleGetFriends</code>:</p>
			<pre>function handleGetUserPrivacyPreferences(
Â Â res: express.Response,
Â Â userId: string,
Â Â err: any,
Â Â privacyPreferences: PrivacyPreferences
) {
Â Â if (err) {
Â Â Â Â return res.status(500).end();
Â Â }
Â Â if (!privacyPreferences.canOthersViewFriends) {
Â Â Â Â return res.status(403).end();
Â Â }
Â Â getFriends(userId, (err, friends) =&gt; handleGetFriends(res, err, friends));
}</pre>
			<p>And finally, <code>handleGetFriends</code> will return the data to the user via the response:</p>
			<pre>function handleGetFriends(res: express.Response, err: any, friends: any[]) {
Â Â if (err) {
Â Â Â Â return res.status(500).end();
Â Â }
Â Â return res
Â Â Â Â .status(200)
Â Â Â Â .send({ friends })
Â Â Â Â .end();
}</pre>
			<p>Now we only have a single nesting level, and no more callback hell.</p>
			<p>The main trade-off here is that while the code is less nested, it is split among multiple functions and may be harder to follow, especially when debugging or skimming through it to understand what's going on at a high level.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor278"/>Chaining Callbacks</h2>
			<p>There are libraries to help us eliminate the callback hell problem by chaining the callbacks to one another â€“ artificially removing nesting levels from our code. One of the popular ones is async.js (<a href="https://github.com/caolan/async">https://github.com/caolan/async</a>), which exposes a few functions to compose callback functions, such as <code>parallel</code>, <code>series</code>, and <code>waterfall</code>. In our preceding code example, we could use the <code>waterfall</code> function to chain the callbacks to happen one after the other:</p>
			<ol>
				<li value="1">We implement an array of functions, and a final handler. <code>async</code> will then call our functions, one by one, when we call the callback in each function, as demonstrated here:<pre>...
import async from 'async';
...
type CallbackFn = &lt;T extends any[]&gt;(err: any, ...data: T) =&gt; void;
class ServerError extends Error {
Â Â constructor(public readonly statusCode: number, message?: string) {
Â Â Â Â super(message);
Â Â }
}
app.get('/:username/friends', (req, res) =&gt; {
Â Â const username = req.params.username;</pre></li>
				<li>Get the user ID from the database:<pre>Â Â async.waterfall(
Â Â Â Â [
Â Â Â Â Â Â // 1. Get the user id from the database
Â Â Â Â Â Â (cb: CallbackFn) =&gt; {
Â Â Â Â Â Â Â Â db.get(
Â Â Â Â Â Â Â Â Â Â `SELECT id
Â Â Â Â Â Â Â Â Â Â Â Â FROM users
Â Â Â Â Â Â Â Â Â Â Â Â WHERE username = username`,
Â Â Â Â Â Â Â Â Â Â [username],
Â Â Â Â Â Â Â Â Â Â (err, row) =&gt; {
Â Â Â Â Â Â Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â return cb(err);
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â return cb(null, row);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â );
Â Â Â Â Â Â },</pre></li>
				<li>Get the user's privacy settings:<pre>Â Â Â Â Â Â (row: { id: string }, cb: CallbackFn) =&gt; {
Â Â Â Â Â Â Â Â getUserPrivacyPreferences(row.id, (err, privacyPreferences) =&gt; {
Â Â Â Â Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â Â Â Â Â return cb(err);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â return cb(null, privacyPreferences, row.id);
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â },</pre></li>
				<li>Check that the user privacy settings allow others to view their friends:<pre>Â Â Â Â Â Â (privacyPreferences: PrivacyPreferences, userId: string, cb: CallbackFn) =&gt; {
Â Â Â Â Â Â Â Â if (!privacyPreferences.canOthersViewFriends) {
Â Â Â Â Â Â Â Â Â Â return cb(new ServerError(403, "User doesn't allow others to view their friends"));
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return cb(null, userId);
Â Â Â Â Â Â },</pre></li>
				<li>Get the user's friends:<pre>Â Â Â Â Â Â (userId: string, cb: CallbackFn) =&gt; {
Â Â Â Â Â Â Â Â getFriends(userId, (err, friends) =&gt; {
Â Â Â Â Â Â Â Â Â Â if (err) {
Â Â Â Â Â Â Â Â Â Â Â Â return cb(err);
Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â return cb(null, friends);
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â },
Â Â Â Â ],</pre></li>
				<li>Finally, handle any errors that occurred, or the data that was returned from the last callback:<pre>Â Â Â Â (error, friends) =&gt; {
Â Â Â Â Â Â if (error) {
Â Â Â Â Â Â Â Â if (error instanceof ServerError) {
Â Â Â Â Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â Â Â Â Â .status(error.statusCode)
Â Â Â Â Â Â Â Â Â Â Â Â .send({ message: error.message })
Â Â Â Â Â Â Â Â Â Â Â Â .end();
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return res.status(500).end();
Â Â Â Â Â Â }
Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â .status(200)
Â Â Â Â Â Â Â Â .send({ friends })
Â Â Â Â Â Â Â Â .end();
Â Â Â Â }
Â Â );
});</pre></li>
			</ol>
			<p>Now the code is much easier to follow â€“ we only have one error handler that's tied down to the response object, and we follow the code from top to bottom, with not much nesting in between, at least not due to callbacks.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor279"/>Promises</h2>
			<p>Promises allow you to essentially flatten the callback tree by doing something similar to async.js' waterfall, but it's more seamless, built into the language itself, and also allows promises to be "squashed." </p>
			<p>We won't go into too much detail here â€“ refer to <em class="italic"> Chapter 13</em>, <em class="italic">Async Await in TypeScript</em> for an in-depth explanation of promises, but the preceding code, using promises, would look like this:</p>
			<pre>...
app.get('/:username/friends', (req, res) =&gt; {
Â Â const username = req.params.username;
Â Â promisify&lt;string, string[], { id: string }&gt;(db.get)(
Â Â Â Â `SELECT id
Â Â FROM users
Â Â WHERE username = username`,
Â Â Â Â [username]
Â Â )
Â Â Â Â .then(row =&gt; {
Â Â Â Â Â Â return getUserPrivacyPreferences(row.id).then(privacyPreferences =&gt; {
Â Â Â Â Â Â Â Â if (!privacyPreferences.canOthersViewFriends) {
Â Â Â Â Â Â Â Â Â Â throw new ServerError(403, "User doesn't allow others to view their friends");
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â return row.id;
Â Â Â Â Â Â });
Â Â Â Â })
Â Â Â Â .then(userId =&gt; {
Â Â Â Â Â Â return getFriends(userId);
Â Â Â Â })
Â Â Â Â .then(friends =&gt; {
Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â .status(200)
Â Â Â Â Â Â Â Â .send({ friends })
Â Â Â Â Â Â Â Â .end();
Â Â Â Â })
Â Â Â Â .catch(error =&gt; {
Â Â Â Â Â Â if (error instanceof ServerError) {
Â Â Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â Â Â .status(error.statusCode)
Â Â Â Â Â Â Â Â Â Â .send({ message: error.message })
Â Â Â Â Â Â Â Â Â Â .end();
Â Â Â Â Â Â }
Â Â Â Â Â Â return res.status(500).end();
Â Â Â Â });
});</pre>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor280"/>async/await</h2>
			<p>Async/await builds upon promises and provides further syntactic sugar on top of them in order to make promises look and read like synchronous code, even though, behind the scenes, it's still async. You can get a more in-depth explanation of them in <em class="italic">Chapter 13</em>, <em class="italic">Async Await in TypeScript</em>, but the preceding code that used promises is equivalent to the following code that uses async/await:</p>
			<pre>...
app.get('/:username/friends', async (req, res) =&gt; {
Â Â const username = req.params.username;
Â Â try {
Â Â Â Â const row = await promisify&lt;string, string[], { id: string }&gt;(db.get)(
Â Â Â Â Â Â `SELECT id
Â Â Â Â Â Â  FROM users
Â Â Â Â Â Â  WHERE username = username`,
Â Â Â Â Â Â [username]
Â Â Â Â );
Â Â Â Â const privacyPreferences = await getUserPrivacyPreferences(row.id);
Â Â Â Â if (!privacyPreferences.canOthersViewFriends) {
Â Â Â Â Â Â throw new ServerError(403, "User doesn't allow others to view their friends");
Â Â Â Â }
Â Â Â Â const friends = await getFriends(row.id);
Â Â Â Â return res
Â Â Â Â Â Â .status(200)
Â Â Â Â Â Â .send({ friends })
Â Â Â Â Â Â .end();
Â Â } catch (error) {
Â Â Â Â if (error instanceof ServerError) {
Â Â Â Â Â Â return res
Â Â Â Â Â Â Â Â .status(error.statusCode)
Â Â Â Â Â Â Â Â .send({ message: error.message })
Â Â Â Â Â Â Â Â .end();
Â Â Â Â }
Â Â Â Â return res.status(500).end();
Â Â }
});</pre>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor281"/>Activity 11.01: Higher-Order Pipe Function</h2>
			<p>In this activity, you are tasked with implementing a <code>pipe</code> function â€“ a higher-order function that accepts other functions, as well as a value, and composes them â€“ returning a function that accepts the arguments of the first function in the composition, runs it through the functions â€“ feeding each function with the output of the previous one (and the first function with the initial value), and returns the result of the last function.</p>
			<p>Such functions exist in utility libraries such as Ramda (<a href="https://ramdajs.com/docs/#pipe">https://ramdajs.com/docs/#pipe</a>). and with variations in other libraries such as Lodash (<a href="https://lodash.com/docs#chain">https://lodash.com/docs#chain</a>) and RxJS (<a href="https://rxjs.dev/api/index/function/pipe">https://rxjs.dev/api/index/function/pipe</a>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find both the activity starter file and solution at <a href="https://packt.link/CQLfx">https://packt.link/CQLfx</a>.</p>
			<p>Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Create a <code>pipe</code> function that accepts functions as arguments and composes them, from left to right.</li>
				<li>Make sure that the return type of the returned functional is correct â€“ it should accept arguments of type <code>T</code>, <code>T</code> being the arguments of the first function in the chain, and return type <code>R</code>, <code>R</code> being the return type of the last function in the chain.<p>Note that due to a current TypeScript limitation, you have to manually type this for the number of arguments you want to support.</p></li>
				<li>Your <code>pipe</code> function should be callable in multiple ways â€“ supporting composition of up to five functions, and will only support composing functions with a single argument, for simplicity. <p>Here is the structure of the <code>pipe</code> function that you can use:</p><pre>const func = pipe(
Â Â (x: string) =&gt; x.toUpperCase(),
Â Â x =&gt; [x, x].join(','),
Â Â x =&gt; x.length,
Â Â x =&gt; x.toString(),
Â Â x =&gt; Number(x),
);
console.log('result is:', func('hello'));</pre></li>
			</ol>
			<p>After solving the preceding steps, the expected output for this code is presented here:</p>
			<pre>result is: 11 </pre>
			<p>Bonus: As a challenge, try expanding the <code>pipe</code> function to support the composition of more functions, or more arguments.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor438">this link</a>.</p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor282"/>Summary</h1>
			<p>In this chapter, we introduced two key concepts in TypeScript â€“ higher-order functions and callbacks. The chapter first defined HOCs and illustrated this concept with a number of examples. You also orchestrated data filtering and manipulation using higher-order functions. Finally, you also tested your skills by creating a higher-order pipe function.</p>
			<p>With regard to callbacks, the chapter first introduced the definition of callbacks with a few generic examples, along with examples relating to callbacks in Node.js. You also saw how you can easily fall into callback hell and how you can avoid it. Although there are several additional steps that you need to take in order to master higher-order functions and callback, this chapter got you started on the journey. The next chapter deals with another important concept in TypeScript â€“ promises.</p>
		</div>
	</body></html>