- en: Chapter 7. Practical – an E-mail Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our past two applications have been fairly straightforward examples, but ones
    that are useful to illustrate how to create a strong foundation for a future,
    more extensive product. In this chapter, we'll build a fully featured webmail
    client that will provide a tailored experience for users of both desktop browsers
    and smaller devices such as tablets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everyone knows the traditional e-mail interface, but we''ll try and at the
    same time show how Ext JS technologies can be used to make short work of building
    such an application. Here''s the breakdown of what we''ll be doing in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing essential requirements for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming up with an ideal user interface for each form factor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the issues that may arise on a smaller screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the view and controller structure to present and orchestrate it all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating the design of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way we'll reinforce our knowledge of routing and view models, as well
    as undertaking constant re-evaluation of our work to ensure the quality of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also take a little more time to finish the design of this application,
    dipping our toe in the water of Ext JS theming. While we won't be building a full
    replacement theme, we'll touch on some of the places where the theming system
    should be used in order to improve the maintainability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Form factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application will adapt to a variety of devices, from desktop browsers to
    tablets and mobile phones. The size of these devices is often called the "form
    factor" and Ext JS provides several mechanisms that allow you to customize the
    user experience depending on the form factor of the device being used.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on `responsiveConfig`, an option available when
    you include the `Ext.mixin.Responsive` class in your views. In a standard desktop
    application, we might have two components side by side in the viewport, since
    desktop screen sizes are generally wider than they are tall. On a mobile phone,
    users will often be in portrait orientation, so this is no longer true; the screen
    is taller than it is wide. In this case, we can use `responsiveConfig` to override
    the original side-by-side configuration and use different layouts, items, and
    component widths—in fact any aspect of the original viewport configuration—and
    change the appearance and behavior of the application for a taller screen.
  prefs: []
  type: TYPE_NORMAL
- en: This one feature provides us with an exceptionally powerful means to deliver
    an experience that is tailored to a particular form factor. In this chapter, we'll
    see some practical examples of implementing `responsiveConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: Application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What features do we expect from an e-mail client? At a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Login**: This helps to gain access to your own account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inbox**: This is a list of our e-mails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sent**: This is a list of e-mails we''ve sent in the past'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Archive**: This is a list of e-mails we''ve disposed of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composer**: This helps to write e-mails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: This helps to find archived e-mails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final version of the app looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The thread view on the left and messages from the selected thread on the right
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need to do to get to this point? Let''s sketch out a design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The login page is pretty standard. We''ll want to validate user input, check
    the e-mail address, and ensure the password isn''t blank, but there really isn''t
    anything out of the ordinary here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here's the main interface for the application. We'll be implementing threaded
    e-mail; we have a list of threads on the left with an excerpt of the most recent
    message showing as the description of the thread. The date of the last message
    is shown on the left-hand side of each thread. On the right-hand side, we show
    the selected message thread, most recent message last. Each message has its received
    date on its left. The thread has a **Reply** button and a dropdown to allow the
    thread to be tagged, more on this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the screen we have a logo (from left to right), an icon for the
    **Contacts** section, a **search** bar, a button to create a new e-mail, and finally,
    a dropdown to filter threads by tag.
  prefs: []
  type: TYPE_NORMAL
- en: The **search** bar will cause matching message threads to appear below (in the
    same style as the **Inbox** view).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having separate screens for archived e-mail, sent e-mail, and so
    on, we make the assumption that **Inbox** threads are just untagged threads. When
    they are tagged—either automatically as "sent" or by some other arbitrary tag
    such as "home" or "work"—then they are removed from the **Inbox** view, as shown
    in the following screenshot. This concept is found in many e-mail clients, for
    example, Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application design](img/5308OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When composing new e-mails, it takes place in the right-hand position. As there
    is no selected thread at this time, the space is clear to be occupied by a panel
    that contains a combo box to choose a recipient for the e-mail, a basic HTML editor
    for the e-mail itself, and a **Send** button.
  prefs: []
  type: TYPE_NORMAL
- en: Replying to an e-mail works in a similar way; the composer panel appears under
    the messages and allows the user to write a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple more items to note are that the user will start off with a number
    of default tags:'
  prefs: []
  type: TYPE_NORMAL
- en: Draft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When selecting a tag for a thread, the user can easily add another by typing
    in the combo box.
  prefs: []
  type: TYPE_NORMAL
- en: I require to admire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As architects of a product, we always need to consider how to make our product
    exemplary, how to make sure the user experience is a good one, how to exceed the
    expectations of our stakeholders. The starting step is to work out in exacting
    detail the facets on the product we'd like to build.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do the requirements we've spelled out translate into the underlying tech?
  prefs: []
  type: TYPE_NORMAL
- en: We want to display a login form with a "remember me" feature, so we need some
    kind of persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to display thread data in a custom format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to display full message threads in a custom format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want a basic HTML editor for message bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need an autocomplete box for recipients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to display search results in the same format as message threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need an autocomplete box for tags to be used in various locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s translate each of these into Ext JS features:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use cookies or local storage to hold login information between systems
    (either using native browser methods or an Ext JS-powered session class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use an Ext JS DataView to create a templated view of thread data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use an Ext JS DataView to create a templated view of message data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS provides an HTML editor widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ext JS combo box can be powered by a store that retrieves remote contact
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reuse the message thread DataView with a different store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `editable:true` option of the Ext JS combo box in cases where
    we need to add new tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a couple of gray areas there that we'll review later, but it does
    look like Ext JS can provide all of the features we're going to need to build
    this application.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to the situation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s another requirement in this project: a responsive design that works
    on devices with smaller screens. Well, it turns out that the UI we''ve come up
    with already looks pretty good on a tablet, with one caveat. You have to be holding
    the device in landscape mode. This is a problem that you don''t really have to
    consider on the desktop, but it becomes critical with mobile devices.'
  prefs: []
  type: TYPE_NORMAL
- en: From an architectural standpoint, we need to understand how the layout of the
    application will differ between screen sizes in order to decide how to assemble
    the application. In the designs so far, there are two panes side by side; there
    simply won't be enough screen space to allow for this on a portrait phone or tablet.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we'll hide or show the "left" and "right" panes depending on user actions.
    If they click on a thread of messages or the **New Message** button, the threads
    will be hidden and the correct right-hand pane will appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other issue with a portrait screen is the application header; there
    are too many components in there to fit in the width of a smaller screen. Instead,
    we''ll show a menu button when in portrait mode that hides some controls when
    toggled and shows others. This gives us a second level of menu that''s only shown
    when the user needs it. Here''s a mockup of some of these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Responding to the situation](img/5308OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When clicking on one of the messages in the left screenshot, the list is replaced
    by the message thread seen in the right-hand side screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: In an HTML-based responsive website, CSS media queries can be used to style
    the page in a fashion appropriate for any screen and orientation. While we can
    obviously still make use of CSS alongside Ext JS to do customization, our requirements
    are more complex; can Ext JS provide any extra features to assist?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `responsive` plugin allows developers to tailor any component configuration
    based on a set of rules relating to the current device screen. Here are a few
    example scenarios in a theoretical responsive application:'
  prefs: []
  type: TYPE_NORMAL
- en: If the screen is less than 500 pixels wide, collapse the sidebar panel by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the screen is in landscape mode, show a new column of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the device is an iOS tablet, apply a different CSS class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the webmail application, we''ve already mentioned showing and hiding header
    items. This can be done something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There's a built-in rule called "portrait" that allows you to specify a configuration
    object that will only be applied when the rule is in effect. As architects, we
    must carefully consider the best way of making use of this feature without ending
    up with lots of messy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the desktop version of the application we have two panes side by side. For
    this, we can use the `hbox` layout. However, for the portrait orientation, we'd
    like to be able to switch between one pane and another. This seems like a good
    use of the card layout. We'll also have to consider how to trigger the switch
    of the panes and have this code run in portrait orientation only.
  prefs: []
  type: TYPE_NORMAL
- en: The important takeaway is that the responsive plugin—in a similar fashion to
    view models—allows you to avoid writing lots of glue code that responds to the
    state of the application environment, and instead lets us declare our intentions
    at configuration time. After this, Ext JS takes care of most of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: This is another example in which analyzing the requirements with a strong understanding
    of the available technology can result in a simpler architecture and a clearer
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: Input required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we've gone into detail about the API we're going to be
    communicating with. There's no denying that it's one of the key parts of any application
    design; in fact many projects can live or die based on the quality of the API
    they're integrating with, but we've discussed this in the past two chapters and
    we've still got a lot to cover. From here on, we're generally going to assume
    that we're working with a well-designed RESTful API that works well with Ext JS.
    This'll give us some room to concentrate on some new ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's not to say you can skip over the API when designing your application.
    It is very rare you'll be working with a perfect backend, so keep analyzing whether
    the server is providing the endpoints you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll move on to looking at the rest of the application, but in a different
    way to previous chapters; once the data''s been pulled down from the server, we''ll
    try and consider how it''s going to move through our app. We''ll also look at
    two other facets of the design in more detail: routing and events. Why this change
    in direction compared to previous chapters?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As our applications become more complicated, we have to continually think about
    how to keep that complexity under control. These three features: view models,
    events, and routing, all allow a "fire and forget" attitude, wire up some basic
    configuration, trigger an action at the source, and this bit of code is done.
    Somewhere else in the application will subscribe to this action—be it a view model
    binding, a routing change or the firing of an event—and consume it accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll first identify our views and controllers as we have in the past and look
    at how this will inform the routing, view models and events that will power the
    functionality of our application.
  prefs: []
  type: TYPE_NORMAL
- en: A view to a thrill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s break down the major views that will make up the main screen of the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A view to a thrill](img/5308OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '1: header view, 2: thread view, 3: message view, and 4: composer view; main
    view encompasses views 1 - 4'
  prefs: []
  type: TYPE_NORMAL
- en: The login view is the simplest; a self-contained view, view controller, and
    a view model to bind with the values of the login form. It's not shown in the
    preceding mockup because it's the only one on the screen at the time, almost standalone.
  prefs: []
  type: TYPE_NORMAL
- en: There's a caveat to this. For the first time, we'll be using an over-arching
    controller to deal with the interactions between views. In the previous chapter,
    this was left to the "main" view controller, since the "main" view was the container
    for every part of our application. Here, the login view and the rest of the application
    are effectively independent from each other and so it makes sense to have a "third
    party" helping them to work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this top-level controller our "root" controller. It''s not a view
    controller, but a completely self-contained class that is responsible for showing
    the login view and reacting to a successful login. To formalize this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The login view controller is responsible for processing a login attempt and
    after doing so, it will fire off the appropriate actions. Along with its view
    and view model, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the `onLoginClick` method is successful, we'll move on to the main
    screen of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Mainly harmless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in previous chapters, the main view is the viewport that contains the other
    views in the application, such as the application header and the list of threads.
    According to our design, the view should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things to note here, the primary views that make up our application
    are mentioned here: header, threads, messages and, composer. We''re also doing
    a bit of forward thinking regarding our design, in that the composer and messages
    views are enclosed in a separate container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to more easily work with the Ext JS layout system, having
    the threads view and this anonymous container in an `hbox` arrangement. The view
    model looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s just convenient for a few pieces of state that need to be shared between
    the views contained in the main view. The view controller looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first method (`onLogout`) will handle clicks on a logout button. The next
    four methods on the main view controller will be triggered by routing, and will
    be responsible for setting changes in the state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the main view and its associated classes don't really have any
    functionality of their own; they're responsible for orchestrating all of the other
    application parts contained within.
  prefs: []
  type: TYPE_NORMAL
- en: Full steam ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first child view of the main viewport is the header view, containing a
    number of components that are available anywhere in the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s actually a surprising amount happening here. We also have to bear
    in mind that this is the target for one of our portrait orientation pieces of
    functionality, so there will be some usage of the responsive plugin in our implementation,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods are event listeners that will in turn trigger further functionality.
    You might wonder why we don''t have handlers to toggle the menu open and closed
    or to choose an item from the combo box. Think about data binding. If we bind
    the state of the menu button and the combo box to a view model, other components
    can bind to the values in the view model and will receive updates without us having
    to write any glue code. To this end, the header view model will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Nothing more than a store to populate the tag filter combo box. We'll talk about
    this use of data binding further when we come to implement the header.
  prefs: []
  type: TYPE_NORMAL
- en: Threading our way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A thread is just a fancy way of saying "a collection of e-mail messages". We''re
    going to use `Ext.DataView` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're going to support HTML e-mails in this application, but to prevent the
    thread view from looking messy, we'll strip out this HTML before presenting it
    to the user. Other than this, it's a normal implementation of DataView.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The view model contains the thread store that powers the view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's only a single method here, one that is triggered by the `itemclick`
    event on the thread DataView. It'll be responsible for redirecting the user to
    a list of messages in this thread.
  prefs: []
  type: TYPE_NORMAL
- en: Send me a message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message view is responsible for showing the messages that make up a thread.
    As such, it's mainly based on DataView. It's a little more complicated than this
    though because DataView doesn't inherit from `Ext.Panel`; it can't have its own
    child items or docked toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we need to have some tools at the bottom of the message list
    in order to change the thread tag and send a reply. Therefore, we wrap the DataView
    in a panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the view model, we need two stores: one for the messages in the thread,
    and one for the tags that are available to choose from.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The view controller has a couple of event handlers to manage the user''s interactions
    with the message view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's now only one missing piece to this application—how do we write new messages?
  prefs: []
  type: TYPE_NORMAL
- en: Stay composed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The composer view is responsible for writing new messages and writing replies.
    It needs several UI components to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Recipients and subject won''t be used if the composer is replying to an existing
    thread. It will only be used when creating a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a store of contacts to power the recipients'' field, and an object
    to store the form values as the user enters them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The view controller will be responsible for saving the message to the server,
    which in turn would send it to the designated recipients.
  prefs: []
  type: TYPE_NORMAL
- en: We don't exactly have an address book in this application; instead, any previously
    used e-mail addresses are just saved and are available to pick in future messages.
  prefs: []
  type: TYPE_NORMAL
- en: Design overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We skipped over a lot of the data layer design this time around because it was
    very "boilerplate" in nature and we'd discussed such things in previous chapters.
    Why go through the class design process for the views and their associated view
    controllers and view models then? We've done this in previous chapters as well.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, every application is different. Breaking it down in this way helps
    us flesh out the code we're going to write without actually writing any code.
    This is important, because we'll avoid thinking too hard about the details of
    the implementation and have a better understanding of the shape of the larger
    pieces in the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to revisit routes, events, and data flow and see how these
    large pieces will work together.
  prefs: []
  type: TYPE_NORMAL
- en: Application state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First up is routing. We said in [Chapter 6](ch06.html "Chapter 6. Practical
    – Monitoring Dashboard"), *Practical – Monitoring Dashboard*, that the route is
    a way of keeping part of the application's state in the URL. Another way of looking
    at this is that as the application changes through its various states, you are
    walking through the screens that the user would see as they interact with the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: By working out the various high-level states of our application, we can better
    visualize the user flow and establish the routes that we can employ in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Home screen/initial load
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is displayed straight after login and represents the default state of
    the main screen of the application before the user interacts with it. It looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The views will have the following state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we're in portrait view, we'll use a card layout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Card" is one of the build-Ext JS layouts, which allows you to easily switch
    out one component for another. It''s also the basis for the `Ext.TabPanel` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the home state of the application needs to have the thread
    view as the active item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the initial state on a normal device, the user has neither selected a message
    nor has chosen to compose a new message. Therefore, there's nothing showing in
    the right-hand pane.
  prefs: []
  type: TYPE_NORMAL
- en: New thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The route that handles requests for a new thread is displayed in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user presses the new message button, they are shown the composer view.
    The overall state changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember that changing route doesn't mean that the state reverts to the initial
    state and then changes; we need to reset all things that could potentially have
    been shown by another route. In this case, if the user previously selected a thread,
    then the messages view would be showing, and we need to hide it when creating
    a new message.
  prefs: []
  type: TYPE_NORMAL
- en: Show thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The route to handle requests for a specific message thread is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s triggered when the user selects a thread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Pretty much the opposite of a new message in which the messages are shown and
    the composer is hidden. The thread that was selected needs to be made available
    to the components that require it, in this case, the message view, so it can load
    the required messages.
  prefs: []
  type: TYPE_NORMAL
- en: New message/reply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The route to handle requests for a new message thread is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the final route in our application, and is used when a thread has been
    selected and then the user clicks on the "reply" button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the "show thread" route, except that the composer is shown as well
    as the messages view.
  prefs: []
  type: TYPE_NORMAL
- en: Routing overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Examining the paths a user can take through your application can be a very valuable
    way of making sure nothing is missing from your design. It also gives the site
    the benefit of understanding the state of your application at various points on
    the path and allows you to translate this into routes to restore that state.
  prefs: []
  type: TYPE_NORMAL
- en: A binding agreement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the state of the application is held in the URL, but other transient
    state is held in view models. We're going to look at an example of how data flows
    through this application in order to better understand how powerful data binding
    can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In portrait mode, our application has a menu button that toggles the visibility
    of various other components. The pseudocode for this could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Code like this isn''t complicated, but it''s lengthy and error prone, a chore
    to write. Instead, we can use data binding to avoid this type of code and set
    up the behavior during configuration, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to understand here: firstly that a button will
    "publish" the state of its `pressed` value. Whenever `pressed` changes, either
    programmatically or because the user clicked on the button, the value will be
    pushed to the view model for this button. Secondly, if a component has its `reference`
    set, this will be available to access its published values in the view model.'
  prefs: []
  type: TYPE_NORMAL
- en: Combine both of these and the bind configuration on the search field becomes
    clear; bind the value of `hidden` on the search field to the value of `pressed`
    on the menu button. If `pressed` is `true`, the search field will be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: While we've covered data binding and view models in some detail in previous
    chapters, this is the first time we've looked at this particular approach. It's
    not even necessary to specify any configuration on the view model itself as long
    as one is available somewhere in the component hierarchy, this will work.
  prefs: []
  type: TYPE_NORMAL
- en: This is another weapon in the armory of tools that allow us to simplify our
    code. Using this kind of declarative approach, where we specify what we'd like
    to happen, but don't have to say how it happens, we can avoid writing methods
    like the pseudocode earlier and use a standardized approach that Ext JS provides.
  prefs: []
  type: TYPE_NORMAL
- en: The tricky part is fully embracing data binding and the view model concept.
    By thinking up-front about the dependencies between components and channeling
    data through view models, powerful interactions can be created with very little
    code.
  prefs: []
  type: TYPE_NORMAL
- en: An eventful application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting observation about both routing and data binding is that they
    are built around events. When a route changes, an event is fired and a controller
    listens to it, setting the application's state accordingly. When a property is
    data bound, Ext JS publishes its changes and other properties listen for these
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We're also familiar with events, such as `click`, `select`, `show`, and so on,
    that are fired from the various Ext JS components. It would seem that as events
    are being used everywhere in an Ext JS application, we might as well make use
    of them ourselves!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `fireEvent` from every `Observable` class in Ext JS. This allows
    you to fire a custom event from pretty much anywhere in our application. In previous
    versions of Ext JS, you needed to define events beforehand using an `addEvent`
    method, but this is no longer the case. However, what use is this? Does it offer
    a real-world advantage? Let''s look at some bad code to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We save a message record. Then, in the callback, reload a list store, show a
    message in the viewport, and hide an editor component.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s three separate things, only one of which—hiding the editor—is probably
    in the right place. The others should be handled by their own view controllers.
    This code would be much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, any code anywhere in the application can listen for a `messagesaved` event
    and proceed accordingly. The key benefit this brings is that this example message
    view controller doesn't have to know anything about any other views, controllers,
    or even anything about the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the messages view and view controller much more resistant to any
    changes in the rest of the system and much easier to test. In theory, it could
    be pulled out of the application and tested standalone.
  prefs: []
  type: TYPE_NORMAL
- en: Events and you
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go back to our webmail application. There's no point in adding events—or
    indeed anything—to our code base unless we're going to use them. A lot of places
    where we could use custom events will be rendered unnecessary by data binding
    and rendered unnecessary by routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one place that a custom event will be useful: when creating a reply.
    The composer controller is responsible for this, but when the reply''s been saved
    we also need to refresh the messages view so that we can see the reply. This is
    a perfect place to make use of a custom event. We''ll see how this is implemented
    shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding – it's been a long time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spent a lot of time examining this proposed application and thinking about
    the techniques we can use to create it in an elegant way. Now, it's time to start
    building it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned that the data layer for this application is very straightforward
    with lots of boilerplate code and nothing that is unexpected based on the knowledge
    we''ve gained in previous chapters. Let''s jump straight in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Four models: `Contact`, `Tag`, `Message`, and `Thread`, all extend a `BaseModel`
    class that contains our data schema. Note that the `BaseModel` class specifies
    a rest proxy, so we know what to expect from the load and save behavior on our
    models. This is completely standard and very familiar from our previous example
    applications. The stores are correspondingly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There is one store for each model class; everything apart from messages will
    load automatically because we need them across the application and they don't
    require any parameters to be passed to them.
  prefs: []
  type: TYPE_NORMAL
- en: It's under control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data fundamentals are in place, so let''s look at a feature we''ll be using
    for the first time in this application: the `Controller`. Not a view controller
    this time, but the over-arching application controller we talked about in our
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In previous examples, `app/Application.js` has been responsible for creating
    the viewport that represents the main view of the application. In this case, the
    root controller takes on this role. We override its `onLaunch` method to detect
    whether the user is logged in, regardless of the route they are on. It also specifies
    the default URL for the application (just an empty string) and again checks for
    a valid login.
  prefs: []
  type: TYPE_NORMAL
- en: When a valid login is detected, the main view is shown, otherwise the login
    is shown. This is a super-simple mechanism to create a crude login system.
  prefs: []
  type: TYPE_NORMAL
- en: Login view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The login view is a window centered in the screen that contains a number of
    fields. Their values are bound to a login object on the view model, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `controller` and `ViewModel` configuration options and the prefix
    of the bind values that links to the login object on the view model. Speaking
    of which:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is happening here other than defining this login object. Let''s move
    on to the view controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The view controller does nothing more than listen for the `click` event on the
    login form's button and then fake a successful login. For simplicity, this application
    doesn't do any validation of user details, so we just instantly fire a redirect
    to the home route.
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that the root controller handles the home token, which removes
    the login view and creates the main view. Let's move on and take a look at that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Main force
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking back at our design, the main view is the container for the rest of
    the UI in our application. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot going on here, but only a couple of new concepts. Note that
    we have added a couple of plugins to this class: `viewport` and `responsive`.
    As we didn''t let our application auto create a view as a `viewport`, adding the
    `viewport` plugin will do just that. The `responsive` plugin allows you to use
    the `responsiveConfig` option, which we discussed earlier in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, on screens that are tall, that is, higher than they are wide,
    such as portrait screens, we use a card layout. On screens that are wide, that
    is, wider than they are high, we use an `hbox` layout because there's a lot more
    horizontal space. This simple declarative way of setting up a responsive view
    has allowed us to make very distinct changes to our application with only a few
    lines of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We've added a utility method to this view to help with manipulating our responsive
    setup; the `isCard` view will let us neatly determine whether this view is using
    a `card` layout or `hbox` layout.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Syntactic sugar is an alternative way of writing something that makes it easier
    to read or allows it to better express its intent. The `isCard` method is an example
    of this, not strictly necessary, but it makes the calling code shorter and easier
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this configuration should be very familiar: two `dockedItems`,
    one is the application header view and another supplying a logout button, and
    the three other views of this application in the items array.'
  prefs: []
  type: TYPE_NORMAL
- en: Main ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On first glance, the code for this will look pretty standard, but when you
    look back at the code for the main view itself, you notice that `currentTag` or
    `searchTerm` is not going to be used anywhere. So, why define them if they''re
    not going to be used? Refer to `ViewModel` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In Ext JS, we have the concept of parent and child view models. The main view
    model, configured on the main view, will become available to all child components
    of the main view. This means that subviews can get data on the main view and also
    pass information back up to it. This is a fantastic way of passing data between
    two child components.
  prefs: []
  type: TYPE_NORMAL
- en: Main ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewController` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting thing happening in here is the route handlers; we're giving
    several routes to the `showRightPane` handler. Looking back at our examination
    of user flow and routes in our application, many of the routes need us to ensure
    that the right-hand panel is in view. This only applies to the responsive portrait
    view, so we only change the active panel if the portrait view's card layout is
    available.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that we've got route handlers that only do part of what
    we'd expect. Where are the bits that pass IDs and show subviews? Don't worry,
    we'll revisit this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The head of the family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the `Header.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That's actually a lot of code for a header bar! Look back at our original
    class design for this view and we did say there was "a surprising amount happening",
    so we weren't wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In the section, *A binding agreement* we discussed a cut-down example of what
    is happening in this class. The `reference` option on the menu button is used
    to allow the other header components to bind to the menu's pressed value; look
    at the previous code and you'll see this approach used in various places to show
    or hide components when the menu button is toggled.
  prefs: []
  type: TYPE_NORMAL
- en: We're not only using the responsive plugin again mostly to set the initial hidden
    state of the header components, but also using it to make sure the hidden config
    is only bound when the viewport is tall. This avoids issues with initial visibility
    of other components when the menu button isn't even in use. This kind of conditional
    binding opens up some exciting possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple more things of note: we mentioned the main view model had some values
    that seemed unused. Well, here they are, bound to the values of the tag filter
    combo and the search text field. When these values change, they''ll be passed
    up to the main view model and available for use by other components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a final item of note: a mysterious home-button component. The code
    for this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We're using this as a fake button, extending the simple container to fire a
    `click` event. This allows you to get a lightweight, unstyled, and clickable component
    to use as a home button.
  prefs: []
  type: TYPE_NORMAL
- en: Header ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewModel` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This `ViewModel` class supplies the tags to populate the tag filter combo. We
    use a session to make sure that we're using the same tag instances across the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Header ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewController` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There are two component event listeners, one on the new message button and one
    on the home button. Both redirect to routes that will be consumed by other controllers.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a controller listener that waits for a `tagadded` event and refreshes
    the tag store on `ViewModel`. This is great because we don't have to worry about
    where this event comes from or which component issued it; we just consume it in
    isolation and perform the action we're interested in.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse applies too, meaning the issuer of the `tagadded` event doesn't
    need to work out how to refresh the tag filter combo; instead, it can just declare
    that a tag was added and rest easy.
  prefs: []
  type: TYPE_NORMAL
- en: Unravel the thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A thread is a collection of e-mail messages, and the thread view makes up the
    left-hand pane of our application. It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We knew from our design work that we would use a DataView for this class and
    its implementation turns out to be fairly straightforward. We're binding its store
    to the threads store on the view model itself also called as threads.
  prefs: []
  type: TYPE_NORMAL
- en: Look back at the design and you'll see that we anticipated a method to strip
    HTML from the message body and here it is; a little bit of trickery that uses
    a temporary DOM element to let the browser do the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Thread ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewModel` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is actually the most complicated view model in the whole application and
    most of this complexity should be familiar from [Chapter 6](ch06.html "Chapter 6. Practical
    – Monitoring Dashboard"), *Practical – Monitoring Dashboard*. The filter array,
    along with the `remoteFilter` setting, will be responsible for sending a JSON
    object containing a filter definition through to the server. In this case, we
    see that we are consuming values from the main view model as broadcast up by the
    tag picker combo and search field in the header.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about this before, but it's worth highlighting again. The data flows
    from the header view to the main view model and then into the thread view. This
    is an incredibly simple way of communicating between parts of an application without
    these parts needing to be aware of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Thread ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewController` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: More of these event listeners, and so on. We knew they'd come in handy, but
    they're everywhere! In the thread view controller, we listen for the DataView's
    `itemclick` event and simply redirect the application off so that another controller's
    route can take care of it. Fire and forget.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, we listen for a `threadschanged` event, which is issued when a thread
    is added. This allows you to refresh the DataView's store in the view model to
    see the effects of the added thread. We don't know or care where `threadschanged`
    came from.
  prefs: []
  type: TYPE_NORMAL
- en: I am the best message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the `Messages.js` file in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In an ideal situation, the code should flow out of your team as the culmination
    of the design process. Any difficult classes or methods should have been part
    of a code spike. Your data layer would have been designed on top of your backend
    API. User interface has been described in wireframes, user stories provide routing,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we're seeing now. As seasoned Ext JS developers, we know how to
    configure a combo box and a store. This book is not here to help with that. We're
    going to continue to focus on the design and the decisions that make your code
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the previous class. The design of the messages view with its DataView
    nested inside a panel allows you to use a `bbar`; we knew about this before we
    even wrote a line of code. This is the crux of a good design. With developers
    who understand the technology they are working with, implementations become easy
    and predictable because it's all been thought about in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Messages ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to `ViewModel` in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See! With an up-front design, you can pass the documentation over to a developer
    and have them create the messages view model. There's little scope for error because
    the shape of the class has already been decided.
  prefs: []
  type: TYPE_NORMAL
- en: Messages ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having said that, there are times when the code is lengthy, so a breakdown
    of what''s happening really helps as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we have our event listeners. Let's look at the component ones; firstly
    the one that handles the reply button's `click` event as it's straightforward.
    It just redirects to a route that will take care of setting up the application
    to reply to a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Next, there's the `onTagChange` method that handles a click on the "set tag"
    button. This will get the selected value from the tag combo box and set it as
    the tag for the first message in the thread. Then, it saves that message to the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Note the callback for this save request (it fires off two events that we've
    seen before). One (`threadschanged`) notifies the application that threads have
    changed in some way; in this case, it's a thread's tag that has changed, so a
    thread list may need to be refreshed. The other (`tagadded`) signifies that there
    may be a new tag and any interested classes should refresh their tag data accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The next two handlers are for routes, but there's something to note here. These
    routes have already been handled by the main view controller! This is a powerful
    feature; we can handle routes in multiple locations so that the classes that are
    interested in this route can do their own thing. This avoids us having to do all
    of the work in the main view controller, for example, the messages view controller
    can take care of loading the messages rather than doing so in the main view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Compare using routes in this way to using events. They're very similar; we can
    redirect to a route, fire this redirect and forget about it, or else, where in
    the application a controller will handle this route. With routes, you get the
    added benefit of keeping state in the URL, thus enabling bookmark support. With
    events, you can send complex data in the event arguments. Both have their strengths.
  prefs: []
  type: TYPE_NORMAL
- en: A composed finish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we come to the view that allows you to actually send e-mails, a pretty
    important part of this application!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Another straightforward component definition, with the values of the form fields
    being bound to the `newMessage` object in the view model for later use. There''s
    another view model trick here, that is, if this `newMessage` object has a `parentId`
    value, we know that we''re replying to an existing thread. This means that we
    can hide the subject and recipient form fields, so we bind the `parentId` to their
    hidden value, making this step automatic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have the contacts store that corresponds to the one in the view that was
    bound to the recipient's combo and then an empty definition for the `newMessage`
    object discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In component listeners, we handle the `click` event of the send button with
    the `onSendClick` method. This creates a new record on the current session and
    saves it to the server. In the `callback` method, we dispatch the application
    to the route that shows thread messages, but note that we'll use the ID of the
    new message in the event of it being a brand new thread and the `parentID` of
    the new message if it's a reply.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of handling routes, there's one (`hideComposer`) that hides the composer
    when viewing the messages in a thread because there's no need for it to be visible
    at that point. Then, there's a second (`showComposer`) that sets the `parentId`
    on the `newMessage` and shows the composer. For new threads, there's no ID captured
    by the route, so the `parentId` argument will be undefined and `newMessage.parentId`
    will be set as such. This enables the automatic viewing and hiding of the recipient
    and subject back in the composer view itself. Back when designing the app, we
    referred to this as `currentThreadId`, but we can see now that it makes sense
    to incorporate it in the `newMessage` object and pass this to the server when
    we save the new record.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on a theme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered all of the parts of this application apart from one: the way
    it looks. Cast your mind back to the screenshot of the app in action earlier in
    the chapter. In fact, have a look at the login screen to see how it differs from
    a standard Ext JS app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deciding on a theme](img/5308OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve changed key things such as the font and color of the window frame, but
    take a look at the code to perform this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Ext JS themes provide an extensive range of variables designated by the dollar
    sign in front of them. By defining our own, such as `$body-font-family`, and overriding
    existing ones, we can easily shape the look of our application to suit different
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only this, but from a maintenance point of view, it''s far preferable to
    set a few variables than it''s to write a swathe of CSS rules to override theme
    style sheets. We can avoid problems like CSS precedence and finding the correct
    selectors to use and get on with making our app stand out. However, if we need
    to, we can drop down to use SASS, the CSS-like compiler that Ext JS uses for theming.
    Take a look at the styling for the thread view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The thread view is a DataView, meaning its template can contain any custom HTML.
    Writing new SASS rules makes sense here, but Ext JS allows you to do this in a
    modular and reusable way, similar to the features it provides to write JavaScript
    classes. In the next few chapters, we'll discuss this and other features of theming
    in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've taken a different approach to designing and implementing this application.
    Rather than discussing the same details we have in previous chapters, we've avoided
    retreading old ground and talked about a higher level of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing routes, view model bindings, and events more extensively than
    ever before, we've shown how a declarative approach to Ext JS can simplify our
    code and make it incredibly easy to understand. At the same time, components that
    issue and listen to events are more decoupled, leading to fewer bugs and increased
    testability.
  prefs: []
  type: TYPE_NORMAL
- en: We also touched on theming, showing how a few lines of code can dramatically
    affect the look of an app and how we can write custom style rules to create brand
    new components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue to explore the architectural ideas we've
    used already, but expanding them to look at how to make best use of them in the
    design phase. We'll look at how Ext JS architecture applies to theming and how
    we can continue to improve our code reuse all across our application.
  prefs: []
  type: TYPE_NORMAL
