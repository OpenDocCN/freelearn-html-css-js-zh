<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 11. Using Force"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/><span class="koboSpan" id="kobo.1.1">Chapter 11. Using Force</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this chapter, we will cover:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.3.1">Using gravity and charge</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.4.1">Customizing velocity</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.5.1">Setting the link constraint</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.6.1">Using force to assist visualization</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.7.1">Manipulating force</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.8.1">Building a force-directed graph</span></li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec75"/><span class="koboSpan" id="kobo.9.1">Introduction</span></h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.10.1">Use the force, Luke!</span></em></span>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em><span class="koboSpan" id="kobo.11.1">A master's words of wisdom to his apprentice</span></em></span>
</p></blockquote></div><p><span class="koboSpan" id="kobo.12.1">In this chapter, we will cover one of the most fascinating aspects of D3: force. </span><span class="koboSpan" id="kobo.12.2">Force simulation is one of the most awe-inspiring techniques that you can add to your visualization. </span><span class="koboSpan" id="kobo.12.3">Through a number of highly interactive and fully functional examples, we will help you explore not only the typical application of D3 force (for example, the force-directed graph), but also other essential aspects of force manipulation.</span></p><p><span class="koboSpan" id="kobo.13.1">D3 force simulation support was created not as a separate capability, but rather as a kind of additional D3 layout. </span><span class="koboSpan" id="kobo.13.2">As we mentioned in </span><a class="link" href="ch09.html" title="Chapter 9. Lay Them Out"><span class="koboSpan" id="kobo.14.1">Chapter 9</span></a><span class="koboSpan" id="kobo.15.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.16.1">Lay Them Out</span></em></span><span class="koboSpan" id="kobo.17.1">, D3 layouts are nonvisual data-oriented layout management programs designed to be used with different visualization. </span><span class="koboSpan" id="kobo.17.2">Force simulation was originally created for the purpose of implementing a specific type of visualization called </span><span class="strong"><strong><span class="koboSpan" id="kobo.18.1">force-directed graph</span></strong></span><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">Its implementation uses standard </span><span class="strong"><strong><span class="koboSpan" id="kobo.20.1">velocity</span></strong></span>
<span class="strong"><strong><span class="koboSpan" id="kobo.21.1">verlet integration</span></strong></span><span class="koboSpan" id="kobo.22.1"> simulating physical forces on particles.</span></p><p><span class="koboSpan" id="kobo.23.1">In other words, D3 implements a numeric method that is capable of loosely simulating the motion of particles using its velocity with stepped temporal functions. </span><span class="koboSpan" id="kobo.23.2">This kind of simulation, of course, was ideal in implementing particular visualization, such as a force-directed graph; however, you will also discover through recipes in this chapter that force simulation is capable of generating many other interesting visualization effects, thanks to its flexibility in custom force manipulation. </span><span class="koboSpan" id="kobo.23.3">The application of such techniques introduced in this chapter goes even beyond the data visualization realm and has practical applications in many other domains, for example, user interface design. </span><span class="koboSpan" id="kobo.23.4">Of course, in this chapter, we will also cover the classical application of force: the force-directed graph.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using gravity and charge"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec76"/><span class="koboSpan" id="kobo.1.1">Using gravity and charge</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In this recipe, we will introduce you to the first two fundamental forces: gravity and charge. </span><span class="koboSpan" id="kobo.2.2">As we have mentioned before, one objective of force layout's design is to loosely simulate the motion of particles, and one major feature of this simulation is the force of charge. </span><span class="koboSpan" id="kobo.2.3">Additionally, force simulation also implements pseudo gravity, or more accurately, a weak geometric constraint typically centered on the canvas that can be leveraged to keep your visualization from escaping the canvas. </span><span class="koboSpan" id="kobo.2.4">In the following example, you will learn how these two fundamental, sometimes opposing, forces can be leveraged to generate various effects with a particle system.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec226"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html
</span></a><span class="koboSpan" id="kobo.6.1">.</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec227"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In the following example, we will experiment with the force simulating gravity and charge settings so you can better understand different opposing forces involved and their interaction:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, r = 4.5, 
        nodes = [], 
        force = d3.forceSimulation() 
                .velocityDecay(0.8) 
                .alphaDecay(0) 
                .force("collision",  
                   d3.forceCollide(r + 0.5).strength(1)); 
 
    var svg = d3.select("body") 
        .append("svg") 
            .attr("width", w) 
            .attr("height", h); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}); 
    }); 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = {x: point[0], y: point[1]}; // &lt;-A 
 
        svg.append("circle") 
                .data([node]) 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("r", 1e-6) 
        .transition() 
            .attr("r", r) 
        .transition() 
            .delay(7000) 
            .attr("r", 1e-6) 
            .on("end", function () { 
                nodes.shift(); // &lt;-B 
                force.nodes(nodes); 
            }) 
            .remove(); 
 
        nodes.push(node); // &lt;-C 
        force.nodes(nodes); 
    }); 
 
    function noForce(){ 
        force.force("charge", null); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function repulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-10)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function gravity(){ 
        force.force("charge", d3.forceManyBody().strength(1)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function positioningWithGravity(){ 
        force.force("charge", d3.forceManyBody().strength(0.5)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
 
    function positioningWithRepulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-20)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="noForce()"&gt; 
        No Force 
    &lt;/button&gt; 
    &lt;button onclick="repulsion()"&gt; 
        Repulsion 
    &lt;/button&gt; 
    &lt;button onclick="gravity()"&gt; 
        Gravity 
    &lt;/button&gt; 
    &lt;button onclick="positioningWithGravity()"&gt; 
        Positioning with Gravity 
    &lt;/button&gt; 
    &lt;button onclick="positioningWithRepulsion()"&gt; 
        Positioning with Repulsion 
    &lt;/button&gt; 
&lt;/div&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This recipe generates a force-enabled particle system that is capable of operating in the modes shown in the following diagram:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_11_001.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Force simulation modes</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec228"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">Before we get our hands dirty with the preceding code example, let's first dig a little bit deeper into the fundamental concepts of alpha decay, velocity decay, charge, positioning, and collision so we can have an easier time understanding all the magic number settings we will use in this recipe.</span></p><div class="section" title="Alpha decay"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec19"/><span class="koboSpan" id="kobo.15.1">Alpha decay</span></h3></div></div></div><p><span class="koboSpan" id="kobo.16.1">Alpha determines how hot a simulation is. </span><span class="koboSpan" id="kobo.16.2">A simulation starts with alpha of 1 and decay toward 0 by default over 300 iterations. </span><span class="koboSpan" id="kobo.16.3">Therefore, if you set the alpha decay to 0 meaning there is no decay therefore simulation will never stop. </span><span class="koboSpan" id="kobo.16.4">This is the setting we will use in this chapter in order to better demonstrate the effects. </span><span class="koboSpan" id="kobo.16.5">In real-life visualization, you will typically use some level of decay so that the simulation will cool down after a while, similar to how particles work in the real world.</span></p></div><div class="section" title="Velocity decay"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec20"/><span class="koboSpan" id="kobo.17.1">Velocity decay</span></h3></div></div></div><p><span class="koboSpan" id="kobo.18.1">At each tick of the simulation particle, velocity is scaled down by a specified decay. </span><span class="koboSpan" id="kobo.18.2">Thus, a value of 1 corresponds to a frictionless environment, whereas a value of 0 freezes all particles in place since they lose their velocity immediately.</span></p></div><div class="section" title="Charge"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec21"/><span class="koboSpan" id="kobo.19.1">Charge</span></h3></div></div></div><p><span class="koboSpan" id="kobo.20.1">Charge is specified to simulate mutual n-body forces among the particles. </span><span class="koboSpan" id="kobo.20.2">A negative value will result in mutual node repulsion, whereas a positive value will result in a mutual node attraction.</span></p></div><div class="section" title="Positioning"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec22"/><span class="koboSpan" id="kobo.21.1">Positioning</span></h3></div></div></div><p><span class="koboSpan" id="kobo.22.1">If X or Y positioning forces are specified, the simulation will push particles toward a desired position along a given dimension with configured strength. </span><span class="koboSpan" id="kobo.22.2">This is typically used as a global force that applies to all particles in the simulation.</span></p></div><div class="section" title="Collision"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec23"/><span class="koboSpan" id="kobo.23.1">Collision</span></h3></div></div></div><p><span class="koboSpan" id="kobo.24.1">The collision force treats particles as circles with a certain radius instead of size-less points. </span><span class="koboSpan" id="kobo.24.2">This will prevent particles from overlapping in a simulation.</span></p><p><span class="koboSpan" id="kobo.25.1">Alright, now with the dry definition behind us, let's take a look at how these forces can be leveraged to generate interesting visual effects.
</span></p></div><div class="section" title="Setting up zero force layout"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec24"/><span class="koboSpan" id="kobo.26.1">Setting up zero force layout</span></h3></div></div></div><p><span class="koboSpan" id="kobo.27.1">To set up zero force layout, we simply set up force layout with neither gravity nor charge. </span><span class="koboSpan" id="kobo.27.2">The force layout can be created using the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">d3.forceSimulation</span></code><span class="koboSpan" id="kobo.29.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.30.1">var w = 1280, h = 800, r = 4.5, 
        nodes = [], 
        force = d3.forceSimulation() 
                .velocityDecay(0.8) 
                .alphaDecay(0) 
                .force("collision",  
                    d3.forceCollide(r + 0.5).strength(1)); 
</span></pre><p><span class="koboSpan" id="kobo.31.1">First of all, we disable </span><code class="literal"><span class="koboSpan" id="kobo.32.1">alphaDecay</span></code><span class="koboSpan" id="kobo.33.1"> so that simulation will continue to run without cooling down while setting the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">velocityDecay</span></code><span class="koboSpan" id="kobo.35.1"> to </span><code class="literal"><span class="koboSpan" id="kobo.36.1">0.8</span></code><span class="koboSpan" id="kobo.37.1"> to simulate the effect of friction. </span><span class="koboSpan" id="kobo.37.2">Next, we set the </span><code class="literal"><span class="koboSpan" id="kobo.38.1">collision</span></code><span class="koboSpan" id="kobo.39.1"> to slightly larger than the radius of the </span><code class="literal"><span class="koboSpan" id="kobo.40.1">svg:circle</span></code><span class="koboSpan" id="kobo.41.1"> element we will create later. </span><span class="koboSpan" id="kobo.41.2">With this setting in place, we then create additional nodes represented as </span><code class="literal"><span class="koboSpan" id="kobo.42.1">svg:circle</span></code><span class="koboSpan" id="kobo.43.1"> on SVG whenever the user moves the mouse:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.44.1">svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = {x: point[0], y: point[1]}; // &lt;-A 
 
        svg.append("circle") 
                .data([node]) 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("r", 1e-6) 
        .transition() 
            .attr("r", r) 
        .transition() 
            .delay(7000) 
            .attr("r", 1e-6) 
            .on("end", function () { 
                nodes.shift(); // &lt;-B 
                force.nodes(nodes); 
            }) 
            .remove(); 
 
        nodes.push(node); // &lt;-C 
        force.nodes(nodes); 
    }); 
</span></pre><p><span class="koboSpan" id="kobo.45.1">Node object was created initially on line </span><code class="literal"><span class="koboSpan" id="kobo.46.1">A</span></code><span class="koboSpan" id="kobo.47.1"> with its coordinates set to the current mouse location. </span><span class="koboSpan" id="kobo.47.2">Like all other D3 layouts, force simulation is not aware and has no visual elements. </span><span class="koboSpan" id="kobo.47.3">Therefore, every node we create needs to be added to the layout's nodes array on line </span><code class="literal"><span class="koboSpan" id="kobo.48.1">C</span></code><span class="koboSpan" id="kobo.49.1"> and removed when the visual representation of these nodes was removed on line </span><code class="literal"><span class="koboSpan" id="kobo.50.1">B</span></code><span class="koboSpan" id="kobo.51.1">. </span><span class="koboSpan" id="kobo.51.2">By default, force simulation starts automatically as soon as the simulation was created. </span><span class="koboSpan" id="kobo.51.3">With zero gravity and charge, this setting essentially lets us place a string of nodes with our mouse movement, as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.52.1"><img src="graphics/image_11_002.jpg" alt="Setting up zero force layout"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.53.1">No Gravity or Charge</span></p></div><div class="section" title="Setting up mutual repulsion"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec25"/><span class="koboSpan" id="kobo.54.1">Setting up mutual repulsion</span></h3></div></div></div><p><span class="koboSpan" id="kobo.55.1">In the next mode, we will set the charge to a negative value without any global positioning force in order to generate a mutual repulsive force field:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.56.1">    function repulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-10)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.57.1">These lines tell force layout to apply </span><code class="literal"><span class="koboSpan" id="kobo.58.1">-10</span></code><span class="koboSpan" id="kobo.59.1"> charge on each node and update the node's </span><code class="literal"><span class="koboSpan" id="kobo.60.1">{x, y}</span></code><span class="koboSpan" id="kobo.61.1"> coordinate accordingly, based on the simulation result on each tick. </span><span class="koboSpan" id="kobo.61.2">However, only doing this is still not enough to move the particles on SVG since the layout has no knowledge of the visual elements. </span><span class="koboSpan" id="kobo.61.3">Next, we need to write some code to connect the data that is being manipulated by force layout to our graphical elements. </span><span class="koboSpan" id="kobo.61.4">Following is the code to do that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}); 
}); 
</span></pre><p><span class="koboSpan" id="kobo.63.1">Here, we register a </span><code class="literal"><span class="koboSpan" id="kobo.64.1">tick</span></code><span class="koboSpan" id="kobo.65.1"> event listener function that updates all circle elements to its new position based on the force layout's calculation. </span><span class="koboSpan" id="kobo.65.2">Tick listener is triggered on each tick of the simulation. </span><span class="koboSpan" id="kobo.65.3">At each tick, we set the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">cx</span></code><span class="koboSpan" id="kobo.67.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.68.1">cy</span></code><span class="koboSpan" id="kobo.69.1"> attributes to be the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">x</span></code><span class="koboSpan" id="kobo.71.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.72.1">y</span></code><span class="koboSpan" id="kobo.73.1"> values on </span><code class="literal"><span class="koboSpan" id="kobo.74.1">d</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">This is because we have already bound the node object as datum to these circle elements. </span><span class="koboSpan" id="kobo.75.3">Therefore, they already contain the new coordinates calculated by force layout. </span><span class="koboSpan" id="kobo.75.4">This effectively establishes force layout's control over all the particles.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note82"/><span class="koboSpan" id="kobo.76.1">Note</span></h3><p><span class="koboSpan" id="kobo.77.1">Force simulation also sets values other than x and y on the node object, which we will cover and leverage in later recipes to implement force drag and custom forces. </span><span class="koboSpan" id="kobo.77.2">In this recipe, let's just focus on the simple force-based positioning first.</span></p></div></div><p><span class="koboSpan" id="kobo.78.1">Other than </span><code class="literal"><span class="koboSpan" id="kobo.79.1">tick</span></code><span class="koboSpan" id="kobo.80.1">, force layout also supports some other events:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.81.1">tick</span></code><span class="koboSpan" id="kobo.82.1">: Triggered on each tick of the simulation</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.83.1">end</span></code><span class="koboSpan" id="kobo.84.1">: Triggered when a simulation ends</span></li></ul></div><p><span class="koboSpan" id="kobo.85.1">This force setting generates the following visual effect:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.86.1"><img src="graphics/image_11_003.jpg" alt="Setting up mutual repulsion"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.87.1">Mutual Repulsion</span></p></div><div class="section" title="Setting up gravity"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec26"/><span class="koboSpan" id="kobo.88.1">Setting up gravity</span></h3></div></div></div><p><span class="koboSpan" id="kobo.89.1">When we change the charge to a positive value, it generates mutual attraction or gravity among the particles:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.90.1">     function gravity(){ 
        force.force("charge", d3.forceManyBody().strength(1)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.91.1">This generates the following visual effect:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.92.1"><img src="graphics/image_11_004.jpg" alt="Setting up gravity"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.93.1">Gravity</span></p></div><div class="section" title="Setting up positioning with gravity"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec27"/><span class="koboSpan" id="kobo.94.1">Setting up positioning with gravity</span></h3></div></div></div><p><span class="koboSpan" id="kobo.95.1">When we turn on gravity with central positioning force, then it generates a somewhat similar effect as the mutual attraction; however, you can notice the strong gravitational pull as the mouse cursor moves away from the center:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.96.1">    function positioningWithGravity(){ 
        force.force("charge", d3.forceManyBody().strength(0.5)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.97.1">This recipe generates the following effect:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.98.1"><img src="graphics/image_11_005.jpg" alt="Setting up positioning with gravity"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.99.1">Positioning with gravity</span></p></div><div class="section" title="Setting up positioning with repulsion"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec28"/><span class="koboSpan" id="kobo.100.1">Setting up positioning with repulsion</span></h3></div></div></div><p><span class="koboSpan" id="kobo.101.1">Finally, we can turn on both positioning and mutual repulsion. </span><span class="koboSpan" id="kobo.101.2">The result is an equilibrium of forces that keeps all particles somewhat stable, neither escaping nor colliding with each other:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.102.1">    function positioningWithRepulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-20)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.103.1">Here is what this force equilibrium looks like:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.104.1"><img src="graphics/image_11_006.jpg" alt="Setting up positioning with repulsion"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.105.1">Positioning with repulsion</span></p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec229"/><span class="koboSpan" id="kobo.106.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.107.1">Refer to Velocity Verlet integration at </span><a class="ulink" href="https://en.wikipedia.org/wiki/Verlet_integration"><span class="koboSpan" id="kobo.108.1">https://en.wikipedia.org/wiki/Verlet_integration
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.109.1">Refer to scalable, versatile, and simple constrained graph layout at </span><a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf"><span class="koboSpan" id="kobo.110.1">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.111.1">Refer to physical simulation at </span><a class="ulink" href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm"><span class="koboSpan" id="kobo.112.1">http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.113.1">The content of this chapter is inspired by Mike Bostock's brilliant talk on D3 Force that can be found at </span><a class="ulink" href="http://mbostock.github.io/d3/talk/20110921/"><span class="koboSpan" id="kobo.114.1">http://mbostock.github.io/d3/talk/20110921/
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.115.1">Refer to </span><a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization"><span class="koboSpan" id="kobo.116.1">Chapter 10</span></a><span class="koboSpan" id="kobo.117.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.118.1">Interacting with Your Visualization</span></em></span><span class="koboSpan" id="kobo.119.1">, for more details on how to interact with the mouse in D3</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.120.1">Refer to D3 Force Simulation API document for more details on force at </span><a class="ulink" href="https://github.com/d3/d3-force"><span class="koboSpan" id="kobo.121.1">https://github.com/d3/d3-force
</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Customizing velocity"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec77"/><span class="koboSpan" id="kobo.1.1">Customizing velocity</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In our previous recipe, we touched upon force simulation node object and its {</span><code class="literal"><span class="koboSpan" id="kobo.3.1">x, y</span></code><span class="koboSpan" id="kobo.4.1">} attributes, which determine the location of a node on the layout. </span><span class="koboSpan" id="kobo.4.2">In this recipe, we will discuss another interesting aspect of physical motion simulation: velocity. </span><span class="koboSpan" id="kobo.4.3">The D3 force layout has a built-in support for velocity simulation, which relies on the {</span><code class="literal"><span class="koboSpan" id="kobo.5.1">vx, vy</span></code><span class="koboSpan" id="kobo.6.1">} attributes on the node object. </span><span class="koboSpan" id="kobo.6.2">Let's see how this can be done in the example described in this recipe.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec230"/><span class="koboSpan" id="kobo.7.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html"><span class="koboSpan" id="kobo.9.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html
</span></a><span class="koboSpan" id="kobo.10.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec231"/><span class="koboSpan" id="kobo.11.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.12.1">In this recipe, we will modify the previous recipe by first disabling both positioning and charge and then giving newly added node some initial velocity. </span><span class="koboSpan" id="kobo.12.2">As a result, now, the faster you move the mouse higher the initial velocity and momentum will be for each node. </span><span class="koboSpan" id="kobo.12.3">Here is the code to do that:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">&lt;script type="text/javascript"&gt; 
    var r = 4.5, nodes = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.1) 
                    .alphaDecay(0) 
                    .force("collision",  
                         d3.forceCollide(r + 0.5).strength(1)); 
 
    var svg = d3.select("body").append("svg:svg"); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}); 
    }); 
 
    var previousPoint; 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = { 
                x: point[0], 
                y: point[1], 
                vx: previousPoint? 
                     </span><span class="koboSpan" id="kobo.13.2">point[0]-previousPoint[0]:point[0], 
                vy: previousPoint? 
                     </span><span class="koboSpan" id="kobo.13.3">point[1]-previousPoint[1]:point[1] 
            }; 
 
        previousPoint = point; 
 
        svg.append("svg:circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
            .transition() 
                .attr("r", r) 
            .transition() 
            .delay(5000) 
                .attr("r", 1e-6) 
                .on("end", function () { 
                    nodes.shift(); 
                    force.nodes(nodes); 
                }) 
                .remove(); 
 
        nodes.push(node); 
        force.nodes(nodes); 
    }); 
&lt;/script&gt;  
</span></pre><p><span class="koboSpan" id="kobo.14.1">This recipe generates a particle system with initial directional velocity proportional to the user's mouse movement, as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.15.1"><img src="graphics/image_11_007.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.16.1">Velocity</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec232"/><span class="koboSpan" id="kobo.17.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.18.1">The overall structure of this recipe is pretty similar to the previous one. </span><span class="koboSpan" id="kobo.18.2">It also generates particles as the user moves the mouse around. </span><span class="koboSpan" id="kobo.18.3">Moreover, once the force simulation starts, the particle position is fully controlled by the force layout in its </span><code class="literal"><span class="koboSpan" id="kobo.19.1">tick</span></code><span class="koboSpan" id="kobo.20.1"> event listener function. </span><span class="koboSpan" id="kobo.20.2">However, in this recipe, we have turned off both positioning and charge so that we can focus more clearly on momentum alone. </span><span class="koboSpan" id="kobo.20.3">We left some friction so that the velocity decay, making simulation look more realistic. </span><span class="koboSpan" id="kobo.20.4">Here is our force layout configuration:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.21.1">var force = d3.forceSimulation() 
                    .velocityDecay(0.1) 
                    .alphaDecay(0) 
                    .force("collision",  
                         d3.forceCollide(r + 0.5).strength(1)); 
</span></pre><p><span class="koboSpan" id="kobo.22.1">The major difference in this recipe is that we keep track of not only the current mouse position, but also the previous mouse position. </span><span class="koboSpan" id="kobo.22.2">Additionally, whenever the user moves the mouse, we generate a node object containing the current location (</span><code class="literal"><span class="koboSpan" id="kobo.23.1">point[0], point[1]</span></code><span class="koboSpan" id="kobo.24.1">) and the previous location (</span><code class="literal"><span class="koboSpan" id="kobo.25.1">previousPoint.x, previousPoint.y</span></code><span class="koboSpan" id="kobo.26.1">):</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">    var previousPoint; 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = { 
                x: point[0], 
                y: point[1], 
                vx: previousPoint? 
                    </span><span class="koboSpan" id="kobo.27.2">point[0]-previousPoint[0]:point[0], 
                vy: previousPoint? 
                    </span><span class="koboSpan" id="kobo.27.3">point[1]-previousPoint[1]:point[1] 
            }; 
 
        previousPoint = point; 
    ... 
</span><span class="koboSpan" id="kobo.27.4">} 
</span></pre><p><span class="koboSpan" id="kobo.28.1">Since user's mouse location is sampled on fixed interval, the faster the user moves the mouse the further apart these two positions will be. </span><span class="koboSpan" id="kobo.28.2">This property and the directional information gained from these two positions are nicely translated automatically by force simulation into initial velocity for each particle we create as we have demonstrated in this recipe.</span></p><p><span class="koboSpan" id="kobo.29.1">Besides the {</span><code class="literal"><span class="koboSpan" id="kobo.30.1">x, y, vx, vy</span></code><span class="koboSpan" id="kobo.31.1">} attributes we have discussed so far, the force layout node object also supports some other useful attributes that we will list here for your reference:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.32.1">index</span></code><span class="koboSpan" id="kobo.33.1">: Zero-based index of the node within the node's array</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.34.1">x</span></code><span class="koboSpan" id="kobo.35.1">: The x-coordinate of the current node position</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.36.1">y</span></code><span class="koboSpan" id="kobo.37.1">: The y-coordinate of the current node position</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.38.1">vx</span></code><span class="koboSpan" id="kobo.39.1">: The node's current x-velocity</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.40.1">vy</span></code><span class="koboSpan" id="kobo.41.1">: The node's current y-velocity</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.42.1">fx</span></code><span class="koboSpan" id="kobo.43.1">: The node's fixed x-position</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.44.1">fy</span></code><span class="koboSpan" id="kobo.45.1">: The node's fixed y-position</span></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note83"/><span class="koboSpan" id="kobo.46.1">Note</span></h3><p><span class="koboSpan" id="kobo.47.1">We will cover </span><code class="literal"><span class="koboSpan" id="kobo.48.1">fx</span></code><span class="koboSpan" id="kobo.49.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.50.1">fy</span></code><span class="koboSpan" id="kobo.51.1"> and their usage in later recipe that involves dragging, which is one of the most common way to leverage fixed positioning of a node.</span></p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec233"/><span class="koboSpan" id="kobo.52.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.53.1">Refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">Interacting with mouse events</span></em></span><span class="koboSpan" id="kobo.55.1"> recipe in </span><a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization"><span class="koboSpan" id="kobo.56.1">Chapter 10</span></a><span class="koboSpan" id="kobo.57.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">Interacting with Your Visualization</span></em></span><span class="koboSpan" id="kobo.59.1">, for more details on how to interact with the mouse in D3.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.60.1">Refer to the D3 Force Simulation Nodes API for more details on node attributes at </span><a class="ulink" href="https://github.com/d3/d3-force#simulation_nodes"><span class="koboSpan" id="kobo.61.1">https://github.com/d3/d3-force#simulation_nodes
</span></a><span class="koboSpan" id="kobo.62.1">.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Setting the link constraint"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec78"/><span class="koboSpan" id="kobo.1.1">Setting the link constraint</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">So far, we have covered some important aspects of the force layout, such as gravity, charge, friction, and velocity. </span><span class="koboSpan" id="kobo.2.2">In this recipe, we will discuss another critical functionality: links. </span><span class="koboSpan" id="kobo.2.3">As we have mentioned in the introduction section, D3 force simulation supports a scalable simple graph constraint, and in this recipe, we will demonstrate how link constraint can be leveraged in conjunction with other forces.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec234"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html
</span></a><span class="koboSpan" id="kobo.6.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec235"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In this recipe, whenever the user clicks on the mouse, we will generate a force-directed ring of particles constrained by links between nodes. </span><span class="koboSpan" id="kobo.8.2">Here is how it is implemented:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, 
            r = 4.5, nodes = [], links = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody() 
                            .strength(-50).distanceMax(h / 4)) 
                    .force("collision",  
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var duration = 10000; 
 
    var svg = d3.select("body") 
            .append("svg") 
                .attr("width", w) 
                .attr("height", h); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
 
        svg.selectAll("line") 
            .attr("x1", function (d) {return boundX(d.source.x);}) 
            .attr("y1", function (d) {return boundY(d.source.y);}) 
            .attr("x2", function (d) {return boundX(d.target.x);}) 
            .attr("y2", function (d) {return boundY(d.target.y);} 
        ); 
    }); 
 
    function boundX(x) { 
        return x &gt; (w - r) ? </span><span class="koboSpan" id="kobo.9.2">(w - r): (x &gt; r ? </span><span class="koboSpan" id="kobo.9.3">x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? </span><span class="koboSpan" id="kobo.9.4">(h - r) : (y &gt; r ? </span><span class="koboSpan" id="kobo.9.5">y : r); 
    } 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function createNodes(point) { 
        var numberOfNodes = Math.round(Math.random() * 10); 
        var newNodes = []; 
 
        for (var i = 0; i &lt; numberOfNodes; ++i) { 
            newNodes.push({ 
                x: point[0] + offset(), 
                y: point[1] + offset() 
            }); 
        } 
 
        newNodes.forEach(function(e){nodes.push(e)}); 
 
        return newNodes; 
    } 
 
    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { // &lt;-A 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
 
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
 
        newLinks.forEach(function (link) { 
            svg.append("line") // &lt;-B 
                    .data([link]) 
                .attr("class", "line") 
                .attr("x1", function (d) {return d.source.x;}) 
                .attr("y1", function (d) {return d.source.y;}) 
                .attr("x2", function (d) {return d.target.x;}) 
                .attr("y2", function (d) {return d.target.y;}) 
                    .transition() 
                    .delay(duration) 
                .style("stroke-opacity", 1e-6) 
                .on("end", function () {links.shift();}) 
                .remove(); 
        }); 
 
        force.nodes(nodes); 
        force.force("link",  
                         d3.forceLink(links) 
                            .strength(1).distance(20)); // &lt;-C 
        force.restart(); 
    }); 
 
    function dragStarted(d) { 
        d.fx = d.x; // &lt;-E 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; // &lt;-F 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; // &lt;-G 
        d.fy = null; 
    } 
&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This recipe generates force-directed particle rings on a mouse click, as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_11_008.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Force-directed particle rings</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec236"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">Link constraint adds another useful dimension to force-assisted visualization. </span><span class="koboSpan" id="kobo.14.2">In this recipe, we set up our force layout with the following parameters:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.15.1">var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge", d3.forceManyBody() 
                             .strength(-50).distanceMax(h / 4)) 
                    .force("collision",   
                            d3.forceCollide(r + 0.5).strength(1)); 
</span></pre><p><span class="koboSpan" id="kobo.16.1">Besides collision, charge, and friction, this time we also bound charge-force interaction to 25% of the maximum height to simulate a more localized force interaction. </span><span class="koboSpan" id="kobo.16.2">When the user clicks on their mouse, a random number of nodes are being created and put under force simulation's control similar to what we have done in the previous recipes. </span><span class="koboSpan" id="kobo.16.3">The major addition in this recipe is the link creation, and its control logic is shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.17.1">    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { // &lt;-A 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
    
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
 
        newLinks.forEach(function (link) { 
            svg.append("line") // &lt;-B 
                    .data([link]) 
                .attr("class", "line") 
                .attr("x1", function (d) {return d.source.x;}) 
                .attr("y1", function (d) {return d.source.y;}) 
                .attr("x2", function (d) {return d.target.x;}) 
                .attr("y2", function (d) {return d.target.y;}) 
                    .transition() 
                    .delay(duration) 
                .style("stroke-opacity", 1e-6) 
                .on("end", function () {links.shift();}) 
                .remove(); 
        }); 
 
        force.nodes(nodes); 
        force.force("link", 
                        d3.forceLink(links) 
                           .strength(1).distance(20)); // &lt;-C 
        force.restart(); 
    }); 
</span></pre><p><span class="koboSpan" id="kobo.18.1">In the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">createLinks</span></code><span class="koboSpan" id="kobo.20.1"> function, the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">n-1</span></code><span class="koboSpan" id="kobo.22.1"> link objects were created connecting a set of nodes into a ring (for loop on line </span><code class="literal"><span class="koboSpan" id="kobo.23.1">A</span></code><span class="koboSpan" id="kobo.24.1">). </span><span class="koboSpan" id="kobo.24.2">Each link object must have two attributes specified as </span><code class="literal"><span class="koboSpan" id="kobo.25.1">source</span></code><span class="koboSpan" id="kobo.26.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.27.1">target</span></code><span class="koboSpan" id="kobo.28.1">, telling force layout which pair of nodes are connected by this link object. </span><span class="koboSpan" id="kobo.28.2">Once this is created, we decided to visualize the links in this recipe using a </span><code class="literal"><span class="koboSpan" id="kobo.29.1">svg:line</span></code><span class="koboSpan" id="kobo.30.1"> element (refer to line </span><code class="literal"><span class="koboSpan" id="kobo.31.1">B</span></code><span class="koboSpan" id="kobo.32.1">). </span><span class="koboSpan" id="kobo.32.2">However, we will see in the next recipe that this does not have to always be the case. </span><span class="koboSpan" id="kobo.32.3">As a matter of fact, you can use pretty much anything; you can imagine to visualize (including hiding them, but retain the links for layout computation) the links as long as it makes sense for the audience of your visualization. </span><span class="koboSpan" id="kobo.32.4">After that, we also need to add link objects to force layout's links array (on line </span><code class="literal"><span class="koboSpan" id="kobo.33.1">C</span></code><span class="koboSpan" id="kobo.34.1">) so that they can be put under force layout's control. </span><span class="koboSpan" id="kobo.34.2">The </span><code class="literal"><span class="koboSpan" id="kobo.35.1">d3.forceLink</span></code><span class="koboSpan" id="kobo.36.1"> function has two important parameters: link distance and link strength; both parameters are exclusively link related:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.37.1">linkDistance</span></code><span class="koboSpan" id="kobo.38.1">: This could be a constant or a function, which defaults to </span><code class="literal"><span class="koboSpan" id="kobo.39.1">20</span></code><span class="koboSpan" id="kobo.40.1"> pixels. </span><span class="koboSpan" id="kobo.40.2">Link distances are evaluated when the simulation is initialized, and it is implemented as weak geometric constraints. </span><span class="koboSpan" id="kobo.40.3">For each tick of the layout, the distance between each pair of linked nodes is computed and compared to the target distance. </span><span class="koboSpan" id="kobo.40.4">The links are then moved toward each other or away from each other.</span></li><li class="listitem" style="list-style-type: disc"><code class="literal"><span class="koboSpan" id="kobo.41.1">linkStength</span></code><span class="koboSpan" id="kobo.42.1">: This could be a constant or a function, which defaults to </span><code class="literal"><span class="koboSpan" id="kobo.43.1">1</span></code><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">Link strength sets the strength (rigidity) of links with a value in the range of </span><code class="literal"><span class="koboSpan" id="kobo.45.1">[0, 1]</span></code><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Link strength is also evaluated on initialization or reset.</span></li></ul></div><p><span class="koboSpan" id="kobo.47.1">Finally, we will need to translate the positioning data generated by force layout to SVG implementation in the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">tick</span></code><span class="koboSpan" id="kobo.49.1"> function for each link similar to what we did for the nodes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.50.1">    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
 
        svg.selectAll("line") 
            .attr("x1", function (d) {return boundX(d.source.x);}) 
            .attr("y1", function (d) {return boundY(d.source.y);}) 
            .attr("x2", function (d) {return boundX(d.target.x);}) 
            .attr("y2", function (d) {return boundY(d.target.y);}); 
    }); 
     
    function boundX(x) { 
        return x &gt; (w - r) ? </span><span class="koboSpan" id="kobo.50.2">(w - r): (x &gt; r ? </span><span class="koboSpan" id="kobo.50.3">x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? </span><span class="koboSpan" id="kobo.50.4">(h - r) : (y &gt; r ? </span><span class="koboSpan" id="kobo.50.5">y : r); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.51.1">As we can see here, the D3 force simulation has again done most of the heavy lifting, therefore, all we need to do is simply set </span><code class="literal"><span class="koboSpan" id="kobo.52.1">{x1, y1}</span></code><span class="koboSpan" id="kobo.53.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.54.1">{x2, y2}</span></code><span class="koboSpan" id="kobo.55.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">svg:line</span></code><span class="koboSpan" id="kobo.57.1"> elements in the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">tick</span></code><span class="koboSpan" id="kobo.59.1"> function. </span><span class="koboSpan" id="kobo.59.2">Additionally, we have also used two bounded X and Y function to make sure that the particles and rings will not escape our SVG canvas area. </span><span class="koboSpan" id="kobo.59.3">For reference, the following screenshot is what a link object looks like after it is manipulated by force layout:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.60.1"><img src="graphics/image_11_009.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.61.1">Link object</span></p><p><span class="koboSpan" id="kobo.62.1">One last additional technique worth mentioning in this recipe is the force-enabled dragging. </span><span class="koboSpan" id="kobo.62.2">All nodes generated by this recipe are "drag gable," and force simulation automatically re-computes all forces and constraints, as the user drags the rings around, as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.63.1"><img src="graphics/image_11_010.jpg" alt="How it works..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.64.1">Dragging, with force simulation</span></p><p><span class="koboSpan" id="kobo.65.1">This is accomplished by registering the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">d3.drag</span></code><span class="koboSpan" id="kobo.67.1"> event handler as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.68.1">D</span></code><span class="koboSpan" id="kobo.69.1"> in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.70.1">       newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
</span></pre><p><span class="koboSpan" id="kobo.71.1">The implementation of each of the drag event handler is pretty straightforward:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.72.1">    function dragStarted(d) { 
        d.fx = d.x; // &lt;-E 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; // &lt;-F 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; // &lt;-G 
        d.fy = null; 
    } 
</span></pre><p><span class="koboSpan" id="kobo.73.1">When dragging happens on a particular node, we use </span><code class="literal"><span class="koboSpan" id="kobo.74.1">fx</span></code><span class="koboSpan" id="kobo.75.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.76.1">fy</span></code><span class="koboSpan" id="kobo.77.1"> to fix that particular node to its initial position as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.78.1">E</span></code><span class="koboSpan" id="kobo.79.1">. </span><span class="koboSpan" id="kobo.79.2">While the dragging is happening, we continue to update the node's position with the user's mouse position, thus, moving the node while being dragged (refer to line </span><code class="literal"><span class="koboSpan" id="kobo.80.1">F</span></code><span class="koboSpan" id="kobo.81.1">). </span><span class="koboSpan" id="kobo.81.2">Finally, when drag ends, we unfix the node position, thus, allowing force simulation to take control once again, as shown on line </span><code class="literal"><span class="koboSpan" id="kobo.82.1">G</span></code><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">This is a very general drag support pattern you will see quite often with force-assisted visualization, including some later recipes in this chapter.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec237"/><span class="koboSpan" id="kobo.84.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.85.1">Scalable, versatile, and simple constrained graph layout: </span><a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf"><span class="koboSpan" id="kobo.86.1">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf
</span></a></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.87.1">For more information about force.links() function please refer to: </span><a class="ulink" href="https://github.com/d3/d3-force#links"><span class="koboSpan" id="kobo.88.1">https://github.com/d3/d3-force#links
</span></a></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Using force to assist visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec79"/><span class="koboSpan" id="kobo.1.1">Using force to assist visualization</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">So far, we learned to use force simulation visualizing particles and links similar to how you would use force in its classic application, the forced-directed graph. </span><span class="koboSpan" id="kobo.2.2">This kind of visualization is what force simulation was designed for in the first place. </span><span class="koboSpan" id="kobo.2.3">However, this is by no means the only way to utilize force in your visualization. </span><span class="koboSpan" id="kobo.2.4">In this recipe, we will explore techniques that I call force-assisted visualization. </span><span class="koboSpan" id="kobo.2.5">With this technique, you can add some randomness and arbitrariness into your visualization by leveraging force.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec238"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html
</span></a><span class="koboSpan" id="kobo.6.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec239"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In this recipe, we will generate bubbles on the user's mouse click. </span><span class="koboSpan" id="kobo.8.2">The bubbles are made of </span><code class="literal"><span class="koboSpan" id="kobo.9.1">svg:path</span></code><span class="koboSpan" id="kobo.10.1"> elements filled with gradient color. </span><span class="koboSpan" id="kobo.10.2">The </span><code class="literal"><span class="koboSpan" id="kobo.11.1">svg:path</span></code><span class="koboSpan" id="kobo.12.1"> elements are not strictly controlled by force layout though they are influenced by force, therefore, giving them the randomness required to simulate a bubble in real life:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">&lt;svg&gt; 
    &lt;defs&gt; 
        &lt;radialGradient id="gradient" cx="50%" cy="50%"  
                                r="100%" fx="50%" fy="50%"&gt; 
            &lt;stop offset="0%" 
              style="stop-color:blue;stop-opacity:0"/&gt; 
            &lt;stop offset="100%" 
              style="stop-color:rgb(255,255,255);stop-opacity:1"/&gt; 
        &lt;/radialGradient&gt; 
    &lt;/defs&gt; 
&lt;/svg&gt; 
 
&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, 
                r = 4.5, nodes = [], links = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge", d3.forceManyBody() 
                              .strength(-50).distanceMax(h / 4)) 
                    .force("collision",  
                              d3.forceCollide(r + 0.5).strength(1)) 
                    .force("position", d3.forceY(h / 2)); 
 
    var duration = 60000; 
 
    var svg = d3.select("svg") 
                .attr("width", w) 
                .attr("height", h); 
 
 
    var line = d3.line() // &lt;-A 
            .curve(d3.curveBasisClosed) 
            .x(function(d){return d.x;}) 
            .y(function(d){return d.y;}); 
 
    force.on("tick", function () { 
        svg.selectAll("path") 
            .attr("d", line); 
    }); 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function createNodes(point) { 
        var numberOfNodes = Math.round(Math.random() * 10); 
        var newNodes = []; 
 
        for (var i = 0; i &lt; numberOfNodes; ++i) { 
            newNodes.push({ 
                x: point[0] + offset(), 
                y: point[1] + offset() 
            }); 
        } 
 
        newNodes.forEach(function(e){nodes.push(e)}); 
 
        return newNodes; 
    } 
 
    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
 
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        console.log(point); 
 
        svg.append("path") 
                .data([newNodes]) 
            .attr("class", "bubble") 
            .attr("fill", "url(#gradient)") // &lt;-B 
            .attr("d", function(d){return line(d);}) 
                .transition().delay(duration) // &lt;-C 
            .attr("fill-opacity", 0) 
            .attr("stroke-opacity", 0) 
            .on("end", function(){d3.select(this).remove();}); 
 
        force.nodes(nodes); 
        force.force("link",  
                   d3.forceLink(links).strength(1).distance(20)); 
        force.restart(); 
    }); 
&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.14.1">This recipe generates force-assisted bubbles on the user's mouse click as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.15.1"><img src="graphics/image_11_011.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.16.1">Force assisted bubbles</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec240"/><span class="koboSpan" id="kobo.17.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.18.1">This recipe is built on top of what we have done in the previous recipe, therefore, its overall approach is quite similar to the last recipe in which we created force-controlled particle rings on the user's mouse click. </span><span class="koboSpan" id="kobo.18.2">The major difference between this recipe and the last one is in this one we decided to use the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">d3.line</span></code><span class="koboSpan" id="kobo.20.1"> generator to create the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">svg:path</span></code><span class="koboSpan" id="kobo.22.1"> element that outlines our bubbles instead of using </span><code class="literal"><span class="koboSpan" id="kobo.23.1">svg:circle</span></code><span class="koboSpan" id="kobo.24.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.25.1">svg:line</span></code><span class="koboSpan" id="kobo.26.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.27.1">var line = d3.line() // &lt;-A 
            .curve(d3.curveBasisClosed) 
            .x(function(d){return d.x;}) 
            .y(function(d){return d.y;}); 
... 
</span><span class="koboSpan" id="kobo.27.2">svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        console.log(point); 
 
        svg.append("path") 
                .data([newNodes]) 
            .attr("class", "bubble") 
            .attr("fill", "url(#gradient)") // &lt;-B 
            .attr("d", function(d){return line(d);}) // &lt;-C 
                .transition().delay(duration) 
            .attr("fill-opacity", 0) 
            .attr("stroke-opacity", 0) 
            .on("end", function(){d3.select(this).remove();}); 
 
        force.nodes(nodes); 
        force.force("link",  
                d3.forceLink(links).strength(1).distance(20)); 
        force.restart(); 
    }); 
</span></pre><p><span class="koboSpan" id="kobo.28.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.29.1">A</span></code><span class="koboSpan" id="kobo.30.1">, we created a line generator with a </span><code class="literal"><span class="koboSpan" id="kobo.31.1">d3.curveBasisClosed</span></code><span class="koboSpan" id="kobo.32.1"> curve mode since this gives us the smoothest outline for our bubble. </span><span class="koboSpan" id="kobo.32.2">Whenever a user clicks on the mouse, a </span><code class="literal"><span class="koboSpan" id="kobo.33.1">svg:path</span></code><span class="koboSpan" id="kobo.34.1"> element was created connecting all nodes (line </span><code class="literal"><span class="koboSpan" id="kobo.35.1">C</span></code><span class="koboSpan" id="kobo.36.1">). </span><span class="koboSpan" id="kobo.36.2">Additionally, we also fill the bubble with our predefined gradient to give it a nice glow (line </span><code class="literal"><span class="koboSpan" id="kobo.37.1">B</span></code><span class="koboSpan" id="kobo.38.1">). </span><span class="koboSpan" id="kobo.38.2">Finally, we also need to implement the force-based positioning in the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">tick</span></code><span class="koboSpan" id="kobo.40.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">    force.on("tick", function () { 
        svg.selectAll("path") 
            .attr("d", line); 
    }); 
</span></pre><p><span class="koboSpan" id="kobo.42.1">In the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">tick</span></code><span class="koboSpan" id="kobo.44.1"> function, we simply re-invoke the line generator function to update the </span><code class="literal"><span class="koboSpan" id="kobo.45.1">d</span></code><span class="koboSpan" id="kobo.46.1"> attribute for each path, thus, animating the bubbles using force layout computation.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec241"/><span class="koboSpan" id="kobo.47.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.48.1">Refer to SVG Gradients and Patterns at </span><a class="ulink" href="https://www.w3.org/TR/SVG/pservers.html"><span class="koboSpan" id="kobo.49.1">https://www.w3.org/TR/SVG/pservers.html
</span></a><span class="koboSpan" id="kobo.50.1">.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.51.1">Refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.52.1">Using line generator</span></em></span><span class="koboSpan" id="kobo.53.1"> recipe in </span><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape"><span class="koboSpan" id="kobo.54.1">Chapter 7</span></a><span class="koboSpan" id="kobo.55.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.56.1">Getting into Shape</span></em></span><span class="koboSpan" id="kobo.57.1">, for more information on D3 line generator.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Manipulating force"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec80"/><span class="koboSpan" id="kobo.1.1">Manipulating force</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">So far, we have explored many interesting aspects and applications of D3 force; however, in all of these prior recipes, we simply applied force layout's computation (gravity, charge, friction, collision, and velocity) directly to our visualization. </span><span class="koboSpan" id="kobo.2.2">In this recipe, we will go one step further to implement custom force manipulation, hence creating our own type of force.</span></p><p><span class="koboSpan" id="kobo.3.1">In this recipe, we will first generate five sets of colored particles then assign corresponding colors and categorical force pull to user's touch, hence pulling only the particles that match the color. </span><span class="koboSpan" id="kobo.3.2">Since this recipe is a bit complex, I will give an example here: if I touch the visualization with my first finger, it will generate a blue circle and pull all blue particles to that circle, whereas my second touch will generate an orange circle and will only pull the orange particles. </span><span class="koboSpan" id="kobo.3.3">This type of force manipulation is commonly referred to as categorical multi-foci.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec242"/><span class="koboSpan" id="kobo.4.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.5.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html"><span class="koboSpan" id="kobo.6.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html
</span></a><span class="koboSpan" id="kobo.7.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec243"/><span class="koboSpan" id="kobo.8.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.9.1">Here is how you can achieve this in code:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.10.1">&lt;script type="text/javascript"&gt; 
    var svg = d3.select("body").append("svg"), 
            colors = d3.scaleOrdinal(d3.schemeCategory20c), 
            r = 4.5, 
            w = 1290, 
            h = 800; 
 
    svg.attr("width", w).attr("height", h); 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody().strength(-30)) 
                    .force("x", d3.forceX(w / 2)) 
                    .force("y", d3.forceY(h / 2)) 
                    .force("collision",   
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var nodes = [], centers = []; 
 
    for (var i = 0; i &lt; 5; ++i) { 
        for (var j = 0; j &lt; 50; ++j) { 
            nodes.push({ 
                x: w / 2 + offset(), 
                y: h / 2 + offset(), 
                color: colors(i), // &lt;-A 
                type: i // &lt;-B 
            }); 
        } 
    } 
 
    force.nodes(nodes); 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function boundX(x) { 
        return x &gt; (w - r) ? </span><span class="koboSpan" id="kobo.10.2">(w - r): (x &gt; r ? </span><span class="koboSpan" id="kobo.10.3">x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? </span><span class="koboSpan" id="kobo.10.4">(h - r) : (y &gt; r ? </span><span class="koboSpan" id="kobo.10.5">y : r); 
    } 
 
    svg.selectAll("circle") 
                .data(nodes).enter() 
            .append("circle") 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("fill", function(d){return d.color;}) 
            .attr("r", 1e-6) 
                .transition() 
            .attr("r", r); 
 
    force.on("tick", function() { 
        var k = 0.1; 
        nodes.forEach(function(node) { 
            var center = centers[node.type]; 
            if(center){ 
                node.x += (center[0] - node.x) * k; 
                node.y += (center[1] - node.y) * k; 
            } 
        }); 
 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
    }); 
 
    d3.select("body") 
        .on("touchstart", touch) 
        .on("touchend", touch); 
 
    function touch() { 
        d3.event.preventDefault(); 
 
        centers = d3.touches(svg.node()); 
 
        console.log(centers); 
 
        var g = svg.selectAll("g.touch") 
                .data(centers, function (d) { 
                    return d.identifier; 
                }); 
 
        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("circle") 
                .attr("class", "touch") 
                .attr("fill",  
                        function(d){return colors(d.identifier);}) 
                    .transition() 
                .attr("r", 50); 
 
        g.exit().remove(); 
    } 
&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.11.1">This recipe generates multi-categorical foci on touch, as shown in the following screenshot:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.12.1"><img src="graphics/image_11_012.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.13.1">Multi-categorical foci on touch</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec244"/><span class="koboSpan" id="kobo.14.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.15.1">The first step of this recipe is to create colored particles and standard force equilibrium between positioning and repulsion. </span><span class="koboSpan" id="kobo.15.2">All node objects contain separate color and type ID attributes (line </span><code class="literal"><span class="koboSpan" id="kobo.16.1">A</span></code><span class="koboSpan" id="kobo.17.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.18.1">B</span></code><span class="koboSpan" id="kobo.19.1">), so they can be easily identified later. </span><span class="koboSpan" id="kobo.19.2">On line </span><code class="literal"><span class="koboSpan" id="kobo.20.1">C</span></code><span class="koboSpan" id="kobo.21.1">, we let force simulation manage all the positioning of these particles as we have done in previous recipes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.22.1">var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody().strength(-30)) 
                    .force("x", d3.forceX(w / 2)) 
                    .force("y", d3.forceY(h / 2)) 
                    .force("collision",  
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var nodes = [], centers = []; 
 
    for (var i = 0; i &lt; 5; ++i) { 
        for (var j = 0; j &lt; 50; ++j) { 
            nodes.push({ 
                x: w / 2 + offset(), 
                y: h / 2 + offset(), 
                color: colors(i), // &lt;-A 
                type: i // &lt;-B 
            }); 
        } 
} 
 
    force.nodes(nodes); // &lt;-C 
</span></pre><p><span class="koboSpan" id="kobo.23.1">Next, we will need to create a large </span><code class="literal"><span class="koboSpan" id="kobo.24.1">svg:circle</span></code><span class="koboSpan" id="kobo.25.1"> element on user touch to represent the touch point:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">function touch() { 
        d3.event.preventDefault(); 
 
        centers = d3.touches(svg.node()); 
 
        var g = svg.selectAll("g.touch") 
                .data(centers, function (d) { 
                    return d.identifier; 
                }); 
 
        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("circle") 
                .attr("class", "touch") 
                .attr("fill",  
                    function(d){return colors(d.identifier);}) 
                    .transition() 
                .attr("r", 50); 
 
        g.exit().remove(); 
    } 
</span></pre><p><span class="koboSpan" id="kobo.27.1">This is the pretty standard multi-touch drawing that we saw in </span><span class="emphasis"><em><span class="koboSpan" id="kobo.28.1">Interacting with a multi-touch device</span></em></span><span class="koboSpan" id="kobo.29.1"> recipe in </span><a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization"><span class="koboSpan" id="kobo.30.1">Chapter 10</span></a><span class="koboSpan" id="kobo.31.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.32.1">Interacting with Your Visualization</span></em></span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">Once the touch point is identified, all the custom force magic are implemented in the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">tick</span></code><span class="koboSpan" id="kobo.35.1"> function. </span><span class="koboSpan" id="kobo.35.2">Now, let's take a look at the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">tick</span></code><span class="koboSpan" id="kobo.37.1"> function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">    force.on("tick", function() { 
        var k = 0.1; 
        nodes.forEach(function(node) { 
            var center = centers[node.type]; // &lt;-C 
            if(center){ 
                node.x += (center[0] - node.x) * k; // &lt;-D 
                node.y += (center[1] - node.y) * k; // &lt;-E 
            } 
        }); 
 
        svg.selectAll("circle") // &lt;-F 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
    }); 
</span></pre><p><span class="koboSpan" id="kobo.39.1">In this tick function, we have the familiar part, on line </span><code class="literal"><span class="koboSpan" id="kobo.40.1">F</span></code><span class="koboSpan" id="kobo.41.1">, where we let force simulation to control the position of all particles on the canvas; however, we have also introduced a custom force. </span><span class="koboSpan" id="kobo.41.2">On line </span><code class="literal"><span class="koboSpan" id="kobo.42.1">C</span></code><span class="koboSpan" id="kobo.43.1">, we looped through all nodes to identify the nodes associated with a given center that represents user's touch. </span><span class="koboSpan" id="kobo.43.2">Once we detect the touch center, we started to move the particle closer to the center one tick at a time (line </span><code class="literal"><span class="koboSpan" id="kobo.44.1">D</span></code><span class="koboSpan" id="kobo.45.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.46.1">E</span></code><span class="koboSpan" id="kobo.47.1">) using the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">k</span></code><span class="koboSpan" id="kobo.49.1"> coefficient. </span><span class="koboSpan" id="kobo.49.2">The larger the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">k</span></code><span class="koboSpan" id="kobo.51.1"> the faster the particles will converge around a touch point.</span></p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec245"/><span class="koboSpan" id="kobo.52.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.53.1">Refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">Interacting with a multi-touch device</span></em></span><span class="koboSpan" id="kobo.55.1"> recipe in </span><a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization"><span class="koboSpan" id="kobo.56.1">Chapter 10</span></a><span class="koboSpan" id="kobo.57.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">Interacting with your Visualization</span></em></span><span class="koboSpan" id="kobo.59.1">, for more information on D3 multi-touch support.</span></li></ul></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Building a force-directed graph"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec81"/><span class="koboSpan" id="kobo.1.1">Building a force-directed graph</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Finally, we will show how to implement a force-directed graph, the classic application of D3 force. </span><span class="koboSpan" id="kobo.2.2">However, we believe with all the techniques and knowledge you have gained so far from this chapter, implementing force-directed graph should feel quite straightforward.</span></p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec246"/><span class="koboSpan" id="kobo.3.1">Getting ready</span></h2></div></div></div><p><span class="koboSpan" id="kobo.4.1">Open your local copy of the following file in your web browser:</span></p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html"><span class="koboSpan" id="kobo.5.1">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html
</span></a><span class="koboSpan" id="kobo.6.1">.
</span></p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec247"/><span class="koboSpan" id="kobo.7.1">How to do it...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.8.1">In this recipe, we will visualize the flare dataset as a force-directed tree (tree is a special type of graph):</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.9.1">&lt;script type="text/javascript"&gt; 
    var w = 1280, 
            h = 800, 
            r = 4.5, 
            colors = d3.scaleOrdinal(d3.schemeCategory20c); 
 
    var force = d3.forceSimulation() 
            .velocityDecay(0.8) 
            .alphaDecay(0) 
            .force("charge", d3.forceManyBody()) 
            .force("x", d3.forceX(w / 2)) 
            .force("y", d3.forceY(h / 2)); 
 
    var svg = d3.select("body").append("svg") 
            .attr("width", w) 
            .attr("height", h); 
 
    d3.json("../../data/flare.json", function (data) { 
        var root = d3.hierarchy(data); 
        var nodes = root.descendants(); 
        var links = root.links(); 
 
        force.nodes(nodes); 
        force.force("link",  
            d3.forceLink(links).strength(1).distance(20)); 
 
          var link = svg.selectAll("line") 
              .data(links) 
            .enter().insert("line") 
              .style("stroke", "#999") 
              .style("stroke-width", "1px"); 
 
          var nodeElements = svg.selectAll("circle.node") 
              .data(nodes) 
            .enter().append("circle") 
              .attr("r", r) 
              .style("fill", function(d) {  
                    return colors(d.parent &amp;&amp; d.parent.data.name);  
              }) 
              .style("stroke", "#000") 
              .call(d3.drag() 
                      .on("start", dragStarted) 
                      .on("drag", dragged) 
                      .on("end", dragEnded)); 
 
          force.on("tick", function(e) { 
            link.attr("x1", function(d) { return d.source.x; }) 
                .attr("y1", function(d) { return d.source.y; }) 
                .attr("x2", function(d) { return d.target.x; }) 
                .attr("y2", function(d) { return d.target.y; }); 
 
            nodeElements.attr("cx", function(d) { return d.x; }) 
                .attr("cy", function(d) { return d.y; }); 
          }); 
    }); 
 
    function dragStarted(d) { 
        d.fx = d.x; 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; 
        d.fy = null; 
    } 
&lt;/script&gt; 
</span></pre><p><span class="koboSpan" id="kobo.10.1">This recipe visualizes the hierarchical flare dataset as a force-directed tree:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.11.1"><img src="graphics/image_11_013.jpg" alt="How to do it..."/></span></div><p>
</p><p><span class="koboSpan" id="kobo.12.1">Force-directed graph (tree)</span></p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec248"/><span class="koboSpan" id="kobo.13.1">How it works...</span></h2></div></div></div><p><span class="koboSpan" id="kobo.14.1">As we can already see, this recipe is pretty short, and a quarter of the code was actually devoted to drag support. </span><span class="koboSpan" id="kobo.14.2">This is due to the fact that force-directed graph is what force simulation was designed for in the first place. </span><span class="koboSpan" id="kobo.14.3">Thus, there is really not much to do other than simply applying the force with correct data structure. </span><span class="koboSpan" id="kobo.14.4">First, we process the hierarchical dataset using the standard </span><code class="literal"><span class="koboSpan" id="kobo.15.1">d3.hierarchy</span></code><span class="koboSpan" id="kobo.16.1"> (line </span><code class="literal"><span class="koboSpan" id="kobo.17.1">A</span></code><span class="koboSpan" id="kobo.18.1">) since this is how we can retrieve the nodes and links data structure </span><code class="literal"><span class="koboSpan" id="kobo.19.1">d3.force</span></code><span class="koboSpan" id="kobo.20.1"> expects:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.21.1">d3.json("../../data/flare.json", function (data) { 
        var root = d3.hierarchy(data); // &lt;-A 
        var nodes = root.descendants(); // &lt;-B 
        var links = root.links(); // &lt;-C 
         
        force.nodes(nodes); // &lt;-D 
        force.force("link", // &lt;-E 
                d3.forceLink(links).strength(1).distance(20)); 
        ... 
</span><span class="koboSpan" id="kobo.21.2">} 
</span></pre><p><span class="koboSpan" id="kobo.22.1">On line </span><code class="literal"><span class="koboSpan" id="kobo.23.1">B</span></code><span class="koboSpan" id="kobo.24.1">, we leverage the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">d3.hierarchy.descendants</span></code><span class="koboSpan" id="kobo.26.1"> function to retrieve all nodes contained in the tree and the links among nodes on line </span><code class="literal"><span class="koboSpan" id="kobo.27.1">C</span></code><span class="koboSpan" id="kobo.28.1"> using the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">d3.hierachy.links</span></code><span class="koboSpan" id="kobo.30.1"> function. </span><span class="koboSpan" id="kobo.30.2">These are the data structure </span><code class="literal"><span class="koboSpan" id="kobo.31.1">d3.force</span></code><span class="koboSpan" id="kobo.32.1"> expects; once we have them, they can be directly passed to simulation on line </span><code class="literal"><span class="koboSpan" id="kobo.33.1">D</span></code><span class="koboSpan" id="kobo.34.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.35.1">E</span></code><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">The rest of the recipe is very similar to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.37.1">Setting the link constraint </span></em></span><span class="koboSpan" id="kobo.38.1">recipe in this chapter. </span><span class="koboSpan" id="kobo.38.2">We created the </span><code class="literal"><span class="koboSpan" id="kobo.39.1">svg:link</span></code><span class="koboSpan" id="kobo.40.1"> element to represent links and </span><code class="literal"><span class="koboSpan" id="kobo.41.1">svg:circle</span></code><span class="koboSpan" id="kobo.42.1"> elements to represent the nodes in the graph:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.43.1">          var link = svg.selectAll("line") 
              .data(links) 
            .enter().insert("line") 
              .style("stroke", "#999") 
              .style("stroke-width", "1px"); 
 
          var nodeElements = svg.selectAll("circle.node") 
              .data(nodes) 
            .enter().append("circle") 
              .attr("r", r) 
              .style("fill", function(d) { // &lt;-F 
                  return colors(d.parent &amp;&amp; d.parent.data.name); 
              }) 
              .style("stroke", "#000") 
              .call(d3.drag() // &lt;-G 
                      .on("start", dragStarted) 
                      .on("drag", dragged) 
                      .on("end", dragEnded)); 
</span></pre><p><span class="koboSpan" id="kobo.44.1">The only parts worth mentioning here is that we colored the node using its parent's name on line </span><code class="literal"><span class="koboSpan" id="kobo.45.1">F</span></code><span class="koboSpan" id="kobo.46.1">, so all siblings will be colored consistently, and on line </span><code class="literal"><span class="koboSpan" id="kobo.47.1">G</span></code><span class="koboSpan" id="kobo.48.1">, we used the common drag support pattern mentioned in the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.49.1">Setting the link constraint </span></em></span><span class="koboSpan" id="kobo.50.1">recipe to allow dragging with this graph. </span><span class="koboSpan" id="kobo.50.2">Finally, we let force simulation to control both nodes and links positioning completely in the tick function:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.51.1">          force.on("tick", function(e) { 
            link.attr("x1", function(d) { return d.source.x; }) 
                .attr("y1", function(d) { return d.source.y; }) 
                .attr("x2", function(d) { return d.target.x; }) 
                .attr("y2", function(d) { return d.target.y; }); 
 
            nodeElements.attr("cx", function(d) { return d.x; }) 
                .attr("cy", function(d) { return d.y; }); 
          }); 
</span></pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec249"/><span class="koboSpan" id="kobo.52.1">See also</span></h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.53.1">Refer to the </span><span class="emphasis"><em><span class="koboSpan" id="kobo.54.1">Building a tree</span></em></span><span class="koboSpan" id="kobo.55.1"> recipe in </span><a class="link" href="ch09.html" title="Chapter 9. Lay Them Out"><span class="koboSpan" id="kobo.56.1">Chapter 9</span></a><span class="koboSpan" id="kobo.57.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.58.1">Lay Them Out</span></em></span><span class="koboSpan" id="kobo.59.1">, for more information on D3 tree layout.</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.60.1">For more information on force-directed graphs, visit </span><a class="ulink" href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing"><span class="koboSpan" id="kobo.61.1">https://en.wikipedia.org/wiki/Force-directed_graph_drawing
</span></a><span class="koboSpan" id="kobo.62.1">.</span></li></ul></div></div></div></div></div></body></html>