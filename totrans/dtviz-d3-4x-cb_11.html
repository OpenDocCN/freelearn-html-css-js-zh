<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Using Force</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using gravity and charge</li><li class="listitem" style="list-style-type: disc">Customizing velocity</li><li class="listitem" style="list-style-type: disc">Setting the link constraint</li><li class="listitem" style="list-style-type: disc">Using force to assist visualization</li><li class="listitem" style="list-style-type: disc">Manipulating force</li><li class="listitem" style="list-style-type: disc">Building a force-directed graph</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec75"/>Introduction</h1></div></div></div><div><blockquote class="blockquote"><p>
<em>Use the force, Luke!</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>A master's words of wisdom to his apprentice</em>
</p></blockquote></div><p>In this chapter, we will cover one of the most fascinating aspects of D3: force. Force simulation is one of the most awe-inspiring techniques that you can add to your visualization. Through a number of highly interactive and fully functional examples, we will help you explore not only the typical application of D3 force (for example, the force-directed graph), but also other essential aspects of force manipulation.</p><p>D3 force simulation support was created not as a separate capability, but rather as a kind of additional D3 layout. As we mentioned in <a class="link" href="ch09.html" title="Chapter 9. Lay Them Out">Chapter 9</a>, <em>Lay Them Out</em>, D3 layouts are nonvisual data-oriented layout management programs designed to be used with different visualization. Force simulation was originally created for the purpose of implementing a specific type of visualization called <strong>force-directed graph</strong>. Its implementation uses standard <strong>velocity</strong>
<strong>verlet integration</strong> simulating physical forces on particles.</p><p>In other words, D3 implements a numeric method that is capable of loosely simulating the motion of particles using its velocity with stepped temporal functions. This kind of simulation, of course, was ideal in implementing particular visualization, such as a force-directed graph; however, you will also discover through recipes in this chapter that force simulation is capable of generating many other interesting visualization effects, thanks to its flexibility in custom force manipulation. The application of such techniques introduced in this chapter goes even beyond the data visualization realm and has practical applications in many other domains, for example, user interface design. Of course, in this chapter, we will also cover the classical application of force: the force-directed graph.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec76"/>Using gravity and charge</h1></div></div></div><p>In this recipe, we will introduce you to the first two fundamental forces: gravity and charge. As we have mentioned before, one objective of force layout's design is to loosely simulate the motion of particles, and one major feature of this simulation is the force of charge. Additionally, force simulation also implements pseudo gravity, or more accurately, a weak geometric constraint typically centered on the canvas that can be leveraged to keep your visualization from escaping the canvas. In the following example, you will learn how these two fundamental, sometimes opposing, forces can be leveraged to generate various effects with a particle system.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec226"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/gravity-and-charge.html
</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec227"/>How to do it...</h2></div></div></div><p>In the following example, we will experiment with the force simulating gravity and charge settings so you can better understand different opposing forces involved and their interaction:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, r = 4.5, 
        nodes = [], 
        force = d3.forceSimulation() 
                .velocityDecay(0.8) 
                .alphaDecay(0) 
                .force("collision",  
                   d3.forceCollide(r + 0.5).strength(1)); 
 
    var svg = d3.select("body") 
        .append("svg") 
            .attr("width", w) 
            .attr("height", h); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}); 
    }); 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = {x: point[0], y: point[1]}; // &lt;-A 
 
        svg.append("circle") 
                .data([node]) 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("r", 1e-6) 
        .transition() 
            .attr("r", r) 
        .transition() 
            .delay(7000) 
            .attr("r", 1e-6) 
            .on("end", function () { 
                nodes.shift(); // &lt;-B 
                force.nodes(nodes); 
            }) 
            .remove(); 
 
        nodes.push(node); // &lt;-C 
        force.nodes(nodes); 
    }); 
 
    function noForce(){ 
        force.force("charge", null); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function repulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-10)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function gravity(){ 
        force.force("charge", d3.forceManyBody().strength(1)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
 
    function positioningWithGravity(){ 
        force.force("charge", d3.forceManyBody().strength(0.5)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
 
    function positioningWithRepulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-20)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
    &lt;button onclick="noForce()"&gt; 
        No Force 
    &lt;/button&gt; 
    &lt;button onclick="repulsion()"&gt; 
        Repulsion 
    &lt;/button&gt; 
    &lt;button onclick="gravity()"&gt; 
        Gravity 
    &lt;/button&gt; 
    &lt;button onclick="positioningWithGravity()"&gt; 
        Positioning with Gravity 
    &lt;/button&gt; 
    &lt;button onclick="positioningWithRepulsion()"&gt; 
        Positioning with Repulsion 
    &lt;/button&gt; 
&lt;/div&gt; 
</pre><p>This recipe generates a force-enabled particle system that is capable of operating in the modes shown in the following diagram:</p><p>
</p><div><img src="img/image_11_001.jpg" alt="How to do it..."/></div><p>
</p><p>Force simulation modes</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec228"/>How it works...</h2></div></div></div><p>Before we get our hands dirty with the preceding code example, let's first dig a little bit deeper into the fundamental concepts of alpha decay, velocity decay, charge, positioning, and collision so we can have an easier time understanding all the magic number settings we will use in this recipe.</p><div><div><div><div><h3 class="title"><a id="ch11lvl3sec19"/>Alpha decay</h3></div></div></div><p>Alpha determines how hot a simulation is. A simulation starts with alpha of 1 and decay toward 0 by default over 300 iterations. Therefore, if you set the alpha decay to 0 meaning there is no decay therefore simulation will never stop. This is the setting we will use in this chapter in order to better demonstrate the effects. In real-life visualization, you will typically use some level of decay so that the simulation will cool down after a while, similar to how particles work in the real world.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec20"/>Velocity decay</h3></div></div></div><p>At each tick of the simulation particle, velocity is scaled down by a specified decay. Thus, a value of 1 corresponds to a frictionless environment, whereas a value of 0 freezes all particles in place since they lose their velocity immediately.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec21"/>Charge</h3></div></div></div><p>Charge is specified to simulate mutual n-body forces among the particles. A negative value will result in mutual node repulsion, whereas a positive value will result in a mutual node attraction.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec22"/>Positioning</h3></div></div></div><p>If X or Y positioning forces are specified, the simulation will push particles toward a desired position along a given dimension with configured strength. This is typically used as a global force that applies to all particles in the simulation.</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec23"/>Collision</h3></div></div></div><p>The collision force treats particles as circles with a certain radius instead of size-less points. This will prevent particles from overlapping in a simulation.</p><p>Alright, now with the dry definition behind us, let's take a look at how these forces can be leveraged to generate interesting visual effects.
</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec24"/>Setting up zero force layout</h3></div></div></div><p>To set up zero force layout, we simply set up force layout with neither gravity nor charge. The force layout can be created using the <code class="literal">d3.forceSimulation</code> function:</p><pre class="programlisting">var w = 1280, h = 800, r = 4.5, 
        nodes = [], 
        force = d3.forceSimulation() 
                .velocityDecay(0.8) 
                .alphaDecay(0) 
                .force("collision",  
                    d3.forceCollide(r + 0.5).strength(1)); 
</pre><p>First of all, we disable <code class="literal">alphaDecay</code> so that simulation will continue to run without cooling down while setting the <code class="literal">velocityDecay</code> to <code class="literal">0.8</code> to simulate the effect of friction. Next, we set the <code class="literal">collision</code> to slightly larger than the radius of the <code class="literal">svg:circle</code> element we will create later. With this setting in place, we then create additional nodes represented as <code class="literal">svg:circle</code> on SVG whenever the user moves the mouse:</p><pre class="programlisting">svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = {x: point[0], y: point[1]}; // &lt;-A 
 
        svg.append("circle") 
                .data([node]) 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("r", 1e-6) 
        .transition() 
            .attr("r", r) 
        .transition() 
            .delay(7000) 
            .attr("r", 1e-6) 
            .on("end", function () { 
                nodes.shift(); // &lt;-B 
                force.nodes(nodes); 
            }) 
            .remove(); 
 
        nodes.push(node); // &lt;-C 
        force.nodes(nodes); 
    }); 
</pre><p>Node object was created initially on line <code class="literal">A</code> with its coordinates set to the current mouse location. Like all other D3 layouts, force simulation is not aware and has no visual elements. Therefore, every node we create needs to be added to the layout's nodes array on line <code class="literal">C</code> and removed when the visual representation of these nodes was removed on line <code class="literal">B</code>. By default, force simulation starts automatically as soon as the simulation was created. With zero gravity and charge, this setting essentially lets us place a string of nodes with our mouse movement, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_002.jpg" alt="Setting up zero force layout"/></div><p>
</p><p>No Gravity or Charge</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec25"/>Setting up mutual repulsion</h3></div></div></div><p>In the next mode, we will set the charge to a negative value without any global positioning force in order to generate a mutual repulsive force field:</p><pre class="programlisting">    function repulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-10)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
</pre><p>These lines tell force layout to apply <code class="literal">-10</code> charge on each node and update the node's <code class="literal">{x, y}</code> coordinate accordingly, based on the simulation result on each tick. However, only doing this is still not enough to move the particles on SVG since the layout has no knowledge of the visual elements. Next, we need to write some code to connect the data that is being manipulated by force layout to our graphical elements. Following is the code to do that:</p><pre class="programlisting">force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}); 
}); 
</pre><p>Here, we register a <code class="literal">tick</code> event listener function that updates all circle elements to its new position based on the force layout's calculation. Tick listener is triggered on each tick of the simulation. At each tick, we set the <code class="literal">cx</code> and <code class="literal">cy</code> attributes to be the <code class="literal">x</code> and <code class="literal">y</code> values on <code class="literal">d</code>. This is because we have already bound the node object as datum to these circle elements. Therefore, they already contain the new coordinates calculated by force layout. This effectively establishes force layout's control over all the particles.</p><div><div><h3 class="title"><a id="note82"/>Note</h3><p>Force simulation also sets values other than x and y on the node object, which we will cover and leverage in later recipes to implement force drag and custom forces. In this recipe, let's just focus on the simple force-based positioning first.</p></div></div><p>Other than <code class="literal">tick</code>, force layout also supports some other events:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">tick</code>: Triggered on each tick of the simulation</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: Triggered when a simulation ends</li></ul></div><p>This force setting generates the following visual effect:</p><p>
</p><div><img src="img/image_11_003.jpg" alt="Setting up mutual repulsion"/></div><p>
</p><p>Mutual Repulsion</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec26"/>Setting up gravity</h3></div></div></div><p>When we change the charge to a positive value, it generates mutual attraction or gravity among the particles:</p><pre class="programlisting">     function gravity(){ 
        force.force("charge", d3.forceManyBody().strength(1)); 
        force.force("x", null); 
        force.force("y", null); 
        force.restart(); 
    } 
</pre><p>This generates the following visual effect:</p><p>
</p><div><img src="img/image_11_004.jpg" alt="Setting up gravity"/></div><p>
</p><p>Gravity</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec27"/>Setting up positioning with gravity</h3></div></div></div><p>When we turn on gravity with central positioning force, then it generates a somewhat similar effect as the mutual attraction; however, you can notice the strong gravitational pull as the mouse cursor moves away from the center:</p><pre class="programlisting">    function positioningWithGravity(){ 
        force.force("charge", d3.forceManyBody().strength(0.5)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
</pre><p>This recipe generates the following effect:</p><p>
</p><div><img src="img/image_11_005.jpg" alt="Setting up positioning with gravity"/></div><p>
</p><p>Positioning with gravity</p></div><div><div><div><div><h3 class="title"><a id="ch11lvl3sec28"/>Setting up positioning with repulsion</h3></div></div></div><p>Finally, we can turn on both positioning and mutual repulsion. The result is an equilibrium of forces that keeps all particles somewhat stable, neither escaping nor colliding with each other:</p><pre class="programlisting">    function positioningWithRepulsion(){ 
        force.force("charge", d3.forceManyBody().strength(-20)); 
        force.force("x", d3.forceX(w / 2)); 
        force.force("y", d3.forceY(h / 2)); 
        force.restart(); 
    } 
</pre><p>Here is what this force equilibrium looks like:</p><p>
</p><div><img src="img/image_11_006.jpg" alt="Setting up positioning with repulsion"/></div><p>
</p><p>Positioning with repulsion</p></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec229"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to Velocity Verlet integration at <a class="ulink" href="https://en.wikipedia.org/wiki/Verlet_integration">https://en.wikipedia.org/wiki/Verlet_integration
</a></li><li class="listitem" style="list-style-type: disc">Refer to scalable, versatile, and simple constrained graph layout at <a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf
</a></li><li class="listitem" style="list-style-type: disc">Refer to physical simulation at <a class="ulink" href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm
</a></li><li class="listitem" style="list-style-type: disc">The content of this chapter is inspired by Mike Bostock's brilliant talk on D3 Force that can be found at <a class="ulink" href="http://mbostock.github.io/d3/talk/20110921/">http://mbostock.github.io/d3/talk/20110921/
</a></li><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization">Chapter 10</a>, <em>Interacting with Your Visualization</em>, for more details on how to interact with the mouse in D3</li><li class="listitem" style="list-style-type: disc">Refer to D3 Force Simulation API document for more details on force at <a class="ulink" href="https://github.com/d3/d3-force">https://github.com/d3/d3-force
</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec77"/>Customizing velocity</h1></div></div></div><p>In our previous recipe, we touched upon force simulation node object and its {<code class="literal">x, y</code>} attributes, which determine the location of a node on the layout. In this recipe, we will discuss another interesting aspect of physical motion simulation: velocity. The D3 force layout has a built-in support for velocity simulation, which relies on the {<code class="literal">vx, vy</code>} attributes on the node object. Let's see how this can be done in the example described in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec230"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/velocity.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec231"/>How to do it...</h2></div></div></div><p>In this recipe, we will modify the previous recipe by first disabling both positioning and charge and then giving newly added node some initial velocity. As a result, now, the faster you move the mouse higher the initial velocity and momentum will be for each node. Here is the code to do that:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var r = 4.5, nodes = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.1) 
                    .alphaDecay(0) 
                    .force("collision",  
                         d3.forceCollide(r + 0.5).strength(1)); 
 
    var svg = d3.select("body").append("svg:svg"); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}); 
    }); 
 
    var previousPoint; 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = { 
                x: point[0], 
                y: point[1], 
                vx: previousPoint? 
                     point[0]-previousPoint[0]:point[0], 
                vy: previousPoint? 
                     point[1]-previousPoint[1]:point[1] 
            }; 
 
        previousPoint = point; 
 
        svg.append("svg:circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
            .transition() 
                .attr("r", r) 
            .transition() 
            .delay(5000) 
                .attr("r", 1e-6) 
                .on("end", function () { 
                    nodes.shift(); 
                    force.nodes(nodes); 
                }) 
                .remove(); 
 
        nodes.push(node); 
        force.nodes(nodes); 
    }); 
&lt;/script&gt;  
</pre><p>This recipe generates a particle system with initial directional velocity proportional to the user's mouse movement, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_007.jpg" alt="How to do it..."/></div><p>
</p><p>Velocity</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec232"/>How it works...</h2></div></div></div><p>The overall structure of this recipe is pretty similar to the previous one. It also generates particles as the user moves the mouse around. Moreover, once the force simulation starts, the particle position is fully controlled by the force layout in its <code class="literal">tick</code> event listener function. However, in this recipe, we have turned off both positioning and charge so that we can focus more clearly on momentum alone. We left some friction so that the velocity decay, making simulation look more realistic. Here is our force layout configuration:</p><pre class="programlisting">var force = d3.forceSimulation() 
                    .velocityDecay(0.1) 
                    .alphaDecay(0) 
                    .force("collision",  
                         d3.forceCollide(r + 0.5).strength(1)); 
</pre><p>The major difference in this recipe is that we keep track of not only the current mouse position, but also the previous mouse position. Additionally, whenever the user moves the mouse, we generate a node object containing the current location (<code class="literal">point[0], point[1]</code>) and the previous location (<code class="literal">previousPoint.x, previousPoint.y</code>):</p><pre class="programlisting">    var previousPoint; 
 
    svg.on("mousemove", function () { 
        var point = d3.mouse(this), 
            node = { 
                x: point[0], 
                y: point[1], 
                vx: previousPoint? 
                    point[0]-previousPoint[0]:point[0], 
                vy: previousPoint? 
                    point[1]-previousPoint[1]:point[1] 
            }; 
 
        previousPoint = point; 
    ... 
} 
</pre><p>Since user's mouse location is sampled on fixed interval, the faster the user moves the mouse the further apart these two positions will be. This property and the directional information gained from these two positions are nicely translated automatically by force simulation into initial velocity for each particle we create as we have demonstrated in this recipe.</p><p>Besides the {<code class="literal">x, y, vx, vy</code>} attributes we have discussed so far, the force layout node object also supports some other useful attributes that we will list here for your reference:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: Zero-based index of the node within the node's array</li><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: The x-coordinate of the current node position</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: The y-coordinate of the current node position</li><li class="listitem" style="list-style-type: disc"><code class="literal">vx</code>: The node's current x-velocity</li><li class="listitem" style="list-style-type: disc"><code class="literal">vy</code>: The node's current y-velocity</li><li class="listitem" style="list-style-type: disc"><code class="literal">fx</code>: The node's fixed x-position</li><li class="listitem" style="list-style-type: disc"><code class="literal">fy</code>: The node's fixed y-position</li></ul></div><div><div><h3 class="title"><a id="note83"/>Note</h3><p>We will cover <code class="literal">fx</code> and <code class="literal">fy</code> and their usage in later recipe that involves dragging, which is one of the most common way to leverage fixed positioning of a node.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec233"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Interacting with mouse events</em> recipe in <a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization">Chapter 10</a>, <em>Interacting with Your Visualization</em>, for more details on how to interact with the mouse in D3.</li><li class="listitem" style="list-style-type: disc">Refer to the D3 Force Simulation Nodes API for more details on node attributes at <a class="ulink" href="https://github.com/d3/d3-force#simulation_nodes">https://github.com/d3/d3-force#simulation_nodes
</a>.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec78"/>Setting the link constraint</h1></div></div></div><p>So far, we have covered some important aspects of the force layout, such as gravity, charge, friction, and velocity. In this recipe, we will discuss another critical functionality: links. As we have mentioned in the introduction section, D3 force simulation supports a scalable simple graph constraint, and in this recipe, we will demonstrate how link constraint can be leveraged in conjunction with other forces.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec234"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/link-constraint.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec235"/>How to do it...</h2></div></div></div><p>In this recipe, whenever the user clicks on the mouse, we will generate a force-directed ring of particles constrained by links between nodes. Here is how it is implemented:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, 
            r = 4.5, nodes = [], links = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody() 
                            .strength(-50).distanceMax(h / 4)) 
                    .force("collision",  
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var duration = 10000; 
 
    var svg = d3.select("body") 
            .append("svg") 
                .attr("width", w) 
                .attr("height", h); 
 
    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
 
        svg.selectAll("line") 
            .attr("x1", function (d) {return boundX(d.source.x);}) 
            .attr("y1", function (d) {return boundY(d.source.y);}) 
            .attr("x2", function (d) {return boundX(d.target.x);}) 
            .attr("y2", function (d) {return boundY(d.target.y);} 
        ); 
    }); 
 
    function boundX(x) { 
        return x &gt; (w - r) ? (w - r): (x &gt; r ? x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? (h - r) : (y &gt; r ? y : r); 
    } 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function createNodes(point) { 
        var numberOfNodes = Math.round(Math.random() * 10); 
        var newNodes = []; 
 
        for (var i = 0; i &lt; numberOfNodes; ++i) { 
            newNodes.push({ 
                x: point[0] + offset(), 
                y: point[1] + offset() 
            }); 
        } 
 
        newNodes.forEach(function(e){nodes.push(e)}); 
 
        return newNodes; 
    } 
 
    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { // &lt;-A 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
 
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
 
        newLinks.forEach(function (link) { 
            svg.append("line") // &lt;-B 
                    .data([link]) 
                .attr("class", "line") 
                .attr("x1", function (d) {return d.source.x;}) 
                .attr("y1", function (d) {return d.source.y;}) 
                .attr("x2", function (d) {return d.target.x;}) 
                .attr("y2", function (d) {return d.target.y;}) 
                    .transition() 
                    .delay(duration) 
                .style("stroke-opacity", 1e-6) 
                .on("end", function () {links.shift();}) 
                .remove(); 
        }); 
 
        force.nodes(nodes); 
        force.force("link",  
                         d3.forceLink(links) 
                            .strength(1).distance(20)); // &lt;-C 
        force.restart(); 
    }); 
 
    function dragStarted(d) { 
        d.fx = d.x; // &lt;-E 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; // &lt;-F 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; // &lt;-G 
        d.fy = null; 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates force-directed particle rings on a mouse click, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_008.jpg" alt="How to do it..."/></div><p>
</p><p>Force-directed particle rings</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec236"/>How it works...</h2></div></div></div><p>Link constraint adds another useful dimension to force-assisted visualization. In this recipe, we set up our force layout with the following parameters:</p><pre class="programlisting">var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge", d3.forceManyBody() 
                             .strength(-50).distanceMax(h / 4)) 
                    .force("collision",   
                            d3.forceCollide(r + 0.5).strength(1)); 
</pre><p>Besides collision, charge, and friction, this time we also bound charge-force interaction to 25% of the maximum height to simulate a more localized force interaction. When the user clicks on their mouse, a random number of nodes are being created and put under force simulation's control similar to what we have done in the previous recipes. The major addition in this recipe is the link creation, and its control logic is shown in the following code snippet:</p><pre class="programlisting">    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { // &lt;-A 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
    
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
 
        newLinks.forEach(function (link) { 
            svg.append("line") // &lt;-B 
                    .data([link]) 
                .attr("class", "line") 
                .attr("x1", function (d) {return d.source.x;}) 
                .attr("y1", function (d) {return d.source.y;}) 
                .attr("x2", function (d) {return d.target.x;}) 
                .attr("y2", function (d) {return d.target.y;}) 
                    .transition() 
                    .delay(duration) 
                .style("stroke-opacity", 1e-6) 
                .on("end", function () {links.shift();}) 
                .remove(); 
        }); 
 
        force.nodes(nodes); 
        force.force("link", 
                        d3.forceLink(links) 
                           .strength(1).distance(20)); // &lt;-C 
        force.restart(); 
    }); 
</pre><p>In the <code class="literal">createLinks</code> function, the <code class="literal">n-1</code> link objects were created connecting a set of nodes into a ring (for loop on line <code class="literal">A</code>). Each link object must have two attributes specified as <code class="literal">source</code> and <code class="literal">target</code>, telling force layout which pair of nodes are connected by this link object. Once this is created, we decided to visualize the links in this recipe using a <code class="literal">svg:line</code> element (refer to line <code class="literal">B</code>). However, we will see in the next recipe that this does not have to always be the case. As a matter of fact, you can use pretty much anything; you can imagine to visualize (including hiding them, but retain the links for layout computation) the links as long as it makes sense for the audience of your visualization. After that, we also need to add link objects to force layout's links array (on line <code class="literal">C</code>) so that they can be put under force layout's control. The <code class="literal">d3.forceLink</code> function has two important parameters: link distance and link strength; both parameters are exclusively link related:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">linkDistance</code>: This could be a constant or a function, which defaults to <code class="literal">20</code> pixels. Link distances are evaluated when the simulation is initialized, and it is implemented as weak geometric constraints. For each tick of the layout, the distance between each pair of linked nodes is computed and compared to the target distance. The links are then moved toward each other or away from each other.</li><li class="listitem" style="list-style-type: disc"><code class="literal">linkStength</code>: This could be a constant or a function, which defaults to <code class="literal">1</code>. Link strength sets the strength (rigidity) of links with a value in the range of <code class="literal">[0, 1]</code>. Link strength is also evaluated on initialization or reset.</li></ul></div><p>Finally, we will need to translate the positioning data generated by force layout to SVG implementation in the <code class="literal">tick</code> function for each link similar to what we did for the nodes:</p><pre class="programlisting">    force.on("tick", function () { 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
 
        svg.selectAll("line") 
            .attr("x1", function (d) {return boundX(d.source.x);}) 
            .attr("y1", function (d) {return boundY(d.source.y);}) 
            .attr("x2", function (d) {return boundX(d.target.x);}) 
            .attr("y2", function (d) {return boundY(d.target.y);}); 
    }); 
     
    function boundX(x) { 
        return x &gt; (w - r) ? (w - r): (x &gt; r ? x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? (h - r) : (y &gt; r ? y : r); 
    } 
</pre><p>As we can see here, the D3 force simulation has again done most of the heavy lifting, therefore, all we need to do is simply set <code class="literal">{x1, y1}</code> and <code class="literal">{x2, y2}</code> on the <code class="literal">svg:line</code> elements in the <code class="literal">tick</code> function. Additionally, we have also used two bounded X and Y function to make sure that the particles and rings will not escape our SVG canvas area. For reference, the following screenshot is what a link object looks like after it is manipulated by force layout:</p><p>
</p><div><img src="img/image_11_009.jpg" alt="How it works..."/></div><p>
</p><p>Link object</p><p>One last additional technique worth mentioning in this recipe is the force-enabled dragging. All nodes generated by this recipe are "drag gable," and force simulation automatically re-computes all forces and constraints, as the user drags the rings around, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_010.jpg" alt="How it works..."/></div><p>
</p><p>Dragging, with force simulation</p><p>This is accomplished by registering the <code class="literal">d3.drag</code> event handler as shown on line <code class="literal">D</code> in the following code snippet:</p><pre class="programlisting">       newNodes.forEach(function (node) { 
            svg.append("circle") 
                    .data([node]) 
                .attr("class", "node") 
                .attr("cx", function (d) {return d.x;}) 
                .attr("cy", function (d) {return d.y;}) 
                .attr("r", 1e-6) 
                    .call(d3.drag() // &lt;-D 
                            .on("start", dragStarted) 
                            .on("drag", dragged) 
                            .on("end", dragEnded)) 
                    .transition() 
                .attr("r", 7) 
                    .transition() 
                    .delay(duration) 
                .attr("r", 1e-6) 
                .on("end", function () {nodes.shift();}) 
                .remove(); 
        }); 
</pre><p>The implementation of each of the drag event handler is pretty straightforward:</p><pre class="programlisting">    function dragStarted(d) { 
        d.fx = d.x; // &lt;-E 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; // &lt;-F 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; // &lt;-G 
        d.fy = null; 
    } 
</pre><p>When dragging happens on a particular node, we use <code class="literal">fx</code> and <code class="literal">fy</code> to fix that particular node to its initial position as shown on line <code class="literal">E</code>. While the dragging is happening, we continue to update the node's position with the user's mouse position, thus, moving the node while being dragged (refer to line <code class="literal">F</code>). Finally, when drag ends, we unfix the node position, thus, allowing force simulation to take control once again, as shown on line <code class="literal">G</code>. This is a very general drag support pattern you will see quite often with force-assisted visualization, including some later recipes in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec237"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scalable, versatile, and simple constrained graph layout: <a class="ulink" href="http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf">http://www.csse.monash.edu.au/~tdwyer/Dwyer2009FastConstraints.pdf
</a></li><li class="listitem" style="list-style-type: disc">For more information about force.links() function please refer to: <a class="ulink" href="https://github.com/d3/d3-force#links">https://github.com/d3/d3-force#links
</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec79"/>Using force to assist visualization</h1></div></div></div><p>So far, we learned to use force simulation visualizing particles and links similar to how you would use force in its classic application, the forced-directed graph. This kind of visualization is what force simulation was designed for in the first place. However, this is by no means the only way to utilize force in your visualization. In this recipe, we will explore techniques that I call force-assisted visualization. With this technique, you can add some randomness and arbitrariness into your visualization by leveraging force.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec238"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/arbitrary-visualization.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec239"/>How to do it...</h2></div></div></div><p>In this recipe, we will generate bubbles on the user's mouse click. The bubbles are made of <code class="literal">svg:path</code> elements filled with gradient color. The <code class="literal">svg:path</code> elements are not strictly controlled by force layout though they are influenced by force, therefore, giving them the randomness required to simulate a bubble in real life:</p><pre class="programlisting">&lt;svg&gt; 
    &lt;defs&gt; 
        &lt;radialGradient id="gradient" cx="50%" cy="50%"  
                                r="100%" fx="50%" fy="50%"&gt; 
            &lt;stop offset="0%" 
              style="stop-color:blue;stop-opacity:0"/&gt; 
            &lt;stop offset="100%" 
              style="stop-color:rgb(255,255,255);stop-opacity:1"/&gt; 
        &lt;/radialGradient&gt; 
    &lt;/defs&gt; 
&lt;/svg&gt; 
 
&lt;script type="text/javascript"&gt; 
    var w = 1280, h = 800, 
                r = 4.5, nodes = [], links = []; 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge", d3.forceManyBody() 
                              .strength(-50).distanceMax(h / 4)) 
                    .force("collision",  
                              d3.forceCollide(r + 0.5).strength(1)) 
                    .force("position", d3.forceY(h / 2)); 
 
    var duration = 60000; 
 
    var svg = d3.select("svg") 
                .attr("width", w) 
                .attr("height", h); 
 
 
    var line = d3.line() // &lt;-A 
            .curve(d3.curveBasisClosed) 
            .x(function(d){return d.x;}) 
            .y(function(d){return d.y;}); 
 
    force.on("tick", function () { 
        svg.selectAll("path") 
            .attr("d", line); 
    }); 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function createNodes(point) { 
        var numberOfNodes = Math.round(Math.random() * 10); 
        var newNodes = []; 
 
        for (var i = 0; i &lt; numberOfNodes; ++i) { 
            newNodes.push({ 
                x: point[0] + offset(), 
                y: point[1] + offset() 
            }); 
        } 
 
        newNodes.forEach(function(e){nodes.push(e)}); 
 
        return newNodes; 
    } 
 
    function createLinks(nodes) { 
        var newLinks = []; 
        for (var i = 0; i &lt; nodes.length; ++i) { 
            if(i == nodes.length - 1) 
                newLinks.push( 
                    {source: nodes[i], target: nodes[0]} 
                ); 
            else 
                newLinks.push( 
                    {source: nodes[i], target: nodes[i + 1]} 
                ); 
        } 
 
        newLinks.forEach(function(e){links.push(e)}); 
 
        return newLinks; 
    } 
 
    svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        console.log(point); 
 
        svg.append("path") 
                .data([newNodes]) 
            .attr("class", "bubble") 
            .attr("fill", "url(#gradient)") // &lt;-B 
            .attr("d", function(d){return line(d);}) 
                .transition().delay(duration) // &lt;-C 
            .attr("fill-opacity", 0) 
            .attr("stroke-opacity", 0) 
            .on("end", function(){d3.select(this).remove();}); 
 
        force.nodes(nodes); 
        force.force("link",  
                   d3.forceLink(links).strength(1).distance(20)); 
        force.restart(); 
    }); 
&lt;/script&gt; 
</pre><p>This recipe generates force-assisted bubbles on the user's mouse click as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_011.jpg" alt="How to do it..."/></div><p>
</p><p>Force assisted bubbles</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec240"/>How it works...</h2></div></div></div><p>This recipe is built on top of what we have done in the previous recipe, therefore, its overall approach is quite similar to the last recipe in which we created force-controlled particle rings on the user's mouse click. The major difference between this recipe and the last one is in this one we decided to use the <code class="literal">d3.line</code> generator to create the <code class="literal">svg:path</code> element that outlines our bubbles instead of using <code class="literal">svg:circle</code> and <code class="literal">svg:line</code>:</p><pre class="programlisting">var line = d3.line() // &lt;-A 
            .curve(d3.curveBasisClosed) 
            .x(function(d){return d.x;}) 
            .y(function(d){return d.y;}); 
... 
svg.on("click", function () { 
        var point = d3.mouse(this), 
                newNodes = createNodes(point), 
                newLinks = createLinks(newNodes); 
 
        console.log(point); 
 
        svg.append("path") 
                .data([newNodes]) 
            .attr("class", "bubble") 
            .attr("fill", "url(#gradient)") // &lt;-B 
            .attr("d", function(d){return line(d);}) // &lt;-C 
                .transition().delay(duration) 
            .attr("fill-opacity", 0) 
            .attr("stroke-opacity", 0) 
            .on("end", function(){d3.select(this).remove();}); 
 
        force.nodes(nodes); 
        force.force("link",  
                d3.forceLink(links).strength(1).distance(20)); 
        force.restart(); 
    }); 
</pre><p>On line <code class="literal">A</code>, we created a line generator with a <code class="literal">d3.curveBasisClosed</code> curve mode since this gives us the smoothest outline for our bubble. Whenever a user clicks on the mouse, a <code class="literal">svg:path</code> element was created connecting all nodes (line <code class="literal">C</code>). Additionally, we also fill the bubble with our predefined gradient to give it a nice glow (line <code class="literal">B</code>). Finally, we also need to implement the force-based positioning in the <code class="literal">tick</code> function:</p><pre class="programlisting">    force.on("tick", function () { 
        svg.selectAll("path") 
            .attr("d", line); 
    }); 
</pre><p>In the <code class="literal">tick</code> function, we simply re-invoke the line generator function to update the <code class="literal">d</code> attribute for each path, thus, animating the bubbles using force layout computation.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec241"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to SVG Gradients and Patterns at <a class="ulink" href="https://www.w3.org/TR/SVG/pservers.html">https://www.w3.org/TR/SVG/pservers.html
</a>.</li><li class="listitem" style="list-style-type: disc">Refer to the <em>Using line generator</em> recipe in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, for more information on D3 line generator.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec80"/>Manipulating force</h1></div></div></div><p>So far, we have explored many interesting aspects and applications of D3 force; however, in all of these prior recipes, we simply applied force layout's computation (gravity, charge, friction, collision, and velocity) directly to our visualization. In this recipe, we will go one step further to implement custom force manipulation, hence creating our own type of force.</p><p>In this recipe, we will first generate five sets of colored particles then assign corresponding colors and categorical force pull to user's touch, hence pulling only the particles that match the color. Since this recipe is a bit complex, I will give an example here: if I touch the visualization with my first finger, it will generate a blue circle and pull all blue particles to that circle, whereas my second touch will generate an orange circle and will only pull the orange particles. This type of force manipulation is commonly referred to as categorical multi-foci.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec242"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/multi-foci.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec243"/>How to do it...</h2></div></div></div><p>Here is how you can achieve this in code:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var svg = d3.select("body").append("svg"), 
            colors = d3.scaleOrdinal(d3.schemeCategory20c), 
            r = 4.5, 
            w = 1290, 
            h = 800; 
 
    svg.attr("width", w).attr("height", h); 
 
    var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody().strength(-30)) 
                    .force("x", d3.forceX(w / 2)) 
                    .force("y", d3.forceY(h / 2)) 
                    .force("collision",   
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var nodes = [], centers = []; 
 
    for (var i = 0; i &lt; 5; ++i) { 
        for (var j = 0; j &lt; 50; ++j) { 
            nodes.push({ 
                x: w / 2 + offset(), 
                y: h / 2 + offset(), 
                color: colors(i), // &lt;-A 
                type: i // &lt;-B 
            }); 
        } 
    } 
 
    force.nodes(nodes); 
 
    function offset() { 
        return Math.random() * 100; 
    } 
 
    function boundX(x) { 
        return x &gt; (w - r) ? (w - r): (x &gt; r ? x : r); 
    } 
 
    function boundY(y){ 
        return y &gt; (h - r) ? (h - r) : (y &gt; r ? y : r); 
    } 
 
    svg.selectAll("circle") 
                .data(nodes).enter() 
            .append("circle") 
            .attr("class", "node") 
            .attr("cx", function (d) {return d.x;}) 
            .attr("cy", function (d) {return d.y;}) 
            .attr("fill", function(d){return d.color;}) 
            .attr("r", 1e-6) 
                .transition() 
            .attr("r", r); 
 
    force.on("tick", function() { 
        var k = 0.1; 
        nodes.forEach(function(node) { 
            var center = centers[node.type]; 
            if(center){ 
                node.x += (center[0] - node.x) * k; 
                node.y += (center[1] - node.y) * k; 
            } 
        }); 
 
        svg.selectAll("circle") 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
    }); 
 
    d3.select("body") 
        .on("touchstart", touch) 
        .on("touchend", touch); 
 
    function touch() { 
        d3.event.preventDefault(); 
 
        centers = d3.touches(svg.node()); 
 
        console.log(centers); 
 
        var g = svg.selectAll("g.touch") 
                .data(centers, function (d) { 
                    return d.identifier; 
                }); 
 
        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("circle") 
                .attr("class", "touch") 
                .attr("fill",  
                        function(d){return colors(d.identifier);}) 
                    .transition() 
                .attr("r", 50); 
 
        g.exit().remove(); 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates multi-categorical foci on touch, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_11_012.jpg" alt="How to do it..."/></div><p>
</p><p>Multi-categorical foci on touch</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec244"/>How it works...</h2></div></div></div><p>The first step of this recipe is to create colored particles and standard force equilibrium between positioning and repulsion. All node objects contain separate color and type ID attributes (line <code class="literal">A</code> and <code class="literal">B</code>), so they can be easily identified later. On line <code class="literal">C</code>, we let force simulation manage all the positioning of these particles as we have done in previous recipes:</p><pre class="programlisting">var force = d3.forceSimulation() 
                    .velocityDecay(0.8) 
                    .alphaDecay(0) 
                    .force("charge",  
                        d3.forceManyBody().strength(-30)) 
                    .force("x", d3.forceX(w / 2)) 
                    .force("y", d3.forceY(h / 2)) 
                    .force("collision",  
                        d3.forceCollide(r + 0.5).strength(1)); 
 
    var nodes = [], centers = []; 
 
    for (var i = 0; i &lt; 5; ++i) { 
        for (var j = 0; j &lt; 50; ++j) { 
            nodes.push({ 
                x: w / 2 + offset(), 
                y: h / 2 + offset(), 
                color: colors(i), // &lt;-A 
                type: i // &lt;-B 
            }); 
        } 
} 
 
    force.nodes(nodes); // &lt;-C 
</pre><p>Next, we will need to create a large <code class="literal">svg:circle</code> element on user touch to represent the touch point:</p><pre class="programlisting">function touch() { 
        d3.event.preventDefault(); 
 
        centers = d3.touches(svg.node()); 
 
        var g = svg.selectAll("g.touch") 
                .data(centers, function (d) { 
                    return d.identifier; 
                }); 
 
        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("circle") 
                .attr("class", "touch") 
                .attr("fill",  
                    function(d){return colors(d.identifier);}) 
                    .transition() 
                .attr("r", 50); 
 
        g.exit().remove(); 
    } 
</pre><p>This is the pretty standard multi-touch drawing that we saw in <em>Interacting with a multi-touch device</em> recipe in <a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization">Chapter 10</a>, <em>Interacting with Your Visualization</em>. Once the touch point is identified, all the custom force magic are implemented in the <code class="literal">tick</code> function. Now, let's take a look at the <code class="literal">tick</code> function:</p><pre class="programlisting">    force.on("tick", function() { 
        var k = 0.1; 
        nodes.forEach(function(node) { 
            var center = centers[node.type]; // &lt;-C 
            if(center){ 
                node.x += (center[0] - node.x) * k; // &lt;-D 
                node.y += (center[1] - node.y) * k; // &lt;-E 
            } 
        }); 
 
        svg.selectAll("circle") // &lt;-F 
            .attr("cx", function (d) {return boundX(d.x);}) 
            .attr("cy", function (d) {return boundY(d.y);}); 
    }); 
</pre><p>In this tick function, we have the familiar part, on line <code class="literal">F</code>, where we let force simulation to control the position of all particles on the canvas; however, we have also introduced a custom force. On line <code class="literal">C</code>, we looped through all nodes to identify the nodes associated with a given center that represents user's touch. Once we detect the touch center, we started to move the particle closer to the center one tick at a time (line <code class="literal">D</code> and <code class="literal">E</code>) using the <code class="literal">k</code> coefficient. The larger the <code class="literal">k</code> the faster the particles will converge around a touch point.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec245"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Interacting with a multi-touch device</em> recipe in <a class="link" href="ch10.html" title="Chapter 10. Interacting with Your Visualization">Chapter 10</a>, <em>Interacting with your Visualization</em>, for more information on D3 multi-touch support.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec81"/>Building a force-directed graph</h1></div></div></div><p>Finally, we will show how to implement a force-directed graph, the classic application of D3 force. However, we believe with all the techniques and knowledge you have gained so far from this chapter, implementing force-directed graph should feel quite straightforward.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec246"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter11/force-directed-graph.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec247"/>How to do it...</h2></div></div></div><p>In this recipe, we will visualize the flare dataset as a force-directed tree (tree is a special type of graph):</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var w = 1280, 
            h = 800, 
            r = 4.5, 
            colors = d3.scaleOrdinal(d3.schemeCategory20c); 
 
    var force = d3.forceSimulation() 
            .velocityDecay(0.8) 
            .alphaDecay(0) 
            .force("charge", d3.forceManyBody()) 
            .force("x", d3.forceX(w / 2)) 
            .force("y", d3.forceY(h / 2)); 
 
    var svg = d3.select("body").append("svg") 
            .attr("width", w) 
            .attr("height", h); 
 
    d3.json("../../data/flare.json", function (data) { 
        var root = d3.hierarchy(data); 
        var nodes = root.descendants(); 
        var links = root.links(); 
 
        force.nodes(nodes); 
        force.force("link",  
            d3.forceLink(links).strength(1).distance(20)); 
 
          var link = svg.selectAll("line") 
              .data(links) 
            .enter().insert("line") 
              .style("stroke", "#999") 
              .style("stroke-width", "1px"); 
 
          var nodeElements = svg.selectAll("circle.node") 
              .data(nodes) 
            .enter().append("circle") 
              .attr("r", r) 
              .style("fill", function(d) {  
                    return colors(d.parent &amp;&amp; d.parent.data.name);  
              }) 
              .style("stroke", "#000") 
              .call(d3.drag() 
                      .on("start", dragStarted) 
                      .on("drag", dragged) 
                      .on("end", dragEnded)); 
 
          force.on("tick", function(e) { 
            link.attr("x1", function(d) { return d.source.x; }) 
                .attr("y1", function(d) { return d.source.y; }) 
                .attr("x2", function(d) { return d.target.x; }) 
                .attr("y2", function(d) { return d.target.y; }); 
 
            nodeElements.attr("cx", function(d) { return d.x; }) 
                .attr("cy", function(d) { return d.y; }); 
          }); 
    }); 
 
    function dragStarted(d) { 
        d.fx = d.x; 
        d.fy = d.y; 
    } 
 
    function dragged(d) { 
        d.fx = d3.event.x; 
        d.fy = d3.event.y; 
    } 
 
    function dragEnded(d) { 
        d.fx = null; 
        d.fy = null; 
    } 
&lt;/script&gt; 
</pre><p>This recipe visualizes the hierarchical flare dataset as a force-directed tree:</p><p>
</p><div><img src="img/image_11_013.jpg" alt="How to do it..."/></div><p>
</p><p>Force-directed graph (tree)</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec248"/>How it works...</h2></div></div></div><p>As we can already see, this recipe is pretty short, and a quarter of the code was actually devoted to drag support. This is due to the fact that force-directed graph is what force simulation was designed for in the first place. Thus, there is really not much to do other than simply applying the force with correct data structure. First, we process the hierarchical dataset using the standard <code class="literal">d3.hierarchy</code> (line <code class="literal">A</code>) since this is how we can retrieve the nodes and links data structure <code class="literal">d3.force</code> expects:</p><pre class="programlisting">d3.json("../../data/flare.json", function (data) { 
        var root = d3.hierarchy(data); // &lt;-A 
        var nodes = root.descendants(); // &lt;-B 
        var links = root.links(); // &lt;-C 
         
        force.nodes(nodes); // &lt;-D 
        force.force("link", // &lt;-E 
                d3.forceLink(links).strength(1).distance(20)); 
        ... 
} 
</pre><p>On line <code class="literal">B</code>, we leverage the <code class="literal">d3.hierarchy.descendants</code> function to retrieve all nodes contained in the tree and the links among nodes on line <code class="literal">C</code> using the <code class="literal">d3.hierachy.links</code> function. These are the data structure <code class="literal">d3.force</code> expects; once we have them, they can be directly passed to simulation on line <code class="literal">D</code> and <code class="literal">E</code>. The rest of the recipe is very similar to the <em>Setting the link constraint </em>recipe in this chapter. We created the <code class="literal">svg:link</code> element to represent links and <code class="literal">svg:circle</code> elements to represent the nodes in the graph:</p><pre class="programlisting">          var link = svg.selectAll("line") 
              .data(links) 
            .enter().insert("line") 
              .style("stroke", "#999") 
              .style("stroke-width", "1px"); 
 
          var nodeElements = svg.selectAll("circle.node") 
              .data(nodes) 
            .enter().append("circle") 
              .attr("r", r) 
              .style("fill", function(d) { // &lt;-F 
                  return colors(d.parent &amp;&amp; d.parent.data.name); 
              }) 
              .style("stroke", "#000") 
              .call(d3.drag() // &lt;-G 
                      .on("start", dragStarted) 
                      .on("drag", dragged) 
                      .on("end", dragEnded)); 
</pre><p>The only parts worth mentioning here is that we colored the node using its parent's name on line <code class="literal">F</code>, so all siblings will be colored consistently, and on line <code class="literal">G</code>, we used the common drag support pattern mentioned in the <em>Setting the link constraint </em>recipe to allow dragging with this graph. Finally, we let force simulation to control both nodes and links positioning completely in the tick function:</p><pre class="programlisting">          force.on("tick", function(e) { 
            link.attr("x1", function(d) { return d.source.x; }) 
                .attr("y1", function(d) { return d.source.y; }) 
                .attr("x2", function(d) { return d.target.x; }) 
                .attr("y2", function(d) { return d.target.y; }); 
 
            nodeElements.attr("cx", function(d) { return d.x; }) 
                .attr("cy", function(d) { return d.y; }); 
          }); 
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec249"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to the <em>Building a tree</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Lay Them Out">Chapter 9</a>, <em>Lay Them Out</em>, for more information on D3 tree layout.</li><li class="listitem" style="list-style-type: disc">For more information on force-directed graphs, visit <a class="ulink" href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">https://en.wikipedia.org/wiki/Force-directed_graph_drawing
</a>.</li></ul></div></div></div></div></div></body></html>