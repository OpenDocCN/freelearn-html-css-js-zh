- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Advanced Routing Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级路由技术
- en: With everything we’ve covered so far, you could set this book down now and go
    build a simple website using SvelteKit. But if you wanted to build more advanced
    functionality into your application, you might find yourself struggling to come
    up with the proper hierarchies for routes. That’s because when it comes to dynamic
    routing, we’ve only scratched the surface. In [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060),
    we discussed creating dynamic pages with parameters passed to our routes. In that
    example, we loaded articles by using the provided slug and matching it with those
    found in our demonstration database. We had no way of knowing what the slug would
    be ahead of time and it would have been needlessly complicated to create a new
    route for each article. Instead, we looked at the slug parameter that was received
    based on the URL being accessed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了所有内容，你现在可以放下这本书，使用SvelteKit构建一个简单的网站。但如果你想在应用程序中构建更高级的功能，你可能会发现自己难以找到合适的路由层次结构。这是因为当我们谈到动态路由时，我们只是触及了表面。在[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)中，我们讨论了通过传递给我们的路由的参数创建动态页面。在那个例子中，我们通过提供的slug加载文章，并将其与我们在演示数据库中找到的匹配。我们无法提前知道slug是什么，为每篇文章创建一个新的路由将会过于复杂。相反，我们研究了基于访问的URL接收到的slug参数。
- en: This was only a brief introduction to dynamic routing. In this chapter, we’ll
    look at some more advanced techniques that can help you supercharge your routing
    logic. We’ll examine routing with optional parameters, parameters of unknown lengths,
    how to match parameters with regular expressions, which routes will take precedence
    in instances of routing logic collisions, and more advanced layout techniques,
    including methodologies for breaking out of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对动态路由的简要介绍。在本章中，我们将探讨一些更高级的技术，可以帮助你提升你的路由逻辑。我们将研究带有可选参数的路由、未知长度的参数、如何使用正则表达式匹配参数、在路由逻辑冲突的情况下哪些路由将具有优先级，以及更高级的布局技术，包括如何从中退出。
- en: 'This chapter will be broken into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下主题：
- en: Using optional parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选参数
- en: Rest parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余参数
- en: Matching, sorting, and encoding – oh, my!
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配、排序和编码——哦，我的天！
- en: Advanced layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级布局
- en: By the end of this chapter, you will have a mastery of the various routing techniques
    available to you in SvelteKit. No matter your next SvelteKit project’s requirements,
    you will have the knowledge required for solving and tackling any complex routing
    dilemmas.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握SvelteKit中可用的各种路由技术。无论你的下一个SvelteKit项目的需求如何，你都将拥有解决和应对任何复杂路由难题所需的知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07](https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter07)
- en: Using optional parameters
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可选参数
- en: Since we teased optional parameters in the *Creating Dynamic Pages* section
    of [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060), let’s start there.
    When creating optional parameters in a route, there are some things to keep in
    mind. For instance, they cannot exist alongside another route as this would cause
    a collision in the routing rules. When creating an optional route, it works best
    for instances where the final portion of the route can have a default option.
    Many applications will change the URL based on a language selected by the user.
    For our example, we’ll illustrate how to create an optional parameter by selecting
    a country in North America that our demonstration store operates in. We won’t
    actually build an entire store but rather use it to illustrate the advanced routing
    concepts in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在[*第4章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)的*创建动态页面*部分提到了可选参数，让我们从这里开始。在创建路由中的可选参数时，有一些事情需要考虑。例如，它们不能与另一个路由共存，因为这会导致路由规则冲突。在创建可选路由时，最佳做法是当路由的最后一部分可以有一个默认选项时。许多应用程序会根据用户选择的语言更改URL。在我们的例子中，我们将展示如何通过选择我们演示商店运营的北美国家来创建一个可选参数。我们实际上不会构建一个完整的商店，而是用它来展示本章中高级路由概念。
- en: 'To begin, let’s create a new route in our navigation just like we have for
    previous examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的导航中创建一个新的路由，就像我们之前的示例一样：
- en: src/lib/Nav.svelte
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: src/lib/Nav.svelte
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All we need to do is add another list item with a link to our new route in
    the navigation menu. After doing that, we can create the `store` directory, which
    is where all of the examples for this chapter will exist:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是再在导航菜单中添加一个链接到我们新的路由的另一个列表项。完成之后，我们可以创建`store`目录，这个目录将包含本章的所有示例：
- en: src/routes/store/+layout.svelte
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/+layout.svelte
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple layout will allow us to navigate the various concepts covered in
    this chapter. After adding links, we use the Svelte `<slot>` element referenced
    in earlier chapters. Take a moment to go and create all of the necessary directories.
    Next, we’ll also create a simple landing page for the `/``store` route:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的布局将允许我们导航本章中涵盖的各种概念。在添加链接后，我们使用在早期章节中提到的Svelte `<slot>`元素。花点时间创建所有必要的目录。接下来，我们还将为`/store`路由创建一个简单的着陆页：
- en: src/routes/store/+page.svelte
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/+page.svelte
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Having created the files necessary for the `/store` route as well as the `locations`
    directory, we’ll now create yet another directory. The major difference with this
    one will be that it uses double square brackets (`[[country]]`) in the name. This
    is how SvelteKit differentiates optional routes from those that are not. Because
    we’re creating a page with an optional parameter, we don’t need to create a `+page.svelte`
    inside of the `locations` directory. Rather, we’ll add that inside of the `[[country]]`
    directory. To proceed, we’ll create the appropriate `+page.svelte` and `+``page.js`
    files:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了`/store`路由和`locations`目录所需的文件之后，我们现在将创建另一个目录。与这个目录的主要区别在于它使用双方括号(`[[country]]`)作为名称。这是SvelteKit区分可选路由和不可选路由的方式。因为我们正在创建一个带有可选参数的页面，所以我们不需要在`locations`目录中创建`+page.svelte`。相反，我们将它添加到`[[country]]`目录中。为了继续，我们将创建适当的`+page.svelte`和`+page.js`文件：
- en: src/routes/store/locations/[[country]]/+page.svelte
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/locations/[[country]]/+page.svelte
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By now, this should look all too familiar. We use `export let data;` so that
    we may access the information provided by `load()` in the next file. We use that
    data to inform the user which country’s store locations they are viewing and display
    the abbreviation in uppercase. We then create an unordered list populated with
    links to the various allowed routes we will provide in the next file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该看起来非常熟悉。我们使用`export let data;`以便在下一个文件中访问`load()`提供的信息。我们使用这些数据来告知用户他们正在查看哪个国家的商店位置，并显示大写缩写。然后我们创建一个无序列表，其中包含指向我们将在下一个文件中提供的各种允许路由的链接。
- en: 'In `[[country]]/+page.js`, we need to check the provided parameters of the
    route against the list of countries our store operates in. We can do so with the
    following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[[country]]/+page.js`中，我们需要将路由提供的参数与我们的商店运营的国家列表进行比对。我们可以使用以下代码来完成：
- en: src/routes/store/locations/[[country]]/+page.js
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/locations/[[country]]/+page.js
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exporting `load()` functions should also feel familiar to you at this point.
    In this particular function, we only need access to `params` and so we destructure
    the `RequestEvent` object passed to `load()`. We’ve then declared a `codes` array
    that works as a list of approved routes. On the next line, we check if the provided
    route is in the array of approved routes by running `filter()` on `codes`. Then
    `filter()` returns an array containing all of the matches and assigns it to the
    `found` constant. We can then return an object containing the `country` property,
    which is assigned the first value inside of `found`. If the first value of `found`
    is empty, we’ll default to the value that shows all of North America. In this
    case, `na`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，导出`load()`函数应该对你来说也很熟悉。在这个特定的函数中，我们只需要访问`params`，所以我们解构了传递给`load()`的`RequestEvent`对象。然后我们声明了一个`codes`数组，它作为一个允许路由的列表。在下一行，我们通过在`codes`上运行`filter()`来检查提供的路由是否在允许路由的数组中。然后`filter()`返回一个包含所有匹配项的数组，并将其分配给`found`常量。然后我们可以返回一个包含`country`属性的数组，它被分配给`found`中的第一个值。如果`found`的第一个值是空的，我们将默认显示所有北美地区的值。在这种情况下，`na`。
- en: Once we’ve done all of this, we can open our application, click `load()`. When
    selecting any of the other options, the abbreviation is updated accordingly. As
    mentioned previously, optional parameters work best when the final section of
    the route can have a default option. If the optional parameter were to be included
    somewhere in the middle of the route, then any subsequent portions of the route
    would be understood by the routing mechanism as the optional parameter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成所有这些，我们就可以打开我们的应用程序，点击 `load()`。当选择其他任何选项时，缩写会相应更新。正如之前提到的，可选参数在路由的最后一部分可以有一个默认选项时效果最佳。如果可选参数被包含在路由中间的某个位置，那么路由机制将理解随后的路由部分为可选参数。
- en: In this example, we created a new route using double square brackets `[[ ]]`.
    While this example has a long way to go before functioning as a complete store,
    it should illuminate how to use optional parameters in routes. Now that you understand
    optional parameters, let’s see how we can wrangle routes of unknown lengths.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用双方括号 `[[ ]]` 创建了一个新的路由。虽然这个例子距离作为一个完整的存储还有很长的路要走，但它应该可以阐明如何在路由中使用可选参数。现在，既然你已经理解了可选参数，让我们看看我们如何可以处理未知长度的路由。
- en: Rest parameters
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: Just as JavaScript functions can accept rest parameters using the rest operator
    (`…`), so too can our routes. By using a rest operator inside of single square
    brackets, we can allow a variable length on the specified route. This feature
    comes in handy when creating something like a file browser where the URL should
    match a path that then makes the page content shareable via the URL.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 JavaScript 函数可以使用剩余参数操作符（`…`）接受剩余参数一样，我们的路由也可以这样做。通过在单个方括号内使用剩余参数操作符，我们可以允许指定路由具有可变长度。当创建类似文件浏览器这样的东西时，URL
    应该匹配一个路径，然后通过 URL 使页面内容可共享，这个特性非常有用。
- en: 'To see this concept in action, let’s create a `products` route in our store.
    Start by adding `src/routes/store/products/+layout.svelte` so that we may navigate
    products easily:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个概念的实际应用，让我们在我们的存储中创建一个 `products` 路由。首先添加 `src/routes/store/products/+layout.svelte`，这样我们就可以轻松地导航产品：
- en: src/routes/store/products/+layout.svelte
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/products/+layout.svelte
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This Svelte component is rather simple. It consists of a title, an unordered
    list, list items, and links to various products. Again, we’ve used the Svelte
    `<slot />` element to keep the navigation on our page as we click around. Next,
    let’s create an endpoint that can handle the varying lengths of products we’ve
    just provided. To do so, we’ll create a folder using square brackets and prefix
    the directory name with the rest operator. For this example, we’ll use `[...details]`
    as the directory name. Let’s look at the `+page.js` and `+page.svelte` files now:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '这个 Svelte 组件相当简单。它由标题、无序列表、列表项以及指向各种产品的链接组成。同样，我们使用了 Svelte 的 `<slot />` 元素来保持我们在页面上的导航，当我们点击时。接下来，让我们创建一个可以处理我们刚刚提供的不同长度的产品端点。为此，我们将创建一个使用方括号和剩余参数操作符作为目录名称的文件夹。在这个例子中，我们将使用
    `[...details]` 作为目录名称。现在，让我们看看 `+page.js` 和 `+page.svelte` 文件： '
- en: src/routes/store/products/[...details]/+page.js
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/products/[...details]/+page.js
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we’re not building out an entire store, we can keep this one incredibly
    simple. As we’re attempting to showcase how rest parameters work within SvelteKit’s
    routing mechanism, we’ll simply return `params` from `load()`. A more robust and
    practical example might take the value from `params` and use it to filter a list
    of products retrieved from the database. That data could then be returned from
    `load()` for each product to be rendered in the next file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不是构建整个存储，我们可以保持这个存储非常简单。因为我们试图展示 SvelteKit 路由机制中剩余参数的工作方式，我们将在 `load()`
    中简单地返回 `params`。一个更健壮且实用的例子可能会从 `params` 中获取值，并使用它来过滤从数据库检索的产品列表。然后，这些数据可以从 `load()`
    返回，以便在下一个文件中渲染每个产品。
- en: 'Now, to show how the rest parameter value changes, we’ll add the following
    `+page.svelte`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了展示剩余参数值的变化，我们将添加以下 `+page.svelte`：
- en: src/routes/store/products/[...details]/+page.svelte
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/store/products/[...details]/+page.svelte
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, we’re keeping things simple. Instead of showing all of the products that
    could be available in `data`, we’re simply using the Svelte `{#if}` and `{:else}`
    directives to demonstrate how the `details` parameter changes. If `data.details`
    is empty, we show a default message. If it has a value, we show it in bold red
    text. Had we given the directory a different name, that name would be how we accessed
    the parameter. Try clicking some of the links to the various products and notice
    how the URL changes in the browser but so too does the value in red. What happens
    if you add your own values to the URL after `/store/products/`?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '再次强调，我们保持简单。我们不是显示 `data` 中可能可用的所有产品，而是简单地使用 Svelte 的 `{#if}` 和 `{:else}` 指令来演示
    `details` 参数如何变化。如果 `data.details` 为空，我们显示一个默认消息。如果它有值，我们以粗体红色文本显示它。如果我们给目录起了一个不同的名字，那么这个名字就是访问参数的方式。尝试点击一些指向各种产品的链接，注意浏览器中的
    URL 如何变化，红色中的值也是如此。如果你在 `/store/products/` 之后向 URL 添加自己的值会发生什么？ '
- en: With these advanced routing techniques, we have to consider some implications.
    For instance, just as optional parameters work best when at the end section of
    the URL, rest parameters cannot be followed by an optional parameter. If we attempt
    to provide optional routing sections after the rest parameter, they will be consumed
    by the rest parameter. To see the error thrown by the Vite development server,
    try creating an optional directory inside of `/[...details]/`. You won’t have
    to worry about accidentally doing this since Vite will be watching out for you,
    but it’s still good to know about it when planning routes for your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些高级路由技术时，我们必须考虑一些影响。例如，正如可选参数在 URL 的末尾部分工作时效果最佳一样，剩余参数后面不能跟一个可选参数。如果我们尝试在剩余参数之后提供可选路由部分，它们将被剩余参数消耗。要查看
    Vite 开发服务器抛出的错误，尝试在 `/[...details]/` 内创建一个可选目录。你不必担心意外这样做，因为 Vite 会为你留意，但在规划应用程序的路由时了解这一点仍然很重要。
- en: If you find yourself building routes of an unknown length into your application,
    consider creating them using SvelteKit’s rest parameters. Not only do they handle
    those indeterminate lengths, but the logic is easily incorporated into the existing
    flow of SvelteKit apps.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在将未知长度的路由构建到应用程序中，考虑使用 SvelteKit 的剩余参数来创建它们。它们不仅处理那些不确定的长度，而且逻辑可以轻松地融入现有的
    SvelteKit 应用程序流程中。
- en: Matching, sorting, and encoding – oh, my!
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配、排序和编码——哦，我的天啊！
- en: 'If you’re unfamiliar with the ins and outs of SvelteKit’s more advanced routing
    techniques, it can quickly become unwieldy. To get ahead of the unexpected, we’re
    going to look at a few more strategies you can use to ensure your application’s
    routing works as you intend it to. In this section, we will cover how you can
    ensure that parameters are of the type you’re expecting them to be. We’ll then
    examine how SvelteKit handles URLs that can resolve to multiple routes. We’ll
    wrap it up with a bit of information about encoding URLs. You can expect to see
    the following sub-sections:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 SvelteKit 更高级的路由技术细节，它可能会很快变得难以控制。为了应对意外情况，我们将探讨一些你可以使用的策略，以确保你的应用程序的路由按预期工作。在本节中，我们将介绍如何确保参数的类型是你所期望的。然后，我们将检查
    SvelteKit 如何处理可以解析到多个路由的 URL。最后，我们将提供一些关于 URL 编码的信息。你可以期待看到以下子章节：
- en: Matching
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配
- en: Sorting
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Encoding
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码
- en: Once finished, you’ll be one step closer to mastering the routing of SvelteKit
    apps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你将更接近掌握 SvelteKit 应用程序的路由。
- en: Matching
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配
- en: We’ve looked at how we can use optional and rest parameters in our routes. But
    think back to the example we created in [*Chapter 4*](B19024_04_Final_AM.xhtml#_idTextAnchor060)
    dealing with dynamic routes. In the news section, we only checked whether the
    provided `[slug]` parameter existed in our database. If we wanted to ensure that
    the value being passed to our database was in fact a slug, we could create a custom
    matcher to do just that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何在路由中使用可选和剩余参数。但回想一下我们在 [*第 4 章*](B19024_04_Final_AM.xhtml#_idTextAnchor060)
    中创建的示例，它涉及到动态路由。在新闻部分，我们只检查提供的 `[slug]` 参数是否存在于我们的数据库中。如果我们想确保传递给数据库的值实际上是一个 slug，我们可以创建一个自定义匹配器来完成这项工作。
- en: 'To create a matcher with SvelteKit, we add a JS file with a descriptive name
    to `src/params/`. If the directory doesn’t exist yet, don’t fret! You can simply
    go ahead and create it now. The files here export a single function: `match()`.
    That function accepts one string parameter and returns a boolean value. Because
    the value passed to the function is a string, we’ll use **regular expressions**
    (**regex**) to ensure the parameter passed in is of the type we want enforced
    on our route. Regex may seem daunting at first but there exist plenty of tools
    online to assist in the creation and learning of regex rules. See the end of this
    chapter for more resources. Now let’s create a matcher for our news articles to
    ensure they are being passed a proper slug before we perform our database lookup:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SvelteKit 创建匹配器，我们向`src/params/`添加一个具有描述性名称的 JS 文件。如果该目录尚不存在，请不要担心！您现在可以简单地创建它。这里的文件导出一个单个函数：`match()`。该函数接受一个字符串参数并返回一个布尔值。因为传递给函数的值是字符串，我们将使用**正则表达式**（**regex**）来确保传入的参数是我们希望在路由上强制执行的类型。正则表达式可能一开始看起来令人畏惧，但网上有大量工具可以帮助创建和学习正则表达式规则。请参阅本章末尾以获取更多资源。现在让我们为我们的新闻文章创建一个匹配器，以确保在执行数据库查找之前传递了正确的
    slug：
- en: src/params/slug.js
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: src/params/slug.js
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As is clear, matchers need not be overly complicated. It simply needs to export
    the `match()` function, which accepts a string parameter. This matcher then tests
    that string against a regex literal, returning true for a match and false for
    a mismatch. This regex tests for one or more string or number characters followed
    by a `–` character, which must be followed by one or more string or number characters.
    A string ending with a `–` character is considered invalid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，匹配器不需要过于复杂。它只需要导出`match()`函数，该函数接受一个字符串参数。然后，此匹配器将该字符串与正则表达式字面量进行比较，对于匹配返回
    true，对于不匹配返回 false。此正则表达式测试一个或多个字符串或数字字符后跟一个`–`字符，该字符必须后跟一个或多个字符串或数字字符。以`–`字符结尾的字符串被认为是无效的。
- en: Applying matchers
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 应用匹配器
- en: 'When applying a matcher to a specific route, the value following the `=` character
    is the name of the given matcher. Another example may include creating a matcher
    that tests for integers. That rule could be enforced on a dynamic route by setting
    the parameter like so: `[param=integer]` where `params/integer.js` is the name
    of the matcher file.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当将匹配器应用于特定路由时，`=`字符后面的值是给定匹配器的名称。另一个例子可能包括创建一个测试整数的匹配器。该规则可以通过设置参数如下来应用于动态路由：`[param=integer]`，其中`params/integer.js`是匹配器文件的名称。
- en: To apply the matcher we just created to our news articles, we need to rename
    `src/routes/news/[slug]` to `src/routes/news/[slug=slug]`. Once we have adjusted
    the parameter in our route accordingly, we can go back and view our news articles
    just as we did before. Of course, the existing articles will match just fine as
    they contain valid slugs. To test that this matcher is being applied before we
    run our database lookup, we can create a new article in `src/lib/articles.json`.
    The content and title of the new article object are irrelevant but by creating
    an article with an invalid slug, we can confirm the matcher is working. Once you
    have created an article with a bad slug, attempt to view it. You should receive
    a **404 Not Found** error even though the article exists. This is because the
    dynamic parameter passed in did not match our provided regular expression.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们刚刚创建的匹配器应用于我们的新闻文章，我们需要将`src/routes/news/[slug]`重命名为`src/routes/news/[slug=slug]`。一旦我们相应地调整了路由中的参数，我们就可以像之前一样查看我们的新闻文章。当然，现有的文章将匹配得很好，因为它们包含有效的
    slugs。为了测试在运行数据库查找之前是否应用了此匹配器，我们可以在`src/lib/articles.json`中创建一个新文章。新文章对象的内容和标题无关紧要，但通过创建一个具有无效
    slug 的文章，我们可以确认匹配器正在工作。一旦您创建了一个具有不良 slug 的文章，尝试查看它。您应该收到**404 未找到**错误，尽管文章存在。这是因为传递给动态参数的值没有匹配我们提供的正则表达式。
- en: While regular expressions can be intimidating to work with, it’s comforting
    to know that SvelteKit empowers developers to harness the power behind them. Being
    able to do so ensures our applications work as we intend them to. However, there
    may still be instances where SvelteKit routes to an endpoint in an unexpected
    way. To avoid these situations, let’s take a look at which routing rules take
    precedence over others.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正则表达式可能难以处理，但知道 SvelteKit 使开发者能够利用其背后的力量是令人欣慰的。能够这样做确保我们的应用程序按预期工作。然而，仍然可能存在
    SvelteKit 路由以意外方式到达端点的情况。为了避免这些情况，让我们看看哪些路由规则比其他规则具有优先级。
- en: Sorting
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: Since it is entirely possible for a URL to match multiple routes, it’s important
    to understand which routing rules will be executed in which order. Similar to
    how CSS rules are given different weights, so too are the rules in SvelteKit’s
    routing. So which routing rules will be executed when and how do we avoid collisions?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 URL 完全可能匹配多个路由，因此了解哪些路由规则将以何种顺序执行非常重要。类似于 CSS 规则被赋予不同的权重，SvelteKit 的路由规则也是如此。那么，在何时以及如何避免冲突？
- en: More specific routes will always take precedence over less specific routes.
    A route without a parameter is considered the highest level. For example, `src/routes/about/+page.svelte`
    will be executed before `src/routes/[param]/+page.svelte`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更具体的路由总是优先于不那么具体的路由。没有参数的路由被认为是最高级别的。例如，`src/routes/about/+page.svelte` 将在 `src/routes/[param]/+page.svelte`
    之前执行。
- en: Applying a matcher to a dynamic parameter will give it a higher priority than
    those without a matcher. Calling `src/routes/news/[slug=slug]/+page.svelte` will
    be given priority over `src/routes/news/[slug]/+page.svelte`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将匹配器应用于动态参数将赋予它比没有匹配器的参数更高的优先级。调用 `src/routes/news/[slug=slug]/+page.svelte`
    将比 `src/routes/news/[slug]/+page.svelte` 具有更高的优先级。
- en: Optional and rest parameters are given the least preference. If they are not
    the final section of the route, they are ignored. For instance, `src/routes/[x]/+page.svelte`
    will execute before `src/routes/[...rest]/+page.svelte`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选参数和剩余参数的优先级最低。如果它们不是路由的最后一部分，则会被忽略。例如，`src/routes/[x]/+page.svelte` 将在 `src/routes/[...rest]/+page.svelte`
    之前执行。
- en: Tiebreakers are determined by alphabetical order of the parameters. That is,
    `src/routes/[x]/+page.svelte` will execute before `src/routes/[z]/+page.svelte`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冲突解决者由参数的字母顺序决定。也就是说，`src/routes/[x]/+page.svelte` 将在 `src/routes/[z]/+page.svelte`
    之前执行。
- en: If you’re planning to leverage the more advanced routing features of SvelteKit,
    then understanding these rules is an absolute must. Try customizing the routes
    created in your project and adjusting them to create collisions. See if you can
    resolve the collisions yourself or predict which pages will be called before others.
    Next, we’ll look at how to manage special characters in URLs via encoding.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划利用 SvelteKit 更高级的路由功能，那么理解这些规则是绝对必要的。尝试自定义项目中创建的路由，并调整它们以创建冲突。看看你是否能自己解决冲突或预测哪些页面将在其他页面之前被调用。接下来，我们将探讨如何通过编码管理
    URL 中的特殊字符。
- en: Encoding
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: At some point in their career, every developer has encountered issues with encoding,
    yet no one ever takes the time to fully understand them. Since you’re a busy developer,
    eager to get started building, and you probably didn’t pick up this book to get
    lectured about encoding, we’ll keep this short. To prevent serious frustration
    when building routes that make use of special characters, SvelteKit lets us encode
    the routes so they may be used in URLs. Of course, some characters such as **[**
    **]** **(** **)** **#** and **%** have special meanings either in SvelteKit or
    the browser and so they are mostly off limits. However, they can still be used
    when properly encoded in the routing mechanism and URL encoded for the browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的职业生涯中，每个开发者都遇到过编码问题，但没有人花时间去完全理解它们。既然你是一位忙碌的开发者，渴望开始构建，而且你可能不是来这本书上听关于编码的讲座的，所以我们会尽量简短。为了防止在构建使用特殊字符的路由时产生严重的挫败感，SvelteKit
    允许我们编码路由，以便它们可以在 URL 中使用。当然，一些字符，如 **[** **]** **(** **)** **#** 和 **%** 在 SvelteKit
    或浏览器中具有特殊含义，因此它们大多被禁止使用。然而，当在路由机制中正确编码并在浏览器中进行 URL 编码时，它们仍然可以使用。
- en: 'When creating routes with special characters in SvelteKit, the special characters
    are written inside of square brackets `[ ]` similar to how dynamic parameters
    are. However, they are then prefixed by `x+` and followed by the hexadecimal value
    of the character. An example of this is when creating a route to the `/.well-known/`
    directory, which could be represented like so: `src/routes/[x+2e]well-known/+page.svelte`.
    In most cases, there should be no issues with this route and encoding won’t be
    necessary, but we’re using it for demonstration purposes. Go ahead and create
    it in your project. In the browser, navigate to the development site and append
    the `/.well-known/` route to confirm it works. Now try to create the route `/?-help/`.
    Because `src/routes/[x+3f]-help/+page.svelte`. But we won’t be able to access
    the web page at `/?-help/`. Instead, we’ll need to access that particular route
    at `/%3f%-help/`. Whenever using a special character in routes, consider encoding
    it with the hexadecimal values beforehand.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在SvelteKit中创建包含特殊字符的路由时，特殊字符的写法类似于动态参数，放在方括号 `[ ]` 内。然而，它们前面会加上 `x+` 前缀，后面跟着字符的十六进制值。一个例子是在创建指向
    `/.well-known/` 目录的路由时，它可以表示为：`src/routes/[x+2e]well-known/+page.svelte`。在大多数情况下，此路由应该没有问题，编码也不必要，但我们使用它来演示。请继续在你的项目中创建它。在浏览器中，导航到开发站点，并将
    `/.well-known/` 路由附加到地址栏以确认它是否工作。现在尝试创建路由 `/?-help/`。因为 `src/routes/[x+3f]-help/+page.svelte`。但我们将无法访问
    `/?-help/` 的网页。相反，我们需要在 `/%3f%-help/` 访问该特定路由。在路由中使用特殊字符时，请考虑事先使用十六进制值对其进行编码。
- en: 'To obtain the hexadecimal value of a character, you can use the following JS
    snippet: `'':''.charCodeAt(0).toString(16);` where `:` is the special character
    you’d like to retrieve the hexadecimal value for. We’re not limited to only using
    hexadecimal values for simple text either. SvelteKit’s routing also supports `[u+xxxx]`
    where `xxxx` is the Unicode code point.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字符的十六进制值，你可以使用以下JS片段：`':'.charCodeAt(0).toString(16);` 其中 `:` 是你想要获取十六进制值的特殊字符。我们不仅限于只使用十六进制值来处理简单的文本。SvelteKit的路由也支持
    `[u+xxxx]`，其中 `xxxx` 是Unicode码点。
- en: To ensure our application behaves as expected, it’s essential to know how to
    properly encode special characters. We also looked at how we can apply matchers
    to routes so that we can ensure dynamic parameters are of the type we’re expecting
    them to be. And with our cursory glance at how routes are given precedence over
    others, you should feel comfortable exploring even more advanced techniques in
    your application’s routing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的应用程序按预期运行，了解如何正确编码特殊字符是至关重要的。我们还探讨了如何将匹配器应用于路由，以确保动态参数的类型符合我们的预期。并且通过简要了解路由是如何优先于其他路由的，你应该可以放心地在应用程序的路由中探索更高级的技术。
- en: Advanced layouts
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级布局
- en: The more complex the application, the more complex the structure becomes. To
    keep application logic organized we can utilize more advanced routing mechanisms
    such as layout groups and breakouts. By using layout groups, we can organize various
    layout components without cluttering the application URL. And by inserting simple
    syntax into pages and templates, we can break a layout or page out from its hierarchy
    while keeping the structure of our application intact.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序越复杂，其结构也越复杂。为了保持应用程序逻辑的有序性，我们可以利用更高级的路由机制，例如布局组和断开。通过使用布局组，我们可以组织各种布局组件，而不会使应用程序的URL变得杂乱。并且通过在页面和模板中插入简单的语法，我们可以将布局或页面从其层次结构中分离出来，同时保持我们应用程序的结构完整。
- en: Since we organize our application components into logical groupings, it makes
    sense to organize application functionality into logical groupings as well. To
    demonstrate using a real-world example, consider interface components that are
    available to logged-in users but not available to anonymous users. When logged
    in, users can interact with other users through comments, change their profile
    information, or view their own notifications. A user of the site that is not logged
    in should not see any of these components. With what we’ve learned so far about
    layouts, creating different layouts for each type of user could potentially run
    us into the issue of affecting our application’s clean URL. This is where we can
    harness SvelteKit’s layout groups.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将应用程序组件组织成逻辑分组，因此将应用程序功能组织成逻辑分组也是有意义的。为了使用实际示例进行演示，考虑那些仅对已登录用户可用而对匿名用户不可用的界面组件。当用户登录时，他们可以通过评论与其他用户互动，更改他们的个人资料信息或查看自己的通知。未登录的网站用户不应看到这些组件中的任何一项。根据我们到目前为止对布局的了解，为每种类型的用户创建不同的布局可能会使我们遇到影响应用程序干净
    URL 的问题。这就是我们可以利用 SvelteKit 的布局组的地方。
- en: 'When creating a layout group, use parenthesis `( )` to surround the directory
    name. All content inside of that layout group will then be included in the group
    and slotted in the `+layout.svelte` file found there. To demonstrate layout groups,
    we’ll create two groups: `(app)` and `(site)`. Inside of `(app)`, we’ll move logic
    related to the application features, and inside of `(site)`, we’ll move logic
    commonly found in basic websites. Our new `routes` directory structure should
    look similar to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建布局组时，使用括号 `( )` 包围目录名称。该布局组内部的所有内容都将包含在该组中，并槽位在找到那里的 `+layout.svelte` 文件中。为了演示布局组，我们将创建两个组：`(app)`
    和 `(site)`。在 `(app)` 中，我们将移动与应用程序功能相关的逻辑，在 `(site)` 中，我们将移动在基本网站上常见的一些逻辑。我们新的
    `routes` 目录结构应该看起来像这样：
- en: src/routes/
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After shuffling our folders around, we can create a layout for each of our
    new layout groups:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整文件夹后，我们可以为每个新的布局组创建一个布局：
- en: src/routes/(app)/+layout.svelte
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/(app)/+layout.svelte
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this layout file, we’re wrapping all of the content that will be rendered
    in the Svelte `<slot />` directive with another `<div>` element that will apply
    a background color. For simplicity’s sake, we’re only attempting to demonstrate
    how different layout groups work. The next file does exactly the same thing but
    applies a different color:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个布局文件中，我们将要在 Svelte `<slot />` 指令中渲染的所有内容包裹在一个应用背景颜色的 `<div>` 元素中。为了简化，我们只是尝试展示不同的布局组是如何工作的。下一个文件会做完全相同的事情，但应用不同的颜色：
- en: src/routes/(site)/+layout.svelte
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: src/routes/(site)/+layout.svelte
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After saving these layouts, you’ll notice the application shows different background
    colors when navigating the browser to `comment/`, `login/`, `notifications/`,
    and `store/` than it does for `about/`, `fetch/`, and `news/`. However, our URLs
    remain exactly the same!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些布局后，你会注意到当在浏览器中导航到 `comment/`、`login/`、`notifications/` 和 `store/` 时，应用程序显示的背景颜色与导航到
    `about/`、`fetch/` 和 `news/` 时显示的颜色不同。然而，我们的 URL 完全相同！
- en: For cases where want to break a particular layout or page out of the existing
    hierarchy, we can append the `@` character to the filename. For example, `+page@`
    or `+layout@`. We can then follow it up with the name of the directory we would
    like it to inherit directly from. If no name is provided after the `@` character,
    then the root layout will be utilized. We can see this in action by renaming `src/routes/(app)/store/products/[...details]/+page.svelte`
    to `src/routes/(app)/store/products/[...details]/+page@(app).svelte`. Doing so
    moves the product page out of the product and store layouts. Try renaming it to
    `+page@store.svelte` to keep the store layout or `+page@.svelte` to take it all
    the way back to the root layout. Of course, our product links are no longer visible
    as the markup to show them was included in `src/routes/(app)/store/products/+layout.svelte`,
    but we’re only trying to demonstrate how you can break a page out of its immediate
    layouts. This functionality can be useful for separating your application logic
    into administrative or authenticated sections while keeping the URL unaffected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要从现有层次结构中跳出特定布局或页面的情况，我们可以在文件名中附加 `@` 字符。例如，`+page@` 或 `+layout@`。然后我们可以跟随着我们希望它直接继承的目录名称。如果没有提供
    `@` 字符后面的名称，则将使用根布局。我们可以通过将 `src/routes/(app)/store/products/[...details]/+page.svelte`
    重命名为 `src/routes/(app)/store/products/[...details]/+page@(app).svelte` 来看到这个功能的效果。这样做将产品页面从产品和存储布局中移出。尝试将其重命名为
    `+page@store.svelte` 以保留存储布局，或重命名为 `+page@.svelte` 以将其完全返回到根布局。当然，我们的产品链接不再可见，因为显示它们的标记包含在
    `src/routes/(app)/store/products/+layout.svelte` 中，但我们只是试图展示如何跳出页面的直接布局。这个功能对于将应用程序逻辑分离到管理或认证部分，同时保持
    URL 不受影响非常有用。
- en: We’ve just seen how we can break out of layouts using `@` symbols in the Svelte
    component naming conventions. When we include `@` followed by the name of our
    desired layout, the file will inherit directly from the named layout instead of
    all layouts between. We’ve also seen how we can create layout groups to keep our
    project structured without disrupting the application URL. With everything we’ve
    covered, you should be capable of meeting even the most complex routing requirements
    for any SvelteKit project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，如何通过在 Svelte 组件命名约定中使用 `@` 符号来跳出布局。当我们包含 `@` 符号后跟我们想要的布局名称时，文件将直接继承该布局名称，而不是所有布局之间的布局。我们还看到了如何创建布局组以保持我们的项目结构，同时不破坏应用程序的
    URL。涵盖了一切之后，你应该能够满足任何 SvelteKit 项目的最复杂的路由需求。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the chapters leading up to this, we covered core routing concepts. In this
    chapter, we looked at the more advanced techniques available in SvelteKit. These
    techniques can help us further customize our application and address edge cases.
    When it comes to routing, we now have an understanding of how we can create optional
    parameters with default values. We’ve also seen how rest parameters can be used
    to create a shareable URL of unknown lengths. Matching was shown to be useful
    for ensuring our application is receiving parameters of the expected types. We
    also saw how SvelteKit prioritizes certain routing rules over others, which is
    helpful for understanding the order of execution when a URL matches multiple routes.
    After covering how to encode special characters in routes, we looked at how we
    can create layout groups and even break out of the layout hierarchies while keeping
    application logic intact. If you’ve finished this chapter and feel comfortable
    with everything learned, you’ll be able to handle even the strangest of edge cases
    encountered while building the routing of your SvelteKit application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节之前的章节中，我们介绍了核心路由概念。在本章中，我们探讨了 SvelteKit 中可用的更高级技术。这些技术可以帮助我们进一步自定义应用程序并解决边缘情况。在路由方面，我们现在理解了如何创建具有默认值的可选参数。我们还看到了如何使用剩余参数创建未知长度的可共享
    URL。匹配被证明对于确保我们的应用程序正在接收预期类型的参数非常有用。我们还看到了 SvelteKit 如何优先考虑某些路由规则，这对于理解当 URL 匹配多个路由时的执行顺序非常有帮助。在介绍了如何在路由中编码特殊字符之后，我们探讨了如何创建布局组，甚至跳出布局层次结构，同时保持应用程序逻辑完整。如果你完成了这一章，并且对所学内容感到满意，你将能够处理在构建
    SvelteKit 应用程序的路由时遇到的任何最奇怪的边缘情况。
- en: In the next chapter, we’ll take a short break from routing to analyze various
    SvelteKit adapters and the environments they are used in. We’ll also take a closer
    look at page options and attempt to build our application for a production environment
    for the first time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将短暂地休息一下路由，分析各种 SvelteKit 适配器和它们所使用的环境。我们还将更仔细地研究页面选项，并尝试第一次为生产环境构建我们的应用程序。
- en: Resources
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'RegExr – a great site for practicing and learning regex: [https://regexr.com/](https://regexr.com/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RegExr – 一个练习和学习正则表达式的优秀网站：[https://regexr.com/](https://regexr.com/)
- en: 'Unicode standards: [https://www.unicode.org/standard/standard.html](https://www.unicode.org/standard/standard.html)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 标准：[https://www.unicode.org/standard/standard.html](https://www.unicode.org/standard/standard.html)
- en: 'Programming with Unicode: [https://unicodebook.readthedocs.io/index.html](https://unicodebook.readthedocs.io/index.html)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Unicode 编程：[https://unicodebook.readthedocs.io/index.html](https://unicodebook.readthedocs.io/index.html)
- en: Part 3 – Supplemental Concepts
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 - 补充概念
- en: This part aims to cover the additional requisite concepts of SvelteKit. It begins
    by showing you how to produce a build for a production environment with resources
    showing how easily it can be done using SvelteKit’s adapter system. It then covers
    how hooks can be used to manipulate data flowing in and out of a SvelteKit application.
    From there, it addresses how to best import static assets by leveraging Vite.
    Then, it explains the various modules available in SvelteKit that make the entire
    framework possible. The section then covers how to ensure that a SvelteKit application
    can be made available to as many users as possible while boosting search engine
    rankings. Finally, it wraps up with various resources that will prove invaluable
    to any developer attempting to power their next project with SvelteKit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分旨在介绍 SvelteKit 的额外必需概念。它首先向您展示如何使用 SvelteKit 的适配器系统轻松地为生产环境生成构建，并展示了如何做到这一点。然后，它涵盖了如何使用钩子来操作进入和离开
    SvelteKit 应用程序的数据。从那里，它讨论了如何利用 Vite 最好地导入静态资源。然后，它解释了 SvelteKit 中可用的各种模块，这些模块使整个框架成为可能。该部分接着介绍了如何确保
    SvelteKit 应用程序能够提供给尽可能多的用户，同时提高搜索引擎排名。最后，它总结了各种对任何试图用 SvelteKit 为其下一个项目提供动力的开发者都非常有价值的资源。
- en: 'This part has the following chapters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B19024_08_Final_AM.xhtml#_idTextAnchor106), *Builds and Adapters*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19024_08_Final_AM.xhtml#_idTextAnchor106)，*构建和适配器*'
- en: '[*Chapter 9*](B19024_09_Final_AM.xhtml#_idTextAnchor116), *Hooks and Error
    Handling*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19024_09_Final_AM.xhtml#_idTextAnchor116)，*钩子和错误处理*'
- en: '[*Chapter 10*](B19024_10_Final_MA.xhtml#_idTextAnchor125), *Managing Static
    Assets*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19024_10_Final_MA.xhtml#_idTextAnchor125)，*管理静态资源*'
- en: '[*Chapter 11*](B19024_11_Final_AM.xhtml#_idTextAnchor137), *Modules and Secrets*'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19024_11_Final_AM.xhtml#_idTextAnchor137)，*模块和密钥*'
- en: '[*Chapter 12*](B19024_12_Final_AM.xhtml#_idTextAnchor154), *Enhancing Accessibility
    and Optimizing SEO*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19024_12_Final_AM.xhtml#_idTextAnchor154)，*增强可访问性和优化 SEO*'
- en: '[*Appendix*](B19024_13_Final_AM.xhtml#_idTextAnchor163) *Examples and Support*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*附录*](B19024_13_Final_AM.xhtml#_idTextAnchor163) *示例和支持*'
