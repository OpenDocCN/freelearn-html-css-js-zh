<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Making Things Move</h1></div></div></div><p>A pretty picture is just the beginning! The hallmark of taking full advantage of the medium is making visualizations that adapt to new situations. Visualizations that let the user explore our data.</p><p>In this chapter, we'll animate our pictures with the powerful transitions module of d3.js, and will look at some strategies for interacting with the user.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Animating with transitions</h1></div></div></div><p>So far attributes<a id="id240" class="indexterm"/> have been applied instantly, which is great for rendering an image, but what if we want to highlight something with a simple animation? Perhaps we just want a smoother transition from nothing to "Hey, graph!" while loading external data?</p><p>That's where transitions come in. Transitions <a id="id241" class="indexterm"/>use the familiar principle of changing a selection's attributes, except that changes are applied over time.</p><p>To slowly turn a rectangle red, we'd use the following line of code:</p><div><pre class="programlisting">d3.select('rect').transition().style('fill', 'red');</pre></div><p>We start a new transition with <code class="literal">.transition()</code> and then define the final state of each animated attribute. By default, every transition takes 250 milliseconds; you can change the timing with <code class="literal">.duration()</code>. New transitions are executed on all properties simultaneously unless you set a delay using <code class="literal">.delay()</code>.</p><p>Delays are handy when we want to make transitions happen in sequence. Without a delay, they are all executed at the same time, depending on an internal timer.</p><p>For single objects, nested transitions<a id="id242" class="indexterm"/> are much simpler than carefully calibrated delays.</p><p>Take our rectangle example and write something like this in your Chrome console. If you haven't already, you'll need to actually add a rectangle to the page for this to work. Such is life.</p><div><pre class="programlisting">d3.select('rect')
  .transition().style('fill', 'red').attr('x', 200)
  .transition().attr('y', 200)</pre></div><p>Running this code, you'll see the rectangle become red as it moves right by a hundred pixels, then moves downwards by the same distance.</p><p>Capturing <a id="id243" class="indexterm"/>animations in screenshots is tough, but say this is your initial state:</p><div><img src="img/0007OS_04_01.jpg" alt="Animating with transitions"/></div><p>The final state would look like this:</p><div><img src="img/0007OS_04_02.jpg" alt="Animating with transitions"/></div><p>We do realize these are just two squares on a white background, but believe me, the red square is a hundred pixels below and to the right of the black square.</p><p>If you want to do something before a transition begins, or want to listen for it to end, you can use <code class="literal">.each()</code> with the appropriate event type like this:</p><div><pre class="programlisting">rect.transition()
    .style('fill', 'red')
    .each('start', function () { console.log("stahp, you're making me blush"); })
    .each('end', function () { console.log("crap, I'm all red now"); })</pre></div><p>This is handy <a id="id244" class="indexterm"/>for making instant changes before or after a transition. Just keep in mind that transitions run independently and you cannot rely on transitions outside the current callback being in this state or that.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec25"/>Interpolators</h2></div></div></div><p>To calculate values between<a id="id245" class="indexterm"/> the initial and final states of a transition, d3.js uses interpolators—functions mapping the <code class="literal">[0,1]</code> domain to the target range (color, number, or string). Under the hood, scales are based on these same interpolators.</p><p>D3's built-in interpolators can interpolate between almost any two arbitrary values, most often between numbers or colors, but also between strings. This sounds odd at first, but it's actually pretty useful.</p><p>To let d3.js pick the right interpolator for the job, we just write <code class="literal">d3.interpolate(a, b)</code> and the <code class="literal">interpolation</code> function is chosen depending on the type of <code class="literal">b</code>.</p><p>If <code class="literal">b</code> is a number, <code class="literal">a</code> will be coerced into a number and <code class="literal">.interpolateNumber()</code> will be used. You should avoid interpolating to or from a zero value because values will eventually be transformed into a string for the actual attribute and very small numbers might turn into scientific notation. CSS and HTML don't quite understand <code class="literal">1e-7</code> (the digit 1 with seven zeroes in front), so the smallest number you can safely use is <code class="literal">1e-6</code>.</p><p>If <code class="literal">b</code> is a string, d3.js checks whether it's a CSS color, in which case it is transformed to a proper color, just like the ones in <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <em>A Primer on DOM, SVG, and CSS</em>. <code class="literal">a</code> is transformed into a color as well, and then d3.js uses <code class="literal">.interpolateRgb()</code> or a more appropriate interpolator for your color space.</p><p>Something even more amazing happens when the string is not a color. d3.js can handle that too! When it encounters a string, d3.js will parse it for numbers, then use <code class="literal">.interpolateNumber()</code> on each numerical piece of the string. This is useful for interpolating mixed style definitions.</p><p>For instance, to transition a font definition, you might do something like this:</p><div><pre class="programlisting">d3.select('svg')
    .append('text')
    .attr({x: 100, y: 100})
    .text("I'm growing!")
    .transition()
    .styleTween('font', function () {
      return d3.interpolate('12px Helvetica', '36px Comic Sans MS');</pre></div><p>We used <code class="literal">.styleTween()</code> to manually define a transition. It is most useful when we want to define the starting value of a transition without relying on the current state. The first argument defines which style attribute to transition and the second is the interpolator.</p><p>You can use <code class="literal">.tween()</code> to do this for attributes other than style.</p><p>Every numerical <a id="id246" class="indexterm"/>part of the string was interpolated between the starting and ending values, and the string parts changed to their final state immediately. An interesting application of this is interpolating path definitions—you can make shapes change in time. How cool is that?</p><p>Keep in mind that only strings with the same number and location of control points (numbers in the string) can be interpolated. You can't use interpolators for everything. Creating a custom interpolator is as simple as defining a function that takes a single <code class="literal">t</code> parameter and returns the start value for <code class="literal">t = 0</code> and end value for <code class="literal">t = 1</code> and blends values for anything in between.</p><p>For example, the following code shows the <code class="literal">interpolateNumber</code> function of d3.js:</p><div><pre class="programlisting">function interpolateNumber(a, b) {
  return function(t) {
    return a + t * (b - a);
  };
}</pre></div><p>It's as simple as that!</p><p>You can even interpolate whole arrays and objects, which work like compound interpolators of multiple values. We'll use those soon.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Easing</h2></div></div></div><p>Easing tweaks<a id="id247" class="indexterm"/> the behavior of interpolators by controlling the <code class="literal">t</code> argument. We use this to make our animations feel more natural, to add some bounce elasticity, and so on. Mostly we use easing to avoid the artificial feel of linear animation.</p><p>Let's make a quick comparison of the easing functions provided by d3.js and see what they do.</p><p>Don't forget the drawing area! I once spent an hour debugging a graph before realizing there was no <code class="literal">svg</code> element.</p><div><pre class="programlisting">var width = 1024,
  height = 768,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});</pre></div><p>Next, we need an array of easing functions and a scale for placing them along the vertical axis.</p><div><pre class="programlisting">var eases = ['linear', 'poly(4)', 'quad', 'cubic', 'sin', 'exp', 'circle', 'elastic(10, -5)', 'back(0.5)', 'bounce', 'cubic-in', 'cubic-out', 'cubic-in-out', 'cubic-out-in'],
    y = d3.scale.ordinal().domain(eases).rangeBands([50, 500]);</pre></div><p>You'll notice that <code class="literal">poly</code>, <code class="literal">elastic</code>, and <code class="literal">back</code> take arguments; since these are just strings, we'll have to manually change them into real arguments later. The <code class="literal">poly</code> easing function is just a polynomial, so <code class="literal">poly(2)</code> is equal to <code class="literal">quad</code> and <code class="literal">poly(3)</code> is equal to <code class="literal">cubic</code>.</p><p>The <code class="literal">elastic</code> easing function<a id="id248" class="indexterm"/> simulates an elastic and the two arguments control tension. I suggest playing with the values to get the effect you want.</p><p>The <code class="literal">back</code> easing function<a id="id249" class="indexterm"/> is supposed to simulate backing into a parking space. The argument controls how much overshoot there's going to be.</p><p>The nonsense at <a id="id250" class="indexterm"/>the end (<code class="literal">cubic-in</code>, <code class="literal">cubic-out</code>, and so on) is a list of the easing functions we create ourselves by combining the following modifiers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-in</code>: It does nothing</li><li class="listitem" style="list-style-type: disc">-<code class="literal">out</code>: It reverses the easing direction</li><li class="listitem" style="list-style-type: disc">-<code class="literal">in-out</code>: It copies and mirrors the easing function from <code class="literal">[0, 0.5]</code> and <code class="literal">[0.5, 1]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">-out-in</code>: It copies and mirrors the easing function from <code class="literal">[1, 0.5]</code> and <code class="literal">[0.5, 0]</code></li></ul></div><p>You can add these to any easing function, so play around. Time to render a circle flying towards the right for every function in the list:</p><div><pre class="programlisting">eases.forEach(function (ease) {
  var transition = svg.append('circle')
    .attr({cx: 130,
      cy: y(ease),
      r: y.rangeBand()/2-5})
    .transition()
    .delay(400)
    .duration(1500)
    .attr({cx: 400});
});</pre></div><p>We loop over the list with an iterator that creates a new circle and uses the <code class="literal">y()</code> scale for vertical placement and <code class="literal">y.rangeBand()</code> for circle size. This way, we can add or remove examples easily. Transitions will start with a delay of just under half a second to give us a chance to see what's going on. A duration of <code class="literal">1500</code> milliseconds and a final position of <code class="literal">400</code> should give enough time and space to see the easing.</p><p>We define the easing at the end of this function, before the <code class="literal">});</code> bit:</p><div><pre class="programlisting">if (ease.indexOf('(') &gt; -1) {
    var args = ease.match(/[0-9]+/g),
      type = ease.match(/^[a-z]+/);

    transition.ease(type, args[0], args[1]);
  }else{
    transition.ease(ease);
  }</pre></div><p>This code <a id="id251" class="indexterm"/>checks for parentheses in the <code class="literal">ease</code> string, parses out the easing function and its arguments, and feeds them to <code class="literal">transition.ease()</code>. Without parentheses, <code class="literal">ease</code> is just the easing type.</p><p>Let's add some text so we can tell the examples apart:</p><div><pre class="programlisting">svg.append('text')
    .text(ease)
    .attr({x: 10,
        y: y(ease)+5});</pre></div><p>The visualization is a cacophony of dots:</p><div><img src="img/0007OS_04_03.jpg" alt="Easing"/></div><p>The screenshot doesn't quite showcase the animation, so you should really try this one in the browser. Or you can take a look at the easing curves at <a class="ulink" href="http://easings.net/">http://easings.net/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Timers</h2></div></div></div><p>To schedule <a id="id252" class="indexterm"/>transitions, d3.js uses timers. Even an immediate transition will start after a delay of 17 ms.</p><p>Far from keeping timers all to itself, d3.js lets us use timers so that we can take animation beyond the two-keyframe model of transition. For those of us who aren't animators, keyframes define the start or end of a smooth transition.</p><p>To create a timer, we use <code class="literal">d3.timer()</code>. It takes a function, a delay, and a starting mark. After the set delay (in milliseconds) from the mark, the function will be executed repeatedly until it returns <code class="literal">true</code>. The mark should be a date converted into milliseconds since Unix epoch (<code class="literal">Date.getTime()</code> will do), or you can let d3.js use <code class="literal">Date.now()</code> by default.</p><p>Let's animate the drawing of a parametric function to work just like the Spirograph toy you might have had as a kid.</p><p>We'll create a timer, let it run for a few seconds, and use the millisecond mark as the parameter for a parametric function.</p><p>First we need a drawing area:</p><div><pre class="programlisting">var width = 600,
  height = 600,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
              height: height});</pre></div><p>I found a good function in Wikipedia's article on parametric equations at <a class="ulink" href="http://en.wikipedia.org/wiki/Parametric_equations">http://en.wikipedia.org/wiki/Parametric_equations</a>.</p><div><pre class="programlisting">var position = function (t) {
  var a = 80, b = 1, c = 1, d = 80;

  return {x: Math.cos(a*t) - Math.pow(Math.cos(b*t), 3),
          y: Math.sin(c*t) - Math.pow(Math.sin(d*t), 3)};
};</pre></div><p>This function will return a mathematical position based on the parameter going from zero up. You can tweak the Spirograph by changing the <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and <code class="literal">d</code> variables—examples in the same Wikipedia article.</p><p>This function returns positions between <code class="literal">-2</code> and <code class="literal">2</code>, so we need some scales to make it visible on the screen:</p><div><pre class="programlisting">var t_scale = d3.scale.linear().domain([500, 25000]).range([0, 2*Math.PI]),
  x = d3.scale.linear().domain([-2, 2]).range([100, width-100]),
  y = d3.scale.linear().domain([-2, 2]).range([height-100, 100]);</pre></div><p>
<code class="literal">t_scale</code> will <a id="id253" class="indexterm"/>translate time into parameters for the function; <code class="literal">x</code> and <code class="literal">y</code> will calculate the final position on the image.</p><p>Now we need to define <code class="literal">brush</code> to fly around and pretend it's drawing and a variable to hold the <code class="literal">previous</code> position so that we can draw straight lines.</p><div><pre class="programlisting">var brush = svg.append('circle')
    .attr({r: 4}),
  previous = position(0);</pre></div><p>Next, we need to define an animation <code class="literal">step</code> function that moves the brush and draws a line between the previous and current points:</p><div><pre class="programlisting">var step = function (time) {
  if (time &gt; t_scale.domain()[1]) {
    return true;
  }

  var t = t_scale(time),
    pos = position(t);

  brush.attr({cx: x(pos.x),
              cy: y(pos.y)});
  svg.append('line')
    .attr({x1: x(previous.x),
           y1: y(previous.y),
           x2: x(pos.x),
           y2: y(pos.y),
           stroke: 'steelblue',
           'stroke-width': 1.3});

  previous = pos;
};</pre></div><p>The first condition stops the timer when the current value of the <code class="literal">time</code> parameter is beyond the domain of <code class="literal">t_scale</code>. Then, we use <code class="literal">t_scale()</code> to translate the time into our parameter and get a new position for the brush.</p><p>Then, we move the brush—there is no transition because <em>we</em> are performing the transition—and draw a new steelblue line between the previous and current position (<code class="literal">pos</code>).</p><p>We conclude by setting a new value for the previous position.</p><p>All that's left now is creating a timer:</p><div><pre class="programlisting">var timer = d3.timer(step, 500);</pre></div><p>That's it. Half a second after a page refresh, the code will begin drawing a beautiful shape and finish 25 seconds later.</p><p>Starting out, it looks like this:</p><div><img src="img/0007OS_04_04.jpg" alt="Timers"/></div><p>Getting the <a id="id254" class="indexterm"/>whole picture takes a while, so this probably isn't the best way to draw <a id="id255" class="indexterm"/>Spirographs. Since we're using time as a parameter, a smoother curve (more points) takes more time.</p><p>Another problem is that lagging computers or slower machines will affect the final outcome of the animation.</p><p>A reader wrote a version without these problems and put the code on Github at <a class="ulink" href="https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js">https://github.com/johnaho/d3.js-book-examples/blob/master/ch4/timers.js</a>.</p><div><img src="img/0007OS_04_05.jpg" alt="Timers"/></div><p>But both versions of the code will eventually come up with a beautiful flower. When I wrote this code, I spent an hour just marveling at the drawing process and tweaking the parameters to see what happens.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Interacting with the user</h1></div></div></div><p>Great visualizations don't just stop at<a id="id256" class="indexterm"/> pretty pictures and animations! They give users the power to play with data and figure things out on their own. That's what we'll look into next.</p><p>You don't know it yet, but you already know how to let users interact with visualizations.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Basic interaction</h2></div></div></div><p>Much like with other UI libraries, <a id="id257" class="indexterm"/>the principle for interaction is simple—attach an event listener to an element and do something when it's triggered. We add and remove listeners to and from selections with the <code class="literal">.on()</code> method, an event type (for instance, <code class="literal">click</code>), and a listener function that is executed when the event is triggered.</p><p>We can set a capture flag, which ensures our listener is called first and all other listeners wait for our listener to finish. Events bubbling up from children elements will not trigger our listener.</p><p>You can rely on the fact there will only ever be a single listener for a particular event on an element because old listeners for the same event are removed when new ones are added. This is very useful for avoiding unpredictable behavior.</p><p>Just like other functions acting on element selections, event listeners get the current datum and index and set the <code class="literal">this</code> context to the DOM element. The global <code class="literal">d3.event</code> will let you access the actual event object.</p><p>Let's play around with these principles and a simple visualization using mouse clicks and finger touches. Yes, d3.js has some support for touch devices, but it doesn't always work perfectly.</p><p>As always, begin with a drawing area:</p><div><pre class="programlisting">var width = 1024,
  height = 768,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});</pre></div><p>Next, we create a function that will emulate ripples in a pond using three circles; you might need some imagination:</p><div><pre class="programlisting">var radiate = function (pos) {
  d3.range(3).forEach(function (d) {
    svg.append('circle')
      .attr({cx: pos[0],
             cy: pos[1],
             r: 0})
      .style('opacity', '1')
      .transition()
      .duration(1000)
      .delay(d*50)
       .attr('r', 50)
       .style('opacity', '0.00001')
       .remove();
  });
};</pre></div><p>The<a id="id258" class="indexterm"/> <code class="literal">radiate</code> function <a id="id259" class="indexterm"/>creates three circles centered around a position, defined by a two-element array—[x, y]. A transition will grow the circles, reduce their opacity, and in the end, remove them. We used <code class="literal">.delay</code> to ensure the circles don't overlap, which creates the rippling illusion.</p><p>Now for the fun part:</p><div><pre class="programlisting">svg.on('click', function () {
  radiate(d3.mouse(this));
});

svg.on('touchstart', function () {
  d3.touches(this).map(radiate);
});</pre></div><p>We used <code class="literal">.on()</code> once for each type of event we want to make ripples for—the familiar <code class="literal">click</code> event first and then the possibly less familiar <code class="literal">touchstart</code>. The <code class="literal">touchstart</code> event is triggered when a finger touches the screen; think of it as the <code class="literal">mousedown</code> event of touch. Other useful touch events are <code class="literal">touchmove</code>, <code class="literal">touchend</code>, <code class="literal">touchcancel</code>, and <code class="literal">tap</code>. Mozilla's documentation explains touch events in more detail at <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events">https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Events/Touch_events</a>.</p><p>The <code class="literal">click</code> listener uses <code class="literal">d3.mouse()</code> to get the cursor's position relative to the container element, and the <code class="literal">touchstart</code> listener maps through a list of all touches. In theory, this will draw several ripples if you smoosh your whole hand on the screen, but I was unable to get this working on any of my devices.</p><p>Make the ripples pretty with some styling:</p><div><pre class="programlisting">&lt;style&gt;
circle {
  fill: none;
  stroke: red;
  stroke-width: 2;
}
&lt;/style&gt;</pre></div><p>Clicking around makes ripples!</p><div><img src="img/0007OS_04_06.jpg" alt="Basic interaction"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Behaviors</h2></div></div></div><p>Sometimes, you want <a id="id260" class="indexterm"/>more than to just let the user click around<a id="id261" class="indexterm"/> like a madman; you want drag-and-drop and zoom-in and zoom-out stuff!</p><p>You can make all this with just click events, but I heartily recommend d3's behaviors module. It makes complex behaviors as simple as calling the right function on some elements.</p><p>Currently, d3.js supports only <code class="literal">drag</code> and <code class="literal">zoom</code>, but I am hopeful that more are on the way. The main benefit of behaviors is that they automatically create relevant event listeners and let you work at a higher level of abstraction.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Drag</h3></div></div></div><p>I can't think of a better <a id="id262" class="indexterm"/>dragging demonstration<a id="id263" class="indexterm"/> than animating with the parallax illusion. The illusion works by having several keyframes rendered in vertical slices and dragging a screen over them to create an animated thingamabob.</p><p>Drawing the lines by hand would be tedious, so we're using an image <em>Marco Kuiper</em> created in Photoshop. I asked on Twitter and he said we can use the image, if we check out his other work at <a class="ulink" href="http://marcofolio.net">marcofolio.net</a>.</p><div><img src="img/0007OS_04_07.jpg" alt="Drag"/></div><p>You can also get the image in the examples repository at <a class="ulink" href="https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png">https://raw.github.com/Swizec/d3.js-book-examples/master/ch4/parallax_base.png</a>.</p><p>We need somewhere to put the parallax:</p><div><pre class="programlisting">var width = 1200,
  height = 450,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});</pre></div><p>We'll use SVG's native support for embedding bitmaps to insert <code class="literal">parallax_base.png</code> into the page:</p><div><pre class="programlisting">svg.append('image')
  .attr({'xlink:href': 'parallax_base.png',
          width: width,
          height: height});</pre></div><p>The <code class="literal">image</code> element's <a id="id264" class="indexterm"/>magic stems from its <code class="literal">xlink:href</code> attribute. It <a id="id265" class="indexterm"/>understands links and even lets us embed images to create self-contained SVGs. To use that, you would prepend an image MIME type to a base64 encoded representation of the image.</p><p>For instance, the following line is the smallest embedded version of a spacer GIF. Don't worry if you don't know what a spacer GIF is; they were useful up to about 2005.</p><div><pre class="programlisting">data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==</pre></div><p>Anyway, now that we have the animation base, we need a screen that can be dragged. It's going to be a bunch of carefully calibrated vertical lines:</p><div><pre class="programlisting">var screen_width = 900,
  lines = d3.range(screen_width/6),
  x = d3.scale.ordinal().domain(lines).rangeBands([0, screen_width]);</pre></div><p>We'll base the screen off an array of numbers (<code class="literal">lines</code>). Since line thickness and density are very important, we divide <code class="literal">screen_width</code> by <code class="literal">6</code>—five pixels for a line and one for spacing. Make sure the value of <code class="literal">screen_width</code> is a multiple of 6; otherwise anti-aliasing ruins the effect.</p><p>The <code class="literal">x</code> scale will help us place the lines evenly:</p><div><pre class="programlisting">svg.append('g')
  .selectAll('line')
  .data(lines)
  .enter()
  .append('line')
  .style('shape-rendering', 'crispEdges')
  .attr({stroke: 'black',
        'stroke-width': x.rangeBand()-1,
         x1: function (d) { return x(d); },
         y1: 0,
         x2: function (d) { return x(d); },
         y2: height});</pre></div><p>There's nothing <a id="id266" class="indexterm"/>particularly interesting here, just stuff you already <a id="id267" class="indexterm"/>know. The code goes through the array and draws a new vertical line for each entry. We made absolutely certain there won't be any anti-aliasing by setting <code class="literal">shape-rendering</code> to <code class="literal">crispEdges</code>.</p><p>Time to define and activate a dragging behavior for our group of lines:</p><div><pre class="programlisting">var drag = d3.behavior.drag()
    .origin(Object)
    .on('drag', function () {
         d3.select(this)
           .attr('transform', 'translate('+d3.event.x+', 0)')
           .datum({x: d3.event.x, y: 0});
    });</pre></div><p>We created the behavior with <code class="literal">d3.behavior.drag()</code>, defined a <code class="literal">.origin()</code> accessor, and specified what happens on drag. The behavior automatically translates touch and mouse events to the higher-level drag event. How cool is that!</p><p>We need to give the behavior an origin so it knows how to calculate positions relatively; otherwise, the current position is always set to the mouse cursor and objects jump around. It's terrible. <code class="literal">Object</code> is the identity function for elements and assumes a datum with <em>x</em> and <em>y</em> coordinates.</p><p>The heavy lifting happens inside the <code class="literal">drag</code> listener. We get the screen's new position from <code class="literal">d3.event.x</code>, move the screen there, and update the attached <code class="literal">.datum()</code> method.</p><p>All that's left to do is to call <code class="literal">drag</code> and make sure to set the attached datum to the current position:</p><div><pre class="programlisting">svg.select('g')
  .datum({x: 0, y: 0})
  .call(drag);</pre></div><p>The item looks solid now! Try dragging the screen at different speeds.</p><div><img src="img/0007OS_04_08.jpg" alt="Drag"/></div><p>The parallax effect <a id="id268" class="indexterm"/>doesn't work very well on a retina display because <a id="id269" class="indexterm"/>the base image gets resized and our screen loses calibration.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Zoom</h3></div></div></div><p>Despite the name, the zoom behavior<a id="id270" class="indexterm"/> lets you do more than just zoom—you can also pan! Like the <a id="id271" class="indexterm"/>drag behavior, zoom automatically handles both mouse and touch events and then triggers the higher-level zoom event. Yes, this means pinch-to-zoom works! That's pretty awesome if you ask me.</p><p>Remember that map from <a class="link" href="ch03.html" title="Chapter 3. Making Data Useful">Chapter 3</a>, <em>Making Data Useful</em>? The one with airports on a world map? That one.</p><p>Let's commit a crime against computational efficiency and make it zoom and pan.</p><p>I am warning you this will be very rudimentary and painfully slow. This is not how you'd make a real explorable map, just an example to let us play with zooming. In real life you should use tiling, progressive detailing, and other tricks.</p><p>To make this a bit more bearable, you should disable water and urban areas. Comment out <code class="literal">add_to_map</code> calls for rivers, lakes, and oceans roughly on lines 30, 36, and 42 in the JavaScript code.</p><p>Your map <a id="id272" class="indexterm"/>becomes <a id="id273" class="indexterm"/>much simpler:</p><div><img src="img/0007OS_04_09.jpg" alt="Zoom"/></div><p>The biggest effect comes from removing large areas, so if you remove land as well, the map will be surprisingly performant but quite useless.</p><p>Jump to the end of <code class="literal">draw_airlines</code> and add a call to <code class="literal">zoomable</code>; we'll define this next:</p><div><pre class="programlisting">  zoomable(airports, R, routes);</pre></div><p>
<code class="literal">zoomable</code> needs <code class="literal">airports</code>, <code class="literal">R_scale</code>, and <code class="literal">routes</code> data to resize the circles when zooming:</p><div><pre class="programlisting">function zoomable(airports, R_scale, routes) {
  svg.call(
    d3.behavior.zoom()
      .translate(projection.translate())
      .scale(projection.scale())
      .on('zoom', function () {
                onzoom(airports, R_scale, routes);
    })
  );
}</pre></div><p>We defined a zoom behavior with <code class="literal">d3.behavior.zoom()</code> and immediately called it on the whole image.</p><p>We set the <a id="id274" class="indexterm"/>current <code class="literal">.translate()</code> vector and <code class="literal">.scale()</code> to whatever the projection <a id="id275" class="indexterm"/>was using. The zoom event will call our <code class="literal">onzoom</code> function.</p><p>Let's define it:</p><div><pre class="programlisting">function onzoom(airports, R_scale, routes) {
  projection
    .translate(d3.event.translate)
    .scale(d3.event.scale);

  d3.selectAll('path')
    .attr('d', d3.geo.path().projection(projection));</pre></div><p>First we told our projection the new translation vector is in <code class="literal">d3.event.translate</code>. The translation vector will pan the map with a transformation, just like in <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <em>A Primer on DOM, SVG, and CSS</em>. <code class="literal">d3.event.scale</code> is just a number the projection uses to scale itself, effectively zooming the map.</p><p>Then, we recalculated all the paths with a new <code class="literal">d3.geo.path()</code> using the changed projection.</p><div><pre class="programlisting">  d3.selectAll('circle')
    .attr('transform', function (id) {
        var airport = airports[id];
        return "translate("+projection([airport.lon, airport.lat])+")";
    })
    .attr('r', function (id) {
      if (routes[id]) {
        var magnifier = d3.event.scale/1200;
        return magnifier*R_scale(routes[id].length);
      }else{
    return 1;
    }
  });
}</pre></div><p>The same approach works for circles. Take the new info, select all the circles, and change their attributes.</p><p>The positioning function is exactly the same as in <code class="literal">draw_airlines</code> because geographic projections handle panning out of the box. Adjusting size takes a bit more work.</p><p>After calculating a magnifier as a ratio between the current and default scale (<code class="literal">1200</code>), we use <code class="literal">R_scale</code> to get the circle's normal size and multiply it by the magnifier.</p><p>You can now explore the world!</p><p>Have patience,<a id="id276" class="indexterm"/> though, it's slow. Redrawing everything on every move will do that.</p><p>For a more performant zoomable <a id="id277" class="indexterm"/>map, we'd have to use data with less detail when zoomed out, draw a sensible number of airports, and possibly avoid drawing parts of the map that fall out of the image anyway.</p><div><img src="img/0007OS_04_10.jpg" alt="Zoom"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Brushes</h3></div></div></div><p>Similar to zoom and drag, <a id="id278" class="indexterm"/>brushes <a id="id279" class="indexterm"/>are a simple way to create complex behavior—they enable users to select a part of the canvas.</p><p>Strangely enough, they aren't considered a behavior, but fall under the <code class="literal">.svg</code> namespace, perhaps because they are mostly meant for visual effects.</p><p>To create a new brush, we'd call <code class="literal">d3.svg.brush()</code> and define its x and y scales using <code class="literal">.x()</code> and <code class="literal">.y()</code>. We can also define a bounding rectangle.</p><p>Time for an example!</p><p>We're going to make a scatterplot of some random data and let the user select points. Begin with a drawing area and some data:</p><div><pre class="programlisting">var width = 600,
  height = 600,
  svg = d3.select('#graph')
    .append('svg')
    .attr({width: width,
           height: height});

var random = d3.random.normal(.5, .11),
  data = d3.range(800).map(function (i) {
    return {x: random(),
            y: random()};
});</pre></div><p>We used a built-in <a id="id280" class="indexterm"/>random <a id="id281" class="indexterm"/>generator to create numbers with a <code class="literal">normal</code> distribution centered around <code class="literal">.5</code> and a dispersion of <code class="literal">.11</code>. d3.js also gives us the <code class="literal">logNormal</code> and <code class="literal">irwinHall</code> distributions.</p><p>We now have an array of 800 random two-dimensional positions. To draw them, we'll use two scales to make the tiny range more visible, then place each datum on the page as a circle.</p><div><pre class="programlisting">var x = d3.scale.linear()
    .range([50, width-50]),
  y = d3.scale.linear()
    .range([height-50, 50]);

svg.append('g')
  .classed('circles', true)
  .selectAll('circle')
  .data(data)
  .enter()
  .append('circle')
  .attr({cx: function (d) { return x(d.x); },
         cy: function (d) { return y(d.y); },
         r: 4});</pre></div><p>I know we don't usually add axes in this book, but scatterplots look ridiculous without them. Let's add some:</p><div><pre class="programlisting">svg.append('g')
  .classed('axis', true)
  .attr('transform', 'translate(50, 0)')
  .call(d3.svg.axis().orient('left').scale(y));

svg.append('g')
  .classed('axis', true)
  .attr('transform', 'translate(0, '+(height-50)+')')
  .call(d3.svg.axis().orient('bottom').scale(x));</pre></div><p>You should remember what's going on here from <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <em>A Primer on DOM, SVG, and CSS</em>, where we discussed axes at length.</p><p>Add some basic styling to the HTML:</p><div><pre class="programlisting">&lt;style&gt;
  .axis path,
  .axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}
&lt;/style&gt;</pre></div><p>And<a id="id282" class="indexterm"/> yay, <a id="id283" class="indexterm"/>scatterplot!</p><div><img src="img/0007OS_04_11.jpg" alt="Brushes"/></div><p>Now for the fun stuff:</p><div><pre class="programlisting">svg.append("g")
  .classed("brush", true)
  .call(d3.svg.brush().x(x).y(y)
  .on("brushstart", brushstart)
  .on("brush", brushmove)
  .on("brushend", brushend));</pre></div><p>We made a new grouping element for the brush and called a freshly constructed <code class="literal">d3.svg.brush()</code> with both scales defined. The <code class="literal">"brush"</code> class will help with styling. Finally, we defined listeners for <code class="literal">brusthstart</code>, <code class="literal">brush</code>, and <code class="literal">brushend</code> events.</p><div><pre class="programlisting">function brushstart() {
  svg.select('.circles')
    .classed('selecting', true);
}</pre></div><p>
<code class="literal">brushstart</code> flicks the styling to <code class="literal">selecting</code>. We'll use it to help the user distinguish between selected and unselected circles:</p><div><pre class="programlisting">function brushmove() {
  var e = d3.event.target.extent();

  svg.selectAll('circle')
    .classed("selected", function(d) {
        return e[0][0] &lt;= d.x &amp;&amp; d.x &lt;= e[1][0]
        &amp;&amp; e[0][1] &lt;= d.y &amp;&amp; d.y &lt;= e[1][1];
    });
}</pre></div><p>
<code class="literal">brushmove</code> is where the real magic happens.</p><p>First, we find the <a id="id284" class="indexterm"/>selection's <a id="id285" class="indexterm"/>boundaries using <code class="literal">d3.event.target.extent()</code>. <code class="literal">d3.event.target</code> returns the current brush and <code class="literal">.extent()</code> returns a set of two points—upper-left and bottom-right corner.</p><p>Then, we go through all the circles and turn the <code class="literal">selected</code> class on or off, depending on whether a circle's position lies within the bounding box:</p><div><pre class="programlisting">function brushend() {
  svg.select('.circles')
    .classed('selecting', !d3.event.target.empty());
}</pre></div><p>
<code class="literal">brushend</code> just turns off the selecting state if the selection is empty.</p><p>Our HTML needs some more styling definitions:</p><div><pre class="programlisting">.brush .extent {
  stroke: #fff;
  fill-opacity: .125;
  shape-rendering: crispEdges;
}

circle {
  -webkit-transition: fill-opacity 125ms ease-in-out;
}

.selecting circle {
  fill-opacity: 0.25;
}

circle.selected {
  stroke: red;
}</pre></div><p>We're changing the <a id="id286" class="indexterm"/>opacity of the circle fill (<code class="literal">fill-opacity)</code> rather than for the borders so that the circle edges always shine out at full opacity. Adding a CSS transition gives everything a smoother feel.</p><p>In this case, we prefer CSS transitions over what d3.js can do, so we can limit JavaScript to changing element states. Brushes sometimes also have problems with d3.js transitions and change properties immediately.</p><p>When you select some elements, the image will look like this:</p><div><img src="img/0007OS_04_12.jpg" alt="Brushes"/></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Summary</h1></div></div></div><p>Wow, what a fun chapter!</p><p>You've made things jump around the page, almost killed your computer and patience with a zoomable map, and created a spinning thingy out of nothing but vertical lines.</p><p>This is everything you need for visualizations users can play with. The rest is just experimentation and some ingenuity in piecing things together. Good luck!</p></div></div>
</body></html>