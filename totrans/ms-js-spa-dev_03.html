<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;SPA Essentials &#x2013; Creating the Ideal Application Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. SPA Essentials – Creating the Ideal Application Environment</h1></div></div></div><p>You should now be fairly comfortable working within the Node.js ecosystem of modules, tasks, and package management. In this chapter, we will dive a bit deeper into the intricacies of a JavaScript SPA and its dependencies. We will explore various data formats and database types, SPA encapsulation architectural patterns, and more through the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSON and other data formats</li><li class="listitem" style="list-style-type: disc">The differences between SQL and NoSQL databases</li><li class="listitem" style="list-style-type: disc">When to use SQL versus NoSQL databases</li><li class="listitem" style="list-style-type: disc">Methods of presenting a single page application container</li><li class="listitem" style="list-style-type: disc">Serving and managing layouts</li></ul></div><div class="section" title="The JSON data format"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>The JSON data format</h1></div></div></div><p>
<span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>) is something that most JavaScript developers today are quite familiar with. Despite its name, JSON is a language-independent standard that is really just a text document, and it must first be parsed by JavaScript, or any language interpreter, before it can be used as data representing objects with name-value pairs, or as simple sequences of values.</p><p>The reason the JSON acronym includes the word <span class="emphasis"><em>JavaScript</em></span> is because its formatting is based on the structure of JavaScript objects and arrays. This is why working with JSON data and JavaScript is so straightforward, and why it makes a lot of sense to consume JSON data from within JavaScript applications.</p><p>The contents of the <code class="literal">user.json</code> file we created in <span class="emphasis"><em>
<a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>
</em></span>, <span class="emphasis"><em>Model-View-Whatever</em></span> is an example of the JSON data interchange format:</p><pre class="programlisting">{ &#13;
    "id": 1, &#13;
    "name": { &#13;
        "first": "Philip", &#13;
        "last": "Klauzinski" &#13;
    }, &#13;
    "title": "Sr. UI Engineer", &#13;
    "website": "http://webtopian.com" &#13;
} &#13;
</pre><p>JSON follows the format of standard JavaScript objects, but must also adhere to a few important rules to be valid:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Property names must be formatted as strings in double quotes</li><li class="listitem" style="list-style-type: disc">A value can be a string in double quotes, a number, <code class="literal">true</code> or <code class="literal">false</code>, an object, or an array</li><li class="listitem" style="list-style-type: disc">Objects and arrays can be nested</li><li class="listitem" style="list-style-type: disc">Double quotes contained within a string must be escaped using backslashes</li></ul></div><p>These rules allow the JSON format to be parsed directly to native JavaScript while still being strict enough to make it an easily interchangeable format across languages. Although native JavaScript object notation does not enforce the use of double quotes around property names, it is required for JSON in order to prevent JavaScript reserved word exceptions from occurring.</p><p>Reserved words in JavaScript are not allowed to be used as variable or function names because they represent some current or potential future construct of the language. For example, the reserved word <code class="literal">class</code> is often misused by inexperienced developers as a variable name for holding a CSS class:</p><pre class="programlisting">Var class = 'myClass'; &#13;
</pre><p>This example would throw an exception because <code class="literal">class</code> is a reserved word. Additionally, using it as a straight property name in a JavaScript object would throw an exception:</p><pre class="programlisting">{ &#13;
    class: 'myClass' &#13;
} &#13;
</pre><p>An experienced JavaScript developer would know not to use this word as a property name due to it being a reserved word, but if your application is consuming JSON data from an external source, you have no control over the property names that may be pulled in with an object. For example, you may retrieve data from an application running on another server that is not JavaScript and has no awareness of the reserved word restrictions of any other application that may consume it. If this application wants to convey CSS class information, it is likely that it may use the word <code class="literal">"class"</code> to do so:</p><pre class="programlisting">{ &#13;
    "class": "myClass" &#13;
} &#13;
</pre><p>In this example, the property name is valid because it is in double quotes and thereby parsed as a string instead of as a reserved word. For this reason, the rule requiring double quotes around property names is strictly enforced, and no JSON parser will allow property names without them.</p><div class="section" title="Other data formats"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Other data formats</h2></div></div></div><p>JSON was first conceived of in 2001 by Douglas Crockford. Before then, data interchange had long been a practice using established formats that were already integrated with many programming languages.</p><div class="section" title="XML"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>XML</h3></div></div></div><p>Long before JSON was commonly known, <span class="strong"><strong>Extensible Markup Language</strong></span> (<span class="strong"><strong>XML</strong></span>) was one of the most widely used web application data interchange formats. XML was first introduced in 1996 and would become an international standard. It is a form of <span class="strong"><strong>Standard Generalized Markup Language</strong></span> (<span class="strong"><strong>SGML</strong></span>) and was created by the <span class="strong"><strong>World Wide Web Consortium</strong></span> (<span class="strong"><strong>W3C</strong></span>):</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &#13;
&lt;note&gt; &#13;
    &lt;to&gt;Tobums Kindermeyer&lt;/to&gt; &#13;
    &lt;from&gt;Jarmond Dittlemore&lt;/from&gt; &#13;
    &lt;heading&gt;A Message&lt;/heading&gt; &#13;
    &lt;body&gt;Hello world!&lt;/body&gt; &#13;
&lt;/note&gt; &#13;
 &#13;
</pre><p>This is a simple example of a XML document. If you haven't worked with XML before, you most likely have at least heard of it. XML was a precursor to many other data formats, including SOAP, RSS, Atom, and XHTML. XHTML is also well known to many web developers, and it was the recommended standard for serving web pages before the HTML5 specification was introduced. Notice that the formatting of the preceding example is similar to HTML.</p></div><div class="section" title="YAML"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>YAML</h3></div></div></div><p>YAML is a recursive acronym, meaning it refers to itself, for <span class="emphasis"><em>YAML Ain't Markup Language</em></span>. What makes YAML interesting, aside from its silly name, is that its syntax for hierarchy requires the use of lines and indentation as delimiters, rather than structured enclosures such as curly braces and brackets, which are used in JSON:</p><pre class="programlisting">item-key-one: &#13;
  - list item 1 &#13;
  - list item 2 &#13;
item-key-two: &#13;
  nested_key_one: this is an associative array &#13;
  nested_key_two: end the associative array &#13;
</pre><p>The syntax for YAML was designed to make the hierarchy structure of data more easily human-readable by requiring the lines and spaces for explicit delineation of its structure. In contrast, other data formats that use characters such as brackets for defining structure can find it difficult to convey hierarchy to the human eye, especially when in compressed format.</p><p>YAML was first created around the same time as JSON, but it has not received nearly the amount of notoriety that JSON has in the web development community. YAML is arguably more flexible than JSON in that it allows for more features, such as comments and relational anchors, but it is likely the simplicity of JSON that makes it a more popular data format for consumption within web applications and beyond.</p></div><div class="section" title="BSON"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>BSON</h3></div></div></div><p>
<span class="strong"><strong>Binary JSON</strong></span> (<span class="strong"><strong>BSON</strong></span>) is a binary form of JSON that is used primarily as the data storage format for the MongoDB document-oriented database system. BSON is just like JSON, with the main difference being that BSON supports more complex data types such as Date, Timestamp, and <code class="literal">ObjectId</code>. An <code class="literal">ObjectId</code> in BSON and MongoDB is a 12-byte unique identifier for a stored object. MongoDB requires that every object has a unique identifier field named <code class="literal">_id</code> and an <code class="literal">ObjectId</code> is the default mechanism for assigning this field a value. This concept is much like a <span class="emphasis"><em>primary key</em></span> in a relational database system.</p><p>A BSON document that uses the <code class="literal">ObjectId</code> and <code class="literal">Timestamp</code> data types might look something like this:</p><pre class="programlisting">{ &#13;
    "_id": ObjectId("542c2b97bac0595474108b48"), &#13;
    "timestamp": Timestamp(1412180887, 1) &#13;
} &#13;
</pre><p>When we discuss MongoDB and document-oriented databases in this text, the term JSON may be used interchangeably for BSON with the implication that this distinction is understood. You can learn more about the BSON specification at bsonspec.org.</p></div></div><div class="section" title="Why does JSON reign supreme?"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Why does JSON reign supreme?</h2></div></div></div><p>JSON is simple, easy to read, and structured in a way that is easily understood by just about any programming language in existence. Lists (or arrays) and name-value pairs (or associative arrays) are a fundamental concept and common implementation in computer languages. The simpler a format is, the easier it is to parse, and thus more platforms will develop a way to inherently consume that data format. Such has been the case with JSON.</p><p>Additionally, the JSON specification was only changed a few times after it was first developed. Its creator, Douglas Crockford, intentionally gave no version number to the specification so that it would be set in stone and could not change over time. This may likely be the biggest factor in JSON's dominance over other data formats. Since it does not change over time, the parsers built to consume it across myriad programming languages and platforms don't have to change either. This has created an ecosystem in which JSON exists with only one version in every place, making it entirely predictable, widely understandable, and virtually unbreakable.</p></div></div></div>
<div class="section" title="The differences between SQL and NoSQL databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>The differences between SQL and NoSQL databases</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever"><span class="emphasis"><em>Chapter 2</em></span></a>, <span class="emphasis"><em>Model-View-Whatever</em></span>, we briefly discussed document-oriented databases, otherwise known as NoSQL databases. This concept is imperative to the MEAN stack, as the <span class="emphasis"><em>M</em></span> in the MEAN acronym stands for MongoDB, a widely used NoSQL database implementation. NoSQL databases are conceptually divergent from traditional relational, or SQL, databases.</p><p>Non-relational databases have existed for decades, but they did not achieve any widespread use until more recently. This rise in popularity led to the term <span class="emphasis"><em>NoSQL</em></span> first being applied to these types of databases. The reason for the increase in the use of NoSQL databases has primarily been to solve the problem of handling <span class="emphasis"><em>Big Data</em></span>, or massive and complex datasets, and <span class="emphasis"><em>scaling</em></span> that data horizontally in modern web applications.</p><div class="section" title="NoSQL data typing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>NoSQL data typing</h2></div></div></div><p>The term NoSQL means <span class="emphasis"><em>non-SQL</em></span> which implies that it is a non-relational database type. NoSQL databases that are document-oriented, like MongoDB, store their data in documents represented by structured JSON objects. The data <span class="emphasis"><em>types</em></span> in a NoSQL database like this are defined by the data itself, as is the case with standard JSON:</p><pre class="programlisting">{ &#13;
    "id": 1 &#13;
} &#13;
</pre><p>For example, if you have a field in a NoSQL database with the key <code class="literal">id</code> and the value is <code class="literal">1</code>, a number, you could easily change the value to <code class="literal">myID</code>, a string, without needing to change any other reference to that data type:</p><pre class="programlisting">{ &#13;
    "id": "myID" &#13;
} &#13;
</pre><p>In this way, the data <span class="emphasis"><em>type</em></span> for that value is entirely dependent upon what it is defined as. In a relational database, making this change would not be so straightforward.</p></div><div class="section" title="Relational data typing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Relational data typing</h2></div></div></div><p>In contrast to document-oriented databases, traditional SQL databases use tables to structure their data. Each table column is set to a specific data type and the data stored under that column must adhere to the defined type. If you have a large SQL database and wish to change the type for a particular column, it can be potentially problematic and could require the change to be executed on thousands of rows of data. Changing a data type in a JSON document is relatively easy compared to this, as it only involves changing the data itself, and there is no concept of a table column defining the data type across multiple records.</p><p>The term <span class="emphasis"><em>relational</em></span> in regard to relational databases refers to the tabular relation of the data stored. Each table of data is considered a relation because the different data stored within it is related to one another in some manner defined by the applications and programs that will be consuming it. A table in a SQL database can be compared to a JSON object in a NoSQL database. The biggest difference between the two, however, is that a table is composed of rows and columns, and the data is further related by column types and rows containing records of related data. In a NoSQL database, there is no concept of rows and columns, and data can be nested with unlimited scope.</p><p>In order to retrieve <span class="emphasis"><em>nested</em></span> data within a SQL database, relations must also be identified between tables. Since data cannot actually be nested, references from one or more tables to one or more other tables must be used to create related sets of data for use in application Models and Views. SQL is a programming language used to manage and extract the data from relational database tables and format it in such a way that is required for an application.</p></div><div class="section" title="ACID transactions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>ACID transactions</h2></div></div></div><p>The majority of NoSQL database systems do not support <span class="emphasis"><em>transactions</em></span> which conform to the properties of <span class="strong"><strong>ACID</strong></span>, which stands for <span class="strong"><strong>Atomicity</strong></span>, <span class="strong"><strong>Consistency</strong></span>, <span class="strong"><strong>Isolation,</strong></span> and<span class="strong"><strong> Durability</strong></span>. This set of properties is required for a database to handle transactions in a reliable fashion. A transaction is any change made to a database. That change can be to a single value for a field in one table, or it can be a change that spans multiple tables and affects multiple rows within those tables. Most widely used relational databases support the ACID properties for transactions, no matter the complexity of the operation that is performed.</p><div class="section" title="Atomicity"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Atomicity</h3></div></div></div><p>The Atomicity property of ACID refers to atomic operations within a database, meaning that the changes required for a transaction must all be ensured to occur, otherwise none will occur. This property provides a guarantee that partial changes are not made, which could lead to corrupt data sets. If an atomic transaction fails at any point within a database, the changes made up to that point are rolled back to their previous state.</p></div><div class="section" title="Consistency"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Consistency</h3></div></div></div><p>The Consistency property of ACID is the requirement that a transaction only causes <span class="emphasis"><em>valid</em></span> data changes as defined by that database system. This includes ensuring that data is not corrupt, that rollbacks are enforced when necessary, and that all the necessary database triggers related to a transaction are executed.</p></div><div class="section" title="Isolation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>Isolation</h3></div></div></div><p>The Isolation property of ACID requires that a simultaneously executed transaction, or concurrency, does not result in database errors in related data. This can involve different levels of strictness, dependent upon the database system being used. The primary goal of Isolation is that the end result of a set of concurrent transactions is the same as if you were to go back and replay them one after another. Isolation is closely tied to Consistency, and it should always ensure that Consistency is maintained.</p></div><div class="section" title="Durability"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Durability</h3></div></div></div><p>The Durability property of ACID requires that a transaction is not <span class="emphasis"><em>lost</em></span> while being executed. You can imagine any number of things going wrong with a computer that could occur during the execution of a transaction, such as a power outage. When something like this occurs, Durability provides that the database system <span class="emphasis"><em>remembers</em></span> the transaction that was in the middle of execution by recording it to disk and ensuring that it isn't lost, even after a reboot.</p></div><div class="section" title="MongoDB and ACID"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec32"/>MongoDB and ACID</h3></div></div></div><p>It is true that many NoSQL database systems do not conform to the ACID properties; however, MongoDB does to a certain degree. As mentioned, MongoDB is a document-oriented database system, which is a more terse subset of NoSQL databases. In this fashion, MongoDB has the ability to support ACID transactions at the single-document level. It cannot support multi-document transactions, so in this way it falls short of most relational databases, which can support ACID transactions across multiple tables, but MongoDB still stands out among document-oriented databases at the document level.</p><div class="section" title="Write-ahead logging with MongoDB"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec10"/>Write-ahead logging with MongoDB</h4></div></div></div><p>Another feature that MongoDB touts above others is <span class="strong"><strong>Write-Ahead Logging</strong></span> (<span class="strong"><strong>WAL</strong></span>). This is a set of features allowing a database system to conform to the Atomicity and Durability properties of ACID. To do this, MongoDB writes a record of all operations and their results to an internal log before actually executing the operations. This is a simple and effective way to ensure the Durability of document-level transactions because with all operations logged ahead of execution, evidence of what occurred is not lost in the event of a sudden interruption to an operation. Similarly, this feature ensures Atomicity because it gives MongoDB the ability to <span class="emphasis"><em>undo</em></span> and <span class="emphasis"><em>redo</em></span> these operations upon reboot after determining what changes were made and comparing them to the state of the database before the interrupted operation.</p></div></div></div></div>
<div class="section" title="When to use SQL versus NoSQL databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>When to use SQL versus NoSQL databases</h1></div></div></div><p>There are clearly major differences between SQL and NoSQL databases, not only in how they are structured, but in how developers and applications interact with them. These differences can have serious implications for the development of an application from both an architectural and a functional perspective. This is why choosing your database type is no small matter and should always be thoroughly evaluated before moving forward with the development of an application.</p><div class="section" title="Scalability"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Scalability</h2></div></div></div><p>It was mentioned earlier that the needs of modern web applications have led to the rise in popularity of NoSQL databases. <span class="emphasis"><em>Scalability</em></span>, or the ability to continuously handle growing amounts of data and operations on that data, is one of these needs. You can imagine this being the scenario for a social media company such as Facebook or Twitter, and any other social applications that may interact with social data received from resources like this. In the following, scalability is a feature you may need to take under consideration when deciding on the type of database you want to use for your application.</p><div class="section" title="Horizontal scaling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec33"/>Horizontal scaling</h3></div></div></div><p>In particular, <span class="emphasis"><em>horizontal scaling</em></span> is a necessity for a growing number of modern-day web applications. This refers to the need for distributed servers and databases geographically with a growing user base. Effective horizontal scaling allows users of an application to receive data from a server that is closest to them, rather than a single server or set of servers that may be in a data warehouse halfway around the world.</p><p>Horizontal scaling is certainly not impossible with a relational database, but it is difficult, and it requires the use of a sophisticated <span class="strong"><strong>Database Management System</strong></span> (<span class="strong"><strong>DBMS</strong></span>). NoSQL databases, on the other hand, are simpler in design, and this makes data replication across clusters of machines and networks much simpler as well.</p></div></div><div class="section" title="Big Data"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Big Data</h2></div></div></div><p>Another need for modern web applications is <span class="strong"><strong>Big Data</strong></span>, which can mean exactly what its name implies: a massive amount of data. More often than not, however, Big Data refers to a high degree of complexity among data sets such that it can be difficult to analyze and extract value from them without the aid of sophisticated techniques for doing so.</p><p>NoSQL databases lend themselves perfectly to handling Big Data due to their support for <span class="emphasis"><em>dynamic schema design</em></span>, which simply means that you do not have to define a specific schema for a data set before you store it, as is required by traditional relational databases. This goes back to the flexibility of data typing in NoSQL, which doesn't require that the type for a field be governed by a rule, as it is for a column in a tabular data schema. Additionally, the schema for a relational database table cannot be changed without affecting all of the data for that table. In contrast, the schema of a particular data set in a JSON document, for instance, can change at any time without affecting previously stored data sets in that same document.</p><p>If Big Data is a foreseeable need for your web application, then the <span class="emphasis"><em>type</em></span> of Big Data is a further consideration you should make before choosing a database type.</p><div class="section" title="Operational Big Data"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec34"/>Operational Big Data</h3></div></div></div><p>
<span class="strong"><strong>Operational Big Data</strong></span> refers to data that is consumed and managed in real time to support the operation of currently running processes in distributed applications. Document-oriented databases such as MongoDB are built with operational Big Data support in mind and focus on <span class="emphasis"><em>speed</em></span> of concurrent read and write operations to provide for this.</p><p>MongoDB, and other NoSQL systems designed to work with operational Big Data, do so by taking advantage of modern distributed network computing power to increase the efficiency of operations. Traditional relational databases were not built with this ability in mind because computer systems were more isolated when they were developed.</p></div><div class="section" title="Analytical Big Data"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec35"/>Analytical Big Data</h3></div></div></div><p>
<span class="strong"><strong>Analytical Big Data</strong></span> contrasts greatly with operational Big Data in that its focus is on <span class="strong"><strong>Massively Parallel Processing</strong></span> (<span class="strong"><strong>MPP</strong></span>). This means that massive amounts of data are consumed and later analyzed for any number of requirements that give value to the application using it. In contrast to operational Big Data, database systems designed for analytical Big Data focus on massive <span class="emphasis"><em>throughput</em></span> and retrospective processing of that data, rather than speed of concurrent, unrelated operations.</p><p>The need to handle analytical Big Data is not always apparent at the outset when developing an application. Anticipation of this requirement is often difficult because when you start out with a small data set, you may not know what massive amounts of data you might want to analyze as your database matures over time. Fortunately, this problem can be handled by the implementation of a solution subsequent to identifying its need. MPP databases are built for this specific purpose, in addition to <span class="emphasis"><em>MapReduce</em></span>, which is an alternative implementation to handle MPP across distributed computers in a cluster.</p></div></div><div class="section" title="Overall considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Overall considerations</h2></div></div></div><p>When deciding whether to use a SQL or NoSQL database for your application, you should consider the needs of your application both at the initial release and what you foresee further down the line. If you expect a large user base and the potential for viral growth, then you will want to consider a NoSQL database built for handling operational Big Data and scalability.</p><p>If you are developing an application that you anticipate having a smaller user base, or perhaps no users other than administrators of the data, then a relational SQL database may be more appropriate. Additionally, if your application may have many users, but has no need for horizontal scalability, a SQL database is likely suitable as well.</p><p>Also consider that many modern, distributed web applications started out using only relational databases, and they later implemented NoSQL solutions in congruence with the existing databases to handle growing needs. This is also a use case that can be planned for and adapted to as needed during the life cycle of an application.</p></div></div>
<div class="section" title="Methods of presenting an SPA container"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Methods of presenting an SPA container</h1></div></div></div><p>In a Single Page Application, the <span class="emphasis"><em>container</em></span> is the object in which the application is initially loaded and displayed to the user. This concept is different from that of a <span class="emphasis"><em>software container</em></span>, which is an isolated environment that an application lives in, much like a virtual machine.</p><p>For a single page web application, the container could be the <code class="literal">&lt;body&gt;</code> element, or any element within the <code class="literal">&lt;body&gt;</code> element. For instance, you may have some static welcome text initially loaded on the page in a <code class="literal">&lt;p&gt;</code> element, and the SPA will then load dynamically below that element in a <code class="literal">&lt;div&gt;</code> element:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;p&gt;This is some welcome text.&lt;/p&gt; &#13;
        &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>In a scenario like this, you will always have some fixed content on the page that doesn't need to change based on the user's interaction with the application. This is just a simple example, but the same could be done for a common <code class="literal">&lt;header&gt;</code>, <code class="literal">&lt;footer&gt;</code>, and <code class="literal">&lt;nav&gt;</code> element:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;header&gt;Static header content&lt;/header&gt; &#13;
        &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
        &lt;footer&gt;Static footer content&lt;/footer&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><div class="section" title="How to define your SPA container"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>How to define your SPA container</h2></div></div></div><p>There is no <span class="emphasis"><em>right</em></span> way to define your SPA container; it really just depends on the type of application you are building and what your preference is. It can also depend on the server-side limitations of the system you are using to serve your <span class="emphasis"><em>layout</em></span> - the HTML page used to house your app.</p><div class="section" title="Partial page container"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec36"/>Partial page container</h3></div></div></div><p>As shown in previous sections, you may want to show some static content in your SPA layout before the application loads. This is useful when you anticipate a long initial load time for an app, or if you require some user interaction to trigger the loading of your app.</p></div><div class="section" title="Full page container"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Full page container</h3></div></div></div><p>If your application can be completely controlled through API endpoints accessed by <span class="strong"><strong>XMLHttpRequest</strong></span>, commonly known as <span class="strong"><strong>Asynchronous JavaScript and XML</strong></span> (<span class="strong"><strong>AJAX</strong></span>), then there is no need to load any static content in your SPA layout unless you want to. One reason you may load static content in your layout is to have something for the user to view or read while they are waiting for the application to load. This can be particularly useful when you anticipate long initial load times for your app and you want to help deter a user from leaving before the application's initial <span class="emphasis"><em>state</em></span> is ready.</p><p>A <span class="emphasis"><em>state</em></span> in a SPA refers to a particular version of the <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>), at any point in time. A <span class="emphasis"><em>loading state</em></span> is one you might show within your container element while waiting for it to load the next requested state. A loading indicator of some sort is often enough to let the user know that something is happening and the application will load soon, but when you have any excessive latency in your app, a user may think something has gone wrong and leave the app layout page before the process completes.</p></div></div><div class="section" title="How to load your SPA container"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>How to load your SPA container</h2></div></div></div><p>The way you initially load your SPA is highly dependent upon the nature of your application. There could be any number of requirements that must be fulfilled before your app can be loaded.</p><div class="section" title="Loading on user interaction"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Loading on user interaction</h3></div></div></div><p>Many web applications require some type of user interaction before the full SPA is loaded. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User authentication</li><li class="listitem" style="list-style-type: disc">User acceptance of an agreement to enter</li><li class="listitem" style="list-style-type: disc">Interstitial content that must be shown and either engaged or dismissed by the user, such as an advertisement</li></ul></div><p>Scenarios like these are quite common in web applications, and they can often be challenging to solve in a fluid manner.</p><div class="section" title="Login page transition"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec11"/>Login page transition</h4></div></div></div><p>In many web applications, the login screen is loaded on a secure page and submitted using HTTP POST to another secure page to authenticate the user and load the actual SPA. This pattern is generally used due to limitations in the server-side framework that is being used to handle authentication.</p><p>If you think about a financial application for accessing your bank account that you log in to on your phone, you will likely not see much more than a login screen until you have authenticated with your username and password. This will typically bring you to a second page that loads the full single page application with your sensitive banking information that you would not otherwise want available to someone else who picks up your phone.</p><p>A login screen is arguably the most common use case requiring user interaction to load an application, and it is one that is often handled with little elegance. The most fluid way to handle this use case, if your REST framework allows for it, is to load a login screen as part of your SPA and request authentication via a REST endpoint from your login form. When you receive a properly authenticated response from your API request, you can then load the data you need into the existing SPA container and replace the login state with a new <span class="emphasis"><em>logged in</em></span> state.</p></div></div><div class="section" title="Loading based on the DOMContentLoaded event"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec39"/>Loading based on the DOMContentLoaded event</h3></div></div></div><p>If your SPA does not require user authentication or any other interaction for initial loading, or if you detect a user that is already authenticated at the time the page is loaded and you can skip that step, then you will want a way to automatically load your SPA upon initial page load, and as soon as possible.</p><p>The best time to load a single page application is generally as soon as the DOM is completely loaded and can be parsed by the browser. Modern browsers fire an event on the <code class="literal">document</code> object when this happens, called <code class="literal">DOMContentLoaded</code>, and that can be used for this purpose. To do this, you would simply add an <code class="literal">EventListener</code> on the <code class="literal">document</code> to detect when the event is fired, and then call a function to load your app:</p><pre class="programlisting">&lt;script&gt; &#13;
    document.addEventListener('DOMContentLoaded', function(event) { &#13;
        loadMyApp(); &#13;
    }); &#13;
&lt;/script&gt; &#13;
</pre><p>Alternatively, if you are using jQuery, you can call the handy jQuery <code class="literal">.ready()</code> method to listen for the <code class="literal">DOMContentLoaded</code> event and trigger your custom application code within an anonymous function:</p><pre class="programlisting">&lt;script&gt; &#13;
    $(document).ready(function() { &#13;
        loadMyApp(); &#13;
    }); &#13;
&lt;/script&gt; &#13;
</pre></div><div class="section" title="Loading based on the document readystatechange event"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec40"/>Loading based on the document readystatechange event</h3></div></div></div><p>Modern browsers also provide an event that is fired on the <code class="literal">document</code> object when you first load a page called <code class="literal">readystatechange</code>. This event can be used to determine three states of the DOM, which are returned as the following via the <code class="literal">document.readyState</code> property:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">loading</code> - This is when the document is still loading and has not been entirely parsed by the browser.</li><li class="listitem" style="list-style-type: disc"><code class="literal">interactive</code> - This is when all DOM elements have finished loading and can be accessed, but certain external resources may have not fully loaded, such as images and stylesheets. This state change also indicates that the <code class="literal">DOMContentLoaded</code> event has been fired.</li><li class="listitem" style="list-style-type: disc"><code class="literal">complete</code> - This is when all DOM elements and external resources have fully loaded.</li></ul></div><p>To use the <code class="literal">readystatechange</code> event to load your application at the same time as the <code class="literal">DOMContentLoaded</code> event, you would assign a function to be called on the <code class="literal">readystatechange</code> event and then check whether the <code class="literal">document.readyState</code> property is set to <code class="literal">interactive</code>. If it is, then you can call your application code:</p><pre class="programlisting">&lt;script&gt; &#13;
    document.onreadystatechange = function() { &#13;
        if (document.readyState === 'interactive') { &#13;
            loadMyApp(); &#13;
        } &#13;
    }; &#13;
&lt;/script&gt; &#13;
</pre><p>Using this method to detect the state of the document provides more flexibility in the event that you want to call custom application code for any of the three document states, and not just on the <code class="literal">DOMContentLoaded</code> event, or <code class="literal">interactive</code> state.</p></div><div class="section" title="Loading directly from the document.body"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec41"/>Loading directly from the document.body</h3></div></div></div><p>The more traditional way of loading <code class="literal">&lt;script&gt;</code> tags is by placing them within the document <code class="literal">&lt;head&gt;</code> element. Adding the <code class="literal">&lt;script&gt;</code> tags to the <code class="literal">&lt;head&gt;</code> is fine for loading an SPA if you are using the document <code class="literal">DOMContentLoaded</code> or <code class="literal">readystatechange</code> events within your external JavaScript to initialize your application code at the appropriate time:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;head&gt; &#13;
        &lt;script src="app.js"&gt;&lt;/script&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
       &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>If you want to avoid using these custom DOM events and trigger your application code precisely when you need it, however, a different and more direct approach can be taken.</p><p>A common technique for loading JavaScript into a web page today is by placing the <code class="literal">&lt;script&gt;</code> tag, which loads your external JavaScript file, directly within the <code class="literal">&lt;body&gt;</code> element of the page. The ability to do this lies in the way the DOM is parsed by a browser: from the top to the bottom.</p><p>Take this code, for example:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;body&gt; &#13;
       &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
        &lt;script src="app.js"&gt;&lt;/script&gt; &#13;
   &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Loading the external JavaScript <code class="literal">app.js</code> file from within the <code class="literal">document.body</code> and just above the closing <code class="literal">&lt;/body&gt;</code> tag will ensure that all DOM elements above the <code class="literal">&lt;script&gt;</code> tag are parsed before it is loaded, and the <code class="literal">app.js</code> file is loaded precisely after the <code class="literal">&lt;div class="container"&gt;</code> element. If that element is where you will load your SPA, then this technique ensures that your application code within <code class="literal">app.js</code> will be executed immediately following the <code class="literal">container</code> element being parsed.</p><p>Another advantage to loading your <code class="literal">&lt;script&gt;</code> tags near the bottom of the DOM and below the elements that are required for loading your application is that the loading of those <code class="literal">&lt;script&gt;</code> tags will not block the loading of any content above them, due to the browser's top-down parsing of the DOM. Once the <code class="literal">&lt;script&gt;</code> tag is reached, there may be some blocking preventing the browser from being usable while it is being loaded, but the user will at least see everything on the page that has been loaded up until that point.</p><p>For this reason, loading a <code class="literal">&lt;script&gt;</code> tag within the <code class="literal">&lt;body&gt;</code> and near the bottom of the DOM is preferable to loading it with the traditional <code class="literal">&lt;head&gt;</code> tag insertion so that no blocking occurs before anything is visible on the page.</p><div class="section" title="Using the script tag async attribute"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec12"/>Using the script tag async attribute</h4></div></div></div><p>One method for preventing a <code class="literal">&lt;script&gt;</code> tag from blocking the browser usability while it is loaded is the <code class="literal">async</code> attribute. This attribute can be added to ensure that your <code class="literal">app.js</code> file is loaded asynchronously once parsed, and so that the rest of the DOM continues to be parsed and loaded, regardless of when the loading of that script completes:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;body&gt; &#13;
       &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
        &lt;script src="app.js" async&gt;&lt;/script&gt; &#13;
   &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The advantage to this is, again, there is no blocking. The disadvantage to it, however, is that when you are loading multiple scripts asynchronously, there is no guarantee in what order they will finish loading and eventually execute. This is why it also a good practice to load only a single, compressed JavaScript file for your application as much as possible. The fewer <code class="literal">&lt;script&gt;</code> tags there are, the fewer external resources have to be parsed and downloaded, and in the case of using the <code class="literal">async</code> attribute, using only one <code class="literal">&lt;script&gt;</code> tag means waiting for only one asynchronous resource to load and not having to worry about the unpredictable sequence of loading multiples files, which could potentially break your application.</p></div><div class="section" title="Using the script tag defer attribute"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec13"/>Using the script tag defer attribute</h4></div></div></div><p>Another method for loading a <code class="literal">&lt;script&gt;</code> tag directly from the body and not causing the document parser to be blocked is the <code class="literal">defer</code> attribute. Unlike <code class="literal">async</code>, this attribute ensures that the <code class="literal">&lt;script&gt;</code> tag will not be loaded until the document parsing is complete, or upon the <code class="literal">DOMContentLoaded</code> event.</p><p>Using the <code class="literal">defer</code> attribute, your <code class="literal">&lt;script&gt;</code> tag can be placed anywhere within the <code class="literal">&lt;body&gt;</code> and always be guaranteed to load after the <code class="literal">DOMContentLoaded</code> event:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;body&gt; &#13;
        &lt;script src="app.js" defer&gt;&lt;/script&gt; &#13;
        &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre></div></div></div></div>
<div class="section" title="Managing layouts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Managing layouts</h1></div></div></div><p>As mentioned in <span class="emphasis"><em>
<a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>
</em></span>, <span class="emphasis"><em>Model-View-Whatever</em></span>, a <span class="emphasis"><em>layout</em></span> in relation to an SPA is the server-side HTML page that is used to house, initialize, and display your app. The layout will contain similar HTML markup to the examples in the previous section regarding how to load your SPA container.</p><p>The layout is generally the only native server-side component necessary to create an SPA, the other components being the native frontend code and the external API for providing endpoints for data consumption and manipulation.</p><div class="section" title="Static layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Static layouts</h2></div></div></div><p>A layout can be something as simple as a static HTML page that is loaded onto a web server and calls the resources necessary for loading your app within a defined container element on that page. Ideally, once that initial HTML page is loaded, no other server-side HTML pages need to be accessed to run your app, hence the term <span class="emphasis"><em>Single Page Application</em></span>.</p><p>If you do not require any server-side framework interaction for setting up environment variables, testing login state, and so on, then a static HTML page is the quickest and easiest way to launch your SPA.</p><p>A static HTML layout page could be something as simple as the following example:</p><pre class="programlisting">&lt;!doctype html&gt; &#13;
&lt;html&gt; &#13;
    &lt;head&gt; &#13;
        &lt;title&gt;This is a static HTML page&lt;/title&gt; &#13;
    &lt;/head&gt; &#13;
    &lt;body&gt; &#13;
       &lt;div class="container"&gt; &#13;
            The application will be loaded here. &#13;
        &lt;/div&gt; &#13;
        &lt;script src="app.js"&gt;&lt;/script&gt; &#13;
    &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>A drawback to using a static HTML file simply being served on a web server is that you have to go directly to that file in order to load your app. If your app is reached at <code class="literal">myapp.com</code>, for instance, and your static HTML layout page is named <code class="literal">index.html</code>, most web servers will route the <span class="emphasis"><em>root</em></span> server request to this page automatically, so a user would not need to navigate directly to <code class="literal">myapp.com/index.html</code> in order to reach it, but just to <code class="literal">myapp.com</code>.</p><p>If a user were to go to <code class="literal">myapp.com/profile</code>, however, where they might find their user profile information, the app layout would not be loaded and the server would generate a <span class="strong"><strong>HTTP 404</strong></span>, or <span class="strong"><strong>Not Found</strong></span>, response. In order to provide for this use case and allow custom URLs for your app, a <span class="emphasis"><em>dynamic layout</em></span> is necessary.</p></div><div class="section" title="Dynamic layouts"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Dynamic layouts</h2></div></div></div><p>When you have control over the server-side framework for your single page application, as would be the case when using the MEAN stack, then you may want to develop a more dynamic server layout page that can load variables and some minimal logic from the server side when your app initially loads.</p><p>Express is a server-side web framework for Node.js, and it is the <span class="emphasis"><em>E</em></span> in the MEAN stack acronym. When you are developing with the MEAN stack, you will be using Express to define and handle all of your REST API endpoints, but you will also want to handle your main application entry point.</p><div class="section" title="Installing Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec42"/>Installing Express</h3></div></div></div><p>Let's go back to our Node.js environment we have been using to work with NPM, Bower, and Grunt, and install Express:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install express --save</strong></span>
</pre><p>In this case, we are using the <code class="literal">--save</code> parameter to save Express to our main NPM dependencies, since it is not just being used for development.</p></div><div class="section" title="Setting up a basic server with Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec43"/>Setting up a basic server with Express</h3></div></div></div><p>Once you have Express installed, create a file called <code class="literal">server.js</code> in the root directory of your app:</p><pre class="programlisting">
<span class="strong"><strong>$ touch server.js</strong></span>
</pre><p>Within this file, add the following code to include the Express module and initialize your application object:</p><pre class="programlisting">var express = require('express'); &#13;
var app = express(); &#13;
</pre><p>The <code class="literal">app</code> object within your <code class="literal">server.js</code> file will allow you to call methods on it for defining routes. In the case of our SPA example, we only need to define one route for the time being.</p></div><div class="section" title="Basic routing with Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec44"/>Basic routing with Express</h3></div></div></div><p>Routing in Express refers to defining URL paths which are used to respond to server requests. Express can define routes for any type of HTTP request, including <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code> requests, which are necessary for creating a REST API. At this point, however, we simply want to define a route for loading a HTML page.</p><p>Defining a route for your main application entry point would be a GET request, and this is quite simple to do with Express. In the <code class="literal">server.js</code> file you just created, add the following code below the <code class="literal">app</code> object definition:</p><pre class="programlisting">app.get('/', function(request, response) { &#13;
    response.sendFile('/index.html', {root: __dirname}); &#13;
}); &#13;
</pre><p>This command adds a route that will serve the <code class="literal">index.html</code> file you created earlier as the root response for the app. The second parameter, which defines a <code class="literal">root</code> property as <code class="literal">__dirname</code>, simply sets the root server path for the app to the current directory.</p><p>Now we want to use Express to serve our app instead of the simple <code class="literal">http-server</code> module from earlier.</p></div><div class="section" title="Running a server with Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec45"/>Running a server with Express</h3></div></div></div><p>Now that you have your <code class="literal">server.js</code> file set up with a basic route to the root of your application, all that is left is to set up a HTTP port to listen on and to load the app. In your <code class="literal">server.js</code> file, add the following code to your route definition:</p><pre class="programlisting">app.listen(8080, function() { &#13;
    console.log('App now listening on port 8080'); &#13;
}); &#13;
</pre><p>This tells the server to listen on HTTP <code class="literal">port 8080</code> for serving the app layout. Now all you have to do is run the server from the command line:</p><pre class="programlisting">
<span class="strong"><strong>$ node server.js</strong></span>
</pre><p>This will run the server and display the console message <code class="literal">App now listening on port 8080</code> in the terminal.</p><p>Now go to <code class="literal">localhost:8080</code> in your browser and you should see the simple SPA page we created in <span class="emphasis"><em>
<a class="link" href="ch02.html" title="Chapter 2. Model-View-Whatever">Chapter 2</a>, Model-View-Whatever</em></span>. You will notice some errors in your browser console, however, because the local JavaScript files which are linked to in <code class="literal">index.html</code> are not found. This is occurring because you have not defined a route for loading static asset files.</p></div><div class="section" title="Loading static assets with Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec46"/>Loading static assets with Express</h3></div></div></div><p>First, stop the app by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> from the command line. Now edit <code class="literal">server.js</code> again and add the following code <span class="emphasis"><em>above</em></span> the SPA layout page route definition:</p><pre class="programlisting">app.use('/', express.static('./')); &#13;
</pre><p>This command will set the app to load static assets from the root directory. Now if you run <code class="literal">nodeserver.js</code> again from the command line and reload the page in your browser, the SPA should load all assets and work just as it did before with <code class="literal">http-server</code>.</p></div><div class="section" title="Dynamic routing with Express"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec47"/>Dynamic routing with Express</h3></div></div></div><p>As mentioned earlier, our app should allow a user to go to something like <code class="literal">myapp.com/profile</code>, or in our case <code class="literal">localhost:8080/profile</code>, to load a dynamic request that will trigger a different view than the main root view for the app. If you go to <code class="literal">localhost:8080/profile</code> in your app now, you will get the following response in your browser:</p><pre class="programlisting">Cannot GET /profile &#13;
</pre><p>To fix this, stop your local server again, edit the <code class="literal">server.js</code> file and make the following change to the app layout route definition:</p><pre class="programlisting">app.get('*', function(request, response) { &#13;
    response.sendFile('/index.html', {root: __dirname}); &#13;
}); &#13;
</pre><p>Here, we simply changed the path parameter in the <code class="literal">GET</code> route definition from <code class="literal">'/'</code> to <code class="literal">'*'</code>. Express allows for regular expression syntax within route definitions, so what this does is tell the server to route all dynamic path requests to the <code class="literal">index.html</code> page, instead of just the root <code class="literal">'/'</code> path.</p><p>Save this change, and now if you run <code class="literal">node server.js</code> again on the command line and go to <code class="literal">localhost:8080/profile</code> in your browser, you will see the SPA displayed again just as it did from the root path, and all static asset files should be loaded as expected.</p><p>After setting up this basic Node.js Express server, your final <code class="literal">server.js</code> file should look like this:</p><pre class="programlisting">var express = require('express'); &#13;
var app = express(); &#13;
 &#13;
app.use('/', express.static('./')); &#13;
 &#13;
app.get('*', function(request, response) { &#13;
    response.sendFile('/index.html', {root: __dirname}); &#13;
}); &#13;
 &#13;
app.listen(8080, function() { &#13;
    console.log('App now listening on port 8080'); &#13;
}); &#13;
</pre><p>Our simple SPA has now become a bit more sophisticated, with the ability to serve a dynamic layout file, and to use dynamic routes for loading the layout via custom URLs.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>You should now have a better understanding of various data interchange formats such as JSON, BSON, XML, and YAML, and how they are used in web applications. You should understand the differences between SQL and NoSQL databases and what the advantages are of using one or the other depending on the needs of your application, and you have also learned about MongoDB and its use of BSON as a binary form of JSON. Additionally, you have learned about using web SPA container elements, and various methods of initializing and loading your app into that container.</p><p>These concepts are fundamental to understanding SPA development in general, and to understanding the inner workings of the MEAN stack and how it differs from other application development architectures.</p><p>Now that you have gotten a glimpse into the server side of a Node.js application and built a basic server with Express, let's go deeper into working with Express and learn about creating REST API requests for consumption within an SPA.</p></div></body></html>