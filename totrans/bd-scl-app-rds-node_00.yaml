- en: '[CHAPTER 1](toc.xhtml#c01)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第一章](toc.xhtml#c01)'
- en: '[Introduction to Node.js](toc.xhtml#c01)'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Node.js 简介](toc.xhtml#c01)'
- en: '[Introduction](toc.xhtml#s1a)'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[简介](toc.xhtml#s1a)'
- en: The popularity of Node.js is booming day by day in the IT market worldwide.
    Through this book, any JavaScript developer can easily learn about Node.js from
    basic to advanced levels. This chapter talks about the Node.js basics and architecture.
    We will also learn how to write a simple Node.js program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 在全球 IT 市场上的普及度日益增长。通过这本书，任何 JavaScript 开发者都可以轻松地从基础到高级学习 Node.js。本章将讨论
    Node.js 的基础和架构。我们还将学习如何编写简单的 Node.js 程序。
- en: '[Structure](toc.xhtml#s2a)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结构](toc.xhtml#s2a)'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining Node.Js and Where It is Used
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 Node.Js 及其应用场景
- en: Pros and Cons of Node.Js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.Js 的优缺点
- en: Installing Node.Js on Various Platforms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种平台上安装 Node.Js
- en: Understanding Event-Driven Programming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件驱动编程
- en: Node.js Architectures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 架构
- en: Writing HTTP and HTTPS Server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 HTTP 和 HTTPS 服务器
- en: Using the Cluster Module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cluster 模块
- en: '[Defining Node.Js](toc.xhtml#s3a)'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[定义 Node.Js](toc.xhtml#s3a)'
- en: When Ryan Dahl demonstrated his remarkable work, *Node.js at JSConf 2009*, it
    was the beginning of a new era. He stated that the concurrency was achieved by
    threads in most of the top languages and that using threads has certain problems
    as context switching between threads is costly. Using the event loop, he showed
    that Node.js achieves way higher concurrency than any of the existing languages.
    People at the conference welcomed the idea and applauded Dahl. Thus began the
    much-awaited shift in the programming world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ryan Dahl 展示了他的杰出工作，*2009 年 JSConf 上的 Node.js*，这标志着新时代的开始。他表示，在大多数顶级语言中，并发是通过线程实现的，而使用线程存在某些问题，因为线程之间的上下文切换成本高昂。通过事件循环，他展示了
    Node.js 实现的并发性远高于任何现有语言。会议上的与会者欢迎这一想法，并鼓掌欢迎 Dahl。因此，编程世界期待已久的转变开始了。
- en: Node.js is an open source cross-platform JavaScript runtime environment. It
    states that anyone can use it free of cost on any operating system such as Windows,
    Linux, Unix, Mac, and more. JavaScript is the foundation of Node.js. The code
    of any node.js application is written in JavaScript. This code runs on Google
    Chrome’s V8 JavaScript engine which converts source code to machine code directly
    without interpreting and then it gets executed without the need for a web browser.
    Node.js provides the necessary environment for the code to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个开源的跨平台 JavaScript 运行时环境。它声明任何人都可以免费在任何操作系统上使用它，例如 Windows、Linux、Unix、Mac
    等。JavaScript 是 Node.js 的基础。任何 node.js 应用的代码都是用 JavaScript 编写的。此代码在 Google Chrome
    的 V8 JavaScript 引擎上运行，该引擎直接将源代码转换为机器代码，然后无需解释即可执行，无需浏览器即可执行。Node.js 为代码的运行提供了必要的环境。
- en: '![](img/1.1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.1.jpg)'
- en: '**Figure 1.1:** Node.js Architecture'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.1:** Node.js 架构'
- en: '*[Figure 1.1](#fig1_1)* shows a high level architecture of Node.js. Even though
    Node.js is single threaded, it still handles lots of concurrent requests at a
    time through a mechanism of asynchronous non-blocking I/O operations which provides
    hidden threads from the `**libuv**` library that executes itself as multi-threaded.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 1.1](#fig1_1)* 展示了 Node.js 的高级架构。尽管 Node.js 是单线程的，但它通过异步非阻塞 I/O 操作的机制，在每次处理大量并发请求，这种机制由
    `**libuv**` 库提供，该库以多线程的方式自行执行。'
- en: Due to non-blocking I/O operation, Node.js is fast compared to other languages
    because the request does not wait for its response and parallelly executes another
    request. All requests are first sent to the event queue, processed in the event
    loop, and then sent back to the V8 engine through the queue as displayed in Node.js
    architecture. More about the event loop is elaborated in the section, “*Event-driven
    Mechanism*” later in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非阻塞 I/O 操作，Node.js 与其他语言相比速度更快，因为请求不会等待其响应，而是并行执行另一个请求。所有请求首先发送到事件队列，在事件循环中处理，然后通过队列发送回
    V8 引擎，如 Node.js 架构中所示。关于事件循环的更多内容将在本章后面的“*事件驱动机制*”部分中详细阐述。
- en: Node.js is not only written for backend-side server programming applications
    but also developed as node modules and used on the client side, which is beneficial
    for developers as the same language is used on both sides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 不仅是为了后端服务器编程应用而编写的，而且还作为节点模块开发并用于客户端，这对开发者来说是有益的，因为两边的语言相同。
- en: '[Applications of Node.js](toc.xhtml#s4a)'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Node.js 的应用](toc.xhtml#s4a)'
- en: The usage of Node.js has been growing at a fast pace in IT Industries due to
    its features and different types of application. Here are a few examples of different
    types of applications related to Node.js.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其特性和不同类型的应用，Node.js 在 IT 行业中的应用正在以较快的速度增长。以下是一些与 Node.js 相关的不同类型应用的例子。
- en: '[Single-Page Applications](toc.xhtml#s5a)'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[单页应用程序](toc.xhtml#s5a)'
- en: Currently, there are a lot of organizations and enterprises that provide complex
    and real time solutions to their clients by developing Node.js applications as
    server side applications through single-page applications. For example, Gmail,
    Twitter, Facebook, Trello, and many more applications are developed as SPA (Single-Page
    Applications). A single-page application communicates with the user’s actions
    by rewriting data on a single web page instead of reloading the whole web page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，许多组织和公司通过开发作为单页应用程序的服务器端应用程序的 Node.js 应用程序，为他们的客户提供复杂和实时的解决方案。例如，Gmail、Twitter、Facebook、Trello
    以及许多其他应用程序都是作为 SPA（单页应用程序）开发的。单页应用程序通过在单个网页上重写数据而不是重新加载整个网页，与用户的操作进行通信。
- en: '[Real-time Applications](toc.xhtml#s6a)'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[实时应用](toc.xhtml#s6a)'
- en: Node.js is an ideal model for real-time applications because it gives responses
    to numerous requests at the same time. If there are a large number of users that
    need real-time response, Node.js is a better choice. You can use Node.js with
    WebSockets for continuous connection and to provide a faster response time. Applications
    such as audio, video, chat, multiplayer games, and stock trading are developed
    in this manner.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是实时应用的理想模型，因为它可以同时响应多个请求。如果有大量用户需要实时响应，Node.js 是更好的选择。您可以使用 Node.js
    与 WebSockets 结合，以实现持续连接并提供更快的响应时间。音频、视频、聊天、多人游戏和股票交易等应用程序都是通过这种方式开发的。
- en: '[IoT Devices Applications](toc.xhtml#s7a)'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[物联网设备应用](toc.xhtml#s7a)'
- en: Due to its faster response time and ability to handle large numbers of requests
    concurrently, Node.js is a good choice for Internet of Things (IoT) apps where
    devices or sensors are connected to the internet and send huge amounts of data
    continuously. IoT use cases such as fire detection, noise pollution measure, fitness
    tracker, health monitoring are many such applications where Node.js is playing
    a big role.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其较快的响应时间和处理大量并发请求的能力，Node.js 是物联网（IoT）应用程序的良好选择，其中设备或传感器连接到互联网并持续发送大量数据。火灾检测、噪音污染测量、健身追踪、健康监测等物联网用例是
    Node.js 发挥重要作用的许多应用之一。
- en: '[Data Streaming Application](toc.xhtml#s8a)'
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[数据流应用程序](toc.xhtml#s8a)'
- en: Node.js allows working with an abstract interface as a stream for data streaming.
    Large media files are divided into small chunks and sent as buffers. These buffers
    are transformed into meaningful data. Netflix-like streaming services use Node.js
    where data is transferred in chunks instead of whole large streams that reduce
    loading and delay while streaming happens.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 允许以流的形式使用抽象接口进行数据处理。大型媒体文件被分割成小块，并以缓冲区形式发送。这些缓冲区被转换成有意义的数据。Netflix 类似的流媒体服务使用
    Node.js，其中数据以块的形式传输，而不是整个大流，这减少了在流传输过程中的加载和延迟。
- en: The uses of Node.js are not limited to the preceding types of applications but
    also many more types of applications developed in Node.js such as making proxy
    or signaling servers, monitoring data-based applications, and more.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的用途不仅限于前面提到的应用类型，还包括在 Node.js 中开发的许多其他类型的应用，例如制作代理或信令服务器、监控基于数据的应用程序等。
- en: '[Pros of Node.js](toc.xhtml#s9a)'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Node.js 的优点](toc.xhtml#s9a)'
- en: 'Node.js is a very powerful runtime environment for JavaScript. It allows developers
    to build high performance and scalable applications. Some of the key advantages
    that Node.js offers are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是一个非常强大的 JavaScript 运行时环境。它允许开发者构建高性能和可扩展的应用程序。Node.js 提供的一些关键优势如下：
- en: '**Cross platform**: Node.js comes up with cross-platform functionality so the
    application can be easily developed on any OS and deployed on any platform. Key
    platforms supported by Node.js are Windows, Mac(Intel), Mac(ARM), and Linux (Intel/ARM).
    Probably every major platform is supported.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台**：Node.js 提供了跨平台功能，因此应用程序可以轻松地在任何操作系统上开发并在任何平台上部署。Node.js 支持的关键平台包括 Windows、Mac（Intel）、Mac（ARM）和
    Linux（Intel/ARM）。可能每个主要平台都得到了支持。'
- en: '**High performance**: Node.js offers high performance due to asynchronous non-blocking
    I/O operations which execute requests in parallel without waiting for the response
    of any other request.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能**：Node.js由于异步非阻塞I/O操作而提供高性能，这些操作可以并行执行请求，而无需等待任何其他请求的响应。'
- en: '**Easy to scale**: Node.js is itself single threaded but in heavy traffic,
    it handles a lot of requests at the same time to scale up with the “*cluster*”
    module which creates child processes and reduces the load on the application.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于扩展**：Node.js本身是单线程的，但在高流量下，它可以通过“*cluster*”模块同时处理大量请求来扩展，该模块创建子进程并减少应用程序的负载。'
- en: '**Caching**: Node.js allows storing data in temporary memory that is not updated
    frequently, which reduces loading time and saves database transactions. This is
    called caching.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：Node.js允许将数据存储在临时内存中，这些数据不经常更新，这可以减少加载时间并节省数据库事务。这被称为缓存。'
- en: '**Huge community**: Ever since Node.js appeared, its community size has been
    increasing day by day. The language used for programming is JavaScript which has
    been the backbone of the internet and almost every front-end developer was already
    familiar with it. This made learning easy and made the community grow rapidly.
    There are more than 1.3 million open-source libraries available for use.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**庞大的社区**：自从Node.js出现以来，其社区规模每天都在增加。用于编程的语言是JavaScript，它是互联网的支柱，几乎每个前端开发者都已经熟悉它。这使得学习变得容易，并使社区迅速增长。有超过130万个开源库可供使用。'
- en: There are many other advantages as well such as cost-effectiveness, ease of
    learning, and adaptability. Node.js is a technique that has really made a difference.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有很多其他优点，如成本效益、易于学习和适应性。Node.js是一种真正有所不同的技术。
- en: '[Cons of Node.js](toc.xhtml#s10a)'
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Node.js的缺点](toc.xhtml#s10a)'
- en: There are some disadvantages of Node.js too. However many of these can be overcome
    using best practices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js也有一些缺点。然而，许多这些缺点可以通过最佳实践来克服。
- en: '**Single threaded**: Node.js is single threaded, which is an advantage as well
    as a pitfall because it is unable to process heavy CPU oriented computation quickly.
    When requests which need more CPU for processing come in the event loop, they
    keep piling up because until it finishes one request, it will not pick other requests
    from the event queue. However, this happens only when there are only CPU centric
    tasks. If a request needs some IO to happen, another request will be picked while
    a request waits for IO to complete. CPU centric tasks make the performance low
    and delay the response. For example, for searching algorithms and mathematical
    calculations where complexity is high at that time, Node.js is not recommended
    due to poor performance.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单线程**：Node.js是单线程的，这既是优点也是缺点，因为它无法快速处理重量级的CPU密集型计算。当需要更多CPU进行处理的请求进入事件循环时，它们会不断堆积，因为直到完成一个请求，它才不会从事件队列中选取其他请求。然而，这仅在只有CPU密集型任务时才会发生。如果请求需要一些I/O发生，另一个请求将在请求等待I/O完成时被选取。CPU密集型任务会降低性能并延迟响应。例如，对于搜索算法和数学计算，当时复杂性很高，由于性能不佳，Node.js不推荐使用。'
- en: '**Callback hell:** Asynchronous programming in Node.js can be challenging for
    some developers, especially when using callbacks. Callback hell is a situation
    when callback functions are nested. This can make code difficult to read and maintain.
    However to avoid this, developers can use promises, async-await, or libraries
    such as Async.js.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调地狱**：在Node.js中进行异步编程对一些开发者来说可能具有挑战性，尤其是在使用回调时。回调地狱是一种回调函数嵌套的情况。这可能会使代码难以阅读和维护。然而，为了避免这种情况，开发者可以使用promises、async-await或如Async.js之类的库。'
- en: '**Library compatibility:** Although there are more than a million libraries
    available yet those being open sourced by individual developers might not be up-to-date
    to the latest versions. This sometimes makes it difficult to use those libs in
    projects.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库兼容性**：尽管有超过一百万个库可用，但那些由个人开发者开源的库可能没有更新到最新版本。这有时会使在项目中使用这些库变得困难。'
- en: '[Installing Node.js](toc.xhtml#s11a)'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[安装Node.js](toc.xhtml#s11a)'
- en: Now when we have a high level understanding of what Node.js is and what it offers,
    let us jump to the setup. There are different ways to download and install Node.js
    in your system but here, we give the easiest and best way. Download the LTS (Long
    Term Support) Version of Node.js from its official site ([https://nodejs.org/en/download](https://nodejs.org/en/download))
    based on your operating system. On the site, there will be LTS and Current Version,
    choose the LTS version because it is stable and recommended for complex projects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Node.js是什么以及它提供了什么有了高层次的理解，让我们跳转到设置部分。在您的系统中下载和安装Node.js有不同方式，但在这里，我们提供最简单和最佳的方式。根据您的操作系统，从其官方网站([https://nodejs.org/en/download](https://nodejs.org/en/download))下载Node.js的LTS（长期支持）版本。在网站上，会有LTS和当前版本，请选择LTS版本，因为它更稳定，并且推荐用于复杂项目。
- en: At the time of writing, Node.js version 20 is ACTIVE.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Node.js版本20是激活状态。
- en: '![](img/1.2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.2.jpg)'
- en: '**Figure 1.2:** Node.js Versions'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.2**：Node.js版本'
- en: The preceding up-to-date release schedule can be seen on Node.js GitHub page—
    [https://github.com/nodejs/release#release-schedule](https://github.com/nodejs/release#release-schedule).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述最新的发布时间表可以在Node.js GitHub页面查看— [https://github.com/nodejs/release#release-schedule](https://github.com/nodejs/release#release-schedule)。
- en: '[Installing Node For Linux/Ubuntu](toc.xhtml#s12a)'
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[在Linux/Ubuntu上安装Node](toc.xhtml#s12a)'
- en: '**NPM** (**Node Package Manager**) is the default package manager for node.js
    and also a library of JavaScript software packages. It is open source so that
    developers can install other modules in their project via npm free of cost.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**NPM**（**Node包管理器**）是node.js的默认包管理器，也是一个JavaScript软件包的库。它是开源的，这样开发者就可以通过npm免费在他们的项目中安装其他模块。'
- en: '**Node Version Manager (NVM)** is a shell script that manages multiple node
    versions and uses it on different projects.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node版本管理器（NVM）**是一个shell脚本，用于管理多个node版本，并在不同的项目中使用它。'
- en: We can highlight the importance of installing Node.js through **NVM** with real
    use cases.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实际案例来强调通过**NVM**安装Node.js的重要性。
- en: 'Using NVM, you can easily manage multiple Node.js versions on the same machine.
    Here is how it helps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NVM，您可以在同一台机器上轻松管理多个Node.js版本。以下是它如何帮助的：
- en: '**Version Management**: NVM allows you to install multiple versions of Node.js
    on your system. This means you can switch between different versions seamlessly
    based on the requirements of your projects.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本管理**：NVM允许您在系统中安装多个Node.js版本。这意味着您可以根据项目的需求无缝地在不同版本之间切换。'
- en: '**Isolated Environments**: Each Node.js version installed through NVM is isolated
    from others. This ensures that changes made to one version won’t affect the others.
    It is particularly useful when you are working on projects with conflicting dependencies
    or when you need to maintain compatibility with older versions.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离环境**：通过NVM安装的每个Node.js版本都与其他版本隔离。这确保了对一个版本的更改不会影响到其他版本。当您在处理具有冲突依赖项的项目或需要与旧版本保持兼容性时，这尤其有用。'
- en: '**Flexibility**: With NVM, you have the flexibility to switch between Node.js
    versions effortlessly. This allows you to test your applications across different
    versions, ensuring compatibility and stability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：使用NVM，您可以轻松地在Node.js版本之间切换。这允许您在不同的版本上测试您的应用程序，确保兼容性和稳定性。'
- en: '**Project-specific Versioning**: NVM allows you to specify the Node.js version
    required for a particular project. This ensures that each project uses the correct
    version of Node.js without interfering with others.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定项目的版本管理**：NVM允许您指定特定项目所需的Node.js版本。这确保了每个项目都使用正确的Node.js版本，而不会干扰到其他项目。'
- en: '**Easy Updates**: NVM simplifies the process of updating Node.js to the latest
    version. You can easily upgrade or downgrade Node.js versions with a single command,
    ensuring that your development environment stays up-to-date.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松更新**：NVM简化了将Node.js更新到最新版本的过程。您可以通过单个命令轻松升级或降级Node.js版本，确保您的开发环境保持最新。'
- en: NVM for managing Node.js versions provides a streamlined and efficient workflow,
    enhancing productivity and reducing potential conflicts between projects. It is
    an essential tool for developers working on multiple Node.js projects simultaneously.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用于管理Node.js版本的NVM提供了一个简化和高效的流程，提高了生产力，并减少了项目之间的潜在冲突。它是同时处理多个Node.js项目的开发者的必备工具。
- en: Based on the advantages of NVM, we will install Node.js through NVM on different
    platforms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据NVM的优势，我们将在不同的平台上通过NVM安装Node.js。
- en: 'Let us first install NVM and then install Node.js by NVM. Open terminal/console
    or cmd and follow three given steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装 NVM，然后通过 NVM 安装 Node.js。打开终端/控制台或 cmd，并按照以下三个步骤操作：
- en: Update your system with the latest versions of packages.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最新版本的软件包更新您的系统。
- en: '`$ sudo apt-get update`'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ sudo apt-get update`'
- en: 'Download and install NVM using this command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令下载和安装 NVM：
- en: '`$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh
    | bash`'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh
    | bash`'
- en: 'Before running the preceding command, make sure `curl` is installed on the
    system. If it is not installed then run the following commands to install and
    verify:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行上述命令之前，请确保系统已安装 `curl`。如果没有安装，请运行以下命令进行安装和验证：
- en: '`$ sudo apt install curl $ curl –version`'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ sudo apt install curl $ curl –version`'
- en: 'Verify NVM version:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 NVM 版本：
- en: '`$ nvm –version`'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nvm –version`'
- en: 'Install Node.js as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式安装 Node.js：
- en: '`$ nvm install node`'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nvm install node`'
- en: This command will install the latest stable version of node.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将安装最新的稳定版 node。
- en: 'To install Node.js with LTS version, use this command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 LTS 版本的 Node.js，使用此命令：
- en: '`$ nvm install -lts`'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nvm install -lts`'
- en: 'If anyone wants specific version of node, then add specific version at end
    of NVM and install as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有人需要特定的 node 版本，那么在 NVM 的末尾添加特定版本，并按以下方式安装：
- en: '`$ nvm install 18.15.0`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nvm install 18.15.0`'
- en: Or
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '`$ nvm install 18.x`'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ nvm install 18.x`'
- en: In the preceding commands, 18.15.0 is a specific version of node.js and 18.x
    means it will consider the highest version of 18 above and below 19.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的命令中，18.15.0 是 node.js 的一个特定版本，18.x 表示它将考虑 18 以上和 19 以下的最高版本。
- en: 'Verify Node.js version as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式验证 Node.js 版本：
- en: '`$ node –version`'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ node –version`'
- en: After successfully executing the above steps, you can expect the following output
    to be displayed in the command prompt for your reference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行上述步骤后，您可以在命令提示符中看到以下输出，供您参考。
- en: '![](img/1.3.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.3.jpg)'
- en: '**Figure 1.3:** Linux Node.js Installation'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.3:** Linux Node.js 安装'
- en: Once Node.js installed, by default NPM is also installed with Node.js installation
    package, which can be verified with `$ npm –version`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Node.js 后，默认情况下，NPM 也会随着 Node.js 安装包一起安装，可以使用 `$ npm –version` 进行验证。
- en: 'Other NVM commands which can be helpful for developers to play with node versions
    on different projects are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对开发者有帮助的 NVM 命令，可用于在不同项目中玩转不同的 node 版本如下：
- en: '`$ nvm ls` - Checks list of node version in the system'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ nvm ls` - 检查系统中 node 版本的列表'
- en: '`$ nvm use 18.x` – For specific use of node version on the project'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ nvm use 18.x` – 在项目中特定使用 node 版本'
- en: '`$ nvm alias default 18.x` – It is to set default for all projects in the system'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ nvm alias default 18.x` – 这是为了设置系统中所有项目的默认版本'
- en: '`$ nvm uninstall 18.x`- It will uninstall that 18.x version from system'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ nvm uninstall 18.x` - 这将从系统中卸载 18.x 版本'
- en: '[Installing Node.js for Windows](toc.xhtml#s13a)'
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[在 Windows 上安装 Node.js](toc.xhtml#s13a)'
- en: While we have covered Linux installation, now let us proceed with the installation
    process on Windows. You can follow the steps outlined below for Windows installation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经涵盖了 Linux 安装，现在让我们继续在 Windows 上进行安装过程。您可以根据以下步骤进行 Windows 安装。
- en: 'Installing Node.js through NVM on Windows via the command prompt (`**cmd**`)
    requires the usage of a specialized tool called "`**nvm-windows**`". Here are
    the steps to install Node.js on Windows using `**nvm-windows**` via the command
    prompt:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令提示符 (`**cmd**`) 使用名为 "`**nvm-windows**`" 的专用工具在 Windows 上通过 NVM 安装 Node.js。以下是使用
    `**nvm-windows**` 通过命令提示符在 Windows 上安装 Node.js 的步骤：
- en: 'Download NVM for Windows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Windows 版本的 NVM：
- en: 'Go to the GitHub repository of `nvm-windows: nvm-windows`. You can explore
    more `**nvm**` for windows on [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '前往 `nvm-windows: nvm-windows` 的 GitHub 仓库。您可以在 [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)
    上探索更多 Windows 版本的 `**nvm**`。'
- en: 'Download the latest installer (.zip file) from the Releases section from following
    link: [https://github.com/coreybutler/nvm-windows/releases](https://github.com/coreybutler/nvm-windows/releases)
    Here, we will download `**nvm-setup.zip**` file'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从以下链接的发行版部分下载最新安装程序 (.zip 文件)：[https://github.com/coreybutler/nvm-windows/releases](https://github.com/coreybutler/nvm-windows/releases)
    这里，我们将下载 `**nvm-setup.zip**` 文件
- en: '![](img/1.4.jpg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/1.4.jpg)'
- en: '**Figure 1.4:** Windows Node.js Download Zip File'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图 1.4:** Windows Node.js 下载 Zip 文件'
- en: 'Extract the Zip File:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压 Zip 文件：
- en: Extract the downloaded .zip file to a directory on your system.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将下载的 .zip 文件解压到系统上的一个目录。
- en: 'Install `**NVM**` for Windows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Windows 安装 `**NVM**`：
- en: Open the Command Prompt as an administrator (right-click and select "`**Run
    as administrator**`"). Navigate to the directory where you extracted the `**nvm-windows**`
    files.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以管理员身份打开命令提示符（右键单击并选择“**以管理员身份运行**”）。导航到您提取`**nvm-windows**`文件的目录。
- en: '![](img/1.5.jpg)'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/1.5.jpg)'
- en: '**Figure 1.5:** NVM Install Select Location'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图1.5：NVM选择安装位置**'
- en: Click `**Finish**` to complete the process:![](img/1.6.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`**完成**`以完成过程！:![完成安装过程](img/1.6.jpg)
- en: '**Figure 1.6:** NVM Finish Install Process'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图1.6：NVM完成安装过程**'
- en: Run the `**nvm-setup.zip**` executable to start the installation process. Follow
    the on-screen instructions to complete the installation.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行`**nvm-setup.zip**`可执行文件以启动安装过程。按照屏幕上的说明完成安装。
- en: 'Verify NVM Installation:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证NVM安装：
- en: Close and reopen the Command prompt as administrator. Run the command NVM version
    to ensure that NVM is installed correctly.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以管理员身份关闭并重新打开命令提示符。运行NVM版本命令以确保NVM已正确安装。
- en: 'Install Node.js:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Node.js：
- en: Once NVM is installed, you can use it to install Node.js. To install a specific
    version of Node.js, use the command `**nvm install <version>**` (for example,
    `**nvm install 18.0.0**`).
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦安装了NVM，您就可以使用它来安装Node.js。要安装特定版本的Node.js，请使用命令`**nvm install <version>**`（例如，`**nvm
    install 18.0.0**`）。
- en: After the installation is complete, you can switch between Node.js versions
    using the `**nvm use <version>**` command.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用`**nvm use <version>**`命令在Node.js版本之间切换。
- en: 'Verify Node.js Installation:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证Node.js安装：
- en: Run the command `**node -v**` to verify that Node.js is installed and the correct
    version is active.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行命令`**node -v**`以验证Node.js已安装且激活了正确的版本。
- en: '[Installing Node.js for mac](toc.xhtml#s14a)'
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[为mac安装Node.js](toc.xhtml#s14a)'
- en: 'Installation of Node.js on Mac OS is similar to that of Linux. Follow the given
    steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS上安装Node.js的过程与Linux类似。遵循以下步骤：
- en: 'Install NVM: To install NVM, we just need to run the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NVM：要安装NVM，我们只需运行以下命令：
- en: '`curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh |
    bash`'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh |
    bash`'
- en: Please make sure that `**curl**` is available.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请确保`**curl**`可用。
- en: 'Install Node.js using NVM. In case, we just want to install latest Node.js,
    run the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用NVM安装Node.js。如果只想安装最新版本的Node.js，请运行以下命令：
- en: '`nvm install node`'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nvm install node`'
- en: 'This command will automatically download and install the latest Node.js version.
    In case you want to install the LTS (Long term support) version, run this command:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将自动下载并安装最新版本的Node.js。如果您想安装LTS（长期支持）版本，请运行此命令：
- en: '`nvm install –-lts`'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nvm install –-lts`'
- en: (Please note that there are two `'`-’ hyphens before lts).
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （请注意，在`lts`之前有两个短横线`'`-’）。
- en: 'Verify the installation by opening the console and run the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过打开控制台并运行以下命令来验证安装：
- en: '`node --version`'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`node --version`'
- en: 'This will output the version installed, for example:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将输出安装的版本，例如：
- en: '`v20.0.0`'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`v20.0.0`'
- en: 'We can also check the npm version using this command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用此命令检查npm版本：
- en: '`npm -- version`'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`npm -- version`'
- en: '`9.6.4`'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`9.6.4`'
- en: '[Event-Driven Mechanism](toc.xhtml#s15a)'
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[事件驱动机制](toc.xhtml#s15a)'
- en: Node.js is an asynchronous non-blocking event-driven programming. Any action
    that happens is called an event and it is either done by the user or the system
    itself. Node.js provides an inbuilt module Event, which is an instance of `**EventEmitter**`.
    Event is an I/O request that is first sent to the Event Queue. If there are multiple
    concurrent requests coming to the queue, then the queue passes it to the event
    loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一种异步非阻塞事件驱动编程。任何发生的行为称为事件，它要么由用户执行，要么由系统本身执行。Node.js提供了一个内置的模块Event，它是`**EventEmitter**`的一个实例。事件是一个I/O请求，首先发送到事件队列。如果有多个并发请求进入队列，则队列将其传递给事件循环。
- en: '![](img/1.7.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.7.jpg)'
- en: '**Figure 1.7:** Event-Driven Diagram'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.7：事件驱动图**'
- en: Event loop monitors the event queue, collects the events from it, then processes
    it and executes based on blocking and non-blocking functions. Blocking functions
    are executed sequentially, one after the other, and the second function is not
    called until the first one responds. Sometimes it depends on external resources
    and waits for its response which takes longer time, whereas non-blocking functions
    do not need to wait for any response. It executes asynchronously, which means
    multiple functions run parallel at a time so that they are not depending on one
    another. Blocking and non-blocking functions send thread and I/O Pool to its pools,
    respectively. Once the actual operation is done, the response of that request
    is sent back to the event queue via event loop. In nutshell, events are emitted
    and then registered or unregistered through a queue, which is monitored by the
    event loop, binding the appropriate handlers accordingly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环监控事件队列，从其中收集事件，然后根据阻塞和非阻塞函数进行处理和执行。阻塞函数依次执行，一个接一个，第二个函数只有在第一个函数响应后才会调用。有时它依赖于外部资源，需要等待较长时间才能得到响应，而非阻塞函数不需要等待任何响应。它们异步执行，这意味着一次可以并行运行多个函数，这样它们就不会相互依赖。阻塞和非阻塞函数分别将线程和
    I/O 池发送到其池中。一旦实际操作完成，该请求的响应将通过事件循环发送回事件队列。简而言之，事件通过队列发出，然后通过事件循环监控的队列进行注册或注销，相应地绑定适当的处理器。
- en: Node.js follows a non-blocking asynchronous model even though it has a single
    thread that handles multiple requests at a time, without blocking its call respective
    handlers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 虽然只有一个线程同时处理多个请求，但它遵循非阻塞异步模型，不会阻塞其各自的调用处理器。
- en: '[Example of Event Programming](toc.xhtml#s16a)'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[事件编程示例](toc.xhtml#s16a)'
- en: 'Create a file save with `**event_index.js**` and paste the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `**event_index.js**` 的文件，并将以下代码粘贴到其中：
- en: '`// Import ''events'' module`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 导入 ''events'' 模块`'
- en: '`const events = require(''events'');`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`const events = require(''events'');`'
- en: '`// Initiate an EventEmitter object`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 初始化一个 EventEmitter 对象`'
- en: '`const eventEmitter = new events.EventEmitter();`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`const eventEmitter = new events.EventEmitter();`'
- en: '`// Binds event handler for send message`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 绑定发送消息的事件处理器`'
- en: '`eventEmitter.on(''send_message'', function () {`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventEmitter.on(''send_message'', function () {`'
- en: '`console.log(''Hi, This is my first message'');`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''Hi, This is my first message'');`'
- en: '`});`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`// Handler associated with the connection event`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 与连接事件关联的处理程序`'
- en: '`const connectHandler = function connected() {`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`const connectHandler = function connected() {`'
- en: '`console.log(''Connection is created'');`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''Connection is created'');`'
- en: '`// Trigger the corresponding event`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 触发相应的事件`'
- en: '`eventEmitter.emit(''send_message'');`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventEmitter.emit(''send_message'');`'
- en: '`};`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: '`// Binds the event with handler`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 将事件与处理程序绑定`'
- en: '`eventEmitter.on(''connection'', connectHandler);`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventEmitter.on(''connection'', connectHandler);`'
- en: '`// Trigger the connection event`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 触发连接事件`'
- en: '`eventEmitter.emit(''connection'');`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`eventEmitter.emit(''connection'');`'
- en: '`console.log("Finish");`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log("Finish");`'
- en: 'Run the file with `**$ node event_index.js**` and the following output will
    be shown:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**$ node event_index.js**` 运行文件，以下输出将显示：
- en: '`Connection is created`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection is created`'
- en: '`Hi, This is my first message`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hi, This is my first message`'
- en: '`Finish`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Finish`'
- en: '[Example of Synchronous Code](toc.xhtml#s17a)'
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[同步代码示例](toc.xhtml#s17a)'
- en: 'Create one file named hello.txt and paste the following text in it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 hello.txt 的文件，并将以下文本粘贴到其中：
- en: '`Hello, I am Developer`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello, I am Developer`'
- en: 'Create another file named index.js within the same folder, paste the following
    code and save it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹内创建另一个名为 index.js 的文件，粘贴以下代码并保存：
- en: '`const fs = require(''fs'');`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`const fs = require(''fs'');`'
- en: '`console.log(''Start'');`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''Start'');`'
- en: '`const data = fs.readFileSync(''hello.txt'');`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`const data = fs.readFileSync(''hello.txt'');`'
- en: '`console.log(data.toString());`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(data.toString());`'
- en: '`console.log(''End'');`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''End'');`'
- en: 'Run the code as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行代码：
- en: '`**$ node sync_index.js**`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ node sync_index.js**`'
- en: 'You will get an output as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '`Start`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`'
- en: '`Hello, I am Developer`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello, I am Developer`'
- en: '`End`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`End`'
- en: Here, fs is a file system module importing it and `**fs.readFileSync()**` is
    a synchronous function which waits until file read is complete and assigns that
    response to the data variable. It prints line-by-line and executes synchronously.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，fs 是一个文件系统模块，导入它，`**fs.readFileSync()**` 是一个同步函数，它等待文件读取完成，并将响应分配给 data
    变量。它逐行打印并同步执行。
- en: '[Example of Asynchronous code](toc.xhtml#s18a)'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[异步代码示例](toc.xhtml#s18a)'
- en: 'Create one file named `**hello.txt**` and paste the following text:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `**hello.txt**` 的文件，并将以下文本粘贴到其中：
- en: '`Hello, I am Developer`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello, I am Developer`'
- en: 'Create another file named `**index.js**` within the same folder, paste the
    following code and save it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹内创建另一个名为 `**index.js**` 的文件，粘贴以下代码并保存：
- en: '`const fs = require(''fs'');`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`const fs = require(''fs'');`'
- en: '`console.log(''Start'');`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''Start'');`'
- en: '`fs.readFile(''hello.txt'', function (err, data) {`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.readFile(''hello.txt'', function (err, data) {`'
- en: '`if (err) {`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (err) {`'
- en: '`return console.error(err);`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`return console.error(err);`'
- en: '`}`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`console.log(data.toString());`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(data.toString());`'
- en: '`});`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`console.log(''End'');`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(''End'');`'
- en: 'Run the code as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行代码：
- en: '`$ node async_index.js`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ node async_index.js`'
- en: 'You will get an output as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '`Start`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`'
- en: '`End`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`End`'
- en: '`Hello, I am Developer`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello, I am Developer`'
- en: Here, fs is a file system module. We import it, and `**fs.readFile()**` is an
    asynchronous function. This function does not wait for the file read to complete.
    Instead, it has a callback function. Once the file read operation is finished,
    the `**callback**` function executes and prints the data. Therefore, the line
    after the callback is executed asynchronously.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，fs 是一个文件系统模块。我们导入它，`**fs.readFile()**` 是一个异步函数。这个函数不会等待文件读取完成。相反，它有一个回调函数。一旦文件读取操作完成，`**callback**`
    函数就会执行并打印数据。因此，回调函数之后的行是异步执行的。
- en: '[Types of Node.js Architectures](toc.xhtml#s19a)'
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[Node.js 架构类型](toc.xhtml#s19a)'
- en: When we start developing the applications using Node.js, it is important to
    decide how your application should be structured. There are many ways to structure
    your Node.js application with different kinds of architecture. Let us discuss
    those briefly here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Node.js 开发应用程序时，决定你的应用程序应该如何结构是很重要的。有几种不同的方式来结构你的 Node.js 应用程序，使用不同的架构。让我们在这里简要讨论一下。
- en: '[Monolithic Architecture](toc.xhtml#s20a)'
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[单体架构](toc.xhtml#s20a)'
- en: 'In this architecture, all components or modules of business logic are blended
    together in a single unit. Almost all web servers or server-side frameworks are
    built using monolithic architecture (see *[Figure 1.8](#fig1_8)*), which is the
    easiest way for developers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，所有业务逻辑的组件或模块都融合在一个单一单元中。几乎所有网络服务器或服务器端框架都是使用单体架构（参见*[图 1.8](#fig1_8)*），这是对开发者来说最简单的方式：
- en: '![](img/1.8.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.8](img/1.8.jpg)'
- en: '**Figure 1.8:** Monolithic Architecture'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.8：单体架构**'
- en: For smaller applications that do not require extensive scalability, this architecture
    can be suitable. However, it may not be well-suited for larger and more complex
    applications. As the traffic load on your server-side application grows, you will
    need to scale it to handle the increased demand. In this architecture, you have
    a single main Node.js server file that routes all API requests to controllers
    and services, managing database transactions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不需要广泛可扩展性的小型应用程序，这种架构可能是合适的。然而，它可能不适合更大和更复杂的应用程序。随着你的服务器端应用程序的流量负载增长，你需要对其进行扩展以处理增加的需求。在这个架构中，你有一个单一的
    Node.js 主服务器文件，它将所有 API 请求路由到控制器和服务，管理数据库事务。
- en: You can scale a monolithic architecture using clusters to reduce the load. However,
    there are instances when a single server is unable to handle the incoming traffic.
    In such cases, you can deploy the same code on multiple servers, run application
    servers, and employ a load balancer like Nginx. The load balancer, using a round-robin
    approach, becomes a reliable solution, especially for very large and heavily used
    applications. We will delve into this aspect in more detail in the deployment
    section. The biggest drawback of this structure is that if there is a small change
    needed on any component, then it needs to be done in all servers and rebuilt and
    redeployed again.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用集群来扩展单体架构以减少负载。然而，在某些情况下，单个服务器无法处理传入的流量。在这种情况下，你可以在多个服务器上部署相同的代码，运行应用程序服务器，并使用像
    Nginx 这样的负载均衡器。负载均衡器使用轮询方法，成为了一种可靠的解决方案，特别是对于非常大和高度使用的应用程序。我们将在部署部分更详细地探讨这个方面。这种结构的最大缺点是，如果任何组件需要小的更改，那么需要在所有服务器上执行更改，然后重新构建和重新部署。
- en: '[Microservice Architecture](toc.xhtml#s21a)'
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[微服务架构](toc.xhtml#s21a)'
- en: A microservices architecture is a type of architecture that is developed as
    a collection of services. The framework provided here allows us to develop and
    deploy the microservices along with maintaining them independently. Microservices
    sort out the challenges of monolithic systems by fragmenting the application from
    a whole into several smaller parts. It is reliable and suitable for large and
    complex applications such as e-commerce platforms, social sites where multiple
    features are provided to millions of users at same time. Hence, during maintenance
    or while adding new features, it does not interrupt other existing features and
    deploy only updated services. Nowadays, it is trending more and more for its flexibility
    where multiple developers work individually and are only responsible for their
    own small code instead of whole system code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种作为服务集合开发的架构。这里提供的框架允许我们开发、部署微服务，并独立维护它们。微服务通过将应用程序从整体分解成几个较小的部分来解决单体系统的挑战。它是可靠且适合大型和复杂应用程序的，例如电子商务平台、社交网站，这些网站同时向数百万用户提供多个功能。因此，在维护或添加新功能时，它不会中断其他现有功能，只部署更新的服务。如今，由于其灵活性，它越来越受欢迎，多个开发者可以独立工作，只需负责他们自己的小段代码，而不是整个系统代码。
- en: 'In this architecture, all components or modules of business logic are individual.
    Many large enterprises use this kind of microservice architecture (see *[Figure
    1.9](#fig1_9)*):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种架构中，所有业务逻辑的组件或模块都是独立的。许多大型企业使用这种类型的微服务架构（参见*[图1.9](#fig1_9)*）：
- en: '![](img/1.9.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.9](img/1.9.jpg)'
- en: '**Figure 1.9:** Microservice Architecture'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.9：微服务架构**'
- en: As per the preceding diagram, client as user or UI sends a request, which is
    collected by API Gateway and passed to the respective microservice, which has
    its own function (Lambda Function). This function connects to the database and
    gives back a response accordingly. Each microservice can be easily changed and
    deployed without affecting each other. In addition, these microservices also call
    each other through API HTTP service or gRPC (Google Remote Procedure Call) which
    is a generic flow of microservice architecture. However, while it is a cost-effective
    and time-saving architecture for development, it may not be suitable for smaller
    applications. This is because it relies on cloud-based solutions, which can become
    expensive even with minimal setup requirements. This cost issue can often be mitigated
    by adopting more budget-friendly solutions offered by monolithic architectures.
    In fact, microservices represent a way to leverage serverless architecture within
    the realm of cloud computing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，客户端作为用户或UI发送请求，该请求被API网关收集并传递给相应的微服务，每个微服务都有自己的功能（Lambda函数）。此函数连接到数据库，并根据情况返回响应。每个微服务都可以轻松更改和部署，而不会相互影响。此外，这些微服务还通过API
    HTTP服务或gRPC（谷歌远程过程调用）相互调用，这是微服务架构的通用流程。然而，虽然这种架构在开发中具有成本效益和时间节省的优势，但它可能不适合小型应用程序。这是因为它依赖于基于云的解决方案，即使是最基本的设置也可能变得昂贵。通过采用更经济实惠的解决方案，这种成本问题通常可以得到缓解，这些解决方案由单体架构提供。实际上，微服务代表了在云计算领域利用无服务器架构的一种方式。
- en: '[Serverless Architecture](toc.xhtml#s22a)'
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[无服务器架构](toc.xhtml#s22a)'
- en: Serverless architecture is the approach for developing and building applications
    without managing infrastructure. Basically any app is developed and deployed on
    a specific server. However, managing the server hosting process can be a cumbersome
    task for developers. This is where serverless architecture becomes a boon for
    those who want to avoid server management and only pay for what they use. In serverless
    architecture, everything is handled by third-party services provided by cloud
    computing providers like AWS, Azure, Google, etc. These providers offer respective
    functions like AWS Lambda functions, Microsoft Azure functions, and Google Cloud
    functions, which is why it is also referred to as “*Function as a Service*” (FaaS).
    However, it is important to note that this approach has its drawbacks, as it involves
    entrusting everything to third parties, which can raise security concerns. Even
    though it has some limitations, it is still becoming more popular because organizations
    focus on actual products and services, not infrastructure, so it will be cost
    effective for those who spend a lot of effort on infrastructure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构是开发和构建应用程序而不管理基础设施的方法。基本上，任何应用程序都是在一个特定的服务器上开发和部署的。然而，管理托管过程对于开发者来说可能是一项繁重的任务。这就是无服务器架构对于那些想要避免服务器管理并且只为其使用的部分付费的人来说成为一大福音。在无服务器架构中，所有事情都由云计算提供商（如AWS、Azure、Google等）提供的第三方服务处理。这些提供商提供各自的功能，如AWS
    Lambda函数、Microsoft Azure函数和Google Cloud函数，因此它也被称为“*函数即服务*”（FaaS）。然而，需要注意的是，这种方法有其缺点，因为它涉及将一切委托给第三方，这可能会引起安全担忧。尽管它有一些局限性，但它仍然越来越受欢迎，因为组织关注的是实际的产品和服务，而不是基础设施，因此对于那些在基础设施上投入大量精力的人来说，这将更加经济高效。
- en: '![](img/1.10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.10.jpg)'
- en: '**Figure 1.10:** Serverless Architecture'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.10:** 无服务器架构'
- en: In this serverless architecture, a transformative approach for application development
    and deployment that eliminates the need for traditional server management. Instead,
    it enables developers to focus solely on writing code while cloud providers handle
    the underlying infrastructure. Below is a visual representation of this serverless
    concept (see *[Figure 1.10](#fig1_10)*).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种无服务器架构中，一种变革性的应用程序开发和部署方法，消除了对传统服务器管理的需求。相反，它使开发者能够专注于编写代码，而云服务提供商则处理底层基础设施。以下是无服务器概念的视觉表示（见*[图1.10](#fig1_10)*）。
- en: It is an example of AWS serverless architecture in which an AWS API gateway
    is used to route REST API calls and is based on the route Lambda function called
    with an attached gateway. Lambda functions can be written in different languages
    but we consider them to be written in Node.js code that have the actual business
    logic to perform action to the database. AWS Cloud provides various database instances
    such as DynamoDB, MySQL, PostgreSQL, and others. Furthermore, it can effortlessly
    scale to accommodate increasing workloads. AWS offers auto-scaling capabilities,
    which means it can automatically add more EC2 instances when there is a surge
    in load and reduce instances when the load decreases.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它是AWS无服务器架构的一个例子，其中使用AWS API网关来路由REST API调用，并基于与附加网关一起调用的路由Lambda函数。Lambda函数可以用不同的语言编写，但我们认为它们是用具有实际业务逻辑的Node.js代码编写的，以执行对数据库的操作。AWS云提供了各种数据库实例，如DynamoDB、MySQL、PostgreSQL等。此外，它可以轻松扩展以适应不断增长的工作负载。AWS提供自动扩展功能，这意味着当负载激增时，它可以自动添加更多EC2实例，而当负载减少时，它可以减少实例。
- en: '| **Aspect** | **Monolithic Architecture** | **Microservices Architecture**
    | **Serverless Architecture** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **方面** | **单体架构** | **微服务架构** | **无服务器架构** |'
- en: '| Development | Easier setup and development process | Complex setup, but independent
    services promote scalability | Focuses on writing functions without managing infrastructure
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 开发和部署过程更简单 | 设置复杂，但独立服务促进可扩展性 | 专注于编写函数而不管理基础设施 |'
- en: '| Scalability | Limited scalability due to the entire application being scaled
    | Scalable, as each service can be independently scaled | Automatically scales
    based on demand |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 由于整个应用程序都需要扩展，因此可扩展性有限 | 可扩展的，因为每个服务都可以独立扩展 | 根据需求自动扩展 |'
- en: '| Maintenance | Single codebase makes maintenance easier | Requires management
    of multiple services and communication | Less management overhead; managed by
    cloud provider |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 维护 | 单一代码库使维护更容易 | 需要管理多个服务和通信 | 较少的维护开销；由云服务提供商管理 |'
- en: '| Technology Stack | Limited flexibility; all components use the same technology
    stack | Flexibility to use different technologies for each service | Limited control
    over underlying infrastructure and runtime |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 技术栈 | 灵活性有限；所有组件使用相同的技术栈 | 每个服务可以使用不同的技术，具有灵活性 | 对底层基础设施和运行时的控制有限 |'
- en: '| Deployment | Simple deployment process; deploy as a single unit | Deployment
    complexity due to multiple services | Simplified deployment process |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 部署 | 部署过程简单；作为一个单一单元部署 | 由于多个服务，部署复杂 | 部署过程简化 |'
- en: '| Resource Utilization | Resource utilization may be inefficient | Optimized
    resource utilization with services scaled as needed | Efficient resource utilization
    with on-demand execution |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 资源利用率 | 资源利用率可能效率低下 | 根据需要扩展服务，实现优化的资源利用率 | 按需执行，实现高效的资源利用率 |'
- en: '| Cost | Lower upfront costs; higher operational costs in the long term | Higher
    initial setup costs; potential cost savings with scale | Pay-per-use model can
    be cost-effective for low traffic apps |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 成本 | 初期成本较低；长期运营成本较高 | 初始设置成本较高；随着规模扩大可能节省成本 | 对于低流量应用，按使用付费模式可能具有成本效益 |'
- en: '| Fault Isolation | A bug in one part can affect the entire application | Faults
    are isolated to specific services; others remain unaffected | Managed by cloud
    provider, potential vendor lock-in |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 错误隔离 | 一个部分的错误可能影响整个应用程序 | 错误被隔离到特定的服务中；其他服务不受影响 | 由云服务提供商管理，可能存在供应商锁定风险
    |'
- en: '| Flexibility | Limited flexibility due to the monolithic structure | Flexibility
    to use different technologies and languages | Limited control over underlying
    infrastructure and runtime |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 灵活性 | 由于单体结构导致的灵活性有限 | 可以使用不同的技术和语言，具有灵活性 | 对底层基础设施和运行时的控制有限 |'
- en: '**Table 1.1:** Comparisons of Architecture'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1.1:** 架构比较'
- en: '*[Table 1.1](#tab1_1)* provides a comparison of various aspects of monolithic,
    microservices, and serverless architectures in Node.js, outlining their respective
    advantages and disadvantages. Depending on specific project requirements, one
    architecture may be more suitable than the others.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*[表 1.1](#tab1_1)* 提供了在 Node.js 中单体、微服务和无服务器架构的各个方面比较，概述了各自的优缺点。根据具体项目需求，一种架构可能比其他架构更适合。'
- en: Let us create a basic http and https server with programming.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编程创建一个基本的 HTTP 和 HTTPS 服务器。
- en: '[Writing an HTTP Server](toc.xhtml#s23a)'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[编写 HTTP 服务器](toc.xhtml#s23a)'
- en: Now when Node.js is properly set up and running in your system, let us do the
    famous "`**Hello World**`" in Node.js way by serving this through an HTTP server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 Node.js 在你的系统中正确设置并运行时，让我们通过 HTTP 服务器来执行著名的 "`**Hello World**`"。
- en: 'Let us create a file with name index.js, and copy the following code into it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 index.js 的文件，并将以下代码复制到其中：
- en: '`const http = require(''http'');`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`const http = require(''http'');`'
- en: '`const hostname = ''127.0.0.1'';`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`const hostname = ''127.0.0.1'';`'
- en: '`const port = 3000;`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`const port = 3000;`'
- en: '`const server = http.createServer((req, res) => {`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`const server = http.createServer((req, res) => {`'
- en: '`res.statusCode = 200;`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.statusCode = 200;`'
- en: '`res.setHeader(''Content-Type'', ''text/plain'');`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.setHeader(''Content-Type'', ''text/plain'');`'
- en: '`res.end(''Hello World'');`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.end(''Hello World'');`'
- en: '`});`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`server.listen(port, hostname, () => {`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.listen(port, hostname, () => {`'
- en: '``console.log(`Server running at http://${hostname}:${port}/`);``'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Server running at http://${hostname}:${port}/`);``'
- en: '`});`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: In the provided code, "`**http**`" is a default module provided by Node.js,
    so there is no need to install it separately. However, for modules not included
    in Node.js’s built-in modules, you can install them from the npm library.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的代码中，"`**http**`" 是 Node.js 默认提供的模块，因此无需单独安装。然而，对于 Node.js 内置模块之外的模块，你可以从
    npm 库中安装它们。
- en: 'The npm library contains millions of registered packages, and you can install
    them using the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: npm 库包含数百万个注册的包，你可以使用以下代码进行安装：
- en: '`$ npm install package-name`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ npm install package-name`'
- en: '`ex. npm install express`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`ex. npm install express`'
- en: package-name can be as "`**body-parser**`", "`**express**`", "`**moment**`",
    and so on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 包名可以是 "`**body-parser**`", "`**express**`", "`**moment**`" 等等。
- en: The http module creates a http server that runs on specific port 3000\. Ideally,
    Node.js runs on port 3000 but developers can assign different ports such as 3001,
    4000 or any port. Just need to make sure that the port number does not conflict
    with other applications on the system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: http 模块创建了一个运行在特定端口 3000 上的 http 服务器。理想情况下，Node.js 应该运行在端口 3000 上，但开发者可以分配不同的端口，如
    3001、4000 或任何端口。只需确保端口号不与其他系统上的应用程序冲突即可。
- en: 'To run the program, open console with source code directory and paste the following
    command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，打开源代码目录的控制台，粘贴以下命令：
- en: '`$ node index.js`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ node index.js`'
- en: Once it runs, open the browser and go to the URL as http://localhost:3000; it
    will print "`**Hello World**`".
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行，打开浏览器并访问URL http://localhost:3000；它将打印"`**Hello World**`"。
- en: '![](img/1.11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.11.jpg)'
- en: '**Figure 1.11:** HTTP Server Program Output'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.11**：HTTP服务器程序输出'
- en: '[Making it HTTPS](toc.xhtml#s24a)'
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[使其成为HTTPS](toc.xhtml#s24a)'
- en: The server we just created does not provide a secure way of serving APIs. Most
    often, we need to serve the APIs using HTTPS rather than HTTP.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的服务器不提供安全的服务API的方式。通常，我们需要使用HTTPS而不是HTTP来服务API。
- en: HTTP does not encrypt the data, thus it is not secure where the information
    is leaked during transmission. On the other hand, HTTPS encrypts data during transmission
    on request from client to server that makes it secure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP不加密数据，因此在传输过程中信息泄露时并不安全。另一方面，HTTPS在客户端到服务器的请求期间加密数据，使其变得安全。
- en: Let us rewrite the same code with the https server. For HTTPS, we need SSL certificates.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用https服务器重写相同的代码。对于HTTPS，我们需要SSL证书。
- en: 'Let us first create a self-signed SSL certificate:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个自签名的SSL证书：
- en: Open console and install `**openssl**` if not installed in your system.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台，如果系统未安装`**openssl**`，则安装。
- en: 'For Debian Linux such as ubuntu, installation can be done using the `**apt**`
    command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Debian Linux（如ubuntu），可以使用`**apt**`命令进行安装：
- en: '`$ sudo apt install openssl`'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ sudo apt install openssl`'
- en: 'For Centos, Fedora, and Rocky Linux, yum can be used to install `**openssl**`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Centos、Fedora和Rocky Linux，可以使用yum来安装`**openssl**`：
- en: '`$ sudo yum install openssl`'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ sudo yum install openssl`'
- en: 'Make `**openssl**` directory as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将`**openssl**`目录设置为：
- en: '`$mkdir openssl`'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$mkdir openssl`'
- en: '`$cd openssl`'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$cd openssl`'
- en: 'Request to generate `**ssl**` certificate with the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令请求生成`**ssl**`证书：
- en: '`$ openssl req -newkey rsa -x509 -sha256 -days 365 -nodes -out ssl.crt -keyout
    ssl.key`'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$ openssl req -newkey rsa -x509 -sha256 -days 365 -nodes -out ssl.crt -keyout
    ssl.key`'
- en: 'Let us understand the preceding command:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解前面的命令：
- en: '`**-newkey rsa**` : create new key with `**rsa**` algorithm default 2048 bit'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-newkey rsa**`：使用`**rsa**`算法创建新密钥，默认2048位'
- en: '`**-x509**` : creates a X.509 Certificate'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-x509**`：创建X.509证书'
- en: '`**-sha256**` : use 265-bit SHA (Secure Hash Algorithm)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-sha256**`：使用256位SHA（安全散列算法）'
- en: '`**-days 365**` : The number of days to certify the certificate for 365\. You
    can use any positive integer'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-days 365**`：证书的有效期为365天。您可以使用任何正整数'
- en: '`**-nodes**` : creates a key without a passphrase.'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-nodes**`：创建不带密码的密钥。'
- en: '`**-out ssl.crt**` : Specifies the filename to write the newly created certificate
    to. You can specify any file name.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-out ssl.crt**`：指定要写入新创建证书的文件名。您可以指定任何文件名。'
- en: '`**-keyout ssl.key**` : Specifies the filename to write the newly created private
    key to. You can specify any file name.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**-keyout ssl.key**`：指定要写入新创建的私钥的文件名。您可以指定任何文件名。'
- en: 'Once you enter this command, it will prompt the following questions (as shown
    in *[Figure 1.12](#fig1_12)*). Press enter until done and check that folder which
    has `**ssl.crt**` and `**ssl.key**` files:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入此命令，它将提示以下问题（如图*[图1.12](#fig1_12)*所示）。按回车键直到完成，并检查包含`**ssl.crt**`和`**ssl.key**`文件的文件夹：
- en: '![](img/1.12.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.12.jpg)'
- en: '**Figure 1.12:** Openssl Certificate Generation'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.12**：OpenSSL证书生成'
- en: 'Now create `**main.js**` and write the following code to create `**https server**`
    with `**port 3000**`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建`**main.js**`，并写入以下代码以创建`**https服务器**`，端口为`**3000**`：
- en: '`// import https module`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 导入https模块`'
- en: '``const https = require(`https`);``'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '``const https = require(`https`);``'
- en: '`//import fs module to read files`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`//导入fs模块以读取文件`'
- en: '``const fs = require(`fs`);``'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '``const fs = require(`fs`);``'
- en: '`const options = {`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`const options = {`'
- en: '``key: fs.readFileSync(`./openssl/ssl.key`),``'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '``key: fs.readFileSync(`./openssl/ssl.key`),``'
- en: '``cert: fs.readFileSync(`./openssl/ssl.crt`)``'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '``cert: fs.readFileSync(`./openssl/ssl.crt`)``'
- en: '`};`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: '`// create https server on port 3000`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 在端口3000上创建https服务器`'
- en: '`https.createServer(options, (req, res) => {`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`https.createServer(options, (req, res) => {`'
- en: '`res.writeHead(200);`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.writeHead(200);`'
- en: '``res.end(`hello world from https server \n`);``'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '``res.end(`hello world from https server \n`);``'
- en: '`}).listen(3000);`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`}).listen(3000);`'
- en: Run the code with node main.js and open the browser with https://localhost:3000
    which displays "`**hello world from https server**`". This way a secure https
    server is built with very basic examples.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用node main.js运行代码，并在浏览器中打开https://localhost:3000，它将显示"`**来自https服务器的hello world**`"。这样，就使用非常基础的示例构建了一个安全的https服务器。
- en: '[Using Cluster Module](toc.xhtml#s25a)'
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[使用集群模块](toc.xhtml#s25a)'
- en: Node.js can easily make applications highly scalable through the cluster module.
    Cluster is creating a child process so that it raises another process which splits
    single thread into multi thread. Due to that heavy traffic load is reduced and
    shared on different instances of thread with the same port. It is a built-in module
    of Node.js. As Node.js supports async single thread and sometimes when blocking
    functions are more, the application performance gets down. Cluster is most important
    and useful to improve it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 可以通过集群模块轻松地使应用程序高度可扩展。集群通过创建子进程来提高另一个进程，从而将单线程分割成多线程。由于这一点，高流量负载被减少并分配到具有相同端口的线程的不同实例上。它是Node.js的内置模块。由于Node.js支持异步单线程，有时当阻塞函数更多时，应用程序性能会下降。集群对于提高性能来说是最重要和最有用的。
- en: Node.js server initiates multiple incoming requests. First, it points to the
    main process that is called primary process or master, which is a single one.
    Afterwards it splits into different child processes from its parent process. Child
    process is called the worker process, which can be multiple and has its own event
    loop that processes it simultaneously. Clustering has two ways of distribution
    process. The first one is the default round robin method in which the master listens
    to server requests and sends them to the worker in an equally circular order,
    and the other one is socket based where the master listens and assigns only interested
    workers who want to do the process.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 服务器启动多个传入请求。首先，它指向主进程，也称为主进程或主节点，这是一个单一的进程。之后，它从父进程中分裂出不同的子进程。子进程被称为工作进程，可以有多个，并且拥有自己的事件循环来同时处理它。集群有两种进程分配方式。第一种是默认的轮询方法，其中主节点监听服务器请求并以等圆周顺序将它们发送到工作进程，另一种是基于套接字的方式，其中主节点监听并仅分配想要执行该进程的感兴趣的工作进程。
- en: Cluster architecture harnesses the capabilities of multiple interconnected servers,
    elevating the performance, reliability, and scalability of contemporary applications.
    *[Figure 1.13](#fig1_13)* provides a visual representation of how cluster nodes
    collaborate seamlessly to efficiently manage incoming requests.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 集群架构利用多个相互连接的服务器的功能，提高了当代应用程序的性能、可靠性和可扩展性。*[图1.13](#fig1_13)*展示了集群节点如何无缝协作，高效地管理传入请求。
- en: '![](img/1.13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.13.jpg)'
- en: '**Figure 1.13:** Cluster Diagram'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.13:** 集群图'
- en: '[Programming Without Cluster Module Example](toc.xhtml#s26a)'
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[无集群模块编程示例](toc.xhtml#s26a)'
- en: 'Create a file named as `**without_cluster.js**` and save the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`**without_cluster.js**`的文件，并保存以下代码：
- en: '`//Import http module for create server`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`//导入http模块以创建服务器`'
- en: '`const http = require(''http'');`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`const http = require(''http'');`'
- en: '`// create server and api for test`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 创建服务器和测试API`'
- en: '`http.createServer(function (req, res) {`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer(function (req, res) {`'
- en: '`if (req.url === "/api/test" && req.method === "GET") {`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (req.url === "/api/test" && req.method === "GET") {`'
- en: '`console.time(''API_without_cluster'');`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.time(''API_without_cluster'');`'
- en: '`let result = 0;`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`let result = 0;`'
- en: '`for (let i = 0; i < 5000000; i++) {`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (let i = 0; i < 5000000; i++) {`'
- en: '`result += i;`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`result += i;`'
- en: '`}`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`console.timeEnd(''API_without_cluster'');`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.timeEnd(''API_without_cluster'');`'
- en: '``console.log(`Result = ${result} - on process ${process.pid}`);``'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`结果 = ${result} - 在进程 ${process.pid}`);``'
- en: '``res.end(`Result = ${result}`);``'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '``res.end(`结果 = ${result}`);``'
- en: '`}`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}).listen(3001);`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`}).listen(3001);`'
- en: 'Run the code with this command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行代码：
- en: '`$ node without_cluster.js`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ node without_cluster.js`'
- en: Now we can test this in the browser with URL http://localhost:3001/api/test
    and call it multiple times continuously by hitting the refresh button multiple
    times.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在浏览器中使用URL http://localhost:3001/api/test来测试它，并通过多次点击刷新按钮连续调用它多次。
- en: 'The following output will be displayed in the console:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将在控制台显示：
- en: '![](img/1.14.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.14.jpg)'
- en: '**Figure 1.14:** Output Without Cluster'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**图1.14:** 无集群输出'
- en: '[Programming With Cluster Module Example](toc.xhtml#s27a)'
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[有集群模块编程示例](toc.xhtml#s27a)'
- en: 'Now create another file named `**cluster.js**` and save the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建另一个名为`**cluster.js**`的文件，并保存以下代码：
- en: '`//Import cluster module`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`//导入集群模块`'
- en: '`const cluster = require(''cluster'');`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`const cluster = require(''cluster'');`'
- en: '`//Import http module for create server`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`//导入http模块以创建服务器`'
- en: '`const http = require(''http'');`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`const http = require(''http'');`'
- en: '`//check if it is master process then create child process through fork() method`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`//检查是否为主进程，然后通过fork()方法创建子进程`'
- en: '`if (cluster.isMaster) {`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (cluster.isMaster) {`'
- en: '`const numWorkers = require(''os'').cpus().length;`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`const numWorkers = require(''os'').cpus().length;`'
- en: '``console.log(`Master ${process.pid} started`);``'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Master ${process.pid} started`);``'
- en: '``console.log(`Number of workers => ${numWorkers}`)``'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Number of workers => ${numWorkers}`)``'
- en: '`for (var i = 0; i < numWorkers; i++) {`'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (var i = 0; i < numWorkers; i++) {`'
- en: '`cluster.fork();`'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster.fork();`'
- en: '`}`'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`cluster.on(''exit'', (worker, code, signal) => {`'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster.on(''exit'', (worker, code, signal) => {`'
- en: '``console.log(`worker ${worker.process.pid} died`);``'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`worker ${worker.process.pid} died`);``'
- en: '`console.log("Let''s fork another worker!");`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log("Let''s fork another worker!");`'
- en: '`cluster.fork();`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster.fork();`'
- en: '`});`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`});`'
- en: '`} else {`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`} else {`'
- en: '`// it is worker process so run multiple process with same 3000 port`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 它是工作进程，因此使用相同的 3000 端口运行多个进程`'
- en: '``console.log(`Worker ${process.pid} started`);``'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Worker ${process.pid} started`);``'
- en: '`http.createServer(function (req, res) {`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer(function (req, res) {`'
- en: '`if (req.url === "/api/test" && req.method === "GET") {`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (req.url === "/api/test" && req.method === "GET") {`'
- en: '`console.time(''API_with_cluster'')`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.time(''API_with_cluster'')`'
- en: '`let result = 0;`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`let result = 0;`'
- en: '`for (let i = 0; i < 5000000; i++) {`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (let i = 0; i < 5000000; i++) {`'
- en: '`result += i;`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`result += i;`'
- en: '`}`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`console.timeEnd(''API_with_cluster'');`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.timeEnd(''API_with_cluster'');`'
- en: '``console.log(`Result = ${result} - on process ${process.pid}`);``'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '``console.log(`Result = ${result} - on process ${process.pid}`);``'
- en: '``res.end(`Result = ${result}`);``'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '``res.end(`Result = ${result}`);``'
- en: '`}`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`}).listen(3000);`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`}).listen(3000);`'
- en: '`}`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'Now run the code using this command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令来执行代码：
- en: '`$ node cluster.js`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ node cluster.js`'
- en: 'Open the browser with URL http://localhost:3000/api/test and call it multiple
    times. It will give the following output in the console:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，输入 URL http://localhost:3000/api/test 并多次调用它。控制台将给出以下输出：
- en: '![](img/1.15.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1.15.jpg)'
- en: '**Figure 1.15:** Output With Cluster'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 1.15：使用集群的输出**'
- en: As we can see that when we use the cluster module, the responses take less time
    between 12 and 16 ms, but without the cluster module, the time goes higher – 14
    to 22 ms. The difference here is not much since the code we are using has almost
    no logic, database operations, or any other IO. The time may be changed with implementation
    so cluster is useful when computation is heavy, but if there are not too many
    computations it might not be beneficial. Basically, cluster allows us to run multiple
    workers which can utilize more than one CPU.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当我们使用集群模块时，响应时间在 12 到 16 毫秒之间，而没有使用集群模块时，时间会更高——14 到 22 毫秒。这里的差异不大，因为我们使用的代码几乎没有任何逻辑、数据库操作或其他
    IO。时间可能会随着实现而变化，因此集群在计算量大时很有用，但如果计算量不是很大，可能就不太有益。基本上，集群允许我们运行多个工作进程，这些进程可以利用多个
    CPU。
- en: The cluster module can also be used to set up a master-worker setup where master
    monitors the workers and in case a worker stops or crashes, master can start another
    worker. This way, we can handle errors safely in the application and prevent applications
    from completely crashing. In *[Chapter 4, Planning the Application](c04.xhtml),*
    we will see it in action.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 集群模块还可以用来设置主从结构，其中主进程监控从进程，如果从进程停止或崩溃，主进程可以启动另一个从进程。这样，我们可以在应用程序中安全地处理错误，并防止应用程序完全崩溃。在*[第
    4 章，规划应用程序](c04.xhtml)*中，我们将看到它的实际应用。
- en: '[Conclusion](toc.xhtml#s28a)'
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[结论](toc.xhtml#s28a)'
- en: In this chapter, we got an introduction to Node.js and what it offers along
    with its pros and cons. We learned how to install Node.js and created a simple
    server. We also got familiar with how Node.js makes use of event loop and different
    types of architecture. Later we created a web server with HTTP and HTTPS. Finally,
    we saw how the cluster module can be used.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Node.js 以及它提供的功能及其优缺点。我们学习了如何安装 Node.js 并创建了一个简单的服务器。我们还熟悉了 Node.js
    如何使用事件循环和不同的架构类型。后来，我们使用 HTTP 和 HTTPS 创建了一个网络服务器。最后，我们看到了如何使用集群模块。
- en: In this chapter, we used JavaScript as a programming language, which is not
    maintainable when the project size becomes big. A better approach is to use Typescript
    instead of JavaScript. In the next chapter, we will learn the basics of Typescript.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了 JavaScript 作为编程语言，当项目规模变大时，它是不易维护的。更好的方法是使用 TypeScript 而不是 JavaScript。在下一章，我们将学习
    TypeScript 的基础知识。
- en: '[Multiple Choice Questions](toc.xhtml#s29a)'
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[多项选择题](toc.xhtml#s29a)'
- en: What is Node.js and which of the following statements about it is true?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 是什么，以下关于它的哪个陈述是正确的？
- en: Node.js is a closed-source JavaScript runtime environment
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 是一个封闭源代码的 JavaScript 运行时环境
- en: Node.js can only be used on Windows operating systems
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 只能在 Windows 操作系统上使用
- en: Node.js is primarily based on Python code
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 主要基于 Python 代码
- en: Node.js is an open-source JavaScript runtime environment that can be used on
    various operating systems
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 是一个开源的 JavaScript 运行时环境，可以在各种操作系统上使用
- en: For which types of applications is Node.js commonly used?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 通常用于哪些类型的应用？
- en: Node.js is mainly used for desktop applications and gaming
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 主要用于桌面应用和游戏
- en: Node.js is primarily utilized for mobile app development
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 主要用于移动应用开发
- en: Node.js is commonly employed for single-page applications (SPAs), real-time
    applications, Internet of Things (IoT) devices applications, and data streaming
    applications
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 通常用于单页应用（SPAs）、实时应用、物联网（IoT）设备应用和数据流应用
- en: Node.js is exclusively used for web-based email services like Gmail
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 仅用于基于 Web 的电子邮件服务，如 Gmail
- en: What is one of the key advantages of using Node.js for real-time applications?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Node.js 进行实时应用的关键优势之一是什么？
- en: Node.js is the only option for building real-time applications
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 是构建实时应用的唯一选择
- en: Node.js provides a graphical user interface for real-time applications
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 为实时应用提供图形用户界面
- en: Node.js offers a continuous connection through WebSockets, enabling faster response
    times
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 通过 WebSockets 提供持续连接，从而实现更快的响应时间
- en: Node.js can only be used for audio and video streaming applications
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 只能用于音频和视频流应用
- en: How can you check the version of Node.js installed on your system?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何检查系统上安装的 Node.js 版本？
- en: Run the command `**node version**` in the terminal
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端运行命令 `**node version**`
- en: Run the command `**node info**` in the terminal
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端运行命令 `**node info**`
- en: Run the command `**node --v**` in the terminal
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端运行命令 `**node --v**`
- en: Run the command `**node -v**` in the terminal
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端运行命令 `**node -v**`
- en: What is the key characteristic of the event loop in Node.js?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 事件循环的关键特征是什么？
- en: It executes blocking functions in parallel to improve performance
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过并行执行阻塞函数来提高性能
- en: It waits for all functions to complete before moving to the next
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在移动到下一个操作之前等待所有函数完成
- en: It handles rendering and user interface tasks in Node.js applications
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在 Node.js 应用程序中处理渲染和用户界面任务
- en: It manages asynchronous operations, ensuring non-blocking execution
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它管理异步操作，确保非阻塞执行
- en: How does microservices architecture differ from monolithic architecture?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构与单体架构有何不同？
- en: Microservices use a single codebase for all components
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务使用单一代码库的所有组件
- en: Microservices are tightly coupled and run as a single application
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务紧密耦合，作为一个单一的应用程序运行
- en: Microservices are loosely coupled and consist of independently deployable services
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务松散耦合，由独立可部署的服务组成
- en: Microservices communicate only via RESTful APIs
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务仅通过 RESTful API 进行通信
- en: When is serverless architecture a suitable choice for application development?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时无服务器架构是应用开发的合适选择？
- en: When you want to focus on writing code and not worry about server provisioning
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想要专注于编写代码而不必担心服务器配置时
- en: When the application has a monolithic codebase
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序有一个单体代码库时
- en: When you want to minimize development costs
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想最小化开发成本时
- en: When you need full control over server management
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你需要完全控制服务器管理时
- en: Which method in the HTTP module is used to create an HTTP server in Node.js?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 模块中哪个方法用于在 Node.js 中创建 HTTP 服务器？
- en: '`**http.createServer()**`'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**http.createServer()**`'
- en: '`**http.request()**`'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**http.request()**`'
- en: '`**http.get()**`'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**http.get()**`'
- en: '`**http.post()**`'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**http.post()**`'
- en: Which method is used to create a cluster of Node.js processes using the Cluster
    module?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cluster 模块创建 Node.js 进程集群的方法是哪个？
- en: '`**cluster.start()**`'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**cluster.start()**`'
- en: '`**cluster.fork()**`'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**cluster.fork()**`'
- en: '`**cluster.create()**`'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**cluster.create()**`'
- en: '`**cluster.spawn()**`'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**cluster.spawn()**`'
- en: How does the Cluster module enhance the performance of a Node.js application?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cluster 模块如何增强 Node.js 应用程序的性能？
- en: By creating multiple instances of the Node.js application
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建 Node.js 应用程序的多个实例
- en: By managing database connections more efficiently
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过更有效地管理数据库连接
- en: By reducing the number of available CPU cores
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过减少可用的 CPU 核心数
- en: By slowing down the application’s response time
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过减慢应用程序的响应时间
- en: '[Answers](toc.xhtml#s30a)'
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[答案](toc.xhtml#s30a)'
- en: d
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: c
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: c
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: d
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: c
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: a
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: b
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: '[Further Reading](toc.xhtml#s31a)'
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[进一步阅读](toc.xhtml#s31a)'
- en: '[https://nodejs.org/en](https://nodejs.org/en)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://nodejs.org/en](https://nodejs.org/en)'
