- en: '[CHAPTER 1](toc.xhtml#c01)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction to Node.js](toc.xhtml#c01)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s1a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The popularity of Node.js is booming day by day in the IT market worldwide.
    Through this book, any JavaScript developer can easily learn about Node.js from
    basic to advanced levels. This chapter talks about the Node.js basics and architecture.
    We will also learn how to write a simple Node.js program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s2a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Node.Js and Where It is Used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros and Cons of Node.Js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Node.Js on Various Platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Event-Driven Programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js Architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing HTTP and HTTPS Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Cluster Module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining Node.Js](toc.xhtml#s3a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Ryan Dahl demonstrated his remarkable work, *Node.js at JSConf 2009*, it
    was the beginning of a new era. He stated that the concurrency was achieved by
    threads in most of the top languages and that using threads has certain problems
    as context switching between threads is costly. Using the event loop, he showed
    that Node.js achieves way higher concurrency than any of the existing languages.
    People at the conference welcomed the idea and applauded Dahl. Thus began the
    much-awaited shift in the programming world.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is an open source cross-platform JavaScript runtime environment. It
    states that anyone can use it free of cost on any operating system such as Windows,
    Linux, Unix, Mac, and more. JavaScript is the foundation of Node.js. The code
    of any node.js application is written in JavaScript. This code runs on Google
    Chrome’s V8 JavaScript engine which converts source code to machine code directly
    without interpreting and then it gets executed without the need for a web browser.
    Node.js provides the necessary environment for the code to run.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.1:** Node.js Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Figure 1.1](#fig1_1)* shows a high level architecture of Node.js. Even though
    Node.js is single threaded, it still handles lots of concurrent requests at a
    time through a mechanism of asynchronous non-blocking I/O operations which provides
    hidden threads from the `**libuv**` library that executes itself as multi-threaded.'
  prefs: []
  type: TYPE_NORMAL
- en: Due to non-blocking I/O operation, Node.js is fast compared to other languages
    because the request does not wait for its response and parallelly executes another
    request. All requests are first sent to the event queue, processed in the event
    loop, and then sent back to the V8 engine through the queue as displayed in Node.js
    architecture. More about the event loop is elaborated in the section, “*Event-driven
    Mechanism*” later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is not only written for backend-side server programming applications
    but also developed as node modules and used on the client side, which is beneficial
    for developers as the same language is used on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: '[Applications of Node.js](toc.xhtml#s4a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usage of Node.js has been growing at a fast pace in IT Industries due to
    its features and different types of application. Here are a few examples of different
    types of applications related to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[Single-Page Applications](toc.xhtml#s5a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there are a lot of organizations and enterprises that provide complex
    and real time solutions to their clients by developing Node.js applications as
    server side applications through single-page applications. For example, Gmail,
    Twitter, Facebook, Trello, and many more applications are developed as SPA (Single-Page
    Applications). A single-page application communicates with the user’s actions
    by rewriting data on a single web page instead of reloading the whole web page.
  prefs: []
  type: TYPE_NORMAL
- en: '[Real-time Applications](toc.xhtml#s6a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is an ideal model for real-time applications because it gives responses
    to numerous requests at the same time. If there are a large number of users that
    need real-time response, Node.js is a better choice. You can use Node.js with
    WebSockets for continuous connection and to provide a faster response time. Applications
    such as audio, video, chat, multiplayer games, and stock trading are developed
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[IoT Devices Applications](toc.xhtml#s7a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to its faster response time and ability to handle large numbers of requests
    concurrently, Node.js is a good choice for Internet of Things (IoT) apps where
    devices or sensors are connected to the internet and send huge amounts of data
    continuously. IoT use cases such as fire detection, noise pollution measure, fitness
    tracker, health monitoring are many such applications where Node.js is playing
    a big role.
  prefs: []
  type: TYPE_NORMAL
- en: '[Data Streaming Application](toc.xhtml#s8a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js allows working with an abstract interface as a stream for data streaming.
    Large media files are divided into small chunks and sent as buffers. These buffers
    are transformed into meaningful data. Netflix-like streaming services use Node.js
    where data is transferred in chunks instead of whole large streams that reduce
    loading and delay while streaming happens.
  prefs: []
  type: TYPE_NORMAL
- en: The uses of Node.js are not limited to the preceding types of applications but
    also many more types of applications developed in Node.js such as making proxy
    or signaling servers, monitoring data-based applications, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pros of Node.js](toc.xhtml#s9a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js is a very powerful runtime environment for JavaScript. It allows developers
    to build high performance and scalable applications. Some of the key advantages
    that Node.js offers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross platform**: Node.js comes up with cross-platform functionality so the
    application can be easily developed on any OS and deployed on any platform. Key
    platforms supported by Node.js are Windows, Mac(Intel), Mac(ARM), and Linux (Intel/ARM).
    Probably every major platform is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High performance**: Node.js offers high performance due to asynchronous non-blocking
    I/O operations which execute requests in parallel without waiting for the response
    of any other request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to scale**: Node.js is itself single threaded but in heavy traffic,
    it handles a lot of requests at the same time to scale up with the “*cluster*”
    module which creates child processes and reduces the load on the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Node.js allows storing data in temporary memory that is not updated
    frequently, which reduces loading time and saves database transactions. This is
    called caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Huge community**: Ever since Node.js appeared, its community size has been
    increasing day by day. The language used for programming is JavaScript which has
    been the backbone of the internet and almost every front-end developer was already
    familiar with it. This made learning easy and made the community grow rapidly.
    There are more than 1.3 million open-source libraries available for use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other advantages as well such as cost-effectiveness, ease of
    learning, and adaptability. Node.js is a technique that has really made a difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[Cons of Node.js](toc.xhtml#s10a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some disadvantages of Node.js too. However many of these can be overcome
    using best practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Single threaded**: Node.js is single threaded, which is an advantage as well
    as a pitfall because it is unable to process heavy CPU oriented computation quickly.
    When requests which need more CPU for processing come in the event loop, they
    keep piling up because until it finishes one request, it will not pick other requests
    from the event queue. However, this happens only when there are only CPU centric
    tasks. If a request needs some IO to happen, another request will be picked while
    a request waits for IO to complete. CPU centric tasks make the performance low
    and delay the response. For example, for searching algorithms and mathematical
    calculations where complexity is high at that time, Node.js is not recommended
    due to poor performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callback hell:** Asynchronous programming in Node.js can be challenging for
    some developers, especially when using callbacks. Callback hell is a situation
    when callback functions are nested. This can make code difficult to read and maintain.
    However to avoid this, developers can use promises, async-await, or libraries
    such as Async.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library compatibility:** Although there are more than a million libraries
    available yet those being open sourced by individual developers might not be up-to-date
    to the latest versions. This sometimes makes it difficult to use those libs in
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Node.js](toc.xhtml#s11a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now when we have a high level understanding of what Node.js is and what it offers,
    let us jump to the setup. There are different ways to download and install Node.js
    in your system but here, we give the easiest and best way. Download the LTS (Long
    Term Support) Version of Node.js from its official site ([https://nodejs.org/en/download](https://nodejs.org/en/download))
    based on your operating system. On the site, there will be LTS and Current Version,
    choose the LTS version because it is stable and recommended for complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Node.js version 20 is ACTIVE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.2:** Node.js Versions'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding up-to-date release schedule can be seen on Node.js GitHub page—
    [https://github.com/nodejs/release#release-schedule](https://github.com/nodejs/release#release-schedule).
  prefs: []
  type: TYPE_NORMAL
- en: '[Installing Node For Linux/Ubuntu](toc.xhtml#s12a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NPM** (**Node Package Manager**) is the default package manager for node.js
    and also a library of JavaScript software packages. It is open source so that
    developers can install other modules in their project via npm free of cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node Version Manager (NVM)** is a shell script that manages multiple node
    versions and uses it on different projects.'
  prefs: []
  type: TYPE_NORMAL
- en: We can highlight the importance of installing Node.js through **NVM** with real
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using NVM, you can easily manage multiple Node.js versions on the same machine.
    Here is how it helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version Management**: NVM allows you to install multiple versions of Node.js
    on your system. This means you can switch between different versions seamlessly
    based on the requirements of your projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated Environments**: Each Node.js version installed through NVM is isolated
    from others. This ensures that changes made to one version won’t affect the others.
    It is particularly useful when you are working on projects with conflicting dependencies
    or when you need to maintain compatibility with older versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: With NVM, you have the flexibility to switch between Node.js
    versions effortlessly. This allows you to test your applications across different
    versions, ensuring compatibility and stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project-specific Versioning**: NVM allows you to specify the Node.js version
    required for a particular project. This ensures that each project uses the correct
    version of Node.js without interfering with others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy Updates**: NVM simplifies the process of updating Node.js to the latest
    version. You can easily upgrade or downgrade Node.js versions with a single command,
    ensuring that your development environment stays up-to-date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NVM for managing Node.js versions provides a streamlined and efficient workflow,
    enhancing productivity and reducing potential conflicts between projects. It is
    an essential tool for developers working on multiple Node.js projects simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the advantages of NVM, we will install Node.js through NVM on different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first install NVM and then install Node.js by NVM. Open terminal/console
    or cmd and follow three given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update your system with the latest versions of packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ sudo apt-get update`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download and install NVM using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh
    | bash`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before running the preceding command, make sure `curl` is installed on the
    system. If it is not installed then run the following commands to install and
    verify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ sudo apt install curl $ curl –version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify NVM version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ nvm –version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install Node.js as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ nvm install node`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command will install the latest stable version of node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To install Node.js with LTS version, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ nvm install -lts`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If anyone wants specific version of node, then add specific version at end
    of NVM and install as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ nvm install 18.15.0`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ nvm install 18.x`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding commands, 18.15.0 is a specific version of node.js and 18.x
    means it will consider the highest version of 18 above and below 19.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify Node.js version as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ node –version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After successfully executing the above steps, you can expect the following output
    to be displayed in the command prompt for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.3:** Linux Node.js Installation'
  prefs: []
  type: TYPE_NORMAL
- en: Once Node.js installed, by default NPM is also installed with Node.js installation
    package, which can be verified with `$ npm –version`
  prefs: []
  type: TYPE_NORMAL
- en: 'Other NVM commands which can be helpful for developers to play with node versions
    on different projects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ nvm ls` - Checks list of node version in the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ nvm use 18.x` – For specific use of node version on the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ nvm alias default 18.x` – It is to set default for all projects in the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ nvm uninstall 18.x`- It will uninstall that 18.x version from system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Installing Node.js for Windows](toc.xhtml#s13a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have covered Linux installation, now let us proceed with the installation
    process on Windows. You can follow the steps outlined below for Windows installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Node.js through NVM on Windows via the command prompt (`**cmd**`)
    requires the usage of a specialized tool called "`**nvm-windows**`". Here are
    the steps to install Node.js on Windows using `**nvm-windows**` via the command
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download NVM for Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the GitHub repository of `nvm-windows: nvm-windows`. You can explore
    more `**nvm**` for windows on [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the latest installer (.zip file) from the Releases section from following
    link: [https://github.com/coreybutler/nvm-windows/releases](https://github.com/coreybutler/nvm-windows/releases)
    Here, we will download `**nvm-setup.zip**` file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/1.4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 1.4:** Windows Node.js Download Zip File'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the Zip File:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the downloaded .zip file to a directory on your system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install `**NVM**` for Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Command Prompt as an administrator (right-click and select "`**Run
    as administrator**`"). Navigate to the directory where you extracted the `**nvm-windows**`
    files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/1.5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 1.5:** NVM Install Select Location'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click `**Finish**` to complete the process:![](img/1.6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Figure 1.6:** NVM Finish Install Process'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the `**nvm-setup.zip**` executable to start the installation process. Follow
    the on-screen instructions to complete the installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify NVM Installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close and reopen the Command prompt as administrator. Run the command NVM version
    to ensure that NVM is installed correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install Node.js:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once NVM is installed, you can use it to install Node.js. To install a specific
    version of Node.js, use the command `**nvm install <version>**` (for example,
    `**nvm install 18.0.0**`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the installation is complete, you can switch between Node.js versions
    using the `**nvm use <version>**` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify Node.js Installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `**node -v**` to verify that Node.js is installed and the correct
    version is active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Installing Node.js for mac](toc.xhtml#s14a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installation of Node.js on Mac OS is similar to that of Linux. Follow the given
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install NVM: To install NVM, we just need to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh |
    bash`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please make sure that `**curl**` is available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install Node.js using NVM. In case, we just want to install latest Node.js,
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nvm install node`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This command will automatically download and install the latest Node.js version.
    In case you want to install the LTS (Long term support) version, run this command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`nvm install –-lts`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Please note that there are two `'`-’ hyphens before lts).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify the installation by opening the console and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`node --version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will output the version installed, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`v20.0.0`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also check the npm version using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`npm -- version`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`9.6.4`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Event-Driven Mechanism](toc.xhtml#s15a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js is an asynchronous non-blocking event-driven programming. Any action
    that happens is called an event and it is either done by the user or the system
    itself. Node.js provides an inbuilt module Event, which is an instance of `**EventEmitter**`.
    Event is an I/O request that is first sent to the Event Queue. If there are multiple
    concurrent requests coming to the queue, then the queue passes it to the event
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.7:** Event-Driven Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Event loop monitors the event queue, collects the events from it, then processes
    it and executes based on blocking and non-blocking functions. Blocking functions
    are executed sequentially, one after the other, and the second function is not
    called until the first one responds. Sometimes it depends on external resources
    and waits for its response which takes longer time, whereas non-blocking functions
    do not need to wait for any response. It executes asynchronously, which means
    multiple functions run parallel at a time so that they are not depending on one
    another. Blocking and non-blocking functions send thread and I/O Pool to its pools,
    respectively. Once the actual operation is done, the response of that request
    is sent back to the event queue via event loop. In nutshell, events are emitted
    and then registered or unregistered through a queue, which is monitored by the
    event loop, binding the appropriate handlers accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js follows a non-blocking asynchronous model even though it has a single
    thread that handles multiple requests at a time, without blocking its call respective
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of Event Programming](toc.xhtml#s16a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file save with `**event_index.js**` and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Import ''events'' module`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const events = require(''events'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Initiate an EventEmitter object`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const eventEmitter = new events.EventEmitter();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Binds event handler for send message`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eventEmitter.on(''send_message'', function () {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Hi, This is my first message'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Handler associated with the connection event`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const connectHandler = function connected() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Connection is created'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Trigger the corresponding event`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eventEmitter.emit(''send_message'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Binds the event with handler`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eventEmitter.on(''connection'', connectHandler);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Trigger the connection event`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eventEmitter.emit(''connection'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log("Finish");`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the file with `**$ node event_index.js**` and the following output will
    be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Connection is created`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hi, This is my first message`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Finish`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of Synchronous Code](toc.xhtml#s17a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create one file named hello.txt and paste the following text in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello, I am Developer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file named index.js within the same folder, paste the following
    code and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const fs = require(''fs'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Start'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const data = fs.readFileSync(''hello.txt'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(data.toString());`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''End'');`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**$ node sync_index.js**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello, I am Developer`'
  prefs: []
  type: TYPE_NORMAL
- en: '`End`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, fs is a file system module importing it and `**fs.readFileSync()**` is
    a synchronous function which waits until file read is complete and assigns that
    response to the data variable. It prints line-by-line and executes synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example of Asynchronous code](toc.xhtml#s18a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create one file named `**hello.txt**` and paste the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello, I am Developer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file named `**index.js**` within the same folder, paste the
    following code and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const fs = require(''fs'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Start'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.readFile(''hello.txt'', function (err, data) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (err) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return console.error(err);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(data.toString());`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''End'');`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ node async_index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start`'
  prefs: []
  type: TYPE_NORMAL
- en: '`End`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello, I am Developer`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, fs is a file system module. We import it, and `**fs.readFile()**` is an
    asynchronous function. This function does not wait for the file read to complete.
    Instead, it has a callback function. Once the file read operation is finished,
    the `**callback**` function executes and prints the data. Therefore, the line
    after the callback is executed asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '[Types of Node.js Architectures](toc.xhtml#s19a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start developing the applications using Node.js, it is important to
    decide how your application should be structured. There are many ways to structure
    your Node.js application with different kinds of architecture. Let us discuss
    those briefly here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Monolithic Architecture](toc.xhtml#s20a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this architecture, all components or modules of business logic are blended
    together in a single unit. Almost all web servers or server-side frameworks are
    built using monolithic architecture (see *[Figure 1.8](#fig1_8)*), which is the
    easiest way for developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.8:** Monolithic Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: For smaller applications that do not require extensive scalability, this architecture
    can be suitable. However, it may not be well-suited for larger and more complex
    applications. As the traffic load on your server-side application grows, you will
    need to scale it to handle the increased demand. In this architecture, you have
    a single main Node.js server file that routes all API requests to controllers
    and services, managing database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: You can scale a monolithic architecture using clusters to reduce the load. However,
    there are instances when a single server is unable to handle the incoming traffic.
    In such cases, you can deploy the same code on multiple servers, run application
    servers, and employ a load balancer like Nginx. The load balancer, using a round-robin
    approach, becomes a reliable solution, especially for very large and heavily used
    applications. We will delve into this aspect in more detail in the deployment
    section. The biggest drawback of this structure is that if there is a small change
    needed on any component, then it needs to be done in all servers and rebuilt and
    redeployed again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Microservice Architecture](toc.xhtml#s21a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservices architecture is a type of architecture that is developed as
    a collection of services. The framework provided here allows us to develop and
    deploy the microservices along with maintaining them independently. Microservices
    sort out the challenges of monolithic systems by fragmenting the application from
    a whole into several smaller parts. It is reliable and suitable for large and
    complex applications such as e-commerce platforms, social sites where multiple
    features are provided to millions of users at same time. Hence, during maintenance
    or while adding new features, it does not interrupt other existing features and
    deploy only updated services. Nowadays, it is trending more and more for its flexibility
    where multiple developers work individually and are only responsible for their
    own small code instead of whole system code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this architecture, all components or modules of business logic are individual.
    Many large enterprises use this kind of microservice architecture (see *[Figure
    1.9](#fig1_9)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.9:** Microservice Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As per the preceding diagram, client as user or UI sends a request, which is
    collected by API Gateway and passed to the respective microservice, which has
    its own function (Lambda Function). This function connects to the database and
    gives back a response accordingly. Each microservice can be easily changed and
    deployed without affecting each other. In addition, these microservices also call
    each other through API HTTP service or gRPC (Google Remote Procedure Call) which
    is a generic flow of microservice architecture. However, while it is a cost-effective
    and time-saving architecture for development, it may not be suitable for smaller
    applications. This is because it relies on cloud-based solutions, which can become
    expensive even with minimal setup requirements. This cost issue can often be mitigated
    by adopting more budget-friendly solutions offered by monolithic architectures.
    In fact, microservices represent a way to leverage serverless architecture within
    the realm of cloud computing.
  prefs: []
  type: TYPE_NORMAL
- en: '[Serverless Architecture](toc.xhtml#s22a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless architecture is the approach for developing and building applications
    without managing infrastructure. Basically any app is developed and deployed on
    a specific server. However, managing the server hosting process can be a cumbersome
    task for developers. This is where serverless architecture becomes a boon for
    those who want to avoid server management and only pay for what they use. In serverless
    architecture, everything is handled by third-party services provided by cloud
    computing providers like AWS, Azure, Google, etc. These providers offer respective
    functions like AWS Lambda functions, Microsoft Azure functions, and Google Cloud
    functions, which is why it is also referred to as “*Function as a Service*” (FaaS).
    However, it is important to note that this approach has its drawbacks, as it involves
    entrusting everything to third parties, which can raise security concerns. Even
    though it has some limitations, it is still becoming more popular because organizations
    focus on actual products and services, not infrastructure, so it will be cost
    effective for those who spend a lot of effort on infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.10:** Serverless Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: In this serverless architecture, a transformative approach for application development
    and deployment that eliminates the need for traditional server management. Instead,
    it enables developers to focus solely on writing code while cloud providers handle
    the underlying infrastructure. Below is a visual representation of this serverless
    concept (see *[Figure 1.10](#fig1_10)*).
  prefs: []
  type: TYPE_NORMAL
- en: It is an example of AWS serverless architecture in which an AWS API gateway
    is used to route REST API calls and is based on the route Lambda function called
    with an attached gateway. Lambda functions can be written in different languages
    but we consider them to be written in Node.js code that have the actual business
    logic to perform action to the database. AWS Cloud provides various database instances
    such as DynamoDB, MySQL, PostgreSQL, and others. Furthermore, it can effortlessly
    scale to accommodate increasing workloads. AWS offers auto-scaling capabilities,
    which means it can automatically add more EC2 instances when there is a surge
    in load and reduce instances when the load decreases.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aspect** | **Monolithic Architecture** | **Microservices Architecture**
    | **Serverless Architecture** |'
  prefs: []
  type: TYPE_TB
- en: '| Development | Easier setup and development process | Complex setup, but independent
    services promote scalability | Focuses on writing functions without managing infrastructure
    |'
  prefs: []
  type: TYPE_TB
- en: '| Scalability | Limited scalability due to the entire application being scaled
    | Scalable, as each service can be independently scaled | Automatically scales
    based on demand |'
  prefs: []
  type: TYPE_TB
- en: '| Maintenance | Single codebase makes maintenance easier | Requires management
    of multiple services and communication | Less management overhead; managed by
    cloud provider |'
  prefs: []
  type: TYPE_TB
- en: '| Technology Stack | Limited flexibility; all components use the same technology
    stack | Flexibility to use different technologies for each service | Limited control
    over underlying infrastructure and runtime |'
  prefs: []
  type: TYPE_TB
- en: '| Deployment | Simple deployment process; deploy as a single unit | Deployment
    complexity due to multiple services | Simplified deployment process |'
  prefs: []
  type: TYPE_TB
- en: '| Resource Utilization | Resource utilization may be inefficient | Optimized
    resource utilization with services scaled as needed | Efficient resource utilization
    with on-demand execution |'
  prefs: []
  type: TYPE_TB
- en: '| Cost | Lower upfront costs; higher operational costs in the long term | Higher
    initial setup costs; potential cost savings with scale | Pay-per-use model can
    be cost-effective for low traffic apps |'
  prefs: []
  type: TYPE_TB
- en: '| Fault Isolation | A bug in one part can affect the entire application | Faults
    are isolated to specific services; others remain unaffected | Managed by cloud
    provider, potential vendor lock-in |'
  prefs: []
  type: TYPE_TB
- en: '| Flexibility | Limited flexibility due to the monolithic structure | Flexibility
    to use different technologies and languages | Limited control over underlying
    infrastructure and runtime |'
  prefs: []
  type: TYPE_TB
- en: '**Table 1.1:** Comparisons of Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Table 1.1](#tab1_1)* provides a comparison of various aspects of monolithic,
    microservices, and serverless architectures in Node.js, outlining their respective
    advantages and disadvantages. Depending on specific project requirements, one
    architecture may be more suitable than the others.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us create a basic http and https server with programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing an HTTP Server](toc.xhtml#s23a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now when Node.js is properly set up and running in your system, let us do the
    famous "`**Hello World**`" in Node.js way by serving this through an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a file with name index.js, and copy the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const http = require(''http'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const hostname = ''127.0.0.1'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const port = 3000;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const server = http.createServer((req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.statusCode = 200;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.setHeader(''Content-Type'', ''text/plain'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.end(''Hello World'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`server.listen(port, hostname, () => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Server running at http://${hostname}:${port}/`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: In the provided code, "`**http**`" is a default module provided by Node.js,
    so there is no need to install it separately. However, for modules not included
    in Node.js’s built-in modules, you can install them from the npm library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The npm library contains millions of registered packages, and you can install
    them using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install package-name`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ex. npm install express`'
  prefs: []
  type: TYPE_NORMAL
- en: package-name can be as "`**body-parser**`", "`**express**`", "`**moment**`",
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The http module creates a http server that runs on specific port 3000\. Ideally,
    Node.js runs on port 3000 but developers can assign different ports such as 3001,
    4000 or any port. Just need to make sure that the port number does not conflict
    with other applications on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the program, open console with source code directory and paste the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ node index.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Once it runs, open the browser and go to the URL as http://localhost:3000; it
    will print "`**Hello World**`".
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.11:** HTTP Server Program Output'
  prefs: []
  type: TYPE_NORMAL
- en: '[Making it HTTPS](toc.xhtml#s24a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server we just created does not provide a secure way of serving APIs. Most
    often, we need to serve the APIs using HTTPS rather than HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP does not encrypt the data, thus it is not secure where the information
    is leaked during transmission. On the other hand, HTTPS encrypts data during transmission
    on request from client to server that makes it secure.
  prefs: []
  type: TYPE_NORMAL
- en: Let us rewrite the same code with the https server. For HTTPS, we need SSL certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first create a self-signed SSL certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: Open console and install `**openssl**` if not installed in your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Debian Linux such as ubuntu, installation can be done using the `**apt**`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ sudo apt install openssl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Centos, Fedora, and Rocky Linux, yum can be used to install `**openssl**`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ sudo yum install openssl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make `**openssl**` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$mkdir openssl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$cd openssl`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Request to generate `**ssl**` certificate with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ openssl req -newkey rsa -x509 -sha256 -days 365 -nodes -out ssl.crt -keyout
    ssl.key`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us understand the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**-newkey rsa**` : create new key with `**rsa**` algorithm default 2048 bit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-x509**` : creates a X.509 Certificate'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-sha256**` : use 265-bit SHA (Secure Hash Algorithm)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-days 365**` : The number of days to certify the certificate for 365\. You
    can use any positive integer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-nodes**` : creates a key without a passphrase.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-out ssl.crt**` : Specifies the filename to write the newly created certificate
    to. You can specify any file name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**-keyout ssl.key**` : Specifies the filename to write the newly created private
    key to. You can specify any file name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you enter this command, it will prompt the following questions (as shown
    in *[Figure 1.12](#fig1_12)*). Press enter until done and check that folder which
    has `**ssl.crt**` and `**ssl.key**` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.12:** Openssl Certificate Generation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create `**main.js**` and write the following code to create `**https server**`
    with `**port 3000**`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// import https module`'
  prefs: []
  type: TYPE_NORMAL
- en: '``const https = require(`https`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`//import fs module to read files`'
  prefs: []
  type: TYPE_NORMAL
- en: '``const fs = require(`fs`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`const options = {`'
  prefs: []
  type: TYPE_NORMAL
- en: '``key: fs.readFileSync(`./openssl/ssl.key`),``'
  prefs: []
  type: TYPE_NORMAL
- en: '``cert: fs.readFileSync(`./openssl/ssl.crt`)``'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// create https server on port 3000`'
  prefs: []
  type: TYPE_NORMAL
- en: '`https.createServer(options, (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.writeHead(200);`'
  prefs: []
  type: TYPE_NORMAL
- en: '``res.end(`hello world from https server \n`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`}).listen(3000);`'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code with node main.js and open the browser with https://localhost:3000
    which displays "`**hello world from https server**`". This way a secure https
    server is built with very basic examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Cluster Module](toc.xhtml#s25a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js can easily make applications highly scalable through the cluster module.
    Cluster is creating a child process so that it raises another process which splits
    single thread into multi thread. Due to that heavy traffic load is reduced and
    shared on different instances of thread with the same port. It is a built-in module
    of Node.js. As Node.js supports async single thread and sometimes when blocking
    functions are more, the application performance gets down. Cluster is most important
    and useful to improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js server initiates multiple incoming requests. First, it points to the
    main process that is called primary process or master, which is a single one.
    Afterwards it splits into different child processes from its parent process. Child
    process is called the worker process, which can be multiple and has its own event
    loop that processes it simultaneously. Clustering has two ways of distribution
    process. The first one is the default round robin method in which the master listens
    to server requests and sends them to the worker in an equally circular order,
    and the other one is socket based where the master listens and assigns only interested
    workers who want to do the process.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster architecture harnesses the capabilities of multiple interconnected servers,
    elevating the performance, reliability, and scalability of contemporary applications.
    *[Figure 1.13](#fig1_13)* provides a visual representation of how cluster nodes
    collaborate seamlessly to efficiently manage incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.13:** Cluster Diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '[Programming Without Cluster Module Example](toc.xhtml#s26a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named as `**without_cluster.js**` and save the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//Import http module for create server`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const http = require(''http'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// create server and api for test`'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.createServer(function (req, res) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (req.url === "/api/test" && req.method === "GET") {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.time(''API_without_cluster'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let result = 0;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for (let i = 0; i < 5000000; i++) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`result += i;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeEnd(''API_without_cluster'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Result = ${result} - on process ${process.pid}`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '``res.end(`Result = ${result}`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}).listen(3001);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ node without_cluster.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can test this in the browser with URL http://localhost:3001/api/test
    and call it multiple times continuously by hitting the refresh button multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output will be displayed in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.14:** Output Without Cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '[Programming With Cluster Module Example](toc.xhtml#s27a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now create another file named `**cluster.js**` and save the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`//Import cluster module`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const cluster = require(''cluster'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//Import http module for create server`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const http = require(''http'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//check if it is master process then create child process through fork() method`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (cluster.isMaster) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const numWorkers = require(''os'').cpus().length;`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Master ${process.pid} started`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Number of workers => ${numWorkers}`)``'
  prefs: []
  type: TYPE_NORMAL
- en: '`for (var i = 0; i < numWorkers; i++) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster.fork();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster.on(''exit'', (worker, code, signal) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`worker ${worker.process.pid} died`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log("Let''s fork another worker!");`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster.fork();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`} else {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// it is worker process so run multiple process with same 3000 port`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Worker ${process.pid} started`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.createServer(function (req, res) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (req.url === "/api/test" && req.method === "GET") {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.time(''API_with_cluster'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let result = 0;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for (let i = 0; i < 5000000; i++) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`result += i;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.timeEnd(''API_with_cluster'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '``console.log(`Result = ${result} - on process ${process.pid}`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '``res.end(`Result = ${result}`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}).listen(3000);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the code using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ node cluster.js`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the browser with URL http://localhost:3000/api/test and call it multiple
    times. It will give the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.15:** Output With Cluster'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see that when we use the cluster module, the responses take less time
    between 12 and 16 ms, but without the cluster module, the time goes higher – 14
    to 22 ms. The difference here is not much since the code we are using has almost
    no logic, database operations, or any other IO. The time may be changed with implementation
    so cluster is useful when computation is heavy, but if there are not too many
    computations it might not be beneficial. Basically, cluster allows us to run multiple
    workers which can utilize more than one CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster module can also be used to set up a master-worker setup where master
    monitors the workers and in case a worker stops or crashes, master can start another
    worker. This way, we can handle errors safely in the application and prevent applications
    from completely crashing. In *[Chapter 4, Planning the Application](c04.xhtml),*
    we will see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s28a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got an introduction to Node.js and what it offers along
    with its pros and cons. We learned how to install Node.js and created a simple
    server. We also got familiar with how Node.js makes use of event loop and different
    types of architecture. Later we created a web server with HTTP and HTTPS. Finally,
    we saw how the cluster module can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we used JavaScript as a programming language, which is not
    maintainable when the project size becomes big. A better approach is to use Typescript
    instead of JavaScript. In the next chapter, we will learn the basics of Typescript.
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple Choice Questions](toc.xhtml#s29a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Node.js and which of the following statements about it is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is a closed-source JavaScript runtime environment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js can only be used on Windows operating systems
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is primarily based on Python code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is an open-source JavaScript runtime environment that can be used on
    various operating systems
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For which types of applications is Node.js commonly used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is mainly used for desktop applications and gaming
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is primarily utilized for mobile app development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is commonly employed for single-page applications (SPAs), real-time
    applications, Internet of Things (IoT) devices applications, and data streaming
    applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is exclusively used for web-based email services like Gmail
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is one of the key advantages of using Node.js for real-time applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js is the only option for building real-time applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js provides a graphical user interface for real-time applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js offers a continuous connection through WebSockets, enabling faster response
    times
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Node.js can only be used for audio and video streaming applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check the version of Node.js installed on your system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `**node version**` in the terminal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `**node info**` in the terminal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `**node --v**` in the terminal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the command `**node -v**` in the terminal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the key characteristic of the event loop in Node.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It executes blocking functions in parallel to improve performance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It waits for all functions to complete before moving to the next
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It handles rendering and user interface tasks in Node.js applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It manages asynchronous operations, ensuring non-blocking execution
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does microservices architecture differ from monolithic architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices use a single codebase for all components
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices are tightly coupled and run as a single application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices are loosely coupled and consist of independently deployable services
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microservices communicate only via RESTful APIs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When is serverless architecture a suitable choice for application development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you want to focus on writing code and not worry about server provisioning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When the application has a monolithic codebase
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When you want to minimize development costs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When you need full control over server management
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method in the HTTP module is used to create an HTTP server in Node.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**http.createServer()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**http.request()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**http.get()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**http.post()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method is used to create a cluster of Node.js processes using the Cluster
    module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**cluster.start()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**cluster.fork()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**cluster.create()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`**cluster.spawn()**`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the Cluster module enhance the performance of a Node.js application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By creating multiple instances of the Node.js application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By managing database connections more efficiently
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By reducing the number of available CPU cores
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By slowing down the application’s response time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Answers](toc.xhtml#s30a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Further Reading](toc.xhtml#s31a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://nodejs.org/en](https://nodejs.org/en)'
  prefs: []
  type: TYPE_NORMAL
