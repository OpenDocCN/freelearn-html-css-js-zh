<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Scaling Up – Ensuring Performance in Complex Applications</h1></div></div></div><p>In this chapter, we will look at the most common performance issues in Backbone, as well as how to avoid them. In particular, we'll cover the following:</p><div><ul class="itemizedlist"><li class="listitem">CPU-based performance issues</li><li class="listitem">Bandwidth-based performance issues related to content size</li><li class="listitem">Bandwidth-based performance issues related to the number of requests</li><li class="listitem">Memory-based performance issues</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Backbone and performance</h1></div></div></div><p>At its core, Backbone is just a <a id="id250" class="indexterm"/>JavaScript library, and as such, it doesn't add any new performance challenges that weren't already in JavaScript to begin with. In fact, the creators of Backbone have taken great care to make the library perform well, and in performance comparisons with rival libraries, Backbone typically comes out ahead, if not on top.</p><p>However, while Backbone itself doesn't create performance issues, it does enable entirely new ways of creating web applications, and because such applications can be far more complex than traditional websites, a whole new realm of potential performance issues is exposed. In this chapter, we will explore these issues, as well as their underlying technical details, and address ways to avoid or mitigate them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Causes of performance issues</h1></div></div></div><p>Whenever a user experiences<a id="id251" class="indexterm"/> performance problems, it is because he has exceeded the capacity of one of his system resources, either bandwidth memory or processing power. Before debugging any performance issue, it's essential to understand which of these factors is responsible, and this can be determined in one of two ways. First, a profiling tool (such as the tools included with all major browsers) can be used to measure how much of each resource is being used, which should quickly make obvious which resource is being used excessively. An explanation of these tools falls outside the scope of this book, but I strongly encourage you to familiarize yourself with the tools available in your favorite browser.</p><p>For most problems, however, a profiling tool won't even be necessary, because their source can be determined by how they manifest. Bandwidth problems only occur when retrieving or sending data from your server (and in most applications, only retrieval operations involve enough bandwidth to be problematic). If they occur at load time, then they could be caused by a significant number of large static resources, such as images, but if they occur afterwards, they are far more likely to be the result of AJAX calls. In Backbone applications, this means <em>fetch</em> operations (or, rarely, <em>save</em> or <em>destroy</em> operations) from <code class="literal">Models</code> or <code class="literal">Collections</code>.</p><p>CPU performance issues only occur when the user's computer is forced to think hard about something you are making it do. For example, a series of nested <code class="literal">for</code> loops, or the rendering of a complex visualization such as a chart can cause such performance issues. This type of performance issue is usually easy to identify because it only occurs when the user triggers such computationally intensive code.</p><p>The final, and by far the most difficult, source of performance issues is the memory. Unlike the other two issues, which usually have obvious triggers such as the start of an AJAX operation or the rendering of a chart, memory issues can occur without any clear or obvious source. In fact, memory issues can begin seconds or even minutes before the user actually starts noticing problems, forcing you to trace back through all the code they hit to try and find a cause. Because memory issues are the most common type, and because they are the hardest to understand and resolve, we will be focusing most heavily on them in this chapter. However, before we do so, let's examine the other two sources, and some common sense approaches to avoiding them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>CPU-related performance issues</h1></div></div></div><p>As mentioned earlier, Backbone<a id="id252" class="indexterm"/> itself will not usually be the source of CPU-related performance issues, because these issues tend to be caused by specific components rather than the overall site architecture. However, there is one way that Backbone can contribute to such problems, and that is by making it easy to repeat the same work in multiple places. For instance, let's imagine that you are creating a dashboard page that will use one main <code class="literal">View</code> class to show your user various pieces of data, and a number of child <code class="literal">Views</code> to render each of these pieces of data. In addition, let's imagine that each of these pieces of data will update periodically. Normally, you would tie the updating of that data to an AJAX response or a user event, but under certain circumstances, you might instead want to use a <code class="literal">setInterval</code> statement. For instance, <code class="literal">onScroll</code> events are known to be problematic, so many developers avoid them and instead rely on <code class="literal">setInterval</code> to check for scrolling periodically.</p><p>This approach will work fine as long as there is only a single <code class="literal">setInterval</code> event running, but what if you instead decide to create a separate <code class="literal">setInterval</code> event for each child <code class="literal">View</code>? With only a few child <code class="literal">Views</code>, this still might work, but eventually, too many such intervals will become a drain on the user's CPU, causing performance problems. In the worst case scenario, while your development machine will be able to handle the page, your user's (less powerful) machine might not, causing the user to report bugs that you can't reproduce.</p><p>The solution in such cases<a id="id253" class="indexterm"/> is straightforward: Don't repeat processing-intensive tasks unnecessarily. In the preceding example, instead of having each child <code class="literal">View</code> update in response to its own <code class="literal">setInterval</code> event, you could start only a single <code class="literal">setIonterval</code> process in the main <code class="literal">View</code> and then, have it trigger updates in your child <code class="literal">Views</code> (possibly by using the pub/sub pattern described in the previous chapter).</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Event delegation</h1></div></div></div><p>One other way developers can easily<a id="id254" class="indexterm"/> create unnecessary strain on the user's browser is by creating too many event handlers. For instance, let's say you want to create a large table (perhaps 20 rows × 20 columns), so you create a parent <code class="literal">View</code> for the table and a large number of child <code class="literal">Views</code> for each cell. So far so good! Now let's say, you add a <code class="literal">click</code> event handler to each of these child <code class="literal">Views</code>. Without realizing it, you just created 400 event handlers. If you add another event handler, such as a <code class="literal">change</code> handler for <code class="literal">&lt;input&gt;</code> elements inside the cell, you add another 400, and so on.</p><p>Given enough <code class="literal">Views</code> and enough event handlers, this can eventually create a performance issue, but luckily, JavaScript comes with a built-in mechanism that we can use to solve this problem: event bubbling. Whenever an event occurs in the DOM, it first triggers event handlers on the relevant DOM element and then bubbles up to each successive parent of that element. In other words, if a <code class="literal">click</code> event occurs on a <code class="literal">&lt;td&gt;</code> element, the browser will resolve any event handlers bound to that <code class="literal">&lt;td&gt;</code> element first, then (unless one of the event handlers returned false) it will call the handlers on the <code class="literal">&lt;td&gt;</code> element's parent <code class="literal">&lt;tr&gt;</code> element and then that <code class="literal">&lt;tr&gt;</code> parent's <code class="literal">&lt;table&gt;</code>:</p><div><pre class="programlisting">$(document.body).append('&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;');
$('td').on('click', function(e) {
    e.target; // will be the td element
    e.currentTarget; // will also be the td element
});
$('tr').on('click', function(e) {
    e.target; // will still be the td element
    e.currentTarget; // will be the tr element
});
$('table').on('click', function(e) {
    e.target; // will still be the td element
    e.currentTarget; // will be the table element
});
$('td').click(); // first the td handler will trigger, then the tr
                 // handler, and finally the table handler</pre></div><p>We can take advantage of <a id="id255" class="indexterm"/>this fact and change our event binding strategy to improve performance by binding our events to the parent <code class="literal">table</code> element's <code class="literal">View</code> rather than to each child <code class="literal">View</code>. This parent <code class="literal">View</code> event handler can then trigger the appropriate logic on the relevant child <code class="literal">View</code> by using the event's <code class="literal">target</code> property to determine which child <code class="literal">View</code> caused the event. While this approach requires slightly more work, it allows us to reduce our 400 click event handlers down to a single event handler, and on particularly complex pages (such as our hypothetical table page), the use of such event delegation can significantly reduce the strain on the browser.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Bandwidth-related performance issues</h1></div></div></div><p>While it's true that the typical <a id="id256" class="indexterm"/>user's bandwidth has grown significantly in the recent years, the bandwidth nevertheless remains a constant issue for web developers. However, many developers don't realize that there are actually two main sources of bandwidth problems. The first of these is fairly obvious: forcing your users to download files that are too large. But, there is also a second, less obvious source: forcing your users to download too many files at once.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec31"/>Downloading excessively large files</h2></div></div></div><p>Let's start with the<a id="id257" class="indexterm"/> obvious source first. If the files that your users need to download are too large, it doesn't matter whether they are images, videos, or JavaScript code files: Your site is going to load slowly. However, you can make a big difference in the size of any file you use by enabling compression at the web server level. On an Apache web server, this can be done by using <code class="literal">mod_deflate</code>, and most other web servers have similar options. Doing so will make your server compress the files that it sends to your users in such a way that your users' browser can easily decompress them … all without the user even knowing that any decompression is going on.</p><p>However, if turning on compression doesn't help enough, then your next steps depend on the file type. If your issues come from images or videos, then you simply have to find a way to use smaller files, for instance, by lowering their resolution. However, if JavaScript files are your main concern, there is another option: using a minification program.</p><p>Minification programs <a id="id258" class="indexterm"/>parse your code to create a new optimized version of it that eliminates comments, removes extra whitespace, and renames variables with shorter names. The only downside to using such a program is that it will make it harder for you to debug problems on your production servers, which shouldn't be an issue as long as you have a matching development environment where you don't minify your files. Further, if the minification truly becomes a problem, you can always temporarily switch your server back to the unminified files to do your debugging.</p><p>Together the two techniques of web server compression and minification can result in a major difference in file size. For example, the uncompressed jQuery library (version 1.11.0) is 276 KB, while the zipped version is only 82 KB and the zipped version of the minified jQuery code is only 33 KB. In other words, just by using these two techniques, it's possible to reduce jQuery's footprint by almost a factor of ten!</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec32"/>Downloading excessive number of files</h2></div></div></div><p>Unfortunately though, even <a id="id259" class="indexterm"/>if you reduce the bandwidth of your code files and assets, there is also another, more subtle bandwidth issue to worry about that has nothing to do with the number of bytes your user downloads. To understand this issue, you have to understand how browsers handle requests for data, both those that come from the DOM (such as the <code class="literal">&lt;link&gt;</code> and <code class="literal">&lt;script&gt;</code> tags) and AJAX requests.</p><p>When a browser opens up a connection to a particular remote computer, it keeps track of how many other connections have already been opened to that computer's domain, and if too many are already open, it pauses until one of the previous requests completes. The exact number of connections that can occur before this happens varies by browser: In Internet Explorer 7, it's only two, but in most modern browsers, it's six or eight. Because of this limit, and because each request, no matter how small, has a certain minimum amount of time that it will take (also called latency), the actual amount of bandwidth used can be irrelevant. There are two main approaches for solving a bandwidth issue.</p><p>The first is, obviously, to make fewer requests. If your problem is too many <code class="literal">Models</code> being fetched at once, <code class="literal">Collections</code> can be very helpful in solving it; instead of fetching each <code class="literal">Model</code> class individually, simply create an endpoint on your server that can return all of the <code class="literal">Models</code> at once and then, use a <code class="literal">Collection</code> class to fetch them. Even though you will be downloading the same amount of data, this change in API will result in significantly less requests. Similarly, if your problem is too many images, you can combine all of the images into a single <code class="literal">sprites</code> file and then, use CSS to only display one image at a time.</p><p>The other option, if your application truly does require a large number of requests, is to use subdomains. When a browser counts how many connections it has outstanding, it doesn't just look at the source's domain but also at its subdomain. This means that you can fetch the maximum number of requests from <a class="ulink" href="http://example.com/">http://example.com/</a> and then, fetch that same number of requests from <code class="literal">foo.example.com</code>, <code class="literal">bar.example.com</code>, and so on. This trick is often used to serve CSS and images more quickly, but it can just as easily be used to make a large number of simultaneous fetches (as long as you update your <code class="literal">url</code> methods appropriately to fetch from the correct subdomain).</p><p>Finally, there is one<a id="id260" class="indexterm"/> last solution to bandwidth issues, which doesn't really solve these issues so much as make them more palatable to the user. If you know that you're going to be making a request that will take long enough for the user to notice, you can give the user a visual wait indicator, such as adding an animated spinner image or changing the cursor's CSS property to wait. If you make these changes just before you start a <code class="literal">fetch</code> operation, you can then use that operation's success and failure callbacks (or, if you use the deferred style, a single <code class="literal">complete</code> callback) to undo the changes. While this won't make your data download any faster, it will make a difference in your user's experience.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Memory-related performance issues</h1></div></div></div><p>Memory-related issues are<a id="id261" class="indexterm"/> the hardest to debug and solve, and unfortunately, they are also the most likely to be encountered when you first start using Backbone. Again, this is not because Backbone itself has memory issues, but because the possibilities that Backbone enables can allow developers to shoot themselves in the foot if they're not careful.</p><p>However, before we proceed, it's important to first explain just how browsers manage memory. As you probably already know, the memory in JavaScript is managed by the browser, not the developer, using something called<a id="id262" class="indexterm"/> <strong>garbage collector</strong>. What this means is that you don't have to tell the browser I'm done using this variable. Instead, you can simply stop using that variable and the browser will figure out that it has become <code class="literal">garbage</code>, which will usually make it clean that variable up automatically.</p><p>The problem is that the garbage collector operates on a very simple interpretation of what is or is not garbage. In essence, any variable that is not referenced by another variable is considered to be garbage. For instance:</p><div><pre class="programlisting">var bookReference = {
    fakeBook: new Book({title: 'Hamlet, Part 2: The Reckoning'})
};
delete bookReference.fakeBook;
// fakeBook has no references, and will be collected as "garbage"</pre></div><p>The problem is that developers often don't realize when they leave behind references to a variable, and as such, they force the browser to keep using its memory even though the programmer considers it garbage. Let's look at an example:</p><div><pre class="programlisting">var exampleModel = new Backbone.Model();
var exampleView = new Backbone.View();
exampleModel.on('change', exampleView.render);
$(document.body).append(exampleView.el);
exampleView.remove();
// exampleView will NOT be garbage collected</pre></div><p>In this example, it <a id="id263" class="indexterm"/>seems like we eliminated all references to <code class="literal">exampleView</code> when we called <code class="literal">exampleView.remove()</code> and removed it from the DOM, but in fact, there was still one reference left behind, hidden inside <code class="literal">exampleModel</code>. This reference was created when we called the <code class="literal">on</code> method of <code class="literal">exampleModel</code> and passed it <code class="literal">exampleView.render</code>. By doing so, we told the <code class="literal">Model</code> to wait until a change happens and then call <code class="literal">exampleView.render</code>, which required it to store a reference to <code class="literal">exampleView.render</code>. Since we didn't delete <code class="literal">exampleModel</code>, this reference remains and won't be garbage-collected, leaving a so-called zombie <code class="literal">View</code> in the browser's memory.</p><p>One way to solve this problem would be to remove this reference manually by using the <code class="literal">off</code> method:</p><div><pre class="programlisting">example.model.off('change');</pre></div><p>However, having to manage such references can quickly become tedious. Luckily, the creators of Backbone added a method to <code class="literal">View</code> (as well as the other three Backbone classes) that helps solve this problem, called <code class="literal">listenTo</code>. This method works very similarly to <code class="literal">on</code> with two important differences. First, it is called on the listening object (in this case, the <code class="literal">View</code>), rather than on the object being listened to (in this case, the <code class="literal">Model</code>), and second, it does not take a context argument. Instead, the context of the callback will always be set to the object that <code class="literal">listenTo</code> was called on.</p><p>Just as there is an <code class="literal">off</code> method for <code class="literal">on</code>, there is a <code class="literal">stopListening</code> method that removes listeners created by <code class="literal">listenTo</code>. However, you won't need to call <code class="literal">stopListening</code> yourself very often, because it's called automatically as part of the <code class="literal">remove</code> method of a <code class="literal">View</code>, which is what makes it so convenient.</p><p>Let's retry our last example using <code class="literal">listenTo</code>:</p><div><pre class="programlisting">exampleModel = new Backbone.Model();exampleView = new Backbone.View();
exampleModel.listenTo('change', exampleView.render);
$(document.body).append(exampleView.el);
exampleView.remove();
// exampleView WILL be garbage collected</pre></div><p>This time, just as before, we have a <code class="literal">View</code> listening for changes in a <code class="literal">Model</code>. However, because we used <code class="literal">listenTo</code> instead of <code class="literal">on</code>, the reference created as a side effect will get removed whenever <code class="literal">stopListening</code> is called. Since we called <code class="literal">remove</code> on <code class="literal">exampleView</code> and since this method automatically calls <code class="literal">stopListening</code> for us, our <code class="literal">View</code> gets garbage-collected correctly without us having to do any extra work.</p><p>Unfortunately, however, <code class="literal">listenTo</code> can't solve all potential leaky references. For one thing, you may still want to use the <code class="literal">on</code> method from time to time. The primary reason for doing so is to listen for events from non-Backbone code, such as a jQuery UI widget. You might also be <a id="id264" class="indexterm"/>tempted to use <code class="literal">on</code> because (unlike <code class="literal">listenTo</code>) it takes a context argument, but thanks to Underscore's <code class="literal">bind</code> method, you don't need to do so; you can simply bind your desired context in your callback function before passing it to <code class="literal">listenTo</code>. However, even if you do avoid using <code class="literal">on</code> entirely, you still have to remember to call <code class="literal">remove</code> on your <code class="literal">View</code>. If you don't, you still need to use <code class="literal">off</code> or <code class="literal">stopListening</code> to clear the event binding references. Finally, event handlers aren't the only source of references. </p><p>For instance, parent <code class="literal">Views</code> and child <code class="literal">Views</code> often reference each other, and unless you delete the referencing <code class="literal">Views</code> entirely, the <code class="literal">Views</code> that it references won't actually be garbage-collected. The good news is that there's no need to worry too much about such references on a small scale, and in fact, trying to optimize performance too heavily on every last bit of code in your application can wind up being counterproductive. Any given <code class="literal">Model</code> or <code class="literal">View</code> will normally take up only a small amount of memory on its own, so even if you do create a leaky reference that prevents it from being garbage-collected, the actual effect on your application's performance will be minimal. If the user never even notices the leak and then reclaims the memory when he closes his browser or hits refresh, then clearly there was no need for you to have spent time worrying about it.</p><p>Instead, you mainly want to focus on managing your references when dealing with large numbers of objects. If you are designing a page <code class="literal">View</code> that will be used throughout your application, or creating a <code class="literal">View</code> for a large table with many separate child <code class="literal">Views</code>, then you will likely want to be extra careful with each reference you create and ensure that all these references get cleaned up when you are done with them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Summary</h1></div></div></div><p>In this chapter, we learned how JavaScript code in general, and Backbone code in particular, can cause performance problems. We learned the three main causes of such problems (namely bandwidth, CPU, and memory), as well as techniques and methods that can be used to solve them. In particular, we learned how leaky event bindings or other references can prevent garbage collection, and how using <code class="literal">listenTo</code> or manually cleaning up references can enable garbage collection to work as expected.</p><p>In the next chapter, we'll examine the benefits of proper code documentation, learn how to solve some of the Backbone-specific documentation challenges, and consider which of the many quality documentation tools are the best for documenting your projects.</p></div></body></html>