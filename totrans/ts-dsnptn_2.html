<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Structural Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Structural Design Patterns</h1></div></div></div><p>While creational patterns play the part of flexibly creating objects, structural patterns, on the other hand, are patterns about composing objects. In this chapter, we are going to talk about structural patterns that fit different scenarios.</p><p>If we take a closer look at structural patterns, they can be divided into <span class="emphasis"><em>structural class patterns</em></span> and <span class="emphasis"><em>structural object patterns</em></span>. Structural class patterns are patterns that play with "interested parties" themselves, while structural object patterns are patterns that weave pieces together (like Composite Pattern). These two kinds of structural patterns complement each other to some degree.</p><p>Here are the patterns we'll walk through in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Composite</strong></span>: Builds tree-like structures using primitive and composite objects. A good example would be the DOM tree that forms a complete page.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decorator</strong></span>: Adds functionality to classes or objects dynamically.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adapter</strong></span>: Provides a general interface and work with different adaptees by implementing different concrete adapters. Consider providing different database choices for a single content management system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bridge</strong></span>: Decouples the abstraction from its implementation, and make both of them interchangeable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Façade</strong></span>: Provides a simplified interface for the combination of complex subsystems.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flyweight</strong></span>: Shares stateless objects that are being used many times to improve memory efficiency and performance.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proxy</strong></span>: Acts as the surrogate that takes extra responsibilities when accessing objects it manages.</li></ul></div><div class="section" title="Composite Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Composite Pattern</h1></div></div></div><p>Objects under the same class could vary from their properties or even specific subclasses, but a complex object can have more than just normal properties. Taking DOM elements, for example, all the elements are instances of class <code class="literal">Node</code>. These nodes form tree structures to represent different pages, but every node in these trees is complete and uniform compared to the node at the root:</p><pre class="programlisting">&lt;html&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;TypeScript&lt;/title&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;TypeScript&lt;/h1&gt; &#13;
    &lt;img /&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The preceding HTML represents a DOM structure like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_001.jpg" alt="Composite Pattern"/></div><p>
</p><p>All of the preceding objects are instances of <code class="literal">Node</code>, they implement the interface of a <span class="emphasis"><em>component</em></span> in Composite Pattern. Some of these nodes like HTML elements (except for <code class="literal">HTMLImageElement</code>) in this example have child nodes (components) while others don't.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Participants</h2></div></div></div><p>The participants of Composite Pattern implementation include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Component</strong></span>: <code class="literal">Node</code><p>Defines the interface and implement the default behavior for objects of the composite. It should also include an interface to access and manage the child components of an instance, and optionally a reference to its parent.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Composite</strong></span>: Includes some HTML elements, like <code class="literal">HTMLHeadElement</code> and <code class="literal">HTMLBodyElement</code><p>Stores child components and implements related operations, and of course its own behaviors.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Leaf</strong></span>: <code class="literal">TextNode</code>, <code class="literal">HTMLImageElement</code><p>Defines behaviors of a primitive component.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>:<p>Manipulates the composite and its components.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Pattern scope</h2></div></div></div><p>Composite Pattern applies when objects can and should be abstracted recursively as components that form tree structures. Usually, it would be a natural choice when a certain structure needs to be formed as a tree, such as trees of view components, abstract syntax trees, or trees that represent file structures.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Implementation</h2></div></div></div><p>We are going to create a composite that represents simple file structures and has limited kinds of components.</p><p>First of all, let's import related node modules:</p><pre class="programlisting">import * as Path from 'path'; &#13;
import * as FS from 'fs'; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Module <code class="literal">path</code> and <code class="literal">fs</code> are built-in modules of Node.js, please refer to Node.js documentation for more information: <a class="ulink" href="https://nodejs.org/api/">https://nodejs.org/api/</a>.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>It is my personal preference to have the first letter of a namespace (if it's not a function at the same time) in uppercase, which reduces the chance of conflicts with local variables. But a more popular naming style for namespace in JavaScript does not.</p></div></div><p>Now we need to make abstraction of the components, say <code class="literal">FileSystemObject</code>:</p><pre class="programlisting">abstract class FileSystemObject { &#13;
  constructor( &#13;
    public path: string, &#13;
    public parent?: FileSystemObject &#13;
  ) { } &#13;
 &#13;
  get basename(): string { &#13;
    return Path.basename(this.path); &#13;
  } &#13;
} &#13;
</pre><p>We are using <code class="literal">abstract class</code> because we are not expecting to use <code class="literal">FileSystemObject</code> directly. An optional <code class="literal">parent</code> property is defined to allow us to visit the upper component of a specific object. And the <code class="literal">basename</code> property is added as a helper for getting the basename of the path.</p><p>The <code class="literal">FileSystemObject</code> is expected to have subclasses, <code class="literal">FolderObject</code> and <code class="literal">FileObject</code>. For <code class="literal">FolderObject</code>, which is a composite that may contain other folders and files, we are going to add an <code class="literal">items</code> property (getter) that returns other <code class="literal">FileSystemObject</code> it contains:</p><pre class="programlisting">class FolderObject extends FileSystemObject { &#13;
  items: FileSystemObject[]; &#13;
 &#13;
  constructor(path: string, parent?: FileSystemObject) { &#13;
    super(path, parent); &#13;
  } &#13;
} &#13;
</pre><p>We can initialize the <code class="literal">items</code> property in the <code class="literal">constructor</code> with actual files and folders existing at given <code class="literal">path</code>:</p><pre class="programlisting">this.items = FS &#13;
  .readdirSync(this.path) &#13;
  .map(path =&gt; { &#13;
    let stats = FS.statSync(path); &#13;
 &#13;
    if (stats.isFile()) { &#13;
      return new FileObject(path, this); &#13;
    } else if (stats.isDirectory()) { &#13;
      return new FolderObject(path, this); &#13;
    } else { &#13;
      throw new Error('Not supported');&#13;
    } &#13;
  }); &#13;
</pre><p>You may have noticed we are forming <code class="literal">items</code> with different kinds of objects, and we are also passing <code class="literal">this</code> as the <code class="literal">parent</code> of newly created child components.</p><p>And for <code class="literal">FileObject</code>, we'll add a simple <code class="literal">readAll</code> method that reads all bytes of the file:</p><pre class="programlisting">class FileObject extends FileSystemObject { &#13;
  readAll(): Buffer { &#13;
    return FS.readFileSync(this.path); &#13;
  } &#13;
} &#13;
</pre><p>Currently, we are reading the child items inside a folder from the actual filesystem when a folder object gets initiated. This might not be necessary if we want to access this structure on demand. We may actually create a getter that calls <code class="literal">readdir</code> only when it's accessed, thus the object would act like a proxy to the real filesystem.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Consequences</h2></div></div></div><p>Both the primitive object and composite object in Composite Pattern share the component interface, which makes it easy for developers to build a composite structure with fewer things to remember.</p><p>It also enables the possibility of using markup languages like XML and HTML to represent a really complex object with extreme flexibility. Composite Pattern can also make the rendering easier by having components rendered recursively.</p><p>As most components are compatible with having child components or being child components of their parents themselves, we can easily create new components that work great with existing ones.</p></div></div></div>
<div class="section" title="Decorator Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Decorator Pattern</h1></div></div></div><p>Decorator Pattern adds new functionality to an object dynamically, usually without compromising the original features. The word decorator in Decorator Pattern does share something with the word decorator in the ES-next decorator syntax, but they are not exactly the same. Classical Decorator Pattern as a phrase would differ even more.</p><p>The classical Decorator Pattern works with a composite, and the brief idea is to create decorators as components that do the decorating work. As composite objects are usually processed recursively, the decorator components would get processed automatically. So it becomes your choice to decide what it does.</p><p>The inheritance hierarchy could be like the following structure shown:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_002.jpg" alt="Decorator Pattern"/></div><p>
</p><p>The decorators are applied recursively like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_003.jpg" alt="Decorator Pattern"/></div><p>
</p><p>There are two prerequisites for the decorators to work correctly: the awareness of context or object that a decorator is decorating, and the ability of the decorators being applied. The Composite Pattern can easily create structures that satisfy those two prerequisites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The decorator knows what it decorates as the <code class="literal">component</code> property</li><li class="listitem" style="list-style-type: disc">The decorator gets applied when it is rendered recursively</li></ul></div><p>However, it doesn't really need to take a structure like a composite to gain the benefits from Decorator Pattern in JavaScript. As JavaScript is a dynamic language, if you can get your decorators called, you may add whatever you want to an object.</p><p>Taking method <code class="literal">log</code> under <code class="literal">console</code> object as an example, if we want a timestamp before every log, we can simply replace the <code class="literal">log</code> function with a wrapper that has the timestamp prefixed:</p><pre class="programlisting">const _log = console.log; &#13;
console.log = function () { &#13;
  let timestamp = `[${new Date().toTimeString()}]`;&#13;
  return _log.apply(this, [timestamp, ...arguments]);&#13;
}; &#13;
</pre><p>Certainly, this example has little to do with the classical Decorator Pattern, but it enables a different way for this pattern to be done in JavaScript. Especially with the help of new decorator syntax:</p><pre class="programlisting">class Target { &#13;
  @decorator &#13;
  method() { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>TypeScript provides the decorator syntax transformation as an experimental feature. To learn more about decorator syntax, please check out the following link: <a class="ulink" href="http://www.typescriptlang.org/docs/handbook/decorators.html">http://www.typescriptlang.org/docs/handbook/decorators.html</a>.</p></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Participants</h2></div></div></div><p>The participants of classical Decorator Pattern implementation include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Component</strong></span>: <code class="literal">UIComponent</code><p>Defines the interface of the objects that can be decorated.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ConcreteComponent</strong></span>: <code class="literal">TextComponent</code><p>Defines additional functionalities of the concrete component.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decorator</strong></span>: <code class="literal">Decorator</code><p>Defines a reference to the component to be decorated, and manages the context. Conforms the interface of a component with proper behaviors.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ConcreteDecorator</strong></span>: <code class="literal">ColorDecorator</code>, <code class="literal">FontDecorator</code><p>Defines additional features and exposes API if necessary.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Pattern scope</h2></div></div></div><p>Decorator Pattern usually cares about objects, but as JavaScript is prototype-based, decorators would work well with the classes of objects through their prototypes.</p><p>The classical implementation of Decorator Pattern could have much in common with other patterns we are going to talk about later, while the function one seems to share less.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Implementation</h2></div></div></div><p>In this part, we'll talk about two implementations of Decorator Pattern. The first one would be classical Decorator Pattern that decorates the target by wrapping with new classes that conform to the interface of <code class="literal">UIComponent</code>. The second one would be decorators written in new decorator syntax that processes target objects.</p><div class="section" title="Classical decorators"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec30"/>Classical decorators</h3></div></div></div><p>Let's get started by defining the outline of objects to be decorated. First, we'll have the <code class="literal">UIComponent</code> as an abstract class, defining its abstract function <code class="literal">draw</code>:</p><pre class="programlisting">abstract class UIComponent { &#13;
  abstract draw(): void; &#13;
} &#13;
</pre><p>Then a <code class="literal">TextComponent</code> that extends the  <code class="literal">UIComponent</code>, as well as its text contents of class <code class="literal">Text</code>:</p><pre class="programlisting">class Text { &#13;
  content: string; &#13;
 &#13;
  setColor(color: string): void { } &#13;
  setFont(font: string): void { } &#13;
 &#13;
  draw(): void { } &#13;
} &#13;
 &#13;
class TextComponent extends UIComponent { &#13;
  texts: Text[]; &#13;
 &#13;
  draw(): void { &#13;
    for (let text of this.texts) { &#13;
      text.draw(); &#13;
    } &#13;
  } &#13;
} &#13;
</pre><p>What's next is to define the interface of decorators to decorate objects that are instances of class <code class="literal">TextComponent</code>:</p><pre class="programlisting">class Decorator extends UIComponent { &#13;
  constructor( &#13;
    public component: TextComponent &#13;
  ) { &#13;
    super(); &#13;
  } &#13;
 &#13;
  get texts(): Text[] { &#13;
    return this.component.texts; &#13;
  } &#13;
 &#13;
  draw(): void { &#13;
    this.component.draw(); &#13;
  } &#13;
} &#13;
</pre><p>Now we have everything for concrete decorators. In this example, <code class="literal">ColorDecorator</code> and <code class="literal">FontDecorator</code> look similar:</p><pre class="programlisting">class ColorDecorator extends Decorator { &#13;
  constructor( &#13;
    component: TextComponent, &#13;
    public color: string &#13;
  ) { &#13;
    super(component); &#13;
  } &#13;
 &#13;
  draw(): void { &#13;
    for (let text of this.texts) { &#13;
      text.setColor(this.color); &#13;
    } &#13;
 &#13;
    super.draw(); &#13;
  } &#13;
} &#13;
 &#13;
class FontDecorator extends Decorator { &#13;
  constructor( &#13;
    component: TextComponent, &#13;
    public font: string &#13;
  ) { &#13;
    super(component); &#13;
  } &#13;
 &#13;
  draw(): void { &#13;
    for (let text of this.texts) { &#13;
      text.setFont(this.font); &#13;
    } &#13;
 &#13;
    super.draw(); &#13;
  } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>In the implementation just described, <code class="literal">this.texts</code> in <code class="literal">draw</code> method calls the getter defined on class <code class="literal">Decorator</code>. As this in that context would ideally be an instance of class <code class="literal">ColorDecorator</code> or <code class="literal">FontDecorator</code>; the <code class="literal">texts</code> it accesses would finally be the array in its <code class="literal">component</code> property.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>This could be even more interesting or confusing if we have nested decorators like we will soon. Try to draw a schematic diagram if it confuses you later.</p></div></div><p>Now it's time to actually assemble them:</p><pre class="programlisting">let decoratedComponent = new ColorDecorator( &#13;
  new FontDecorator( &#13;
    new TextComponent(), &#13;
    'sans-serif' &#13;
  ), &#13;
  'black' &#13;
); &#13;
</pre><p>The order of nesting decorators does not matter in this example. As either <code class="literal">ColorDecorator</code> or <code class="literal">FontDecorator</code> is a valid <code class="literal">UIComponent</code>, they can be easily dropped in and replace previous <code class="literal">TextComponent</code>.</p></div><div class="section" title="Decorators with ES-next syntax"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec31"/>Decorators with ES-next syntax</h3></div></div></div><p>There is a limitation with classical Decorator Pattern that can be pointed out directly via its nesting form of decorating. That applies to ES-next decorators as well. Take a look at the following example:</p><pre class="programlisting">class Foo { &#13;
  @prefix &#13;
  @suffix &#13;
  getContent(): string { &#13;
    return '...'; &#13;
  } &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>What follows the <code class="literal">@</code> character is an expression that evaluates to a decorator. While a decorator is a function that processes target objects, we usually use higher-order functions to parameterize a decorator.</p></div></div><p>We now have two decorators <code class="literal">prefix</code> and <code class="literal">suffix</code> decorating the <code class="literal">getContent</code> method. It seems that they are just parallel at first glance, but if we are going to add a prefix and suffix onto the content returned, like what the name suggests, the procedure would actually be recursive rather than parallel just like the classical implementation.</p><p>To make decorators cooperate with others as we'd expect, we need to handle things carefully:</p><pre class="programlisting">function prefix( &#13;
  target: Object, &#13;
  name: string, &#13;
  descriptor: PropertyDescriptor &#13;
): PropertyDescriptor { &#13;
  let method = descriptor.value as Function; &#13;
 &#13;
  if (typeof method !== 'function') { &#13;
    throw new Error('Expecting decorating a method'); &#13;
  } &#13;
 &#13;
  return { &#13;
    value: function () { &#13;
      return '[prefix] ' + method.apply(this, arguments); &#13;
    }, &#13;
    enumerable: descriptor.enumerable, &#13;
    configurable: descriptor.configurable, &#13;
    writable: descriptor.writable &#13;
  }; &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>In current ECMAScript decorator proposal, when decorating a method or property (usually with getter or setter), you will have the third argument passed in as the property descriptor.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>Check out the following link for more information about property descriptors: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a>.</p></div></div><p>The <code class="literal">suffix</code> decorator would be just like the <code class="literal">prefix</code> decorator. So I'll save the code lines here.</p></div></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Consequences</h2></div></div></div><p>The key to the Decorator Pattern is being able to add functionalities dynamically, and decorators are usually expected to play nice with each other. Those expectations of Decorator Pattern make it really flexible to form a customized object. However, it would be hard for certain types of decorators to actually work well together.</p><p>Consider decorating an object with multiple decorators just like the second example of implementation, would the decorating order matter? Or should the decorating order matter?</p><p>A properly written decorator should always work no matter where it is in the decorators list. And it's usually <span class="emphasis"><em>preferred</em></span> that the decorated target behaves almost the same with decorators decorated in different orders.</p></div></div>
<div class="section" title="Adapter Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Adapter Pattern</h1></div></div></div><p>Adapter Pattern connects existing classes or objects with another existing client. It makes classes that are not designed to work together possible to cooperate with each other.</p><p>An adapter could be either a <span class="emphasis"><em>class</em></span> adapter or an <span class="emphasis"><em>object</em></span> adapter. A class adapter extends the adaptee class and exposes extra APIs that would work with the client. An object adapter, on the other hand, does not extend the adaptee class. Instead, it stores the adaptee as a dependency.</p><p>The class adapter is useful when you need to access protected methods or properties of the adaptee class. However, it also has some restrictions when it comes to the JavaScript world:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The adaptee class needs to be extendable</li><li class="listitem" style="list-style-type: disc">If the client target is an abstract class other than pure interface, you can't extend the adaptee class and the client target with the same adapter class without a <span class="emphasis"><em>mixin</em></span></li><li class="listitem" style="list-style-type: disc">A single class with two sets of methods and properties could be confusing</li></ul></div><p>Due to those limitations, we are going to talk more about object adapters. Taking browser-side storage for example, we'll assume we have a client working with storage objects that have both methods <code class="literal">get</code> and <code class="literal">set</code> with correct signatures (for example, a storage that stores data online through AJAX). Now we want the client to work with IndexedDB for faster response and offline usage; we'll need to create an adapter for IndexedDB that gets and sets data:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_004.jpg" alt="Adapter Pattern"/></div><p>
</p><p>We are going to use Promise for receiving results or errors of asynchronous operations. See the following link for more information if you are not yet familiar with Promise: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a>.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Participants</h2></div></div></div><p>The participants of Adapter Pattern include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Target: </strong></span><code class="literal">Storage</code><p>Defines the interface of existing targets that works with client</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adaptee</strong></span>: <code class="literal">IndexedDB</code><p>The implementation that is not designed to work with the client</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adapter</strong></span>: <code class="literal">IndexedDBStorage</code><p>Conforms the interface of target and interacts with adaptee</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>.<p>Manipulates the target</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Pattern scope</h2></div></div></div><p>Adapter Pattern can be applied when the existing client class is not designed to work with the existing adaptees. It focuses on the unique <span class="emphasis"><em>adapter</em></span> part when applying to different combinations of clients and adaptees.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Implementation</h2></div></div></div><p>Start with the <code class="literal">Storage</code> interface:</p><pre class="programlisting">interface Storage { &#13;
  get&lt;T&gt;(key: string): Promise&lt;T&gt;; &#13;
  set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt;; &#13;
} &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>We defined the <code class="literal">get</code> method with generic, so that if we neither specify the generic type, nor cast the value type of a returned Promise, the type of the value would be <code class="literal">{}</code>. This would probably fail following type checking.</p></div></div><p>With the help of examples found on MDN, we can now set up the IndexedDB adapter. Visit  <code class="literal">IndexedDBStorage</code>: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB</a>.</p><p>The creation of IndexedDB instances is asynchronous. We could put the opening operation inside a <code class="literal">get</code> or <code class="literal">set</code> method so the database can be opened on demand. But for now, let's make it easier by creating an instance of <code class="literal">IndexedDBStorage</code> that has a database instance which is already opened.</p><p>However, constructors usually don't have asynchronous code. Even if they do, it cannot apply changes to the instance before completing the construction. Fortunately, Factory Method Pattern works well with asynchronous initiation:</p><pre class="programlisting">class IndexedDBStorage implements Storage { &#13;
  constructor( &#13;
    public db: IDBDatabase, &#13;
    public storeName = 'default' &#13;
  ) { } &#13;
 &#13;
  open(name: string): Promise&lt;IndexedDBStorage&gt; { &#13;
    return new Promise&lt;IndexedDBStorage&gt;( &#13;
      (resolve, reject) =&gt; { &#13;
      let request = indexedDB.open(name); &#13;
       &#13;
      // ... &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>Inside the Promise resolver of method <code class="literal">open</code>, we'll get the asynchronous work done:</p><pre class="programlisting">let request = indexedDB.open(name); &#13;
 &#13;
request.onsuccess = event =&gt; { &#13;
  let db = request.result as IDBDatabase; &#13;
  let storage = new IndexedDBStorage(db); &#13;
  resolve(storage); &#13;
}; &#13;
 &#13;
request.onerror = event =&gt; { &#13;
  reject(request.error); &#13;
}; &#13;
</pre><p>Now when we are accessing an instance of <code class="literal">IndexedDBStorage</code>, we can assume it has an opened database and is ready to make queries. To make changes or to get values from the database, we need to create a transaction. Here's how:</p><pre class="programlisting">get&lt;T&gt;(key: string): Promise&lt;T&gt; { &#13;
  return new Promise&lt;T&gt;((resolve, reject) =&gt; { &#13;
    let transaction = this.db.transaction(this.storeName); &#13;
    let store = transaction.objectStore(this.storeName); &#13;
 &#13;
    let request = store.get(key); &#13;
 &#13;
    request.onsuccess = event =&gt; { &#13;
      resolve(request.result); &#13;
    }; &#13;
 &#13;
    request.onerror = event =&gt; { &#13;
      reject(request.error); &#13;
    }; &#13;
  }); &#13;
} &#13;
</pre><p>Method <code class="literal">set</code> is similar. But while the transaction is by default read-only, we need to explicitly specify <code class="literal">'readwrite'</code> mode.</p><pre class="programlisting">set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; { &#13;
  return new Promise&lt;void&gt;((resolve, reject) =&gt; { &#13;
    let transaction = &#13;
      this.db.transaction(this.storeName, 'readwrite'); &#13;
    let store = transaction.objectStore(this.storeName); &#13;
 &#13;
    let request = store.put(value, key); &#13;
 &#13;
    request.onsuccess = event =&gt; { &#13;
      resolve(); &#13;
    }; &#13;
 &#13;
    request.onerror = event =&gt; { &#13;
      reject(request.error); &#13;
    }; &#13;
  }); &#13;
} &#13;
</pre><p>And now we can have a drop-in replacement for the previous storage used by the client.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Consequences</h2></div></div></div><p>By applying Adapter Pattern, we can fill the gap between classes that originally would not work together. In this situation, Adapter Pattern is quite a straightforward solution that might come to mind.</p><p>But in other scenarios like a debugger <span class="emphasis"><em>adapter</em></span> for debugging extensions of an IDE, the implementation of Adapter Pattern could be more challenging.</p></div></div>
<div class="section" title="Bridge Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Bridge Pattern</h1></div></div></div><p>Bridge Pattern decouples the abstraction manipulated by clients from functional implementations and makes it possible to add or replace these abstractions and implementations easily.</p><p>Take a set of <span class="emphasis"><em>cross-API</em></span> UI elements as an example:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_005.jpg" alt="Bridge Pattern"/></div><p>
</p><p>We have the abstraction <code class="literal">UIElement</code> that can access different implementations of <code class="literal">UIToolkit</code> for creating different UI based on either SVG or canvas. In the preceding structure, the <span class="emphasis"><em>bridge</em></span> is the connection between <code class="literal">UIElement</code> and <code class="literal">UIToolkit</code>.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Participants</h2></div></div></div><p>The participants of Bridge Pattern include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstraction: </strong></span><code class="literal">UIElement</code><p>Defines the interface of objects to be manipulated by the client and stores the reference to its implementer.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Refined abstraction</strong></span>: <code class="literal">TextElement</code>, <code class="literal">ImageElement</code><p>Extends abstraction with specialized behaviors.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Implementer</strong></span>: <code class="literal">UIToolkit</code><p>Defines the interface of a general implementer that will eventually carry out the operations defined in abstractions. The implementer usually cares only about basic operations while the abstraction will handle high-level operations.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concrete implementer</strong></span>: <code class="literal">SVGToolkit</code>, <code class="literal">CanvasToolkit</code><p>Implements the implementer interface and manipulates low-level APIs.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Pattern scope</h2></div></div></div><p>Although having abstraction and implementer decoupled provides Bridge Pattern with the ability to work with several abstractions and implementers, most of the time, bridge patterns work only with a single implementer.</p><p>If you take a closer look, you will find Bridge Pattern is extremely similar to Adapter Pattern. However, while Adapter Pattern tries to make existing classes cooperate and focuses on the adapters part, Bridge Pattern foresees the divergences and provides a well-thought-out and universal interface for its abstractions that play the part of adapters.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Implementation</h2></div></div></div><p>A working implementation could be non-trivial in the example we are talking about. But we can still sketch out the skeleton easily.</p><p>Start with implementer <code class="literal">UIToolkit</code> and abstraction <code class="literal">UIElement</code> that are directly related to the bridge concept:</p><pre class="programlisting">interface UIToolkit { &#13;
  drawBorder(): void; &#13;
  drawImage(src: string): void; &#13;
  drawText(text: string): void; &#13;
} &#13;
 &#13;
abstract class UIElement { &#13;
  constructor( &#13;
    public toolkit: UIToolkit &#13;
  ) { } &#13;
 &#13;
  abstract render(): void; &#13;
} &#13;
</pre><p>And now we can extend <code class="literal">UIElement</code> for refined abstractions with different behaviors. First the <code class="literal">TextElement </code> class:</p><pre class="programlisting">class TextElement extends UIElement { &#13;
  constructor( &#13;
    public text: string, &#13;
    toolkit: UIToolkit &#13;
  ) { &#13;
    super(toolkit); &#13;
  } &#13;
 &#13;
  render(): void { &#13;
    this.toolkit.drawText(this.text); &#13;
  } &#13;
} &#13;
</pre><p>And the <code class="literal">ImageElement</code>  class with similar code:</p><pre class="programlisting">class ImageElement extends UIElement { &#13;
  constructor( &#13;
    public src: string, &#13;
    toolkit: UIToolkit &#13;
  ) { &#13;
    super(toolkit); &#13;
  } &#13;
 &#13;
  render(): void { &#13;
    this.toolkit.drawImage(this.src); &#13;
  } &#13;
} &#13;
</pre><p>By creating concrete <code class="literal">UIToolkit</code> subclasses, we can manage to make everything together with the client. But as it could lead to hard work we would not want to touch now, we'll skip it by using a variable pointing to <code class="literal">undefined</code> in this example:</p><pre class="programlisting">let toolkit: UIToolkit; &#13;
 &#13;
let imageElement = new ImageElement('foo.jpg', toolkit); &#13;
let textElement = new TextElement('bar', toolkit); &#13;
 &#13;
imageElement.render(); &#13;
textElement.render(); &#13;
</pre><p>In the real world, the render part could also be a heavy lift. But as it's coded at a relatively higher-level, it tortures you in a different way.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Consequences</h2></div></div></div><p>Despite having completely different names for the abstraction (<code class="literal">UIElement</code>) in the example above and the adapter interface (<code class="literal">Storage</code>), they play similar roles in a static combination.</p><p>However, as we mentioned in the pattern scope section, the intentions of Bridge Pattern and Adapter Pattern differ.</p><p>By decoupling the abstraction and implementer, Bridge Pattern brings great extensibility to the system. The client does not need to know about the implementation details, and this helps to build more stable systems as it forms a healthier dependency structure.</p><p>Another bonus that might be brought by Bridge Pattern is that, with a properly configured build process, it can reduce compilation time as the compiler does not need to know information on the other end of the bridge when changes are made to a refined abstraction or concrete implementer.</p></div></div>
<div class="section" title="Fa&#xE7;ade Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Façade Pattern</h1></div></div></div><p>The Façade Pattern organizes subsystems and provides a unified higher-level interface. An example that might be familiar to you is a modular system. In JavaScript (and of course TypeScript), people use modules to organize code. A modular system makes projects easier to maintain, as a clean project structure can help reveal the interconnections among different parts of the project.</p><p>It is common that one project gets referenced by others, but obviously the project that references other projects doesn't and shouldn't care much about the inner structures of its dependencies. Thus a façade can be introduced for a dependency project to provide a higher-level API and expose what really matters to its dependents.</p><p>Take a robot as an example. People who build a robot and its components will need to control every part separately and let them cooperate at the same time. However, people who want to use this robot would only need to send simple commands like "walk" and "jump".</p><p>For the most flexible usage, the robot "SDK" can provide classes like <code class="literal">MotionController</code>, <code class="literal">FeedbackController</code>, <code class="literal">Thigh</code>, <code class="literal">Shank</code>, <code class="literal">Foot</code> and so on. Possibly like the following image shows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_006.jpg" alt="Façade Pattern"/></div><p>
</p><p>But certainly, most of the people who want to control or program this robot do not want to know as many details as this. What they really want is not a fancy tool box with <span class="emphasis"><em>everything</em></span> inbox, but just an integral robot that follows their commands. Thus the robot "SDK" can actually provide a façade that controls the inner pieces and exposes much simpler APIs:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_007.jpg" alt="Façade Pattern"/></div><p>
</p><p>Unfortunately, Façade Pattern leaves us an open question of how to design the façade API and subsystems. Answering this question properly is not easy work.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Participants</h2></div></div></div><p>The participants of a Façade Pattern are relatively simple when it comes to their categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Façade</strong></span>: <code class="literal">Robot</code><p>Defines a set of higher-level interfaces, and makes subsystems cooperate.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subsystems</strong></span>: <code class="literal">MotionController</code>, <code class="literal">FeedbackController</code>, <code class="literal">Thigh</code>, <code class="literal">Shank</code> and <code class="literal">Foot</code><p>Implements their own functionalities and communicates internally with other subsystems if necessary. Subsystems are dependencies of a façade, and they do not depend on the façade.</p></li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Pattern scope</h2></div></div></div><p>Façades usually act as junctions that connect a higher-level system and its subsystems. The key to the Façade Pattern is to draw a line between what a dependent should or shouldn't care about of its dependencies.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Implementation</h2></div></div></div><p>Consider putting up a robot with its left and right legs, we can actually add another abstraction layer called <code class="literal">Leg</code> that manages <code class="literal">Thigh</code>, <code class="literal">Shank</code> , and <code class="literal">Foot</code>. If we are going to separate motion and feedback controllers to different legs respectively, we may also add those two as part of the <code class="literal">Leg</code>:</p><pre class="programlisting">class Leg { &#13;
  thigh: Thigh; &#13;
  shank: Shank; &#13;
  foot: Foot; &#13;
 &#13;
  motionController: MotionController; &#13;
  feedbackController: FeedbackController; &#13;
} &#13;
</pre><p>Before we add more details to <code class="literal">Leg</code>, let's first define <code class="literal">MotionController</code> and <code class="literal">FeedbackController</code> .</p><p>The <code class="literal">MotionController</code> is supposed to control a whole leg based on a value or a set of values. Here we are simplifying that as a single angle for not being distracted by this impossible robot:</p><pre class="programlisting">class MotionController { &#13;
  constructor( &#13;
    public leg: Leg &#13;
  ) { } &#13;
 &#13;
  setAngle(angle: number): void { &#13;
    let { &#13;
      thigh, &#13;
      shank, &#13;
      foot &#13;
    } = this.leg; &#13;
 &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>And the <code class="literal">FeedbackController</code> is supposed to be an instance of <code class="literal">EventEmitter</code> that reports the state changes or useful events:</p><pre class="programlisting">import { EventEmitter } from 'events'; &#13;
 &#13;
class FeedbackController extends EventEmitter { &#13;
  constructor( &#13;
    public foot: Foot &#13;
  ) { &#13;
    super(); &#13;
  } &#13;
} &#13;
</pre><p>Now we can make class <code class="literal">Leg</code> relatively complete:</p><pre class="programlisting">class Leg { &#13;
  thigh = new Thigh(); &#13;
  shank = new Shank(); &#13;
  foot = new Foot(); &#13;
 &#13;
  motionController: MotionController; &#13;
  feedbackController: FeedbackController; &#13;
 &#13;
  constructor() { &#13;
    this.motionController = &#13;
      new MotionController(this); &#13;
    this.feedbackController = &#13;
      new FeedbackController(this.foot); &#13;
 &#13;
    this.feedbackController.on('touch', () =&gt; { &#13;
      // ... &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>Let's put two legs together to sketch the skeleton of a robot:</p><pre class="programlisting">class Robot { &#13;
  leftLegMotion: MotionController; &#13;
  rightLegMotion: MotionController; &#13;
 &#13;
  leftFootFeedback: FeedbackController; &#13;
  rightFootFeedback: FeedbackController; &#13;
 &#13;
  walk(steps: number): void { } &#13;
  jump(strength: number): void { } &#13;
} &#13;
</pre><p>I'm omitting the definition of classes <code class="literal">Thigh</code>, <code class="literal">Shank</code> , and <code class="literal">Foot</code> as we are not actually going to walk the robot. Now for a user that only wants to walk or jump a robot via simple API, they can make it via the <code class="literal">Robot</code> object that has everything connected.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Consequences</h2></div></div></div><p>Façade Pattern loosens the coupling between client and subsystems. Though it does not decouple them completely as you will probably still need to work with objects defined in subsystems.</p><p>Façades usually forward operations from client to proper subsystems or even do heavy work to make them work together.</p><p>With the help of Façade Pattern, the system and the relationship and structure within the system can stay clean and intuitive.</p></div></div>
<div class="section" title="Flyweight Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Flyweight Pattern</h1></div></div></div><p>A flyweight in Flyweight Pattern is a stateless object that can be shared across objects or maybe classes many times. Obviously, that suggests Flyweight Pattern is a pattern about memory efficiency and maybe performance if the construction of objects is expensive.</p><p>Taking drawing snowflakes as an example. Despite real snowflakes being different to each other, when we are trying to draw them onto canvas, we usually have a limited number of styles. However, by adding <span class="emphasis"><em>properties</em></span> like sizes and transformations, we can create a beautiful snow scene with limited snowflake styles.</p><p>As a flyweight is stateless, ideally it allows multiple operations simultaneously. You might need to be cautious when working with multi-thread stuff. Fortunately, JavaScript is usually single-threaded and avoids this issue if all related code is synchronous. You will still need to take care in detailed scenarios if your code is working asynchronously.</p><p>Assume we have some flyweights of class <code class="literal">Snowflake</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_008.jpg" alt="Flyweight Pattern"/></div><p>
</p><p>When it snows, it would look like this:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_009.jpg" alt="Flyweight Pattern"/></div><p>
</p><p>In the image above, snowflakes in different styles are the result of rendering with different properties.</p><p>It's common that we would have styles and image resources being loaded dynamically, thus we could use a <code class="literal">FlyweightFactory</code> for creating and managing flyweight objects.</p><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Participants</h2></div></div></div><p>The simplest implementation of Flyweight Pattern has the following participants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>F</strong></span><span class="strong"><strong>lyweight</strong></span>: <code class="literal">Snowflake</code><p>Defines the class of flyweight objects.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flyweight factory</strong></span>: <code class="literal">FlyweightFactory</code><p>Creates and manages flyweight objects.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>.<p>Stores states of targets and uses flyweight objects to manipulate these targets.</p></li></ul></div><p>With these participants, we assume that the manipulation could be accomplished through flyweights with different states. It would also be helpful sometimes to have <code class="literal">concrete flyweight</code> class allowing customized behaviors.</p></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Pattern scope</h2></div></div></div><p>Flyweight Pattern is a result of efforts to improving memory efficiency and performance. The implementation cares about having the instances being stateless, and it is usually the client that manages detailed states for different targets.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Implementation</h2></div></div></div><p>What makes Flyweight Pattern useful in the snowflake example is that a snowflake with the same style usually shares the same image. The image is what consumes time to load and occupies notable memory.</p><p>We are starting with a fake <code class="literal">Image</code> class that pretends to load images:</p><pre class="programlisting">class Image { &#13;
  constructor(url: string) { } &#13;
} &#13;
</pre><p>The <code class="literal">Snowflake</code> class in our example has only a single <code class="literal">image</code> property, and that is a property that will be shared by many snowflakes to be drawn. As the instance is now stateless, parameters from context are required for rendering:</p><pre class="programlisting">class Snowflake { &#13;
  image: Image; &#13;
 &#13;
  constructor( &#13;
    public style: string &#13;
  ) { &#13;
    let url = style + '.png'; &#13;
    this.image = new Image(url); &#13;
  } &#13;
 &#13;
  render(x: number, y: number, angle: number): void { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>The flyweights are managed by a factory for easier accessing. We'll have a <code class="literal">SnowflakeFactory</code> that caches created snowflake objects with certain styles:</p><pre class="programlisting">const hasOwnProperty = Object.prototype.hasOwnProperty; &#13;
 &#13;
class SnowflakeFactory { &#13;
  cache: { &#13;
    [style: string]: Snowflake; &#13;
  } = {}; &#13;
 &#13;
  get(style: string): Snowflake { &#13;
    let cache = this.cache; &#13;
    let snowflake: Snowflake; &#13;
 &#13;
    if (hasOwnProperty.call(cache, style)) { &#13;
      snowflake = cache[style]; &#13;
    } else { &#13;
      snowflake = new Snowflake(style); &#13;
      cache[style] = snowflake; &#13;
    } &#13;
 &#13;
    return snowflake; &#13;
  } &#13;
} &#13;
</pre><p>With building blocks ready, we'll implement the client (<code class="literal">Sky</code>) that snows:</p><pre class="programlisting">const SNOW_STYLES = ['A', 'B', 'C']; &#13;
 &#13;
class Sky { &#13;
  constructor( &#13;
    public width: number, &#13;
    public height: number &#13;
  ) { } &#13;
 &#13;
  snow(factory: SnowflakeFactory, count: number) { } &#13;
} &#13;
</pre><p>We are going to fill the sky with random snowflakes at random positions. Before that let's create a helper function that generates a number between 0 and a max value given:</p><pre class="programlisting">function getRandomInteger(max: number): number { &#13;
  return Math.floor(Math.random() * max); &#13;
} &#13;
</pre><p>And then complete method <code class="literal">snow</code> of <code class="literal">Sky</code>:</p><pre class="programlisting">snow(factory: SnowflakeFactory, count: number) { &#13;
    <span class="strong"><strong>let stylesCount = SNOW_STYLES.length; &#13;
 &#13;
    for (let i = 0; i &lt; count; i++) { &#13;
        let style = SNOW_STYLES[getRandomInteger(stylesCount)]; &#13;
        let snowflake = factory.get(style); &#13;
 &#13;
        let x = getRandomInteger(this.width); &#13;
        let y = getRandomInteger(this.height); &#13;
 &#13;
        let angle = getRandomInteger(60); &#13;
 &#13;
        snowflake.render(x, y, angle); &#13;
    } &#13;
</strong></span>} &#13;
</pre><p>Now we may have thousands of snowflakes in the sky but with only three instances of <code class="literal">Snowflake</code> created. You can continue this example by storing the state of snowflakes and animating the snowing.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Consequences</h2></div></div></div><p>Flyweight Pattern reduces the total number of objects involved in a system. As a direct result, it may save quite a lot memory. This saving becomes more significant when the flyweights get used by the client that processes a large number of targets.</p><p>Flyweight Pattern also brings extra logic into the system. When to use or not to use this pattern is again a balancing game between development efficiency and runtime efficiency from this point of view. Though most of the time, if there's not a good reason, we go with development efficiency.</p></div></div>
<div class="section" title="Proxy Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Proxy Pattern</h1></div></div></div><p>Proxy Pattern applies when the program needs to know about or to intervene the behavior of accessing objects. There are several detailed scenarios in Proxy Pattern, and we can distinguish those scenarios by their different purposes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Remote proxy</strong></span>: A proxy with interface to manipulate remote objects, such as data items on a remote server</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Virtual proxy</strong></span>: A proxy that manages expensive objects which need to be loaded on demand</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protection proxy</strong></span>: A proxy that controls access to target objects, typically it verifies permissions and validates values</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Smart proxy</strong></span>: A proxy that does additional operations when accessing target objects</li></ul></div><p>In the section of Adapter Pattern, we used factory method <code class="literal">open</code> that creates an object asynchronously. As a trade-off, we had to let the client wait before the object gets created.</p><p>With Proxy Pattern, we could now <code class="literal">open</code> database on demand and create storage instances synchronously.</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_010.jpg" alt="Proxy Pattern"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>A proxy is usually dedicated to object or objects with known methods and properties. But with the new <code class="literal">Proxy</code> API provided in ES6, we can get more interesting things done by getting to know what methods or properties are being accessed. Please refer to the following link for more information: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a>.</p></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec68"/>Participants</h2></div></div></div><p>The participants of Proxy Pattern include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proxy</strong></span>: <code class="literal">IndexedDB</code><code class="literal">Storage</code><p>Defines interface and implements operations to manage access to the subject.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subject</strong></span>: <code class="literal">IndexedDB</code><p>The subject to be accessed by proxy.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>: Accesses subject via proxy.</li></ul></div></div><div class="section" title="Pattern scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec69"/>Pattern scope</h2></div></div></div><p>Despite having a similar structure to Adapter Pattern, the key of Proxy Pattern is to intervene the access to target objects rather than to adapt an incompatible interface. Sometimes it might change the result of a specific method or the value of a certain property, but that is probably for falling back or exception  handling purposes.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec70"/>Implementation</h2></div></div></div><p>There are two differences we'll have in this implementation compared to the example for pure Adapter Pattern. First, we'll create the <code class="literal">IndexedDBStorage</code> instance with a constructor, and have the database opened on demand. Second, we are going to add a useless permission checking for methods <code class="literal">get</code> and <code class="literal">set</code>.</p><p>Now when we call the method <code class="literal">get</code> or <code class="literal">set</code>, the database could either have been opened or not. Promise is a great choice for representing a value that might either be pending or settled. Consider this example:</p><pre class="programlisting">let ready = new Promise&lt;string&gt;(resolve =&gt; { &#13;
  setTimeout(() =&gt; { &#13;
    resolve('biu~'); &#13;
  }, Math.random() * 1000); &#13;
}); &#13;
 &#13;
setTimeout(() =&gt; { &#13;
  ready.then(text =&gt; { &#13;
    console.log(text); &#13;
  }); &#13;
}, 999); &#13;
</pre><p>It's hard to tell whether Promise <code class="literal">ready</code> is fulfilled when the second timeout fires. But the overall behavior is easy to predict: it will log the <code class="literal">'biu~'</code> text in around 1 second. By replacing the Promise variable <code class="literal">ready</code> with a method or getter, it would be able to start the asynchronous operation only when needed.</p><p>So let's start the refactoring of class <code class="literal">IndexedDBStorage</code> with the getter that creates the Promise of the database to be opened:</p><pre class="programlisting">private dbPromise: Promise&lt;IDBDatabase&gt;; &#13;
 &#13;
constructor( &#13;
  public name: string, &#13;
  public storeName = 'default' &#13;
) { } &#13;
 &#13;
private get dbReady(): Promise&lt;IDBDatabase&gt; { &#13;
  if (!this.dbPromise) { &#13;
    this.dbPromise = &#13;
      new Promise&lt;IDBDatabase&gt;((resolve, reject) =&gt; { &#13;
      let request = indexedDB.open(name); &#13;
 &#13;
      request.onsuccess = event =&gt; { &#13;
        resolve(request.result); &#13;
      }; &#13;
 &#13;
      request.onerror = event =&gt; { &#13;
        reject(request.error); &#13;
      }; &#13;
    }); &#13;
  } &#13;
 &#13;
  return this.dbPromise; &#13;
} &#13;
</pre><p>Now the first time we access property <code class="literal">dbReady</code>, it will open the database and create a Promise that will be fulfilled with the database being opened. To make this work with methods <code class="literal">get</code> and <code class="literal">set</code>, we just need to wrap what we've implemented into a <code class="literal">then</code> method following the <code class="literal">dbReady</code> Promise.</p><p>First for method <code class="literal">get</code>:</p><pre class="programlisting">get&lt;T&gt;(key: string): Promise&lt;T&gt; { &#13;
  return this &#13;
    .dbReady &#13;
    .then(db =&gt; new Promise&lt;T&gt;((resolve, reject) =&gt; { &#13;
      let transaction = db.transaction(this.storeName); &#13;
      let store = transaction.objectStore(this.storeName); &#13;
 &#13;
      let request = store.get(key); &#13;
 &#13;
      request.onsuccess = event =&gt; { &#13;
        resolve(request.result); &#13;
      }; &#13;
 &#13;
      request.onerror = event =&gt; { &#13;
        reject(request.error); &#13;
      }; &#13;
    })); &#13;
} &#13;
</pre><p>And followed by updated method <code class="literal">set</code>:</p><pre class="programlisting">set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; { &#13;
  return this &#13;
    .dbReady &#13;
    .then(db =&gt; new Promise&lt;void&gt;((resolve, reject) =&gt; { &#13;
      let transaction = db&#13;
         .transaction(this.storeName, 'readwrite'); &#13;
      let store = transaction.objectStore(this.storeName); &#13;
 &#13;
      let request = store.put(value, key); &#13;
 &#13;
      request.onsuccess = event =&gt; { &#13;
        resolve(); &#13;
      }; &#13;
 &#13;
      request.onerror = event =&gt; { &#13;
        reject(request.error); &#13;
      }; &#13;
    })); &#13;
} &#13;
</pre><p>Now we finally have the <code class="literal">IndexedDBStorage</code> property that can do a real drop-in replacement for the client that supports the interface. We are also going to add simple permission checking with a plain object that describes the permission of read and write:</p><pre class="programlisting">interface Permission { &#13;
  write: boolean; &#13;
  read: boolean; &#13;
} &#13;
</pre><p>Then we will add permission checking for method <code class="literal">get</code> and <code class="literal">set</code> separately:</p><pre class="programlisting">get&lt;T&gt;(key: string): Promise&lt;T&gt; { &#13;
  <span class="strong"><strong>if (!this.permission.read) { &#13;
    return Promise.reject&lt;T&gt;(new Error('Permission denied')); &#13;
  }</strong></span> &#13;
 &#13;
  // ... &#13;
} &#13;
 &#13;
set&lt;T&gt;(key: string, value: T): Promise&lt;void&gt; { &#13;
 <span class="strong"><strong> if (!this.permission.write) { &#13;
    return Promise.reject(new Error('Permission denied')); &#13;
  }</strong></span> &#13;
 &#13;
  // ... &#13;
} &#13;
</pre><p>You may recall Decorator Pattern when you are thinking about the permission checking part, and decorators could be used to simplify the lines written. Try to use decorator syntax to implement this permission checking yourself.</p></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec71"/>Consequences</h2></div></div></div><p>The implementation of Proxy Pattern can usually be treated as the encapsulation of the operations to specific objects or targets. It is easy to have the encapsulation augmented without extra burden on the client.</p><p>For example, a working online database proxy could do much more than just acting like a plain surrogate. It may cache data and changes locally, or synchronize on schedule without the client being aware.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we learned about structural design patterns including Composite, Decorator, Adapter, Bridge, Façade, Flyweight, and Proxy. Again we found some of these patterns are highly inter related and even similar to each other to some degree.</p><p>For example, we mixed Composite Pattern with Decorator Pattern, Adapter Pattern with Proxy Pattern, compared Adapter Pattern and Bridge Pattern. During the journey of exploring, we sometimes found it was just a natural result to have our code end in a pattern that's similar to what we've listed if we took writing <span class="emphasis"><em>better code</em></span> into consideration.</p><p>Taking Adapter Pattern and Bridge Pattern as an example, when we are trying to make two classes cooperate, it comes out with Adapter Pattern and when we are planning on connecting with different classes in advance, it goes with Bridge Pattern. There are no actual lines between each pattern and the applications of those patterns, though the techniques behind patterns could usually be useful.</p><p>In the next chapter, we are going to talk about behavioral patterns that help to form algorithms and assign the responsibilities.</p></div></body></html>