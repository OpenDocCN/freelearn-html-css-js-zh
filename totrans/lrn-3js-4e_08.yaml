- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating and Loading Advanced Meshes and Geometries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和加载高级网格和几何体
- en: 'In this chapter, we’ll look at a couple of different ways that you can create
    and load advanced and complex geometries and meshes. In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    *Learning to Work with Geometries*, and [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring Advanced Geometries*, we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we’ll use the following
    two approaches to create advanced geometries and meshes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几种不同的方法来创建和加载高级和复杂的几何体和网格。在第[*5章*](B18726_05.xhtml#_idTextAnchor081)“学习与几何体一起工作”和第[*6章*](B18726_06.xhtml#_idTextAnchor101)“探索高级几何体”中，我们向您展示了如何使用Three.js的内置对象创建一些高级几何体。在本章中，我们将使用以下两种方法来创建高级几何体和网格：
- en: Geometry grouping and merging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何分组和合并
- en: Loading geometries from external resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部资源加载几何体
- en: We start with the “group and merge” approach. With this approach, we use the
    standard Three.js grouping (`THREE.Group`) and the `BufferGeometryUtils.mergeBufferGeometries()`
    function to create new objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从“分组和合并”方法开始。使用这种方法，我们使用标准的Three.js分组（`THREE.Group`）和`BufferGeometryUtils.mergeBufferGeometries()`函数来创建新的对象。
- en: Geometry grouping and merging
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何分组和合并
- en: 'In this section, we’ll look at two basic features of Three.js: grouping objects
    together and merging multiple geometries into a single geometry. We’ll start with
    grouping objects.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Three.js的两个基本功能：将对象分组在一起以及将多个几何体合并成一个单一的几何体。我们将从分组对象开始。
- en: Grouping objects together
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象分组在一起
- en: In some of the previous chapters, you already saw how you can group objects
    when working with multiple materials. When you create a mesh from a geometry using
    multiple materials, Three.js creates a group. Multiple copies of your geometry
    are added to this group, each with its own specific material. This group is returned,
    so it looks like a mesh that uses multiple materials. In truth, however, it is
    a group that contains a number of meshes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些前面的章节中，您已经看到了在处理多个材质时如何分组对象。当您使用多个材质从几何体创建网格时，Three.js会创建一个组。您的几何体的多个副本被添加到这个组中，每个副本都有其特定的材质。这个组被返回，所以它看起来像是一个使用多个材质的网格。然而，实际上，它是一个包含多个网格的组。
- en: Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the `add` function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. When using a group, you can still
    refer to, modify, and position the individual geometries. The only thing you need
    to remember is that all positions, rotations, and translations are done relative
    to the parent object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组非常简单。你创建的每个网格都可以包含子元素，可以使用`add`函数添加。将子对象添加到组中的效果是，你可以移动、缩放、旋转和平移父对象，所有子对象也会受到影响。当使用组时，你仍然可以引用、修改和定位单个几何体。你需要记住的唯一一点是，所有位置、旋转和平移都是相对于父对象进行的。
- en: 'Let’s look at an example (`grouping.html`) in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下截图中的示例（`grouping.html`）：
- en: '![Figure 8.1 – Using a THREE.Group object to group objects together](img/Figure_8.1_B18726.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 使用THREE.Group对象将对象分组在一起](img/Figure_8.1_B18726.jpg)'
- en: Figure 8.1 – Using a THREE.Group object to group objects together
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 使用THREE.Group对象将对象分组在一起
- en: 'In this example, you see a large number of cubes, which are added to the scene
    as a single group. Before we look at the controls and the effect of using a group,
    let’s have a quick look at how we’ve created this mesh:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您可以看到大量被作为一个单一组添加到场景中的立方体。在我们查看控件和使用组的效果之前，让我们快速看看我们是如何创建这个网格的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code snippet, you can see that we create a `THREE.Group` instance.
    This object is almost identical to `THREE.Object3D`, which is the base class of
    `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn’t contain anything or
    cause anything to be rendered. In this example, we use the `add` function to add
    a large number of cubes to this scene. For this example, we’ve added the controls
    you can use to change the position of a mesh. Whenever you change a property using
    this menu, the relevant property of the `THREE.Group` object is changed. For instance,
    in the next example, you can see that when we scale this `THREE.Group` object,
    all the nested cubes get scaled as well:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Scaling a group](img/Figure_8.2_B18726.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Scaling a group
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment a bit more with the `THREE.Group` object, a good exercise
    would be to alter the example so that the `THREE.Group` instance itself is rotating
    on the *x* axis while the individual cubes are rotating on their *y* axis.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Performance impact of using THREE.Group
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section where we look at merging, a quick note
    on performance. When you use `THREE.Group`, all the individual meshes inside this
    group are treated as individual objects, which Three.js needs to manage and render.
    If you’ve got a large number of objects in the scene, you’ll see a noticeable
    drop in performance. If you look at the top-left corner of *Figure 8**.2*, you
    can see that with 5,000 cubes on screen, we get around 56 **frames per second**
    (**FPS**). Not too bad, but normally we would run at around 120 FPS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Three.js provides an additional way where we can still control the individual
    meshes, but get much better performance. This is done through `THREE.InstancedMesh`.
    This object works great if you want to render a large number of objects with the
    same geometry but with different transformations (for example, rotation, scale,
    color, or any other matrix transformation).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve created an example called `instanced-mesh.html`, which shows how this
    works. In this example, we render 250,000 cubes and still have great performance:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Using an InstancedMesh object for grouping](img/Figure_8.3_B18726.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Using an InstancedMesh object for grouping
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with a `THREE.InstancedMesh` object, we create it similarly to how
    we created the `THREE.Group` instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main difference in creating a `THREE.InstancedMesh` object compared to `THREE.Group`
    is that we need to define beforehand which material and geometry we want to use
    and how many instances of this geometry we want to create. To position or rotate
    one of our instances, we need to provide the transformation using a `THREE.Matrix4`
    instance. Luckily, we don’t need to go into the math behind matrices, since Three.js
    provides us with a couple of helper functions on the `THREE.Matrix4` instance
    to define a rotation, a translation, and a couple of other transformations. In
    this example, we simply position each instance at a random location.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: So, if you’re working with a small number of meshes (or meshes using different
    geometries), you should use a `THREE.Group` object if you want to group them together.
    If you’re dealing with a large number of meshes that share a geometry and material,
    you can use a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry`
    object for a great performance boost.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at merging, where you’ll combine multiple separate
    geometries and end up with a single `THREE.Geometry` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Merging geometries
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you’re dealing with a very large number of objects, however,
    performance will become an issue since Three.js has to treat all the children
    of the group individually. With `BufferGeometryUtils.mergeBufferGeometries`, you
    can merge geometries together and create a combined one, so Three.js would only
    have to manage this single geometry. In *Figure 8**.4*, you can see how this works
    and the effect it has on performance. If you open the `merging.html` example,
    you see a scene again with the same set of randomly distributed semi-transparent
    cubes, which we merged into a single `THREE.BufferGeometry` object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – 500,000 geometries merged into a single geometry](img/Figure_8.4_B18726.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – 500,000 geometries merged into a single geometry
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we can easily render 50,000 cubes without any drop in performance.
    To do this, we use the following few lines of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code snippet, we create a large number of `THREE.BoxGeometry` objects,
    which we merge together using the `BufferGeometryUtils.mergeBufferGeometries(geoms)`
    function. The result is a single large geometry, which we can add to the scene.
    The biggest drawback is that you lose control over the individual cubes since
    they are all merged into a single large geometry. If you want to move, rotate,
    or scale a single cube, you can’t (unless you search for the correct faces and
    vertices and position them individually).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating new geometries through Constructive Solid Geometry
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Besides merging geometries in the way we saw in this chapter, we can also create
    geometries using `three-bvh-csg` ([https://github.com/gkjohnson/three-bvh-csg](https://github.com/gkjohnson/three-bvh-csg))
    and `Three.csg` ([https://github.com/looeee/threejs-csg](https://github.com/looeee/threejs-csg)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn’t always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we’ll look at how you can load geometries
    and meshes from external resources.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Loading geometries from external resources
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js can read a large number of 3D file formats and import geometries and
    meshes defined in those files. A note here is that not all the features of these
    formats are always supported. So, sometimes there might be an issue with the textures,
    or materials might not be set up correctly. The new de facto standard for exchanging
    models and textures is **glTF**, so if you want to load externally created models,
    exporting those models to glTF format will usually give you the best results in
    Three.js.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll dive a bit deeper into some of the formats that are
    supported by Three.js, but we won’t show you all the loaders. The following list
    shows an overview of the formats supported by Three.js:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**AMF**: AMF is another 3D printing standard, but isn’t under active development
    anymore. The following *Wikipedia* page has additional information on this standard:
    [https://www.sculpteo.com/en/glossary/amf-definition/](https://www.sculpteo.com/en/glossary/amf-definition/).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3DM**: 3DM is the format used by Rhinoceros, which is a tool to create 3D
    models. More information on Rhinoceros can be found here: [https://www.rhino3d.com/](https://www.rhino3d.com/).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3MF**: 3MF is one of the standards used in 3D printing. Information about
    this format can be found on the *3MF Consortium* home page: [https://3mf.io](https://3mf.io).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COLLAborative Design Activity (COLLADA**): COLLADA is a format for defining
    digital assets in an XML-based format. This is a widely used format that is supported
    by pretty much all 3D applications and rendering engines.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draco**: Draco is a file format for storing geometries and point clouds in
    a very efficient way. It specifies how these elements are best compressed and
    decompressed. Details about how Draco works can be found on its GitHub page: [https://github.com/google/draco](https://github.com/google/draco).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCode**: GCode is a standard way of talking to 3D printers or **CNC** machines.
    When a model is printed, one of the ways a 3D printer can be controlled is by
    sending it GCode commands. The details of this standard are described in the following
    paper: [https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374](https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.glb` extension and a text-based format with the `.gltf` extension. More information
    on this standard can be found here: [https://www.khronos.org/gltf/](https://www.khronos.org/gltf/).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industry Foundation Classes (IFC)**: This is an open file format used by
    **building information modeling** (**BIM**) tools. It contains a model of a building
    and a lot of additional information on the materials used. More information about
    this standard can be found here: [https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/](https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON**: Three.js has its own JSON format that you can use to declaratively
    define a geometry or a scene. Even though this isn’t an official format, it’s
    very easy to use and comes in very handy when you want to reuse complex geometries
    or scenes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KMZ**: This is the format used for 3D assets on Google Earth. More information
    can be found here: [https://developers.google.com/kml/documentation/kmzarchives](https://developers.google.com/kml/documentation/kmzarchives).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LDraw**: LDraw is an open standard you can use to create virtual LEGO models
    and scenes. More information can be found on the LDraw home page: [https://ldraw.org](https://ldraw.org).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LWO**: This is the file format used by LightWave 3D. More information on
    LightWave 3D can be found here: [https://www.lightwave3d.com/](https://www.lightwave3d.com/).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NRRD**: NRRD is a file format used to visualize volumetric data. It can,
    for instance, be used to render CT scans. A lot of information and samples can
    be found here: [http://teem.sourceforge.net/nrrd/](http://teem.sourceforge.net/nrrd/).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJExporter`, should you want to export your models to OBJ from Three.js.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PCD**: This is an open format for describing point clouds. More information
    can be found here: [https://pointclouds.org/documentation/tutorials/pcd_file_format.html](https://pointclouds.org/documentation/tutorials/pcd_file_format.html).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PDB**: This is a very specialized format, created by **Protein Data Bank**
    (**PDB**), which is used to specify what proteins look like. Three.js can load
    and visualize proteins specified in this format.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polygon File Format (PLY)**: This is most often used to store information
    from 3D scanners.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packed Raw WebGL Model (PRWM)**: This is another format focusing on the efficient
    storage and parsing of 3D geometries. More information on this standard and how
    you can use it is described here: [https://github.com/kchapelier/PRWM](https://github.com/kchapelier/PRWM).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包原始WebGL模型 (PRWM)**: 这是一个专注于高效存储和解析3D几何形状的格式。有关此标准和如何使用它的更多信息，请参阅此处：[https://github.com/kchapelier/PRWM](https://github.com/kchapelier/PRWM).'
- en: '`STLExporter.js`, should you want to export your models to STL from Three.js.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STLExporter.js`，如果您想从Three.js导出模型到STL。'
- en: '`THREE.Path` elements that you can use for extruding or rendering in 2D.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Path`元素，您可以使用它进行挤出或2D渲染。'
- en: '**3DS**: The Autodesk 3DS format. More information can be found at [https://www.autodesk.com/](https://www.autodesk.com/).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3DS**: 这是Autodesk 3DS格式。更多信息请参阅[https://www.autodesk.com/](https://www.autodesk.com/).'
- en: '**TILT**: TILT is the format used by Tilt Brush, a VR tool that allows you
    to paint in VR. More information is available here: [https://www.tiltbrush.com/](https://www.tiltbrush.com/).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TILT**: TILT是Tilt Brush使用的格式，Tilt Brush是一个VR工具，允许您在VR中绘画。更多信息请参阅此处：[https://www.tiltbrush.com/](https://www.tiltbrush.com/).'
- en: '**VOX**: The format used by MagicaVoxel, a free tool you can use to create
    voxel art. More information is available on the home page of MagicaVoxel: [https://ephtracy.github.io/](https://ephtracy.github.io/).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VOX**: 这是MagicaVoxel使用的格式，MagicaVoxel是一个免费工具，可用于创建体素艺术。更多信息可以在MagicaVoxel的主页上找到：[https://ephtracy.github.io/](https://ephtracy.github.io/).'
- en: '**Virtual Reality Modeling Language (VRML)**: This is a text-based format that
    allows you to specify 3D objects and worlds. It has been superseded by the X3D
    file format. Three.js doesn’t support loading **X3D** models, but these models
    can be easily converted to other formats. More information can be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟现实建模语言 (VRML)**: 这是一个基于文本的格式，允许您指定3D对象和世界。它已被X3D文件格式取代。Three.js不支持加载**X3D**模型，但这些模型可以轻松转换为其他格式。更多信息请参阅[http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).'
- en: '**Visualization Toolkit (VTK)**: This is the file format defined by and used
    to specify vertices and faces. There are two formats available: a binary one and
    a text-based **ASCII** one. Three.js only supports the ASCII-based format.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化工具包 (VTK)**: 这是用于定义和指定顶点和面的文件格式。有两种格式可供选择：一种二进制格式和基于文本的**ASCII**格式。Three.js仅支持基于ASCII的格式。'
- en: '**XYZ**: This is a very simple file format for describing points in 3D space.
    More information is available here: [https://people.math.sc.edu/Burkardt/data/xyz/xyz.html](https://people.math.sc.edu/Burkardt/data/xyz/xyz.html).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XYZ**: 这是一个用于描述3D空间中点的非常简单的文件格式。更多信息请参阅此处：[https://people.math.sc.edu/Burkardt/data/xyz/xyz.html](https://people.math.sc.edu/Burkardt/data/xyz/xyz.html).'
- en: In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), *Animations and Moving the
    Camera*, we’ll revisit some of these formats (and look at a number of additional
    ones) when we look at animations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B18726_09.xhtml#_idTextAnchor148)，“动画和移动相机”中，当我们研究动画时，我们将重新审视这些格式（并查看一些额外的格式）。
- en: As you can see from this list, Three.js supports a very large number of 3D file
    formats. We won’t be describing all of them, just the most interesting ones. We’ll
    start with the JSON loader since that provides a nice way to store and retrieve
    scenes you’ve created yourself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从列表中看到的，Three.js支持非常多的3D文件格式。我们不会描述所有这些格式，只描述其中最有趣的一些。我们将从JSON加载器开始，因为它提供了一种存储和检索您自己创建的场景的好方法。
- en: Saving and loading in Three.js JSON format
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Three.js JSON格式中保存和加载
- en: You can use the Three.js JSON format for two different scenarios in Three.js.
    You can use it to save and load a single `THREE.Object3D` object (which means
    you can also use it to export a `THREE.Scene` object).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Three.js中使用JSON格式进行两种不同的场景。您可以使用它来保存和加载单个`THREE.Object3D`对象（这意味着您也可以使用它来导出`THREE.Scene`对象）。
- en: 'To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just as we did in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081)*,*
    and, using the **save** button from the **Save/load** menu, you can save the current
    geometry. For this example, we save using the HTML5 local storage API. This API
    allows us to easily store persistent information in the client’s browser and retrieve
    it at a later time (even after the browser has been shut down and restarted):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Showing the loaded and the current mesh](img/Figure_8.5_B18726.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Showing the loaded and the current mesh
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see two meshes—the red one is the one we
    loaded, and the yellow one is the original one. If you open this example yourself
    and click the **save** button, the current state of the mesh will be stored. Now,
    you can refresh the browser and click **load**, and the saved state will be shown
    in red.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Exporting in JSON from Three.js is very easy and doesn’t require you to include
    any additional libraries. The only thing you need to do is to export `THREE.Mesh`
    as JSON and store it in the browser’s `localstorage`, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before saving it, we first convert the result from the `toJSON` function (a
    JavaScript object) to a string using the `JSON.stringify` function. To save this
    information using the HTML5 local storage API, all we have to do is call the `localStorage.setItem`
    function. The first argument is the key value (json) that we can later use to
    retrieve the information we passed in as the second argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'This JSON string looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, Three.js saves all the information about the `THREE.Mesh` object.
    Loading `THREE.Mesh` back into Three.js also requires just a few lines of code,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first get the JSON from local storage using the name we saved it with
    (json, in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a load function,
    where you can pass the URL to a file containing the JSON definition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see here, we only saved a `THREE.Mesh` object, so we lose everything
    else. If you want to save the complete scene, including the lights and the cameras,
    you can use the same approach to export a scene:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result of this is a complete scene description in JSON:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Exporting a scene to JSON](img/Figure_8.5_B18726.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Exporting a scene to JSON
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: This can be loaded in the same way as we already showed for a `THREE.Mesh` object.
    While storing your current scene and objects in JSON comes in very handy when
    you’re working exclusively in Three.js, this isn’t a format that can easily be
    exchanged with or created by other tools and programs. In the next section, we’ll
    look a bit deeper into some of the 3D formats supported by Three.js.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过与我们之前展示的 `THREE.Mesh` 对象相同的方式进行加载。当你在 Three.js 中独立工作并存储当前场景和对象为 JSON 时，这非常有用，但这并不是一个可以轻松与其他工具和程序交换或创建的格式。在下一节中，我们将更深入地探讨
    Three.js 支持的一些 3D 格式。
- en: Importing from 3D file formats
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 3D 文件格式导入
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we’ll quickly walk through a few examples of those
    formats.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们列出了一些 Three.js 支持的格式。在本节中，我们将快速浏览这些格式的几个示例。
- en: The OBJ and MTL formats
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 格式
- en: 'OBJ and MTL are companion formats and are often used together. An OBJ file
    defines the geometry, and an MTL file defines the materials that are used. Both
    OBJ and MTL are text-based formats. A part of an OBJ file looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 是配套格式，通常一起使用。OBJ 文件定义几何形状，MTL 文件定义使用的材质。OBJ 和 MTL 都是文本格式。OBJ 文件的一部分看起来像这样：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An MTL file defines materials, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: MTL 文件定义材质，如下所示：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The OBJ and MTL formats are well supported by Three.js, so this is a good format
    to choose if you want to exchange 3D models. Three.js has two different loaders
    you can use. If you only want to load the geometry, you use `OBJLoader`. We used
    this loader for our example (`load-obj.html`). The following screenshot shows
    this example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OBJ 和 MTL 格式在 Three.js 中得到了很好的支持，因此如果你想要交换 3D 模型，这是一个不错的选择。Three.js 有两个不同的加载器你可以使用。如果你只想加载几何形状，你使用
    `OBJLoader`。我们使用了这个加载器作为我们的示例（`load-obj.html`）。以下截图显示了此示例：
- en: '![Figure 8.7 – OBJ model that just defines the geometry](img/Figure_8.7_B18726.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 仅定义几何形状的 OBJ 模型](img/Figure_8.7_B18726.jpg)'
- en: Figure 8.7 – OBJ model that just defines the geometry
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 仅定义几何形状的 OBJ 模型
- en: 'Loading an OBJ model from an external file is done like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部文件加载 OBJ 模型的操作如下：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, we use `OBJLoader` to load the model from a URL asynchronously.
    This returns a JavaScript promise, which, when resolved, will contain the mesh.
    Once the model is loaded, we do some fine-tuning and make sure the model casts
    shadows and receives shadows as well. Besides `loadAsync`, each loader also provides
    a `load` function, which, instead of working with promises, works with callbacks.
    This same code would then look something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们使用 `OBJLoader` 从 URL 异步加载模型。这返回一个 JavaScript promise，当解析时，将包含网格。一旦模型加载完成，我们进行一些微调，并确保模型可以投射阴影并接收阴影。除了
    `loadAsync`，每个加载器还提供了一个 `load` 函数，它不使用 promises，而是使用回调。这段代码将看起来像这样：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this chapter, we’ll use the `Promise`-based `loadAsync` approach, since
    that avoids having nested callbacks and makes it a bit easier to chain these kinds
    of calls together. The next example (`oad-obj-mtl.html`) uses `OBJLoader`, together
    with `MTLLoader`, to load a model and directly assign a material. The following
    screenshot shows this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用基于 `Promise` 的 `loadAsync` 方法，因为它避免了嵌套回调，并使这些调用更容易串联。下一个示例（`oad-obj-mtl.html`）使用
    `OBJLoader` 和 `MTLLoader` 一起加载模型并直接分配材质。以下截图显示了此示例：
- en: '![Figure 8.8 – OBJ.MTL model with a model and materials](img/Figure_8.8_B18726.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 带有模型和材质的 OBJ.MTL 模型](img/Figure_8.8_B18726.jpg)'
- en: Figure 8.8 – OBJ.MTL model with a model and materials
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 带有模型和材质的 OBJ.MTL 模型
- en: 'Using an `MTL` file besides the `OBJ` file follows the same principle we saw
    earlier in this section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 OBJ 文件外，使用 `MTL` 文件遵循本节前面看到的相同原则：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to mention before we look at the code is that if you receive
    an `OBJ` file, an `MTL` file, and the required texture files, you’ll have to check
    how the `MTL` file references the textures. These should be referenced relative
    to the `MTL` file and not as an absolute path. The code itself isn’t that different
    than the one we saw for `THREE.ObjLoader`. The first thing we do is load the `MTL`
    file with a `THREE.MTLLoader` object and the loaded materials are set in `THREE.ObjLoader`
    through the `setMaterials` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The model we’ve used as an example, in this case, is complex. So, we set some
    specific properties in the callback to fix a number of rendering issues, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: We needed to merge the vertices in the model so that it is rendered as a smooth
    model. For this, we first needed to remove the already defined `normal` vectors
    from the loaded model so that we could use the `BufferGeometryUtils.mergeVertices`
    and `computeVertexNormals` functions to provide Three.js with the information
    to correctly render the model.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we needed to set the `side` property to the `THREE.DoubleSide`
    value.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of one another. We fixed that by setting the `alphaTest` property.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune various
    material properties, though.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Loading a gLTF model
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already mentioned that glTF is a great format to use when importing data
    in Three.js. Just to show you how easy it is to import and show even complex scenes,
    we’ve added an example where we just took a model from [https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d](https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Complex 3D scene loaded from glTF with Three.js](img/Figure_8.9_B18726.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Complex 3D scene loaded from glTF with Three.js
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the previous screenshot, this isn’t a simple scene but
    a complex one, with lots of models, textures, shadows, and other elements. To
    get this in Three.js, all we had to do was this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’re already familiar with the async loader, and the only thing we needed
    to fix was to make sure the `depthWrite` property of the materials was set correctly
    (this seems to be a common issue with some glTF models). And that’s it—it just
    works. glTF also allows us to define animations, which is something we’ll look
    at a bit closer in the next chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Showing complete LEGO models
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides 3D models, where the model defines the vertices, materials, lights,
    and more, there are also various file formats that don’t explicitly define the
    geometries but have more specific usage. The `LDrawLoader` loader, which we’ll
    be looking at in this section, was created to render LEGO models in 3D. Using
    this loader works in the same way as we’ve already seen a couple of times:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the results look really great:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – LEGO Imperial AT-ST model](img/Figure_8.10_B18726.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – LEGO Imperial AT-ST model
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it shows the complete structure of a LEGO set. There are many
    different models out there that you can use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.11 – L\uFEFFEGO X-Wing Fighter](img/Figure_8.11_B18726.jpg)"
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – LEGO X-Wing Fighter
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to explore more models, you can download them from the LDraw repository:
    [https://omr.ldraw.org/](https://omr.ldraw.org/).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Loading voxel-based models
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting approach to creating 3D models is by using voxels. This
    allows you to build models using small cubes and render them using Three.js. For
    instance, you can create Minecraft structures outside of Minecraft using such
    a tool and import them into Minecraft at a later time. A free tool to experiment
    with voxels is MagicaVoxel ([https://ephtracy.github.io/](https://ephtracy.github.io/)).
    This tool allows you to create voxel models such as this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Example model created with MagicaVoxel](img/Figure_8.12_B18726.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Example model created with MagicaVoxel
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that you can easily import these models in Three.js
    using the `VOXLoader` loader, like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `models` folder, you can find a couple of vox models. The following
    screenshot shows what it looks like loaded with Three.js:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Vox model loading with Three.js](img/Figure_8.13_B18726.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Vox model loading with Three.js
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The next loader is another very specific one. We’ll look at how to render proteins
    from PDB format.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Showing proteins from PDB
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PDB website ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides an explanation of these proteins,
    it also provides a way to download the structure of these molecules in PDB format.
    Three.js provides a loader for files specified in the PDB format. In this section,
    we’ll give an example of how you can parse PDB files and visualize them with Three.js.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'With this loader included, we’re going to create the following 3D model of
    the molecule description provided (see the `load-pdb.html` example):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Visualizing a protein using Three.js and PDBLoader](img/Figure_8.14_B18726.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Visualizing a protein using Three.js and PDBLoader
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see from this example code, we instantiate a `THREE.PDBLoader` object
    and pass in the model file we want to load, and once the model is loaded, we process
    it. In this case, the model consists of two properties: `geometryAtoms` and `geometryBonds`.
    The position attributes from `geometryAtoms` contain the positions of the individual
    atoms, and the color attributes can be used to color the individual atoms. For
    a link between the atoms, `geometryBonds` is used.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the position and color, we create a `THREE.Mesh` object and add it
    to a group:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With regard to the connection between the atoms, we follow the same approach.
    We get the start and end positions of the connection and use those to draw the
    connection:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For the connection, we first create a 3D path using `THREE.CatmullRomCurve3`.
    This path is used as input for `THREE.TubeGeometry` and is used to create a connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from PDB.
    For instance, the following screenshot shows the structure of a diamond:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The structure of a diamond](img/Figure_8.15_B18726.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – The structure of a diamond
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’re looking at the support Three.js has for the PLY model,
    which can be used to load point cloud data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Loading a point cloud from a PLY model
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with the PLY format isn’t that much different than the other formats.
    You include the loader and handle the loaded model. For this last example, however,
    we’re going to do something different. Instead of rendering the model as a mesh,
    we’ll use the information from this model to create a particle system (see the
    `load-ply.html` example in the following screenshot):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Point cloud loaded from a PLY model](img/Figure_8.16_B18726.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Point cloud loaded from a PLY model
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript code to render the preceding screenshot is actually very simple;
    it looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we use `THREE.PLYLoader` to load the model and use this geometry
    as input for `THREE.Points`. The material we use is the same as what we used for
    the last example in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122), *Points and
    Sprites*. As you can see, with Three.js, it is very easy to combine models from
    various sources and render them in different ways, all with a few lines of code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Other loaders
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, in the *Loading geometries from external
    resources* section, we showed you a list of all the different loaders provided
    by Three.js. We’ve provided examples of all these in the sources for `chapter-8`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Directory showing examples of all the loaders](img/Figure_8.17_B18726.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Directory showing examples of all the loaders
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The source code for all these loaders follows the same patterns as we’ve seen
    for the loaders we have explained in this chapter. Just load the model, determine
    which part of the loaded model you want to show, make sure scaling and positions
    are correct, and add it to the scene.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加载器的源代码遵循我们在这章中解释的加载器相同的模式。只需加载模型，确定你想显示加载模型的哪一部分，确保缩放和位置正确，然后将其添加到场景中。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using models from external sources isn’t that hard to do in Three.js, especially
    for simple models—you only have to take a few easy steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用外部模型并不困难，特别是对于简单的模型——你只需要进行几个简单的步骤。
- en: When working with external models, or creating them using grouping and merging,
    it is good to keep a couple of things in mind. The first thing you need to remember
    is that when you group objects, they remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you’re dealing with thousands of geometries you
    need to render and you’re running into performance issues. The final approach
    if you want to control a large number of meshes of the same geometry is to use
    a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry` object, which
    allows you to position and transform the individual meshes, but still get great
    performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当与外部模型一起工作，或者通过分组和合并创建它们时，有一些事情需要牢记。首先，你需要记住的是，当你对对象进行分组时，它们仍然作为单独的对象可用。应用于父对象的变化也会影响子对象，但你仍然可以单独变换子对象。除了分组之外，你还可以合并几何体。采用这种方法，你会失去单独的几何体，而得到一个单一的新几何体。这在处理需要渲染成千上万的几何体且遇到性能问题时特别有用。如果你想要控制大量相同几何体的网格，最终的方法是使用`THREE.InstancedMesh`对象或`THREE.InstancedBufferGeometry`对象，这允许你定位和变换单独的网格，同时仍然获得良好的性能。
- en: Three.js supports a large number of external formats. When using these format
    loaders, it’s a good idea to look through the source code and add `console.log`
    statements to determine what the data loaded really looks like. This will help
    you to understand the steps you need to take to get the correct mesh and set it
    to the correct position and scale. Often, when the model doesn’t show correctly,
    this is caused by its material settings. It could be that incompatible texture
    formats are used, opacity is incorrectly defined, or the format contains incorrect
    links to the texture images. It is usually a good idea to use a test material
    to determine whether the model itself is loaded correctly and log the loaded material
    to the JavaScript console to check for unexpected values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持大量外部格式。当使用这些格式加载器时，查看源代码并添加`console.log`语句以确定加载数据的真实外观是个好主意。这将帮助你理解需要采取的步骤以获取正确的网格并将其设置为正确的位置和比例。通常，当模型显示不正确时，这是由于其材质设置引起的。可能是使用了不兼容的纹理格式，不透明度定义不正确，或者格式包含指向纹理图像的错误链接。通常，使用测试材质来确定模型本身是否正确加载，并将加载的材质记录到JavaScript控制台以检查意外值是个好主意。
- en: If you want to reuse your own scenes or models, you can simply export these
    by just calling the `asJson` function and loading them again with `ObjectLoader`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重用你自己的场景或模型，你可以通过调用`asJson`函数简单地导出它们，然后使用`ObjectLoader`再次加载它们。
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren’t animated, don’t move around, and don’t change
    shape. In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), you’ll learn how you
    can animate your models to make them come to life. Besides animations, the next
    chapter will also explain the various camera controls provided by Three.js. With
    a camera control, you can move, pan, and rotate the camera around your scene.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及前几章中你使用的模型大多是静态模型。它们没有动画，不会移动，也不会改变形状。在[*第9章*](B18726_09.xhtml#_idTextAnchor148)中，你将学习如何使你的模型动起来，使其栩栩如生。除了动画之外，下一章还将解释Three.js提供的各种相机控制。通过相机控制，你可以移动、平移和旋转相机，使其围绕场景移动。
