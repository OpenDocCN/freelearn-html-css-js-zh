- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Loading Advanced Meshes and Geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at a couple of different ways that you can create
    and load advanced and complex geometries and meshes. In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    *Learning to Work with Geometries*, and [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring Advanced Geometries*, we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we’ll use the following
    two approaches to create advanced geometries and meshes:'
  prefs: []
  type: TYPE_NORMAL
- en: Geometry grouping and merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading geometries from external resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start with the “group and merge” approach. With this approach, we use the
    standard Three.js grouping (`THREE.Group`) and the `BufferGeometryUtils.mergeBufferGeometries()`
    function to create new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry grouping and merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at two basic features of Three.js: grouping objects
    together and merging multiple geometries into a single geometry. We’ll start with
    grouping objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping objects together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some of the previous chapters, you already saw how you can group objects
    when working with multiple materials. When you create a mesh from a geometry using
    multiple materials, Three.js creates a group. Multiple copies of your geometry
    are added to this group, each with its own specific material. This group is returned,
    so it looks like a mesh that uses multiple materials. In truth, however, it is
    a group that contains a number of meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the `add` function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. When using a group, you can still
    refer to, modify, and position the individual geometries. The only thing you need
    to remember is that all positions, rotations, and translations are done relative
    to the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example (`grouping.html`) in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using a THREE.Group object to group objects together](img/Figure_8.1_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Using a THREE.Group object to group objects together
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you see a large number of cubes, which are added to the scene
    as a single group. Before we look at the controls and the effect of using a group,
    let’s have a quick look at how we’ve created this mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, you can see that we create a `THREE.Group` instance.
    This object is almost identical to `THREE.Object3D`, which is the base class of
    `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn’t contain anything or
    cause anything to be rendered. In this example, we use the `add` function to add
    a large number of cubes to this scene. For this example, we’ve added the controls
    you can use to change the position of a mesh. Whenever you change a property using
    this menu, the relevant property of the `THREE.Group` object is changed. For instance,
    in the next example, you can see that when we scale this `THREE.Group` object,
    all the nested cubes get scaled as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Scaling a group](img/Figure_8.2_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Scaling a group
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment a bit more with the `THREE.Group` object, a good exercise
    would be to alter the example so that the `THREE.Group` instance itself is rotating
    on the *x* axis while the individual cubes are rotating on their *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Performance impact of using THREE.Group
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next section where we look at merging, a quick note
    on performance. When you use `THREE.Group`, all the individual meshes inside this
    group are treated as individual objects, which Three.js needs to manage and render.
    If you’ve got a large number of objects in the scene, you’ll see a noticeable
    drop in performance. If you look at the top-left corner of *Figure 8**.2*, you
    can see that with 5,000 cubes on screen, we get around 56 **frames per second**
    (**FPS**). Not too bad, but normally we would run at around 120 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js provides an additional way where we can still control the individual
    meshes, but get much better performance. This is done through `THREE.InstancedMesh`.
    This object works great if you want to render a large number of objects with the
    same geometry but with different transformations (for example, rotation, scale,
    color, or any other matrix transformation).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve created an example called `instanced-mesh.html`, which shows how this
    works. In this example, we render 250,000 cubes and still have great performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Using an InstancedMesh object for grouping](img/Figure_8.3_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Using an InstancedMesh object for grouping
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with a `THREE.InstancedMesh` object, we create it similarly to how
    we created the `THREE.Group` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The main difference in creating a `THREE.InstancedMesh` object compared to `THREE.Group`
    is that we need to define beforehand which material and geometry we want to use
    and how many instances of this geometry we want to create. To position or rotate
    one of our instances, we need to provide the transformation using a `THREE.Matrix4`
    instance. Luckily, we don’t need to go into the math behind matrices, since Three.js
    provides us with a couple of helper functions on the `THREE.Matrix4` instance
    to define a rotation, a translation, and a couple of other transformations. In
    this example, we simply position each instance at a random location.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you’re working with a small number of meshes (or meshes using different
    geometries), you should use a `THREE.Group` object if you want to group them together.
    If you’re dealing with a large number of meshes that share a geometry and material,
    you can use a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry`
    object for a great performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at merging, where you’ll combine multiple separate
    geometries and end up with a single `THREE.Geometry` object.
  prefs: []
  type: TYPE_NORMAL
- en: Merging geometries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you’re dealing with a very large number of objects, however,
    performance will become an issue since Three.js has to treat all the children
    of the group individually. With `BufferGeometryUtils.mergeBufferGeometries`, you
    can merge geometries together and create a combined one, so Three.js would only
    have to manage this single geometry. In *Figure 8**.4*, you can see how this works
    and the effect it has on performance. If you open the `merging.html` example,
    you see a scene again with the same set of randomly distributed semi-transparent
    cubes, which we merged into a single `THREE.BufferGeometry` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – 500,000 geometries merged into a single geometry](img/Figure_8.4_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – 500,000 geometries merged into a single geometry
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we can easily render 50,000 cubes without any drop in performance.
    To do this, we use the following few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we create a large number of `THREE.BoxGeometry` objects,
    which we merge together using the `BufferGeometryUtils.mergeBufferGeometries(geoms)`
    function. The result is a single large geometry, which we can add to the scene.
    The biggest drawback is that you lose control over the individual cubes since
    they are all merged into a single large geometry. If you want to move, rotate,
    or scale a single cube, you can’t (unless you search for the correct faces and
    vertices and position them individually).
  prefs: []
  type: TYPE_NORMAL
- en: Creating new geometries through Constructive Solid Geometry
  prefs: []
  type: TYPE_NORMAL
- en: Besides merging geometries in the way we saw in this chapter, we can also create
    geometries using `three-bvh-csg` ([https://github.com/gkjohnson/three-bvh-csg](https://github.com/gkjohnson/three-bvh-csg))
    and `Three.csg` ([https://github.com/looeee/threejs-csg](https://github.com/looeee/threejs-csg)).
  prefs: []
  type: TYPE_NORMAL
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn’t always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we’ll look at how you can load geometries
    and meshes from external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Loading geometries from external resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js can read a large number of 3D file formats and import geometries and
    meshes defined in those files. A note here is that not all the features of these
    formats are always supported. So, sometimes there might be an issue with the textures,
    or materials might not be set up correctly. The new de facto standard for exchanging
    models and textures is **glTF**, so if you want to load externally created models,
    exporting those models to glTF format will usually give you the best results in
    Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll dive a bit deeper into some of the formats that are
    supported by Three.js, but we won’t show you all the loaders. The following list
    shows an overview of the formats supported by Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AMF**: AMF is another 3D printing standard, but isn’t under active development
    anymore. The following *Wikipedia* page has additional information on this standard:
    [https://www.sculpteo.com/en/glossary/amf-definition/](https://www.sculpteo.com/en/glossary/amf-definition/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3DM**: 3DM is the format used by Rhinoceros, which is a tool to create 3D
    models. More information on Rhinoceros can be found here: [https://www.rhino3d.com/](https://www.rhino3d.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3MF**: 3MF is one of the standards used in 3D printing. Information about
    this format can be found on the *3MF Consortium* home page: [https://3mf.io](https://3mf.io).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COLLAborative Design Activity (COLLADA**): COLLADA is a format for defining
    digital assets in an XML-based format. This is a widely used format that is supported
    by pretty much all 3D applications and rendering engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draco**: Draco is a file format for storing geometries and point clouds in
    a very efficient way. It specifies how these elements are best compressed and
    decompressed. Details about how Draco works can be found on its GitHub page: [https://github.com/google/draco](https://github.com/google/draco).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GCode**: GCode is a standard way of talking to 3D printers or **CNC** machines.
    When a model is printed, one of the ways a 3D printer can be controlled is by
    sending it GCode commands. The details of this standard are described in the following
    paper: [https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374](https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3?pub_id=823374).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.glb` extension and a text-based format with the `.gltf` extension. More information
    on this standard can be found here: [https://www.khronos.org/gltf/](https://www.khronos.org/gltf/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industry Foundation Classes (IFC)**: This is an open file format used by
    **building information modeling** (**BIM**) tools. It contains a model of a building
    and a lot of additional information on the materials used. More information about
    this standard can be found here: [https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/](https://www.buildingsmart.org/standards/bsi-standards/industry-foundation-classes/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON**: Three.js has its own JSON format that you can use to declaratively
    define a geometry or a scene. Even though this isn’t an official format, it’s
    very easy to use and comes in very handy when you want to reuse complex geometries
    or scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KMZ**: This is the format used for 3D assets on Google Earth. More information
    can be found here: [https://developers.google.com/kml/documentation/kmzarchives](https://developers.google.com/kml/documentation/kmzarchives).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LDraw**: LDraw is an open standard you can use to create virtual LEGO models
    and scenes. More information can be found on the LDraw home page: [https://ldraw.org](https://ldraw.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LWO**: This is the file format used by LightWave 3D. More information on
    LightWave 3D can be found here: [https://www.lightwave3d.com/](https://www.lightwave3d.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NRRD**: NRRD is a file format used to visualize volumetric data. It can,
    for instance, be used to render CT scans. A lot of information and samples can
    be found here: [http://teem.sourceforge.net/nrrd/](http://teem.sourceforge.net/nrrd/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJExporter`, should you want to export your models to OBJ from Three.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PCD**: This is an open format for describing point clouds. More information
    can be found here: [https://pointclouds.org/documentation/tutorials/pcd_file_format.html](https://pointclouds.org/documentation/tutorials/pcd_file_format.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PDB**: This is a very specialized format, created by **Protein Data Bank**
    (**PDB**), which is used to specify what proteins look like. Three.js can load
    and visualize proteins specified in this format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polygon File Format (PLY)**: This is most often used to store information
    from 3D scanners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packed Raw WebGL Model (PRWM)**: This is another format focusing on the efficient
    storage and parsing of 3D geometries. More information on this standard and how
    you can use it is described here: [https://github.com/kchapelier/PRWM](https://github.com/kchapelier/PRWM).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STLExporter.js`, should you want to export your models to STL from Three.js.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.Path` elements that you can use for extruding or rendering in 2D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3DS**: The Autodesk 3DS format. More information can be found at [https://www.autodesk.com/](https://www.autodesk.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TILT**: TILT is the format used by Tilt Brush, a VR tool that allows you
    to paint in VR. More information is available here: [https://www.tiltbrush.com/](https://www.tiltbrush.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VOX**: The format used by MagicaVoxel, a free tool you can use to create
    voxel art. More information is available on the home page of MagicaVoxel: [https://ephtracy.github.io/](https://ephtracy.github.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual Reality Modeling Language (VRML)**: This is a text-based format that
    allows you to specify 3D objects and worlds. It has been superseded by the X3D
    file format. Three.js doesn’t support loading **X3D** models, but these models
    can be easily converted to other formats. More information can be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization Toolkit (VTK)**: This is the file format defined by and used
    to specify vertices and faces. There are two formats available: a binary one and
    a text-based **ASCII** one. Three.js only supports the ASCII-based format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XYZ**: This is a very simple file format for describing points in 3D space.
    More information is available here: [https://people.math.sc.edu/Burkardt/data/xyz/xyz.html](https://people.math.sc.edu/Burkardt/data/xyz/xyz.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), *Animations and Moving the
    Camera*, we’ll revisit some of these formats (and look at a number of additional
    ones) when we look at animations.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this list, Three.js supports a very large number of 3D file
    formats. We won’t be describing all of them, just the most interesting ones. We’ll
    start with the JSON loader since that provides a nice way to store and retrieve
    scenes you’ve created yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading in Three.js JSON format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the Three.js JSON format for two different scenarios in Three.js.
    You can use it to save and load a single `THREE.Object3D` object (which means
    you can also use it to export a `THREE.Scene` object).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just as we did in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081)*,*
    and, using the **save** button from the **Save/load** menu, you can save the current
    geometry. For this example, we save using the HTML5 local storage API. This API
    allows us to easily store persistent information in the client’s browser and retrieve
    it at a later time (even after the browser has been shut down and restarted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Showing the loaded and the current mesh](img/Figure_8.5_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Showing the loaded and the current mesh
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see two meshes—the red one is the one we
    loaded, and the yellow one is the original one. If you open this example yourself
    and click the **save** button, the current state of the mesh will be stored. Now,
    you can refresh the browser and click **load**, and the saved state will be shown
    in red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exporting in JSON from Three.js is very easy and doesn’t require you to include
    any additional libraries. The only thing you need to do is to export `THREE.Mesh`
    as JSON and store it in the browser’s `localstorage`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before saving it, we first convert the result from the `toJSON` function (a
    JavaScript object) to a string using the `JSON.stringify` function. To save this
    information using the HTML5 local storage API, all we have to do is call the `localStorage.setItem`
    function. The first argument is the key value (json) that we can later use to
    retrieve the information we passed in as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'This JSON string looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Three.js saves all the information about the `THREE.Mesh` object.
    Loading `THREE.Mesh` back into Three.js also requires just a few lines of code,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first get the JSON from local storage using the name we saved it with
    (json, in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a load function,
    where you can pass the URL to a file containing the JSON definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see here, we only saved a `THREE.Mesh` object, so we lose everything
    else. If you want to save the complete scene, including the lights and the cameras,
    you can use the same approach to export a scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is a complete scene description in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Exporting a scene to JSON](img/Figure_8.5_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Exporting a scene to JSON
  prefs: []
  type: TYPE_NORMAL
- en: This can be loaded in the same way as we already showed for a `THREE.Mesh` object.
    While storing your current scene and objects in JSON comes in very handy when
    you’re working exclusively in Three.js, this isn’t a format that can easily be
    exchanged with or created by other tools and programs. In the next section, we’ll
    look a bit deeper into some of the 3D formats supported by Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Importing from 3D file formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we’ll quickly walk through a few examples of those
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: The OBJ and MTL formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OBJ and MTL are companion formats and are often used together. An OBJ file
    defines the geometry, and an MTL file defines the materials that are used. Both
    OBJ and MTL are text-based formats. A part of an OBJ file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An MTL file defines materials, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The OBJ and MTL formats are well supported by Three.js, so this is a good format
    to choose if you want to exchange 3D models. Three.js has two different loaders
    you can use. If you only want to load the geometry, you use `OBJLoader`. We used
    this loader for our example (`load-obj.html`). The following screenshot shows
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – OBJ model that just defines the geometry](img/Figure_8.7_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – OBJ model that just defines the geometry
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading an OBJ model from an external file is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we use `OBJLoader` to load the model from a URL asynchronously.
    This returns a JavaScript promise, which, when resolved, will contain the mesh.
    Once the model is loaded, we do some fine-tuning and make sure the model casts
    shadows and receives shadows as well. Besides `loadAsync`, each loader also provides
    a `load` function, which, instead of working with promises, works with callbacks.
    This same code would then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we’ll use the `Promise`-based `loadAsync` approach, since
    that avoids having nested callbacks and makes it a bit easier to chain these kinds
    of calls together. The next example (`oad-obj-mtl.html`) uses `OBJLoader`, together
    with `MTLLoader`, to load a model and directly assign a material. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – OBJ.MTL model with a model and materials](img/Figure_8.8_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – OBJ.MTL model with a model and materials
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an `MTL` file besides the `OBJ` file follows the same principle we saw
    earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to mention before we look at the code is that if you receive
    an `OBJ` file, an `MTL` file, and the required texture files, you’ll have to check
    how the `MTL` file references the textures. These should be referenced relative
    to the `MTL` file and not as an absolute path. The code itself isn’t that different
    than the one we saw for `THREE.ObjLoader`. The first thing we do is load the `MTL`
    file with a `THREE.MTLLoader` object and the loaded materials are set in `THREE.ObjLoader`
    through the `setMaterials` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model we’ve used as an example, in this case, is complex. So, we set some
    specific properties in the callback to fix a number of rendering issues, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We needed to merge the vertices in the model so that it is rendered as a smooth
    model. For this, we first needed to remove the already defined `normal` vectors
    from the loaded model so that we could use the `BufferGeometryUtils.mergeVertices`
    and `computeVertexNormals` functions to provide Three.js with the information
    to correctly render the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we needed to set the `side` property to the `THREE.DoubleSide`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of one another. We fixed that by setting the `alphaTest` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune various
    material properties, though.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a gLTF model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already mentioned that glTF is a great format to use when importing data
    in Three.js. Just to show you how easy it is to import and show even complex scenes,
    we’ve added an example where we just took a model from [https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d](https://sketchfab.com/3d-models/sea-house-bc4782005e9646fb9e6e18df61bfd28d):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Complex 3D scene loaded from glTF with Three.js](img/Figure_8.9_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Complex 3D scene loaded from glTF with Three.js
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the previous screenshot, this isn’t a simple scene but
    a complex one, with lots of models, textures, shadows, and other elements. To
    get this in Three.js, all we had to do was this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You’re already familiar with the async loader, and the only thing we needed
    to fix was to make sure the `depthWrite` property of the materials was set correctly
    (this seems to be a common issue with some glTF models). And that’s it—it just
    works. glTF also allows us to define animations, which is something we’ll look
    at a bit closer in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Showing complete LEGO models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides 3D models, where the model defines the vertices, materials, lights,
    and more, there are also various file formats that don’t explicitly define the
    geometries but have more specific usage. The `LDrawLoader` loader, which we’ll
    be looking at in this section, was created to render LEGO models in 3D. Using
    this loader works in the same way as we’ve already seen a couple of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results look really great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – LEGO Imperial AT-ST model](img/Figure_8.10_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – LEGO Imperial AT-ST model
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it shows the complete structure of a LEGO set. There are many
    different models out there that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.11 – L\uFEFFEGO X-Wing Fighter](img/Figure_8.11_B18726.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – LEGO X-Wing Fighter
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to explore more models, you can download them from the LDraw repository:
    [https://omr.ldraw.org/](https://omr.ldraw.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading voxel-based models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting approach to creating 3D models is by using voxels. This
    allows you to build models using small cubes and render them using Three.js. For
    instance, you can create Minecraft structures outside of Minecraft using such
    a tool and import them into Minecraft at a later time. A free tool to experiment
    with voxels is MagicaVoxel ([https://ephtracy.github.io/](https://ephtracy.github.io/)).
    This tool allows you to create voxel models such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Example model created with MagicaVoxel](img/Figure_8.12_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Example model created with MagicaVoxel
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part is that you can easily import these models in Three.js
    using the `VOXLoader` loader, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `models` folder, you can find a couple of vox models. The following
    screenshot shows what it looks like loaded with Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Vox model loading with Three.js](img/Figure_8.13_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Vox model loading with Three.js
  prefs: []
  type: TYPE_NORMAL
- en: The next loader is another very specific one. We’ll look at how to render proteins
    from PDB format.
  prefs: []
  type: TYPE_NORMAL
- en: Showing proteins from PDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PDB website ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides an explanation of these proteins,
    it also provides a way to download the structure of these molecules in PDB format.
    Three.js provides a loader for files specified in the PDB format. In this section,
    we’ll give an example of how you can parse PDB files and visualize them with Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this loader included, we’re going to create the following 3D model of
    the molecule description provided (see the `load-pdb.html` example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Visualizing a protein using Three.js and PDBLoader](img/Figure_8.14_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Visualizing a protein using Three.js and PDBLoader
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this example code, we instantiate a `THREE.PDBLoader` object
    and pass in the model file we want to load, and once the model is loaded, we process
    it. In this case, the model consists of two properties: `geometryAtoms` and `geometryBonds`.
    The position attributes from `geometryAtoms` contain the positions of the individual
    atoms, and the color attributes can be used to color the individual atoms. For
    a link between the atoms, `geometryBonds` is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the position and color, we create a `THREE.Mesh` object and add it
    to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With regard to the connection between the atoms, we follow the same approach.
    We get the start and end positions of the connection and use those to draw the
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the connection, we first create a 3D path using `THREE.CatmullRomCurve3`.
    This path is used as input for `THREE.TubeGeometry` and is used to create a connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from PDB.
    For instance, the following screenshot shows the structure of a diamond:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The structure of a diamond](img/Figure_8.15_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – The structure of a diamond
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’re looking at the support Three.js has for the PLY model,
    which can be used to load point cloud data.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a point cloud from a PLY model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with the PLY format isn’t that much different than the other formats.
    You include the loader and handle the loaded model. For this last example, however,
    we’re going to do something different. Instead of rendering the model as a mesh,
    we’ll use the information from this model to create a particle system (see the
    `load-ply.html` example in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Point cloud loaded from a PLY model](img/Figure_8.16_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Point cloud loaded from a PLY model
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript code to render the preceding screenshot is actually very simple;
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use `THREE.PLYLoader` to load the model and use this geometry
    as input for `THREE.Points`. The material we use is the same as what we used for
    the last example in [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122), *Points and
    Sprites*. As you can see, with Three.js, it is very easy to combine models from
    various sources and render them in different ways, all with a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Other loaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, in the *Loading geometries from external
    resources* section, we showed you a list of all the different loaders provided
    by Three.js. We’ve provided examples of all these in the sources for `chapter-8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Directory showing examples of all the loaders](img/Figure_8.17_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Directory showing examples of all the loaders
  prefs: []
  type: TYPE_NORMAL
- en: The source code for all these loaders follows the same patterns as we’ve seen
    for the loaders we have explained in this chapter. Just load the model, determine
    which part of the loaded model you want to show, make sure scaling and positions
    are correct, and add it to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using models from external sources isn’t that hard to do in Three.js, especially
    for simple models—you only have to take a few easy steps.
  prefs: []
  type: TYPE_NORMAL
- en: When working with external models, or creating them using grouping and merging,
    it is good to keep a couple of things in mind. The first thing you need to remember
    is that when you group objects, they remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you’re dealing with thousands of geometries you
    need to render and you’re running into performance issues. The final approach
    if you want to control a large number of meshes of the same geometry is to use
    a `THREE.InstancedMesh` object or a `THREE.InstancedBufferGeometry` object, which
    allows you to position and transform the individual meshes, but still get great
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js supports a large number of external formats. When using these format
    loaders, it’s a good idea to look through the source code and add `console.log`
    statements to determine what the data loaded really looks like. This will help
    you to understand the steps you need to take to get the correct mesh and set it
    to the correct position and scale. Often, when the model doesn’t show correctly,
    this is caused by its material settings. It could be that incompatible texture
    formats are used, opacity is incorrectly defined, or the format contains incorrect
    links to the texture images. It is usually a good idea to use a test material
    to determine whether the model itself is loaded correctly and log the loaded material
    to the JavaScript console to check for unexpected values.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reuse your own scenes or models, you can simply export these
    by just calling the `asJson` function and loading them again with `ObjectLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren’t animated, don’t move around, and don’t change
    shape. In [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), you’ll learn how you
    can animate your models to make them come to life. Besides animations, the next
    chapter will also explain the various camera controls provided by Three.js. With
    a camera control, you can move, pan, and rotate the camera around your scene.
  prefs: []
  type: TYPE_NORMAL
