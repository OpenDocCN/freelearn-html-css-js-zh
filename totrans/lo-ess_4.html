<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Transformations Using Map/Reduce"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Transformations Using Map/Reduce</h1></div></div></div><p>The preceding three chapters alluded to transformation possibilities with Lo-Dash. Whether you're working with collections, objects, or functions, a common pattern with Lo-Dash functions is transformation of the input by generating a new, albeit slightly altered, version. The idea of transforming values is central to applicative programming, where much of the code you write is a series of transformations. Beginning with this chapter, we're going to shift gears and look at transformations in more detail.</p><p>Particularly, we'll be looking at all the interesting things we can do with Lo-Dash and the map/reduce programming model. We'll start off with the basics, getting our feet wet with some basic mappings and basic reductions. As we progress through the chapter, we'll start introducing more advanced techniques to think about in terms of map/reduce with Lo-Dash.</p><p>The goal, once you've reached the end of this chapter, is to have a solid understanding of the Lo-Dash functions available that aid in mapping and reducing collections. Additionally, you'll start to notice how disparate Lo-Dash functions work together in the map/reduce domain. Ready?</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Plucking values</li><li class="listitem" style="list-style-type: disc">Mapping collections</li><li class="listitem" style="list-style-type: disc">Mapping objects</li><li class="listitem" style="list-style-type: disc">Reducing collections</li><li class="listitem" style="list-style-type: disc">Reducing objects</li><li class="listitem" style="list-style-type: disc">Binding contexts</li><li class="listitem" style="list-style-type: disc">Map/reduce patterns</li></ul></div><div class="section" title="Plucking values"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Plucking values</h1></div></div></div><p>We've already seen how<a id="id246" class="indexterm"/> values can be plucked from collections using the <code class="literal">pluck()</code> function<a id="id247" class="indexterm"/> in <a class="link" href="ch01.html" title="Chapter 1. Working with Arrays and Collections">Chapter 1</a>, <span class="emphasis"><em>Working with Arrays and Collections</em></span>. Consider that your informal introduction to mapping, because that's essentially what it's doing. It's taking an input collection and mapping it to a new collection, plucking only the properties we're interested in. This is shown in the following example:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Virginia', age: 45 },
    { name: 'Debra', age: 34 },
    { name: 'Jerry', age: 55 },
    { name: 'Earl', age: 29 }
];  

_.pluck(collection, 'age');
// → [ 45, 34, 55, 29 ]</pre></div><p>This is about as simple a mapping operation as you'll find. In fact, you can do the same thing with <code class="literal">map()</code>:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Michele', age: 58 },
    { name: 'Lynda', age: 23 },
    { name: 'William', age: 35 },
    { name: 'Thomas', age: 41 }
];

_.map(collection, 'name');
// → 
// [
//   "Michele",
//   "Lynda",
//   "William",
//   "Thomas"
// ] </pre></div><p>As you'd expect, the output here is exactly the same as it would be with <code class="literal">pluck()</code>. In fact, <code class="literal">pluck()</code> is actually using the <code class="literal">map()</code> function<a id="id248" class="indexterm"/> under the hood. The callback passed to <code class="literal">map()</code> is constructed using <code class="literal">property()</code>, which just returns the specified property value. The <code class="literal">map()</code> function falls back to this plucking behavior when passed a string instead of a function.</p><p>With that brief introduction to the nature of mapping, let's dig a little deeper and see what's possible in mapping collections.</p></div></div>
<div class="section" title="Mapping collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Mapping collections</h1></div></div></div><p>In this section, we'll explore<a id="id249" class="indexterm"/> mapping collections. Mapping one collection to another ranges from composing simple—as we saw in the preceding section—to sophisticated callbacks. Callbacks that map each item in the collection can include or exclude properties and can calculate new values. We'll also address the issue of filtering collections and how this can be done in conjunction with mapping.</p><div class="section" title="Including and excluding properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Including and excluding properties</h2></div></div></div><p>When applied to an <a id="id250" class="indexterm"/>object, the <code class="literal">pick()</code> function generates <a id="id251" class="indexterm"/>a new object containing only the specified properties. The opposite function, <code class="literal">omit()</code>, generates an object with every property except those specified. Since these functions work fine for individual object instances, why not use them with a collection? You can use both of these functions to shed properties from collections by mapping them to new ones, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { first: 'Ryan', last: 'Coleman', age: 23 },
    { first: 'Ann', last: 'Sutton', age: 31 },
    { first: 'Van', last: 'Holloway', age: 44 },
    { first: 'Francis', last: 'Higgins', age: 38 }
];  

_.map(collection, function(item) {
    return _.pick(item, [ 'first', 'last' ]); 
});
// → 
// [
//   { first: "Ryan", last: "Coleman" },
//   { first: "Ann", last: "Sutton" },
//   { first: "Van", last: "Holloway" },
//   { first: "Francis", last: "Higgins" }
// ]</pre></div><p>Here, we're creating a new collection using the <code class="literal">map()</code> function. The callback function supplied to <code class="literal">map()</code> is applied to each item in the collection. The <code class="literal">item</code> argument is the original item from the collection. The callback is expected to return the mapped version of that item and this version could be anything, including the original item itself.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Be careful when manipulating the original item in <code class="literal">map()</code> callbacks. If the item is an object and it's referenced elsewhere in your application, it could have unintended consequences.</p></div></div><p>We're returning a new<a id="id252" class="indexterm"/> object as the mapped item in the <a id="id253" class="indexterm"/>preceding code. This is done using the <code class="literal">pick()</code> function. We only care about the <code class="literal">first</code> and the <code class="literal">last</code> properties. Our newly mapped collection looks identical to the original, except that no item has an <code class="literal">age</code> property. This newly-mapped collection is seen in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { first: 'Clinton', last: 'Park', age: 19 },
    { first: 'Dana', last: 'Hines', age: 36 },
    { first: 'Pete', last: 'Ross', age: 31 },
    { first: 'Annie', last: 'Cross', age: 48 }
];  

_.map(collection, function(item) {
    return _.omit(item, 'first');
});
// → 
// [
//   { last: "Park", age: 19 },
//   { last: "Hines", age: 36 },
//   { last: "Ross", age: 31 },
//   { last: "Cross", age: 48 }
// ]</pre></div><p>This code follows the exact same approach as the previous <code class="literal">pick()</code> code. The only difference is that we're excluding the <code class="literal">first</code> property from the newly-created collection. You'll also notice that we're passing a string containing a single property name instead of an array of property names.</p><p>In addition to passing strings or arrays as the argument to <code class="literal">pick()</code> or <code class="literal">omit()</code>, we can pass in a function callback. This is suitable when it's not very clear which objects in a collection should have which properties. Using a callback like this inside a <code class="literal">map()</code> callback lets us perform detailed comparisons and transformations on collections with very little code:</p><div class="informalexample"><pre class="programlisting">function invalidAge(value, key) {
    return key === 'age' &amp;&amp; value &lt; 40; 
}   

var collection = [ 
    { first: 'Kim', last: 'Lawson', age: 40 },
    { first: 'Marcia', last: 'Butler', age: 31 },
    { first: 'Shawna', last: 'Hamilton', age: 39 },
    { first: 'Leon', last: 'Johnston', age: 67 }
];
 
_.map(collection, function(item) {
    return _.omit(item, invalidAge);
});
// → 
// [
//   { first: "Kim", last: "Lawson", age: 40 },
//   { first: "Marcia", last: "Butler" },
//   { first: "Shawna", last: "Hamilton" },
//   { first: "Leon", last: "Johnston", age: 67 }
// ]</pre></div><p>The new collection<a id="id254" class="indexterm"/> generated by this code excludes the <code class="literal">age</code> property for <a id="id255" class="indexterm"/>items where the <code class="literal">age</code> value is less than <code class="literal">40</code>. The callback supplied to <code class="literal">omit()</code> is applied to each key-value pair in the object. This code is a good illustration of the conciseness achievable with Lo-Dash. There's a lot of iterative code running here, and there is no <code class="literal">for</code> or <code class="literal">while</code> statement in sight.</p></div><div class="section" title="Performing calculations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Performing calculations</h2></div></div></div><p>It's time now to turn our<a id="id256" class="indexterm"/> attention to performing calculations in our <code class="literal">map()</code> callbacks. This entails looking at the item and, based on its current state, computing a new value that will be ultimately mapped to the new collection. This could mean extending the original item's properties or replacing one with a newly computed value. Whichever the case, it's a lot easier to map these computations than to write your own logic that applies these functions to every item in your collection. This is explained using the following example:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Valerie', jqueryYears: 4, cssYears: 3 },
    { name: 'Alonzo', jqueryYears: 1, cssYears: 5 },
    { name: 'Claire', jqueryYears: 3, cssYears: 1 },
    { name: 'Duane', jqueryYears: 2, cssYears: 0 } 
];  

_.map(collection, function(item) {
    return _.extend({
        experience: item.jqueryYears + item.cssYears,
        specialty: item.jqueryYears &gt;= item.cssYears ?
            'jQuery' : 'CSS'
    }, item);
});
// → 
// [
//   {
//     experience": 7,
//     specialty": "jQuery",
//     name": "Valerie",
//     jqueryYears": 4,
//     cssYears: 3
//   },
//   {
//     experience: 6,
//     specialty: "CSS",
//     name: "Alonzo",
//     jqueryYears: 1,
//     cssYears: 5
//   },
//   {
//     experience: 4,
//     specialty: "jQuery",
//     name: "Claire",
//     jqueryYears: 3,
//     cssYears: 1
//   },
//   {
//     experience: 2,
//     specialty: "jQuery",
//     name: "Duane",
//     jqueryYears: 2,
//     cssYears: 0
//   }
// ]</pre></div><p>Here, we're mapping <a id="id257" class="indexterm"/>each item in the original collection to an extended version of it. Particularly, we're computing two new values for each item—<code class="literal">experience</code> and <code class="literal">specialty</code>. The <code class="literal">experience</code> property is simply the sum of the <code class="literal">jqueryYears</code> and <code class="literal">cssYears</code> properties. The <code class="literal">specialty</code> property is computed based on the larger value of the <code class="literal">jqueryYears</code> and <code class="literal">cssYears</code> properties.</p><p>Earlier, I mentioned the need to be careful when modifying items in <code class="literal">map()</code> callbacks. In general, it's a bad idea. It's helpful to try and remember that <code class="literal">map()</code> is used to generate new collections, not to modify existing collections. Here's an illustration of the horrific consequences of not being careful:</p><div class="informalexample"><pre class="programlisting">var app = {}, 
    collection = [ 
        { name: 'Cameron', supervisor: false },
        { name: 'Lindsey', supervisor: true },
        { name: 'Kenneth', supervisor: false },
        { name: 'Caroline', supervisor: true }
    ];  

app.supervisor = _.find(collection, { supervisor: true }); 
    
_.map(collection, function(item) {
    return _.extend(item, { supervisor: false }); 
}); 
    
console.log(app.supervisor);
// → { name: "Lindsey", supervisor: false }</pre></div><p>The destructive<a id="id258" class="indexterm"/> nature of this callback is not obvious at all and next to impossible for programmers to track down and diagnose. It is essentially resetting the <code class="literal">supervisor</code> property for each item. If these items are used anywhere else in the application, the <code class="literal">supervisor</code> property value will be clobbered whenever this map job is executed. If you need to reset values like this, ensure that the change is mapped to the new value and not made to the original.</p><p>Mapping also works with primitive values as the item. Often, we'll have an array of primitive values that we'd like transformed into an alternative representation. For example, let's say you have an array of sizes, expressed in bytes. You can map those arrays to a new collection with those sizes expressed as human-readable values, using the following code:</p><div class="informalexample"><pre class="programlisting">function bytes(b) {
    var units = [ 'B', 'K', 'M', 'G', 'T', 'P' ],
        target = 0;
    while (b &gt;= 1024) { 
        b = b / 1024;
        target++;
    }   
    return (b % 1 === 0 ? b : b.toFixed(1)) +
        units[target] + (target === 0 ? '' : 'B');
}   

var collection = [ 
    1024,
    1048576,
    345198,
    120120120
];  

_.map(collection, bytes);
// → [ "1KB", "1MB", "337.1KB", "114.6MB" ]</pre></div><p>The <code class="literal">bytes()</code> function<a id="id259" class="indexterm"/> takes a numerical argument, which is the number of bytes to be formatted. This is the starting unit. We just keep incrementing the <code class="literal">target</code> unit until we have something that is less than <code class="literal">1024</code>. For example, the last item in our collection maps to <code class="literal">'114.6MB'</code>. The <code class="literal">bytes()</code> function can be passed directly to <code class="literal">map()</code> since it's expecting values in our collection as they are.</p></div><div class="section" title="Calling functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Calling functions</h2></div></div></div><p>We don't always have to write our<a id="id260" class="indexterm"/> own callback functions for <code class="literal">map()</code>. Wherever it makes sense, we're free to leverage Lo-Dash functions to map our collection items. For example, let's say we have a collection and we'd like to know the size of each item. There's a <code class="literal">size()</code> Lo-Dash function we can use as our <code class="literal">map()</code> callback, as follows:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    [ 1, 2 ],
    [ 1, 2, 3 ],
    { first: 1, second: 2 },
    { first: 1, second: 2, third: 3 } 
];  

_.map(collection, _.size);
// → [ 2, 3, 2, 3 ]</pre></div><p>This code has the added benefit that the <code class="literal">size()</code> function returns consistent results, no matter what kind of argument is passed to it. In fact, any function that takes a single argument and returns a new value based on that argument is a valid candidate for a <code class="literal">map()</code> callback. For instance, we could also map the minimum and maximum value of each item:</p><div class="informalexample"><pre class="programlisting">var source = _.range(1000),
    collection = [ 
        _.sample(source, 50),
        _.sample(source, 100),
        _.sample(source, 150)
    ];  

_.map(collection, _.min);
// → [ 20, 21, 1 ]

_.map(collection, _.max);
// → [ 931, 985, 991 ]</pre></div><p>What if we want to map each item of our collection to a sorted version? Since we do not sort the collection itself, we don't care about the item positions within the collection, but the items themselves, if they're arrays, for instance. Let's see what happens with the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    [ 'Evan', 'Veronica', 'Dana' ],
    [ 'Lila', 'Ronald', 'Dwayne' ],
    [ 'Ivan', 'Alfred', 'Doug' ],
    [ 'Penny', 'Lynne', 'Andy' ]
];  

_.map(collection, _.compose(_.first, function(item) {
    return _.sortBy(item);
}));

// → [ "Dana", "Dwayne", "Alfred", "Andy" ]</pre></div><p>This code uses the <code class="literal">compose()</code> function<a id="id261" class="indexterm"/> to construct a <code class="literal">map()</code> callback. The first function returns the sorted version of the item by passing it to <code class="literal">sortBy()</code>. The <code class="literal">first()</code> item of this sorted list is then returned as the mapped item. The end result is a new collection containing the alphabetically-first item from each array in our collection, with three lines of code. Not bad.</p></div><div class="section" title="Filtering and mapping"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Filtering and mapping</h2></div></div></div><p>Filtering and <a id="id262" class="indexterm"/>mapping are two <a id="id263" class="indexterm"/>closely related collection operations. Filtering extracts only those collection items that are of particular interest. Mapping transforms collections to produce new collections. But what if we only want to map a certain subset of our collection? Then it would make sense to chain together the filtering and mapping operations, right? Here's an example of what that might look like:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Karl', enabled: true },
    { name: 'Sophie', enabled: true },
    { name: 'Jerald', enabled: false },
    { name: 'Angie', enabled: false }
];  

_.compose(
    _.partialRight(_.map, 'name'),
    _.partialRight(_.filter, 'enabled')
)(collection);
// → [ "Karl", "Sophie" ]</pre></div><p>This map is executed <a id="id264" class="indexterm"/>using <code class="literal">compose()</code> to build a function that is called<a id="id265" class="indexterm"/> right away, with our <code class="literal">collection</code> as the argument. The function is composed of two partials. We're using <code class="literal">partialRight()</code> on both arguments because we want the collection supplied as the leftmost argument in both cases. The first partial function is <code class="literal">filter()</code>. We're partially applying the <code class="literal">enabled</code> argument. So this function will filter our collection before it's passed to <code class="literal">map()</code>. The result of filtering the collection is passed to <code class="literal">map()</code>, which has the <code class="literal">name</code> argument partially applied. The end result is a collection with enabled <code class="literal">name</code> strings.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>The important thing to note about the preceding code is that the filtering operation takes place <span class="emphasis"><em>before</em></span> the <code class="literal">map()</code> function is run. We could have stored the filtered collection in an intermediate variable instead of streamlining with <code class="literal">compose()</code>. Regardless of flavor, it's important that the items in your mapped collection correspond to the items in the source collection. It's conceivable to filter out the items in the <code class="literal">map()</code> callback by not returning anything, but this is ill-advised as it doesn't map well, both figuratively and literally.</p></div></div></div></div>
<div class="section" title="Mapping objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Mapping objects</h1></div></div></div><p>The previous section focused on <a id="id266" class="indexterm"/>collections and how to map them. But wait, objects are collections too, right? That is indeed correct, but it's worth differentiating between arrays and plain objects. The main reason is that there are implications with ordering and keys when performing map/reduce. At the end of the day, arrays and objects serve different use cases with map/reduce, and this chapter tries to acknowledge these differences.</p><p>Now we'll start looking at some techniques Lo-Dash programmers employ when working with objects and mapping them to collections. There are a number of factors to consider, such as the keys within an object, and calling methods on objects. We'll take a look at the relationship between key-value pairs and how they can be used in a mapping context.</p><div class="section" title="Working with keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Working with keys</h2></div></div></div><p>We can use the keys of a <a id="id267" class="indexterm"/>given object in interesting ways to map the object to a new collection. For example, we can use the <code class="literal">keys()</code> function to extract the keys of an object and map them to values other than the property value, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var object = { 
    first: 'Ronald',
    last: 'Walters',
    employer: 'Packt'
};  

_.map(_.sortBy(_.keys(object)), function(item) {
    return object[item];
});
// → [ "Packt", "Ronald", "Walters" ]</pre></div><p>The preceding code builds an<a id="id268" class="indexterm"/> array of property values from <code class="literal">object</code>. It does this using <code class="literal">map()</code>, which is actually mapping the <code class="literal">keys()</code> array of <code class="literal">object</code>. These keys are sorted using <code class="literal">sortBy()</code>. So <code class="literal">Packt</code> is the first element of the resulting array because <code class="literal">employer</code> is alphabetically-first in the <code class="literal">object</code> keys.</p><p>Sometimes, it's desirable to perform lookups in other objects and map those values to a target object. For example, not all APIs return everything you need for a given page, packaged in a neat little object. You have to do joins and build the data you need. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var users = {}, 
    preferences = {}; 

_.each(_.range(100), function() {
    var id = _.uniqueId('user-');
    users[id] = { type: 'user' };
    preferences[id] = { emailme: !!(_.random()) };
}); 

_.map(users, function(value, key) {
    return _.extend({ id: key }, preferences[key]);
});
// →
// [
//   { id: "user-1", emailme: true },
//   { id: "user-2", emailme: false },
//   ...
// ]</pre></div><p>This example builds two objects, <code class="literal">users</code> and <code class="literal">preferences</code>. In the case of each object, the keys are user identifiers that we're generating with <code class="literal">uniqueId()</code>. The <code class="literal">user</code> objects just have some dummy attribute in them, while the <code class="literal">preferences</code> objects have an <code class="literal">emailme</code> attribute, set to a random Boolean value.</p><p>Now let's say we need quick access to this preference for all users in the <code class="literal">users</code> object. As you can see, it's straightforward to implement using <code class="literal">map()</code> on the <code class="literal">users</code> object. The callback function returns a new object with the user ID. We extend this object with the preference for that particular user by looking them up by <code class="literal">key</code>.</p></div><div class="section" title="Calling methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Calling methods</h2></div></div></div><p>Object properties aren't limited to storing <a id="id269" class="indexterm"/>primitive strings and numbers. Properties can store functions as their values, or methods, as they're commonly referred. However, depending on the context where you're using your object, methods aren't always callable, especially if you have little or no control over the context where your objects are used. One technique that's helpful in situations such as these is mapping the result of calling these methods and using this result in the context in question. Let's see how this can be done with the following code:</p><div class="informalexample"><pre class="programlisting">var object = { 
    first: 'Roxanne',
    last: 'Elliot',
    name: function() {
        return this.first + ' ' + this.last;
    },  
    age: 38, 
    retirement: 65, 
    working: function() {
        return this.retirement - this.age;
    }   
};  

_.map(object, function(value, key) {
    var item = {}; 
    item[key] = _.isFunction(value) ? object[key]() : value
    return item;
});
// →
// [
//   { first: "Roxanne" },
//   { last: "Elliot" },
//   { name: "Roxanne Elliot" },
//   { age: 38 },
//   { retirement: 65 },
//   { working: 27 }
// ]

_.map(object, function(value, key) {
    var item = {}; 
    item[key] = _.result(object, key);
    return item;
});
// →
// [
//   { first: "Roxanne" },
//   { last: "Elliot" },
//   { name: "Roxanne Elliot" },
//   { age: 38 },
//   { retirement: 65 },
//   { working: 27 }
// ]</pre></div><p>Here, we have an object with<a id="id270" class="indexterm"/> both primitive property values and methods that use these properties. Now we'd like to map the results of calling those methods and we will experiment with two different approaches. The first approach uses the <code class="literal">isFunction()</code> function to determine whether the property value is callable or not. If it is, we call it and return that value. The second approach is a little easier to implement and achieves the same outcome. The <code class="literal">result()</code> function is applied to the object using the current key. This tests whether we're working with a function or not, so our code doesn't have to.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>In the first approach to mapping method invocations, you might have noticed that we're calling the method using <code class="literal">object[key]()</code> instead of <code class="literal">value()</code>. The former retains the context as the object variable, but the latter loses the context, since it is invoked as a plain function without any object. So when you're writing mapping callbacks that call methods and not getting the expected results, make sure the method's context is intact.</p></div></div><p>Perhaps you have an object but you're not sure which properties are methods. You can use <code class="literal">functions()</code> to figure this out and then map the results of calling each method to an array, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var object = { 
    firstName: 'Fredrick',
    lastName: 'Townsend',
    first: function() {
        return this.firstName;
    },  
    last: function() {
        return this.lastName;
    }   
};  

var methods = _.map(_.functions(object), function(item) {
    return [ _.bindKey(object, item) ];
}); 

_.invoke(methods, 0);
// → [ "Fredrick", "Townsend" ]</pre></div><p>The <code class="literal">object</code> variable has two methods, <code class="literal">first()</code> and <code class="literal">last()</code>. Assuming we didn't know about these methods, we can find them using <code class="literal">functions()</code>. Here, we're building a <code class="literal">methods</code> array using <code class="literal">map()</code>. The input is an array containing the names of all the methods of the given object. The value we're returning is interesting. It's a single-value array; you'll see why in a moment. The value of this array is a function built by passing the object and the name of the method to <code class="literal">bindKey()</code>. This function, when invoked, will always use <code class="literal">object</code> as its context.</p><p>Lastly, we use <code class="literal">invoke()</code> to <a id="id271" class="indexterm"/>invoke each method in our <code class="literal">methods</code> array, building a new result array. Recall that our <code class="literal">map()</code> callback returned an array. This was a simple hack to make <code class="literal">invoke()</code> work, since it's a convenient way to call methods. It generally expects a key as the second argument, but a numerical index works just as well, since they're both looked up the same.</p></div><div class="section" title="Mapping key-value pairs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Mapping key-value pairs</h2></div></div></div><p>Just because you're working <a id="id272" class="indexterm"/>with an object doesn't mean it's ideal, or even necessary. That's what <code class="literal">map()</code> is for—mapping what you're given to what you need. For instance, the property values are sometimes all that matter for what you're doing, and you can dispense with the keys entirely. For that, we have the <code class="literal">values()</code> function and we feed the values to <code class="literal">map()</code>:</p><div class="informalexample"><pre class="programlisting">var object = { 
    first: 'Lindsay',
    last: 'Castillo',
    age: 51
};  

_.map(_.filter(_.values(object), _.isString), function(item) {
    return '&lt;strong&gt;' + item + '&lt;/strong&gt;';
});
// → [ "&lt;strong&gt;Lindsay&lt;/strong&gt;", "&lt;strong&gt;Castillo&lt;/strong&gt;" ]</pre></div><p>All we want from the <code class="literal">object</code> variable here is a list of property values, which are strings, so that we can format them. In other words, the fact that the keys are <code class="literal">first</code>, <code class="literal">last</code>, and <code class="literal">age</code> is irrelevant. So first, we call <code class="literal">values()</code> to build an array of values. Next, we pass that array to <code class="literal">filter()</code>, removing anything that's not a string. We then pass the output of this to <code class="literal">map()</code>, where we're able to map the string using <code class="literal">&lt;strong/&gt;</code> tags.</p><p>The opposite might also be true—the value is completely meaningless without its key. If that's the case, it may be fitting to map key-value pairs to a new collection, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}   

function format(label, value) {
    return '&lt;label&gt;' + capitalize(label) + ':&lt;/label&gt;' +
        '&lt;strong&gt;' + value + '&lt;/strong&gt;';
}   

var object = { 
    first: 'Julian',
    last: 'Ramos',
    age: 43
};  

_.map(_.pairs(object), function(pair) {
    return format.apply(undefined, pair);
});
// →
// [
//   "&lt;label&gt;First:&lt;/label&gt;&lt;strong&gt;Julian&lt;/strong&gt;",
//   "&lt;label&gt;Last:&lt;/label&gt;&lt;strong&gt;Ramos&lt;/strong&gt;",
//   "&lt;label&gt;Age:&lt;/label&gt;&lt;strong&gt;43&lt;/strong&gt;"
// ]</pre></div><p>We're passing the result of <a id="id273" class="indexterm"/>running our object through the <code class="literal">pairs()</code> function to <code class="literal">map()</code>. The argument passed to our <code class="literal">map</code> callback function is an array, the first element being the key and the second being the value. It so happens that the <code class="literal">format()</code> function expects a key and a value to format the given string, so we're able to use <code class="literal">format.apply()</code> to call the function, passing it the <code class="literal">pair</code> array. This approach is just a matter of taste. There's no need to call <code class="literal">pairs()</code> before <code class="literal">map()</code>. We could just as easily have called <code class="literal">format</code> directly. But sometimes, this approach is preferred, and the reasons, not least of which is the style of the programmer, are wide and varied.</p></div></div>
<div class="section" title="Reducing collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Reducing collections</h1></div></div></div><p>It's now time to look at <a id="id274" class="indexterm"/>reducing collections. Lo-Dash helps a lot here too, supplying functions that help us reduce arrays, objects, and anything that's thrown our way. Aside from primitives, all data structures can be reduced to something simpler.</p><p>We'll start off by looking at the common reduce cases, summing values, and such. This will be followed by the topic of filtering collections and how it relates to reducing. Then, we'll look at some more advanced computational techniques.</p><div class="section" title="Summing values"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Summing values</h2></div></div></div><p>Unlike other programming <a id="id275" class="indexterm"/>languages, JavaScript has no built-in mechanism to sum together an array of values. The closest we get to summing is the native <code class="literal">Array.reduce()</code> method, which is actually general purpose and not specifically for summing values. The Lo-Dash version of <code class="literal">reduce</code> is even more general purpose, and here's an example of how to use it in summing values in a collection:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { ram: 1024, storage: 2048 },
    { ram: 2048, storage: 4096 },
    { ram: 1024, storage: 2048 },
    { ram: 2048, storage: 4096 }
];  

_.reduce(collection, function(result, item) {
    return result + item.ram;
}, 0);
// → 6144

_.reduce(collection, function(result, item) {
    return result + item.storage;
}, 0);
// → 12288</pre></div><p>Here, we have a simple collection that we're reducing to two values. The first call to <code class="literal">reduce()</code> has a callback that sums together the <span class="strong"><strong>accumulator</strong></span><a id="id276" class="indexterm"/> and the <code class="literal">ram</code> property of the current item. The second <code class="literal">reduce()</code> call does the same thing, except that it works on the <code class="literal">storage</code> property. We're essentially reducing the collection to a number, hence the term. You'll also notice that we passed a <code class="literal">0</code> value to <code class="literal">reduce()</code> after the callback function. This is the accumulator. As the name suggests, its job is to accumulate data as each item is passed through the callback. This is also called the result and is always passed as the first argument to the <code class="literal">reduce</code> callback. Let's look at a different kind of accumulator now:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { hits: 2, misses: 4 },
    { hits: 5, misses: 1 },
    { hits: 3, misses: 8 },
    { hits: 7, misses: 3 } 
];  

_.reduce(collection, function(result, item) {
    return {
        hits: result.hits + item.hits,
        misses: result.misses + item.misses
    }; 
}, { hits: 0, misses: 0 });
// → { hits: 17, misses: 16 }</pre></div><p>This accumulator is an <a id="id277" class="indexterm"/>object and it initializes two properties to <code class="literal">0</code>. The callback function just keeps returning a new accumulator object with computed sums of <code class="literal">hits</code> and <code class="literal">misses</code>. A nice side effect to this approach is that there's only one call to <code class="literal">reduce()</code> instead of two. However, accumulators aren't strictly necessary. In simple cases of summing items, there's actually no point in using them. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">function add(a, b) {
    return a + b;
}   

var collection = [ 
    { wins: 34, loses: 21 },
    { wins: 58, loses: 12 },
    { wins: 34, loses: 23 },
    { wins: 40, loses: 15 }
];  

_.reduce(_.range(1, 6), add);
// → 15

_.reduce(_.pluck(collection, 'wins'), add);
// → 166

_.reduce(_.pluck(collection, 'loses'), add);
// → 71</pre></div><p>This example uses a generic <code class="literal">reduce</code> callback function that returns the sum of its two arguments. Then we have a basic collection of objects, each with two properties. The first call to <code class="literal">reduce()</code> passes an array of numbers to the <code class="literal">add()</code> callback. The next two calls first use <code class="literal">pluck()</code> to build an array of numbers, using their respective key name strings. These calls use the same callback. The thing to notice about this code is that there is no explicit accumulator in the call to <code class="literal">reduce()</code>. The default, when none is specified by the caller, is the first element of the collection. With arrays that have primitive values such as these, this is fine and can actually simplify the callback function.</p></div><div class="section" title="Filtering and reducing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Filtering and reducing</h2></div></div></div><p>You won't always need or want to <a id="id278" class="indexterm"/>reduce entire<a id="id279" class="indexterm"/> collections to a single value. Instead, it's a filtered subset that's required. Sometimes, your code is passed a collection that's the result of applying a filter to some larger collection. Or, you need to apply the filter itself. Consider the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Gina', age: 34, enabled: true },
    { name: 'Trevor', age: 45, enabled: false },
    { name: 'Judy', age: 71, enabled: true },
    { name: 'Preston', age: 19, enabled: false }
];  

_.reduce(_.filter(collection, 'enabled'), function(result, item) {
    result.names.push(item.name);
    result.years += item.age;
    return result;
}, { names: [], years: 0 });
// →
// {
//   names: [
//     "Gina",
//     "Judy"
//   ],
//   years: 105
// }</pre></div><p>The <code class="literal">filter()</code> function is used only to feed enabled objects to the <code class="literal">reduce()</code> call. This is called filtering <span class="emphasis"><em>then</em></span> reducing. However, there's an alternative approach that could be applied here. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Melissa', age: 28, enabled: true },
    { name: 'Kristy', age: 22, enabled: true },
    { name: 'Kerry', age: 31, enabled: false },
    { name: 'Damon', age: 36, enabled: false }
];  

_.reduce(collection, function(result, item) {
    if (item.enabled) {
        result.names.push(item.name);
        result.years += item.age;
    }   
    return result;
}, { names: [], years: 0 });
// →
// {
//   names: [
//     "Melissa",
//     "Kristy"
//   ],
//   years: 50
// }</pre></div><p>This approach <a id="id280" class="indexterm"/>performs the necessary filtering inside the callback. This is <a id="id281" class="indexterm"/>called filtering <span class="emphasis"><em>and</em></span> reducing. If the item isn't enabled, we simply return the last result. If it's enabled, we do the regular reduce work. So it's as though we're simply skipping items that would have been filtered anyway. This has the advantage that with big collections, you're not doing a linear operation through the collection twice, but only once. The downside is the added complexity in the <code class="literal">reduce</code> callback. But wherever this can be minimized, such as in the preceding case, shift the filtering work to the <code class="literal">reduce</code> callback to optimize your code.</p></div><div class="section" title="Min, max, and average operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Min, max, and average operations</h2></div></div></div><p>Lo-Dash has functions that help in <a id="id282" class="indexterm"/>more complex operations and simultaneously let you<a id="id283" class="indexterm"/> write clean and concise code. For example, the<a id="id284" class="indexterm"/> <code class="literal">min()</code> <a id="id285" class="indexterm"/>and <code class="literal">max()</code> functions<a id="id286" class="indexterm"/> accept callbacks that let them be used in a variety of situations, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">function score(item) {
    return _.reduce(item.scores, function(result, score) {
        return result + score;
    }); 
}   

var collection = [ 
    { name: 'Madeline', scores: [ 88, 45, 83 ] },
    { name: 'Susan', scores: [ 79, 82, 78 ] },
    { name: 'Hugo', scores: [ 90, 84, 85 ] },
    { name: 'Thomas', scores: [ 74, 69, 78 ] } 
];  

_.min(collection, score);
// →
// {
//   name: "Madeline",
//   scores: [
//     88,
//     45,
//     83
//   ]
// }

_.max(collection, score);
// →
// {
//   name: "Hugo",
//   scores: [
//     90,
//     84,
//     85
//   ]
// }</pre></div><p>The <code class="literal">score()</code> function <a id="id287" class="indexterm"/>defined in this code reduces the passed-in <a id="id288" class="indexterm"/>item to the <a id="id289" class="indexterm"/>sum of its <code class="literal">scores</code> property, assumed to be an array. This<a id="id290" class="indexterm"/> is meant to be used as a callback to the <code class="literal">min()</code> and <code class="literal">max()</code> functions. The idea is that <code class="literal">score()</code> is applied to each object in our collection and the minimum or maximum value is returned. So we're actually doing two reduce jobs, one for the <code class="literal">scores</code> property and another for the collection.</p><p>Reducing collections to averages is a little trickier because there's no Lo-Dash function called <code class="literal">avg()</code> that reduces a collection to an average. Let's see if we can implement something that doesn't require much more code than the preceding example:</p><div class="informalexample"><pre class="programlisting">function average(items) {
    return _.reduce(items, function(result, item) {
        return result + item;
    }) / items.length;
}   

var collection = [ 
    { name: 'Anthony', scores: [ 89, 59, 78 ] },
    { name: 'Wendy', scores: [ 84, 80, 81 ] },
    { name: 'Marie', scores: [ 58, 67, 63 ] },
    { name: 'Joshua', scores: [ 76, 68, 74 ] } 
];  

_.reduce(collection, function(result, item, index, coll) {
    var ave = average(item.scores);
    result.push(ave);
    if (index === (coll.length - 1)) {
        return average(result);
    }   
    return result;
}, []).toFixed(2);
// → "73.08"</pre></div><p>Like the <code class="literal">scores()</code> callback<a id="id291" class="indexterm"/> function before this example, we have<a id="id292" class="indexterm"/> an <code class="literal">average()</code> function. This reduces the passed-in items <a id="id293" class="indexterm"/>to their average value. Our collection is composed of objects, each of which has a <code class="literal">scores</code> array. We're interested in finding the average of the entire collection. So, we'll call <code class="literal">reduce()</code> on our collection. The callback uses the <code class="literal">average()</code> function<a id="id294" class="indexterm"/> to compute the average score for each item. This result is then added to the <code class="literal">reduce()</code> accumulator. If we've reached the last item, average is done by checking the collection length. Then it's time to compute the final average—an average of averages. Since the accumulator is an array of numbers, we can simply return the value generated by passing it to <code class="literal">average()</code>.</p></div></div>
<div class="section" title="Reducing objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Reducing objects</h1></div></div></div><p>In this section, we will turn our <a id="id295" class="indexterm"/>attention to reducing objects and working with object accumulators. Reducing objects is a lot like reducing arrays, the difference being that you have a key instead of an index. Oh yeah, there's also the ordering, which is kind of important—arrays are ordered, objects aren't.</p><p>Previously in the chapter, we caught a glimpse of what accumulators are. Here we'll take a deeper look at object accumulators, including some of the built-in Lo-Dash functions that utilize this concept.</p><div class="section" title="Reducing keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Reducing keys</h2></div></div></div><p>You can reduce an object to something <a id="id296" class="indexterm"/>different based solely on its keys. For example, if there are only certain properties you need, you can reduce the object to include only those properties, using the following code:</p><div class="informalexample"><pre class="programlisting">var object = { 
        first: 'Kerry',
        last: 'Singleton',
        age: 41
    },  
    allowed = [ 'first', 'last' ];

_.reduce(object, function(result, value, key) {
    if (_.contains(allowed, key)) {
        result[key] = value;
    }   
    return result;
}, {});
// → { first: "Kerry", last: "Singleton" }

_.pick(object, allowed);
// → { first: "Kerry", last: "Singleton" }</pre></div><p>The <code class="literal">allowed</code> array contains the names of allowed property keys, and we're using the <code class="literal">reduce()</code> function to check whether the given key is allowed or not. If it is allowed, it gets added to the object<a id="id297" class="indexterm"/> accumulator. Otherwise, it's skipped. You'll notice that we can achieve the same effect by passing the <code class="literal">allowed</code> array to the <code class="literal">pick()</code> function. So check what Lo-Dash does out of the box before writing your own callback. On the other hand, your own code lends itself to changeability.</p></div><div class="section" title="Object accumulators"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Object accumulators</h2></div></div></div><p>As an alternative to <code class="literal">reduce()</code>, the <code class="literal">transform()</code> function is<a id="id298" class="indexterm"/> used to transform a source object into a target object. The main difference is that with <code class="literal">transform</code>, there's an implied accumulator. This accumulator object is created when the <code class="literal">transform()</code> function is first called. It's then passed as a reference to the <code class="literal">callback</code> function for each property, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var object = { 
    first: '&amp;lt;strong&amp;gt;Nicole&amp;lt;/strong&amp;gt;',
    last: '&amp;lt;strong&amp;gt;Russel&amp;lt;/strong&amp;gt;',
    age: 26
};   

_.transform(object, function(result, value, key) {
    if (_.isString(value)) {
        result[key] = _.unescape(value);
    }   
});
// →
// {
//   first: "&lt;strong&gt;Nicole&lt;/strong&gt;",
//   last: "&lt;strong&gt;Russel&lt;/strong&gt;"
// }</pre></div><p>Here we have an object with two string properties. The <code class="literal">callback</code> function we passed to <code class="literal">transform()</code> looks for string properties and uses <code class="literal">unescape()</code> to replace any HTML character codes. The <code class="literal">result</code> argument is here, just as it was in the <code class="literal">reduce()</code> callbacks, but we don't need to return it. We also don't need to supply an accumulator object because it is created for us. Let's take a closer look at how the accumulator is created.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The downside to using <code class="literal">transform()</code> is that it looks as though you're transforming and returning the object that was passed in, which isn't the case. The <code class="literal">transform()</code> function does not touch the source object.</p></div></div><p>Let's say we're transforming<a id="id299" class="indexterm"/> an instance of a class, rather than just a plain object. This can be done using the following code:</p><div class="informalexample"><pre class="programlisting">function Person(first, last) {
    this.first = first;
    this.last = last;
}   

Person.prototype.name = function name() {
    return this.first + ' ' + this.last;
};  

var object = new Person('Alex', 'Rivera');

_.transform(object, function(result, value, key) {
    if (_.isString(value)) {
        result[key] = value.toUpperCase();
    }   
}).name();
// → "ALEX RIVERA"</pre></div><p>The <code class="literal">object</code> variable holds an instance of <code class="literal">Person</code>. Our <code class="literal">transform()</code> callback simply looks for strings and transforms them into their uppercase equivalents. When we call the <code class="literal">name()</code> function on the transformed object, we get the uppercase result we expect. Notice that the <code class="literal">name()</code> method is on the <code class="literal">Person</code> prototype. The <code class="literal">transform()</code> function constructs the transformed instance properly using the appropriate constructor function. This ensures that the prototypical methods and properties are where they should be.</p><p>Lo-Dash has other functions that work along the same lines in terms of object accumulators, the difference being that the source is a collection instead of an object. For example, you can take a collection and group or index the items, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { id: _.uniqueId('id-'), position: 'absolute', top: 12 },
    { id: _.uniqueId('id-'), position: 'relative', top: 20 },
    { id: _.uniqueId('id-'), position: 'absolute', top: 12 },
    { id: _.uniqueId('id-'), position: 'relative', top: 20 }
];  

_.groupBy(collection, 'position');
// →
// {
//   absolute: [
//     { id: "id-1", position: "absolute", top: 12 },
//     { id: "id-3", position: "absolute", top: 12 }
//   ],
//   relative: [
//     { id: "id-2", position: "relative", top: 20 },
//     { id: "id-4", position: "relative", top: 20 }
//   ]
// }

_.indexBy(collection, 'id');
// →
// {
//   "id-1": {
//     id: "id-1",
//     position: "absolute",
//     top: 12
//   },
//   "id-2": {
//     id: "id-2",
//     position: "relative",
//     top: 20
//   },
//   "id-3": {
//     id: "id-3",
//     position: "absolute",
//     top: 12
//   },
//   "id-4": {
//     id: "id-4",
//     position: "relative",
//     top: 20
//   }
// }</pre></div><p>The <code class="literal">groupBy()</code> function groups<a id="id300" class="indexterm"/> items of the collection according to the value of the specified property. That is, if the same two items have the same <code class="literal">position</code> property value, they'll be grouped together under the same object key. On the other hand, <code class="literal">indexBy()</code> will put only one item in a given key. So this function is better suited for unique properties such as identifiers. Instead of a <code class="literal">property</code> string, we can pass a function that generates the value if we're so inclined. The result of running the <code class="literal">indexBy()</code> call is an object with unique keys that we can use to look up items.</p></div></div>
<div class="section" title="Binding contexts"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Binding contexts</h1></div></div></div><p>You might not always<a id="id301" class="indexterm"/> want to use anonymous functions, or Lo-Dash functions, as your <code class="literal">map()</code> callback. This is the same case with <code class="literal">reduce()</code>. Luckily, you can easily bind the callback function context in both cases. For example, let's say that you have an application object that is not global. You can still make it the context of your callback function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var app = { 
    states: [
        'running',
        'off',
        'paused'
    ],  
    machines: [
        { id: _.uniqueId(), state: 1 },
        { id: _.uniqueId(), state: 0 },
        { id: _.uniqueId(), state: 0 },
        { id: _.uniqueId(), state: 2 } 
    ]   
};  

var mapStates = _.partialRight(_.map, function(item) {
    return _.extend({
        state: this.states[item.state]
    }, _.pick(item, 'id'));
}, app);

mapStates(app.machines);
// →
// [
//   { state: "off", id: "1" },
//   { state: "running", id: " " },
//   { state: "running", id: " " },
//   { state: "paused", id: " " }
// ]</pre></div><p>The preceding example uses the <code class="literal">partialRight()</code> function to compose a callback function. We're partially applying arguments to the <code class="literal">map()</code> function. The first is the callback function and the second is the context of the function, the <code class="literal">app</code> instance in this case. This basically enables the callback function to refer to the <code class="literal">this</code> keyword as the application, despite it not being in the global scope.</p><p>The same context-binding principle can be applied to the <code class="literal">reduce()</code> function:</p><div class="informalexample"><pre class="programlisting">var collection = [ 12, 34, 53, 43 ],
    settings = { tax: 1.15 },
    applyTax = _.partialRight(_.reduce, function(result, item) {
        return result + item * this.tax;
    }, 0, settings);

applyTax(collection).toFixed(2);
// → "163.30"</pre></div><p>Here, the <code class="literal">reduce</code> callback<a id="id302" class="indexterm"/> is a partial function that has a <code class="literal">settings</code> object as its context. This object has a <code class="literal">tax</code> property that's used to reduce the collection, by multiplying its value by each item in the collection. This result is then added to the accumulator.</p></div>
<div class="section" title="Map/reduce patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Map/reduce patterns</h1></div></div></div><p>We'll close the chapter with an<a id="id303" class="indexterm"/> introduction to some basic map/reduce patterns, applicable to everything you've learned in this chapter so far. First, we'll take a look at what generic callback functions look like and why they're useful. Then we'll introduce the notion of map/reduce chains.</p><div class="section" title="Generic callback functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Generic callback functions</h2></div></div></div><p>As the development of your<a id="id304" class="indexterm"/> frontend application progresses, you'll start to notice that there is some commonality between all of your map/reduce callback functions. In other words, you could probably factor the generic aspects of the callbacks into a single generic callback. As you've seen throughout this chapter and the previous chapter, it's easy to partially apply and compose new functions with Lo-Dash. This is especially helpful when you have a handful of generic functions that you'd like to use as callbacks.</p><p>For instance, let's create some generic <code class="literal">map()</code> callback functions and see how they can be used:</p><div class="informalexample"><pre class="programlisting">function add(item) {
    var result = _.clone(item);
    result[this.prop] += this.value;
    return result;
}   

function upper(item) {
    var result = _.clone(item);
    result[this.prop] = result[this.prop].toUpperCase();
    return result;
}   

var collection = [ 
    { name: 'Gerard', balance: 100 },
    { name: 'Jean', balance: 150 },
    { name: 'Suzanne', balance: 200 },
    { name: 'Darrell', balance: 250 }
];  

var mapAdd = _.partial(_.map, collection, add),
    mapUpper = _.partial(_.map, collection, upper);

mapAdd({ prop: 'balance', value: 50 }); 
// →
// [
//   { name: "Gerard", balance: 150 },
//   { name: "Jean", balance: 200 },
//   { name: "Suzanne", balance: 250 },
//   { name: "Darrell", balance: 300 }
// ]

mapAdd({ prop: 'balance', value: 100 });
// →
// [
//   { name: "Gerard", balance: 200 },
//   { name: "Jean", balance: 250 },
//   { name: "Suzanne", balance: 300 },
//   { name: "Darrell", balance: 350 }
// ]

mapUpper({ prop: 'name'});
// →
// [
//   { name: "GERARD", balance: 100 },
//   { name: "JEAN", balance: 150 },
//   { name: "SUZANNE", balance: 200 },
//   { name: "DARRELL", balance: 250 }
// ]</pre></div><p>Here, we have two <a id="id305" class="indexterm"/>generic functions, <code class="literal">add()</code> and <code class="literal">upper()</code>. They both follow similar patterns. For example, both refer to the <code class="literal">this.prop</code> property. So they're both context dependent. However, this is a strength, not a weakness. The <code class="literal">add()</code> callback uses <code class="literal">this.prop</code> to determine which property to manipulate. The <code class="literal">this.value</code> property determines the value to add. As we've seen, it's easy to supply context to these functions and that's how we get specific information to these callbacks. The <code class="literal">upper()</code> callback does the same thing, but it transforms the existing property to uppercase.</p><p>The <code class="literal">mapAdd()</code> and <code class="literal">mapUpper()</code> functions are created as partials, pre-supplying the collection and the generic callback function. All that's missing is the context and that is supplied when the function is called. This means these functions have the potential to be useful throughout the application, getting new contexts when called.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>It's tempting, as with any other programming endeavor to try and create generic map/reduce callback functions up-front, that is, trying to foresee where you'll need similar but slightly different functionality. The truth is that <span class="strong"><strong>hindsight</strong></span><a id="id306" class="indexterm"/> is a powerful tool. It's much easier to see where generic functions become useful after you've started to repeat yourself. <span class="strong"><strong>Foresight</strong></span>, on the other hand, tends to <a id="id307" class="indexterm"/>lead to conceptually useful callback functions that aren't actually needed.</p></div></div><p>All the ideas that apply to generic functions for <code class="literal">map()</code> callback functions also apply to <code class="literal">reduce()</code> callback functions. Here's an example:</p><div class="informalexample"><pre class="programlisting">function sum(a, b) {
    return a + b[this.prop];
}   

var collection = [ 
    { low: 40, high: 70 },
    { low: 43, high: 83 },
    { low: 39, high: 79 },
    { low: 45, high: 74 }
];  

var reduceSum = _.partial(_.reduce, collection, sum, 0); 

reduceSum({ prop: 'low' });
// → 167

reduceSum({ prop: 'high' });
// → 306</pre></div><p>The generic <code class="literal">sum()</code> function<a id="id308" class="indexterm"/> returns the sum of the two arguments. However, it uses <code class="literal">this.prop</code> to determine which property should be added. Then we proceed to create the <code class="literal">reduceSum()</code> function using <code class="literal">partial()</code>. Now we can call <code class="literal">reduceSum()</code> with any context we want.</p></div><div class="section" title="Map/reduce chains"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Map/reduce chains</h2></div></div></div><p>The final pattern we'll look at in this chapter is <a id="id309" class="indexterm"/>the notion of a map/reduce chain. This is closely related to the map/reduce programming model introduced by Google. The idea is that with large datasets, it's easier to tackle computationally intensive problems when you can break the problem into a set of mapping operations. These operations are then fed to a set of reducing operations. From this perspective, it's much easier to distribute the computation across nodes.</p><p>What we're interested in, however, is the handoff that takes place between the map job and the reduce job. The map job is responsible for mapping the source data to something that is consumable by the reduce job. This pattern might actually repeat several times. For example, a dataset is mapped and then reduced. The result of reducing it is then further mapped, and further reduced, and so on. Let's see how something like this looks in Lo-Dash:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Wade', balance: 100 },
    { name: 'Donna', balance: 125 },
    { name: 'Glenn', balance: 90 },
    { name: 'Floyd', balance: 110 }
], bonus = 25; 

var mapped = _.map(collection, function(item) {
    return _.extend({
        bonus: item.balance + bonus
    }, item);
}); 

_.reduce(mapped, function(result, item, index, coll) {
    result += (item.bonus - item.balance) / item.bonus;
    if (index === (coll.length - 1)) {
        result = result / coll.length * 100;
    }   
    return result;
}, 0).toFixed(2) + '%';
// → "19.23%"</pre></div><p>Here, we map the collection by computing the amount after adding a <code class="literal">bonus</code> property to the <code class="literal">balance</code> item for each item. This newly mapped collection is stored in the <code class="literal">mapped</code> variable. Then we reduce the collection to the average rate of increase. Note that the reduce callback expects a mapped collection since it makes use of the <code class="literal">bonus</code> property, which isn't in the original collection.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Summary</h1></div></div></div><p>This chapter introduced you to the map/reduce programming model and how Lo-Dash tools can help to realize it in your application. First, we examined mapping collections, including how to choose which properties get included and how to perform calculations. We then moved on to mapping objects. Keys have an important role in how objects get mapped to new objects and collections. There are also methods and functions to consider when mapping.</p><p>The second part of the chapter covered reducing, including how to sum items, how to transform objects, and how to formulate generic callback functions that can be used in a variety of contexts. The chapter closed with a brief look at what chaining map/reduce operations together looks like.</p><p>Map/reduce is an important topic because Lo-Dash supports many variations of the programming model. It's now time to expand on the chaining concept, and it turns out that there's a lot more than just map/reduce functions that can be glued together.</p></div></body></html>