<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;What Was I Thinking? Documenting Backbone Code" id="aid-2F4UM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. What Was I Thinking? Documenting Backbone Code</h1></div></div></div><p>In this chapter, we will consider various options for documenting your Backbone code, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">"Non-documentation" approach to documentation</li><li class="listitem">How to explicitly document your code without a formal structure</li><li class="listitem">How to explicitly document your code using a formal structure such as JSDoc</li><li class="listitem">How to use Docco, an alternate documentation tool from the creator of Backbone'</li></ul></div><div class="section" title="Backbone and documentation"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Backbone and documentation</h1></div></div></div><p>Documentation <a id="id265" class="indexterm"/>is important in any software project, but Backbone projects have some unique considerations when it comes to documentation. However, before we delve into these considerations, it's important to identify why you are documenting your code in the first place, and what strategy you plan to use to document it.</p><p>Many developers have the false impression that documentation is for other developers, when in fact, nothing could be further from the truth. Most software isn't written just once but is instead iterated on over time. Each new revision can occur days, months, or even years after the previous one, and when you go back to modify code you wrote months/years ago, the code can almost look as if it was written by another person.</p><p>Because of this, even if you are the only developer on your team, and even if you know exactly how every last line in your code base works at the moment, it is important to document your code, if only for the benefit of your future self. Further, if you aren't the only developer on your team, documentation becomes all the more important, as it can also serve as a bridge between you and your coworkers.</p></div></div>
<div class="section" title="Documentation approaches" id="aid-2G3F81"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Documentation approaches</h1></div></div></div><p>There are three main<a id="id266" class="indexterm"/> approaches to documenting JavaScript code, none of which are a one-size-fits-all solution. You will need to determine which approach makes the most sense for you and your team on the basis of your team size and the ambitions of your project.</p><p>The three main approaches can be referred to as the non-documentation, simple documentation, and robust documentation approaches.</p><p>In general, the larger your team is, and the larger the organization to which this team belongs is, the more likely are you to want robust documentation, although size isn't the only factor to consider here. Other factors include your team members' desire for external documentation and whether or not any of your code is customer-facing (for instance, if you offer a public API for your customers to extend your application).</p></div>
<div class="section" title="The non-documentation approach" id="aid-2H1VQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec79"/>The non-documentation approach</h1></div></div></div><p>First, let me clarify that <a id="id267" class="indexterm"/>the non-documentation approach doesn't mean avoiding documentation entirely. Rather, it relies on using forms of documentation other than explicit code comments.</p><p>For instance, consider the following line of code:</p><div class="informalexample"><pre class="programlisting">var Book = Backbone.Model.extend();</pre></div><p>Now, if we had wanted to, we could have written a comment describing this line of code, as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * This defines a book model.
 */Book = Backbone.Model.extend();</pre></div><p>However, adding such a comment doesn't really tell us anything we don't already know, because our choice of variable name (<code class="literal">Book</code>) already tells us what the class is. Simply by choosing a descriptive variable name for our class, we have documented what it does, without the need of supplemental documentation.</p><p>However, the names of class variables aren't the only important names. Function names, and particularly, method names, can also be very helpful in explaining what the function/method does. Consider the following:</p><div class="informalexample"><pre class="programlisting">     bookNav: function() {
         router.navigate('bookPage', {silent: true, trigger: true});
    }
vs.:
     navigateSilentlyToBookPage: function() {
         router.navigate('bookPage', {silent: true, trigger: true});
    }</pre></div><p>Just by typing a few extra characters we've eliminated the need to read the method's definition in order to understand it. Further, while reading, the definition might not seem so hard in this particular example; however, if the function were longer or more complex, it might not be so easy.</p><p>One other way that functions<a id="id268" class="indexterm"/> can be used to convey documentation is by breaking them up into separate functions. For instance, let's say we had a <code class="literal">View</code> method that incremented a counter, saved a <code class="literal">Model</code>, updated and then rendered another <code class="literal">View</code> method, and finally changed the URL, as follows:</p><div class="informalexample"><pre class="programlisting">    example: function(router) {
        this.model.set('counter', this.model.get('counter') + 1);
        this.model.save();

        this.siblingView.model = this.model;
        this.siblingView.render();

        var url = this.url();
        router.navigate(url, {silent: true, trigger: false});
    }</pre></div><p>Naming such a method would be difficult: </p><p>
<code class="literal">"incrementCounterAndSaveModelAndUpdateAndRenderSiblingViewAndRefreshURL</code>" doesn't roll off the tongue very well. You could simplify it to <code class="literal">updateCounterAndRefresh</code>, but then you'd lose some of the non-documentation that the more verbose name would provide.</p><p>A better approach is to use the simpler name but separate the parts of the method into their own methods, as follows:</p><div class="informalexample"><pre class="programlisting">    incrementCounterAndSave: function() {
        this.model.set('counter', this.model.get('counter') + 1);
        this.model.save();
    },
    updateAndRenderSiblingView: function() {
        this.siblingView.model = this.model;
        this.siblingView.render();
    },
    refreshURL: function(router) {
        var url = this.url();
        router.navigate(url, {silent: true, trigger: false});
    },
    updateCounterAndRefresh: function(router) {
        this.incrementAndSaveCounter();
        this.updateAndRenderSiblingView();
        this.refreshURL(router);
    }</pre></div><p>As you can see the contents of our <code class="literal">updateCounterAndRefresh</code> method now read almost like an English documentation string, effectively documenting what's going on without any actual documentation. Furthermore, if we wanted to unit test this code (which we'll discuss in the following chapter), it will be far easier to do so with these separate methods than it would have been originally.</p><p>Moreover, the preceding code is a relatively simple example, while your actual methods may in fact be much longer than six lines. In real-world projects, it is even more important to utilize this technique of using many (well-named) methods rather than long monolithic methods, as it will greatly improve both the code's readability and ease of testing.</p><p>Class, function, and other <a id="id269" class="indexterm"/>variable names are not the only forms of non-documentation. File names and folder structure can also provide a great deal of information if used correctly. Consider a file named <code class="literal">Book.js</code>. On its own, we have no way of knowing whether this file contains a book <code class="literal">Model</code>, a book <code class="literal">View</code>, both, or something else entirely. However, if this file were renamed "<code class="literal">BookView.js</code>", it would be obvious. Similarly, if the file retained the name "<code class="literal">Book.js</code>" but was stored inside a "<code class="literal">views</code>" folder, the contents would again be apparent, without the requirement of any additional documentation.</p><div class="section" title="Benefits of non-documentation for other approaches"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec33"/>Benefits of non-documentation for other approaches</h2></div></div></div><p>Before we move on to the <a id="id270" class="indexterm"/>other two documentation approaches, it is worth noting that the strategies we just described aren't only useful if you choose the non-documentation approach. In fact, they are great advice for all programmers. No matter what documentation you generate to supplement your code, at the end of the day, you and your fellow developers are going to have to work with the code itself, not the documentation. By working to keep that code as readable and instructive as possible, you provide benefits that while not the same as those offered by explicit documentation, are none the less very valuable, particularly in the long run.</p></div></div>
<div class="section" title="The simple documentation approach" id="aid-2I0GC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/>The simple documentation approach</h1></div></div></div><p>Non-documentation is incredibly <a id="id271" class="indexterm"/>important to writing maintainable code, but it does have its limits. For instance, while you can use expressive variable names to describe many variables, you can't use them to describe parts of Backbone itself. For example, when a <code class="literal">View</code> takes a <code class="literal">model</code> option, the only way to rename it more expressively would be to create an entirely new property:</p><div class="informalexample"><pre class="programlisting">var BookView = Backbone.View.extend({
    initialize: function() {
        this.bookModel = this.model;
    }
});</pre></div><p>Now, there is nothing wrong with the above code, but in some sense, it crosses the line between <span class="emphasis"><em>code as documentation</em></span> and <span class="emphasis"><em>replacing documentation with code</em></span>. In cases like these, a more natural solution may instead be to simply use a comment, as follows:</p><div class="informalexample"><pre class="programlisting">// This View takes a ""Book"" ModelBookView = Backbone.View.extend();</pre></div><p>However, many programmers <a id="id272" class="indexterm"/>find that it's easy to miss such single-line comments, and therefore, they save them only for documenting specific lines of code. For class or method documentation, these developers rely on a specialized form of the multiline comment, which is marked with an extra leading asterisk and (optional) leading asterisks on each subsequent line:</p><div class="informalexample"><pre class="programlisting">/**
 * This View takes a ""Book"" Model
 */BookView = Backbone.View.extend();
When used this way throughout your code, these documentation sections form easy-to-read alternating blocks, making it trivial to skim through to what you're looking for without having to actually read the code in between:BookView = Backbone.View.extend({
    /**
     * This ""foo"" method does foo stuff
     */
    foo: function() {
        doSomeFooStuff();
    },
    /*
     * This ""bar"" method takes a ""Baz"" argument and does bar stuff
     */
    bar: function(baz) {
        doBarStuffWith(baz);
    }
});</pre></div><p>Most modern code editors will color such documentation differently from the rest of the code as well, making it even easier to skim through.</p><p>By using a combination of these multiline comments for your classes and methods, and using single-line comments to explain the tricky code inside of functions, you can very effectively document what class of <code class="literal">Model</code> a <code class="literal">View</code> has or which routes use a particular <code class="literal">View</code>. Further, while writing such comments does take more time than relying on non-documentation, the few extra<a id="id273" class="indexterm"/> seconds that they take you to write could save you hours or even days of work later on.</p></div>
<div class="section" title="The robust documentation approach" id="aid-2IV0U1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/>The robust documentation approach</h1></div></div></div><p>Either of the two preceding<a id="id274" class="indexterm"/> approaches are enough for most programmers to reap the benefits of documentation without having to spend too much time writing it. However, if you are looking for a more universal structure to your documentation, or if you and your team are not the documentation's only audience, then it might be beneficial to use an external tool such as JSDoc or Docco.</p><p>In larger organizations, it's not uncommon to have different teams working on different parts of the code. When one team needs to use a component or library that another team manages, the first team may not want to read the second team's code, or for that matter, they might not even have access to it themselves. Robust documentation can be useful in these cases by providing a way for teams to understand each other's code without having to read it directly.</p><p>Another important scenario is user customization. With the robust and powerful applications that Backbone enables, it often is only a matter of time before a customer requests a way to customize something or, if they can't write JavaScript themselves, have a consultant customize it for them. In these cases, the best solution is often to expose a subset of the code for the customer to work with, and this public customization API will require documentation so that the customer (or their contractor) can learn how to use it.</p><p>In either of these cases, a tool such as JSDoc or Docco can be used to generate separate documentation files that can be shared without sharing the code itself. However, at the same time, developers can still write their documentation along with their code; there's no need for them to maintain (for instance) a separate MS Word document.</p><p>Many teams also use the structure of JSDoc within their documentation, without ever actually using this tool to generate externally facing documentation. For these teams, the main benefit of JSDoc lies in its annotations, which let the teams write documentation in a similar manner and in a way that future team members are more likely to understand.</p><div class="section" title="JSDoc"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec34"/>JSDoc</h2></div></div></div><p>JSDoc (<a class="ulink" href="http://www.usejsdoc.org">http://www.usejsdoc.org</a>) is the<a id="id275" class="indexterm"/> oldest and most popular JavaScript documentation tool <a id="id276" class="indexterm"/>available. As far back as 1999, before the JSDoc tool even existed, developers used its syntax (borrowed from JavaDoc) to document the very early JavaScript code. The JSDoc tool itself, now in its third edition, is incorporated into several different other tools (including Google's Closure compiler), and support for its syntax can be found in almost every major code editor from Sublime to Eclipse to Visual Studio.</p><p>Using JSDoc, a developer can easily convert his inline documentation into external HTML files, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00167.jpeg" alt="JSDoc"/></div><p style="clear:both; height: 1em;"> </p><p>JSDoc works by relying on<a id="id277" class="indexterm"/> annotations included in documentation strings. For instance, consider the following code:</p><div class="informalexample"><pre class="programlisting">    /**
     * This ""bar"" method takes a ""Baz"" argument and does bar stuff
     */
    bar: function(baz) {
        doBarStuffWith(baz);
    }</pre></div><p>Instead of using the above code, a developer using JSDoc would use an <code class="literal">@param</code> annotation, as follows:</p><div class="informalexample"><pre class="programlisting">    /**
     * Does bar stuff
     * @param {Baz} baz this argument is used to do bar stuff
     */
    bar: function(baz) {
        doBarStuffWith(baz);
    }</pre></div><p>The <code class="literal">"@param</code> annotation tells JSDoc that the method takes a <span class="emphasis"><em>baz</em></span> argument and that it should be an instance of the "<code class="literal">Baz</code>" class. The full list of annotations can be found on the JSDoc website, and they are fairly straightforward, so we won't discuss all of them here. However, two of them (<code class="literal">@property</code> and <code class="literal">@param</code>) can be slightly problematic when used with the Backbone code, so let's examine how to use them properly.</p><p>Let's imagine that we want to document a Backbone <code class="literal">Model</code>. For doing so, we might write the following code:</p><div class="informalexample"><pre class="programlisting">/**
  * This model represents a book in our application.
  * @class
  */
var Book = Backbone.Model({ ...</pre></div><p>Now, let's assume that <a id="id278" class="indexterm"/>our <code class="literal">Book Model</code> can have three different attributes: title, description, and page length. Now, the problem is how do we document them? There is no <code class="literal">@attribute</code> annotation in JSDoc since <span class="emphasis"><em>attributes</em></span> are Backbone-specific and the <code class="literal">@param</code> annotation can seemingly only specify the argument of a single attribute; it can't (for example) tell us that two of the attributes should be strings and the others should be integers.</p><p>Luckily, one can use multiple <code class="literal">@param</code> or <code class="literal">@property</code> annotations to solve this problem (which one you use is up to you; because Backbone creates properties for both attributes and options, both are in fact parameters and properties). Consider the following:</p><div class="informalexample"><pre class="programlisting">/**
  * This model represents a book in our application.
  * @param {object} attributes
  * @param {string} attributes.title book's title
  * @param {string} attributes.description description of the book
  * @param {integer} attributes.pageLength number of pages
  */Book = Backbone.Model({ ...</pre></div><p>If you are using JSDoc informally (that is, you don't plan to generate external documentation), you can even simplify the above slightly by leaving out the initial <code class="literal">@param {object} </code>attribute annotation.</p></div><div class="section" title="Docco"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec35"/>Docco</h2></div></div></div><p>Docco(<a class="ulink" href="http://jashkenas.github.io/docco/">http://jashkenas.github.io/docco/</a>) is notable<a id="id279" class="indexterm"/> both because it takes a very different <a id="id280" class="indexterm"/>approach from JSDoc and because it was written by the creator of Backbone itself (Jeremy Ashkenas). Unlike JSDoc, which focuses on creating API documentation, Docco focuses on generating tutorials and/or explanations of how a given block of code works. Docco also differs from JSDoc in that it uses single-line comments, rather than multiline ones, to generate its documentation.</p><p>Here's an example of documentation generated using Docco; in fact, it was generated using Backbone's own source code (you can find the original version on the Backbone website):</p><div class="mediaobject"><img src="../Images/image00168.jpeg" alt="Docco"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see from the preceding example, Docco generates documentation with two columns. On the right is the original source code being documented, minus any comments, and on the left are the comments that correspond to this source code. For example, here are the original lines from Backbone that were used to generate the preceding example:</p><div class="informalexample"><pre class="programlisting">//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' &amp;&amp; define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;</pre></div><p>A key part of Docco's<a id="id281" class="indexterm"/> appeal is just how simple it is: There are no annotations or even multiline comments, just plain old <code class="literal">//</code> single-line comments. Docco is also valuable because of the type of documentation it generates: If you want to create a tutorial or walk through of your code Docco is a much better choice than JSDoc.</p><p>Ultimately which documentation system or systems you use will depend on your needs and future expectations. Even if you opt for simple documentation, it is important that you not underestimate the need to properly document your code. If you do, your future self (and possibly your coworkers) will regret it.</p><p>Of course, as with most things in programming, it is also possible to have too much documentation. When adding documentation, you should always remember that as you refactor and update your code, any documentation written for that code must similarly be updated. This certainly shouldn't stop you from adding documentation, given its many benefits, but before we move on to testing (which shares the same downside), we'd be remiss not to mention this ongoing maintenance cost.</p></div></div>
<div class="section" title="Summary" id="aid-2JTHG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Summary</h1></div></div></div><p>In this chapter, we learned how to document Backbone JavaScript code and what specific areas to focus on when doing so. We explored three different documentation options—non-documentation, simple documentation, and robust documentation—and considered two popular tools for generating robust documentation: JSDoc, and Docco.</p><p>In the next chapter, we'll look at how to test your Backbone code. In particular, we'll explore the popular test running frameworks QUnit and Mocha, as well as the Sinon library for creating spies, stubs, and mocks.</p></div></body></html>