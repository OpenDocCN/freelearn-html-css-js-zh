<html><head></head><body>
		<div><h1 id="_idParaDest-41" class="chapter-number"><a id="_idTextAnchor040"/>3</h1>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Working with Light Sources in Three.js</h1>
			<p>In <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you learned about the basics of Three.js, and in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">The Basic Components that Make up a Three.js Application</em>, we looked a bit deeper at the most important parts of the scene: the geometries, meshes, and cameras. You might have noticed that we skipped exploring the details of lights in that chapter, even though they make up an important part of every Three.js scene. Without lights, we won’t see anything rendered (unless we use basic or wireframe materials). Since Three.js contains several different light sources, each of which has a specific use, we’ll use this chapter to explain the various details of lights and prepare you for the upcoming chapters on material usage. By the end of this chapter, you’ll know the differences between the available lights and be able to choose and configure the correct light for your scene.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">WebGL itself doesn’t have inherent support for lighting. Without Three.js, you would have to write specific WebGL shader programs to simulate these kinds of lights, which is quite difficult. A good introduction to simulating lighting in WebGL<a id="_idIndexMarker176"/> from scratch can be found at <a href="https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL">https://developer.mozilla.org/en-US/docs/Web/WebGL/Lighting_in_WebGL</a>.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Different kinds of lighting in Three.js</li>
				<li>Working with basic lights</li>
				<li>Working with special lights</li>
			</ul>
			<p>As with all the chapters, we have a lot of examples that you can use to experiment with the behavior of lights. The examples shown in this chapter can be found in the <code>chapter-03</code> folder of the supplied sources.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>What lighting types are provided in Three.js?</h1>
			<p>Several different lights are available in Three.js that all have specific behavior and usages. In this chapter, we’ll discuss the following set of lights:</p>
			<ul>
				<li><code>THREE.AmbientLight</code>: This is a <a id="_idIndexMarker177"/>basic light, the color of which is added to the current color of the objects in the scene.</li>
				<li><code>THREE.PointLight</code>: This is <a id="_idIndexMarker178"/>a single point in space from which light spreads in all directions. This light can be used to create shadows.</li>
				<li><code>THREE.SpotLight</code>: This<a id="_idIndexMarker179"/> light source has a cone-like effect like that of a desk lamp, a spotlight in the ceiling, or a torch. This light can cast shadows.</li>
				<li><code>THREE.DirectionalLight</code>: This is <a id="_idIndexMarker180"/>also called infinite light. The light rays from this light can be seen as parallel, similar to the light from the Sun. This light can also be used to create shadows.</li>
				<li><code>THREE.HemisphereLight</code>: This <a id="_idIndexMarker181"/>is a special light and can be used to create more natural-looking outdoor lighting by simulating a reflective surface and a faintly illuminating sky. This light also doesn’t provide any shadow-related functionality.</li>
				<li><code>THREE.RectAreaLight</code>: With <a id="_idIndexMarker182"/>this light source, instead of a single point in space, you can specify an area from which light emanates. <code>THREE.RectAreaLight</code> doesn’t cast any shadows.</li>
				<li><code>THREE.LightProbe</code>: This is a special <a id="_idIndexMarker183"/>kind of light source where, based on the environment map used, a dynamic ambient light source is created to light the scene.</li>
				<li><code>THREE.LensFlare</code>: This is<a id="_idIndexMarker184"/> not a light source, but with <code>THREE.LensFlare</code>, you can add a lens flare effect to the lights in your scene.</li>
			</ul>
			<p>This chapter is divided into two main parts. First, we’ll look at the basic lights: <code>THREE.AmbientLight</code>, <code>THREE.PointLight</code>, <code>THREE.SpotLight</code>, and <code>THREE.DirectionalLight</code>. All these lights extend the base <code>THREE.Light</code> object, which provides shared functionality. The lights mentioned here are simple lights that require little setup and can be used to recreate most of the required lighting scenarios. In the second part, we will look at a couple of special-purpose lights and effects: <code>THREE.HemisphereLight</code>, <code>THREE.RectAreaLight</code>, <code>THREE.LightProbe</code>, and <code>THREE.LensFlare</code>. You’ll probably only need these lights in very specific cases.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Working with basic lights</h1>
			<p>We’ll start with the most basic of the lights: <code>THREE.AmbientLight</code>.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>THREE.AmbientLight</h2>
			<p>When you create a <code>THREE.AmbientLight</code>, the color is applied globally. There isn’t a specific direction <a id="_idIndexMarker185"/>this light comes from, and <code>THREE.AmbientLight</code> doesn’t <a id="_idIndexMarker186"/>contribute to any shadows. You would normally not use <code>THREE.AmbientLight</code> as the single source of light in a scene since it applies its color to all the objects in the scene in the same way, regardless of the shape of the mesh. You use it together with other lighting sources, such as <code>THREE.SpotLight</code> or <code>THREE.DirectionalLight</code>, to soften the shadows or add some additional color to the scene. The easiest way to understand this is by looking at the <code>ambient-light.html</code> example in the <code>chapter-03</code> folder. In this example, you get a simple user interface that can be used to modify the <code>THREE.AmbientLight</code> object that is available in this scene.</p>
			<p>In the following screenshots, you can see that we used a simple waterfall model, and made the <code>color</code> and <code>intensity</code> properties of the used <code>THREE.AmbientLight</code> object configurable. In this first screenshot, you can see what happens when we set the color of the light to red:</p>
			<div><div><img src="img/Figure_3.1_B18726.jpg" alt="Figure 3.1 – Ambient light set to red"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Ambient light set to red</p>
			<p>As you can see, each <a id="_idIndexMarker187"/>element in our scene now has a red color added to its<a id="_idIndexMarker188"/> original color. And if we change the color to blue, we’ll get something like this:</p>
			<div><div><img src="img/Figure_3.2_B18726.jpg" alt="Figure 3.2 – Ambient light set to blue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Ambient light set to blue</p>
			<p>As this screenshot<a id="_idIndexMarker189"/> shows, the blue color is applied to all the objects <a id="_idIndexMarker190"/>and casts a glow over the complete scene. What you should remember when working with this light is that you should be very conservative with the color you specify. If the color you specify is too bright, you’ll quickly get a completely oversaturated image. Besides the color, we can also set the <code>intensity</code> property of the light. This property determines how much <code>THREE.AmbientLight</code> affects the colors in the scene. If we turn it down, only a little of the color is applied to the objects in the scene. If we turn it up, our scene becomes really bright:</p>
			<div><div><img src="img/Figure_3.3_B18726.jpg" alt="Figure 3.3 – Ambient light set to red with high intensity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Ambient light set to red with high intensity</p>
			<p>Now that we’ve seen what it does, let’s look at how you can create and use a <code>THREE.AmbientLight</code>. The <a id="_idIndexMarker191"/>following lines of code show you how to create <a id="_idIndexMarker192"/>a <code>THREE.AmbientLight</code>:</p>
			<pre class="source-code">
const color = new THREE.Color(0xffffff);
const light = new THREE.AmbientLight(color);
scene.add(light);</pre>
			<p>Creating a <code>THREE.AmbientLight</code> is very simple and only takes a couple of steps. <code>THREE.AmbientLight</code> doesn’t have a position and is applied globally, so we only need to specify the color and add this light to the scene. Optionally, we can also provide an additional value in this constructor for the intensity of this light. Since we didn’t specify it here, it uses a default intensity of <code>1</code>.</p>
			<p>Note that in the previous code fragment, we passed in an explicit <code>THREE.Color</code> object to the constructor of <code>THREE.AmbientLight</code>. We could have also passed in the color as a string – for example, <code>"rgb(255, 0, 0)"</code> or <code>"hsl(0, 100%, 50%)"</code> – or as a number, as we did in the previous chapters: <code>0xff0000</code>. More information on this can be found in the <em class="italic">Using the THREE.Color </em><em class="italic">object</em> section.</p>
			<p>Before we discuss <code>THREE.PointLight</code>, <code>THREE.SpotLight</code>, and <code>THREE.DirectionalLight</code>, first, let’s highlight their main difference – that is, how they emit light. The following diagram shows how these three light sources emit light:</p>
			<div><div><img src="img/Figure_3.4_B18726.jpg" alt="Figure 3.4 – How different light sources emit light"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – How different light sources emit light</p>
			<p>You can see the following from this diagram:</p>
			<ul>
				<li><code>THREE.PointLight</code> emits light from a specific point in all directions</li>
				<li><code>THREE.SpotLight</code> emits light from a specific point in a cone-like shape</li>
				<li><code>THREE.DirectionalLight</code> doesn’t emit light from a single point but emits light rays from a 2D plane, where the<a id="_idIndexMarker193"/> rays are parallel to each <a id="_idIndexMarker194"/>other</li>
			</ul>
			<p>We’ll look at these light sources in more detail in the next few sections. Let’s start with <code>THREE.SpotLight</code>.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>THREE.SpotLight</h2>
			<p><code>THREE.SpotLight</code> is one of<a id="_idIndexMarker195"/> the lights you’ll use often (especially if you want to use shadows). <code>THREE.SpotLight</code> is a light source that has a cone-like effect. You can<a id="_idIndexMarker196"/> compare this with a flashlight or a lantern. This light source has a direction and an angle at which it produces light. The following screenshot shows what a <code>THREE.SpotLight</code> looks like (<code>spotlight.html</code>):</p>
			<div><div><img src="img/Figure_3.5_B18726.jpg" alt="Figure 3.5 – Spotlight lighting a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Spotlight lighting a scene</p>
			<p>The following table lists all the <a id="_idIndexMarker197"/>properties that you can use to finetune <code>THREE.SpotLight</code>. First, we’ll <a id="_idIndexMarker198"/>look at the properties specific to the light’s behavior:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Angle</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines how wide the beam emerging from the light is. The width is measured in radians and defaults to <code>Math.PI/3</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>castShadow</code></p>
						</td>
						<td class="No-Table-Style">
							<p>If set to <code>true</code>, the light to which the property is applied will create shadows. See the following table on how to configure the shadows.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Color</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the color of the light.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>decay</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the amount the light intensity diminishes the farther you move away from the light source. A <code>decay</code> of <code>2</code> leads to more realistic light, and the default value is <code>1</code>. This property is only effective when the <code>physicallyCorrectLights</code> property is set on <code>WebGLRenderer</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>distance</code></p>
						</td>
						<td class="No-Table-Style">
							<p>When this property is set to a non-<code>0</code> value, the light intensity will decrease linearly from the set intensity at the light’s position to <code>0</code> at the specified distance.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>intensity</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the intensity with which the light shines. The property’s default value is <code>1</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>penumbra</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the percentage at the edge of the spotlight’s coin, which is smoothed (blurred) to <code>0</code>. It takes a value between <code>0</code> and <code>1</code>, where the default is <code>0</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>power</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Denotes the light’s <code>power</code> when rendered in the physically correct mode (enable this by setting the <code>physicallyCorrectLights</code> property set on <code>WebGLRenderer</code>). This property is measured in lumens and the default value is <code>4*Math.PI</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>position</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the position of a light in <code>THREE.Scene</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>target</code></p>
						</td>
						<td class="No-Table-Style">
							<p>With <code>THREE.SpotLight</code>, the direction the light is pointed in is important. With the <code>target</code> property, you can point <code>THREE.SpotLight</code> to look at a specific object or position in the scene. Note that this property requires a <code>THREE.Object3D</code> object (such as a <code>THREE.Mesh</code>). This is in contrast to the cameras we saw in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, which use <code>THREE.Vector3</code> in their <code>lookAt</code> function.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>visible</code></p>
						</td>
						<td class="No-Table-Style">
							<p>If this property is set to <code>true</code> (the default), the light is turned on, while if it is set to <code>false</code>, the light is turned off.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Properties of the THREE.SpotLight object</p>
			<p>When you enable the<a id="_idIndexMarker199"/> shadow for <code>THREE.SpotLight</code>, you can control how that shadow is rendered. You can control this through the shadow property of a <code>THREE.SpotLight</code>, which can <a id="_idIndexMarker200"/>comprise the following:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.bias</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves the cast shadow away or toward the object casting the shadow. You can use this to solve some strange effects when you work with very thin objects. If you see strange shadow effects on your models, small values (for example, <code>0.01</code>) for this property can often resolve the issue. The default value for this property is <code>0</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.camera.far</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines from what distance from the light shadows should be created. The default value is <code>5000</code>. Note that you can also set all the other properties provided for <code>THREE.PerspectiveCamera</code>, which we showed in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.camera.fov</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines how large the field of view used to create shadows is (see the <em class="italic">Using different cameras for different scenes</em> section in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>). The default value is <code>50</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.camera.near</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines from what distance from the light shadows should be created. The default value is <code>50</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.mapSize.width</code> and</p>
							<p><code>shadow.mapSize.height</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determine how many pixels are used to create a shadow. Increase these when a shadow has jagged edges or doesn’t look smooth. This can’t be changed after the scene has been rendered. The default value for both is <code>512</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>shadow.radius</code></p>
						</td>
						<td class="No-Table-Style">
							<p>When this value is set higher than 1, the edge of the shadows will be blurred. This won’t have any effect if the <code>shadowMap.type</code> property of <code>THREE.WebGlRenderer</code> is set to <code>THREE.BasicShadowMap</code>.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Shadow properties of the THREE.SpotLight object</p>
			<p>Creating <code>THREE.SpotLight</code> is very <a id="_idIndexMarker201"/>easy. Just specify the color, set the properties<a id="_idIndexMarker202"/> you want, and add it to the scene, as follows:</p>
			<pre class="source-code">
const spotLight = new THREE.SpotLight("#ffffff")
spotLight.penumbra = 0.4;
spotLight.position.set(10, 14, 5);
spotLight.castShadow = true;
spotLight.intensity = 1;
spotLight.shadow.camera.near = 10;
spotLight.shadow.camera.far = 25;
spotLight.shadow.mapSize.width = 2048;
spotLight.shadow.mapSize.height = 2048;
spotLight.shadow.bias = -0.01;
scene.add(spotLight.target);</pre>
			<p>Here, we create an instance of <code>THREE.SpotLight</code> and set the various properties to configure the light. We also explicitly set the <code>castShadow</code> property to <code>true</code> because we want shadows. We also need to point <code>THREE.SpotLight</code> somewhere, which we do with the <code>target</code> property. Before we can use this property, we first need to add the default <code>target</code> of the light to the scene, as follows:</p>
			<pre class="source-code">
scene.add(spotLight.target);</pre>
			<p>By default, the target will be set to <code>(0, 0, 0)</code>. In the example for this section, you can change the location of the <code>target</code> property and see that the light follows the position of this object:</p>
			<div><div><img src="img/Figure_3.8_B18726.jpg" alt="Figure 3.8 – Spotlight pointing to a target"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Spotlight pointing to a target</p>
			<p>Note that you can also set the target of the light to an object in the scene. In that case, the direction of the light will be pointed to that object. If the object that the light is pointed at moves around, the light will keep pointing at that object.</p>
			<p>In the table at the <a id="_idIndexMarker203"/>beginning of<a id="_idIndexMarker204"/> this section, we showed a couple of properties that can be used to control how the light emanates from <code>THREE.SpotLight</code>. The <code>distance</code> and <code>angle</code> properties define the shape of the cone of light. The <code>angle</code> property defines the width of the cone, and with the <code>distance</code> property, we set the length of the cone. The following diagram explains how these two values define the area that will receive light from <code>THREE.SpotLight</code>:</p>
			<div><div><img src="img/Figure_3.9_B18726.jpg" alt="Figure 3.9 – Spotlight angle and distance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Spotlight angle and distance</p>
			<p>Usually, you won’t need<a id="_idIndexMarker205"/> to set these values since they come with reasonable defaults, but you can use these properties, for instance, to create a <code>THREE.SpotLight</code> instance <a id="_idIndexMarker206"/>that has a very narrow beam or quickly decreases in light intensity. The last property you can use to change the way <code>THREE.SpotLight</code> produces light is the <code>penumbra</code> property. With this property, you set from what position the intensity of the light decreases at the edge of the light cone. In the following screenshot, you can see the result of the <code>penumbra</code> property in action. We have a very bright light (high intensity) that rapidly decreases in intensity as it reaches the edge of the cone:</p>
			<div><div><img src="img/Figure_3.10_B18726.jpg" alt="Figure 3.10 – Spotlight with a hard penumbra"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Spotlight with a hard penumbra</p>
			<p>Sometimes, it can be<a id="_idIndexMarker207"/> difficult to determine the correct settings for your lights, just by looking at the rendered scene. You might want to finetune the area that is lit for performance reasons or try and move the light around to a very specific location. This can be achieved by using <code>THREE.SpotLightHelper</code>:</p>
			<pre class="source-code">
const spotLightHelper = new THREE.SpotLightHelper
  (spotLight);
scene.add(spotLightHelper)
// in the render loop
spotLightHelper.update();</pre>
			<p>With the preceding code, you get <a id="_idIndexMarker208"/>an outline that shows the details of the spotlight, and can help in debugging and correctly positioning and configuring your light:</p>
			<div><div><img src="img/Figure_3.11_B18726.jpg" alt="Figure 3.11– Spotlight with the helper enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11– Spotlight with the helper enabled</p>
			<p>Before moving on to <a id="_idIndexMarker209"/>the next light source, we’ll quickly look at the shadow-related properties available for a <code>THREE.SpotLight</code> object. You’ve already learned that we can get shadows by setting the <code>castShadow</code> property of a <code>THREE.SpotLight</code> instance to <code>true</code>. You also know that a <code>THREE.Mesh</code> object has two <a id="_idIndexMarker210"/>shadow-related properties. You set the <code>castShadow</code> property for objects that should cast shadows, and you use the <code>receiveShadow</code> property for objects that should show a shadow. Three.js also allows you very fine-grained control over how the shadow is rendered. This is done by a couple of the properties we explained in the table at the beginning of this section. With <code>shadow.camera.near</code>, <code>shadow.camera.far</code>, and <code>shadow.camera.fov</code>, you can control how and where this light casts a shadow. For a <code>THREE.SpotLight</code> instance, you can’t set <code>shadow.camera.fov</code> directly. This property is based on the <code>angle</code> property of <code>THREE.SpotLight</code>. This works in the same way as the perspective camera’s field of view, which we explained in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>. The easiest way to see this in action is by adding a <code>THREE.CameraHelper</code>; you can do this by checking the menu’s <code>shadow-helper</code> checkbox and playing around with the camera settings. As you can see in the following screenshot, selecting this checkbox shows the area that is used to determine the shadows for this light:</p>
			<div><div><img src="img/Figure_3.12_B18726.jpg" alt="Figure 3.12 – Spotlight with the shadow helper enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Spotlight with the shadow helper enabled</p>
			<p>When debugging issues<a id="_idIndexMarker211"/> with shadows, adding <code>THREE.CameraHelper</code> is useful. To<a id="_idIndexMarker212"/> do this, just add the following lines:</p>
			<pre class="source-code">
const shadowCameraHelper = new THREE.CameraHelper
  (spotLight.shadow.camera);
scene.add(shadowCameraHelper);
// in the render loop
shadowCameraHelper.update();</pre>
			<p>I’ll end this section with a couple of pointers, just in case you run into issues with shadows.</p>
			<p>If the shadow looks blocky, you can increase the <code>shadow.mapSize.width</code> and <code>shadow.mapSize.Height</code> properties and make sure the area that is used to calculate the shadow tightly wraps your object. You can use the <code>shadow.camera.near</code>, <code>shadow.camera.far</code>, and <code>shadow.camera.fov</code> properties to configure this area.</p>
			<p>Remember that you not only have to tell the light to cast shadows but also have to tell each geometry whether it will receive and/or cast shadows by setting the <code>castShadow</code> and <code>receiveShadow</code> properties.</p>
			<p class="callout-heading">Shadow bias</p>
			<p class="callout">If you use thin objects in your scene, you might see strange artifacts when you render shadows. You can use the <code>shadow.bias</code> property to slightly offset the shadows, which will often fix these issues.</p>
			<p>If you want to have softer shadows, you can set a different <code>shadowMapType</code> value on <code>THREE.WebGLRenderer</code>. By default, this property is set to <code>THREE.PCFShadowMap</code>; if you set this<a id="_idIndexMarker213"/> property to <code>PCFSoftShadowMap</code>, you’ll get softer<a id="_idIndexMarker214"/> shadows.</p>
			<p>Now, let’s look at the next light source in the list: <code>THREE.PointLight</code>.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>THREE.PointLight</h2>
			<p><code>THREE.PointLight</code> is a light<a id="_idIndexMarker215"/> source that shines light in all directions emanating from<a id="_idIndexMarker216"/> a single point. A good example of a point light is a signal flare fired into the night sky or a campfire. Just as with all the lights, we have a specific example you can use to play around with <code>THREE.PointLight</code>. If you look at <code>point-light.html</code> in the <code>chapter-03</code> folder, you can find an example where a <code>THREE.PointLight</code> is being used in the same scene we’re also using for the other lights:</p>
			<div><div><img src="img/Figure_3.13_B18726.jpg" alt="Figure 3.13 – PointLight with the helper enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – PointLight with the helper enabled</p>
			<p>As you can see<a id="_idIndexMarker217"/> from the previous screenshot, this light emits to all sides. Just like the<a id="_idIndexMarker218"/> spotlight we saw earlier, this light also has a helper, which you can use in the same way. You can see this as the wireframe in the center of the scene:</p>
			<pre class="source-code">
const pointLightHelper = new THREE.PointLightHelper
  (pointLight);
scene.add(pointLightHelper)
// in the render loop
pointLightHelper.update();</pre>
			<p><code>THREE.PointLight</code> shares <a id="_idIndexMarker219"/>several properties with <code>THREE.SpotLight</code>, which you <a id="_idIndexMarker220"/>can use to configure how this light behaves:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>color</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The color of the light that this light source emits.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>distance</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the distance for which the light shines. The default value is <code>0</code>, which means that the light’s intensity doesn’t decrease based on distance.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>intensity</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the intensity the light shines with. This defaults to <code>1</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>position</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the position of the light in <code>THREE.Scene</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>visible</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether the light is turned off or on. If this property is set to <code>true</code> (the default), this light is turned on, and if set it to <code>false</code>, the light is turned off.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>decay</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the amount the light intensity diminishes the farther you move away from the light source. A <code>decay</code> of <code>2</code> leads to more realistic light, and the default value is <code>1</code>. This property is effective only when the <code>physicallyCorrectLights</code> property is set on <code>WebGLRenderer</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>power</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Refers to the light’s power when being rendered in the physically correct mode (enable this by setting the <code>physicallyCorrectLights</code> property set on <code>WebGLRenderer</code>). This property is measured in lumens and the default value is <code>4*Math.PI</code>. <code>Power</code> is also directly related to the <code>intensity</code> property (<em class="italic">power = intensity * </em><em class="italic">4π</em>).</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Properties of the THREE.PointLight object</p>
			<p>Besides these properties, the <code>THREE.PointLight</code> object’s shadow can be configured in the same way as the shadow for <code>THREE.SpotLight</code>. In the next couple of examples and screenshots, we’ll show how these properties work for <code>THREE.PointLight</code>. First, let’s look at how <a id="_idIndexMarker221"/>you can create a <code>THREE.PointLight</code>:</p>
			<pre class="source-code">
const pointLight = new THREE.PointLight();
scene.add(pointLight);</pre>
			<p>There’s nothing <a id="_idIndexMarker222"/>special here – we just define the light and add it to the scene; you can, of course, set any of the properties we just showed as well. The two main properties of the <code>THREE.SpotLight</code> object are <code>distance</code> and <code>intensity</code>. With <code>distance</code>, you can specify how far the light is emitted before it decays to <code>0</code>. For example, in the following screenshot, we set the <code>distance</code> property to a low value, and increased the <code>intensity</code> property a bit to simulate a campfire between the trees:</p>
			<div><div><img src="img/Figure_3.15_B18726.jpg" alt="Figure 3.15 – PointLight with low distance and higher intensity"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – PointLight with low distance and higher intensity</p>
			<p>You can’t set<a id="_idIndexMarker223"/> the <code>power</code> and decay properties in this example; these properties are <a id="_idIndexMarker224"/>really useful if you want to simulate real-world scenarios. A good example of this can be found on the Three.js website: <a href="https://threejs.org/examples/#webgl_lights_physical">https://threejs.org/examples/#webgl_lights_physical</a>.</p>
			<p><code>THREE.PointLight</code> also uses a camera to determine where to draw the shadows, so you can use <code>THREE.CameraHelper</code> to show what part is covered by that camera. In addition, <code>THREE.PointLight</code> provides a helper, <code>THREE.PointLightHelper</code>, to show where <code>THREE.PointLight</code> shines its light. With both enabled, you get the following very useful debug information:</p>
			<div><div><img src="img/Figure_3.16_B18726.jpg" alt="Figure 3.16 – PointLight with helpers enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – PointLight with helpers enabled</p>
			<p>If you look <a id="_idIndexMarker225"/>closely at the previous screenshot (<em class="italic">Figure 3</em><em class="italic">.16</em>), you might notice <a id="_idIndexMarker226"/>that shadows are created outside the area the shadow camera is showing. This is because the shadow helper only shows the shadows being cast down from the position of the point light. You can visualize a <code>THREE.PointLight</code> as a cube, where each side emits light and can cast shadows. In this case, <code>THREE.ShadowCameraHelper</code> only shows the shadows being cast down.</p>
			<p>The last of the basic lights that we’ll be discussing is <code>THREE.DirectionalLight</code>.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>THREE.DirectionalLight</h2>
			<p>This type of light source can be <a id="_idIndexMarker227"/>considered as a light that is very far away. All the<a id="_idIndexMarker228"/> light rays it sends out are parallel to each other. A good example of this is the Sun. The Sun is so far away that the light rays we receive on Earth are (almost) parallel to each other. The main difference between <code>THREE.DirectionalLight</code> and <code>THREE.SpotLight</code> (which we saw previously) is that this light won’t diminish the farther it gets from the source as it does with <code>THREE.SpotLight</code> (you can fine-tune this with the <code>distance</code> and <code>exponent</code> parameters). The complete area that is lit by <code>THREE.DirectionalLight</code> receives the same intensity of light. To see <a id="_idIndexMarker229"/>this in action, look at the following <code>directional-light.html</code> example:</p>
			<div><div><img src="img/Figure_3.17_B18726.jpg" alt="Figure 3.17 – Directional light simulating a sunset"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Directional light simulating a sunset</p>
			<p>As you can see, it is very easy to simulate, for instance, a sunset, using a <code>THREE.DirectionalLight</code>. Just as with <code>THREE.SpotLight</code>, there are a couple of properties you can set on this light. For example, you can set the <code>intensity</code> property of the light and the way it casts shadows. <code>THREE.DirectionalLight</code> has a lot of properties that are the same as those of <code>THREE.SpotLight</code>: <code>position</code>, <code>target</code>, <code>intensity</code>, <code>castShadow</code>, <code>shadow.camera.near</code>, <code>shadow.camera.far</code>, <code>shadow.mapSize.width</code>, <code>shadow.mapSize.width</code>, and <code>shadowBias</code>. For more information on those properties, you can look at the preceding section on <code>THREE.SpotLight</code>.</p>
			<p>If you look back at<a id="_idIndexMarker230"/> the <code>THREE.SpotLight</code> examples, you will see that we had to define the cone of light where shadows were applied. Since all the rays are parallel to each other for <code>THREE.DirectionalLight</code>, we don’t have a cone where shadows need to be applied; instead, we <a id="_idIndexMarker231"/>have a cuboid area (represented internally with a <code>THREE.OrthographicCamera</code>), as you can see in the following screenshot, where we enabled the shadow helper:</p>
			<div><div><img src="img/Figure_3.18_B18726.jpg" alt="Figure 3.18 – Directional light showing a cuboid shadow area"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Directional light showing a cuboid shadow area</p>
			<p>Everything that falls within this<a id="_idIndexMarker232"/> cube can cast and receive shadows from the light. Just as for <code>THREE.SpotLight</code>, the tighter you define this area around the objects, the<a id="_idIndexMarker233"/> better your shadows will look. Define this cube using the following properties:</p>
			<pre class="source-code">
directionalLight.castShadow = true;
directionalLight.shadow.camera.near = 2;
directionalLight.shadow.camera.far = 80;
directionalLight.shadow.camera.left = -30;
directionalLight.shadow.camera.right = 30;
directionalLight.shadow.camera.top = 30;
directionalLight.shadow.camera.bottom = -30;</pre>
			<p>You can <a id="_idIndexMarker234"/>compare this with the<a id="_idIndexMarker235"/> way we configured the orthographic camera in the <em class="italic">Using different cameras for different scenes</em> section in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>.</p>
			<p>As we’ve already seen in this section, light sources use colors. For now, we’ve just configured the colors using a hex string, but the <code>THREE.Color</code> object provides a lot of different options for creating the initial color object. In this next section, we’ll explore the functionality provided by the <code>THREE.Color</code> object.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Using the THREE.Color object</h2>
			<p>In Three.js, when you need to <a id="_idIndexMarker236"/>provide a color (for example, for materials, lights, and so on), you can pass in a <code>THREE.Color</code> object; otherwise, Three.js will create one<a id="_idIndexMarker237"/> from a passed-in string value, as we saw for <code>THREE.AmbientLight</code>. Three.js is very flexible when parsing the input for the <code>THREE.Color</code> constructor. You can create a <code>THREE.Color</code> object in the following ways:</p>
			<ul>
				<li><code>new THREE.Color("#ababab")</code> will create a color based on the passed-in CSS color string.</li>
				<li><code>new THREE.Color(0xababab)</code> will create the color based on the passed-in hex value. If you know the hex value, this is usually the best approach.</li>
				<li><code>new THREE.Color("rgb(255, 0, 0)")</code> or <code>new THREE.Color("rgb(100%, </code><code>0%, 0%)"</code>.</li>
				<li><code>new THREE.Color( '</code><code>skyblue' )</code>.</li>
				<li><code>new THREE.Color("hsl(0, </code><code>100%, 50%)")</code>.</li>
				<li><code>new THREE.Color( 1, 0, </code><code>0 )</code>.</li>
			</ul>
			<p>If you want to change the <a id="_idIndexMarker238"/>color after construction, you’ll have to create a new <code>THREE.Color</code> object or modify the internal properties of the <code>THREE.Color</code> object. The <code>THREE.Color</code> object comes with a large set of properties and functions. The first<a id="_idIndexMarker239"/> group of functions allows you to set the color of a <code>THREE.Color</code> object:</p>
			<ul>
				<li><code>set(value)</code>: Sets the value of a color to the supplied hex value. This hex value may be a string, a number, or an existing <code>THREE.Color</code> instance.</li>
				<li><code>setHex(value)</code>: Sets the value of a color to the supplied numeric hex value.</li>
				<li><code>setRGB(r,g,b)</code>: Sets the value of a color based on the supplied RGB values. The values range from <code>0</code> to <code>1</code>.</li>
				<li><code>setHSL(h,s,l)</code>: Sets the value of this color on the supplied HSL values. The values range from 0 to 1. A good explanation of how HSL works for configuring colors can be found at <a href="http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL">http://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL</a>.</li>
				<li><code>setStyle(style)</code>: Sets the value of a color based on the CSS way of specifying colors. For instance, you could use <code>rgb(255,0,0)</code>, <code>#ff0000</code>, <code>#f00</code>, or even <code>red</code>.</li>
			</ul>
			<p>If you’ve already <a id="_idIndexMarker240"/>got an existing <code>THREE.Color</code> instance and want to use that <a id="_idIndexMarker241"/>color, you can use the following functions:</p>
			<ul>
				<li><code>copy(color)</code>: Copies the color values from the <code>THREE.Color</code> instance provided to this color.</li>
				<li><code>copySRGBToLinear(color)</code>: Sets the color of this object based on the <code>THREE.Color</code> instance supplied. The color is first converted from the sRGB color space into the linear color space. The sRGB color space uses an exponential scale instead of a linear one. More information on the sRGB color space can be found here: <a href="https://www.w3.org/Graphics/Color/sRGB.html">https://www.w3.org/Graphics/Color/sRGB.html</a>.</li>
				<li><code>copyLinearToSRGB(color)</code>: Sets the color of this object based on the <code>THREE.Color</code> instance supplied. The color is first converted from the linear color space into the sRGB color space.</li>
				<li><code>convertSGRBToLinear()</code>: Converts the current color from the sRGB color space into the linear color space.</li>
				<li><code>convertLinearToSGRB()</code>: Converts the current color from the linear color space into the sRGB color space.</li>
			</ul>
			<p>If you want information on the currently configured color, the <code>THREE.Color</code> object also provides some helper functions for that:</p>
			<ul>
				<li><code>getHex()</code>: Returns the value from this color object as a number: <code>435241</code>.</li>
				<li><code>getHexString()</code>: Returns the value from this color object as a hex string: <code>0c0c0c</code>.</li>
				<li><code>getStyle()</code>: Returns the value from this color object as a CSS-based value: <code>rgb(112,0,0)</code>.</li>
				<li><code>getHSL(target)</code>: Returns the value from this color object as an HSL value (<code>{ h: 0, s: 0, l: 0 }</code>). If you provide the optional <code>target</code> object, Three.js will set the <code>h</code>, <code>s</code>, and <code>l</code> properties on that object.</li>
			</ul>
			<p>Three.js also<a id="_idIndexMarker242"/> provides functions to change the current color by modifying the <a id="_idIndexMarker243"/>individual color components. This is shown here:</p>
			<ul>
				<li><code>offsetHSL(h, s, l)</code>: Adds the <code>h</code>, <code>s</code>, and <code>l</code> values provided to the <code>h</code>, <code>s</code>, and <code>l</code> values of the current color.</li>
				<li><code>add(color)</code>: Adds the <code>r</code>, <code>g</code>, and <code>b</code> values of the color supplied to the current color.</li>
				<li><code>addColors(color1, color2)</code>: Adds <code>color1</code> and <code>color2</code> and sets the value of the current color to the result.</li>
				<li><code>addScalar(s)</code>: Adds a value to the RGB components of the current color. Bear in mind that the internal values use a range from <code>0</code> to <code>1</code>.</li>
				<li><code>multiply(color)</code>: Multiplies the current RGB values with the RGB values from <code>THREE.Color</code>.</li>
				<li><code>multiplyScalar(s)</code>: Multiplies the current RGB values with the value supplied. Remember that the internal values range between <code>0</code> to <code>1</code>.</li>
				<li><code>lerp(color, alpha)</code>: Finds the color that is between the color of this object and the <code>color</code> property supplied. The <code>alpha</code> property defines how far between the current color and the supplied color you want the result to be.</li>
			</ul>
			<p>Finally, there are a couple of basic helper methods available:</p>
			<ul>
				<li><code>equals(color)</code>: Returns <code>true</code> if the RGB values of the <code>THREE.Color</code> instance supplied match the values of the current color</li>
				<li><code>fromArray(array)</code>: Has the same functionality as <code>setRGB</code>, but now, the RGB values can be provided as an array of numbers</li>
				<li><code>toArray</code>: Returns an array with three elements: <code>[r, </code><code>g, b]</code></li>
				<li><code>clone</code>: Creates an exact copy of a color</li>
			</ul>
			<p>In the preceding lists, you can see that there are many ways in which you can change the current color. A lot of these functions are used internally by Three.js, but they also provide a good way to<a id="_idIndexMarker244"/> easily change the color of lights and materials, without <a id="_idIndexMarker245"/>having to create and assign new <code>THREE.Color</code> objects.</p>
			<p>So far, we’ve looked at the basic lights provided by Three.js and how shadows work. In most cases, you’ll use a combination of these lights for your scene. Three.js also provides a couple of special lights for very specific use cases. We’ll look at those in the next section.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Working with special lights</h1>
			<p>In this section on special<a id="_idIndexMarker246"/> lights, we’ll discuss three additional lights provided by Three.js. First, we’ll discuss <code>THREE.HemisphereLight</code>, which helps in creating more natural lighting for outdoor scenes. Then, we’ll look at <code>THREE.RectAreaLight</code>, which emits lights from a large area instead of a single point. Next, we’ll look at how we can use a <code>LightProbe</code> to apply light based on a cubemap, and finally, we’ll show you how you can add a lens flare effect to your scene.</p>
			<p>The first special light we’re going to look at is <code>THREE.HemisphereLight</code>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>THREE.HemisphereLight</h2>
			<p>With <code>THREE.HemisphereLight</code>, we<a id="_idIndexMarker247"/> can create more natural-looking<a id="_idIndexMarker248"/> outdoor lighting. Without this light, we could simulate the outdoors by creating <code>THREE.DirectionalLight</code>, which emulates the sun, and maybe add another <code>THREE.AmbientLight</code> to provide some general color to the scene. However, doing so won’t look natural. When you’re outdoors, not all the light comes directly from above: much is diffused by the atmosphere and reflected by the ground and other objects. <code>THREE.HemisphereLight</code> in Three.js was created for this scenario. This is an easy way to get more natural-looking outdoor lighting. To see an example, look at <code>hemisphere-light.html</code> in the following figure:</p>
			<div><div><img src="img/Figure_3.19_B18726.jpg" alt="Figure 3.19 – Hemisphere light"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – Hemisphere light</p>
			<p>If you look closely at this screenshot, you will see that the ground color of the hemisphere is shown more at the bottom of the sphere, and the sky color (set through the <code>color</code> property) is visible at the top of the scene. In this example, you can set these colors and their intensity. Creating <a id="_idIndexMarker249"/>a hemisphere light is just as <a id="_idIndexMarker250"/>easy as creating any of the other lights:</p>
			<pre class="source-code">
const hemiLight = new THREE.HemisphereLight(0x0000ff,
  0x00ff00, 0.6); hemiLight.position.set(0, 500, 0);
scene.add(hemiLight);</pre>
			<p>You just specify the color that is received from the sky, the color received from the ground, and the intensity of these lights. If you want to change these values later on, you can access them through the following properties:</p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>groundColor</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the color that is emitted from the ground</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>color</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Implies the color that is emitted from the sky</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>intensity</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Implies the intensity with which the light shines</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – Properties of the THREE.HemisphereLight object</p>
			<p>Since a <code>HemisphereLight</code> acts like a <code>THREE.AmbientLight</code> object and just adds color to all the<a id="_idIndexMarker251"/> objects in the scene, it isn’t capable of casting shadows. The<a id="_idIndexMarker252"/> lights we’ve seen so far are more traditional. The next property allows you to simulate light from rectangular light sources – for instance, a window or a computer screen.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>THREE.RectAreaLight</h2>
			<p>With <code>THREE.RectAreaLight</code>, we can<a id="_idIndexMarker253"/> define a rectangular area that emits <a id="_idIndexMarker254"/>light. Before we look at the details, let’s first look at the result we’re aiming for (<code>rectarea-light.html</code> opens this example); the following screenshot shows a couple of <code>THREE.RectAreaLight</code> objects:</p>
			<div><div><img src="img/Figure_3.21_B18726.jpg" alt="Figure 3.21 – RectArea lights emitting across their complete surface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – RectArea lights emitting across their complete surface</p>
			<p>What you see in <a id="_idIndexMarker255"/>this screenshot is that we’ve defined three <code>THREE.RectAreaLight</code> objects, each with its own color. You can see how these lights affect the <a id="_idIndexMarker256"/>whole area, and when you move them around or change their position, you can see how the different objects in the scene are affected.</p>
			<p>We haven’t explored the different materials and how light affects them. We’ll do this in the next chapter, <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with Three.js Materials</em>. A <code>THREE.RectAreaLight</code> only works with <code>THREE.MeshStandardMaterial</code> or <code>THREE.MeshPhysicalMaterial</code>. More on these materials will be presented in <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>.</p>
			<p>To work with a <code>THREE.RectAreaLight</code>, we need to take a couple of small additional steps. First, we need to load and initialize <code>RectAreaLightUniformsLib</code>; the following is a set of additional low-level WebGL scripts needed by this light:</p>
			<pre class="source-code">
import { RectAreaLightUniformsLib } from "three/examples
  /jsm/lights/RectAreaLightUniformsLib.js";
...
RectAreaLightUniformsLib.init();</pre>
			<p>Next, we can create the <code>THREE.AreaLight</code> object just like any other light:</p>
			<pre class="source-code">
const rectLight1 = new THREE.RectAreaLight
  (0xff0000, 5, 2, 5);
rectLight1.position.set(-3, 0, 5);
scene.add(rectLight1);</pre>
			<p>If you look at the constructor of this object, you will see that it takes four properties. The first one is the color of the light, the second one is the intensity, and the last two define how large the area of this light is. Note that if you want to visualize these lights, as we did in the example, you have to create a rectangle yourself at the same position, rotation, and size as your <code>THREE.RectAreaLight</code>.</p>
			<p>This light can be used to create some nice effects, but it’ll probably take some experimenting to get the effect you want. Once again, in this example, you’ve got a menu on the right-hand side that you can use to play around with the various settings.</p>
			<p>In recent <a id="_idIndexMarker257"/>versions of Three.js, a new light was added called <code>THREE.LightProbe</code>. This light is similar to <code>THREE.AmbientLight</code> but takes the <a id="_idIndexMarker258"/>cubemap of <code>WebGLRenderer</code> into account. This is the last light source that we’ll discuss in this chapter.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>THREE.LightProbe</h2>
			<p>In the previous chapter, we<a id="_idIndexMarker259"/> talked a little bit about what a cubemap is. With a<a id="_idIndexMarker260"/> cubemap, you can show your models inside an environment. In the previous chapter, we used a cubemap to create a background that rotates with the view of the camera:</p>
			<div><div><img src="img/Figure_3.22_B18726.jpg" alt="Figure 3.22 – Cubemap example from Chapter 2"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – Cubemap example from <a href="B18726_02.xhtml#_idTextAnchor028">Chapter 2</a></p>
			<p>As we’ll see in the next chapter, we can use the information from a cubemap to show reflections on our materials. Normally, though, these environment maps don’t contribute any light to your scene. With a <code>THREE.LightProbe</code>, however, we can extract lighting level <a id="_idIndexMarker261"/>information from the cubemap and use it to illuminate<a id="_idIndexMarker262"/> our models. So, what you’ll get looks a bit like a <code>THREE.AmbientLight</code>, but it affects the objects based on their location in the scene and the information from the cubemap.</p>
			<p>The easiest way to explain this is by looking at an example. Open up <code>light-probe.html</code> in your browser; you’ll see the following scene:</p>
			<div><div><img src="img/Figure_3.23_B18726.jpg" alt="Figure 3.23 – LightProbe with a model in a cave"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – LightProbe with a model in a cave</p>
			<p>In the preceding example, we’ve<a id="_idIndexMarker263"/> got a model inside a cave-like environment. What you<a id="_idIndexMarker264"/> can see, if you rotate the camera around, is that based on the light of the environment, our model is slightly differently lit. In the previous screenshot, we’re looking at the back of the object, which is further down in the cave, so the model is darker on that side. If we completely rotate the camera and set the entrance of the cave to our back, we’ll see that the model is much brighter and receives more light:</p>
			<div><div><img src="img/Figure_3.24_B18726.jpg" alt="Figure 3.24 – LightProbe with a model in a cave receiving more light"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – LightProbe with a model in a cave receiving more light</p>
			<p>This is a really neat trick<a id="_idIndexMarker265"/> to make your objects look more life-like and less flat, and <a id="_idIndexMarker266"/>with a <code>THREE.LightProbe</code>, your model will receive light non-uniformly, which looks much better.</p>
			<p>Setting up a <code>THREE.LightProbe</code> is a bit more work but only needs to be done once when you create your scene. So long as you don’t change the environment, you don’t need to recalculate the values of the <code>THREE.LightProbe</code> object:</p>
			<pre class="source-code">
Import { LightProbeGenerator } from "three/examples/
  jsm/lights//LightProbeGenerator";
...
const loadCubeMap = (renderer, scene) =&gt; {
  const base = "drachenfels";
  const ext = "png";
  const urls = [
    "/assets/panorama/" + base + "/posx." + ext,
    "/assets/panorama/" + base + "/negx." + ext,
    "/assets/panorama/" + base + "/posy." + ext,
    "/assets/panorama/" + base + "/negy." + ext,
    "/assets/panorama/" + base + "/posz." + ext,
    "/assets/panorama/" + base + "/negz." + ext,
  ];
  new THREE.CubeTextureLoader().load(urls, function
    (cubeTexture) {
    cubeTexture.encoding = THREE.sRGBEncoding;
    scene.background = cubeTexture;
    const lp = LightProbeGenerator.fromCubeTexture
      (cubeTexture);
    lp.intensity = 15;
    scene.add(lp);
  });
};</pre>
			<p>In the preceding <a id="_idIndexMarker267"/>code fragment, we do two main things. First, we use <code>THREE.CubeTextureLoader</code> to load in a cubemap. As we’ll see in the next chapter, a<a id="_idIndexMarker268"/> cubemap consists of six images representing the six sides of a cube, which together will make up our environment. Once that has been loaded, we set this to the background of our scene (note that this isn’t needed for <code>THREE.LightProbe</code> to work).</p>
			<p>Now that we’ve got this cubemap, we can generate a <code>THREE.LightProbe</code> from it. This is done by passing in <code>cubeTexture</code> to a <code>LightProbeGenerator</code>. The result is a <code>THREE.LightProbe</code>, which we add to our scene, just like any other light. Just like with a <code>THREE.AmbientLight</code>, you can control how much this light contributes to the lighting of your meshes by setting the <code>intensity</code> property.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is also another kind of <code>LightProbe</code> provided by Three.js: <code>THREE.HemisphereLightProbe</code>. This one works pretty much the same as a normal <code>THREE.HemisphereLight</code>, but uses a <code>LightProbe</code> internally.</p>
			<p>The final object in<a id="_idIndexMarker269"/> this chapter isn’t a light source but plays a trick on the camera<a id="_idIndexMarker270"/> often seen in movies: <code>THREE.LensFlare</code>.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>THREE.LensFlare</h2>
			<p>You are probably already <a id="_idIndexMarker271"/>familiar with lens flares. For instance, they appear when you take a <a id="_idIndexMarker272"/>direct photograph of the Sun or another bright light source. In most cases, you want to avoid this, but for games and 3D-generated images, it provides a nice effect that makes scenes look a bit more realistic. Three.js also has support for lens flares and makes it very easy to add them to your scene. In this last section, we’re going to add a lens flare to a scene and create the output shown in the following screenshot; you can see this for yourself by opening <code>lens-flare.html</code>:</p>
			<div><div><img src="img/Figure_3.25_B18726.jpg" alt="Figure 3.25 – A lens flare appears when you look into the light"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25 – A lens flare appears when you look into the light</p>
			<p>We can create a lens <a id="_idIndexMarker273"/>flare by instantiating the <code>LensFlare</code> object and by<a id="_idIndexMarker274"/> adding <code>LensFlareElement</code> objects:</p>
			<pre class="source-code">
import {
  Lensflare,
  LensflareElement,
} from "three/examples/jsm/objects/Lensflare";
const textureLoader = new THREE.TextureLoader()
const textureFlare0 = textureLoader.load
  ('/assets/textures/lens-flares/lensflare0.png')
const textureFlare1 = textureLoader.load
  ('/assets/textures/lens-flares/lensflare3.png')
const lensFlare = new LensFlare();
lensFlare.addElement(new LensflareElement
  (textureFlare0, 512, 0));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 60, 0.6));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 70, 0.7));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 120, 0.9));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 70, 1.0));
pointLight.add(lensFlare);</pre>
			<p>The <code>LensFlare</code> element is<a id="_idIndexMarker275"/> just a container for our <code>LensFlareElement</code> objects, and <code>LensFlareElement</code> is the artifact you see when you look at the light source. Then, we add <code>LensFlare</code> to the light source, and we’re done. If you look at the <a id="_idIndexMarker276"/>code, you will see that we pass in several properties for each <code>LensFlareElement</code>. These properties determine what <code>LensFlareElement</code> looks like and where it is rendered on screen. To use this element, we can apply the following constructor arguments:</p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Property</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>texture</code></p>
						</td>
						<td class="No-Table-Style">
							<p>A texture is an image that determines the shape of the flare.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>size</code></p>
						</td>
						<td class="No-Table-Style">
							<p>We can specify how large the flare should be. <code>size</code> denotes the size in pixels. If you specify <code>-1</code>, the size of the texture itself is used.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>distance</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates the distance from the light source (<code>0</code>) to the camera (<code>1</code>). Use this to position the lens flare in the right position.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>color</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Denotes the color of the flare.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26 – Properties of the THREE.LensFlareElement object</p>
			<p>First, let’s look a <a id="_idIndexMarker277"/>bit closer at <a id="_idIndexMarker278"/>the first <code>LensFlareElement</code>:</p>
			<pre class="source-code">
const textureLoader = new THREE.TextureLoader();
const textureFlare0 = textureLoader.load(
  "/assets/textures/lens-flares/lensflare0.png"
);
lensFlare.addElement(new LensflareElement
  (textureFlare0, 512, 0));</pre>
			<p>The first argument, <code>texture</code>, is an image that shows the shape and some basic coloring of the flare. We load this with a <code>THREE.TextureLoader</code>, where we simply add the location of <code>texture</code>:</p>
			<div><div><img src="img/Figure_3.27_B18726.jpg" alt="Figure 3.27 – Lens flare used in the example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27 – Lens flare used in the example</p>
			<p>The second argument is <a id="_idIndexMarker279"/>the size of this flare. Since this is the flare we see at the<a id="_idIndexMarker280"/> light source itself, we’re going to make it quite big: <code>512</code> pixels in this case. Next, we need to set the <code>distance</code> property of this flare. What you set here is the relative distance between the source of the light and the center of the camera. If we set a distance of <code>0</code>, the texture will be shown at the position of the light, and if we set it to <code>1</code>, it will be shown at the position of the camera. In this case, we put it directly at the light source.</p>
			<p>Now, if you look back at the <a id="_idIndexMarker281"/>position of the other <code>LightFlareElement</code> objects, you will see that we positioned them at intervals from <code>0</code> to <code>1</code>, which results in the effect <a id="_idIndexMarker282"/>you see when you open up the <code>lens-flare.html</code> example:</p>
			<pre class="source-code">
const textureFlare1 = textureLoader.load(
  "/assets/textures/lens-flares/lensflare3.png"
);
lensFlare.addElement(new LensflareElement
  (textureFlare1, 60, 0.6));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 70, 0.7));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 120, 0.9));
lensFlare.addElement(new LensflareElement
  (textureFlare1, 70, 1.0));</pre>
			<p>With that, we’ve discussed the various lighting options provided by Three.js.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Summary</h1>
			<p>In this chapter, we covered a lot of information about the different kinds of lights that are available in Three.js. You learned that configuring lights, colors, and shadows is not an exact science. To get the correct result, you should experiment with the different settings and use a <code>lil.GUI</code> control to fine-tune your configuration. The different lights behave in different ways and, as we’ll see in <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, materials respond differently to lights as well.</p>
			<p>A <code>THREE.AmbientLight</code> color is added to every color in the scene and is often used to smooth hard colors and shadows. <code>THREE.PointLight</code> emits light in all directions and can cast shadows. <code>THREE.SpotLight</code> is a light that resembles a flashlight. It has a conical shape, can be configured to fade over distance, and can cast shadows. We also looked at <code>THREE.DirectionalLight</code>. This light can be compared to a faraway light, such as the Sun, whose light rays travel parallel to each other, the intensity of which doesn’t decrease the farther away it gets from the configured target, and which can also cast shadows.</p>
			<p>Besides the standard lights, we also looked at a couple of more specialized lights. For a more natural outdoor effect, you can use <code>THREE.HemisphereLight</code>, which takes into account ground and sky reflections. <code>THREE.RectAreaLight</code> doesn’t shine from a single point but emits light from a large area. We also showed a more advanced sort of ambient lighting by using a <code>THREE.LightProbe</code>, which used information from an environment map to determine how an object is lit. Finally, we showed you how to add a photographic lens flare with the <code>THREE.LenseFlare</code> object.</p>
			<p>In the chapters so far, we have already introduced a couple of different materials, and in this chapter, you saw that not all materials respond in the same manner to the available lights. In <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, we’ll provide an overview of the materials that are available in Three.js.</p>
		</div>
	

		<div><h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Part 2: Working with the Three.js Core Components</h1>
			<p>In this second part, we’ll dive into the different materials provided by Three.js and the different geometries you can use to create your own scenes. Besides the geometries, we’ll also look at how Three.js supports points and sprites, which you can use, for instance, for rain and smoke effects.</p>
			<p>In this part, there are the following chapters:</p>
			<ul>
				<li><a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with Three.js Materials</em></li>
				<li><a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Learning to Work with Geometries</em></li>
				<li><a href="B18726_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Advanced Geometries</em></li>
				<li><a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Points and Sprites</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>