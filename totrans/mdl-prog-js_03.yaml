- en: Chapter 3. Module Design Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reviewed some important JavaScript OOP concepts in the previous
    chapter, we are going to leverage some of the techniques discussed to create modules
    and start using them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with the term **design pattern**, which is essentially
    a way of structuring code as a reusable solution for common programming problems.
    In this chapter, we are going to focus on a particular design pattern in JavaScript
    called **module pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how we can create simple modules using this pattern and then
    we will build upon these modules to create our application's modules in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Module pattern is one of the most frequently used patterns in JavaScript for
    creating modular applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics that we will discuss in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal private scope in module pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create simple modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a module factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had a look at how we can create private variables
    and namespaces inside functions. We also explored how private scopes can be implemented.
    Some concepts related to private scopes can also be applied to **singleton** objects
    residing inside functions.
  prefs: []
  type: TYPE_NORMAL
- en: A singleton object is an object there will only ever be one instance of it in
    the application. Singleton objects can be created using object literal notation,
    which we saw examples of in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following object definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding object does not do anything, it is in fact a valid object
    and there can only be one instance of this object as we cannot create other objects
    based on `mySingletonObj`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some value properties and methods (method properties) to this object
    and see how we can access such properties outside of the object definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above object definition, we have created a singleton object with four
    properties. Two of them are value properties and two are method properties.
  prefs: []
  type: TYPE_NORMAL
- en: Our method properties have access to our value properties and return their values.
    However, we can also directly access the object's properties and even override
    their values from outside of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows that, while we have encapsulation (I am using the term loosely here)
    in our code, we do not have access control and the external code can change the
    values of the properties in our object. This at times, is undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's re-factor our code and create a simple module, using the module pattern.
    This will help us implement encapsulations as well as access control in our singleton
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created an **Immediately Invoked Function Expression**
    (**IIFE**) and have assigned its return value (which is a singleton object) to
    the variable `mySingletonObj`.
  prefs: []
  type: TYPE_NORMAL
- en: The returned singleton object has two methods that have access to the private
    variables of the container function and return their related values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to access the function variables directory from the returned object
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are unable to do so. This is because the `name` property is a private property
    of the container function and it does not exist on the returned anonymous object.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can access this property through the privileged method `getName`,
    which is defined on the singleton object returned by our IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `mySingletonObj` variable has a reference to this singleton object,
    if we execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to access the value assigned to the `name` property of the function.
    Note that the singleton object returned from the IIFE still has access to the
    context of the anonymous function that contains it. This is possible because we
    have created a closure here. Of course, the same applies to the `title` property
    of the function as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This approach of structuring our code in such a way that a returned singleton
    object from inside a function provides access to the private members (internal
    private scope) of the container function object) is what forms the basis of module
    pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Internal private scope in module pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Module pattern enables us to create a private scope for our code inside a function
    while providing controlled access to such a private scope through an interface.
    This interface can be in the form of a returned singleton object.
  prefs: []
  type: TYPE_NORMAL
- en: In the code example in the previous section, `mySingletonObj` is the interface
    to the private scope of our IIFE.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we add another property to `mySingletonObj` that has the same
    identifier as one of the properties of the containing function?
  prefs: []
  type: TYPE_NORMAL
- en: Well, `mySingletonObj` is like any other object in the sense that we can add
    properties to it regardless of it containing the object's properties. However,
    the important thing to remember here is that assigning or modifying such properties
    on the returned interface has no effect on the private variables encapsulated
    in the function that contains the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our previous module and dig a little deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added a `name` property to our returned singleton object
    from the IIFE, which has the same identifier as the `name` property on the function
    object. We have also replaced one of the previous methods with two new methods
    in our interface (the singleton object returned from the IIFE). The first method,
    `getOuterName`, simply returns the value of the `name` property.
  prefs: []
  type: TYPE_NORMAL
- en: The question is, which `name` property, the one from the private scope of the
    function or the `name` property from the singleton object itself?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the value returned is the value in the scope of the singleton
    object itself; thus, `Tom` is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we try to access the same property, using the method property on
    the interface, a different value will be returned. Have a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the value returned from this method is the value for the `name`
    property from the outer scope of the interface, which is the scope of the container
    function. This can be rather confusing.
  prefs: []
  type: TYPE_NORMAL
- en: If the intent is to return the value for the name property which is defined
    inside the singleton object itself (the interface), we need to qualify the property
    using the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the second new method that we added to our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we specifically qualify the context for `name` using the `this`
    keyword, which references the context of the singleton object itself as opposed
    to the containing function. Thus, if we run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The value assigned to `name` in the context of the singleton object is returned.
    This is an important distinction to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Adding properties to an interface in module pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen how internal private scope is at in play when we use the
    module pattern, let's see what happens if we add new dynamic properties to the
    singleton object returned in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are simply adding a new property dynamically to our object `mySingletonObj`.
    This property happens to have the same identifier as an already existing property
    on the object. What happens to the original value of the `name` property?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find out by running the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the new value of the singleton object's property is displayed
    regardless of whether we directly access the property or use our singleton's method
    to return the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, as expected, no changes have taken place in the value of
    the property contained in the container function's context, even though our singleton
    object does have access to this context.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when we use the module pattern in JavaScript and return a singleton
    object from it (as an interface to the containing object/function), there are
    two contexts that are at play.
  prefs: []
  type: TYPE_NORMAL
- en: First, the internal private scope of the container function, which our singleton
    object has access to through closure.
  prefs: []
  type: TYPE_NORMAL
- en: The second is the context of the singleton object itself as with any other object
    in JavaScript. It is important to understand the distinction between the two contexts
    when you design your modules using the module pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to keep in mind is that the code structure (pattern)
    shown previously allows us to have both object encapsulation and access control
    on the properties defined in a private namespace. In this case, the anonymous
    function creates a namespace that returns an anonymous object or, more accurately,
    a reference to the anonymous object (the singleton object) as an interface.
  prefs: []
  type: TYPE_NORMAL
- en: This approach becomes very valuable since now we can be sure that no external
    code is able to either intentionally or accidentally change the values of the
    properties in our namespace. This structure provides control over what properties
    are accessible by the outside code and what properties are hidden away and protected
    in the private scope.
  prefs: []
  type: TYPE_NORMAL
- en: Object factory module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can design our modules to be very specialized chunks of code that do very
    specific tasks, while protecting their internals from external code interferences.
    So far, we have looked at a very simple pattern for creating modules. We can take
    this pattern a step further and design a module that creates instances of an object,
    adds properties to these instances, and then returns them to the code external
    to the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this code, we have combined two patterns together: the **object
    factory** pattern and the module pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design patterns in JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not familiar with design patterns in general or would like to become
    more familiar with design patterns in JavaScript, I highly recommend the following
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering JavaScript Design Patterns* by *Simon Timms*.'
  prefs: []
  type: TYPE_NORMAL
- en: When our function `myCarFactoryModule` is called, based on the parameters passed
    in, we create an instance of a car and then we assign it to an array which is
    the repository for all instances of the cars created. We have designed this module
    in such a way that the external code to the module has no access to the method
    that creates the cars, nor has access to the car repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the outside code can call our module's interface to create cars
    and also get a count on the number of the cars created. It can also remove a car,
    if it is desired to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three privileged methods in this module: `createCar`, `getCarCount`,
    and `removeCar`. You can think of these methods as bridges between the internals
    of the module, which are hidden away from the outside world, and the external
    code, which relies on the internals of the module to do some specific tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The privileged methods (which are members of the singleton interface object)
    are exposed to the external code to provide the module's functionality to whoever
    needs its services.
  prefs: []
  type: TYPE_NORMAL
- en: There is a notable advantage to this design. As you might have noticed, we can
    modify the code inside our module and add additional functionality to the module
    without affecting how other parts of our application can interact with our module.
  prefs: []
  type: TYPE_NORMAL
- en: This is true, as long as we don't change the name or the functionality of the
    privileged methods that provide access for the external code to utilize the module's
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we can add new privileged methods to the interface of the
    module or modify the internals of our current privileged methods in the singleton
    object without affecting the internal code of the module itself.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to have a good separation of concerns and responsibilities between
    the exposed part of our module (the module's interface) and the private internals
    of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Creating loose coupling among modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a modular design, an application is often created using many modules. In
    order for these modules to work together, we need to create coupling among them,
    without the modules being tightly dependent on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an application based on a few simple modules and have the modules
    interact with each other in a loosely coupled manner. Of course, we will keep
    this application very simple for now. In later chapters, we will take the concepts
    utilized in this application and build upon them to create our fully modularized
    application ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: I'm making the safe assumption here that our future application will consist
    of many separate modules, with each one of them being responsible for doing a
    very specific task.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating our core application module and calling it `ApplicationInitModule`.
    Usually, the very first step in running an application is to take care of the
    application's initialization tasks. Our `ApplicationInitModule` will be designed
    to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code snippet, when `ApplicationInitModule` is started, it will
    in turn start all the registered modules and their initialization routines. This
    process will take care of the application's initialization routine as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code and see how our application is designed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a few interesting things are taking place in this application,
    but all the techniques used, we have already discussed in this book. Nonetheless,
    I'll go through each piece and explain the inner workings of each module.
  prefs: []
  type: TYPE_NORMAL
- en: Application core module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code starts by defining `ApplicationInitModule` as an application initializer
    module. The purpose of this module is to register all the available modules in
    the application (store them in an array) and then initialize them all (one at
    a time), when the application runs.
  prefs: []
  type: TYPE_NORMAL
- en: This module also provides an interface with some hooks for the external code
    to interact with it. As you can see, there are methods to register a module, get
    the count of all the modules registered in the app for initialization, and remove
    a module from the list of registered modules; of course, there is also a method
    to initialize all modules that have been registered with the app.
  prefs: []
  type: TYPE_NORMAL
- en: In this module, we are using an IIFE to return a reference to an anonymous singleton
    object, which is essentially the interface of the module.
  prefs: []
  type: TYPE_NORMAL
- en: One of the points that I'd like to draw your attention to is the fact that the
    functionality of this module is really defined in its interface. However, the
    module didn't have to be designed in this manner. You can also see that, in the
    other modules shown in the previous code, I have not used this approach. This
    is so you can see how we can implement the module pattern in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: Application Mediator module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `GlobalApp` module also uses an IIFE to return a singleton object as the
    interface to the module. The whole purpose of this module is to act as a mediator
    (abstraction layer) between `testModule1`, `testModule2`, and our core module,
    `ApplicationInitModule`.
  prefs: []
  type: TYPE_NORMAL
- en: We have designed the application this way so we can create a loose coupling
    between our core module and the other registered modules. As you can see, `GlobalApp`
    has been designed as a very thin layer.
  prefs: []
  type: TYPE_NORMAL
- en: This thin layer allows us to change our core module (`ApplicationInitModule`)
    as we please and even change its interface to the outside world, without affecting
    the other modules that rely on this module's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In our design, the only module which relies directly on the `ApplicationInitModule`
    interface is our `GlobalApp` module. This means that, if there are any changes
    to the interface of `ApplicationInitModule`, we only need to make modifications
    to our thin mediator layer `GlobalApp`. All the other modules in the application
    will be unaffected, as they still use the same thin layer interface provided by
    `GlobalApp`.
  prefs: []
  type: TYPE_NORMAL
- en: You will see in the future chapters of this book that this thin layer is called
    the **sandbox** and we will be using this concept of sandboxing to isolate our
    application modules/components from our application's core module(s). We will
    also use the same technique to isolate the modules/components from each other.
    For now, just try to become familiar with the general idea of module isolation
    (sandboxing) as shown in the previous application.
  prefs: []
  type: TYPE_NORMAL
- en: Application non-core modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our application implementation, we have created two simple modules that register
    themselves with the core module and really do nothing other than announcing to
    the world that they have been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a closer look at how these modules have been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: testModule1 implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `testModule1`, we have created an empty object called `self`, which gets
    augmented with a method called `initialize`. This is the method that will be called
    when our core module tries to initialize this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registration of this module with the core module happens using an internal
    IIFE, which in turn calls our mediator module `GlobalApp` with a reference to
    the object `self`. This is implemented as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `GlobalApp.registerModule` method is in fact a reference to the
    core module's method, `ApplicationInitModule.registerModule`. However, `testModule1`
    does not know that and is only aware of `GlobalApp` provided interface, `GlobalApp.registerModule`.
  prefs: []
  type: TYPE_NORMAL
- en: We have also used an IIFE to return an interface to this module, which is available
    through the `testModule1` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the interface provides two properties. One is a reference to the `self.initialize`
    method of the module and the other, `getName`, simply returns the value of the
    encapsulated and hidden `moduleName` variable. Also note that `moduleName` is
    not a property on the `self` object. Instead, it is implemented as a containing
    function's property.
  prefs: []
  type: TYPE_NORMAL
- en: testModule2 implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `testModule2` is implemented a little differently in comparison to `testModule1`.
    As shown in the code, we have simply defined a function inside our module called
    `initialize` that is exposed to the external code indirectly through the interface
    returned from our IIFE for this module.
  prefs: []
  type: TYPE_NORMAL
- en: In our `testModule2`, the `moduleName` variable is completely sealed from the
    outside world as there are no methods defined on the interface to provide access
    to this variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also no internal IIFE that registers the module with our core module,
    `ApplicationInitModule`, thus we need to make a call outside of our module definition
    to achieve this task, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have used our mediator module `GlobalApp` for this registration
    again and we are not directly calling the related method on the core module. This
    allows us to still preserve our loose coupling among the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design Pattern used in testModule2**'
  prefs: []
  type: TYPE_NORMAL
- en: The way we have implemented `testModule2` is based on a design pattern known
    as **revealing module pattern**, in its simplest form. This is a very popular
    pattern for designing modules but of course there are various ways of implementing
    modules, as we have already seen. We will see even more patterns for implementing
    modules in the upcoming chapters. To get a better understanding of this pattern,
    please refer to previously mentioned resource for JavaScript design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-initialization of application modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have seen how our application modules use a mediator module to register
    themselves with our application's core module, without being aware of the existence
    of the core module.
  prefs: []
  type: TYPE_NORMAL
- en: We also noted that communication among modules was done through the interfaces
    that were provided by the modules to the outside world. Only such interfaces had
    access to the internals of the modules and their internal private scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the relationships that exist among our application
    modules and provides an overall view of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Auto-initialization of application modules](img/B04910_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's have a look at the method in the core module that is responsible for calling
    initialization methods on all of our registered modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that a reference to each application module registered with the core
    module has been added to the array `registeredModules`. This is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the `initializeAllModules` method in our application (on the core
    module), a `for` loop is used to call the `initialize` method on all the registered
    modules. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `initializeAllModules` has no idea what each registered module's
    `initialize` method does when it is called. All it knows is to call the `initialize`
    method on the registered module and let the module take care of its own initialization
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important point when we modularize our code. Each module only
    deals with tasks that are specific to that module's design and none of the other
    modules have any knowledge of how such tasks are done in that module.
  prefs: []
  type: TYPE_NORMAL
- en: This means, while our core module calls the `initialize` method on one or many
    modules, it does not directly get involved with the initialization tasks of each
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to run a test and see how application initialization takes place.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we run the preceding code, we can see that both of our modules report that
    they have been successfully initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have designed our application in such a way that all the registered
    modules do have an accessible method called `initialize`. This allows us to use
    an array and a `for` loop to initialize them all in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Module initialization and design considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the application design time, you decide on how the modules should be initialized
    and how the initialization method in each module should be called. The important
    point is that calling the initialization routine of each module should not cause
    a tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'For consistency reasons, as well as ease of maintainability, I usually name
    the methods which are responsible for initialization tasks in all of my application
    modules: `initialize` or `init`. This allows me to use a `for` loop to call all
    the registered modules in sequence and ask the modules to initialize themselves
    accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that creating loose coupling among modules is only possible as
    long as the interfaces (public method hooks) in our modules do not change their
    names and their accessibility for the external code.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, for example, if `testModule1` calls the `GlobalApp.registerModule`
    method to register itself, it should always be able to call that method for registration.
    This should hold true even if the mechanism of how this registration takes place
    changes internally in the `GlobalApp` object.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture and design that you saw in our simple application here creates
    a foundation for creating loose coupling among our application modules. This in
    turn leads to a more extensible and maintainable implementation for both small
    and large applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can look at module interfaces as contracts among modules, which enables
    them to interact with each other regardless of how the internals of such contracts
    are implemented. Note that, while there are contracts among modules in the application,
    there is no direct dependency among them. Each module is free to decide on how
    to implement its specific functionality to accomplish the tasks that it was designed
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: This is so, as long as the module provides the functionality and the service
    which is expected from it.
  prefs: []
  type: TYPE_NORMAL
- en: This approach will provide a great deal of flexibility and extensibility for
    our application. It allows us to add, remove, and modify various parts of our
    application in a very targeted and manageable manner without such changes having
    an impact on other pieces of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental architectural concepts that we discussed here are the concepts
    that will form the building blocks of the final application that we will build
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at one of the most popular design patterns in JavaScript:
    module pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: By creating simple modules, we explored various aspects of internal private
    scope in module pattern and saw how modules can interact with each other, without
    having access to the protected properties of each other's private scope.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows us to create encapsulation and access control in our objects
    and modules, while providing an interface for the external code to leverage the
    implemented functionality intended for external use.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important aspect of module pattern is how it can be used to
    create a modular design for our application as a whole. This enables us to create
    loose coupling among our modules, which are essentially the building blocks of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will utilize this approach and slowly build more complex
    modules to create a robust and easily maintainable code base for our application.
    These modules can also be easily reused as needed, in all of our future applications.
  prefs: []
  type: TYPE_NORMAL
