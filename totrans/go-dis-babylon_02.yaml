- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ramping up on Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the risk of sounding hyperbolic, **Babylon.js** (**BJS**) is nothing short
    of incredible in how fast effortless, and **fun** it can be to work with 3D graphics
    and games. Most game and graphics engines come with sizable footprints in terms
    of size and computing resource requirements, but BJS is different because it can
    run in a web browser. The BJS team has created a rich web-based tooling ecosystem
    that covers a wide range of development workflows and use cases to support developers
    and designers from many different angles. After establishing some shared vocabulary
    and reviewing some basics, we will begin our journey with the **Babylon.js Playground**
    (**PG**). After this chapter, we’ll have laid the foundations for Space-Truckers
    by creating and rendering a basic animated scene that uses the PG along with content
    from the asset library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get from where we are to where we want to be, we’ll divide the
    work into these sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Catching up or Refreshing on Babylon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Our Scene in the Playground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating Orbits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most things in software, you’ll get the best results with Babylon.js. PG
    snippets requires only a web browser supporting **WebGL**, but a desktop-based
    browser is required for some BJS web-based toolsets such as the **Node Material
    Editor** (**NME**). A keyboard is highly recommended for typing code into the
    PG. With regards to browser support, while there are some exceptions around specific
    devices and platforms the latest versions of Edge, Chrome, and Firefox all support
    WebGL2, with ever-growing support for the newer WebGPU functionality. See [https://caniuse.com/webgl2](https://caniuse.com/webgl2)
    for the most up-to-date list of browser vendors supporting WebGL2.
  prefs: []
  type: TYPE_NORMAL
- en: Catching up or Refreshing on Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When starting a new project, it’s easy to get overwhelmed by the sheer number
    of different things that need to be done. Throw unfamiliar technologies or domains
    into the mix, and even the most seasoned software veteran might blanch a bit at
    the challenge. That’s an okay feeling to have! The key to overcoming and moving
    past it is both difficult and simple at the same time: you just need to find an
    atomic, well-defined task and then just do that task. After tackling a few of
    these tasks, you can take a step back to reassess things in light of what you
    now know. Most likely, you will find that the work you originally thought was
    needed isn’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re a veteran game developer exploring the possibilities of BJS or
    someone who has never programmed a game before, a strategy of starting simple
    and building iteratively can be the best way to get usable, immediate results.
    Let’s start with the basics. The following screenshot is part of the BJS 4.2 release
    content that demonstrates simply how BJS can render scenes with high visual fidelity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent
    shadows, reflections, and refraction are clearly visible along (and inside) the
    bottle and table, just as different substances cast different shadows in the real
    world. (https://playground.babylonjs.com/#P1RZV0)](img/Figure_2.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: A real-time interactive demo from the Babylon.js home page. Semi-transparent
    shadows, reflections, and refraction are clearly visible along (and inside) the
    bottle and table, just as different substances cast different shadows in the real
    world. ([https://playground.babylonjs.com/#P1RZV0](https://playground.babylonjs.com/#P1RZV0))'
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of BJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'BJS is a WebGL-based, full-featured 3D rendering engine written in TypeScript
    and compiled to JavaScript. Although commonly accessed via a web browser, current
    versions do not require an HTML DOM or Canvas elements, meaning that it can run
    “headless” on a server. The BJS team has a very clear vision and mandate, as illustrated
    from the BJS home page ([https://www.BJS.com](https://www.BJS.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: “Our mission is to create one of the most powerful, beautiful, and simple Web
    rendering engines in the world. Our passion is to make it completely open and
    free for everyone. We are artists, developers, creators, and dreamers and we want
    to make it as simple as possible to enable everyone to bring their ideas to life.”
  prefs: []
  type: TYPE_NORMAL
- en: BJS supports a wide range of both input and output scenarios, from game pads
    and accelerometer-based input to single- or multiple-viewport output (e.g., VR/AR).
    A full list of the engine’s specifications is available at [https://www.babylonjs.com/specifications](https://www.babylonjs.com/specifications).
    Something that’s less obvious from the specifications is that support for WebGPU
    is limited only by the implementation of the standard by browser vendors, so if
    you read news about WebGPU support being released for a browser, you can be confident
    that BJS will be able to take full advantage of it without needing you to do anything
    at all!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Something I always forget to apply to when I’m working with imported assets
    being from other 3D/image editing tools such as Blender is coordinate conventions.
    The 3D coordinate system used by BJS is “left-handed,” meaning that the positive
    *y*-axis will (by default) point in the “up” direction, the positive *x*-axis
    to the “right,” and the positive *z*-axis “toward” the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Get Started with Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that will quickly become apparent to anyone browsing the documentation
    for BJS is how thorough and comprehensive that documentation is. Given the high
    quality of the Getting Started content there, it would be a pointless waste of
    precious space in this book to attempt to recreate the basic tutorial at [https://doc.babylonjs.com/start](https://doc.babylonjs.com/start).
    If this is your first time adventuring with game development, BJS, or JavaScript,
    it is *highly* recommended that you take the time to at least browse through the
    Getting Started tutorial linked earlier. Don’t worry about leaving – everything
    will still be here right as you left it when you get back!
  prefs: []
  type: TYPE_NORMAL
- en: Tools for the Toolbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the advantages of being JavaScript-based is that it is very easy to
    make web-based tooling available that allows users to code and render in real
    time in a tight iteration loop. The BJS **Playground** (**PG**) is probably the
    most prominent member of the BJS toolchain, but that should not diminish the utility
    and importance of the other tools that we’re going to cover. The following table
    summarizes the various tools available and their purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, we’ll be making heavy use of the PG; we’ll use it to quickly
    put together a piece of code or test a concept before integrating it into our
    application code. Not to be left out, the **Inspector** (and its accompanying
    tools) is also going to see heavy usage for its powerful scene-debugging capabilities.
    Finally, the NME will be covered later in this book as we dive into the making
    of Space-Truckers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The typical usage of the word **Game** in this book denotes the portion of the
    overall **Application** that is devoted to the game mechanics, logic, and loops.
  prefs: []
  type: TYPE_NORMAL
- en: The Asset Types of BJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many different types of files and formats are supported by BJS, either directly
    or indirectly (via exporter plugins). When selecting and/or creating assets for
    your game, it’s important to put together a production workflow that minimizes
    the amount of friction without sacrificing quality – something we’ll learn more
    about in the next chapter. Here are a few of the most commonly encountered third-party
    tools and file types that BJS supports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Textures/Images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DDS (DXT1, 4bpp, and RGBA)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PNG/JPEG/BMP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TGA
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HDR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '3D Models:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GLTF (preferred)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OBJ
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: STL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: BLENDER/3DS Max/Maya (exporter plugins)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WAV
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MP3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MP4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M4A
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fonts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TrueType
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OTT
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More relevant to our immediate purposes, however, is the BJS **Asset Library**.
    You can see the asset categories and browse entries by category at [https://doc.babylonjs.com/toolsAndResources/assetLibraries](https://doc.babylonjs.com/toolsAndResources/assetLibraries),
    but the true power of the Asset Library comes from being able to reference and
    load them from the PG! Let’s start off our scene creation by doing just that.
    Open up your browser of choice and head to the BJS PG: [https://playground.babylonjs.com](https://playground.babylonjs.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Playground Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Babylon.js Playground** is designed around providing users with the easiest,
    shortest possible path to rendering content in the scene. Open your web browser
    of choice and navigate to [https://playground.babylonjs.com/](https://playground.babylonjs.com/)
    and you’ll see the basic outline of a snippet. This basic template snippet simply
    creates a new **scene** and a **camera** that renders it, but it’s as good a starting
    place as any!
  prefs: []
  type: TYPE_NORMAL
- en: On the left of the playground is the code editor and on the right the render
    canvas. The important thing to know about the playground is that each snippet
    is unique in two ways, both contained within the URL to the snippet. The characters
    after the first hash (#) symbol are the snippet’s ID, the number after the second
    hash the revision. Every time a snippet is created it is assigned a unique identifier,
    and every time that snippet is saved a new revision is created. For example, **#L92PHY#36**
    points to a sample showing multiple viewports in an FPS camera, with the current
    revision being 36\. Thus, it’s possible to step incrementally through a particular
    snippet’s revision history simply by changing the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because we are going to be using snippets from the PG in our game though, we’re
    going to want to do a little bit of preparatory structuring so that we can easily
    and reliably transfer code between our PG snippets and the source repos (more
    on this in [*Chapter 3*](B17266_03_Final_AM.xhtml#_idTextAnchor049)*, Establishing
    the Development Workflow*). Throughout the book and in snippets, we will be using
    **ES6** syntax where possible. This gives us access to some important language
    features that we’ll be leveraging to help keep our code readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 recommendation: choose `let` over `var`.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s all about hoisting and closures. Variables declared using the `var` keyword
    are valid in their declaring scopes, but also potentially in a/their containing
    scope (known as “hoisting”). Additionally, you can reference a `var` prior to
    its usage without throwing a runtime error. When a variable is declared with the
    `let` statement, it is only available in the declared scope, and it must be declared
    prior to usage; otherwise, an error will be thrown. Generally, you should prefer
    the use of `let` over `var` because it will more easily prevent and expose all-too-common-but-potentially-quite-subtle
    defects. Of course, if you aren’t going to be changing the value, you should use
    `const` over `let`.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the AppStartScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new PG snippet starts with a single block of code – the `createScene` function.
    As the code comments also indicate, the `engine` and `canvas` global variables
    are available in the window’s context.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The HTML Canvas element has been removed as a dependency in BJS 4.2+, but for
    backward compatibility reasons, methods involving the HTML Canvas element will
    still function as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the createScene function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the reuse of code easier, we will make a small change to the initial
    function template. Instead of putting all of the scene’s logic into the same `createScene`
    function, we’re going to subdivide the logic into atomic functions as much as
    possible. The initialization routine will be done in a new function, which will
    return an object containing the populated scene objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A sharp observer will notice that we have not as yet implemented the `createStartScene`
    function, which is of course the next step. Its purpose is to create and initialize
    the scene and its elements – see the following list. Low-friction change is critically
    important, so to make it easier to change them later we’re going to place each
    piece of functionality into its own function (pun intended):'
  prefs: []
  type: TYPE_NORMAL
- en: ArcRotateCamera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Star (sun)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skybox for background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planets – four rocky and one gas giant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s time to fill out our add and populate this new function, `createStartScene`.
    First, we are creating the scene and camera, specifying some specifics before
    making calls to soon-to-be-written functions (in bold) that create their respective
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To save you the effort of doing the math in your head, the `camBeta` (or, the
    latitudinal position in radians of the camera from the target) value comes out
    to around 0.785 rad - 45 degrees, between the equator and the pole of an imaginary
    circle around the target of `camDist` radius. Of course, this code won’t compile
    or run yet because we haven’t yet defined `setupEnvironment`, `createStar`, or
    `populatePlanetarySystem`. Add stub implementations for these functions to make
    sure that the code runs as expected. The resulting scene is empty, but it’s a
    good checkpoint in our progress. It’s time to fill in the stubs and make our scene
    come to life! Don’t forget to save (*Ctrl* + *S*) your snippet before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default environment is pretty bland and dark. The primary source of lighting
    for the scene is going to be a **Point Light** positioned at the center of the
    star system, while a skybox gives the scene perspective. The texturing of the
    skybox is of particular interest, because an attractive-looking skybox tends to
    be quite large in terms of file size. We care about this because we are going
    to use this scene as a loading graphic, meaning that it needs to load and begin
    rendering as quickly as possible. Loading a large texture over an internet connection
    is unlikely to help us with that goal, so instead we will create the texture on
    the fly using the **Starfield Procedural Texture** from the Babylon.js **Procedural
    Textures Library** (see [https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary](https://doc.babylonjs.com/toolsAndResources/assetLibraries/proceduralTexturesLibrary)
    for the full list of available procedural textures).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Every `darkmatter`, which controls the lacunae (voids), and `distfading`, which
    governs the sharpness or blurriness of the rendered texture. The values in the
    code listed in the following code were arrived at after trial-and-error, so experiment
    to see what you like the best!
  prefs: []
  type: TYPE_NORMAL
- en: '`PointLight` is, as the name implies, a source of light that radiates in a
    spherical shell from a single point in space. Because of the darkness of the scene
    and its large-ish size, the intensity of the light gets a bump before setting
    some sun-like colors for the diffuse and specular color channels. We use the `createDefaultEnvironment`
    method along with some previously defined options to create the skybox and accompanying
    background material. That method returns an `EnvironmentHelper` instance, which
    we will kindly return to the original caller of `setupEnvironment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Clicking **Run** should now show a nifty-looking starfield in a skybox you can
    pan around. If everything is working correctly, now is a good time to save your
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Starfield skybox environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Starfield skybox environment
  prefs: []
  type: TYPE_NORMAL
- en: Birthing a Star
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mesh for our star is a simple sphere, but when we add the standard material
    and some color channels, the result is a single-toned, flat-appearing circle –
    not very “star-like.” We can get a more nuanced look with very little effort by
    combining an `BABYLON.Texture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Without changing the `diffuseTexture.level` value, the `emissiveColor` tends
    to either wash out the distortion or be extinguished entirely by the diffuse texture’s
    pixel values. The level, 1.8, was a product of trial-and-error (as is the case
    with many of these “magic numbers” that tend to show up during app design/game
    development). This is a good checkpoint for **saving** your progress if you haven’t
    recently.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Emissive color combined with a diffuse distortion texture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Emissive color combined with a diffuse distortion texture
  prefs: []
  type: TYPE_NORMAL
- en: Producing Planets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s only one remaining top-level scene element that we still need to create,
    and that’s the `populatePlanetarySystem` function. The implementation for this
    is a classic example of the power of compositional software patterns – a topic
    we will be returning to later. There’s what you might think of as a central control
    logic in the form of `populatePlanetarySystems`, which is responsible for defining
    the number and unique properties of the various planetary bodies. It then asks
    another function, the new `createPlanet` method, to take care of how the actual
    object is constructed. Finally, it collects the planets into an array that it
    returns to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be able to create different types of planets with different properties,
    so in our `populatePlanetarySystems` method, we create an array of objects that
    define each planet. For the full listing of planetary data, see [https://playground.babylonjs.com/#0UYAPE#26](https://playground.babylonjs.com/%230UYAPE%2326):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `posRadians` property generates a random value between 0 and 360 degrees
    (in radians), whereas the `posRadius` property specifies the distance from the
    origin the planet should reside – how far away it is from the sun. The overall
    size of the planet is determined by its `scale` factor, while the `color` property.
    We’ll cover the final property in a moment. Scaling of a scene can be tricky,
    but you can use relative scale guides to help come up with appropriate ranges
    of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to stick to realistic numbers – have you ever been told that
    “Space is Big. Really Big”? It is, in fact, quite too big to fit in our tiny viewport,
    so when choosing `posRadius` for the planet, it might be easier to approach coming
    up with a figure from a different direction. By looking at the orbital radius
    in terms of the relative steps between planets, we can come up with a decent-looking
    (but probably not realistically stable) system of planets. Our `starDiameter`
    is 16, giving us a radius of 8 units. Our inner-most planet, `“hg”`, needs to
    be at least 8 + 2 = 10 units to avoid intersecting the star; putting it at 14
    units seems about right. Moving to subsequent planets, by placing each planet
    around 1.5–1.8x, the orbital radius of the previous planet will give nice-looking
    results that aren’t too far from the ratios found in our own Solar System – that’s
    how you know it will be interesting!
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with the `rocky` property. This flag will signal our logic that
    it needs to apply a different set of textures to the `createPlanet` into the `planets`
    array before returning the populated array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The final sub-task needed to display our planetary system is to implement the
    `createPlanet` function. In this method, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sphere **Mesh** using the **MeshBuilder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `diffuseColor` and `specularColor` to the passed-in `Color3` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign textures based on the value of the `rocky` flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the material to the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale and position `planet` according to the passed-in `scale`, `posRadians`,
    and `posRadius` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It may not be immediately obvious, but we are also setting the material’s `specularPower`
    to zero. This is because we will otherwise get very shiny spots on our planets,
    making them look more like billiard balls than rocky or gaseous spheres. For rocky
    planets, we are pulling in both `bumpTexture` (a.k.a. a `diffuseTexture` from
    the BJS **Textures Library**. For planets with no visible surface, we use the
    distortion texture to add the appearance of cloud bands in the atmosphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With that code in place, you should be able to **Run** the scene and get a most
    excellent result, showing our central star with four various-sized and colored
    planets at varying distances from the star.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Star system with planets and a skybox'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Star system with planets and a skybox
  prefs: []
  type: TYPE_NORMAL
- en: '**Save** the snippet and strap in, because next, we’re going to learn two different
    ways and styles of making our planets move.'
  prefs: []
  type: TYPE_NORMAL
- en: Animating the Orbits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'BJS has many different ways of accomplishing any given task; animating objects
    in a scene is no different. Some of the different ways to animate in BJS include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a reusable `BABYLON.Animation` object that will interpolate specified
    properties between an array of **keyframes**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import pre-built Animations from a file – `BABYLON`, `GLTF`, `GLB`, `OBJ`, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `OnPreRenderObservable` to update object properties (e.g., position, rotation,
    color, and so on) before each frame is rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our title screen animations, we will be using the first and third methods
    to animate the rotations and circular orbits of our little solar system, respectively.
    In later chapters, we will see more of the second.
  prefs: []
  type: TYPE_NORMAL
- en: Putting Spin on the Star and Planets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rotation of stars and planets is pretty simple, but it can serve as a good
    review of the principle and practice of keyframe animation. Since animations can
    be looped or cycled, it’s often unnecessary to need a large number of frames for
    a given animation. We’ll follow a few easy steps to add a `createSpinAnimation`
    function that returns a new **Animation** instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we figure out what/which properties of the animation’s target will be
    changing. In this case, it is just the target node’s `rotation.y` value. We can
    say that our animation should complete a full circle (360 degrees or 2 * Pi radians)
    in 2 seconds. Next, determine how many frames the animation should comprise in
    total, the number of `Scalar.TwoPi`. This is all we need to implement the code
    to create and set the animation properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `createSpinAnimation` method is called from `createStartScene` to make the
    `spinAnim` variable available to the rest of the scene’s controlling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the animation has been created, it can then be added to one or more different
    `mesh.animations` arrays. This attaches the animation to that particular `Animation`
    object has no `start` function or equivalent. That is because the Animation itself
    is agnostic of its target, allowing it to be used across any arbitrary number
    of different meshes. Starting with `star` and then looping through our `planets`
    array, we add `spinAnim` to each mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To start an animation, you call the `scene.beginAnimation` function, passing
    the start frame, the end frame, and the speed parameters along with the animation
    object. We want it to loop, so we pass `true` as our final parameter to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When the scene is run, the animation automatically starts and you can observe
    the rotation of all the bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Making Orbital Motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the `scene.onBeforeRenderObservable`. In the context of the game engine
    loop, this is where the update logic happens. At the end of `createPlanet`, we
    will add code to attach the event listener along with additional data that tracks
    the planet’s orbital parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our `createAndStartOrbitAnimation` method needs to derive a number of values.
    Two of these, the orbital radius (`posRadius`) and the angular position (`posRadians`)
    are added to `planet` as the `orbitOptions` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `period` orbital is the amount of time it takes for the planet to make
    one complete revolution (360 degrees or 2 * Pi radians) and is measured in seconds.
    We want each planet to have a different period, with distant bodies taking longer
    than closer ones to complete an orbit, but we don’t want to laboriously tweak
    values until they look good. Physics – or, more specifically, Newtonian mechanics
    – gives us the equations to compute a planet’s orbital speed given its distance
    (radius) from a given massive body. Knowing the rate of position change over time,
    it’s possible to calculate the angular velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Gm` constant is more or less arbitrarily chosen to ensure a smooth distribution
    of orbital velocities as the radius changes. The state variable needed is `angPos`,
    which is incremented by `w` every frame and kept within a valid range by wrapping
    the statement in a call to `Scalar.Repeat`. In general, it’s useful to think of
    the angular components of these kinematics as being counters or watch dials; incrementing
    the angular position by the angular velocity over time and computing position
    components completes the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Returning the `preRenderObsv` object isn’t needed to make this work, but it’s
    a good practice so that we can later on cleanly dispose of the observer when it’s
    no longer needed. Now, when the scene is run, the planets all circle around the
    sun in a unique fashion. This is all looking great, but there’s one last thing
    we can do to really spice things up before we move on. Mash **Save** and let’s
    move on to the finale.
  prefs: []
  type: TYPE_NORMAL
- en: Orbit Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To cap off this animation, we’re going to add lines to each planet’s orbit
    using a `createAndStartOrbitAnimation` method is a good place to do this. We declare
    our `TrailMesh` and pass it `planet` to attach to along with the `circum` orbital
    (length) of the trail ribbon, also specifying that we want the trail to start
    immediately. At the same time, we also create a new material and associate it
    with the Trail Mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Before adding the trail mesh, we need to force recomputation of the planet’s
    **World Matrix**; otherwise, the trail will have artifacts from the origin to
    the planet’s location. That’s it! The orbits trace out nice circles as they move,
    but it still feels as if the scene were a bit dark and washed out.
  prefs: []
  type: TYPE_NORMAL
- en: Shining up with GlowLayer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, BJS does not add the emissive color channel of a material to the
    lighting computations – emissive textures and colors don’t brighten up a scene.
    Making objects glow is easy; just add this line to the `createStartScene` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless otherwise specified, the GlowLayer will impact every mesh in the scene.
    We don’t want the planets to glow, so while we’re looping through the planets
    to animate their rotation, add the planet to the mesh exclusion list of the GlowLayer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Click **Run** to view the results. If you’re not satisfied with how things look,
    you can tweak the camera altitude and angle (**beta** and **alpha** respectively),
    distance, and so on. Make sure to save the snippet in any case and enjoy the fruits
    of your labor. Once you’re done admiring your work, post your snippets on the
    boards at [https://github.com/jelster/space-truckers/discussions/21](https://github.com/jelster/space-truckers/discussions/21),
    where you can look at other folks’ creations, share, and discuss – but don’t forget
    to come back here, there’s still more work to be done!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Completed orbital animation with GlowLayer and Trail Meshes
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The completed snippet meets the immediate needs of our application, but that
    doesn’t mean that there aren’t ways to improve it! The following are a few ideas
    you might pursue on your own that could enhance the scene. Join the BJS and the
    Space-Truckers community by posting and sharing your snippets over at the Space-Truckers
    Discussions board ([https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions))
    or over on the BJS forums ([https://forum.babylonjs.com/](https://forum.babylonjs.com/)).
    The discussion boards and forum aren’t just there to share your accomplishments,
    however. They’re a place where you can post questions or issues you’re encountering,
    with a thriving community that loves to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the helix-like appearance of the planet trails. The spin animation and
    the trail mesh are both parented to the planet. As the planet rotates, the trail
    mesh gets twisted around. One approach to fixing this could be to add a **TransformNode**
    to the scene and parent the planet to it. Keep the spin animation on the planet,
    but associate and point the **TrailMesh** and the orbital animation at the **TransformNode**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the star’s current texture with a particle system. The **ParticleHelper**
    has a **sun** effect that can bring a cool effect to the scene. The docs on this
    are at [https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper](https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper),
    where there’s also useful information on how to create your own custom **ParticleSets**.
    The easiest (and perhaps the best) option for creating custom particle systems
    is to use the NME ([https://nme.babylonjs.com/](https://nme.babylonjs.com/)) in
    **Particle** mode. The NME is to shaders as the PG is to scenes, meaning that
    just as you can save and share PG snippets, you can also save and share NME snippets.
    The difference between them in this context is that you can use NME snippets in
    the PG but not vice versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a comet on an **inclined** orbit that brightens and shows a tail as it gets
    closer to the star on its elliptical path through the scene. An inclination simply
    means that the object includes the y axis as it “bobs” up and down through the
    orbital plane. An elliptical orbit has the same period as a circular orbit, with
    an orbital radius that’s the same as the ellipse’s **semi-major axis** (the length
    of the line dividing the ellipse along its long side), but the difference is that
    rather than having a constant velocity along its path, objects moving in an elliptical
    orbit travel fastest at their closest approach (**apopse**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Give the outer-most gas giant planet a ring system. One way to approach this
    would be to create a flat torus mesh using the MeshBuilder, and then use BJS **Parenting**
    to attach the rings to a planet. Another approach that builds on the prior would
    be to use the **Solid Particle System** (**SPS**) to generate tens or even hundreds
    of small rocks to comprise the rings. Consider it a preview of what’s coming up:
    in the next chapter, we’ll be using the SPS to create an asteroid belt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add clouds specular, terrain bump (normal) map to a rocky planet to make it
    look like real-world planets. The BJS **Asset Library** has a height map of the
    earth’s terrain along with various textures for cloud and ground effects. The
    **Materials Library** also has some interesting options to explore for making
    the planets unique and attractive – have fun!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the camera pan and zoom around the system cinematically. Choose one of
    the animation methods we discussed previously, targeting the scene’s `camera`.
    Depending on your methods and plan, you may want to unset or change the camera’s
    target to be a **TransformNode**. This new, non-rendered node acts as a sort of
    “mark” that can be moved around to change the camera’s view as the position changes.
    Another option is to explore a different type of camera than the current **ArcRotateCamera**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we’ve refreshed and ramped ourselves up on
    BJS by creating a simple scene in the PG. We learned about different ways of animating
    a scene along with how to load textures and other assets from the BJS Asset Library.
    Hopefully, we’ve had a little bit of fun along the way, but this is just the tip
    of the iceberg when it comes to what’s in store in later chapters. If you needed
    a little bit of a refresher on BJS, hopefully this has gotten you warmed up and
    ready to go. If you’re new to BJS, then I hope this has empowered you to push
    onward to the next chapter. Coming up in the next chapter, we will begin Space-Truckers
    in earnest by setting up a local development environment along with source control
    and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The BJS documentation site contains an enormous wealth of knowledge and content.
    Here are some relevant pages from the docs that go into more detail on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve gotten how to do individual Animations, read about Animation sequencing,
    grouping, and combining, starting at [https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations](https://doc.babylonjs.com/divingDeeper/animation/sequenceAnimations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about importing different files types of assets into a scene and how loaders
    work at [https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Diving Deeper: The Mesh section has details on how the GlowLayer works
    at [https://doc.babylonjs.com/divingDeeper/mesh/glowLayer](https://doc.babylonjs.com/divingDeeper/mesh/glowLayer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on the different types of cameras and their properties, see [https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction](https://doc.babylonjs.com/divingDeeper/cameras/camera_introduction).
    Something that is worth mentioning is that whenever you see the docs mention `FreeCamera`,
    `TouchCamera`, or `GamepadCamera`, you should instead substitute or use `UniversalCamera`,
    as it supersedes those three, which are retained for backward compatibility reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
