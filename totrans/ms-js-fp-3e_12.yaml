- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Better Containers – Functional Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design Patterns*,
    we went over how to use functions to achieve different results. In this chapter,
    we will look at data types from a functional point of view. We’ll be considering
    how we can implement our own data types, along with several features that can
    help us compose operations or ensure their purity so that our FP coding will become
    simpler and shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll be touching on several topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data types** from a functional point of view. Even though JavaScript is not
    a typed language, a better understanding of types and functions is needed, to
    complement our usage of TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**, including functors and the mystifying monads, to structure
    a data flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions as structures**, in which we’ll see yet another way of using functions
    to represent data types, with immutability thrown in as an extra.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Specifying data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though JavaScript is a dynamic language, without static or explicit typing
    declarations and controls, it doesn’t mean you can simply ignore types. Even if
    the language doesn’t allow you to specify the types of your variables or functions,
    you still work—even if only in your head—with types. Specifying types has advantages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript can detect compile-time errors, avoiding many bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will help if you move from JavaScript to a more functional language, such
    as Elm (see [elm-lang.org](http://elm-lang.org)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as documentation that lets future developers understand what type
    of arguments they must pass to the function and what type it will return. All
    the functions in the Ramda library are documented in this way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also help us with the functional data structures we will cover later
    in this section, where we will examine a way of dealing with structures, similar
    to what you do in fully functional languages such as Haskell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are we discussing types again, after using TypeScript throughout the whole
    book? The reason is that in most FP texts, a different style is used. TypeScript
    definitions are just, well, TypeScript, but the definitions we’ll see here can
    be applied to any other language. Let’s forget TypeScript for a minute and start
    thinking about a new type system. We’ll start with functions, the most relevant
    type, and then consider other definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Signatures for functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The specification of a function’s arguments and the result are given by a signature.
    Type signatures are based on a type system called **Hindley–Milner** (**HM**),
    which influenced several (mostly functional) languages, including Haskell, though
    the notation has changed from that of the original paper. This system can even
    deduce types that are not directly given, in the same way that TypeScript or Flow
    does. Instead of providing a dry, formal explanation about the rules for writing
    correct signatures, let’s work with examples. We only need to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be writing the type declaration as a comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function name is written first, and then `::`, which can be read as *is
    of type* or *has type*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional constraints may follow, with a double (fat) arrow `⇒` (or `=>` in basic
    ASCII fashion, if you cannot type in the arrow) afterward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input type of the function follows, with a `→` (or `->`, depending on your
    keyboard)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result type of the function comes last
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Careful with arrows!
  prefs: []
  type: TYPE_NORMAL
- en: 'An advance warning: check out the arrow styles we’ll use; they are not what
    TypeScript uses! A “thin” arrow will be used instead of `=>`, and a “fat” arrow
    will be used to specify a generic constraint; be careful!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can begin with some examples. Let’s define the type for a simple function
    that capitalizes a word, and do the same for the `Math.random` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These are simple cases—only take the signatures into account here; we are not
    interested in the actual functions. The arrows denote functions. The first function
    receives a string as an argument and returns a new string. The second one receives
    no arguments (as indicated by the empty parentheses) and returns a floating-point
    number. So, we can read the first signature as `firstToUpper()` *is a function
    of the type that receives a string and returns a string*. We can speak similarly
    about the maligned (impurity-wise) `Math.random()` function, the only difference
    being that it doesn’t receive arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparing the new type definition with TypeScript, it’s clear that they are
    very much alike. However, the new style is clearer. You could have also defined
    `firstToUpper()` in the following way, without specifying the result type (because
    TypeScript can work it out), but with HM types, you have to provide all the details,
    providing more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Another detail is that in this new way of specifying types, the type descriptions
    stand on their own, without being mixed with the details of the programming language—you
    don’t need to understand JavaScript, TypeScript, or any other language to figure
    out what types are involved in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already looked at functions with zero or one parameter, but what about
    functions with more than one? There are two answers to this. If we are working
    in a strict functional style, we would always be currying (as we saw in [*Chapter
    7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*), so all the functions
    would be unary. The other solution is enclosing a list of argument types in parentheses.
    We can see both of these solutions in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `sum3c()` is actually `(a) => (b) => (c) => a + b + c`; this
    explains the first signature, which can also be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After you provide the first argument to the function, you are left with a new
    function, which also expects an argument and returns a third function, which,
    when given an argument, will produce the final result. We won’t be using parentheses
    because we’ll always assume this grouping from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what about higher-order functions, which receive functions as arguments?
    The `map()` function poses a problem: it works with arrays of any type. Also,
    the mapping function can produce any type of result. For these cases, we can specify
    generic types, identified by lowercase letters. These generic types can stand
    for any possible type. For arrays themselves, we use brackets. So, we would have
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s perfectly valid to have `a` and `b` represent the same type, as in a mapping
    that’s applied to an array of numbers, which produces another array of numbers.
    The point is that, in principle, `a` and `b` may stand for different types, which
    we described previously. This definition requires using generic types in TypeScript,
    `A` and `B` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we weren’t currying, the signature would have been `([a], (a →
    b)) → [b]`, showing a function that receives two arguments (an array of elements
    of type `a` and a function that maps from type `a` to type `b`) and produces an
    array of elements of type `b` as its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can similarly write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the big one: what’s the signature for `reduce()`? Be sure to read it
    carefully and see whether you can work out why it’s written that way. You may
    prefer thinking about the second part of the signature as if it were `((b, a)
    →` `b)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you are defining a method instead of a function, you use a squiggly
    arrow such as `~>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have defined data types for functions, but we aren’t done with this
    subject. Let’s consider some other cases.
  prefs: []
  type: TYPE_NORMAL
- en: Other data type options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What else are we missing? Let’s look at some other options that you might use.
    *Product types* are a sets of values that are always together and are commonly
    used with objects. For *tuples* (that is, arrays with a fixed number of elements
    of (probably) different types), we can write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For objects, we can go with a definition very similar to what JavaScript already
    uses. Let’s imagine we have a `getPerson()` function that receives an ID and returns
    an object with data about a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Sum types* (also known as *union types*) are defined as a list of possible
    values. For example, our `getField()` function from [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, returns either the value of an attribute or `undefined`.
    For this, we can write the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also define a type (union or otherwise) and use it in further definitions.
    For instance, the data types that can be directly compared and sorted are numbers,
    strings, and Booleans, so we could write the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we could specify that a comparison function can be defined in terms
    of the `Sortable` type, but be careful: there’s a hidden problem here!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous definition would allow us to write a function that received, say,
    a `number` and a `Boolean`. It doesn’t say that both types should be the same.
    However, there’s a way out. If you have constraints for some data types, you can
    express them before the actual signature, using a fat arrow, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition is now correct because all occurrences of the same type (denoted
    by the same letter, in this case, `a`) must be exactly the same. An alternative,
    but one that requires much more typing, would have been to write all three possibilities
    with a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this definition isn’t very precise because you can compare any type,
    even if it doesn’t make much sense. However, bear with me for the sake of this
    example! If you want to refresh your memory about sorting and comparison functions,
    see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been using the standard type definitions. However, when working
    with JavaScript, we have to consider other possibilities, such as functions with
    optional parameters, or even with an undetermined number of parameters. We can
    use `...` to stand for any number of arguments and add `?` to represent an optional
    type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unary()` higher-order function we defined in the same chapter we cited
    previously took any function as a parameter and returned a unary function as its
    result. We can show that the original function can receive any number of arguments
    but that the result used only the first. The data type definition for this would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The standard `parseInt()` function provides an example of optional arguments,
    though it’s highly recommended that you don’t omit the second parameter (the base
    radix); you can, in fact, skip it.
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic definitions?
  prefs: []
  type: TYPE_NORMAL
- en: Check out [github.com/fantasyland/fantasy-land/](http://github.com/fantasyland/fantasy-land/)
    and [sanctuary.js.org/#types](http://sanctuary.js.org/#types) for a more formal
    definition and description of types, as applied to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, throughout this chapter, we’ll not only be using TypeScript, but
    we will also be adding HM signatures to methods and functions, so you can get
    used to them. Let’s now change track and cover a highly important topic: *containers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Building containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    and later, in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we saw that the ability to apply a mapping to all the elements of an array—and
    even better, being able to chain a sequence of similar operations—was an excellent
    way to produce better, more understandable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a problem: the `map()` method (or the equivalent, demethodized
    one, which we looked at in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*) is only available for arrays, and we might want to be able to apply
    mappings and chaining to other data types. So, what can we do?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider different ways of doing this, which will give us several new
    tools for better functional coding. Basically, there are only two possible ways
    of solving this: we can either add new methods to existing types (though that
    will be limited because we can only apply that to basic JavaScript types) or wrap
    types in some type of container, which will allow mapping and chaining.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by extending current types before moving on to using wrappers, which
    will lead us into the deep functional territory with entities such as functors
    and monads.
  prefs: []
  type: TYPE_NORMAL
- en: Extending current data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to add mapping to basic JavaScript data types, we need to start
    by considering our options:'
  prefs: []
  type: TYPE_NORMAL
- en: With `null`, `undefined`, and `Symbol`, applying maps doesn’t sound too interesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have some interesting possibilities with `Boolean`, `Number`, and `String`
    data types, so we can examine some of those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applying mapping to an object is trivial: we just have to add a `map()` method,
    which must return a new object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, despite not being basic data types, we could also consider special
    cases, such as dates or functions, to which we could also add `map()` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the rest of this book, we are sticking to plain JavaScript and TypeScript,
    but you should look into libraries such as Lodash, Underscore, or Ramda, which
    already provide functionalities similar to the ones we are developing here.
  prefs: []
  type: TYPE_NORMAL
- en: A key point to consider in all these mapping operations should be that the returned
    value is of the same type as the original one. When we use `Array.map()`, the
    result is also an array, and similar considerations must apply to any other `map()`
    method implementations (you could observe that the resulting array may have different
    element types to the original one, but it is still an array).
  prefs: []
  type: TYPE_NORMAL
- en: 'What could we do with a Boolean? First, let’s accept that Booleans are not
    containers, so they don’t really behave in the same way as an array. Trivially,
    a Boolean can only have a Boolean value, while an array may contain any type of
    element. However, accepting that difference, we can extend `Boolean.prototype`
    (though, as I’ve already mentioned, that’s not usually recommended) by adding
    a new `map()` method to it and making sure that whatever the mapping function
    returns is turned into a new Boolean value. For the latter, the solution will
    be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We already saw examples of adding a (fake) `this` parameter to a method, to
    let TypeScript know what type `this` will be—in this case, a Boolean. The `!!`
    operator forces the result to be a Boolean. `Boolean(fn(this))` could also have
    been used. This kind of solution can also be applied to numbers and strings, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with Boolean values, we are forcing the results of the mapping operations
    to the correct data types. By the way, TypeScript won’t directly accept any of
    these new `map()` definitions; see *Question 12.1* to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we wanted to apply mappings to a function, what would that mean?
    Mapping a function should produce a function. The logical interpretation for `f.map(g)`
    would be applying `f()`, and then applying `g()` to the result. So, `f.map(g)`
    should be the same as writing `x => g(f(x))` or, equivalently, `pipe(f,g)`. The
    definition is more complex than it was for the previous examples (but, in my opinion,
    simpler in HM than with TypeScript), so study it carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Verifying that this works is simple, and the following code is an easy example
    of how to do this. The `times10()` mapping function is applied to the result of
    calculating `plus1(3)`, so the result is 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done talking about what we can achieve with basic JavaScript
    types, but we need a more general solution if we want to apply this to other data
    types. We’d like to be able to apply mapping to any kind of value, and for that,
    we’ll need to create a container. We’ll do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we did in the previous section works and can be used without problems.
    However, we would like to consider a more general solution that we can apply to
    any data type. Since not all things in JavaScript provide the desired `map()`
    method, we will have to either extend the type (as we did in the previous section)
    or apply a design pattern that we considered in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*: wrapping our data types with a wrapper that will
    provide the required `map()` operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by seeing how to build a basic container, wrapping a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the container into something more powerful—a functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Study how to deal with missing values using a special functor, `Maybe`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping a value – a basic container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s pause for a minute and consider what we need from this wrapper. There
    are two basic requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have a `map()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a simple way to wrap a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, let’s create a basic container. Any object containing just
    a value would do, but we want some additions, so our object won’t be that trivial;
    we’ll explain the differences after the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Some primary considerations that we need to keep in mind are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to store some value in a container, so the constructor takes
    care of that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `protected` attribute avoids “tinkering” from the outside, but allows
    access to subclasses. (See *Question 12.2* for some JavaScript considerations.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to `map()`, so a method is provided for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our barebones container is ready, but we can also add some other methods for
    convenience, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To get the value of a container, we could use `map((x) => x)`, but that won’t
    work with more complex containers, so we’ll add a `valueOf()` method to get the
    contained value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to list a container can undoubtedly help with debugging. The `toString()`
    method will come in handy for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we don’t need to write `new Container()` all the time, we can add a
    static `of()` method to do the same job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functional sin?
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes to represent containers (and later, functors and monads)
    when living in a FP world may seem like heresy or sin... but remember that we
    don’t want to be dogmatic, and using classes simplifies our coding. Similarly,
    it could be argued that you must never take a value out of the container—but using
    a `valueOf()` method is sometimes too handy, so we won’t be that restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: 'By taking all of this into account, our container is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use this container to store a value, and `map()` to apply any function
    to that value, but this isn’t very different from what we could do with a variable!
    Let’s enhance this a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our container – functors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to have wrapped values, so what exactly should `map()` return? If we
    want to be able to chain operations, the only logical answer is that it should
    return a new wrapped object. In true functional style, when we apply a mapping
    to a wrapped value, the result will be another wrapped value that we can keep
    working on.
  prefs: []
  type: TYPE_NORMAL
- en: A map by any other name
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `map()`, this operation is sometimes called `fmap()`, standing for
    *functorial map*. The rationale for the name change was to avoid expanding the
    meaning of `map()`. However, since we are working in a language that supports
    reusing the name, we can keep it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend our `Container` class to implement this change and get ourselves
    an enhanced container: a *functor*. The `of()` and `map()` methods will require
    a small change. For this, we’ll be creating a new class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `of()` method produces a `Functor` object, and so does the `map()`
    method. With these changes, we have just defined what a *functor* is in category
    theory! (Or, if you want to get really technical, a *pointed functor* because
    of the `of()` method—but let’s keep it simple.) We won’t go into the theoretical
    details, but roughly speaking, a functor is some container that allows us to apply
    `map()` to its contents, producing a new container of the same type. If this sounds
    familiar, it’s because you already know a functor: arrays! When you apply `map()`
    to an array, the result is a new array containing transformed (mapped) values.'
  prefs: []
  type: TYPE_NORMAL
- en: Extra requirements
  prefs: []
  type: TYPE_NORMAL
- en: There are more requirements for functors. First, the contained values may be
    polymorphic (of any type), just like arrays. Second, a function must exist whose
    mapping produces the same contained value—`(x) => x` does this for us. Finally,
    applying two consecutive mappings must produce the same result as applying their
    composition. This means that `container.map(f).map(g)` must be the same as `container.map(compose(g,f))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pause for a moment and consider the signatures for our function and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function, `of()`, is the simplest: given a value of any type, it
    produces a functor of that type. The following two are also relatively simple
    to understand: given a functor, `toString()` always returns a string (no surprise
    there!), and if the functor-contained value is of a given type, `valueOf()` produces
    a result of that same type. The third one, `map()`, is more interesting. Given
    a function that takes an argument of type `a` and produces a result of type `b`,
    applying it to a functor that contains a value of type `a` produces a functor
    containing a value of type `b`. This is precisely what we described previously.'
  prefs: []
  type: TYPE_NORMAL
- en: Promises and Functors
  prefs: []
  type: TYPE_NORMAL
- en: You could compare functors to promises, at least in one aspect. With functors,
    instead of acting on its value directly, you have to apply a function with `map()`.
    In promises, you do exactly the same, but using `then()` instead! In fact, there
    are more analogies, as we’ll be seeing soon.
  prefs: []
  type: TYPE_NORMAL
- en: As is, functors are not allowed or expected to produce side effects, throw exceptions,
    or exhibit any other behavior outside of producing a container-ed result. Their
    main usage is to provide us with a way to manipulate a value, apply operations
    to it, compose results, and so on, without changing the original value—in this
    sense, we are once again coming back to immutability.
  prefs: []
  type: TYPE_NORMAL
- en: However, you could reasonably say that this isn’t enough since, in everyday
    programming, it’s pretty common to have to deal with exceptions, undefined or
    null values, and so on. So, let’s start by looking at more examples of functors.
    After that, we’ll enter the realm of monads to look at even more sophisticated
    processing. Let’s experiment a bit!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing values with Maybe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common problem in programming is dealing with missing values. There are many
    possible causes for this situation: a web service Ajax call may have returned
    an empty result, a dataset could be empty, an optional attribute might be missing
    from an object, and so on. In a normal imperative fashion, dealing with this kind
    of situation requires adding `if` statements or ternary operators everywhere to
    catch the possible missing value to avoid a certain runtime error. We can do better
    by implementing a `Maybe` functor to represent a value that may (or may *not*)
    be present! We will use two classes, `Just` (as in *just some value*) and `Nothing`,
    both of which are functors. The `Nothing` functor is particularly simple, with
    trivial methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `isNothing()` method returns `true`, `toString()` returns constant text,
    and `map()` always returns itself, no matter what function it’s given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, the `Just` functor is also a basic one, with the added `isNothing()`
    method (which always returns `false`, since a `Just` object isn’t `Nothing`),
    and a `map()` method that now returns `Maybe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `Maybe` class packs the logic needed to construct either `Nothing`
    or `Just`. If it receives an `undefined` or `null` value, `Nothing` will be constructed;
    in other cases, `Just` will be the result. The `of()` method has exactly the same
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using an `abstract` class because you shouldn’t directly write `new
    Maybe(…)`; you should use `Maybe.of()` or directly build `Just` or `Nothing`.
    (If you are wondering how to do this in JavaScript, see *Question 12.3*.) We can
    quickly verify that this works by trying to apply an operation to either a valid
    value or a missing one. Let’s look at two examples of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When we applied `plus1()` (twice) to `Maybe.of(2209)`, everything worked fine,
    and we ended up with a `Just(2011)` value. On the other hand, when we applied
    the same sequence of operations to a `Maybe.of(null)` value, the end result was
    `Nothing`, but there were no errors, even if we tried to do math with a `null`
    value. A `Maybe` functor can deal with mapping a missing value by just skipping
    the operation and returning a wrapped `null` value instead. This means that this
    functor includes an abstracted check, which won’t let an error happen.
  prefs: []
  type: TYPE_NORMAL
- en: (Later in this chapter, we’ll see that `Maybe` can actually be a monad instead
    of a functor, and we’ll also examine more examples of monads.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a more realistic example of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with varying API results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we are writing a small server-side service in Node.js to get the weather
    alerts for a city and produce a not-very-fashionable HTML `<table>` with them,
    to be part of some server-side-produced web page. (Yes, I know you should try
    to avoid tables in your pages, but I want a short example of HTML generation,
    and the actual results aren’t significant.) If we used the *Dark Sky* API (see
    [darksky.net](http://darksky.net) for more on this API and how to register with
    it) to get the alarms, our code would be something like the following, all quite
    normal. Note the callback in case of an error; you’ll see why in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The (heavily edited and reduced in size) output of such a call might be something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I got this information for Houston, TX, US, on a day when Hurricane Harvey
    was approaching the state. If you called the API on a normal day, the data would
    not include the `alerts:[...]` part. Here, we can use a `Maybe` functor to process
    the received data without any problems, with or without any alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you would probably do something more interesting than just logging
    the value of the contained result of `produceAlertsTable()`! The most likely option
    would be to use `map()` again with a function that would output the table, send
    it to a client, or do whatever you needed to do. In any case, the resulting output
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The output table is not much to look at, but the logic that
    produced it didn’t require a single if statement](img/Figure_12.1_B9301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The output table is not much to look at, but the logic that produced
    it didn’t require a single if statement
  prefs: []
  type: TYPE_NORMAL
- en: If we had called `getAlerts(-34.9, -54.60, ...)` with the coordinates for Montevideo,
    Uruguay, instead, since there were no alerts for that city, the `getField("alerts")`
    function would have returned `undefined`—and since that value is recognized by
    the `Maybe` functor, and even though all the following `map()` operations would
    still be executed, no one would actually do anything, and a `null` value would
    be the final result.
  prefs: []
  type: TYPE_NORMAL
- en: We took advantage of this behavior when we coded the error logic. If an error
    occurs when calling the service, we would still call the original callback to
    produce a table but provide an empty object. Even if this result is unexpected,
    we would be safe because the same guards would avoid causing a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final enhancement, we can add an `orElse()` method to provide a default
    value when no value is provided. The added method will return the default value
    if `Maybe` is `Nothing`, or the `Maybe` value itself otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this new method instead of `valueOf()`, trying to get the alerts for
    someplace without weather warnings would just return a default result. In the
    case we mentioned previously, attempting to get the alerts for Montevideo, instead
    of a `null` value, we would get the following appropriate result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have looked at an example of dealing with different situations
    when working with an API. Let’s quickly revisit another topic from a previous
    chapter and look at a better implementation of prisms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing prisms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The more common implementations of prisms (which we first met in the *Prisms*
    section of [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188)*, Ensuring Purity*),
    instead of returning either some value or `undefined` and leaving it up to the
    caller to check what happened, opt to return `Maybe`, which already provides us
    with easy ways to deal with missing values. In our new implementation (which we’ll
    look at soon), our example from the aforementioned chapter would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to access the `author.user` attribute, the result would be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if we asked for a non-existent pseudonym attribute, instead of `undefined`
    (as in our previous version of `Prism`), we would get `Nothing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this new version of `Prism` is better to work with if you are already used
    to dealing with `Maybe` values. What do we need to implement this? We need just
    a single change; our `Constant` class now needs to return `Maybe` instead of a
    value, so we’ll have a new `ConstantP` (`P` for `Prism`) class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have to rewrite `preview()` to use the new class, and that finishes
    the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'So, getting `Prism` to work with `Maybe` wasn’t that hard, and now we have
    a consistent way of dealing with possibly missing attributes. Working in this
    fashion, we can simplify our coding and avoid many tests for nulls and other similar
    situations. However, we may want to go beyond this; for instance, we may want
    to know why there were no alerts: was it a service error? Or just a normal situation?
    Just getting null at the end isn’t enough, and to work with these new requirements,
    we will need to add some extra functionality to our functors (as we’ll see in
    the next section) and enter the domain of *monads*.'
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monads have weird fame among programmers. Well-known developer Douglas Crockford
    has famously spoken of a curse, maintaining that “*Once you happen to finally
    understand monads, you immediately lose the ability to explain them to other people!*
    ” On a different note, if you decide to go back to the basics and read *Categories
    for the Working Mathematician* by Saunders Mac Lane (one of the creators of category
    theory), you may find a somewhat disconcerting explanation—which is not too illuminating!
  prefs: []
  type: TYPE_NORMAL
- en: A monad in X is just a monoid in the category of endofunctors of X, with product
    × replaced by composition of endofunctors and unit set by the identity endofunctor.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between monads and functors is that the former adds some extra
    functionality; we’ll see what functionality they add soon. Let’s start by looking
    at the new requirements before moving on and considering some common, useful monads.
    As with functors, we will have a basic monad, which you could consider an *abstract*
    version, and specific *monadic types*, which are *concrete* implementations geared
    to solve specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: All you could want to read
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a precise and careful description of functors, monads, and their family
    (but leaning heavily to the theoretical side, with plenty of algebraic definitions
    to go around), try the *Fantasy Land Specification* at [github.com/fantasyland/fantasy-land/](http://github.com/fantasyland/fantasy-land/).
    Please don’t say we didn’t warn you: the alternative name for that page is *Algebraic*
    *JavaScript Specification*!'
  prefs: []
  type: TYPE_NORMAL
- en: Adding operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider a simple problem. Suppose you have the following pair of functions,
    working with `Maybe` functors: the first function tries to search for something
    (say, a client or a product) given its key, and the second attempts to extract
    some attribute from whatever we found (I’m being purposefully vague because the
    problem does not have anything to do with whatever objects or things we may be
    working with). Both functions produce `Maybe` results to avoid possible errors.
    We are using a mocked search function just to help us see the problem. For even
    keys, it returns fake data, and for odd keys, it throws an exception. The code
    for this search is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this search, our `findSomething()` function will try to do a search and
    return `Maybe.of()` (a `Just`) for a successful call, or `Maybe.of(null)` (a `Nothing`)
    in case of an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With this, we could think of writing these two functions to do some searching,
    but not everything would be fine; can you see the problem here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem in this sequence is that the output from `getSome()` is a `Maybe`
    value, which itself contains a `Maybe` value, so the result we want is double-wrapped,
    as we can see by executing a couple of calls, for an even number (which will return
    `"whatever"`) and for an odd number (which will be an error), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem can be easily solved in this toy problem if we avoid using `Maybe.of()`
    in `getSome()`, but this kind of issue can arise in many more complex ways. For
    instance, you could be building a `Maybe` out of an object, one of whose attributes
    happened to be a `Maybe`, and you’d end up in the same situation when accessing
    that attribute: you would end up with a double-wrapped value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to look into monads. A monad should provide the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that inserts a value into a monad: our `of()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that allows us to chain operations: our `map()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that can remove extra wrappers: we will call it `unwrap()`. It will
    solve our preceding multiple wrapper problems. Sometimes, this function is called
    `flatten()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To simplify our coding, we will also have a function to chain calls and another
    function to apply functions, but we’ll get to those later. Let’s see what a monad
    looks like in actual JavaScript code. Data type specifications are very much like
    those for functors, so we won’t repeat them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We use recursion to successively remove wrappers until the wrapped value isn’t
    a container anymore. Using this method, we could avoid double wrapping easily,
    and we could rewrite our previous troublesome function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this sort of problem could reoccur at different levels. For example,
    if we were doing a series of `map()` operations, any intermediate results may
    end up double-wrapped. You could solve this by remembering to call `unwrap()`
    after each `map()`—note that you could do this even if it is not actually needed
    since the result of `unwrap()` would be the very same object (can you see why?).
    But we can do better! Let’s define a `chain()` operation (sometimes named `flatMap()`
    instead, which is a bit confusing since we already have another meaning for that;
    see [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    for more on this) that will do both things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There’s only one operation left. Suppose you have a curried function with two
    parameters—nothing outlandish! What would happen if you provided that function
    to a `map()` operation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'What would `something` be? Given that we have only provided one argument to
    add, the result of that application will be a function—not just any function,
    though, but a wrapped one! (Since functions are first-class objects, there’s no
    logical obstacle to wrapping a function in a monad, is there?) What would we want
    to do with such a function? To be able to apply this wrapped function to a value,
    we’ll need a new method: `ap()`. What could its value be? In this case, it could
    either be a plain number or a number wrapped in a monad as a result of other operations.
    Since we can always map a plain number into a wrapped one with `Map.of()`, let’s
    have `ap()` work with a monad as its parameter; the new method would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, you could then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can use monads to hold values or functions and to interact with other monads
    and chaining operations as you wish. So, as you can see, there’s no big trick
    to monads, which are just functors with some extra methods. Now, let’s look at
    how we can apply them to our original problem and handle errors in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Handling alternatives – the Either monad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Knowing that a value was missing may be enough in some cases, but in others,
    you’ll want to be able to provide an explanation. We can get such an explanation
    if we use a different functor, which will take one of two possible values—one
    associated with a problem, error, or failure, and another associated with normal
    execution, or success:'
  prefs: []
  type: TYPE_NORMAL
- en: A *left* value, which should be null, but if present, then it represents some
    special value (for example, an error message or a thrown exception) that cannot
    be mapped over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *right* value, which represents the normal value of the functor and can be
    mapped over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can construct this monad similarly to what we did for `Maybe` (actually,
    the added operations make it better for `Maybe` to extend `Monad` as well). The
    constructor will receive a left and a right value. If the left value is present,
    it will become the value of the `Either` monad; otherwise, the right value will
    be used. Since we have provided `of()` methods for all our functors, we need one
    for `Either` too. The `Left` monad is very similar to our previous `Nothing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `Right` resembles our previous `Just`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And with these two monads under our belt, we can write our `Either` monad. It
    shouldn’t be surprising that this resembles our previous `Maybe`, should it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map()` method is key. If this functor has got a left value, it won’t be
    processed any further; in other cases, the mapping will be applied to the right
    value, and the result will be wrapped. Now, how can we enhance our code with this?
    The key idea is for every involved method to return an `Either` monad; `chain()`
    will be used to execute operations one after another. Getting the alerts would
    be the first step—we invoke the callback either with an `AJAX FAILURE` message
    or with the result from the API call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the general process would be as follows. We use an `Either` monad again.
    If there are no alerts, instead of an array, we will return a `"NO` `ALERTS"`
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note how we used `chain()` so that multiple wrappers would be no problem. Now,
    we can test multiple situations and get appropriate results—or at least, for the
    current weather situation around the world!
  prefs: []
  type: TYPE_NORMAL
- en: For Houston, TX, we still get an HTML table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Montevideo, UY, we get a text saying there were no alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a point with wrong coordinates, we learn that the AJAX call failed: nice!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We are not done with the `Either` monad. It’s likely that much of your code
    will involve calling functions. Let’s look at a better way of achieving this by
    using a variant of this monad.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function – the Try monad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are calling functions that may throw exceptions and we want to do so
    in a functional way, we could use the `Try` monad to encapsulate the function
    result or the exception. The idea is basically the same as the `Either` monad.
    The only difference is in the constructor, which receives a function and calls
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no problems, the returned value becomes the `right` value for the
    monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there’s an exception, it will become the `left` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Why the `@ts-expect-error` notation? A constructor should either call `super()`
    or return a fully constructed method, but TypeScript always expects the former,
    so we have to tell it that we know what we’re doing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can invoke any function, catching exceptions in a good way. For example,
    the `getField()` function that we have been using would crash if it were called
    with a `null` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *Implementing prisms* section of [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, we wrote a `getFieldP()` function that could deal with `null`
    values, but here, we will rewrite it using the `Try` monad, so, in addition, it
    will play nice with other composed functions. The alternative implementation of
    our getter would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check that this works by trying to apply our new function to a null
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There are many more monads, and, of course, you can even define your own, so
    we couldn’t possibly go over all of them. However, let’s visit just one more—one
    you have been using already, without being aware of its monad-ness!
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected monads – promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s finish this section on monads by mentioning yet another one that you
    may have used, though under a different name: promises! Previously, we mentioned
    that functors (and, remember, monads are functors) had at least something in common
    with promises: using a method to access the value. However, the similarities are
    greater than that!'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.resolve()` corresponds with `Monad.of()`—if you pass a value to `.resolve()`,
    you’ll get a promise resolved to that value, and if you provide a promise, you
    will get a new promise, the value of which will be that of the original one (see
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
    for more on this). This is an unwrapping behavior!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Promise.then()` stands for `Monad.map()` as well as `Monad.chain()`, given
    the mentioned unwrapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We don’t have a direct match to `Monad.ap()`, but we could add something like
    the following code (this will be rejected by TypeScript, but we’ve seen how to
    solve this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Promises – never gone
  prefs: []
  type: TYPE_NORMAL
- en: Even if you opt for the modern `async` and `await` features, internally, they
    are based on promises. Furthermore, in some situations, you may still need `Promise.race()`
    and `Promise.all()`, so you will likely keep using promises, even if you opt for
    full ES8 coding.
  prefs: []
  type: TYPE_NORMAL
- en: This is an appropriate ending for this section. Earlier, you found that ordinary
    arrays were, in fact, functors. Now, in the same way that Monsieur Jourdain (a
    character in Molière’s play *Le Bourgeois Gentilhomme*, *The Bourgeois Gentleman*)
    discovered that all his life he had been speaking in prose, you now know you had
    already been using monads without even knowing it! So far, we have learned how
    to build different types of containers. Now, let’s learn how functions can also
    make do as containers, as well as for all kinds of data structures!
  prefs: []
  type: TYPE_NORMAL
- en: Functions as data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to use functions to work with or transform other
    functions to process data structures or to create data types. Now, we’ll finish
    this chapter by showing you how a function can implement a data type, becoming
    a container of its own. In fact, this is a fundamental theoretical point of lambda
    calculus (if you want to learn more, look up *Church encoding* and *Scott encoding*),
    so we may very well say that we have come back to where we began this book, to
    the origins of FP! We will start with a detour that considers binary trees in
    a different functional language, Haskell, and then move on to implementing trees
    as functions, but in JavaScript. This experience will help you work out how to
    deal with other data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Binary trees in Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a binary tree. Such a tree may either be empty or consist of a node
    (the tree *root*) with two children: a *left* binary tree and a *right* one. A
    node that has no children is called a *leaf*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of many types of trees
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, we
    worked with more general tree structures, such as a filesystem or the browser
    DOM itself, which allow a node to have any number of children. In the case of
    the trees in this section, each node always has two children, although each of
    them may be empty. The difference may seem minor, but allowing for empty subtrees
    lets you define that all nodes are binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a digression with the Haskell language. In it, we might write something
    like the following; `a` would be the type of whatever value we hold in the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Haskell language, pattern matching is often used for coding. For example,
    we could define an empty function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this mean? Apart from the data type definition, the logic is simple:
    if the tree is `Nil` (the first possibility in the definition of the type), then
    the tree is certainly empty; otherwise, the tree isn’t empty. The last line would
    probably be written as `empty _ = False`, using `_` as a placeholder because you
    don’t actually care about the components of the tree; the mere fact that it’s
    not `Nil` suffices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for a value in a binary search tree (in which the root is greater
    than all the values of its left subtree and less than all the values of its right
    subtree) would be written similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'What patterns are matched here? We have four patterns now, which must be considered
    in order:'
  prefs: []
  type: TYPE_NORMAL
- en: An empty tree (`Nil`—it doesn’t matter what we are looking for, so just write
    `_`) doesn’t contain the searched value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the tree isn’t empty, and the root matches the searched value (`x`), we are
    done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the root doesn’t match and is greater than the searched value, the answer
    is found while searching in the left subtree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the answer is found by searching in the right subtree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There’s an important point to remember: for this data type, which is a union
    of two possible types, we have to provide two conditions, and pattern matching
    will be used to decide which one will be applied. Keep this in mind!'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as binary trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can we do something similar with functions? The answer is yes: we will represent
    a tree (or any other structure) with a function itself—not with a data structure
    that is processed by a set of functions, nor with an object with some methods,
    but by just a function. Furthermore, we will get a functional data structure that’s
    100% immutable, which, if updated, produces a new copy of itself. We will do all
    this without using objects; here, closures will provide the desired results.'
  prefs: []
  type: TYPE_NORMAL
- en: How can this work? We shall be applying similar concepts to the ones we looked
    at earlier in this chapter, so the function will act as a container and produce,
    as its result, a mapping of its contained values. Let’s walk backward and start
    by looking at how we’ll use the new data type. Then, we’ll go through the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a tree can be done by using two functions: `EmptyTree()` and `Tree(value,
    leftTree, rightTree)`. For example, let’s say we wish to create a tree similar
    to the one shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.2 – A binary search tree\uFEFF](img/Figure_12.2_B19301.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – A binary search tree
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'How do you work with this structure? According to the data type description,
    whenever you work with a tree, you must consider two cases: a non-empty tree and
    an empty one. In the preceding code, `myTree()` is a function that receives two
    functions as arguments, one for each of the two data type cases. The first function
    will be called with the node value and left and right trees as arguments, while
    the second function will receive none:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the root of a tree, we could write something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If we were dealing with a non-empty tree, we would expect the first function
    to be called and return the value of the root. With an empty tree, the second
    function should be called, and then a `null` value would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we wanted to count how many nodes there are in a tree, we would
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For non-empty trees, the first function would return `1` (for the root), plus
    the node count from both the root’s subtrees. For empty trees, the count is simply
    `0`. Get the idea?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can show the `NewTree()` and `EmptyTree()` functions. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `destructure()` function is what you will pass as an argument (the name
    comes from the destructuring statement in JavaScript, which lets you separate
    an object attribute into distinct variables). You will have to provide two versions
    of this function. If the tree is non-empty, the first function will be executed;
    for an empty tree, the second one will be run (this mimics the case selection
    in the Haskell code, except we are placing the non-empty tree case first and the
    empty tree last). The underscore-named variable is used as a placeholder that
    stands for an otherwise-ignored argument but shows that two arguments are assumed;
    an initial underscore is usually meant to imply some parameter isn’t used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be hard to understand, so let’s look at more examples. If we need
    to access specific elements of a tree, we have the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we decide whether a tree is empty? See whether you can figure out why
    the following short line of code works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go over a few more examples of this. For example, we can build an object
    out of a tree, which would help with debugging. I added logic to avoid including
    left or right empty subtrees, so the produced object would be more compact; check
    out the two `if` statements in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the usage of recursion, as in the *Traversing a tree structure* section
    of [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), Designing Functions, to produce
    the object equivalents of the left and right subtrees. An example of this function
    is as follows; I edited the output to make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we search for a node? Of course, and the logic closely follows the definition
    we saw in the previous section. (We could have shortened the code a bit, but I
    wanted to parallel the Haskell version; for a leaner version, see *Question 12.6*.)
    Our `treeSearch()` function could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If the value we want is the root, we found it; if it’s smaller than the root,
    we recursively search the left subtree, and if greater, the right subtree.
  prefs: []
  type: TYPE_NORMAL
- en: 'To round off this section, let’s also look at how to add new nodes to a tree.
    Study the code carefully; you’ll notice how the current tree isn’t modified and
    that a new one is produced instead. Of course, given that we are using functions
    to represent our tree data type, it should be evident that we wouldn’t have been
    able to modify the old structure: it’s immutable by default. The tree insertion
    function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: When trying to insert a new key, if its value is less than or equal to the root
    of the tree, we produce a new tree that has the current root as its own root,
    maintains the old right subtree, but changes its left subtree to incorporate the
    new value (which will be done recursively). If the key was greater than the root,
    the changes wouldn’t have been symmetrical; they would have been analogous. If
    we try to insert a new key and find ourselves with an empty tree, we replace that
    empty structure with a new tree having the new value at its root, and empty left
    and right subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test out this logic easily, but the simplest way is to verify that the
    binary tree that we showed earlier (*Figure 12**.2*) is generated by the following
    sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We could make this insertion function even more general by providing the comparator
    function that would be used to compare values. In this fashion, we could easily
    adapt a binary tree to represent a generic map. The value of a node would actually
    be an object such as `{key:... , data:...}` and the provided function would compare
    `newValue.key` and `value.key` to decide where to add the new node. Of course,
    if the two keys were equal, we would change the root of the current tree. The
    new tree insertion code would be as follows. Let’s start with types and comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The tree insertion code is now the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'What else do we need? Of course, we can program diverse functions: deleting
    a node, counting nodes, determining a tree’s height, comparing two trees, and
    so on. However, in order to gain more usability, we should really turn the structure
    into a functor by implementing a `map()` function. Fortunately, using recursion,
    this proves to be easy—we apply the mapping function to the tree root and use
    `map()` recursively on the left and right subtrees, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We could go on with more examples, but that wouldn’t change the important conclusions
    we can derive from this work:'
  prefs: []
  type: TYPE_NORMAL
- en: We are handling a data structure (a recursive one, at that) and representing
    it with a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We aren’t using external variables or objects for the data: closures are used
    instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data structure satisfies all the requirements we analyzed in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, insofar that it is immutable and all the changes always produce
    new structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tree is a functor, providing all the corresponding advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have looked at one more application of FP as well as how
    a function can actually become a structure by itself, which isn’t what we are
    usually accustomed to!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the theory of data types and learned how to use
    and implement them from a functional point of view. We started with defining function
    signatures to help us understand the transformations implied by the multiple operations
    we looked at later, with a syntax independent from TypeScript’s. Then, we went
    on to define several containers, including functors and monads, and saw how they
    can be used to enhance function composition. Finally, we learned how functions
    can be directly used by themselves, with no extra baggage, to implement functional
    data structures to simplify dealing with errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we have looked at several features of FP for JavaScript and TypeScript.
    We started with some definitions, and a practical example, then moved on to important
    considerations such as pure functions, avoiding side effects, immutability, testability,
    building new functions out of other ones, and implementing a data flow based upon
    function connections and data containers. We have looked at a lot of concepts,
    but I’m confident that you’ll be able to put them to practice and start writing
    even higher-quality code—give it a try, and thank you very much for reading this
    book!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1 `global` declaration; can you add that declaration?
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 `Symbol`!
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 `Maybe` and `Either` monads, but those types of classes are only available
    in TypeScript. Can you figure out an alternative way of working, but in JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 `Maybe` or `Either` monad to simplify that code.
  prefs: []
  type: TYPE_NORMAL
- en: '12.5 **Extending your trees**: To get a more complete implementation of our
    functional binary search trees, implement the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the tree’s height or, equivalently, the maximum distance from the
    root to any other node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all the tree’s keys, in ascending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a key from a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6 `treeSearch()` function could be shortened—can you do that? Yes, this is
    more of a JavaScript problem than a functional one, and I’m not saying that shorter
    code is necessarily better, but many programmers act as if it were, so it’s good
    to be aware of such a style if only because you’re likely to find it.
  prefs: []
  type: TYPE_NORMAL
- en: '12.7 **Functional lists**: In the same spirit as binary trees, implement functional
    lists. Since a list is defined to be either empty or a node (*head*), followed
    by another list (*tail*), you might want to start with the following, quite similar
    to our binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some easy one-line operations to get you started; note they are very
    similar in style to what we wrote for binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'You could consider having these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a list into an array and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appending one list to the end of another list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating two lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t forget a `listMap()` function! Also, the `listReduce()` and `listFilter()`
    functions will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 `true` and `false` Boolean values, but we didn’t have any operators such
    as `&&`, `||`, or `!`. While we could make up for their absence with some (possibly
    repetitive) coding, we can have functions produce the same results; can you see
    how? Think along the same lines as for binary trees. We could represent a Boolean
    value by a function that takes a pair of functions as arguments and applies the
    first if the Boolean is true, and the second otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Answers to Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions (partial, or worked out in full) to the questions that
    were contained within the chapters in this book. In many cases, there are extra
    questions so that you can do further work if you choose to.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1, Becoming Functional – Several Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '1.1 **TypeScript, please!** The following are the fully annotated versions
    of the code in the chapter. This is the code for the factorial functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the spreading examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Why do we need to specify the type of `x`, but not those of `f`, `g`, `h`, `p`,
    and `q`? The issue is that TypeScript checks the call to `sum3()`, and for that,
    it needs to be sure that `x` is defined to be an array with three numbers.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript would be able to deduce that `sum3()` returns a number, but it’s
    best if you specify it, to prevent possible future bugs where you would return
    something that isn’t a number.
  prefs: []
  type: TYPE_NORMAL
- en: The `newCounter()` function needs no type definitions; TypeScript is able to
    work types out. (See *Question 1.7* further on.)
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 `new`. Therefore, it stands to reason that we should be able to pass classes
    as parameters to other functions. `makeSaluteClass()` creates a class (that is,
    a special function) that uses a closure to remember the value of `term`. We have
    looked at more examples like this throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript code for the class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note the usage of TypeScript’s `ReturnType<>` utility type to specify that `c`
    will be something created by calling `makeSaluteClass()`.
  prefs: []
  type: TYPE_NORMAL
- en: '1.3 `f`, and we make it climb from `1` to `n`. We must be careful so that `factUp(0)
    ===` `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to specify that `f` is of type `number`; TypeScript automatically
    works that out.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution may worry you because nobody prevents calling `factUp()` with
    two arguments – but we need the second parameter to be omitted, so it will be
    initialized to `1`. We can solve this defect as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The internal `factAux()` function is basically our previous `factUp()` function,
    except that it doesn’t need the `n` parameter, because it’s available in its scope.
    Our new `factUp2()` function calls `factAux()`, providing its needed default value
    of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like having a default value, you can go with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: To test these functions, the tests (for correct values) in *Question 1.5* will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: '1.4 **Factorial errors**: The key to avoiding repeating tests is to write a
    function that will check the value of the argument to ensure it’s valid, and if
    so, call an inner function to do the factorial itself, without worrying about
    erroneous arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In order, we check that `n` must be a number, not negative, and an integer.
    When an incorrect argument is recognized, we throw an error. By the way, that’s
    the reason for the `number | never` type specification; the user of this function
    directly recognizes that sometimes (namely, when an exception is thrown) no value
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '1.5 **Factorial testing**: The following tests do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Running the suite shows we achieved 100% coverage.
  prefs: []
  type: TYPE_NORMAL
- en: '1.6 `++` operator (for more information, see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment)),
    you can condense `newCounter()` down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Using arrow functions isn’t hard to understand, but be aware that many developers
    may have questions or doubts about using `++` as a prefix operator, so this version
    could prove to be harder to understand.
  prefs: []
  type: TYPE_NORMAL
- en: ESLint has a `no-plusplus` rule that disallows both `++` and `--`. Since I do
    approve of using them, I had to disable the rule; see [eslint.org/docs/latest/user-guide/configuring/rules](http://eslint.org/docs/latest/user-guide/configuring/rules)
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 `newCounter()` takes no arguments and returns a number, the answer is `()
    =>` `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working with Visual Studio Code, there’s a quicker way of doing
    this: hovering will provide the answer, as in *Figure 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1 – Visual Studio Code helps with typing](img/Figure_1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1 – Visual Studio Code helps with typing
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2, Thinking Functionally – A First Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2.1 `fn` variable itself as a flag. After calling `fn()`, we set the variable
    to `null`. Before calling `fn()`, we check that it’s not `null` by using the short-circuit
    `&&` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We need a small change to let TypeScript know that `fn` could be `null`; otherwise,
    it would object to the `fn =` `null` assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '2.2 **Alternating functions**: Like what we did in the previous question, we
    swap functions, and then we do the call. Here, we use a destructuring assignment
    to write the swap more compactly. For more information, refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write a test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We set up two mock functions, one will return `"A"` and the other `"B"`, and
    then we test that successive calls alternate between those two values.
  prefs: []
  type: TYPE_NORMAL
- en: '2.3 `limit` is greater than `0`. If so, we decrement it by 1 and call the original
    function; otherwise, we do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write a test for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Our `testFn()` function is set to call `fn()` twice, no more; the tests confirm
    that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '2.4 `once()`, so if `fn()` crashes, we’ll reset `done` to `false` to allow
    a new attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this works with a simple example; our `crashTwice()` function will
    throw an error twice and work fine afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to check two cases: when the called function works normally and when
    it crashes at least once. The first case is just like the test we wrote for `once()`,
    so nothing is new here. For the second case, we set up a mock `myFn()` function
    that throws errors twice and returns a regular value afterward; the test verifies
    the expected behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '2.5 **Say no to arrows**: The code is essentially the same, but the placement
    of type information varies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 3, Starting Out with Functions – A Core Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3.1 `type` is considered to be labeling a statement, which doesn’t really do
    anything: it’s a `(t)` expression that isn’t used. Due to this, the code is considered
    valid, and since it doesn’t have an explicit `return` statement, the implicit
    returned value is `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The corrected code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
    for more on labels, and developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals
    for more on returning objects.
  prefs: []
  type: TYPE_NORMAL
- en: '3.2 `useArguments2()`, but with `useArguments()`, you would get an error since
    arguments are not defined for arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '3.3 **Three more types**: We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fn1` is `(y: number) => (z: number) =>` `number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn2` is `(z: number) =>` `number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn3` is just `number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3.4 **One-liner**: It works! (Yes, a one-line answer is appropriate in this
    case!)'
  prefs: []
  type: TYPE_NORMAL
- en: '3.5 `State`, we’d have an object with all the fields needed for your application.
    For a generic version, we could write the following, but a specific description
    would be much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We would define all the possible action types with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We’d have an object with `type` and an optional `payload` for actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: (It would be much better if you defined in detail what possible payloads you
    could have, instead of going with a generic definition as in the preceding code.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `doAction()` function would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'For `dispatchTable`, we’d have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '3.6 `console(...), window.store.set(...)`) code, but the bug isn’t there: because
    of how the comma operator works, JavaScript does the logging first, and then the
    setting. The real problem is that `oldSet()` is not bound to the `window.store`
    object, so the second line should be as follows instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Reread the *Working with methods* section for more on this, and see *Question
    11.1* for another way of doing logging – that is, with decorators.
  prefs: []
  type: TYPE_NORMAL
- en: '3.7 `bind()` wasn’t available, you could use a closure, the `that` trick (which
    we saw in the *Handling the this value* section), and the `apply()` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We could do something similar to what we did in the *Adding missing* *functions*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, just for variety, we could use a common idiom based on the `||`
    operator: if `Function.prototype.bind` exists, evaluation stops right there, and
    the existing `bind()` method is used; otherwise, our new function is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 3.8 `compare(a,b)` comparison function must return a positive number if `a>b`,
    a negative number if `a<b`, or `0` if `a` equals `b`. When you subtract `ab`,
    you get that result, so it works. (Of course, this assumes that no number is either
    `Infinity` or `NaN`.) For more on this, check [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description).
  prefs: []
  type: TYPE_NORMAL
- en: '3.9 `-`”, so that’s kind of right, but the numbers themselves are still sorted
    as strings, so the result is wrong anyway. In the following example, the lowest
    number is `-666`, which should have been the first element after sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '3.10 **Lexicographic sorting**: Let’s suppose we have an array of strings.
    To sort it lexicographically in an efficient way, a solution would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform the array of strings into an array of objects with an added `sortBy`
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each string, generate the corresponding string to sort by, and put the value
    in the `sortBy` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the array by `sortBy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop the added field to convert the sorted array into an array of strings as
    originally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3.11 `console.log()` method can accept any number of arguments of any type,
    and won’t return anything, so its type is `(...args:` `any[]): void`.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4, Behaving Properly – Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1 **Must return?** If a pure function doesn’t return anything, it means that
    the function doesn’t do anything since it can’t modify its inputs and doesn’t
    have any other side effect.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 `string | undefined`, because the `.pop()` method returns `undefined` if
    the input array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '4.3 `fib2()` in an IIFE; `fibC()` is equivalent to `fib2()` but with an internal
    `cache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '4.4 **Minimalistic function**: It works because fib(0)=0 and fib(1)=1, so it’s
    true that for *n*<2, fib(*n*) equals *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 `a` and `b` stand for two consecutive Fibonacci numbers. This implementation
    is quite efficient!
  prefs: []
  type: TYPE_NORMAL
- en: '4.6 **Rounding type**: The full definition, including the result type, would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '4.7 **Tuples to go**: In this case, we would return an array with two numbers,
    so we may write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests are very similar to what we already wrote; here, we have abridged
    versions of our previous code, highlighting the needed changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 4.8 `calculateDeb2()` would still attempt to call the API. Providing an object
    with the dependencies makes injection an *all-or-nothing* option.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 `"Math failure?"` message. The problem has to do with the fact that JavaScript
    internally uses binary instead of decimal, and floating-point precision is limited.
    In decimal, 0.1, 0.2, and 0.3 have a fixed, short representation, but in binary,
    they have infinite representation, much like 1/3=0.33333... has in decimal. If
    you write out the value of `a+b` after the test, you’ll get 0.30000000000000004
    – and that’s why you must be very careful when testing for equality in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '4.10 **Breaking laws**: Some of the properties are no longer always valid.
    To simplify our examples, let’s assume two numbers are close to each other if
    they differ by no more than 0.1\. If this is the case, then we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 is close to 0.6, and 0.6 is close to 0.7, but 0.5 is not close to 0.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.5 is close to 0.6, and 0.7 is close to 0.8, but *0.5+0.7=1.2* is not close
    to *0.6+0.8=1.4*, and *0.5*0.7=0.35* is not close to *0.6*0.8=0.48* either
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0.5 is close to 0.4, and 0.2 is close to 0.3, but *0.5-0.2=0.3* is not close
    to *0.4-0.3=0.1*, and *0.5/0.2=2.5* is not close to *0.4/0.3=1.333*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other cited properties are always valid.
  prefs: []
  type: TYPE_NORMAL
- en: '4.11 **Shuffling kinds**: This type definition allows our function to work
    with arrays of any type (strings, numbers, objects, etc.) and says that the type
    of the output array will be the same as the type of the input array.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.12 `<T>(arr: T[]) => void`. See www.typescriptlang.org/docs/handbook/2/functions.html
    for more.'
  prefs: []
  type: TYPE_NORMAL
- en: '4.13 `JSON.stringify()` on it, and save the result. After shuffling, sort a
    copy of the shuffled array and use `JSON.stringify()` on it too. Those two JSON
    strings should be equal. This does away with all the other tests since it ensures
    that the array doesn’t change its length or elements, and it would also work for
    arrays with repeated elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '4.14 `shuffle` function works well, an idea is to shuffle a small array many
    times, and count how many possible outputs come up; the final counts should be
    similar, though not necessarily (because of the random aspects) equal. In my article
    at [blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/](https://blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/),
    I tested the Fisher–Yates algorithm by shuffling a four-letter (A to D) array
    24,000 times, and got this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All 24 possible orderings were produced (see the *Recursion* section in [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional*), and the results
    were all pretty close to 1,000; the difference between the highest and lowest
    counts is only around 10%. This is not a thorough statistical confirmation – for
    that, we’d have to apply statistical frequency tests such as χ² (Chi-squared),
    Kolmogorov–Smirnov, or Anderson–Darling – but at least we get a notion that shuffling
    is not working very badly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I applied the (supposedly good!) algorithm, the counts were more lopsided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The highest count is more than 14 times the lowest; we can definitely conclude
    that not all arrangements are equally likely, so the popular shuffling algorithm
    is simply not good enough.
  prefs: []
  type: TYPE_NORMAL
- en: '4.15 **Shuffling by sorting**: To get a random sequence, we can assign to each
    array element a random number and sort by that number; the result will be a totally
    random shuffling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The first `.map()` transforms each array element into an object, with the original
    value at `val` and a random value at `key`. We then sort the array by the `key`
    value, using the technique shown in *Question 3.8*. Finally, we undo the first
    mapping to get just the original values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final comment: this code is truly functional, and returns a new array instead
    of modifying the original argument in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Programming Declaratively – A Better Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5.1 `filter()`, `map()`, and `reduce()`, but the objective of this question
    was to make you think about how to manage with only those. Using `join()` or other
    extra string functions would make the problem easier. For instance, finding out
    a way to add the enclosing `<div><ul> ... </ul></div>` tags is tricky, so we had
    to make the first `reduce()` operation produce an array so that we could keep
    on working on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the array and index arguments for the `map()` or `reduce()` callbacks
    would also provide solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Study the three examples: they will help you gain insight into these higher-order
    functions and provide you with ideas so that you can do independent work.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 `map()` method and the new `myMap()` function, but instead of using `JSON.stringify()`,
    use Jest’s `toEqual()` method to compare the results. See the answer to *Question
    5.5* for more.
  prefs: []
  type: TYPE_NORMAL
- en: '5.3 `sum()` function so TypeScript won’t object. Overloading isn’t available
    for arrow functions, so we have to change how we define `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `reverseString2()` works and summing an array of numbers also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to do something as `sum(22,"X")` or `sum(false,{a:1})`, TypeScript
    will reject it because it won’t match the defined overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 5.4 **Reversed reverse?** In this case, it would return the same input string
    as the output; check it out!
  prefs: []
  type: TYPE_NORMAL
- en: '5.5 `1` for the former and `-1` for the latter. We used `Math.sign()` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'A different implementation starts by calculating how big an array is needed
    and then filling it using `fill()` and `map()`. We must be careful if `start`
    and `stop` are equal to avoid a division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'A few examples of calculated ranges show the diversity in terms of the options
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing Jest tests is straightforward; the following code shows just three
    cases of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Using this new `range2()` function means you can write a greater variety of
    loops in a functional way, with no need for `for(...)` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '5.6 `from`) and then updates it (by summing the `step` value) until the resulting
    value is outside the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write tests for this function in several different ways: manually calling
    the generator several times, using the spread operator to get all the values at
    once, or using the `for..of` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 5.7 `String.fromCharCode()` is not unary; it may receive any number of arguments.
    When you write `map(String.fromCharCode)`, the callback gets called with three
    parameters (the current value, the index, and the array) and that causes unexpected
    results. Using `unary()` from the *Arity changing* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions,* would also work. To find out more, go to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode).
  prefs: []
  type: TYPE_NORMAL
- en: '5.8 **Producing a CSV**: A first solution, along with some auxiliary functions,
    is as follows; can you understand what each function does?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: An alternative one-liner is possible, but not as clear – do you agree?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 5.9 `flat1()` and `flat2()` depend on `flatOne()`. If that function (in any
    of its two provided implementations) finds an empty array position, it doesn’t
    `concat()` anything to its output.
  prefs: []
  type: TYPE_NORMAL
- en: '5.10 **Producing better output**: For this, you’ll have to do some extra mapping,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '5.11 `join()` to build a single long string out of the individual sentences,
    using `split()` to separate that string into words, and finally, looking at the
    length of the resulting array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 5.12 `Boolean(x)` is the same as `!!x`, turning an expression from `truthy`
    or `falsy` into `true` or `false`, respectively. Thus, the `filter()` operation
    removes all `falsy` elements from the array.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 `fact4(0)` returns `1` as expected. The `range(1,1)` call produces an empty
    array, so the original value of `result` (`1`) is returned without further change.
  prefs: []
  type: TYPE_NORMAL
- en: 5.14 `forEach()`, `map()`, and so on, and also develops a class for `async`
    arrays that allows chaining.
  prefs: []
  type: TYPE_NORMAL
- en: '5.15 `mapAsync()` to get the async values and apply the original function to
    the returned array. An example for `some()` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write tests for this in two different fashions: awaiting the result
    of a call, or using Jest’s `.resolves` for shorter code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '5.16 `workerCall()` or when we reset a worker to be not in use. Let’s go with
    the second solution, to make the call as fast as possible. We will add a `MAX_NOT_IN_USE`
    constant with the threshold of number of workers not in use and a `notInUse()`
    predicate as a refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll change the last part of the `workerCall()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: While the count of workers not in use is higher than our limit, we find one
    worker to remove, `terminate()` it, and remove it from the pool of workers.
  prefs: []
  type: TYPE_NORMAL
- en: '5.17 **Queueing for the pool**: This question has an interesting way of handling
    a promise to act as a barrier, initially denying but eventually allowing procedures
    to go through. The idea is to check that there are not too many running workers
    before adding a worker to the pool. If so, proceed as before, but if not, add
    something to the queue (we’ll see what), so we can run the worker later. Whenever
    a worker responds, we’ll check whether there’s anything in the queue to allow
    it to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first add three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The way we’ll handle waiting is by creating a promise, which we’ll eventually
    resolve at a later time. That explains the weird `queue` data type, which contains
    resolving functions. The `running` variable will count how many workers are running,
    and `MAX_TO_USE` is the maximum possible value for `running`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with the queue, we’ll have two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The `enqueue()` function checks how many workers are running; if there are less
    than `MAX_TO_USE`, it increments `running` (because a worker will run) and then
    calls `resolve2()` to allow the corresponding request to go forward. If there
    are too many running workers, the function to call is instead pushed into the
    queue. The `dequeue()` function just tries to get the front element from the queue,
    and if there’s something, it calls the dequeued value to allow a queued request
    to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified `workerCall()` function is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The `new Promise((resolve2) => …)` line is the barrier we mentioned; it will
    allow work to go on (at `then()`) only when its `resolve2()` function is called
    – which will be done either by `enqueue()` (if there were few running workers)
    or `dequeue()` (when some previously running worker ends).
  prefs: []
  type: TYPE_NORMAL
- en: '5.18 **Showing results**: Basically, given a string, it returns a logging function
    that expects a single parameter and lists both the string and the argument. We’ll
    see other ways of achieving similar results in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.19 `filter()` goes through all the workers, and then `find()` goes through
    the filtered ones. This could be achieved in a single pass as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '5.20 `"error"` event, which fires if an error occurs in the worker. In this
    case, the worker should be marked as not in use (because it has ended its job)
    and the promise should be rejected. The final part of the `workerCall()` function
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: For an “industrial-strength” level library, you should deal with all possible
    events; check developer.mozilla.org/en-US/docs/Web/API/Worker#events and nodejs.org/api/worker_threads.html#class-worker
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6, Producing Functions – Higher-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6.1 **Go with arrows**: Just minor changes are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '6.2 `memoize4()`. Instead of using an object for `cache`, we create a map.
    We check whether the map has the searched `strX` key, we set new values after
    calling the original function, and we get the return value from the cache. The
    `as` part in `return` is to let TypeScript know that `get()` will succeed because
    the search won’t fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '6.3 `calc(n)` the number of calls needed to evaluate `fib(n)`. Analyzing the
    tree that shows all the needed calculations, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: calc(0)=1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: calc(1)=1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *n*>1, calc(*n*)=1 + calc(*n*-1) + calc(*n*-2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line follows from the fact that when we call `fib(n)`, we have one
    call, plus calls to `fib(n-1)` and `fib(n-2)`. A spreadsheet shows that `calc(50)`
    is 40,730,022,147 – rather high!
  prefs: []
  type: TYPE_NORMAL
- en: If you care for some algebra, it can be shown that calc(*n*)=5fib(*n*-1)+fib(*n*-4)-1,
    or that as *n* grows, calc(*n*) becomes approximately (1+√5)=3.236 times the value
    of fib(*n*) – but since this is not a math book, I won’t even mention those results!
  prefs: []
  type: TYPE_NORMAL
- en: '6.4 `shuffle()` function from [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069),
    *Behaving Properly*, we can write the following code. We remove the first function
    from the list before shuffling the rest, and we add it back at the end of the
    array to avoid repeating any calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: We need to add `as T` when assigning a value to `first`; otherwise, TypeScript
    will object because `fns.shift()` returns `undefined` if `fns` is empty. It wouldn’t
    be a bad idea to check that `fns` is not empty; can you add it?
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick verification shows it fulfills all our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'A minor consideration: the first function in the list can never be called the
    first time around because of the way `randomizer()` is written. Can you provide
    a better version that won’t have this slight defect so that all the functions
    in the list have the same chance of being called the first time?'
  prefs: []
  type: TYPE_NORMAL
- en: '6.5 **Not in TypeScript**: The following code does the job. The only difference
    between the functions is that one works with Boolean-returning functions and the
    other with number-returning ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '6.6 `typeof` to check whether the returned value is numeric or Boolean before
    deciding what to return. We must declare that the input function is either a Boolean-returning
    or a number-returning function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '6.7 **Invert tests**: We can quickly transform the example shown in the text
    into a real test; we’ll leave it up to you to write more tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 6.8 `filter()` expects to receive a function with three parameters (the `A`,
    `number`, and `A[]` types), and the type of `not(fn)` doesn’t match that.
  prefs: []
  type: TYPE_NORMAL
- en: '6.9 `eval()` – which, in general, isn’t such a good idea! If you persist and
    insist, though, we can write a `function.length` preserving version of `arity()`
    as follows; let’scall it `arityL()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to apply `arityL()` to `Number.parseInt`, the results would be
    as follows. The produced functions have the right `length` property, and their
    actual implementation is given in the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Do note, however, that TypeScript cannot determine the type of the resulting
    functions because that will be known at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '6.10 **Many arities!** If we were working just with JavaScript, the following
    would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding data types, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '6.11 **Throttling promises**: Every time we actually do a call, we’ll set up
    a timer that will, in time, remove the promise from the cache. By default, let’s
    have a delay of 5 minutes. We’ll have a pool of timers, one per promise. In case
    of an error when calling the API, we’ll remove both the rejected promise and its
    corresponding timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 6.12 `+`, `-`, `*`, `/`, `**`, and `%`), all bitwise operators (`&`, `|`, and
    `^`), all logical operators (`&&` and `||`), all shift operators (`<<`, `>>`,
    and `>>>`), all comparisons (`>`, `>=`, `<`, `<=`, `==`, `===`, `!=`, and `!==`),
    and the new nullish coalescing operator (`??`). The comma operator could be included
    as well. Check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)
    for more on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: '6.13 **Missing companion**: A simple one-line version could be as follows.
    Here, we use spreading to get a shallow copy of the original object and then set
    the specified attribute to its new value by using a computed property name. See
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)
    for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we
    wrote `deepCopy()`, which would be better than spreading when it comes to creating
    a totally new object instead of a shallow copy. By using this, we would have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you could also look into modifying the `updateObject()` function, also
    from [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, by removing
    the freezing code; I’ll leave it up to you.
  prefs: []
  type: TYPE_NORMAL
- en: '6.14 `null` object would throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'With TypeScript, the code won’t compile because first, `"someField"` isn’t
    the name of an attribute, and second, `null` is not a valid object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: However, it’s still possible to do things “behind TypeScript’s back” and get
    the code accepted and the exception thrown. Having functions throw exceptions
    is not usually good in FP. You may opt to produce `undefined` instead, or work
    with monads, just like in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building
    Better Containers*. A safer version of `getField()` would add a safeguard and
    return `obj &&` `obj[f]` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '6.15 **Typed demethodizing**: The three full definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '6.16 `Math.max()` and `Math.min()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of writing this could be achieved by defining the following first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could write in a pointfree style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '6.17 **Comparing heroes**: The first suggested change wouldn’t allow for ties
    in some features, where no hero beats the other. And, in fact, this points out
    a problem in our logic; if the first hero doesn’t beat the second one, we assume
    that the latter beat the former, not allowing for ties between heroes.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7, Transforming Functions – Currying and Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.1 `sum(3)` returns a function with `3` already bound; `sum(3)()` returns the
    same, and `sum(3)()(5)` produces the result.
  prefs: []
  type: TYPE_NORMAL
- en: '7.2 `sumMany()` function does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript, the function poses no problem; with TypeScript, we’ll get an
    objection because it cannot determine that `sumMany(2)` is a function, not a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'A small detail: can you fix the function so `sumMany()` will return `0`?'
  prefs: []
  type: TYPE_NORMAL
- en: '7.3 **Curry with eval?** Let’s see this in JavaScript first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a chunk of code to digest, and, in fact, it should instead be
    coded in several separate lines to make it more understandable. Let’s see how
    this works when applied to the `make3()` function as input:'
  prefs: []
  type: TYPE_NORMAL
- en: The `range()` function produces an array with the `[``0,1,2]` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `map()` to generate a new array with the `["``x0","x1","x2"]` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use `join()`on the values in that array to produce `x0=>x1=>x2`, which will
    be the beginning of the code that we will evaluate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then add an arrow, the function’s name, and an opening parenthesis, to make
    the middle part of our newly generated code: `=>` `make3(`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use `range()`, `map()`, and `join()` again, but this time, to generate a
    list of arguments: `x0,x1,x2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We finally add a closing parenthesis, and after applying `eval()`, we get the
    curried version of `make3()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After following all these steps, in our case, the resulting function would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Typing is essentially the same as for our `curry()` function since we are getting
    the same parameter and producing the same output. Note, however, that we’re definitely
    “lying” to TypeScript because it wouldn’t be able to deduce what `eval()` was
    returning; it’s really up to us not to mess up! Without further ado, we can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'We see we can do currying by using `eval()` – but there’s one remaining problem:
    if the original function didn’t have a name, the transformation wouldn’t work.
    We can work around the function name problem by including the actual code of the
    function to be curried:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change is that instead of including the original function name, we
    substitute its actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '7.4 **Uncurrying the curried**: We can work similarly to what we did in the
    previous question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, when currying, given an `fn()` function with an arity of `3`, we would
    have generated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to uncurry a function (say, `curriedFn()`), we want to do something very
    similar: the only difference is the placement of the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected behavior is as follows – and let’s use the last result from the
    previous question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: If you want to consider a case in which the function to “uncurry” has no name,
    you can apply the same change we did in the previous question and include `fn.toString()`
    in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '7.5 **Let me count the ways**: If the function has *n* parameters, there are
    2n-1 ways of calling it. This means that our three-parameter function could be
    called in 22=4 ways (correct!), a function with two parameters would allow 21=2
    ways, and a function with just one parameter would allow only 20=1 way.'
  prefs: []
  type: TYPE_NORMAL
- en: '7.6 `curry()` version so that it uses this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '7.7 **Shorter typing**: The suggested earlier test shortens the code. We are
    essentially saying “*if there’s at least one argument, return a curried function;
    otherwise, return* *a value*”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '7.8 `P` has a single type by checking `P["length"]` as follows – and to access
    that single type, we’ll have to write `P[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '7.9 `applyStyle()` or by using our `curry()` function – let’s see both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '7.10 `what()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 7.11 `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12 `curryN()` function is an alternative version of our `partialCurry()`.
    The only difference is that if you provide all the arguments to a function, this
    new `curryN()` function directly calls the curried function, while `partialCurry()`
    would first bind the function to all its arguments and then recursively call it
    to return the final result – but the result would be precisely the same.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8, Connecting Functions – Pipelining, Composition, and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8.1 `split()`, `map()`, and `join()`. Using `demethodize()` from [*Chapter
    6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, and `flipTwo()`
    from [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    would have also been possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipeline works as expected: we split the string into words, we map each
    word to make its first letter uppercase, and we join the array elements to form
    a string again. We could have used `reduce()` for the last step, but `join()`
    already does what we need, so why reinvent the wheel?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '8.2 **Pending tasks**: The following pipeline does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reduce()` call may be mystifying. By that time, we are handling an array
    with a single element – an object – and we want the object in the pipeline, not
    the array. This code works even if the responsible person doesn’t exist, or if
    all the tasks have been completed; can you see why? Also, note that if `allTasks`
    is `null`, an object must be provided with the `byPerson` property so that future
    functions won’t crash! For an even better solution, I think monads are better:
    see *Question 12.1* for more.'
  prefs: []
  type: TYPE_NORMAL
- en: '8.3 **Thinking in abstract terms**: The simple solution implies composing.
    I preferred it to pipelining in order to keep the list of functions in the same
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '8.4 **Reversing types**: We can apply recursion to reverse a list of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can define `Compose<>` in terms of `Pipeline<>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Instead of an overload, we’re using a cast here to let TypeScript know what
    types we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 `pipeline()` function we wrote accesses `fns[0]` without checking whether
    the `fns` array is empty, so it won’t work. The `pipeline1()` and `pipeline2()`
    functions use `reduce()` without an initial value, so they will also fail. We
    must add an initial test, so if no functions are provided (`fns.length===0`),
    we’ll simply return the input value as the result.
  prefs: []
  type: TYPE_NORMAL
- en: '8.6 **Undetected impurity?** Yes, the function is impure, but using it as-is
    would fall squarely under the **Sorta Functional Programming** (**SFP**) style
    we mentioned back in the *Theory versus practice* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional*. The version we used is not pure, but in the way we use it,
    the final results are pure: we modify an array in place, but it’s a new array
    that we are creating. The alternate implementation is pure and also works, but
    will be slower since it creates a completely new array every time we call it.
    So, accepting this bit of impurity helps us get a function that performs better;
    we can accept that!'
  prefs: []
  type: TYPE_NORMAL
- en: '8.7 `map()` operations, you could apply a single `map()` by pipelining all
    the mapping functions into a single one. For `filter()` operations, it becomes
    a bit harder, but here’s a tip: use `reduce()` to apply all the filters in sequence
    with a carefully thought-out accumulating function.'
  prefs: []
  type: TYPE_NORMAL
- en: '8.8 `chainify()`, the type of `myCity2` is `Chainify<City>`. Attributes have
    the same types as before, but the `void`-returning methods now return an object
    of the same `Chainify<City>` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 9, Designing Functions – Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '9.1 `reverse("MONTEVIDEO")` can be found by doing `reverse("ONTEVIDEO")+"M"`.
    In the same way, `reverse("ONTEVIDEO")` would be equal to `reverse("NTEVIDEO")+"O"`,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '9.2 **Climbing steps**: To climb a ladder with *n* steps, we can act in two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Climb one single step and then climb an (*n*-1) steps ladder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Climb two steps at once and then climb an (*n*-2) steps ladder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we call ladder(*n*) the number of ways to climb a steps ladder, we know
    that ladder(n)= ladder(*n*-1) + ladder(*n*-2). Adding the fact that ladder(0)=1
    (there’s only one way to climb a ladder with no steps: do nothing) and ladder(1)=1,
    the solution is that ladder(*n*) equals the (*n*-1)th Fibonacci number! Check
    it out: ladder(2)=2, ladder(3)=3, ladder(4)=5, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '9.3 `max`), create a new copy of the array but without that element, sort the
    copy, and then return the sorted copy with `max` added at the end. Take a look
    at how we dealt with the mutator functions to avoid modifying the original array
    and note that this sorting code only works with numbers because of the way we
    find `max`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 9.4 `smaller` would be an empty array, and `greaterEqual` would be equal to
    the whole array to sort, so the logic would enter an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: The original code can never enter a loop because every pass removes one element
    (the pivot) so you’re guaranteed to reach a state with nothing left to sort.
  prefs: []
  type: TYPE_NORMAL
- en: '9.5 **More efficiency**: The following code does the work for us. Here, we
    use a ternary operator to decide where to push the new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '9.6 `mapR()`, so I’ll skip repeating explanations – the only difference is
    in the `return` value, which is now a value from the array (`arr[0]` in `findLoop()`)
    instead of a mapped whole array as in `mapR()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '9.7 `mapR()` example, so I won’t comment on the looping, types, and so on.
    When programming `everyR()`, we must be careful what to do with empty arrays or
    missing places; the standard `every()` method considers them to return `true`,
    so we’ll do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'When programming `someR()`, an empty array means a false result, but empty
    places are skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '9.8 **Symmetrical queens**: The key to finding only symmetric solutions is
    as follows. After the first four queens have been (tentatively) placed on the
    first half of the board, we don’t have to try all the possible positions for the
    other queens; they are automatically determined with regard to the first ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Calling `symmetricFinder()` produces four solutions, which are essentially the
    same. Make drawings and check them to make sure the solution is correct!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '9.9 `a` and `b`, can be found with recursion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the length of `a` is zero, or if the length of `b` is zero, return zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first characters of `a` and `b` match, the answer is 1 plus the LCS of
    `a` and `b`, both minus their initial characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the first characters of `a` and `b` do not match, the answer is the largest
    of the following two results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LCS of `a` minus its initial character, and `b`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The LCS of `a`, and `b` minus its initial character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can implement this as follows. We do memoization “by hand” to avoid repeating
    calculations; we could have also used our memoization function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: As an extra exercise, you could produce not only the length of the LCS but also
    the characters that are involved.
  prefs: []
  type: TYPE_NORMAL
- en: '9.10 `2` and check whether the remainder is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have another solution by doing `return Boolean(n %` `2)` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to divide the number by 2 and check whether it has a fractional
    part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'If a number is odd, dividing it by 2 and dividing its predecessor by 2, both
    results have the same integer part (for instance, 9/2 and 8/2 both have integer
    part 4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Using bit operations is fast; an odd number will have its least significant
    bit set to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'As in `isOdd1()`, you get another variation by doing `return Boolean(n &` `1)`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Shifting in binary also works; if we shift the number one bit to the right
    (dropping its least significant bit) and then shift the number back one bit to
    the left, for an odd number, we don’t get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Shifting to the right is the same as dividing by 2 and keeping the integer
    part, so this solution is basically the same as the third one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Odd numbers end in 1, 3, 5, 7, or 9, so we can also look at the string representation
    of the number and check its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: We could work with the string by using `find()` or `indexOf()`; I’ll leave these
    versions to you.
  prefs: []
  type: TYPE_NORMAL
- en: '9.11 `trampoline()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, the first `return` in `isEven()` used to be `return true`; now
    we trampoline a thunk that will call a continuation with `true`. We can now finish
    the job by providing an appropriate continuation that just returns the calculated
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '9.12 `isEven(1)` or `isOdd(2)`, you get an infinite loop; can you see why?
    (The same will happen if you replace `1` and `2` with any odd or even number,
    respectively.) A hint: the problem is with the base cases for recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.13 `while()` with a `for(;;)` loop and breaking out with a `return`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.14 `power()` function, sitting between `term()` and `factor()`, so its priority
    will be correctly placed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2 – Power represents a sequence of exponentiations](img/Figure_2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2 – Power represents a sequence of exponentiations
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll change `term()` to call `power()` instead of `factor()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly calculate “towers” such as 2^3^4, we’ll store `2`, `3`, and `4`
    in an array, and then reduce it from right to left: we’ll first calculate 3^4,
    and then 2^(the calculated result for 3^4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '9.15 **Error-prone evaluation**: Here are some ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: When skipping a token, check if it’s correct anyway; for instance, `factor()`
    skips the second parenthesis without actually checking whether it is, so it would
    evaluate “(1+2]” as 3, even though it’s wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a special end-of-string (EOS) token, to check whether the evaluation finishes
    at that token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check you do not go beyond the end of the `tokens` array whenever you advance
    to the next token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 10, Ensuring Purity – Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '10.1 `jsonCopy()` in the following example, but don’t assume there aren’t any
    more problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Four of the properties got transformed into an empty object, and the function
    was ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '10.2 `deepCopy()` function does marginally better; with the same agent object
    as in the previous question, copying produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The error and the function got converted OK. The map and the set were converted
    into the right types, but they are empty; this could be fixed by adding logic
    that would scan the original objects and insert copies of them into the new ones.
    (*Question 10.10* may help.) Finally, cloning a regular expression is a tad harder,
    but google “*clone regexp in JavaScript*” and you’ll find several implementations
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: '10.3 `deepCopy2()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the `mapped` variable for our map. When we find that we have to clone
    an `obj` object, we first check (`mapped.has(obj)`) whether we have already done
    that, and if so, we return the value from the map. If this was a new, not yet
    copied object, we add it and its `aux` copy to the map (`mapped.set(obj,aux)`)
    for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify how this work with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `deepCopy()` on `circular`, we’ll get a `RangeError: Maximum call
    stack size exceeded` exception. However, with our new `deepCopy2()` function,
    the circular reference is tackled with no problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '10.4 **Freezing by proxying**: As requested, a proxy allows you to intercept
    changes on an object. (See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    for more on this.) We use recursion to apply the proxy all the way down in case
    some attributes are objects themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The following is the output of the preceding code. For real-life implementations,
    you’d probably require something other than a `DON'T MODIFY ANYTHING IN ME` message,
    of course!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '10.5 **Inserting into a list, persistently**: Using recursion helps out as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the list is empty, we cannot insert the new key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are at a node whose key is `oldKey`, we create a clone of that node that
    points at a list that starts with a new node with `newKey` as its value and a
    pointer to the rest of the original node’s list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are at a node whose key isn’t `oldKey`, we create a clone of the node
    and (recursively) insert the new key somewhere in the rest of the original node’s
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we can see this working. The new list is similar to
    the one shown in *Figure 10**.2*. However, printing out the lists (`c3` and `newList`)
    wouldn’t be enough; you wouldn’t be able to distinguish new or old nodes, so I’ve
    included several comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: A lot of `!` non-null assertions were needed to inform TypeScript that no `null`
    values were around.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new question: In the preceding logic, nothing is inserted if `oldKey` isn’t
    found. Can you change the logic so, in that case, the new node is added at the
    end of the list?'
  prefs: []
  type: TYPE_NORMAL
- en: '10.6 `reduce()`. Let’s write the `composeManyLenses()` function and apply it
    to the same example that was shown in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `deepObject` example seen earlier, plus all the lenses to get `c`,
    `e`, `g`, and so on, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 10.7 `getField()` to `getByPath()`.
  prefs: []
  type: TYPE_NORMAL
- en: '10.8 `fullName` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Being able to set several attributes based on a single value isn’t always possible,
    but if we assume the incoming name is in the `LAST,FIRST` format, we can split
    it by the comma and assign the two parts to the first and last names, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 10.9 `view()` function would work well, but `set()` and `over()` wouldn’t work
    in a pure way since `setArray()` doesn’t return a new array; instead, it modifies
    the current one in place. Take a look at the following question for a related
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: '10.10 **Lenses into maps**: Getting a value from the map poses no problem,
    but for setting, we need to clone the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Chapter 11, Implementing Design Patterns – The Functional Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '11.1 **Decorating methods, the future way**: As we’ve already mentioned, decorators
    aren’t a fixed, definitive feature at the moment. However, by following [tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/),
    we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to add a `@logging` decoration to a method. We save the original method
    in `savedMethod` and substitute a new method that will log the received arguments,
    call the original method to save its return value, log that, and finally return
    it. If the original method throws an exception, we catch it, report it, and throw
    it again so that it can be processed as expected. A simple example of this is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '11.2 `addBar()` function that receives a `Base` class and extends it. In this
    case, I decided to add a new attribute and a new method. The constructor for the
    extended class calls the original constructor and creates the `barValue` attribute.
    The new class has both the original’s `doSomething()` method and the new `somethingElse()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 11.3 `event.detail`; you can find out more at [developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail](http://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail).
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 `flags` array with Boolean values, you don’t need any special comparison
    function; `flags.sort()` works “out of the box” and will place `false` values
    first and `true` values last. This is because the standard sort works by converting
    values into strings, and then comparing them; when you do this, Boolean values
    become `"false"` and `"true"`, and as `"false" < "true"`, everything turns out
    well!
  prefs: []
  type: TYPE_NORMAL
- en: 11.5 `RouteFinder` class with several subclasses, such as `ByFootRouteFinder`,
    `BicycleRouteFinder`, and so on, each implementing a `findRouteAlgorithm()` method
    in a different way, and a factory that chooses what subclass to instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12, Building Better Containers – Functional Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '12.1 `map()` method to Booleans, numbers, and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '12.2 `Symbol`, whose value was defined inside a module and not exported, so
    nobody could access the corresponding attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a `Symbol` helps hide the field: the property key won’t show up in `Object.keys()`
    or in `for...in` or `for...of` loops, making them more meddle-proof. (If you haven’t
    worked with JavaScript symbols, possibly the least known of its primitive data
    types, you might want to check out [developer.mozilla.org/en-US/docs/Glossary/symbol](http://developer.mozilla.org/en-US/docs/Glossary/symbol).)'
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` method could access the “protected” attribute because it had access
    to the `VALUE` symbol, but without that, you cannot get at the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '12.3 `XXX` class to be abstract, it should start like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '12.4 **Maybe tasks?** The following code shows a simpler solution than the
    one we looked at earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Here, we apply one function after the other, secure in the knowledge that if
    any of these functions produces an empty result (or even if the original `listOfTasks`
    is null), the sequence of calls will go on. In the end, you will either get an
    array of task IDs or a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: '12.5 **Extending your trees**: Calculating the tree’s height is simple if you
    do this in a recursive fashion. The height of an empty tree is zero, while the
    height of a non-empty tree is one (for the root) plus the maximum height of its
    left and right subtrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the keys in order is a well-known requirement. Because of the way that
    the tree is built, you list the left subtree’s keys first, then the root, and
    finally the right subtree’s keys, all in a recursive fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, deleting a key from a binary search tree is a bit more complex. First,
    you must locate the node that is going to be removed, and then there are several
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the node has no subtrees, deletion is simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node has only one subtree, you just replace the node with its subtree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the node has two subtrees, then you have to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the minimum key in the tree with a greater key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Place it in the node’s place
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since this algorithm is well covered in all computer science textbooks, I won’t
    go into more detail about this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '12.6 `||` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, seeing that both alternatives in the second ternary operator are very
    similar, you could also do some shortening there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember: shorter doesn’t imply better! However, I’ve found many examples of
    this kind of code tightening, and it’s better if you have been exposed to it,
    too.'
  prefs: []
  type: TYPE_NORMAL
- en: '12.7 **Functional lists**: Let’s add to the samples that have already been
    provided. We can simplify working with lists if we can transform a list into an
    array, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating two lists together and appending a value to a list have simple
    recursive implementations. We can also reverse a list by using the appending function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the basic `map()`, `filter()`, and `reduce()` operations are good
    to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some exercises that have been left for you to tackle. Generate
    a printable version of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare two lists to see whether they have the same values, in the same order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search a list for a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get, update, or remove the value at the *n*th position of a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.8 `BOOLEAN` type and two special functions, `TRUE` and `FALSE`, which will
    stand for the usual `true` and `false` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BOOLEAN` type receives two values and returns one of those. A `TRUE` Boolean
    returns the first of those two values; a `FALSE` Boolean returns the second. We
    can construct and check variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'These are not the only possibilities, but I’ll leave you to discover alternatives.
    Finally, we could have an `ifElse()` function to work with these `BOOLEAN` values
    and thunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'A final comment: this code goes to show more things that you *could* do with
    functions, but it doesn’t mean you *should* do them this way! You can read the
    following at [www.usrsb.in/Building-Data-Structures-from-Functions.html](http://www.usrsb.in/Building-Data-Structures-from-Functions.html):'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, this might strike you as nothing more than a useless programming
    trick. In a sense that’s right. I’d never use this in my own code. What makes
    this technique so valuable is that it actually fits into the broader context of
    lambda calculus, which is a mathematical abstraction of computation.
  prefs: []
  type: TYPE_NORMAL
- en: Couldn’t say it better myself!
  prefs: []
  type: TYPE_NORMAL
- en: Bibliography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following texts are freely available online:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ECMA-262: ECMAScript 2022 Language Specification*, latest edition (currently
    the 13th) at [www.ecma-international.org/ecma-262/](http://www.ecma-international.org/ecma-262/).
    This provides the official standard for the current version of JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Eloquent JavaScript*, Second Edition, by *Marijn Haverbeke*, at [eloquentjavascript.net/](http://eloquentjavascript.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript for Impatient Programmers (ES2022 edition)*, by *Dr. Axel* *Rauschmayer*,
    at [exploringjs.com/impatient-js/](http://exploringjs.com/impatient-js/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional-Light JavaScript*, by *Kyle Simpson*, at [github.com/getify/Functional-Light-JS](http://github.com/getify/Functional-Light-JS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript Allongé (the “six” edition)*, by *Reginald Braithwaite*, at [leanpub.com/javascriptallongesix/read](http://leanpub.com/javascriptallongesix/read)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Professor Frisby’s Mostly Adequate Guide to Functional Programming*, by *Dr.
    Boolean* (*Brian Lonsdorf*), at [github.com/MostlyAdequate/mostly-adequate-guide](http://github.com/MostlyAdequate/mostly-adequate-guide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you prefer printed books, you can go with this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning Functional JavaScript*, by *Anto Aravinth*, *Apress*, 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Discover Functional JavaScript*, by *Cristian Salcescu*, (independently published),
    2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional JavaScript*, by *Michael Fogus*, *O’Reilly* *Media*, 2013'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in JavaScript*, by *Dan Mantyla*, *Packt* *Publishing*,
    2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in JavaScript*, by *Luis Atencio*, *Manning* *Publications*,
    2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Grokking Simplicity – Taming complex software with functional thinking*, by
    *Eric Normand*, *Manning* *Publications*, 2021'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-on Functional Programming with TypeScript*, by *Remo Jansen*, *Packt*
    *Publishing*, 2019'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Introduction to Functional Programming*, by *Richard Bird and Philip Wadler*,
    *Prentice Hall International*, 1988\. A more theoretical point of view, not dealing
    specifically with JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pro JavaScript Design Patterns*, by *Ross Harmes and Dustin Díaz*, *Apress*,
    2008'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secrets of the JavaScript Ninja*, by John Resig and Bear Bibeault, *Manning*
    *Publications*, 2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeScript 4 Design Patterns and Best Practices*, by *Theo Despoudis*, *Packt*
    *Publishing*, 2021'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also interesting, though with a lesser focus on functional programming, are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*High-Performance JavaScript*, by *Nicholas Zakas*, *O’Reilly* *Media*, 2010'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript Patterns*, by *Stoyan Stefanov*, *O’Reilly* *Media*, 2010'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript: The Good Parts*, by *Douglas Crockford*, *O’Reilly* *Media*, 2008'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*JavaScript with Promises*, by *Daniel Parker*, *O’Reilly* *Media*, 2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Learning JavaScript Design Patterns*, by *Addy Osmani*, *O’Reilly* *Media*,
    2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering JavaScript Design Patterns*, *Second Edition*, by *Simon Timms*,
    *Packt* *Publishing*, 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering JavaScript High Performance*, by *Chad Adams*, *Packt* *Publishing*,
    2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pro JavaScript Performance*, by *Tom Barker*, *Apress*, 2012'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These titles are on the subject of reactive functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering Reactive JavaScript*, by *Erich de Souza Oliveira*, *Packt* *Publishing*,
    2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reactive Programming with Node.js*, by *Fernando Doglio*, *Apress*, 2016'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reactive Programming with RxJS*, by *Sergi Mansilla*, *The Pragmatic* *Programmers*,
    2015'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
