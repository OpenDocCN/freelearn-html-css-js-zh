- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Building Better Containers – Functional Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建更好的容器 - 函数式数据类型
- en: In [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204), *Implementing Design Patterns*,
    we went over how to use functions to achieve different results. In this chapter,
    we will look at data types from a functional point of view. We’ll be considering
    how we can implement our own data types, along with several features that can
    help us compose operations or ensure their purity so that our FP coding will become
    simpler and shorter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B19301_11.xhtml#_idTextAnchor204) *实现设计模式* 中，我们讨论了如何使用函数来实现不同的结果。在本章中，我们将从函数式角度探讨数据类型。我们将考虑如何实现我们自己的数据类型，以及一些可以帮助我们组合操作或确保其纯度的特性，从而使我们的函数式编程变得更加简单和简洁。
- en: 'We’ll be touching on several topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涉及几个主题：
- en: '**Data types** from a functional point of view. Even though JavaScript is not
    a typed language, a better understanding of types and functions is needed, to
    complement our usage of TypeScript.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从函数式角度**的**数据类型**。尽管JavaScript不是一种类型语言，但为了补充我们对TypeScript的使用，我们需要更好地理解类型和函数。'
- en: '**Containers**, including functors and the mystifying monads, to structure
    a data flow.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**，包括函子和神秘的单子，以结构化数据流。'
- en: '**Functions as structures**, in which we’ll see yet another way of using functions
    to represent data types, with immutability thrown in as an extra.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数作为结构**，我们将看到另一种使用函数来表示数据类型的方法，并加入不可变性作为额外的特性。'
- en: With that, let’s get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，让我们开始吧！
- en: Specifying data types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定数据类型
- en: 'Even though JavaScript is a dynamic language, without static or explicit typing
    declarations and controls, it doesn’t mean you can simply ignore types. Even if
    the language doesn’t allow you to specify the types of your variables or functions,
    you still work—even if only in your head—with types. Specifying types has advantages,
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript是一种动态语言，但没有静态或显式的类型声明和控制，并不意味着你可以简单地忽略类型。即使语言不允许你指定变量或函数的类型，你仍然在用类型工作——即使只是在你的脑海中。指定类型有如下优势：
- en: TypeScript can detect compile-time errors, avoiding many bugs.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 可以检测编译时错误，避免许多bug。
- en: It will help if you move from JavaScript to a more functional language, such
    as Elm (see [elm-lang.org](http://elm-lang.org)).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你从JavaScript迁移到更函数式的语言，如Elm（见[elm-lang.org](http://elm-lang.org)），这将有所帮助。
- en: It serves as documentation that lets future developers understand what type
    of arguments they must pass to the function and what type it will return. All
    the functions in the Ramda library are documented in this way.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为文档，让未来的开发者了解他们必须传递给函数的参数类型以及函数将返回的类型。Ramda库中的所有函数都是以这种方式进行文档化的。
- en: It will also help us with the functional data structures we will cover later
    in this section, where we will examine a way of dealing with structures, similar
    to what you do in fully functional languages such as Haskell.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也将帮助我们理解本节后面将要介绍的功能性数据结构，我们将探讨一种处理结构的方法，类似于你在像Haskell这样的完全函数式语言中所做的那样。
- en: Why are we discussing types again, after using TypeScript throughout the whole
    book? The reason is that in most FP texts, a different style is used. TypeScript
    definitions are just, well, TypeScript, but the definitions we’ll see here can
    be applied to any other language. Let’s forget TypeScript for a minute and start
    thinking about a new type system. We’ll start with functions, the most relevant
    type, and then consider other definitions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在整本书都使用TypeScript之后，我们又要讨论类型呢？原因在于，在大多数函数式编程文本中，使用了一种不同的风格。TypeScript定义只是，嗯，TypeScript，但我们将在这里看到的定义可以应用于任何其他语言。让我们暂时忘记TypeScript，开始思考一个新的类型系统。我们将从函数开始，这是最相关的类型，然后考虑其他定义。
- en: Signatures for functions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的签名
- en: 'The specification of a function’s arguments and the result are given by a signature.
    Type signatures are based on a type system called **Hindley–Milner** (**HM**),
    which influenced several (mostly functional) languages, including Haskell, though
    the notation has changed from that of the original paper. This system can even
    deduce types that are not directly given, in the same way that TypeScript or Flow
    does. Instead of providing a dry, formal explanation about the rules for writing
    correct signatures, let’s work with examples. We only need to know the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数和结果的指定由签名给出。类型签名基于称为 **Hindley–Milner**（**HM**）的类型系统，该系统影响了几个（主要是函数式）语言，包括
    Haskell，尽管符号与原始论文中的不同。该系统甚至可以推断出没有直接给出的类型，就像 TypeScript 或 Flow 一样。而不是提供关于编写正确签名的规则的枯燥、正式的解释，让我们通过例子来工作。我们只需要知道以下内容：
- en: We will be writing the type declaration as a comment
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把类型声明写成注释
- en: The function name is written first, and then `::`, which can be read as *is
    of type* or *has type*
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名首先写出来，然后是 `::`，这可以读作 *is of type* 或 *has type*
- en: Optional constraints may follow, with a double (fat) arrow `⇒` (or `=>` in basic
    ASCII fashion, if you cannot type in the arrow) afterward
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选约束可能随后，后面跟着一个双箭头（粗箭头）`⇒`（或在基本 ASCII 格式下，如果无法输入箭头，则为 `=>`）
- en: The input type of the function follows, with a `→` (or `->`, depending on your
    keyboard)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的输入类型随后，后面跟着 `→`（或 `->`，取决于你的键盘）
- en: The result type of the function comes last
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的结果类型位于最后
- en: Careful with arrows!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 小心箭头！
- en: 'An advance warning: check out the arrow styles we’ll use; they are not what
    TypeScript uses! A “thin” arrow will be used instead of `=>`, and a “fat” arrow
    will be used to specify a generic constraint; be careful!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 提前警告：查看我们将使用的箭头样式；它们与 TypeScript 使用的不同！我们将使用“细”箭头代替 `=>`，使用“粗”箭头来指定泛型约束；请小心！
- en: 'Now, we can begin with some examples. Let’s define the type for a simple function
    that capitalizes a word, and do the same for the `Math.random` function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从一些例子开始。让我们定义一个将单词转换为大写的简单函数的类型，并为 `Math.random` 函数做同样的处理：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are simple cases—only take the signatures into account here; we are not
    interested in the actual functions. The arrows denote functions. The first function
    receives a string as an argument and returns a new string. The second one receives
    no arguments (as indicated by the empty parentheses) and returns a floating-point
    number. So, we can read the first signature as `firstToUpper()` *is a function
    of the type that receives a string and returns a string*. We can speak similarly
    about the maligned (impurity-wise) `Math.random()` function, the only difference
    being that it doesn’t receive arguments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是简单的情况——这里只考虑签名；我们对实际的函数不感兴趣。箭头表示函数。第一个函数接收一个字符串作为参数并返回一个新的字符串。第二个函数不接收任何参数（如空括号所示）并返回一个浮点数。因此，我们可以将第一个签名读作
    `firstToUpper()` *是一个接收字符串并返回字符串的函数类型*。我们可以类似地谈论被诟病的（从不纯性角度看）`Math.random()` 函数，唯一的区别是它不接收参数。
- en: 'Comparing the new type definition with TypeScript, it’s clear that they are
    very much alike. However, the new style is clearer. You could have also defined
    `firstToUpper()` in the following way, without specifying the result type (because
    TypeScript can work it out), but with HM types, you have to provide all the details,
    providing more clarity:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的类型定义与 TypeScript 进行比较，很明显它们非常相似。然而，新的风格更清晰。你也可以用以下方式定义 `firstToUpper()`，不指定结果类型（因为
    TypeScript 可以推断出来），但使用 HM 类型，你必须提供所有细节，提供更多的清晰度：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another detail is that in this new way of specifying types, the type descriptions
    stand on their own, without being mixed with the details of the programming language—you
    don’t need to understand JavaScript, TypeScript, or any other language to figure
    out what types are involved in a function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节是，在这种指定类型的新方式中，类型描述独立存在，没有与编程语言的细节混合——你不需要理解 JavaScript、TypeScript 或任何其他语言就能弄清楚函数中涉及的类型。
- en: 'We’ve already looked at functions with zero or one parameter, but what about
    functions with more than one? There are two answers to this. If we are working
    in a strict functional style, we would always be currying (as we saw in [*Chapter
    7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*), so all the functions
    would be unary. The other solution is enclosing a list of argument types in parentheses.
    We can see both of these solutions in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了具有零个或一个参数的函数，但对于具有多个参数的函数呢？有两个答案。如果我们在一个严格的函数式风格中工作，我们总是会进行柯里化（如我们在 [*第7章*](B19301_07.xhtml#_idTextAnchor128)，*转换函数*）中看到的），所以所有的函数都会是一元函数。另一个解决方案是将参数类型列表括起来。我们可以在以下代码中看到这两个解决方案：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remember that `sum3c()` is actually `(a) => (b) => (c) => a + b + c`; this
    explains the first signature, which can also be read as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`sum3c()` 实际上是 `(a) => (b) => (c) => a + b + c`；这解释了第一个签名，它也可以读作以下内容：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you provide the first argument to the function, you are left with a new
    function, which also expects an argument and returns a third function, which,
    when given an argument, will produce the final result. We won’t be using parentheses
    because we’ll always assume this grouping from right to left.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你向函数提供第一个参数之后，你将剩下一个新的函数，它也期望一个参数，并返回一个第三个函数，当给定一个参数时，将产生最终结果。我们不会使用括号，因为我们始终假设从右到左的这种分组。
- en: 'Now, what about higher-order functions, which receive functions as arguments?
    The `map()` function poses a problem: it works with arrays of any type. Also,
    the mapping function can produce any type of result. For these cases, we can specify
    generic types, identified by lowercase letters. These generic types can stand
    for any possible type. For arrays themselves, we use brackets. So, we would have
    the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于接受函数作为参数的高阶函数，我们该怎么办呢？`map()` 函数提出了一个问题：它可以与任何类型的数组一起工作。此外，映射函数可以产生任何类型的输出。对于这些情况，我们可以指定泛型类型，由小写字母标识。这些泛型类型可以代表任何可能的类型。对于数组本身，我们使用括号。因此，我们将有如下所示的内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s perfectly valid to have `a` and `b` represent the same type, as in a mapping
    that’s applied to an array of numbers, which produces another array of numbers.
    The point is that, in principle, `a` and `b` may stand for different types, which
    we described previously. This definition requires using generic types in TypeScript,
    `A` and `B` in our case.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让 `a` 和 `b` 代表相同的类型是完全有效的，例如，在应用于数字数组的映射中，它会产生另一个数字数组。关键是，原则上，`a` 和 `b` 可能代表不同的类型，这是我们之前描述的。这个定义要求在
    TypeScript 中使用泛型类型，在我们的例子中是 `A` 和 `B`。
- en: Note that if we weren’t currying, the signature would have been `([a], (a →
    b)) → [b]`, showing a function that receives two arguments (an array of elements
    of type `a` and a function that maps from type `a` to type `b`) and produces an
    array of elements of type `b` as its result.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们没有进行柯里化，签名将是 `([a], (a → b)) → [b]`，这显示了一个接收两个参数（类型为 `a` 的元素数组和一个从类型
    `a` 映射到类型 `b` 的函数）并产生类型为 `b` 的元素数组作为其结果的函数。
- en: 'We can similarly write the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地写出以下内容：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now the big one: what’s the signature for `reduce()`? Be sure to read it
    carefully and see whether you can work out why it’s written that way. You may
    prefer thinking about the second part of the signature as if it were `((b, a)
    →` `b)`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候考虑 `reduce()` 的签名了。务必仔细阅读它，看看你是否能弄清楚为什么它被写成这样。你可能更喜欢将签名的第二部分想象成 `((b, a)
    →` `b)`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, if you are defining a method instead of a function, you use a squiggly
    arrow such as `~>`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你正在定义一个方法而不是函数，你使用波浪线箭头，例如 `~>`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So far, we have defined data types for functions, but we aren’t done with this
    subject. Let’s consider some other cases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为函数定义了数据类型，但我们对这个主题还没有完成。让我们考虑一些其他的情况。
- en: Other data type options
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据类型选项
- en: 'What else are we missing? Let’s look at some other options that you might use.
    *Product types* are a sets of values that are always together and are commonly
    used with objects. For *tuples* (that is, arrays with a fixed number of elements
    of (probably) different types), we can write something like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还缺少什么？让我们看看你可能使用的其他选项。*产品类型* 是一组总是在一起出现的值，通常与对象一起使用。对于 *元组*（即具有固定数量元素（可能是不同类型）的数组），我们可以写出如下内容：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For objects, we can go with a definition very similar to what JavaScript already
    uses. Let’s imagine we have a `getPerson()` function that receives an ID and returns
    an object with data about a person:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象，我们可以采用与JavaScript已经使用的定义非常相似的定义。让我们想象我们有一个`getPerson()`函数，它接收一个ID并返回一个包含有关人员数据的对象：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Sum types* (also known as *union types*) are defined as a list of possible
    values. For example, our `getField()` function from [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, returns either the value of an attribute or `undefined`.
    For this, we can write the following signature:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*求和类型*（也称为*联合类型*）被定义为可能值的列表。例如，我们的`getField()`函数来自[*第6章*](B19301_06.xhtml#_idTextAnchor107)，*生成函数*，返回一个属性的值或`undefined`。为此，我们可以写出以下签名：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We could also define a type (union or otherwise) and use it in further definitions.
    For instance, the data types that can be directly compared and sorted are numbers,
    strings, and Booleans, so we could write the following definitions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以定义一个类型（联合或否则）并在进一步的定义中使用它。例如，可以直接比较和排序的数据类型有数字、字符串和布尔值，因此我们可以写出以下定义：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Afterward, we could specify that a comparison function can be defined in terms
    of the `Sortable` type, but be careful: there’s a hidden problem here!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以指定比较函数可以用`Sortable`类型来定义，但要注意：这里有一个隐藏的问题！
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous definition would allow us to write a function that received, say,
    a `number` and a `Boolean`. It doesn’t say that both types should be the same.
    However, there’s a way out. If you have constraints for some data types, you can
    express them before the actual signature, using a fat arrow, as shown in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的定义将允许我们编写一个接收，比如说，一个`number`和一个`Boolean`的函数。它并没有说这两种类型应该是相同的。然而，有一个解决办法。如果你对某些数据类型有约束，你可以在实际的签名之前表达它们，使用一个粗箭头，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The definition is now correct because all occurrences of the same type (denoted
    by the same letter, in this case, `a`) must be exactly the same. An alternative,
    but one that requires much more typing, would have been to write all three possibilities
    with a union:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的定义是正确的，因为所有相同类型（用相同的字母表示，在这种情况下是`a`）的出现必须完全相同。一个替代方案，但需要输入更多文字，就是用联合来写出所有三种可能性：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Actually, this definition isn’t very precise because you can compare any type,
    even if it doesn’t make much sense. However, bear with me for the sake of this
    example! If you want to refresh your memory about sorting and comparison functions,
    see [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个定义并不非常精确，因为你可以比较任何类型，即使它没有太多意义。然而，为了这个例子，请耐心一点！如果你想刷新你对排序和比较函数的记忆，请参阅[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)。
- en: 'So far, we have been using the standard type definitions. However, when working
    with JavaScript, we have to consider other possibilities, such as functions with
    optional parameters, or even with an undetermined number of parameters. We can
    use `...` to stand for any number of arguments and add `?` to represent an optional
    type, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用标准的类型定义。然而，当使用JavaScript时，我们必须考虑其他可能性，例如具有可选参数的函数，甚至具有不确定数量的参数的函数。我们可以使用`...`来表示任意数量的参数，并添加`?`来表示可选类型，如下所示：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `unary()` higher-order function we defined in the same chapter we cited
    previously took any function as a parameter and returned a unary function as its
    result. We can show that the original function can receive any number of arguments
    but that the result used only the first. The data type definition for this would
    be as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前引用的同一章中定义的`unary()`高阶函数接受任何函数作为参数，并返回一个一元函数作为其结果。我们可以表明原始函数可以接收任意数量的参数，但结果只使用了第一个。这个数据类型定义如下：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The standard `parseInt()` function provides an example of optional arguments,
    though it’s highly recommended that you don’t omit the second parameter (the base
    radix); you can, in fact, skip it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`parseInt()`函数提供了一个可选参数的例子，尽管强烈建议不要省略第二个参数（基数）；实际上，你可以跳过它。
- en: Fantastic definitions?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的定义？
- en: Check out [github.com/fantasyland/fantasy-land/](http://github.com/fantasyland/fantasy-land/)
    and [sanctuary.js.org/#types](http://sanctuary.js.org/#types) for a more formal
    definition and description of types, as applied to JavaScript.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查看github.com/fantasyland/fantasy-land/和sanctuary.js.org/#types以获取关于类型在JavaScript中应用的更正式定义和描述。
- en: 'From now on, throughout this chapter, we’ll not only be using TypeScript, but
    we will also be adding HM signatures to methods and functions, so you can get
    used to them. Let’s now change track and cover a highly important topic: *containers*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在本章的整个过程中，我们不仅将使用TypeScript，我们还将向方法和函数添加HM签名，这样你就可以习惯它们。现在让我们改变方向，覆盖一个高度重要的话题：*容器*。
- en: Building containers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器
- en: Back in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    and later, in [*Chapter 8*](B19301_08.xhtml#_idTextAnchor148), *Connecting Functions*,
    we saw that the ability to apply a mapping to all the elements of an array—and
    even better, being able to chain a sequence of similar operations—was an excellent
    way to produce better, more understandable code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B19301_05.xhtml#_idTextAnchor084)“声明式编程”和随后的[*第8章*](B19301_08.xhtml#_idTextAnchor148)“函数连接”中，我们看到了将映射应用于数组所有元素的能力——甚至更好的是，能够链式执行一系列类似操作——这是生成更好、更易于理解的代码的绝佳方式。
- en: 'However, there is a problem: the `map()` method (or the equivalent, demethodized
    one, which we looked at in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*) is only available for arrays, and we might want to be able to apply
    mappings and chaining to other data types. So, what can we do?'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：`map()`方法（或其等效的未方法化版本，我们在[*第6章*](B19301_06.xhtml#_idTextAnchor107)“生成函数”中讨论过）仅适用于数组，我们可能希望能够将映射和链式操作应用于其他数据类型。那么，我们能做什么呢？
- en: 'Let’s consider different ways of doing this, which will give us several new
    tools for better functional coding. Basically, there are only two possible ways
    of solving this: we can either add new methods to existing types (though that
    will be limited because we can only apply that to basic JavaScript types) or wrap
    types in some type of container, which will allow mapping and chaining.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑不同的实现方式，这将为我们提供几个新的工具，以更好地进行函数式编程。基本上，有两种可能的解决方案：我们可以向现有类型添加新方法（尽管这将有限，因为我们只能将其应用于基本JavaScript类型）或者将类型包装在某种容器中，这将允许映射和链式操作。
- en: Let’s start by extending current types before moving on to using wrappers, which
    will lead us into the deep functional territory with entities such as functors
    and monads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在转向使用包装器之前，让我们先扩展当前的数据类型，这将引导我们进入深度的函数式领域，涉及诸如函子（functors）和单子（monads）等实体。
- en: Extending current data types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展当前数据类型
- en: 'If we want to add mapping to basic JavaScript data types, we need to start
    by considering our options:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将映射添加到基本JavaScript数据类型，我们需要首先考虑我们的选项：
- en: With `null`, `undefined`, and `Symbol`, applying maps doesn’t sound too interesting
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`null`、`undefined`和`Symbol`，应用映射听起来并不那么有趣。
- en: We have some interesting possibilities with `Boolean`, `Number`, and `String`
    data types, so we can examine some of those
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`Boolean`、`Number`和`String`数据类型上有一些有趣的可能性，因此我们可以检查其中的一些。
- en: 'Applying mapping to an object is trivial: we just have to add a `map()` method,
    which must return a new object'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将映射应用于一个对象是微不足道的：我们只需添加一个`map()`方法，该方法必须返回一个新的对象。
- en: Finally, despite not being basic data types, we could also consider special
    cases, such as dates or functions, to which we could also add `map()` methods
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，尽管它们不是基本数据类型，但我们也可以考虑特殊案例，例如日期或函数，我们可以为它们添加`map()`方法。
- en: As in the rest of this book, we are sticking to plain JavaScript and TypeScript,
    but you should look into libraries such as Lodash, Underscore, or Ramda, which
    already provide functionalities similar to the ones we are developing here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书的其余部分一样，我们坚持使用纯JavaScript和TypeScript，但你应该研究Lodash、Underscore或Ramda等库，这些库已经提供了我们在这里开发的功能。
- en: A key point to consider in all these mapping operations should be that the returned
    value is of the same type as the original one. When we use `Array.map()`, the
    result is also an array, and similar considerations must apply to any other `map()`
    method implementations (you could observe that the resulting array may have different
    element types to the original one, but it is still an array).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些映射操作中，一个需要考虑的关键点是返回的值应该与原始类型相同。当我们使用`Array.map()`时，结果也是一个数组，类似的考虑必须适用于任何其他`map()`方法实现（你可以观察到结果数组可能具有与原始数组不同的元素类型，但它仍然是一个数组）。
- en: 'What could we do with a Boolean? First, let’s accept that Booleans are not
    containers, so they don’t really behave in the same way as an array. Trivially,
    a Boolean can only have a Boolean value, while an array may contain any type of
    element. However, accepting that difference, we can extend `Boolean.prototype`
    (though, as I’ve already mentioned, that’s not usually recommended) by adding
    a new `map()` method to it and making sure that whatever the mapping function
    returns is turned into a new Boolean value. For the latter, the solution will
    be similar to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用布尔值做什么呢？首先，让我们接受布尔值不是容器，因此它们并不真正以与数组相同的方式表现。显然，布尔值只能有布尔值，而数组可以包含任何类型的元素。然而，接受这种差异，我们可以通过向其中添加一个新的`map()`方法来扩展`Boolean.prototype`（尽管，如我之前提到的，这通常不推荐），并确保映射函数返回的任何内容都被转换成一个新的布尔值。对于后者，解决方案将与以下类似：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We already saw examples of adding a (fake) `this` parameter to a method, to
    let TypeScript know what type `this` will be—in this case, a Boolean. The `!!`
    operator forces the result to be a Boolean. `Boolean(fn(this))` could also have
    been used. This kind of solution can also be applied to numbers and strings, as
    shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何向一个方法添加一个（假的）`this`参数的例子，以让TypeScript知道`this`的类型是什么——在这种情况下，是一个布尔值。`!!`运算符强制结果成为一个布尔值。`Boolean(fn(this))`也可以使用。这种解决方案也可以应用于数字和字符串，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with Boolean values, we are forcing the results of the mapping operations
    to the correct data types. By the way, TypeScript won’t directly accept any of
    these new `map()` definitions; see *Question 12.1* to fix this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与布尔值一样，我们正在强制映射操作的结果转换为正确的数据类型。顺便说一句，TypeScript不会直接接受这些新的`map()`定义；参见*问题12.1*以修复此问题。
- en: 'Finally, if we wanted to apply mappings to a function, what would that mean?
    Mapping a function should produce a function. The logical interpretation for `f.map(g)`
    would be applying `f()`, and then applying `g()` to the result. So, `f.map(g)`
    should be the same as writing `x => g(f(x))` or, equivalently, `pipe(f,g)`. The
    definition is more complex than it was for the previous examples (but, in my opinion,
    simpler in HM than with TypeScript), so study it carefully:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想要将映射应用于一个函数，那意味着什么呢？映射一个函数应该产生一个函数。对于`f.map(g)`的逻辑解释将是先应用`f()`，然后对结果应用`g()`。因此，`f.map(g)`应该等同于写作`x
    => g(f(x))`或者，等价地，`pipe(f,g)`。这个定义比之前的例子更复杂（但在我看来，在HM中比在TypeScript中更简单），所以请仔细研究：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verifying that this works is simple, and the following code is an easy example
    of how to do this. The `times10()` mapping function is applied to the result of
    calculating `plus1(3)`, so the result is 40:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 验证这一点很简单，以下代码是展示如何做到这一点的简单示例。`times10()`映射函数被应用于计算`plus1(3)`的结果，因此结果是40：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this, we are done talking about what we can achieve with basic JavaScript
    types, but we need a more general solution if we want to apply this to other data
    types. We’d like to be able to apply mapping to any kind of value, and for that,
    we’ll need to create a container. We’ll do this in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们就完成了关于我们可以用基本JavaScript类型实现什么内容的讨论，但如果我们想将其应用于其他数据类型，我们需要一个更通用的解决方案。我们希望能够将映射应用于任何类型的值，为此，我们需要创建一个容器。我们将在下一节中这样做。
- en: Containers and functors
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和函子
- en: 'What we did in the previous section works and can be used without problems.
    However, we would like to consider a more general solution that we can apply to
    any data type. Since not all things in JavaScript provide the desired `map()`
    method, we will have to either extend the type (as we did in the previous section)
    or apply a design pattern that we considered in [*Chapter 11*](B19301_11.xhtml#_idTextAnchor204),
    *Implementing Design Patterns*: wrapping our data types with a wrapper that will
    provide the required `map()` operations.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们所做的工作是有效的，并且可以无问题地使用。然而，我们希望考虑一个更通用的解决方案，我们可以将其应用于任何数据类型。由于并非JavaScript中的所有事物都提供所需的`map()`方法，我们可能必须扩展类型（就像我们在上一节中所做的那样）或应用我们在[*第11章*](B19301_11.xhtml#_idTextAnchor204)中考虑的设计模式：用包装器包装我们的数据类型，该包装器将提供所需的`map()`操作。
- en: 'In particular, we will do the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将执行以下操作：
- en: Start by seeing how to build a basic container, wrapping a value
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先看看如何构建一个基本的容器，包装一个值
- en: Convert the container into something more powerful—a functor
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器转换成更强大的函子
- en: Study how to deal with missing values using a special functor, `Maybe`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用特殊的函子`Maybe`处理缺失值
- en: Wrapping a value – a basic container
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装一个值——一个基本容器
- en: 'Let’s pause for a minute and consider what we need from this wrapper. There
    are two basic requirements:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，考虑一下我们需要从这个包装器中得到什么。有两个基本要求：
- en: We must have a `map()` method
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个`map()`方法
- en: We need a simple way to wrap a value
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个简单的方式来封装一个值
- en: 'To get started, let’s create a basic container. Any object containing just
    a value would do, but we want some additions, so our object won’t be that trivial;
    we’ll explain the differences after the code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建一个基本的容器。任何只包含一个值的对象都可以，但我们希望有一些额外的功能，所以我们的对象不会那么简单；我们将在代码之后解释这些差异：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Some primary considerations that we need to keep in mind are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的一些基本考虑因素如下：
- en: We want to be able to store some value in a container, so the constructor takes
    care of that.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够在容器中存储一些值，因此构造函数负责这一点。
- en: Using a `protected` attribute avoids “tinkering” from the outside, but allows
    access to subclasses. (See *Question 12.2* for some JavaScript considerations.)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`protected`属性可以避免外部“篡改”，但允许子类访问。（参见*问题12.2*中的一些JavaScript考虑因素。）
- en: We need to be able to `map()`, so a method is provided for that.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够使用`map()`，因此提供了一个方法来实现这一点。
- en: 'Our barebones container is ready, but we can also add some other methods for
    convenience, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本容器已经准备好了，但我们也可以添加一些其他方法以方便使用，如下所示：
- en: To get the value of a container, we could use `map((x) => x)`, but that won’t
    work with more complex containers, so we’ll add a `valueOf()` method to get the
    contained value.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取容器的值，我们可以使用`map((x) => x)`，但对于更复杂的容器来说，这不会起作用，因此我们将添加一个`valueOf()`方法来获取包含的值。
- en: Being able to list a container can undoubtedly help with debugging. The `toString()`
    method will come in handy for this.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出容器无疑有助于调试。`toString()`方法将非常有用。
- en: Because we don’t need to write `new Container()` all the time, we can add a
    static `of()` method to do the same job.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不需要每次都写`new Container()`，我们可以添加一个静态的`of()`方法来完成同样的工作。
- en: A functional sin?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个禁忌？
- en: Working with classes to represent containers (and later, functors and monads)
    when living in a FP world may seem like heresy or sin... but remember that we
    don’t want to be dogmatic, and using classes simplifies our coding. Similarly,
    it could be argued that you must never take a value out of the container—but using
    a `valueOf()` method is sometimes too handy, so we won’t be that restrictive.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程的世界中，使用类来表示容器（以及后来的函子和单子）可能看起来像是异端或罪恶...但记住，我们不想过于教条，使用类可以简化我们的编码。同样，可以争论说，你永远不应该从容器中取出值——但使用`valueOf()`方法有时非常方便，所以我们不会那么限制。
- en: 'By taking all of this into account, our container is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们的容器如下：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we can use this container to store a value, and `map()` to apply any function
    to that value, but this isn’t very different from what we could do with a variable!
    Let’s enhance this a bit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个容器来存储一个值，并使用`map()`来对那个值应用任何函数，但这与我们使用变量所能做的并没有太大区别！让我们再增强一下这一点。
- en: Enhancing our container – functors
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强我们的容器 – 函子
- en: We want to have wrapped values, so what exactly should `map()` return? If we
    want to be able to chain operations, the only logical answer is that it should
    return a new wrapped object. In true functional style, when we apply a mapping
    to a wrapped value, the result will be another wrapped value that we can keep
    working on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拥有封装的值，那么`map()`函数究竟应该返回什么？如果我们想要能够链式调用操作，唯一合理的答案就是它应该返回一个新的封装对象。在真正的函数式风格中，当我们对一个封装值应用映射时，结果将是一个新的封装值，我们可以继续对其操作。
- en: A map by any other name
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何名称的映射
- en: Instead of `map()`, this operation is sometimes called `fmap()`, standing for
    *functorial map*. The rationale for the name change was to avoid expanding the
    meaning of `map()`. However, since we are working in a language that supports
    reusing the name, we can keep it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map()`不同，这个操作有时被称为`fmap()`，代表*函子映射*。名称变更的理由是为了避免扩展`map()`的含义。然而，由于我们正在使用一个支持重用名称的语言，我们可以保留它。
- en: 'We can extend our `Container` class to implement this change and get ourselves
    an enhanced container: a *functor*. The `of()` and `map()` methods will require
    a small change. For this, we’ll be creating a new class, as shown in the following
    code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的`Container`类扩展以实现这一变化，并得到一个增强的容器：一个*函子*。`of()`和`map()`方法将需要一些小的改动。为此，我们将创建一个新的类，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the `of()` method produces a `Functor` object, and so does the `map()`
    method. With these changes, we have just defined what a *functor* is in category
    theory! (Or, if you want to get really technical, a *pointed functor* because
    of the `of()` method—but let’s keep it simple.) We won’t go into the theoretical
    details, but roughly speaking, a functor is some container that allows us to apply
    `map()` to its contents, producing a new container of the same type. If this sounds
    familiar, it’s because you already know a functor: arrays! When you apply `map()`
    to an array, the result is a new array containing transformed (mapped) values.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`of()` 方法产生一个 `Functor` 对象，`map()` 方法也是如此。通过这些变化，我们刚刚定义了在范畴论中什么是 *函子*！（或者，如果你想真正技术化，由于
    `of()` 方法，它是一个 *带点函子*——但让我们保持简单。）我们不会深入理论细节，但大致来说，函子是一些容器，允许我们对其内容应用 `map()`，产生相同类型的新容器。如果你听起来很熟悉，那是因为你已经知道函子了：数组！当你对数组应用
    `map()` 时，结果是包含转换（映射）值的新数组。
- en: Extra requirements
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 额外要求
- en: There are more requirements for functors. First, the contained values may be
    polymorphic (of any type), just like arrays. Second, a function must exist whose
    mapping produces the same contained value—`(x) => x` does this for us. Finally,
    applying two consecutive mappings must produce the same result as applying their
    composition. This means that `container.map(f).map(g)` must be the same as `container.map(compose(g,f))`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 函子有更多的要求。首先，包含的值可能是多态的（任何类型），就像数组一样。其次，必须存在一个函数，其映射会产生相同的包含值——`(x) => x` 就为我们做了这件事。最后，应用两个连续的映射必须产生与应用它们的组合相同的结果。这意味着
    `container.map(f).map(g)` 必须与 `container.map(compose(g,f))` 相同。
- en: 'Let’s pause for a moment and consider the signatures for our function and methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，考虑我们的函数和方法签名：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first function, `of()`, is the simplest: given a value of any type, it
    produces a functor of that type. The following two are also relatively simple
    to understand: given a functor, `toString()` always returns a string (no surprise
    there!), and if the functor-contained value is of a given type, `valueOf()` produces
    a result of that same type. The third one, `map()`, is more interesting. Given
    a function that takes an argument of type `a` and produces a result of type `b`,
    applying it to a functor that contains a value of type `a` produces a functor
    containing a value of type `b`. This is precisely what we described previously.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `of()` 是最简单的：给定任何类型的值，它会产生该类型的函子。接下来的两个也比较容易理解：给定一个函子，`toString()` 总是返回一个字符串（这不足为奇！），如果函子包含的值是给定类型，`valueOf()`
    会产生相同类型的值。第三个 `map()` 更有趣。给定一个接受类型 `a` 的参数并产生类型 `b` 的结果的函数，将其应用于包含类型 `a` 的值的函子会产生包含类型
    `b` 的值的函子。这正是我们之前描述的。
- en: Promises and Functors
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 和 Functors
- en: You could compare functors to promises, at least in one aspect. With functors,
    instead of acting on its value directly, you have to apply a function with `map()`.
    In promises, you do exactly the same, but using `then()` instead! In fact, there
    are more analogies, as we’ll be seeing soon.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将函子与承诺进行比较，至少在一个方面。在函子中，你无法直接对其值进行操作，而是必须使用 `map()` 应用一个函数。在承诺中，你完全一样，但使用
    `then()`！实际上，还有更多的类比，我们很快就会看到。
- en: As is, functors are not allowed or expected to produce side effects, throw exceptions,
    or exhibit any other behavior outside of producing a container-ed result. Their
    main usage is to provide us with a way to manipulate a value, apply operations
    to it, compose results, and so on, without changing the original value—in this
    sense, we are once again coming back to immutability.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，函子不允许或预期产生副作用、抛出异常或展示任何其他在产生容器结果之外的行为。它们的主要用途是提供一种方式来操作值、对其应用操作、组合结果等，而不改变原始值——从这个意义上说，我们再次回到了不可变性。
- en: However, you could reasonably say that this isn’t enough since, in everyday
    programming, it’s pretty common to have to deal with exceptions, undefined or
    null values, and so on. So, let’s start by looking at more examples of functors.
    After that, we’ll enter the realm of monads to look at even more sophisticated
    processing. Let’s experiment a bit!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以说这还不够，因为在日常编程中，处理异常、未定义或空值等情况是非常常见的。所以，让我们先看看更多关于函子的例子。之后，我们将进入单子的领域，看看更复杂的处理。让我们实验一下！
- en: Dealing with missing values with Maybe
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Maybe 处理缺失值
- en: 'A common problem in programming is dealing with missing values. There are many
    possible causes for this situation: a web service Ajax call may have returned
    an empty result, a dataset could be empty, an optional attribute might be missing
    from an object, and so on. In a normal imperative fashion, dealing with this kind
    of situation requires adding `if` statements or ternary operators everywhere to
    catch the possible missing value to avoid a certain runtime error. We can do better
    by implementing a `Maybe` functor to represent a value that may (or may *not*)
    be present! We will use two classes, `Just` (as in *just some value*) and `Nothing`,
    both of which are functors. The `Nothing` functor is particularly simple, with
    trivial methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中常见的一个问题是处理缺失值。这种情况可能有多种原因：一个Web服务的Ajax调用可能返回了一个空结果，一个数据集可能是空的，一个可选属性可能从对象中缺失，等等。在常规的命令式风格中，处理这种情况需要在每个地方添加`if`语句或三元运算符来捕获可能缺失的值以避免某些运行时错误。我们可以通过实现一个`Maybe`函子来表示可能（或可能*不*）存在的值来做得更好！我们将使用两个类，`Just`（表示*仅仅某个值*）和`Nothing`，它们都是函子。`Nothing`函子尤其简单，具有平凡的方法：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `isNothing()` method returns `true`, `toString()` returns constant text,
    and `map()` always returns itself, no matter what function it’s given.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNothing()`方法返回`true`，`toString()`返回恒定的文本，而`map()`无论给定什么函数都总是返回自身。'
- en: 'Moving forward, the `Just` functor is also a basic one, with the added `isNothing()`
    method (which always returns `false`, since a `Just` object isn’t `Nothing`),
    and a `map()` method that now returns `Maybe`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Just`函子也是一个基本的函子，增加了`isNothing()`方法（它总是返回`false`，因为`Just`对象不是`Nothing`），以及一个现在返回`Maybe`的`map()`方法：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, our `Maybe` class packs the logic needed to construct either `Nothing`
    or `Just`. If it receives an `undefined` or `null` value, `Nothing` will be constructed;
    in other cases, `Just` will be the result. The `of()` method has exactly the same
    behavior:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`Maybe`类包含了构建`Nothing`或`Just`所需的所有逻辑。如果它接收到一个`undefined`或`null`值，将构建`Nothing`；在其他情况下，结果是`Just`。`of()`方法具有完全相同的行为：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We are using an `abstract` class because you shouldn’t directly write `new
    Maybe(…)`; you should use `Maybe.of()` or directly build `Just` or `Nothing`.
    (If you are wondering how to do this in JavaScript, see *Question 12.3*.) We can
    quickly verify that this works by trying to apply an operation to either a valid
    value or a missing one. Let’s look at two examples of this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个`abstract`类，因为你不应该直接写`new Maybe(…)`；你应该使用`Maybe.of()`或直接构建`Just`或`Nothing`。（如果你想知道如何在JavaScript中这样做，请参阅*问题12.3*。）我们可以通过尝试对一个有效值或缺失值应用操作来快速验证这一点。让我们看看这个的两个例子：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we applied `plus1()` (twice) to `Maybe.of(2209)`, everything worked fine,
    and we ended up with a `Just(2011)` value. On the other hand, when we applied
    the same sequence of operations to a `Maybe.of(null)` value, the end result was
    `Nothing`, but there were no errors, even if we tried to do math with a `null`
    value. A `Maybe` functor can deal with mapping a missing value by just skipping
    the operation and returning a wrapped `null` value instead. This means that this
    functor includes an abstracted check, which won’t let an error happen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`plus1()`（两次）应用于`Maybe.of(2209)`时，一切正常，我们最终得到了一个`Just(2011)`值。另一方面，当我们将相同的操作序列应用于`Maybe.of(null)`值时，最终结果是`Nothing`，即使我们尝试用`null`值进行数学运算，也没有错误。一个`Maybe`函子可以通过跳过操作并返回一个包装的`null`值来处理映射缺失值。这意味着这个函子包含了一个抽象的检查，它不会让错误发生。
- en: (Later in this chapter, we’ll see that `Maybe` can actually be a monad instead
    of a functor, and we’ll also examine more examples of monads.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: （在本章的后面部分，我们将看到`Maybe`实际上可以是一个函子而不是函子，我们还将检查更多关于函子的例子。）
- en: Let’s look at a more realistic example of its usage.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它使用的一个更现实的例子。
- en: Dealing with varying API results
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理变化的API结果
- en: 'Suppose we are writing a small server-side service in Node.js to get the weather
    alerts for a city and produce a not-very-fashionable HTML `<table>` with them,
    to be part of some server-side-produced web page. (Yes, I know you should try
    to avoid tables in your pages, but I want a short example of HTML generation,
    and the actual results aren’t significant.) If we used the *Dark Sky* API (see
    [darksky.net](http://darksky.net) for more on this API and how to register with
    it) to get the alarms, our code would be something like the following, all quite
    normal. Note the callback in case of an error; you’ll see why in the following
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在用 Node.js 编写一个小型的服务器端服务，用于获取某个城市的天气警报，并生成一个不太时尚的 HTML `<table>` 表格，作为某个服务器端生成的网页的一部分。（是的，我知道你应该尽量避免在页面上使用表格，但我只想举一个简单的
    HTML 生成示例，实际结果并不重要。）如果我们使用 *Dark Sky* API（有关此 API 的更多信息以及如何注册，请参阅 [darksky.net](http://darksky.net)），来获取警报，我们的代码可能如下所示，都是相当正常的。注意错误情况下的回调；你将在下面的代码中看到原因：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The (heavily edited and reduced in size) output of such a call might be something
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的调用（经过大量编辑和缩小尺寸）的输出可能如下所示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I got this information for Houston, TX, US, on a day when Hurricane Harvey
    was approaching the state. If you called the API on a normal day, the data would
    not include the `alerts:[...]` part. Here, we can use a `Maybe` functor to process
    the received data without any problems, with or without any alerts:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我是在美国德克萨斯州休斯顿获取的这些信息，那天飓风哈维正在接近该州。如果你在正常的日子里调用 API，数据将不会包括 `alerts:[...]` 部分。在这里，我们可以使用
    `Maybe` 函子来处理接收到的数据，无论是否有任何警报：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Of course, you would probably do something more interesting than just logging
    the value of the contained result of `produceAlertsTable()`! The most likely option
    would be to use `map()` again with a function that would output the table, send
    it to a client, or do whatever you needed to do. In any case, the resulting output
    would look something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能不会仅仅记录 `produceAlertsTable()` 包含的结果的值。最可能的选择是再次使用 `map()`，并使用一个函数来输出表格，将其发送到客户端，或者执行你需要做的任何事情。在任何情况下，最终的输出看起来可能如下所示：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the preceding code can be seen in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出可以在以下屏幕截图中看到：
- en: '![Figure 12.1 – The output table is not much to look at, but the logic that
    produced it didn’t require a single if statement](img/Figure_12.1_B9301.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 输出表格看起来并不怎么样，但生成它的逻辑并没有使用任何 if 语句](img/Figure_12.1_B9301.jpg)'
- en: Figure 12.1 – The output table is not much to look at, but the logic that produced
    it didn’t require a single if statement
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 输出表格看起来并不怎么样，但生成它的逻辑并没有使用任何 if 语句
- en: If we had called `getAlerts(-34.9, -54.60, ...)` with the coordinates for Montevideo,
    Uruguay, instead, since there were no alerts for that city, the `getField("alerts")`
    function would have returned `undefined`—and since that value is recognized by
    the `Maybe` functor, and even though all the following `map()` operations would
    still be executed, no one would actually do anything, and a `null` value would
    be the final result.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用蒙得维的亚，乌拉圭的坐标调用 `getAlerts(-34.9, -54.60, ...)`，由于该城市没有警报，`getField("alerts")`
    函数将返回 `undefined`——由于该值被 `Maybe` 函子识别，尽管接下来的所有 `map()` 操作仍然会执行，但实际上没有人会做任何事情，最终结果将是
    `null` 值。
- en: We took advantage of this behavior when we coded the error logic. If an error
    occurs when calling the service, we would still call the original callback to
    produce a table but provide an empty object. Even if this result is unexpected,
    we would be safe because the same guards would avoid causing a runtime error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写错误逻辑时利用了这种行为。如果在调用服务时发生错误，我们仍然会调用原始回调来生成表格，但提供一个空对象。即使这个结果出乎意料，我们也会很安全，因为相同的防护措施将避免导致运行时错误。
- en: 'As a final enhancement, we can add an `orElse()` method to provide a default
    value when no value is provided. The added method will return the default value
    if `Maybe` is `Nothing`, or the `Maybe` value itself otherwise:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的增强，我们可以添加一个 `orElse()` 方法，在未提供值时提供一个默认值。如果 `Maybe` 是 `Nothing`，则添加的方法将返回默认值，否则返回
    `Maybe` 值本身：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using this new method instead of `valueOf()`, trying to get the alerts for
    someplace without weather warnings would just return a default result. In the
    case we mentioned previously, attempting to get the alerts for Montevideo, instead
    of a `null` value, we would get the following appropriate result:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新方法代替 `valueOf()`，尝试获取没有天气警告的地方的警报，只会返回默认结果。在我们之前提到的例子中，尝试获取蒙得维的亚的警报，而不是
    `null` 值，我们会得到以下适当的结果：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this, we have looked at an example of dealing with different situations
    when working with an API. Let’s quickly revisit another topic from a previous
    chapter and look at a better implementation of prisms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了处理与 API 一起工作时不同情况的一个示例。让我们快速回顾一下之前章节中的另一个主题，并看看棱镜的更好实现。
- en: Implementing prisms
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现棱镜
- en: 'The more common implementations of prisms (which we first met in the *Prisms*
    section of [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188)*, Ensuring Purity*),
    instead of returning either some value or `undefined` and leaving it up to the
    caller to check what happened, opt to return `Maybe`, which already provides us
    with easy ways to deal with missing values. In our new implementation (which we’ll
    look at soon), our example from the aforementioned chapter would look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的棱镜实现（我们首次在 [*第10章*](B19301_10.xhtml#_idTextAnchor188)*，确保纯净性*）部分中遇到），而不是返回某个值或
    `undefined` 并让调用者检查发生了什么，而是选择返回 `Maybe`，这已经为我们提供了处理缺失值的简单方法。在我们的新实现（我们很快就会看到）中，上述章节中的示例将看起来像这样：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we wanted to access the `author.user` attribute, the result would be different:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要访问 `author.user` 属性，结果将不同：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, if we asked for a non-existent pseudonym attribute, instead of `undefined`
    (as in our previous version of `Prism`), we would get `Nothing`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们请求一个不存在的别名属性，而不是 `undefined`（如我们之前版本的 `Prism`），我们会得到 `Nothing`：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, this new version of `Prism` is better to work with if you are already used
    to dealing with `Maybe` values. What do we need to implement this? We need just
    a single change; our `Constant` class now needs to return `Maybe` instead of a
    value, so we’ll have a new `ConstantP` (`P` for `Prism`) class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你已经习惯了处理 `Maybe` 值，那么这个 `Prism` 的新版本会更好用。我们需要做些什么来实现这个功能呢？我们只需要一个改动；我们的
    `Constant` 类现在需要返回 `Maybe` 而不是值，因此我们将有一个新的 `ConstantP` (`P` 代表 `Prism`) 类：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will have to rewrite `preview()` to use the new class, and that finishes
    the change:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不重写 `preview()` 以使用新的类，这样改动就完成了：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, getting `Prism` to work with `Maybe` wasn’t that hard, and now we have
    a consistent way of dealing with possibly missing attributes. Working in this
    fashion, we can simplify our coding and avoid many tests for nulls and other similar
    situations. However, we may want to go beyond this; for instance, we may want
    to know why there were no alerts: was it a service error? Or just a normal situation?
    Just getting null at the end isn’t enough, and to work with these new requirements,
    we will need to add some extra functionality to our functors (as we’ll see in
    the next section) and enter the domain of *monads*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让 `Prism` 与 `Maybe` 一起工作并不那么困难，现在我们有了处理可能缺失属性的一致方式。以这种方式工作，我们可以简化我们的编码并避免许多对空值的测试和其他类似情况。然而，我们可能想要做得更多；例如，我们可能想知道为什么没有警报：是服务错误吗？还是只是一个正常情况？仅仅在最后得到空值是不够的，为了满足这些新要求，我们需要向我们的函子添加一些额外的功能（我们将在下一节中看到），并进入
    *单子* 的领域。
- en: Monads
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子
- en: Monads have weird fame among programmers. Well-known developer Douglas Crockford
    has famously spoken of a curse, maintaining that “*Once you happen to finally
    understand monads, you immediately lose the ability to explain them to other people!*
    ” On a different note, if you decide to go back to the basics and read *Categories
    for the Working Mathematician* by Saunders Mac Lane (one of the creators of category
    theory), you may find a somewhat disconcerting explanation—which is not too illuminating!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 单子在程序员中有着奇特的名声。知名开发者 Douglas Crockford 曾著名地提到一个诅咒，认为“*一旦你最终理解了单子，你立即失去了向其他人解释它们的能力!*
    ”另一方面，如果你决定回到基础并阅读 Saunders Mac Lane 的 *工作数学家的范畴学*（范畴理论的创始人之一），你可能会发现一个多少有些令人不安的解释——这并不是特别有启发性！
- en: A monad in X is just a monoid in the category of endofunctors of X, with product
    × replaced by composition of endofunctors and unit set by the identity endofunctor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 X 中的单子就是 X 的内射函子范畴中的幺半群，其中乘积 × 被内射函子的组合所替代，单位集由恒等内射函子所构成。
- en: The difference between monads and functors is that the former adds some extra
    functionality; we’ll see what functionality they add soon. Let’s start by looking
    at the new requirements before moving on and considering some common, useful monads.
    As with functors, we will have a basic monad, which you could consider an *abstract*
    version, and specific *monadic types*, which are *concrete* implementations geared
    to solve specific cases.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单子和模范函数之间的区别在于前者添加了一些额外的功能；我们很快就会看到它们添加了哪些功能。让我们先看看新的要求，然后再考虑一些常见且有用的单子。与模范函数一样，我们将有一个基本的单子，你可以将其视为一个
    *抽象* 版本，以及特定的 *单子类型*，它们是针对解决特定情况的具体实现。
- en: All you could want to read
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你想阅读的一切
- en: 'To read a precise and careful description of functors, monads, and their family
    (but leaning heavily to the theoretical side, with plenty of algebraic definitions
    to go around), try the *Fantasy Land Specification* at [github.com/fantasyland/fantasy-land/](http://github.com/fantasyland/fantasy-land/).
    Please don’t say we didn’t warn you: the alternative name for that page is *Algebraic*
    *JavaScript Specification*!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读关于模范函数、单子和它们家族的精确和细致的描述（但侧重于理论方面，有很多代数定义），请尝试查看 [github.com/fantasyland/fantasy-land/](http://github.com/fantasyland/fantasy-land/)
    的 *Fantasy Land Specification*。请别说我没有警告你：该页面的另一个名称是 *代数* *JavaScript Specification*！
- en: Adding operations
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加操作
- en: 'Let’s consider a simple problem. Suppose you have the following pair of functions,
    working with `Maybe` functors: the first function tries to search for something
    (say, a client or a product) given its key, and the second attempts to extract
    some attribute from whatever we found (I’m being purposefully vague because the
    problem does not have anything to do with whatever objects or things we may be
    working with). Both functions produce `Maybe` results to avoid possible errors.
    We are using a mocked search function just to help us see the problem. For even
    keys, it returns fake data, and for odd keys, it throws an exception. The code
    for this search is very simple:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的问题。假设你有一对函数，它们使用 `Maybe` 模范函数：第一个函数尝试根据其键搜索某些内容（比如，客户或产品），第二个函数尝试从找到的任何内容中提取一些属性（我故意说得模糊，因为这个问题与我们可能正在处理的任何对象或事物无关）。这两个函数都产生
    `Maybe` 结果以避免可能的错误。我们使用一个模拟的搜索函数只是为了帮助我们理解这个问题。对于偶数键，它返回假数据，对于奇数键，它抛出异常。这个搜索的代码非常简单：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using this search, our `findSomething()` function will try to do a search and
    return `Maybe.of()` (a `Just`) for a successful call, or `Maybe.of(null)` (a `Nothing`)
    in case of an error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个搜索，我们的 `findSomething()` 函数将尝试进行搜索，并在成功调用时返回 `Maybe.of()`（一个 `Just`），在出错时返回
    `Maybe.of(null)`（一个 `Nothing`）：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this, we could think of writing these two functions to do some searching,
    but not everything would be fine; can you see the problem here?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可能会认为可以编写这两个函数来进行一些搜索，但并不是所有事情都会顺利；你能看到这里的问题吗？
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The problem in this sequence is that the output from `getSome()` is a `Maybe`
    value, which itself contains a `Maybe` value, so the result we want is double-wrapped,
    as we can see by executing a couple of calls, for an even number (which will return
    `"whatever"`) and for an odd number (which will be an error), as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列中的问题是 `getSome()` 的输出是一个 `Maybe` 值，它本身又包含一个 `Maybe` 值，所以结果被双重封装，正如我们可以通过执行几个调用所看到的，对于偶数（将返回
    `"whatever"`）和奇数（将是一个错误），如下所示：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This problem can be easily solved in this toy problem if we avoid using `Maybe.of()`
    in `getSome()`, but this kind of issue can arise in many more complex ways. For
    instance, you could be building a `Maybe` out of an object, one of whose attributes
    happened to be a `Maybe`, and you’d end up in the same situation when accessing
    that attribute: you would end up with a double-wrapped value.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个玩具问题中避免在 `getSome()` 中使用 `Maybe.of()`，这个问题就可以轻松解决，但这类问题可能会以许多更复杂的方式出现。例如，你可能会从一个对象中构建一个
    `Maybe`，该对象的某个属性恰好是一个 `Maybe`，当你访问该属性时，你将遇到相同的情况：你将得到一个双重封装的值。
- en: 'Now, we are going to look into monads. A monad should provide the following
    operations:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨单子。一个单子应该提供以下操作：
- en: A constructor.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数。
- en: 'A function that inserts a value into a monad: our `of()` method.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将值插入到单子中的函数：我们的 `of()` 方法。
- en: 'A function that allows us to chain operations: our `map()` method.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许我们链式操作的功能：我们的 `map()` 方法。
- en: 'A function that can remove extra wrappers: we will call it `unwrap()`. It will
    solve our preceding multiple wrapper problems. Sometimes, this function is called
    `flatten()`.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以移除额外包装器的函数：我们将称之为`unwrap()`。它将解决我们之前的多重包装问题。有时，这个函数被称为`flatten()`。
- en: 'To simplify our coding, we will also have a function to chain calls and another
    function to apply functions, but we’ll get to those later. Let’s see what a monad
    looks like in actual JavaScript code. Data type specifications are very much like
    those for functors, so we won’t repeat them here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的编码，我们还将有一个用于链式调用的函数，另一个用于应用函数的函数，但我们会稍后讨论这些。让我们看看在实际的JavaScript代码中，单子（monad）看起来是什么样子。数据类型规范与函子（functor）的规范非常相似，所以我们在这里不再重复：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We use recursion to successively remove wrappers until the wrapped value isn’t
    a container anymore. Using this method, we could avoid double wrapping easily,
    and we could rewrite our previous troublesome function like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用递归来连续移除包装器，直到包装的值不再是容器为止。使用这种方法，我们可以轻松地避免双重包装，并且我们可以像这样重写我们之前麻烦的函数：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'However, this sort of problem could reoccur at different levels. For example,
    if we were doing a series of `map()` operations, any intermediate results may
    end up double-wrapped. You could solve this by remembering to call `unwrap()`
    after each `map()`—note that you could do this even if it is not actually needed
    since the result of `unwrap()` would be the very same object (can you see why?).
    But we can do better! Let’s define a `chain()` operation (sometimes named `flatMap()`
    instead, which is a bit confusing since we already have another meaning for that;
    see [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084), *Programming Declaratively*,
    for more on this) that will do both things for us:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这类问题可能会在不同级别上重复出现。例如，如果我们进行一系列的`map()`操作，任何中间结果最终可能会被双重包装。你可以通过记住在每次`map()`之后调用`unwrap()`来解决此问题——请注意，即使实际上不需要这样做，你也可以这样做，因为`unwrap()`的结果将是完全相同的对象（你能看到为什么吗？）。但我们可以做得更好！让我们定义一个`chain()`操作（有时也称为`flatMap()`，这有点令人困惑，因为我们已经为另一个含义赋予了它的名字；有关更多信息，请参阅[*第5章*](B19301_05.xhtml#_idTextAnchor084)，*声明式编程*），这个操作将为我们完成这两件事：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There’s only one operation left. Suppose you have a curried function with two
    parameters—nothing outlandish! What would happen if you provided that function
    to a `map()` operation?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下最后一个操作。假设你有一个有两个参数的柯里化函数——这没什么奇怪的！如果你将这个函数提供给`map()`操作，会发生什么？
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What would `something` be? Given that we have only provided one argument to
    add, the result of that application will be a function—not just any function,
    though, but a wrapped one! (Since functions are first-class objects, there’s no
    logical obstacle to wrapping a function in a monad, is there?) What would we want
    to do with such a function? To be able to apply this wrapped function to a value,
    we’ll need a new method: `ap()`. What could its value be? In this case, it could
    either be a plain number or a number wrapped in a monad as a result of other operations.
    Since we can always map a plain number into a wrapped one with `Map.of()`, let’s
    have `ap()` work with a monad as its parameter; the new method would be as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`something`会是什么？鉴于我们只提供了一个参数来添加，该应用的结果将是一个函数——但不是一个普通的函数，而是一个被包装的函数！（由于函数是一等对象，将函数包装在单子中没有逻辑障碍，对吧？）我们想用这样的函数做什么？为了能够将这个包装函数应用于一个值，我们需要一个新的方法：`ap()`。它的值会是什么？在这种情况下，它可以是普通的数字，也可以是其他操作的结果而被单子包装的数字。由于我们总是可以用`Map.of()`将普通数字映射到一个包装的数字，让我们让`ap()`以单子作为其参数；新的方法如下：'
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this, you could then do the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，你就可以做以下事情：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can use monads to hold values or functions and to interact with other monads
    and chaining operations as you wish. So, as you can see, there’s no big trick
    to monads, which are just functors with some extra methods. Now, let’s look at
    how we can apply them to our original problem and handle errors in a better way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单子来持有值或函数，并按需与其他单子和链式操作交互。所以，正如你所看到的，单子并没有什么大技巧，它们只是具有一些额外方法的函子。现在，让我们看看我们如何将它们应用于我们的原始问题，并以更好的方式处理错误。
- en: Handling alternatives – the Either monad
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理替代方案——Either单子
- en: 'Knowing that a value was missing may be enough in some cases, but in others,
    you’ll want to be able to provide an explanation. We can get such an explanation
    if we use a different functor, which will take one of two possible values—one
    associated with a problem, error, or failure, and another associated with normal
    execution, or success:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，知道一个值缺失可能就足够了，但在其他情况下，你可能希望能够提供一个解释。如果我们使用不同的函子，我们可以得到这样的解释，这个函子将取两个可能值之一——一个与问题、错误或失败相关联，另一个与正常执行或成功相关联：
- en: A *left* value, which should be null, but if present, then it represents some
    special value (for example, an error message or a thrown exception) that cannot
    be mapped over
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**左**值，它应该是null，但如果存在，则表示一些特殊值（例如，错误消息或抛出的异常），这些值不能被映射
- en: A *right* value, which represents the normal value of the functor and can be
    mapped over
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**正确**的值，它代表函子的正常值，并且可以被映射
- en: 'We can construct this monad similarly to what we did for `Maybe` (actually,
    the added operations make it better for `Maybe` to extend `Monad` as well). The
    constructor will receive a left and a right value. If the left value is present,
    it will become the value of the `Either` monad; otherwise, the right value will
    be used. Since we have provided `of()` methods for all our functors, we need one
    for `Either` too. The `Left` monad is very similar to our previous `Nothing`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像为`Maybe`所做的那样构建这个单子（实际上，添加的操作使`Maybe`扩展`Monad`变得更好）。构造函数将接收一个左值和一个右值。如果左值存在，它将成为`Either`单子的值；否则，将使用右值。由于我们已经为所有我们的函子提供了`of()`方法，我们也需要为`Either`提供一个。`Left`单子与我们之前的`Nothing`非常相似：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Similarly, `Right` resembles our previous `Just`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Right`与我们之前的`Just`相似：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And with these two monads under our belt, we can write our `Either` monad. It
    shouldn’t be surprising that this resembles our previous `Maybe`, should it?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了这两个单子，我们可以编写我们的`Either`单子。这和之前的`Maybe`相似，这并不令人惊讶，对吧？
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `map()` method is key. If this functor has got a left value, it won’t be
    processed any further; in other cases, the mapping will be applied to the right
    value, and the result will be wrapped. Now, how can we enhance our code with this?
    The key idea is for every involved method to return an `Either` monad; `chain()`
    will be used to execute operations one after another. Getting the alerts would
    be the first step—we invoke the callback either with an `AJAX FAILURE` message
    or with the result from the API call, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`方法是关键。如果这个函子有一个左值，它将不会被进一步处理；在其他情况下，映射将被应用于右值，并且结果将被包装。现在，我们如何用这个来增强我们的代码？关键思想是让每个涉及的方法都返回一个`Either`单子；`chain()`将用于依次执行操作。获取警报将是第一步——我们用`AJAX
    FAILURE`消息或API调用的结果调用回调，如下所示：'
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, the general process would be as follows. We use an `Either` monad again.
    If there are no alerts, instead of an array, we will return a `"NO` `ALERTS"`
    message:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一般的过程是这样的。我们再次使用`Either`单子。如果没有警报，我们将返回一个`"NO ALERTS"`消息，而不是一个数组：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note how we used `chain()` so that multiple wrappers would be no problem. Now,
    we can test multiple situations and get appropriate results—or at least, for the
    current weather situation around the world!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`chain()`，这样多个包装器就不会有问题。现在，我们可以测试多种情况并得到适当的结果——至少，对于全球当前的天气状况来说是这样！
- en: For Houston, TX, we still get an HTML table
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于德克萨斯州的休斯顿，我们仍然得到一个HTML表格
- en: For Montevideo, UY, we get a text saying there were no alerts
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于乌拉圭的蒙得维的亚，我们得到一条消息说没有警报
- en: 'For a point with wrong coordinates, we learn that the AJAX call failed: nice!'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于坐标错误的点，我们了解到AJAX调用失败了：太好了！
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We are not done with the `Either` monad. It’s likely that much of your code
    will involve calling functions. Let’s look at a better way of achieving this by
    using a variant of this monad.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成`Either`单子的工作。很可能你的代码将涉及调用函数。让我们看看如何通过使用这个单子的一个变体来更好地实现这一点。
- en: Calling a function – the Try monad
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用一个函数——Try单子
- en: 'If we are calling functions that may throw exceptions and we want to do so
    in a functional way, we could use the `Try` monad to encapsulate the function
    result or the exception. The idea is basically the same as the `Either` monad.
    The only difference is in the constructor, which receives a function and calls
    it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用可能会抛出异常的函数，并且想以函数式的方式这样做，我们可以使用`Try`单子来封装函数结果或异常。基本思想与`Either`单子相同。唯一的不同在于构造函数，它接收一个函数并调用它：
- en: If there are no problems, the returned value becomes the `right` value for the
    monad
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有问题，返回的值将成为单子的右值
- en: If there’s an exception, it will become the `left` value
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有异常，它将成为`left`值
- en: 'This can be seen in the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下代码中看到：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Why the `@ts-expect-error` notation? A constructor should either call `super()`
    or return a fully constructed method, but TypeScript always expects the former,
    so we have to tell it that we know what we’re doing here.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`@ts-expect-error`注解？构造函数应该要么调用`super()`，要么返回一个完全构建的方法，但TypeScript总是期望前者，因此我们必须告诉它我们在这里知道我们在做什么。
- en: 'Now, we can invoke any function, catching exceptions in a good way. For example,
    the `getField()` function that we have been using would crash if it were called
    with a `null` argument:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以良好的方式调用任何函数，并捕获异常。例如，我们一直在使用的`getField()`函数，如果它被一个`null`参数调用，将会崩溃：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the *Implementing prisms* section of [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, we wrote a `getFieldP()` function that could deal with `null`
    values, but here, we will rewrite it using the `Try` monad, so, in addition, it
    will play nice with other composed functions. The alternative implementation of
    our getter would be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19301_10.xhtml#_idTextAnchor188)的*实现prisms*部分中，*确保纯净性*，我们编写了一个`getFieldP()`函数，它可以处理`null`值，但在这里，我们将使用`Try`
    monad重写它，因此，它还将与其他组合函数很好地协同工作。我们的getter的替代实现如下：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can check that this works by trying to apply our new function to a null
    value:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试将我们的新函数应用于一个空值来检查这是否有效：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There are many more monads, and, of course, you can even define your own, so
    we couldn’t possibly go over all of them. However, let’s visit just one more—one
    you have been using already, without being aware of its monad-ness!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的monads，当然，你甚至可以定义自己的，所以我们不可能涵盖所有这些。然而，让我们参观最后一个——你已经使用过，但没有意识到它的monad特性！
- en: Unexpected monads – promises
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 意料之外的monads——承诺
- en: 'Let’s finish this section on monads by mentioning yet another one that you
    may have used, though under a different name: promises! Previously, we mentioned
    that functors (and, remember, monads are functors) had at least something in common
    with promises: using a method to access the value. However, the similarities are
    greater than that!'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提及另一个你可能已经使用过但名称不同的monad来结束关于monad的这部分内容：承诺！之前，我们提到过，functors（记住，monads也是functors）至少在一点上与承诺有共同之处：使用方法来访问值。然而，相似之处远不止于此！
- en: '`Promise.resolve()` corresponds with `Monad.of()`—if you pass a value to `.resolve()`,
    you’ll get a promise resolved to that value, and if you provide a promise, you
    will get a new promise, the value of which will be that of the original one (see
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
    for more on this). This is an unwrapping behavior!'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.resolve()`对应于`Monad.of()`——如果你向`.resolve()`传递一个值，你将得到一个解析为该值的承诺，如果你提供一个承诺，你将得到一个新的承诺，其值将是原始承诺的值（有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)）。这是一个解包行为！'
- en: '`Promise.then()` stands for `Monad.map()` as well as `Monad.chain()`, given
    the mentioned unwrapping.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.then()`代表`Monad.map()`以及`Monad.chain()`，考虑到提到的解包行为。'
- en: 'We don’t have a direct match to `Monad.ap()`, but we could add something like
    the following code (this will be rejected by TypeScript, but we’ve seen how to
    solve this):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有直接匹配`Monad.ap()`的对应物，但我们可以添加一些类似以下代码的东西（这将由TypeScript拒绝，但我们已经看到了如何解决这个问题）：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Promises – never gone
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺——永不消失
- en: Even if you opt for the modern `async` and `await` features, internally, they
    are based on promises. Furthermore, in some situations, you may still need `Promise.race()`
    and `Promise.all()`, so you will likely keep using promises, even if you opt for
    full ES8 coding.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你选择了现代的`async`和`await`特性，在内部，它们基于承诺。此外，在某些情况下，你可能仍然需要`Promise.race()`和`Promise.all()`，所以即使你选择了完整的ES8编码，你也很可能会继续使用承诺。
- en: This is an appropriate ending for this section. Earlier, you found that ordinary
    arrays were, in fact, functors. Now, in the same way that Monsieur Jourdain (a
    character in Molière’s play *Le Bourgeois Gentilhomme*, *The Bourgeois Gentleman*)
    discovered that all his life he had been speaking in prose, you now know you had
    already been using monads without even knowing it! So far, we have learned how
    to build different types of containers. Now, let’s learn how functions can also
    make do as containers, as well as for all kinds of data structures!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对本节的适当结束。之前，你发现普通的数组实际上是函子。现在，就像Monsieur Jourdain（莫里哀戏剧《Le Bourgeois Gentilhomme》中的角色，《The
    Bourgeois Gentleman》）发现他一生都在用散文说话一样，你现在知道你已经在不知不觉中使用了单子！到目前为止，我们已经学习了如何构建不同类型的容器。现在，让我们学习函数如何也能作为容器，以及所有种类的数据结构！
- en: Functions as data structures
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为数据结构
- en: So far, we have learned how to use functions to work with or transform other
    functions to process data structures or to create data types. Now, we’ll finish
    this chapter by showing you how a function can implement a data type, becoming
    a container of its own. In fact, this is a fundamental theoretical point of lambda
    calculus (if you want to learn more, look up *Church encoding* and *Scott encoding*),
    so we may very well say that we have come back to where we began this book, to
    the origins of FP! We will start with a detour that considers binary trees in
    a different functional language, Haskell, and then move on to implementing trees
    as functions, but in JavaScript. This experience will help you work out how to
    deal with other data structures.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用函数来处理或转换其他函数以处理数据结构或创建数据类型。现在，我们将通过展示一个函数如何实现数据类型，成为其自己的容器来结束这一章。实际上，这是λ演算的一个基本理论点（如果你想了解更多，可以查阅*Church编码*和*Scott编码*），所以我们可以说，我们确实回到了这本书的开头，回到了函数式编程的起源！我们将从一个考虑二叉树的不同函数式语言，Haskell的偏离开始，然后转向在JavaScript中实现作为函数的树。这次经历将帮助你弄清楚如何处理其他数据结构。
- en: Binary trees in Haskell
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Haskell中的二叉树
- en: 'Consider a binary tree. Such a tree may either be empty or consist of a node
    (the tree *root*) with two children: a *left* binary tree and a *right* one. A
    node that has no children is called a *leaf*.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个二叉树。这样的树可能为空，或者由一个节点（树的*根节点*）及其两个子节点组成：一个*左*二叉树和一个*右*二叉树。没有子节点的节点称为*叶节点*。
- en: Of many types of trees
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 树的许多类型
- en: In [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, we
    worked with more general tree structures, such as a filesystem or the browser
    DOM itself, which allow a node to have any number of children. In the case of
    the trees in this section, each node always has two children, although each of
    them may be empty. The difference may seem minor, but allowing for empty subtrees
    lets you define that all nodes are binary.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19301_09.xhtml#_idTextAnchor172) *设计函数*中，我们处理了更通用的树结构，例如文件系统或浏览器DOM本身，这些结构允许一个节点有任意数量的子节点。在本节中的树的情况下，每个节点总是有两个子节点，尽管它们中的每一个都可能为空。这种差异可能看起来很小，但允许空子树可以使你定义所有节点都是二元的。
- en: 'Let’s make a digression with the Haskell language. In it, we might write something
    like the following; `a` would be the type of whatever value we hold in the nodes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Haskell语言做一个偏离。在其中，我们可能会写如下内容；`a`将是节点中持有的任何值的类型：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the Haskell language, pattern matching is often used for coding. For example,
    we could define an empty function as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell语言中，模式匹配常用于编码。例如，我们可以如下定义一个空函数：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'What does this mean? Apart from the data type definition, the logic is simple:
    if the tree is `Nil` (the first possibility in the definition of the type), then
    the tree is certainly empty; otherwise, the tree isn’t empty. The last line would
    probably be written as `empty _ = False`, using `_` as a placeholder because you
    don’t actually care about the components of the tree; the mere fact that it’s
    not `Nil` suffices.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？除了数据类型定义之外，逻辑很简单：如果树是`Nil`（类型定义中的第一个可能性），那么树肯定是空的；否则，树不是空的。最后一行可能写成`empty
    _ = False`，使用`_`作为占位符，因为你实际上并不关心树的组件；它不是`Nil`的事实就足够了。
- en: 'Searching for a value in a binary search tree (in which the root is greater
    than all the values of its left subtree and less than all the values of its right
    subtree) would be written similarly:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树（其中根节点大于其左子树的所有值，小于其右子树的所有值）中搜索一个值的方式类似：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What patterns are matched here? We have four patterns now, which must be considered
    in order:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里匹配了哪些模式？我们现在有四种模式，必须按顺序考虑：
- en: An empty tree (`Nil`—it doesn’t matter what we are looking for, so just write
    `_`) doesn’t contain the searched value.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空树（`Nil`——我们寻找什么并不重要，所以只需写 `_`）不包含搜索值。
- en: If the tree isn’t empty, and the root matches the searched value (`x`), we are
    done.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果树不为空，且根匹配搜索值（`x`），我们就完成了。
- en: If the root doesn’t match and is greater than the searched value, the answer
    is found while searching in the left subtree.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果根不匹配且大于搜索值，答案在搜索左子树时找到。
- en: Otherwise, the answer is found by searching in the right subtree.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，答案是通过搜索右子树找到的。
- en: 'There’s an important point to remember: for this data type, which is a union
    of two possible types, we have to provide two conditions, and pattern matching
    will be used to decide which one will be applied. Keep this in mind!'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的要点需要记住：对于这种数据类型，它是两种可能类型的联合，我们必须提供两个条件，并且模式匹配将用于决定应用哪一个。请记住这一点！
- en: Functions as binary trees
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为二叉树的函数
- en: 'Can we do something similar with functions? The answer is yes: we will represent
    a tree (or any other structure) with a function itself—not with a data structure
    that is processed by a set of functions, nor with an object with some methods,
    but by just a function. Furthermore, we will get a functional data structure that’s
    100% immutable, which, if updated, produces a new copy of itself. We will do all
    this without using objects; here, closures will provide the desired results.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否用函数做类似的事情？答案是肯定的：我们将用函数本身来表示一棵树（或任何其他结构），而不是用一组函数处理的数据结构，也不是用具有一些方法的对象，而只是一个函数。此外，我们将得到一个100%不可变的函数数据结构，如果更新，将产生一个新的副本。我们将不使用对象来完成所有这些；在这里，闭包将提供所需的结果。
- en: How can this work? We shall be applying similar concepts to the ones we looked
    at earlier in this chapter, so the function will act as a container and produce,
    as its result, a mapping of its contained values. Let’s walk backward and start
    by looking at how we’ll use the new data type. Then, we’ll go through the implementation
    details.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的呢？我们将应用与本章前面所讨论的类似的概念，因此函数将充当容器，并产生其包含值的映射作为其结果。让我们从后往前看，首先看看我们将如何使用新的数据类型。然后，我们将通过实现细节进行说明。
- en: 'Creating a tree can be done by using two functions: `EmptyTree()` and `Tree(value,
    leftTree, rightTree)`. For example, let’s say we wish to create a tree similar
    to the one shown in the following diagram:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一棵树可以通过使用两个函数来完成：`EmptyTree()` 和 `Tree(value, leftTree, rightTree)`。例如，假设我们希望创建一个类似于以下图表的树：
- en: "![Figure 12.2 – A binary search tree\uFEFF](img/Figure_12.2_B19301.jpg)"
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 二叉搜索树](img/Figure_12.2_B19301.jpg)'
- en: Figure 12.2 – A binary search tree
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 二叉搜索树
- en: 'We can create this using the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码创建它：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'How do you work with this structure? According to the data type description,
    whenever you work with a tree, you must consider two cases: a non-empty tree and
    an empty one. In the preceding code, `myTree()` is a function that receives two
    functions as arguments, one for each of the two data type cases. The first function
    will be called with the node value and left and right trees as arguments, while
    the second function will receive none:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理这个结构？根据数据类型描述，每次处理树时，你必须考虑两种情况：非空树和空树。在前面的代码中，`myTree()` 是一个接收两个函数作为参数的函数，每个参数对应两种数据类型情况之一。第一个函数将使用节点值和左右树作为参数被调用，而第二个函数将不接收任何参数：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To get the root of a tree, we could write something similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一棵树的根，我们可以写类似以下的内容：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we were dealing with a non-empty tree, we would expect the first function
    to be called and return the value of the root. With an empty tree, the second
    function should be called, and then a `null` value would be returned.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是非空树，我们期望第一个函数被调用并返回根的值。对于空树，第二个函数应该被调用，然后返回一个 `null` 值。
- en: 'Similarly, if we wanted to count how many nodes there are in a tree, we would
    write the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想计算树中有多少个节点，我们会写以下内容：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For non-empty trees, the first function would return `1` (for the root), plus
    the node count from both the root’s subtrees. For empty trees, the count is simply
    `0`. Get the idea?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非空树，第一个函数将返回 `1`（对于根），然后加上根的左右子树的节点计数。对于空树，计数是简单的 `0`。明白了吗？
- en: 'Now, we can show the `NewTree()` and `EmptyTree()` functions. They are as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以展示 `NewTree()` 和 `EmptyTree()` 函数。它们如下所示：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `destructure()` function is what you will pass as an argument (the name
    comes from the destructuring statement in JavaScript, which lets you separate
    an object attribute into distinct variables). You will have to provide two versions
    of this function. If the tree is non-empty, the first function will be executed;
    for an empty tree, the second one will be run (this mimics the case selection
    in the Haskell code, except we are placing the non-empty tree case first and the
    empty tree last). The underscore-named variable is used as a placeholder that
    stands for an otherwise-ignored argument but shows that two arguments are assumed;
    an initial underscore is usually meant to imply some parameter isn’t used.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`destructure()` 函数是你将作为参数传递的内容（这个名字来自 JavaScript 中的解构语句，它允许你将对象属性分离成不同的变量）。你必须提供这个函数的两个版本。如果树不为空，第一个函数将被执行；对于空树，第二个函数将被运行（这模仿了
    Haskell 代码中的情况选择，除了我们将非空树的情况放在第一位，空树放在最后）。以下划线命名的变量用作占位符，代表一个否则会被忽略的参数，但同时也表明假设有两个参数；通常，初始的下划线意味着某个参数没有被使用。'
- en: 'This can be hard to understand, so let’s look at more examples. If we need
    to access specific elements of a tree, we have the following three functions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能难以理解，所以让我们看看更多的例子。如果我们需要访问树中的特定元素，我们有以下三个函数：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'How can we decide whether a tree is empty? See whether you can figure out why
    the following short line of code works:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断一棵树是否为空？看看你是否能弄清楚以下简短代码行为什么能工作：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let’s go over a few more examples of this. For example, we can build an object
    out of a tree, which would help with debugging. I added logic to avoid including
    left or right empty subtrees, so the produced object would be more compact; check
    out the two `if` statements in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看这个的几个更多例子。例如，我们可以从树中构建一个对象，这有助于调试。我添加了逻辑来避免包含左或右空子树，因此生成的对象会更紧凑；查看以下代码中的两个
    `if` 语句：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Note the usage of recursion, as in the *Traversing a tree structure* section
    of [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), Designing Functions, to produce
    the object equivalents of the left and right subtrees. An example of this function
    is as follows; I edited the output to make it clearer:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到递归的使用，正如在[*第 9 章*](B19301_09.xhtml#_idTextAnchor172)“设计函数”中的*遍历树结构*部分所展示的，以生成左右子树的等价对象。这个函数的一个例子如下；我编辑了输出以使其更清晰：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Can we search for a node? Of course, and the logic closely follows the definition
    we saw in the previous section. (We could have shortened the code a bit, but I
    wanted to parallel the Haskell version; for a leaner version, see *Question 12.6*.)
    Our `treeSearch()` function could be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否搜索一个节点？当然可以，其逻辑与我们在上一节中看到的定义紧密相关。（我们本可以稍微缩短代码，但我希望与 Haskell 版本保持一致；对于更简洁的版本，请参阅*问题
    12.6*。）我们的 `treeSearch()` 函数可能如下所示：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If the value we want is the root, we found it; if it’s smaller than the root,
    we recursively search the left subtree, and if greater, the right subtree.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要的值是根节点，我们就找到了它；如果它小于根节点，我们递归地搜索左子树，如果大于，则搜索右子树。
- en: 'To round off this section, let’s also look at how to add new nodes to a tree.
    Study the code carefully; you’ll notice how the current tree isn’t modified and
    that a new one is produced instead. Of course, given that we are using functions
    to represent our tree data type, it should be evident that we wouldn’t have been
    able to modify the old structure: it’s immutable by default. The tree insertion
    function would be as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一节，让我们也看看如何向树中添加新节点。仔细研究代码；你会注意到当前树没有被修改，而是生成了一个新的树。当然，鉴于我们正在使用函数来表示我们的树数据类型，应该很明显，我们无法修改旧的结构：它默认是不可变的。树插入函数可能如下所示：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: When trying to insert a new key, if its value is less than or equal to the root
    of the tree, we produce a new tree that has the current root as its own root,
    maintains the old right subtree, but changes its left subtree to incorporate the
    new value (which will be done recursively). If the key was greater than the root,
    the changes wouldn’t have been symmetrical; they would have been analogous. If
    we try to insert a new key and find ourselves with an empty tree, we replace that
    empty structure with a new tree having the new value at its root, and empty left
    and right subtrees.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试插入一个新键时，如果其值小于或等于树的根，我们产生一个新的树，其当前根作为其自己的根，保持旧的右子树，但将其左子树更改为包含新值（这将递归完成）。如果键大于根，变化就不会是对称的；它们将是类似的。如果我们尝试插入一个新键并发现自己有一个空树，我们用具有新值作为根的新树替换那个空结构，并带有空左子树和右子树。
- en: 'We can test out this logic easily, but the simplest way is to verify that the
    binary tree that we showed earlier (*Figure 12**.2*) is generated by the following
    sequence of operations:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地测试这个逻辑，但最简单的方法是验证我们之前显示的二叉树（*图12**.2*）是通过以下操作序列生成的：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We could make this insertion function even more general by providing the comparator
    function that would be used to compare values. In this fashion, we could easily
    adapt a binary tree to represent a generic map. The value of a node would actually
    be an object such as `{key:... , data:...}` and the provided function would compare
    `newValue.key` and `value.key` to decide where to add the new node. Of course,
    if the two keys were equal, we would change the root of the current tree. The
    new tree insertion code would be as follows. Let’s start with types and comparisons:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供用于比较值的比较函数来使这个插入函数更加通用。这样，我们就可以轻松地将二叉树调整为表示一个通用映射。一个节点的值实际上是一个对象，例如
    `{key:... , data:...}`，提供的函数将比较 `newValue.key` 和 `value.key` 以确定添加新节点的地方。当然，如果两个键相等，我们会改变当前树的根。新的树插入代码如下。让我们从类型和比较开始：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The tree insertion code is now the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 树插入代码现在是以下内容：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'What else do we need? Of course, we can program diverse functions: deleting
    a node, counting nodes, determining a tree’s height, comparing two trees, and
    so on. However, in order to gain more usability, we should really turn the structure
    into a functor by implementing a `map()` function. Fortunately, using recursion,
    this proves to be easy—we apply the mapping function to the tree root and use
    `map()` recursively on the left and right subtrees, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要什么？当然，我们可以编写各种函数：删除节点、计数节点、确定树的高度、比较两个树等等。然而，为了获得更多的可用性，我们实际上应该通过实现一个 `map()`
    函数将结构转换为函子。幸运的是，使用递归，这证明是容易的——我们将映射函数应用于树根，并在左子树和右子树上递归地使用 `map()`，如下所示：
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We could go on with more examples, but that wouldn’t change the important conclusions
    we can derive from this work:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续提供更多示例，但这不会改变我们可以从这个工作中得出的重要结论：
- en: We are handling a data structure (a recursive one, at that) and representing
    it with a function
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在处理一个数据结构（一个递归的数据结构）并用一个函数来表示它
- en: 'We aren’t using external variables or objects for the data: closures are used
    instead'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有使用外部变量或对象来处理数据：而是使用闭包
- en: The data structure satisfies all the requirements we analyzed in [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188),
    *Ensuring Purity*, insofar that it is immutable and all the changes always produce
    new structures
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该数据结构满足我们在[*第10章*](B19301_10.xhtml#_idTextAnchor188)“确保纯净性”中分析的所有要求，即它是不可变的，所有的更改总是产生新的结构
- en: The tree is a functor, providing all the corresponding advantages
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该树是一个函子，提供了所有相应的优势
- en: In this section, we have looked at one more application of FP as well as how
    a function can actually become a structure by itself, which isn’t what we are
    usually accustomed to!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了FP的另一个应用，以及一个函数如何实际上成为一个结构本身，而这并不是我们通常习惯的！
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the theory of data types and learned how to use
    and implement them from a functional point of view. We started with defining function
    signatures to help us understand the transformations implied by the multiple operations
    we looked at later, with a syntax independent from TypeScript’s. Then, we went
    on to define several containers, including functors and monads, and saw how they
    can be used to enhance function composition. Finally, we learned how functions
    can be directly used by themselves, with no extra baggage, to implement functional
    data structures to simplify dealing with errors.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了数据类型的理论，并从函数式角度学习了如何使用和实现它们。我们从定义函数签名开始，以帮助我们理解后来观察到的多个操作所隐含的转换，该语法独立于TypeScript的语法。然后，我们继续定义了几个容器，包括函子（functors）和单子（monads），并看到了它们如何被用来增强函数组合。最后，我们学习了函数可以直接自身使用，没有任何额外负担，以实现函数式数据结构，从而简化错误处理。
- en: In this book, we have looked at several features of FP for JavaScript and TypeScript.
    We started with some definitions, and a practical example, then moved on to important
    considerations such as pure functions, avoiding side effects, immutability, testability,
    building new functions out of other ones, and implementing a data flow based upon
    function connections and data containers. We have looked at a lot of concepts,
    but I’m confident that you’ll be able to put them to practice and start writing
    even higher-quality code—give it a try, and thank you very much for reading this
    book!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们探讨了JavaScript和TypeScript的FP（函数式编程）的几个特性。我们从一个定义和一些实际例子开始，然后转向重要的考虑因素，如纯函数、避免副作用、不可变性、可测试性、从其他函数构建新函数，以及基于函数连接和数据容器的数据流实现。我们探讨了大量的概念，但我相信你将能够将它们付诸实践，并开始编写更高品质的代码——试试看，非常感谢你阅读这本书！
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 12.1 `global` declaration; can you add that declaration?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1 `全局`声明；你能添加这个声明吗？
- en: 12.2 `Symbol`!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2 `符号`!
- en: 12.3 `Maybe` and `Either` monads, but those types of classes are only available
    in TypeScript. Can you figure out an alternative way of working, but in JavaScript?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3 `Maybe`和`Either`单子，但这些类型的类仅在TypeScript中可用。你能想出一个在JavaScript中工作的替代方法吗？
- en: 12.4 `Maybe` or `Either` monad to simplify that code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 12.4 使用`Maybe`或`Either`单子来简化代码。
- en: '12.5 **Extending your trees**: To get a more complete implementation of our
    functional binary search trees, implement the following functions:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 12.5 **扩展你的树**：为了得到我们函数式二叉搜索树的更完整实现，实现以下函数：
- en: Calculate the tree’s height or, equivalently, the maximum distance from the
    root to any other node
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算树的高度，或者等价地，从根到任何其他节点的最大距离
- en: List all the tree’s keys, in ascending order
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按升序列出树的所有键
- en: Delete a key from a tree
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从树中删除一个键
- en: 12.6 `treeSearch()` function could be shortened—can you do that? Yes, this is
    more of a JavaScript problem than a functional one, and I’m not saying that shorter
    code is necessarily better, but many programmers act as if it were, so it’s good
    to be aware of such a style if only because you’re likely to find it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 12.6 `treeSearch()`函数可以被缩短——你能做到吗？是的，这更像是JavaScript问题而不是函数式问题，我并不是说更短的代码一定是更好的，但许多程序员似乎是这样认为的，所以了解这种风格是好的，仅因为你有可能会遇到它。
- en: '12.7 **Functional lists**: In the same spirit as binary trees, implement functional
    lists. Since a list is defined to be either empty or a node (*head*), followed
    by another list (*tail*), you might want to start with the following, quite similar
    to our binary search tree:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 12.7 **函数式列表**：与二叉树的精神相同，实现函数式列表。由于列表被定义为要么是空的，要么是一个节点（*头*），后面跟着另一个列表（*尾*），你可能想从以下内容开始，这与我们的二叉搜索树非常相似：
- en: '[PRE79]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here are some easy one-line operations to get you started; note they are very
    similar in style to what we wrote for binary trees:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的单行操作来帮助你开始；注意它们在风格上与我们为二叉树所写的非常相似：
- en: '[PRE80]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You could consider having these operations:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑以下操作：
- en: Transforming a list into an array and vice versa
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表转换为数组，反之亦然
- en: Reversing a list
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转一个列表
- en: Appending one list to the end of another list
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个列表追加到另一个列表的末尾
- en: Concatenating two lists
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个列表
- en: Don’t forget a `listMap()` function! Also, the `listReduce()` and `listFilter()`
    functions will come in handy.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`listMap()`函数！此外，`listReduce()`和`listFilter()`函数也会很有用。
- en: 12.8 `true` and `false` Boolean values, but we didn’t have any operators such
    as `&&`, `||`, or `!`. While we could make up for their absence with some (possibly
    repetitive) coding, we can have functions produce the same results; can you see
    how? Think along the same lines as for binary trees. We could represent a Boolean
    value by a function that takes a pair of functions as arguments and applies the
    first if the Boolean is true, and the second otherwise.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 12.8 `true`和`false`布尔值，但我们没有像`&&`、`||`或`!`这样的运算符。虽然我们可以通过一些（可能是重复的）编码来弥补它们的缺失，但我们可以让函数产生相同的结果；你能看到吗？沿着二叉树的思路思考。我们可以用一个函数来表示布尔值，该函数接受一对函数作为参数，并在布尔值为真时应用第一个函数，否则应用第二个函数。
- en: Answers to Questions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题答案
- en: Here are the solutions (partial, or worked out in full) to the questions that
    were contained within the chapters in this book. In many cases, there are extra
    questions so that you can do further work if you choose to.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了本书各章节中包含的问题的解决方案（部分或全部解决）。在许多情况下，还有额外的题目，以便你可以选择进一步工作。
- en: Chapter 1, Becoming Functional – Several Questions
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章，成为函数式编程者——几个问题
- en: '1.1 **TypeScript, please!** The following are the fully annotated versions
    of the code in the chapter. This is the code for the factorial functions:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 **TypeScript，请！**以下是对章节中代码的完整注释版本。这是阶乘函数的代码：
- en: '[PRE81]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is the code for the spreading examples:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是展开示例的代码：
- en: '[PRE82]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Why do we need to specify the type of `x`, but not those of `f`, `g`, `h`, `p`,
    and `q`? The issue is that TypeScript checks the call to `sum3()`, and for that,
    it needs to be sure that `x` is defined to be an array with three numbers.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要指定`x`的类型，但不指定`f`、`g`、`h`、`p`和`q`的类型？问题是TypeScript检查`sum3()`的调用，为此，它需要确保`x`被定义为包含三个数字的数组。
- en: TypeScript would be able to deduce that `sum3()` returns a number, but it’s
    best if you specify it, to prevent possible future bugs where you would return
    something that isn’t a number.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript能够推断出`sum3()`返回一个数字，但最好还是指定它，以防止未来可能出现的错误，你可能会返回一个不是数字的东西。
- en: The `newCounter()` function needs no type definitions; TypeScript is able to
    work types out. (See *Question 1.7* further on.)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`newCounter()`函数不需要类型定义；TypeScript能够推断出类型。（参见后面的*问题1.7*。）'
- en: 1.2 `new`. Therefore, it stands to reason that we should be able to pass classes
    as parameters to other functions. `makeSaluteClass()` creates a class (that is,
    a special function) that uses a closure to remember the value of `term`. We have
    looked at more examples like this throughout this book.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 `new`。因此，我们可以合理地认为我们应该能够将类作为参数传递给其他函数。`makeSaluteClass()`创建了一个类（即一个特殊函数），它使用闭包来记住`term`的值。我们在本书中已经看到了更多这样的例子。
- en: 'The TypeScript code for the class is as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 类的TypeScript代码如下：
- en: '[PRE83]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note the usage of TypeScript’s `ReturnType<>` utility type to specify that `c`
    will be something created by calling `makeSaluteClass()`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意TypeScript的`ReturnType<>`实用类型的使用，以指定`c`将通过调用`makeSaluteClass()`创建。
- en: '1.3 `f`, and we make it climb from `1` to `n`. We must be careful so that `factUp(0)
    ===` `1`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3 `f`，我们让它从`1`增加到`n`。我们必须小心，以确保`factUp(0) ===` `1`：
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You don’t need to specify that `f` is of type `number`; TypeScript automatically
    works that out.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要指定`f`的类型为`number`；TypeScript会自动推断出来。
- en: 'This solution may worry you because nobody prevents calling `factUp()` with
    two arguments – but we need the second parameter to be omitted, so it will be
    initialized to `1`. We can solve this defect as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可能会让你担心，因为没有人阻止用两个参数调用`factUp()`——但我们需要省略第二个参数，因此它将被初始化为`1`。我们可以如下解决这个缺陷：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The internal `factAux()` function is basically our previous `factUp()` function,
    except that it doesn’t need the `n` parameter, because it’s available in its scope.
    Our new `factUp2()` function calls `factAux()`, providing its needed default value
    of `1`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`factAux()`函数基本上是我们之前的`factUp()`函数，除了它不需要`n`参数，因为它在其作用域内可用。我们新的`factUp2()`函数调用`factAux()`，提供其需要的默认值`1`。
- en: 'If you like having a default value, you can go with the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用默认值，你可以使用以下代码：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: To test these functions, the tests (for correct values) in *Question 1.5* will
    do.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这些函数，可以在*问题1.5*中找到的测试（对于正确值）将进行测试。
- en: '1.4 **Factorial errors**: The key to avoiding repeating tests is to write a
    function that will check the value of the argument to ensure it’s valid, and if
    so, call an inner function to do the factorial itself, without worrying about
    erroneous arguments:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 **阶乘错误**：避免重复测试的关键是编写一个函数，它会检查参数的值以确保其有效性，如果是这样，就调用一个内部函数来执行阶乘本身，而不必担心错误的参数：
- en: '[PRE87]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In order, we check that `n` must be a number, not negative, and an integer.
    When an incorrect argument is recognized, we throw an error. By the way, that’s
    the reason for the `number | never` type specification; the user of this function
    directly recognizes that sometimes (namely, when an exception is thrown) no value
    will be returned.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，我们检查 `n` 必须是一个数字，不能是负数，并且是一个整数。当识别到错误的参数时，我们抛出一个错误。顺便说一句，这就是 `number | never`
    类型指定的原因；此函数的使用者直接认识到有时（即当抛出异常时）不会返回任何值。
- en: '1.5 **Factorial testing**: The following tests do the trick:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 1.5 **阶乘测试**：以下测试有效：
- en: '[PRE88]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Running the suite shows we achieved 100% coverage.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试套件显示我们达到了 100% 的覆盖率。
- en: '1.6 `++` operator (for more information, see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment)),
    you can condense `newCounter()` down to the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6 `++` 操作符（更多信息请参阅 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Increment))，你可以将
    `newCounter()` 简化为以下形式：
- en: '[PRE89]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Using arrow functions isn’t hard to understand, but be aware that many developers
    may have questions or doubts about using `++` as a prefix operator, so this version
    could prove to be harder to understand.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数并不难理解，但请注意，许多开发者可能对使用 `++` 作为前缀操作符有疑问或怀疑，因此这个版本可能更难理解。
- en: ESLint has a `no-plusplus` rule that disallows both `++` and `--`. Since I do
    approve of using them, I had to disable the rule; see [eslint.org/docs/latest/user-guide/configuring/rules](http://eslint.org/docs/latest/user-guide/configuring/rules)
    for more on this.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 有一个 `no-plusplus` 规则，禁止使用 `++` 和 `--`。由于我并不反对使用它们，所以我不得不禁用这个规则；有关更多信息，请参阅
    [eslint.org/docs/latest/user-guide/configuring/rules](http://eslint.org/docs/latest/user-guide/configuring/rules)。
- en: 1.7 `newCounter()` takes no arguments and returns a number, the answer is `()
    =>` `number`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7 `newCounter()` 不接受任何参数并返回一个数字，答案是 `() => number`。
- en: 'If you are working with Visual Studio Code, there’s a quicker way of doing
    this: hovering will provide the answer, as in *Figure 1*.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Visual Studio Code，有一种更快的方法来做这件事：悬停会提供答案，就像 *图 1* 中所示。
- en: '![Figure 1 – Visual Studio Code helps with typing](img/Figure_1_B19301.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图 1 – Visual Studio Code 帮助输入](img/Figure_1_B19301.jpg)'
- en: Figure 1 – Visual Studio Code helps with typing
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1 – Visual Studio Code 帮助输入
- en: Chapter 2, Thinking Functionally – A First Example
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章，函数式思考 – 第一个示例
- en: '2.1 `fn` variable itself as a flag. After calling `fn()`, we set the variable
    to `null`. Before calling `fn()`, we check that it’s not `null` by using the short-circuit
    `&&` operator:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 `fn` 变量本身作为标志。在调用 `fn()` 之后，我们将变量设置为 `null`。在调用 `fn()` 之前，我们通过使用短路 `&&`
    操作符检查它是否不是 `null`：
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We need a small change to let TypeScript know that `fn` could be `null`; otherwise,
    it would object to the `fn =` `null` assignment.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一个小改动，让 TypeScript 知道 `fn` 可能是 `null`；否则，它会反对 `fn = null` 的赋值。
- en: '2.2 **Alternating functions**: Like what we did in the previous question, we
    swap functions, and then we do the call. Here, we use a destructuring assignment
    to write the swap more compactly. For more information, refer to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2 **交替函数**：就像我们在上一个问题中所做的那样，我们交换函数，然后进行调用。在这里，我们使用解构赋值来更紧凑地编写交换。有关更多信息，请参阅
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#swapping_variables)：
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can write a test as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样编写测试：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We set up two mock functions, one will return `"A"` and the other `"B"`, and
    then we test that successive calls alternate between those two values.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了两个模拟函数，一个将返回 `"A"`，另一个返回 `"B"`，然后我们测试连续调用在这两个值之间交替。
- en: '2.3 `limit` is greater than `0`. If so, we decrement it by 1 and call the original
    function; otherwise, we do nothing:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3 `limit` 大于 `0`。如果是这样，我们将其减 1 并调用原始函数；否则，我们不做任何事情：
- en: '[PRE93]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can write a test for it as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样编写测试：
- en: '[PRE94]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Our `testFn()` function is set to call `fn()` twice, no more; the tests confirm
    that behavior.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `testFn()` 函数被设置为调用 `fn()` 两次，不再调用；测试确认了这种行为。
- en: '2.4 `once()`, so if `fn()` crashes, we’ll reset `done` to `false` to allow
    a new attempt:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4 `once()`，所以如果 `fn()` 发生崩溃，我们将 `done` 重置为 `false` 以允许新的尝试：
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can see this works with a simple example; our `crashTwice()` function will
    throw an error twice and work fine afterward:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的例子看到这是如何工作的；我们的 `crashTwice()` 函数将抛出两次错误并在之后正常工作：
- en: '[PRE96]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can write tests as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式编写测试：
- en: '[PRE97]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We need to check two cases: when the called function works normally and when
    it crashes at least once. The first case is just like the test we wrote for `once()`,
    so nothing is new here. For the second case, we set up a mock `myFn()` function
    that throws errors twice and returns a regular value afterward; the test verifies
    the expected behavior.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查两种情况：当被调用的函数正常工作以及当它至少崩溃一次。第一种情况就像我们为 `once()` 编写的测试一样，所以这里没有新的内容。对于第二种情况，我们设置了一个模拟的
    `myFn()` 函数，该函数会抛出两次错误并在之后返回一个常规值；测试验证了预期的行为。
- en: '2.5 **Say no to arrows**: The code is essentially the same, but the placement
    of type information varies:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 2.5 **拒绝箭头函数**：代码本质上相同，但类型信息的放置不同：
- en: '[PRE98]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Chapter 3, Starting Out with Functions – A Core Concept
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章，从函数开始——一个核心概念
- en: '3.1 `type` is considered to be labeling a statement, which doesn’t really do
    anything: it’s a `(t)` expression that isn’t used. Due to this, the code is considered
    valid, and since it doesn’t have an explicit `return` statement, the implicit
    returned value is `undefined`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1 `type` 被认为是标记一个语句，实际上并没有做什么：它是一个 `(t)` 表达式，没有被使用。因此，代码被认为是有效的，并且由于它没有显式的
    `return` 语句，隐式返回的值是 `undefined`。
- en: 'The corrected code is as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 修正后的代码如下所示：
- en: '[PRE99]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
    for more on labels, and developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals
    for more on returning objects.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label)
    了解更多关于标签的信息，以及 developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Returning_object_literals
    了解更多关于返回对象的信息。
- en: '3.2 `useArguments2()`, but with `useArguments()`, you would get an error since
    arguments are not defined for arrow functions:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2 `useArguments2()`，但使用 `useArguments()`，你会得到一个错误，因为箭头函数没有定义参数：
- en: '[PRE100]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '3.3 **Three more types**: We have the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3 **三种更多类型**：我们有以下内容：
- en: '`fn1` is `(y: number) => (z: number) =>` `number`'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn1` 是 `(y: number) => (z: number) =>` `number`'
- en: '`fn2` is `(z: number) =>` `number`'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn2` 是 `(z: number) =>` `number`'
- en: '`fn3` is just `number`'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn3` 只是 `number`'
- en: '3.4 **One-liner**: It works! (Yes, a one-line answer is appropriate in this
    case!)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 3.4 **一行代码即可解决问题**：它确实有效！（是的，在这种情况下，一行回答是合适的！）
- en: '3.5 `State`, we’d have an object with all the fields needed for your application.
    For a generic version, we could write the following, but a specific description
    would be much better:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 3.5 `State`，我们将有一个包含你应用程序所需所有字段的对象。对于通用版本，我们可以写出以下内容，但具体的描述会更好：
- en: '[PRE101]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We would define all the possible action types with something like the following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会用类似以下的方式定义所有可能的行为类型：
- en: '[PRE102]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We’d have an object with `type` and an optional `payload` for actions:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个包含 `type` 和可选 `payload` 的动作对象：
- en: '[PRE103]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: (It would be much better if you defined in detail what possible payloads you
    could have, instead of going with a generic definition as in the preceding code.)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你能详细定义可能有的有效负载，而不是像前面代码中那样使用通用定义，那会好得多。）
- en: 'Our `doAction()` function would be as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `doAction()` 函数如下所示：
- en: '[PRE104]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For `dispatchTable`, we’d have the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `dispatchTable`，我们将有如下内容：
- en: '[PRE105]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Finally, we would write the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们会写出以下内容：
- en: '[PRE106]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '3.6 `console(...), window.store.set(...)`) code, but the bug isn’t there: because
    of how the comma operator works, JavaScript does the logging first, and then the
    setting. The real problem is that `oldSet()` is not bound to the `window.store`
    object, so the second line should be as follows instead:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 3.6 `console(...), window.store.set(...)`) 代码，但错误并不在那里：因为逗号操作符的工作方式，JavaScript
    首先执行日志记录，然后是设置。真正的问题是 `oldSet()` 没有绑定到 `window.store` 对象，所以第二行应该如下所示：
- en: '[PRE107]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Reread the *Working with methods* section for more on this, and see *Question
    11.1* for another way of doing logging – that is, with decorators.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 重新阅读 *使用方法* 部分，了解更多相关信息，并查看 *问题11.1* 了解另一种日志记录方式——即使用装饰器。
- en: '3.7 `bind()` wasn’t available, you could use a closure, the `that` trick (which
    we saw in the *Handling the this value* section), and the `apply()` method, as
    follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 3.7 `bind()`不可用，你可以使用闭包，`that`技巧（我们在*处理this值*部分看到过），以及`apply()`方法，如下所示：
- en: '[PRE108]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We could do something similar to what we did in the *Adding missing* *functions*
    section.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些类似于我们在*添加缺失函数*部分所做的事情。
- en: 'Alternatively, just for variety, we could use a common idiom based on the `||`
    operator: if `Function.prototype.bind` exists, evaluation stops right there, and
    the existing `bind()` method is used; otherwise, our new function is applied:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了变化，我们可以使用基于`||`操作符的常用惯用语：如果`Function.prototype.bind`存在，评估将立即停止，并使用现有的`bind()`方法；否则，应用我们新的函数：
- en: '[PRE109]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 3.8 `compare(a,b)` comparison function must return a positive number if `a>b`,
    a negative number if `a<b`, or `0` if `a` equals `b`. When you subtract `ab`,
    you get that result, so it works. (Of course, this assumes that no number is either
    `Infinity` or `NaN`.) For more on this, check [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8 `compare(a,b)`比较函数必须返回一个正数，如果`a>b`，一个负数，如果`a<b`，或者`0`，如果`a`等于`b`。当你从`ab`中减去时，你会得到那个结果，所以它有效。（当然，这假设没有任何数字是`Infinity`或`NaN`。）关于这一点，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description)。
- en: '3.9 `-`”, so that’s kind of right, but the numbers themselves are still sorted
    as strings, so the result is wrong anyway. In the following example, the lowest
    number is `-666`, which should have been the first element after sorting:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 3.9 `-`”，所以这有点正确，但数字本身仍然是按字符串排序的，所以无论如何结果都是错误的。在以下示例中，最低的数字是`-666`，在排序后应该是第一个元素：
- en: '[PRE110]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '3.10 **Lexicographic sorting**: Let’s suppose we have an array of strings.
    To sort it lexicographically in an efficient way, a solution would be as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 3.10 **字典序排序**：假设我们有一个字符串数组。为了高效地按字典序排序，一个解决方案如下：
- en: Transform the array of strings into an array of objects with an added `sortBy`
    field.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串数组转换为具有添加的`sortBy`字段的对象数组。
- en: For each string, generate the corresponding string to sort by, and put the value
    in the `sortBy` field.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字符串，生成相应的用于排序的字符串，并将值放入`sortBy`字段。
- en: Sort the array by `sortBy`.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照`sortBy`排序数组。
- en: Drop the added field to convert the sorted array into an array of strings as
    originally.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除添加的字段，将排序后的数组转换为原始的字符串数组。
- en: '3.11 `console.log()` method can accept any number of arguments of any type,
    and won’t return anything, so its type is `(...args:` `any[]): void`.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '3.11 `console.log()`方法可以接受任何数量和类型的参数，并且不会返回任何内容，所以它的类型是`(...args:` `any[]):
    void`。'
- en: Chapter 4, Behaving Properly – Pure Functions
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章，行为规范 – 纯函数
- en: 4.1 **Must return?** If a pure function doesn’t return anything, it means that
    the function doesn’t do anything since it can’t modify its inputs and doesn’t
    have any other side effect.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 4.1 **必须返回吗？**如果一个纯函数不返回任何内容，这意味着该函数没有做任何事情，因为它不能修改其输入，并且没有其他副作用。
- en: 4.2 `string | undefined`, because the `.pop()` method returns `undefined` if
    the input array is empty.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 4.2 `string | undefined`，因为`.pop()`方法在输入数组为空时返回`undefined`。
- en: '4.3 `fib2()` in an IIFE; `fibC()` is equivalent to `fib2()` but with an internal
    `cache`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 4.3 `fib2()`在IIFE中；`fibC()`与`fib2()`等效，但有一个内部的`cache`：
- en: '[PRE111]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '4.4 **Minimalistic function**: It works because fib(0)=0 and fib(1)=1, so it’s
    true that for *n*<2, fib(*n*) equals *n*.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 4.4 **最小化函数**：它之所以有效，是因为`fib(0)=0`和`fib(1)=1`，所以对于`*n*<2`，`fib(*n*)`等于`*n*`。
- en: 4.5 `a` and `b` stand for two consecutive Fibonacci numbers. This implementation
    is quite efficient!
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 4.5 `a`和`b`代表两个连续的斐波那契数。这种实现相当高效！
- en: '4.6 **Rounding type**: The full definition, including the result type, would
    be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 4.6 **舍入类型**：完整的定义，包括结果类型，如下所示：
- en: '[PRE112]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '4.7 **Tuples to go**: In this case, we would return an array with two numbers,
    so we may write the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 4.7 **元组传递**：在这种情况下，我们将返回一个包含两个数字的数组，因此我们可以写出以下内容：
- en: '[PRE113]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The tests are very similar to what we already wrote; here, we have abridged
    versions of our previous code, highlighting the needed changes:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与我们已经写过的非常相似；这里，我们有我们之前代码的简略版本，突出显示所需的变化：
- en: '[PRE114]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 4.8 `calculateDeb2()` would still attempt to call the API. Providing an object
    with the dependencies makes injection an *all-or-nothing* option.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 4.8 `calculateDeb2()`仍然会尝试调用API。提供一个包含依赖项的对象使注入成为一个**全有或全无**的选项。
- en: 4.9 `"Math failure?"` message. The problem has to do with the fact that JavaScript
    internally uses binary instead of decimal, and floating-point precision is limited.
    In decimal, 0.1, 0.2, and 0.3 have a fixed, short representation, but in binary,
    they have infinite representation, much like 1/3=0.33333... has in decimal. If
    you write out the value of `a+b` after the test, you’ll get 0.30000000000000004
    – and that’s why you must be very careful when testing for equality in JavaScript.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 4.9 `"Math failure?"` 消息。这个问题与 JavaScript 内部使用二进制而不是十进制有关，并且浮点精度有限。在十进制中，0.1、0.2
    和 0.3 有一个固定的、简短的表示，但在二进制中，它们有无限的表示，就像十进制中的 1/3=0.33333... 一样。如果你在测试后写出 `a+b` 的值，你会得到
    0.30000000000000004 – 这就是为什么在 JavaScript 中测试相等性时必须非常小心。
- en: '4.10 **Breaking laws**: Some of the properties are no longer always valid.
    To simplify our examples, let’s assume two numbers are close to each other if
    they differ by no more than 0.1\. If this is the case, then we have the following:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 4.10 **违反规则**：一些属性不再总是有效。为了简化我们的示例，让我们假设两个数字如果它们之间的差异不超过 0.1，则彼此接近。如果是这样，那么我们就有以下情况：
- en: 0.5 is close to 0.6, and 0.6 is close to 0.7, but 0.5 is not close to 0.7
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.5 接近 0.6，0.6 接近 0.7，但 0.5 不接近 0.7
- en: 0.5 is close to 0.6, and 0.7 is close to 0.8, but *0.5+0.7=1.2* is not close
    to *0.6+0.8=1.4*, and *0.5*0.7=0.35* is not close to *0.6*0.8=0.48* either
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.5 接近 0.6，0.7 接近 0.8，但 *0.5+0.7=1.2* 不接近 *0.6+0.8=1.4*，并且 *0.5*0.7=0.35* 也不接近
    *0.6*0.8=0.48*。
- en: 0.5 is close to 0.4, and 0.2 is close to 0.3, but *0.5-0.2=0.3* is not close
    to *0.4-0.3=0.1*, and *0.5/0.2=2.5* is not close to *0.4/0.3=1.333*
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.5 接近 0.4，0.2 接近 0.3，但 *0.5-0.2=0.3* 不接近 *0.4-0.3=0.1*，并且 *0.5/0.2=2.5* 也不接近
    *0.4/0.3=1.333*
- en: The other cited properties are always valid.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 另一些引用的属性始终有效。
- en: '4.11 **Shuffling kinds**: This type definition allows our function to work
    with arrays of any type (strings, numbers, objects, etc.) and says that the type
    of the output array will be the same as the type of the input array.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 4.11 **打乱类型**：这种类型定义允许我们的函数处理任何类型的数组（字符串、数字、对象等），并说明输出数组的类型将与输入数组的类型相同。
- en: '4.12 `<T>(arr: T[]) => void`. See www.typescriptlang.org/docs/handbook/2/functions.html
    for more.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '4.12 `<T>(arr: T[]) => void`。更多信息请参阅 www.typescriptlang.org/docs/handbook/2/functions.html。'
- en: '4.13 `JSON.stringify()` on it, and save the result. After shuffling, sort a
    copy of the shuffled array and use `JSON.stringify()` on it too. Those two JSON
    strings should be equal. This does away with all the other tests since it ensures
    that the array doesn’t change its length or elements, and it would also work for
    arrays with repeated elements:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在它上面使用 `JSON.stringify()` 并保存结果。在打乱顺序后，对打乱顺序的数组的一个副本进行排序，并再次使用 `JSON.stringify()`。这两个
    JSON 字符串应该相等。这消除了所有其他测试，因为它确保数组不会改变其长度或元素，这也适用于包含重复元素的数组：
- en: '[PRE115]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '4.14 `shuffle` function works well, an idea is to shuffle a small array many
    times, and count how many possible outputs come up; the final counts should be
    similar, though not necessarily (because of the random aspects) equal. In my article
    at [blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/](https://blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/),
    I tested the Fisher–Yates algorithm by shuffling a four-letter (A to D) array
    24,000 times, and got this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 4.14 `shuffle` 函数工作良好，一个想法是多次打乱一个小数组，并计算出现多少种可能的输出；最终的计数应该相似，尽管不一定相等（因为随机因素），在我的文章
    [blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/](https://blog.openreplay.com/forever-functional-shuffling-an-array-not-as-trivial-as-it-sounds/)
    中，我通过打乱一个四个字母（A到D）的数组 24,000 次来测试 Fisher–Yates 算法，并得到了以下结果：
- en: '![](img/Figure_3_B19301.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3_B19301.jpg)'
- en: All 24 possible orderings were produced (see the *Recursion* section in [*Chapter
    1*](B19301_01.xhtml#_idTextAnchor015)*, Becoming Functional*), and the results
    were all pretty close to 1,000; the difference between the highest and lowest
    counts is only around 10%. This is not a thorough statistical confirmation – for
    that, we’d have to apply statistical frequency tests such as χ² (Chi-squared),
    Kolmogorov–Smirnov, or Anderson–Darling – but at least we get a notion that shuffling
    is not working very badly.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的 24 种排序都产生了（见 [*第一章*](B19301_01.xhtml#_idTextAnchor015)*，成为函数式程序员*中的 *递归*
    部分），并且结果都相当接近 1,000；最高和最低计数之间的差异只有大约 10%。这并不是彻底的统计确认 – 对于那，我们得应用统计频率测试，如 χ²（卡方）、Kolmogorov–Smirnov
    或 Anderson–Darling – 但至少我们得到了一个概念，即打乱并没有工作得很差。
- en: 'When I applied the (supposedly good!) algorithm, the counts were more lopsided:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当我应用（据称是好的！）算法时，计数结果更加不平衡：
- en: '![](img/Figure_4_B19301.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_4_B19301.jpg)'
- en: The highest count is more than 14 times the lowest; we can definitely conclude
    that not all arrangements are equally likely, so the popular shuffling algorithm
    is simply not good enough.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最高计数是最低计数的14倍以上；我们可以肯定地说，并非所有排列的可能性都是相等的，因此流行的洗牌算法显然是不够好的。
- en: '4.15 **Shuffling by sorting**: To get a random sequence, we can assign to each
    array element a random number and sort by that number; the result will be a totally
    random shuffling:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 4.15 **通过排序进行洗牌**：为了得到一个随机序列，我们可以给每个数组元素分配一个随机数，并按该数进行排序；结果将是一个完全随机的洗牌：
- en: '[PRE116]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The first `.map()` transforms each array element into an object, with the original
    value at `val` and a random value at `key`. We then sort the array by the `key`
    value, using the technique shown in *Question 3.8*. Finally, we undo the first
    mapping to get just the original values.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `.map()` 将每个数组元素转换为一个对象，其中原始值在 `val`，随机值在 `key`。然后我们按 `key` 值对数组进行排序，使用
    *问题3.8* 中显示的技术。最后，我们撤销第一个映射，只得到原始值。
- en: 'A final comment: this code is truly functional, and returns a new array instead
    of modifying the original argument in place.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的评论：这段代码确实是函数式的，并返回一个新的数组，而不是在原地修改原始参数。
- en: Chapter 5, Programming Declaratively – A Better Style
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章，声明式编程 – 更好的风格
- en: '5.1 `filter()`, `map()`, and `reduce()`, but the objective of this question
    was to make you think about how to manage with only those. Using `join()` or other
    extra string functions would make the problem easier. For instance, finding out
    a way to add the enclosing `<div><ul> ... </ul></div>` tags is tricky, so we had
    to make the first `reduce()` operation produce an array so that we could keep
    on working on it:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1 `filter()`、`map()` 和 `reduce()`，但这个问题的目的是让你思考如何仅使用这些方法来管理。使用 `join()` 或其他额外的字符串函数会使问题更容易解决。例如，找出添加包围
    `<div><ul> ... </ul></div>` 标签的方法是棘手的，因此我们必须使第一个 `reduce()` 操作产生一个数组，这样我们就可以继续工作：
- en: '[PRE117]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Accessing the array and index arguments for the `map()` or `reduce()` callbacks
    would also provide solutions:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `map()` 或 `reduce()` 回调的数组参数和索引参数也会提供解决方案：
- en: '[PRE118]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We could also do the following:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以这样做：
- en: '[PRE119]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Study the three examples: they will help you gain insight into these higher-order
    functions and provide you with ideas so that you can do independent work.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 研究这三个示例：它们将帮助你深入了解这些高阶函数，并提供你独立工作的想法。
- en: 5.2 `map()` method and the new `myMap()` function, but instead of using `JSON.stringify()`,
    use Jest’s `toEqual()` method to compare the results. See the answer to *Question
    5.5* for more.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 `map()` 方法和新 `myMap()` 函数，但不是使用 `JSON.stringify()`，而是使用 Jest 的 `toEqual()`
    方法来比较结果。有关更多信息，请参阅 *问题5.5* 的答案。
- en: '5.3 `sum()` function so TypeScript won’t object. Overloading isn’t available
    for arrow functions, so we have to change how we define `sum()`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 `sum()` 函数，这样 TypeScript 不会反对。箭头函数不支持重载，因此我们必须改变定义 `sum()` 的方式：
- en: '[PRE120]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now `reverseString2()` works and summing an array of numbers also works:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `reverseString2()` 可以正常工作，并且对数字数组求和也可以正常工作：
- en: '[PRE121]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If you try to do something as `sum(22,"X")` or `sum(false,{a:1})`, TypeScript
    will reject it because it won’t match the defined overloads:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试执行 `sum(22,"X")` 或 `sum(false,{a:1})` 这样的操作，TypeScript 会拒绝它，因为它不会匹配定义的重载：
- en: '[PRE122]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 5.4 **Reversed reverse?** In this case, it would return the same input string
    as the output; check it out!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 5.4 **反转反转？** 在这种情况下，它将返回与输入字符串相同的输出字符串；检查一下！
- en: '5.5 `1` for the former and `-1` for the latter. We used `Math.sign()` for this:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 5.5 `1` 用于前者，`-1` 用于后者。我们使用了 `Math.sign()` 来实现这一点：
- en: '[PRE123]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'A different implementation starts by calculating how big an array is needed
    and then filling it using `fill()` and `map()`. We must be careful if `start`
    and `stop` are equal to avoid a division by zero:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式首先计算所需的数组大小，然后使用 `fill()` 和 `map()` 来填充它。我们必须小心，如果 `start` 和 `stop` 相等，以避免除以零：
- en: '[PRE124]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'A few examples of calculated ranges show the diversity in terms of the options
    we have:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 一些计算范围的示例显示了我们在选项方面的多样性：
- en: '[PRE125]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Writing Jest tests is straightforward; the following code shows just three
    cases of the preceding code:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Jest 测试很简单；以下代码仅显示了前面代码的三个案例：
- en: '[PRE126]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Using this new `range2()` function means you can write a greater variety of
    loops in a functional way, with no need for `for(...)` statements.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的 `range2()` 函数意味着你可以以函数式的方式编写更多样化的循环，无需使用 `for(...)` 语句。
- en: '5.6 `from`) and then updates it (by summing the `step` value) until the resulting
    value is outside the range:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 5.6 `from`) 然后通过累加 `step` 值来更新它，直到结果值超出范围：
- en: '[PRE127]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We can write tests for this function in several different ways: manually calling
    the generator several times, using the spread operator to get all the values at
    once, or using the `for..of` construct:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用几种不同的方式为这个函数编写测试：手动多次调用生成器，使用扩展运算符一次性获取所有值，或者使用 `for..of` 构造。
- en: '[PRE128]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 5.7 `String.fromCharCode()` is not unary; it may receive any number of arguments.
    When you write `map(String.fromCharCode)`, the callback gets called with three
    parameters (the current value, the index, and the array) and that causes unexpected
    results. Using `unary()` from the *Arity changing* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions,* would also work. To find out more, go to [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 5.7 `String.fromCharCode()` 不是一元函数；它可以接收任意数量的参数。当你写 `map(String.fromCharCode)`
    时，回调函数会接收到三个参数（当前值、索引和数组），这会导致意外的结果。使用来自 *Arity changing* 部分的 `unary()`，在 [*第
    6 章*](B19301_06.xhtml#_idTextAnchor107)*，生成函数* 也会工作。要了解更多信息，请访问 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)。
- en: '5.8 **Producing a CSV**: A first solution, along with some auxiliary functions,
    is as follows; can you understand what each function does?'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 5.8 **生成 CSV**：一个初步解决方案，以及一些辅助函数，如下所示；你能理解每个函数的作用吗？
- en: '[PRE129]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: An alternative one-liner is possible, but not as clear – do you agree?
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个替代的一行解决方案，但不是很清晰——你同意吗？
- en: '[PRE130]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 5.9 `flat1()` and `flat2()` depend on `flatOne()`. If that function (in any
    of its two provided implementations) finds an empty array position, it doesn’t
    `concat()` anything to its output.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 5.9 `flat1()` 和 `flat2()` 依赖于 `flatOne()`。如果该函数（在其两个提供的实现中的任何一个）发现一个空数组位置，它不会将其输出
    `concat()` 到任何东西。
- en: '5.10 **Producing better output**: For this, you’ll have to do some extra mapping,
    as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 5.10 **生成更好的输出**：为此，你可能需要进行一些额外的映射，如下所示：
- en: '[PRE131]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '5.11 `join()` to build a single long string out of the individual sentences,
    using `split()` to separate that string into words, and finally, looking at the
    length of the resulting array:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 5.11 使用 `join()` 将单个长字符串构建出来，使用 `split()` 将该字符串分割成单词，最后查看结果数组的长度：
- en: '[PRE132]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 5.12 `Boolean(x)` is the same as `!!x`, turning an expression from `truthy`
    or `falsy` into `true` or `false`, respectively. Thus, the `filter()` operation
    removes all `falsy` elements from the array.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 5.12 `Boolean(x)` 与 `!!x` 相同，将表达式从 `truthy` 或 `falsy` 转换为 `true` 或 `false`，因此
    `filter()` 操作从数组中移除了所有 `falsy` 元素。
- en: 5.13 `fact4(0)` returns `1` as expected. The `range(1,1)` call produces an empty
    array, so the original value of `result` (`1`) is returned without further change.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 5.13 `fact4(0)` 返回预期的 `1`。调用 `range(1,1)` 产生一个空数组，因此原始的 `result` (`1`) 值被返回，没有进一步的变化。
- en: 5.14 `forEach()`, `map()`, and so on, and also develops a class for `async`
    arrays that allows chaining.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 5.14 `forEach()`、`map()` 等等，并开发了一个允许链式调用的 `async` 数组类。
- en: '5.15 `mapAsync()` to get the async values and apply the original function to
    the returned array. An example for `some()` would be as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 5.15 使用 `mapAsync()` 获取异步值并将原始函数应用于返回的数组。对于 `some()` 的一个示例如下：
- en: '[PRE133]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We can write tests for this in two different fashions: awaiting the result
    of a call, or using Jest’s `.resolves` for shorter code:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种不同的方式为这个函数编写测试：等待调用的结果，或者使用 Jest 的 `.resolves` 来编写更短的代码：
- en: '[PRE134]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '5.16 `workerCall()` or when we reset a worker to be not in use. Let’s go with
    the second solution, to make the call as fast as possible. We will add a `MAX_NOT_IN_USE`
    constant with the threshold of number of workers not in use and a `notInUse()`
    predicate as a refactor:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 5.16 在调用 `workerCall()` 或当我们重置一个工作线程使其不再使用时。让我们选择第二个方案，以便尽可能快地完成调用。我们将添加一个 `MAX_NOT_IN_USE`
    常量，其阈值是未使用的工作线程数量，并添加一个 `notInUse()` 断言作为重构：
- en: '[PRE135]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then, we’ll change the last part of the `workerCall()` function as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `workerCall()` 函数的最后部分修改如下：
- en: '[PRE136]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: While the count of workers not in use is higher than our limit, we find one
    worker to remove, `terminate()` it, and remove it from the pool of workers.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当未使用的工作线程数量超过我们的限制时，我们会找到一个工作线程来移除，`terminate()` 它，并从工作线程池中移除。
- en: '5.17 **Queueing for the pool**: This question has an interesting way of handling
    a promise to act as a barrier, initially denying but eventually allowing procedures
    to go through. The idea is to check that there are not too many running workers
    before adding a worker to the pool. If so, proceed as before, but if not, add
    something to the queue (we’ll see what), so we can run the worker later. Whenever
    a worker responds, we’ll check whether there’s anything in the queue to allow
    it to run.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 5.17 **为池排队**：这个问题有一个有趣的方式来处理承诺作为屏障，最初拒绝但最终允许程序通过。想法是在向池中添加工人之前检查运行中的工人数量是否太多。如果是这样，就按以前的方式进行，如果不是，就将某些东西添加到队列中（我们稍后会看到是什么），这样我们就可以稍后运行该工人。每当工人响应时，我们将检查队列中是否有任何东西允许它运行。
- en: 'We’ll first add three things:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加三件事：
- en: '[PRE137]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The way we’ll handle waiting is by creating a promise, which we’ll eventually
    resolve at a later time. That explains the weird `queue` data type, which contains
    resolving functions. The `running` variable will count how many workers are running,
    and `MAX_TO_USE` is the maximum possible value for `running`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理等待的方式是通过创建一个承诺，我们将在稍后某个时间点最终解决它。这解释了奇怪的`queue`数据类型，它包含了解决函数。`running`变量将计算正在运行的工人数，而`MAX_TO_USE`是`running`可能的最大值。
- en: 'To work with the queue, we’ll have two functions:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 要与队列一起工作，我们将有两个函数：
- en: '[PRE138]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The `enqueue()` function checks how many workers are running; if there are less
    than `MAX_TO_USE`, it increments `running` (because a worker will run) and then
    calls `resolve2()` to allow the corresponding request to go forward. If there
    are too many running workers, the function to call is instead pushed into the
    queue. The `dequeue()` function just tries to get the front element from the queue,
    and if there’s something, it calls the dequeued value to allow a queued request
    to proceed.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue()`函数检查正在运行的工人数；如果少于`MAX_TO_USE`，则增加`running`（因为一个工人将要运行）然后调用`resolve2()`以允许相应的请求前进。如果有太多的正在运行的工人，则将需要调用的函数推入队列。`dequeue()`函数只是尝试从队列中获取前面的元素，如果有东西，它将调用出列的值以允许队列中的请求继续。'
- en: 'The modified `workerCall()` function is now as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`workerCall()`函数现在如下所示：
- en: '[PRE139]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The `new Promise((resolve2) => …)` line is the barrier we mentioned; it will
    allow work to go on (at `then()`) only when its `resolve2()` function is called
    – which will be done either by `enqueue()` (if there were few running workers)
    or `dequeue()` (when some previously running worker ends).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Promise((resolve2) => …)`这一行是我们提到的屏障；只有当其`resolve2()`函数被调用时，它才会允许工作继续（在`then()`中）——这可以通过`enqueue()`（如果有很少的正在运行的工人）或`dequeue()`（当某个之前正在运行的工人结束时）来完成。'
- en: '5.18 **Showing results**: Basically, given a string, it returns a logging function
    that expects a single parameter and lists both the string and the argument. We’ll
    see other ways of achieving similar results in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 5.18 **显示结果**：基本上，给定一个字符串，它返回一个期望单个参数的日志函数，并列出该字符串和参数。我们将在[*第6章*](B19301_06.xhtml#_idTextAnchor107)
    *生产函数*中看到实现类似结果的其他方法。
- en: '5.19 `filter()` goes through all the workers, and then `find()` goes through
    the filtered ones. This could be achieved in a single pass as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 5.19 `filter()`遍历所有工人，然后`find()`遍历过滤后的那些。这可以通过以下方式在单次遍历中实现：
- en: '[PRE140]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '5.20 `"error"` event, which fires if an error occurs in the worker. In this
    case, the worker should be marked as not in use (because it has ended its job)
    and the promise should be rejected. The final part of the `workerCall()` function
    should look something like this:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 5.20 `"error"`事件，如果工人在执行过程中发生错误，则会触发。在这种情况下，应该将工人标记为未使用（因为它已经完成了工作）并且应该拒绝承诺。`workerCall()`函数的最后部分应该看起来像这样：
- en: '[PRE141]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: For an “industrial-strength” level library, you should deal with all possible
    events; check developer.mozilla.org/en-US/docs/Web/API/Worker#events and nodejs.org/api/worker_threads.html#class-worker
    for more on this.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个“工业级”的库，你应该处理所有可能的事件；查看developer.mozilla.org/en-US/docs/Web/API/Worker#events和nodejs.org/api/worker_threads.html#class-worker以获取更多相关信息。
- en: Chapter 6, Producing Functions – Higher-Order Functions
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，生产函数 – 高阶函数
- en: '6.1 **Go with arrows**: Just minor changes are needed:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 6.1 **使用箭头**：只需要做些小的改动：
- en: '[PRE142]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '6.2 `memoize4()`. Instead of using an object for `cache`, we create a map.
    We check whether the map has the searched `strX` key, we set new values after
    calling the original function, and we get the return value from the cache. The
    `as` part in `return` is to let TypeScript know that `get()` will succeed because
    the search won’t fail:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2 `memoize4()`。我们不是使用对象作为`cache`，而是创建一个映射。我们检查映射中是否有搜索到的`strX`键，在调用原始函数后设置新值，并从缓存中获取返回值。`return`中的`as`部分是为了让TypeScript知道`get()`将成功，因为搜索不会失败：
- en: '[PRE143]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '6.3 `calc(n)` the number of calls needed to evaluate `fib(n)`. Analyzing the
    tree that shows all the needed calculations, we get the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 6.3 `calc(n)`是评估`fib(n)`所需的调用次数。分析显示所有必要计算的树，我们得到以下结果：
- en: calc(0)=1
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: calc(0)=1
- en: calc(1)=1
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: calc(1)=1
- en: For *n*>1, calc(*n*)=1 + calc(*n*-1) + calc(*n*-2)
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*n*>1，calc(*n*)=1 + calc(*n*-1) + calc(*n*-2)
- en: The last line follows from the fact that when we call `fib(n)`, we have one
    call, plus calls to `fib(n-1)` and `fib(n-2)`. A spreadsheet shows that `calc(50)`
    is 40,730,022,147 – rather high!
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行遵循这样一个事实：当我们调用`fib(n)`时，我们有一个调用，加上对`fib(n-1)`和`fib(n-2)`的调用。电子表格显示`calc(50)`是40,730,022,147
    – 相当高！
- en: If you care for some algebra, it can be shown that calc(*n*)=5fib(*n*-1)+fib(*n*-4)-1,
    or that as *n* grows, calc(*n*) becomes approximately (1+√5)=3.236 times the value
    of fib(*n*) – but since this is not a math book, I won’t even mention those results!
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关心一些代数，可以证明calc(*n*)=5fib(*n*-1)+fib(*n*-4)-1，或者随着*n*的增长，calc(*n*)大约是(1+√5)=3.236倍fib(*n*)的值
    – 但由于这不是一本数学书，我不会提及这些结果！
- en: '6.4 `shuffle()` function from [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069),
    *Behaving Properly*, we can write the following code. We remove the first function
    from the list before shuffling the rest, and we add it back at the end of the
    array to avoid repeating any calls:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 6.4 `shuffle()`函数来自[*第4章*](B19301_04.xhtml#_idTextAnchor069)，*行为规范*，我们可以编写以下代码。在打乱其余函数之前，我们从列表中删除第一个函数，并在数组的末尾将其添加回来，以避免重复调用：
- en: '[PRE144]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: We need to add `as T` when assigning a value to `first`; otherwise, TypeScript
    will object because `fns.shift()` returns `undefined` if `fns` is empty. It wouldn’t
    be a bad idea to check that `fns` is not empty; can you add it?
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将值赋给`first`时，需要添加`as T`；否则，TypeScript会提出异议，因为如果`fns`为空，`fns.shift()`将返回`undefined`。检查`fns`不为空也不是一个坏主意；你能添加它吗？
- en: 'A quick verification shows it fulfills all our requirements:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 快速验证表明它满足我们所有的要求：
- en: '[PRE145]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'A minor consideration: the first function in the list can never be called the
    first time around because of the way `randomizer()` is written. Can you provide
    a better version that won’t have this slight defect so that all the functions
    in the list have the same chance of being called the first time?'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小考虑：由于`randomizer()`的编写方式，列表中的第一个函数在第一次调用时永远不会被调用。你能提供一个更好的版本，这样就不会有这个轻微的缺陷，以便列表中的所有函数都有相同的机会在第一次被调用吗？
- en: '6.5 **Not in TypeScript**: The following code does the job. The only difference
    between the functions is that one works with Boolean-returning functions and the
    other with number-returning ones:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 6.5 **不在TypeScript中**：以下代码可以完成任务。函数之间的唯一区别是，一个与返回布尔值的函数一起工作，另一个与返回数字值的函数一起工作：
- en: '[PRE146]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '6.6 `typeof` to check whether the returned value is numeric or Boolean before
    deciding what to return. We must declare that the input function is either a Boolean-returning
    or a number-returning function:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 6.6 使用`typeof`检查返回值是数字还是布尔值，在决定返回什么之前。我们必须声明输入函数要么是返回布尔值的函数，要么是返回数字值的函数：
- en: '[PRE147]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '6.7 **Invert tests**: We can quickly transform the example shown in the text
    into a real test; we’ll leave it up to you to write more tests:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 6.7 **反转测试**：我们可以快速将文本中显示的示例转换为实际测试；我们将把它留给你自己来编写更多测试：
- en: '[PRE148]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 6.8 `filter()` expects to receive a function with three parameters (the `A`,
    `number`, and `A[]` types), and the type of `not(fn)` doesn’t match that.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 6.8 `filter()`期望接收一个具有三个参数（`A`、`number`和`A[]`类型）的函数，而`not(fn)`的类型不匹配。
- en: '6.9 `eval()` – which, in general, isn’t such a good idea! If you persist and
    insist, though, we can write a `function.length` preserving version of `arity()`
    as follows; let’scall it `arityL()`:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 6.9 `eval()` – 通常不是一个好主意！尽管如此，如果你坚持并坚持，我们可以编写一个保留`function.length`版本的`arity()`，如下所示；让我们称它为`arityL()`：
- en: '[PRE149]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'If you were to apply `arityL()` to `Number.parseInt`, the results would be
    as follows. The produced functions have the right `length` property, and their
    actual implementation is given in the comments:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`arityL()`应用于`Number.parseInt`，结果如下。产生的函数具有正确的`length`属性，它们的实际实现已在注释中给出：
- en: '[PRE150]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Do note, however, that TypeScript cannot determine the type of the resulting
    functions because that will be known at runtime.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，TypeScript无法确定结果的函数类型，因为这将是在运行时知道的。
- en: '6.10 **Many arities!** If we were working just with JavaScript, the following
    would do:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 6.10 **许多变元**！如果我们只使用JavaScript，以下就会这样做：
- en: '[PRE151]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Adding data types, we get the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 添加数据类型，我们得到以下：
- en: '[PRE152]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '6.11 **Throttling promises**: Every time we actually do a call, we’ll set up
    a timer that will, in time, remove the promise from the cache. By default, let’s
    have a delay of 5 minutes. We’ll have a pool of timers, one per promise. In case
    of an error when calling the API, we’ll remove both the rejected promise and its
    corresponding timer:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 6.11 **节流承诺**：每次我们实际进行调用时，我们都会设置一个计时器，该计时器最终会从缓存中删除承诺。默认情况下，让我们有一个5分钟的延迟。我们将有一个计时器池，每个承诺一个计时器。在调用API时发生错误的情况下，我们将删除被拒绝的承诺及其对应的计时器：
- en: '[PRE153]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 6.12 `+`, `-`, `*`, `/`, `**`, and `%`), all bitwise operators (`&`, `|`, and
    `^`), all logical operators (`&&` and `||`), all shift operators (`<<`, `>>`,
    and `>>>`), all comparisons (`>`, `>=`, `<`, `<=`, `==`, `===`, `!=`, and `!==`),
    and the new nullish coalescing operator (`??`). The comma operator could be included
    as well. Check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)
    for more on this topic.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 6.12 `+`, `-`, `*`, `/`, `**`, 和 `%`），所有位运算符（`&`, `|`, 和 `^`），所有逻辑运算符（`&&` 和
    `||`），所有位移运算符（`<<`, `>>`, 和 `>>>`），所有比较运算符（`>`, `>=`, `<`, `<=`, `==`, `===`,
    `!=`, 和 `!==`），以及新的空值合并运算符（`??`）。逗号运算符也可以包括在内。有关更多关于这个主题的信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)：
- en: '6.13 **Missing companion**: A simple one-line version could be as follows.
    Here, we use spreading to get a shallow copy of the original object and then set
    the specified attribute to its new value by using a computed property name. See
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)
    for more details:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 6.13 **缺少伴随者**：一个简单的单行版本可以是以下这样。在这里，我们使用展开操作来获取原始对象的一个浅拷贝，然后通过使用计算属性名来设置指定的属性为新值。有关更多详细信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer)：
- en: '[PRE154]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'In [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, we
    wrote `deepCopy()`, which would be better than spreading when it comes to creating
    a totally new object instead of a shallow copy. By using this, we would have the
    following:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B19301_10.xhtml#_idTextAnchor188)，*确保纯净性*中，我们写了`deepCopy()`，当涉及到创建一个全新的对象而不是浅拷贝时，这会比展开操作更好。通过使用这个，我们会有以下：
- en: '[PRE155]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Finally, you could also look into modifying the `updateObject()` function, also
    from [*Chapter 10*](B19301_10.xhtml#_idTextAnchor188), *Ensuring Purity*, by removing
    the freezing code; I’ll leave it up to you.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以考虑修改`updateObject()`函数，它也来自[*第10章*](B19301_10.xhtml#_idTextAnchor188)，*确保纯净性*，通过删除冻结代码；我将把它留给你。
- en: '6.14 `null` object would throw an error:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 6.14 `null` 对象会抛出错误：
- en: '[PRE156]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'With TypeScript, the code won’t compile because first, `"someField"` isn’t
    the name of an attribute, and second, `null` is not a valid object:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript，代码将无法编译，因为首先`"someField"`不是属性名，其次`null`不是一个有效的对象：
- en: '[PRE157]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: However, it’s still possible to do things “behind TypeScript’s back” and get
    the code accepted and the exception thrown. Having functions throw exceptions
    is not usually good in FP. You may opt to produce `undefined` instead, or work
    with monads, just like in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building
    Better Containers*. A safer version of `getField()` would add a safeguard and
    return `obj &&` `obj[f]` instead.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然可以在TypeScript的背后做一些事情，并使代码被接受，异常被抛出。在函数中抛出异常通常在FP（函数式编程）中不是很好。你可以选择产生`undefined`，或者与monads一起工作，就像在[*第12章*](B19301_12.xhtml#_idTextAnchor221)，*构建更好的容器*中一样。`getField()`的一个更安全的版本会添加一个保护措施，并返回`obj
    && obj[f]`。
- en: '6.15 **Typed demethodizing**: The three full definitions are as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 6.15 **类型化去方法化**：三个完整的定义如下：
- en: '[PRE158]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '6.16 `Math.max()` and `Math.min()` as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 6.16 `Math.max()` 和 `Math.min()` 如下：
- en: '[PRE159]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Another way of writing this could be achieved by defining the following first:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种写法可以是首先定义以下内容：
- en: '[PRE160]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Then, we could write in a pointfree style:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用无点风格来写：
- en: '[PRE161]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '6.17 **Comparing heroes**: The first suggested change wouldn’t allow for ties
    in some features, where no hero beats the other. And, in fact, this points out
    a problem in our logic; if the first hero doesn’t beat the second one, we assume
    that the latter beat the former, not allowing for ties between heroes.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 6.17 **比较英雄**：第一个建议的更改不会允许某些特征中出现平局，即没有英雄能打败另一个。实际上，这指出了我们逻辑中的一个问题；如果第一个英雄没有打败第二个，我们就假设后者打败了前者，不允许英雄之间有平局。
- en: Chapter 7, Transforming Functions – Currying and Partial Application
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，函数转换——柯里化和部分应用
- en: 7.1 `sum(3)` returns a function with `3` already bound; `sum(3)()` returns the
    same, and `sum(3)()(5)` produces the result.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1 `sum(3)` 返回一个已经绑定 `3` 的函数；`sum(3)()` 返回相同的结果，而 `sum(3)()(5)` 产生结果。
- en: '7.2 `sumMany()` function does the job:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2 `sumMany()` 函数完成了工作：
- en: '[PRE162]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: In JavaScript, the function poses no problem; with TypeScript, we’ll get an
    objection because it cannot determine that `sumMany(2)` is a function, not a number.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，这个函数没有问题；但在 TypeScript 中，我们会遇到一个反对意见，因为它无法确定 `sumMany(2)` 是一个函数，而不是一个数字。
- en: 'A small detail: can you fix the function so `sumMany()` will return `0`?'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小细节：你能修复函数，让 `sumMany()` 返回 `0` 吗？
- en: '7.3 **Curry with eval?** Let’s see this in JavaScript first:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3 **使用 eval() 柯里化**？让我们首先在 JavaScript 中看看这个例子：
- en: '[PRE163]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This is quite a chunk of code to digest, and, in fact, it should instead be
    coded in several separate lines to make it more understandable. Let’s see how
    this works when applied to the `make3()` function as input:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当难消化的代码，实际上，它应该被编码在几行中，以便更容易理解。让我们看看当它应用于 `make3()` 函数作为输入时是如何工作的：
- en: The `range()` function produces an array with the `[``0,1,2]` values.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`range()` 函数生成一个包含 `[``0,1,2]` 值的数组。'
- en: We use `map()` to generate a new array with the `["``x0","x1","x2"]` values.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `map()` 生成一个包含 `["``x0","x1","x2"]` 值的新数组。
- en: We use `join()`on the values in that array to produce `x0=>x1=>x2`, which will
    be the beginning of the code that we will evaluate.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这个数组中的值上使用 `join()` 生成 `x0=>x1=>x2`，这将是我们将要评估的代码的开始。
- en: 'We then add an arrow, the function’s name, and an opening parenthesis, to make
    the middle part of our newly generated code: `=>` `make3(`.'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加一个箭头，函数的名称，以及一个开括号，来构成我们新生成代码的中间部分：`=>` `make3(`。
- en: 'We use `range()`, `map()`, and `join()` again, but this time, to generate a
    list of arguments: `x0,x1,x2`.'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用 `range()`、`map()` 和 `join()`，但这次是为了生成一个参数列表：`x0,x1,x2`。
- en: We finally add a closing parenthesis, and after applying `eval()`, we get the
    curried version of `make3()`.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最终添加一个闭括号，然后应用 `eval()`，我们得到了 `make3()` 的柯里化版本。
- en: 'After following all these steps, in our case, the resulting function would
    be as follows:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循所有这些步骤之后，在我们的例子中，生成的函数如下：
- en: '[PRE164]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Typing is essentially the same as for our `curry()` function since we are getting
    the same parameter and producing the same output. Note, however, that we’re definitely
    “lying” to TypeScript because it wouldn’t be able to deduce what `eval()` was
    returning; it’s really up to us not to mess up! Without further ado, we can write
    the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 类型基本上与我们的 `curry()` 函数相同，因为我们得到相同的参数和相同的输出。然而，请注意，我们绝对是在对 TypeScript “撒谎”，因为它无法推断出
    `eval()` 返回了什么；这完全取决于我们不要出错！无需多言，我们可以写出以下内容：
- en: '[PRE165]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We see we can do currying by using `eval()` – but there’s one remaining problem:
    if the original function didn’t have a name, the transformation wouldn’t work.
    We can work around the function name problem by including the actual code of the
    function to be curried:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以通过使用 `eval()` 来进行柯里化——但还有一个问题：如果原始函数没有名字，转换就不会工作。我们可以通过包含要柯里化的函数的实际代码来绕过函数名的问题：
- en: '[PRE166]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The only change is that instead of including the original function name, we
    substitute its actual code:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是，我们不是包含原始函数的名称，而是替换它的实际代码：
- en: '[PRE167]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '7.4 **Uncurrying the curried**: We can work similarly to what we did in the
    previous question:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4 **取消柯里化**：我们可以类似地做我们之前做过的事情：
- en: '[PRE168]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Earlier, when currying, given an `fn()` function with an arity of `3`, we would
    have generated the following:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在柯里化时，给定一个 `arity` 为 `3` 的 `fn()` 函数，我们会生成以下内容：
- en: '[PRE169]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Now, to uncurry a function (say, `curriedFn()`), we want to do something very
    similar: the only difference is the placement of the parentheses:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要取消一个函数的柯里化（比如 `curriedFn()`），我们想要做的是非常相似的：唯一的区别是括号的位置：
- en: '[PRE170]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The expected behavior is as follows – and let’s use the last result from the
    previous question:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为如下——让我们使用上一个问题的最后一个结果：
- en: '[PRE171]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: If you want to consider a case in which the function to “uncurry” has no name,
    you can apply the same change we did in the previous question and include `fn.toString()`
    in the output.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要考虑一个没有名称的“去curry”函数的情况，你可以应用我们在上一个问题中做的相同更改，并在输出中包含`fn.toString()`。
- en: '7.5 **Let me count the ways**: If the function has *n* parameters, there are
    2n-1 ways of calling it. This means that our three-parameter function could be
    called in 22=4 ways (correct!), a function with two parameters would allow 21=2
    ways, and a function with just one parameter would allow only 20=1 way.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 7.5 **让我数数方式**：如果函数有*n*个参数，那么有2n-1种调用它的方法。这意味着我们的三个参数函数可以以22=4种方式调用（正确！），具有两个参数的函数将允许21=2种方式，而只有一个参数的函数将只允许20=1种方式。
- en: '7.6 `curry()` version so that it uses this:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 7.6 `curry()`版本，使其使用此：
- en: '[PRE172]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '7.7 **Shorter typing**: The suggested earlier test shortens the code. We are
    essentially saying “*if there’s at least one argument, return a curried function;
    otherwise, return* *a value*”:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 7.7 **更短的类型**：之前建议的测试缩短了代码。我们本质上是在说“如果至少有一个参数，则返回一个curried函数；否则，返回*值*”：
- en: '[PRE173]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '7.8 `P` has a single type by checking `P["length"]` as follows – and to access
    that single type, we’ll have to write `P[0]`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 7.8 通过以下方式检查`P["length"]`来使`P`具有单一类型 – 而要访问这个单一类型，我们将不得不编写`P[0]`：
- en: '[PRE174]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '7.9 `applyStyle()` or by using our `curry()` function – let’s see both ways:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 7.9 使用`applyStyle()`或通过我们的`curry()`函数 – 让我们看看两种方式：
- en: '[PRE175]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '7.10 `what()` function is as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 7.10 `what()`函数如下：
- en: '[PRE176]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 7.11 `this`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 7.11 `this`。
- en: 7.12 `curryN()` function is an alternative version of our `partialCurry()`.
    The only difference is that if you provide all the arguments to a function, this
    new `curryN()` function directly calls the curried function, while `partialCurry()`
    would first bind the function to all its arguments and then recursively call it
    to return the final result – but the result would be precisely the same.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 7.12 `curryN()`函数是`partialCurry()`的另一种版本。唯一的区别是，如果你向函数提供了所有参数，这个新的`curryN()`函数将直接调用curried函数，而`partialCurry()`将首先将函数绑定到所有参数，然后递归调用它以返回最终结果
    – 但结果将完全相同。
- en: Chapter 8, Connecting Functions – Pipelining, Composition, and More
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章，连接函数 – 管道、组合和更多
- en: '8.1 `split()`, `map()`, and `join()`. Using `demethodize()` from [*Chapter
    6*](B19301_06.xhtml#_idTextAnchor107), *Producing Functions*, and `flipTwo()`
    from [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    would have also been possible:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1 `split()`、`map()`和`join()`。使用来自[*第6章*](B19301_06.xhtml#_idTextAnchor107)的`demethodize()`，*生成函数*和来自[*第7章*](B19301_07.xhtml#_idTextAnchor128)的`flipTwo()`，*转换函数*也是可能的：
- en: '[PRE177]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The pipeline works as expected: we split the string into words, we map each
    word to make its first letter uppercase, and we join the array elements to form
    a string again. We could have used `reduce()` for the last step, but `join()`
    already does what we need, so why reinvent the wheel?'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 管道工作如预期：我们将字符串拆分为单词，将每个单词映射为其首字母大写，然后将数组元素连接起来再次形成字符串。我们本可以使用`reduce()`来完成最后一步，但`join()`已经完成了我们需要的功能，所以为什么还要重新发明轮子呢？
- en: '[PRE178]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '8.2 **Pending tasks**: The following pipeline does the job:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2 **待办任务**：以下管道完成了工作：
- en: '[PRE179]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The `reduce()` call may be mystifying. By that time, we are handling an array
    with a single element – an object – and we want the object in the pipeline, not
    the array. This code works even if the responsible person doesn’t exist, or if
    all the tasks have been completed; can you see why? Also, note that if `allTasks`
    is `null`, an object must be provided with the `byPerson` property so that future
    functions won’t crash! For an even better solution, I think monads are better:
    see *Question 12.1* for more.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`调用可能令人困惑。到那时，我们正在处理一个只有一个元素的数组 – 一个对象 – 我们想要管道中的对象，而不是数组。即使负责的人不存在，或者所有任务都已完成，这段代码仍然可以工作；你能看出为什么吗？此外，请注意，如果`allTasks`是`null`，必须提供一个具有`byPerson`属性的`object`，以便未来的函数不会崩溃！为了更好的解决方案，我认为单子更好：参见*问题12.1*以获取更多信息。'
- en: '8.3 **Thinking in abstract terms**: The simple solution implies composing.
    I preferred it to pipelining in order to keep the list of functions in the same
    order:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3 **以抽象术语思考**：简单的解决方案意味着组合。我更喜欢它，而不是管道，以便保持函数列表的顺序：
- en: '[PRE180]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '8.4 **Reversing types**: We can apply recursion to reverse a list of types:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 8.4 **反转类型**：我们可以通过递归来反转类型列表：
- en: '[PRE181]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'With this, we can define `Compose<>` in terms of `Pipeline<>`:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以用`Pipeline<>`来定义`Compose<>`：
- en: '[PRE182]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Instead of an overload, we’re using a cast here to let TypeScript know what
    types we are working with.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用类型转换而不是重载，让TypeScript知道我们正在处理什么类型。
- en: 8.5 `pipeline()` function we wrote accesses `fns[0]` without checking whether
    the `fns` array is empty, so it won’t work. The `pipeline1()` and `pipeline2()`
    functions use `reduce()` without an initial value, so they will also fail. We
    must add an initial test, so if no functions are provided (`fns.length===0`),
    we’ll simply return the input value as the result.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 8.5 我们编写的 `pipeline()` 函数在访问 `fns[0]` 时没有检查 `fns` 数组是否为空，所以它不会工作。`pipeline1()`
    和 `pipeline2()` 函数使用没有初始值的 `reduce()`，所以它们也会失败。我们必须添加一个初始测试，如果没有提供函数（`fns.length===0`），我们只需将输入值作为结果返回。
- en: '8.6 **Undetected impurity?** Yes, the function is impure, but using it as-is
    would fall squarely under the **Sorta Functional Programming** (**SFP**) style
    we mentioned back in the *Theory versus practice* section of [*Chapter 1*](B19301_01.xhtml#_idTextAnchor015)*,
    Becoming Functional*. The version we used is not pure, but in the way we use it,
    the final results are pure: we modify an array in place, but it’s a new array
    that we are creating. The alternate implementation is pure and also works, but
    will be slower since it creates a completely new array every time we call it.
    So, accepting this bit of impurity helps us get a function that performs better;
    we can accept that!'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 8.6 **未检测到的杂质？** 是的，这个函数是不纯的，但如果我们直接使用它，就会完全符合我们在 [*第一章*](B19301_01.xhtml#_idTextAnchor015)
    的 *理论与实践* 部分提到的 **Sorta Functional Programming** （SFP）风格。我们使用的版本不是纯的，但按照我们的使用方式，最终结果仍然是纯的：我们在原地修改数组，但我们创建的是一个新数组。另一种实现方式是纯的，也可以工作，但会慢一些，因为它每次调用都会创建一个全新的数组。所以，接受这一点杂质有助于我们获得性能更好的函数；我们可以接受这一点！
- en: '8.7 `map()` operations, you could apply a single `map()` by pipelining all
    the mapping functions into a single one. For `filter()` operations, it becomes
    a bit harder, but here’s a tip: use `reduce()` to apply all the filters in sequence
    with a carefully thought-out accumulating function.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 8.7 在 `map()` 操作中，你可以通过将所有映射函数管道化到一个单独的函数中，应用单个 `map()`。对于 `filter()` 操作，这会变得有点困难，但这里有一个提示：使用
    `reduce()` 来按顺序应用所有过滤器，并使用一个精心设计的累积函数。
- en: '8.8 `chainify()`, the type of `myCity2` is `Chainify<City>`. Attributes have
    the same types as before, but the `void`-returning methods now return an object
    of the same `Chainify<City>` type:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 8.8 `chainify()`，`myCity2` 的类型是 `Chainify<City>`。属性类型与之前相同，但现在返回 `void` 的方法现在返回相同类型的
    `Chainify<City>` 对象：
- en: '[PRE183]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Chapter 9, Designing Functions – Recursion
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章，设计函数 – 递归
- en: '9.1 `reverse("MONTEVIDEO")` can be found by doing `reverse("ONTEVIDEO")+"M"`.
    In the same way, `reverse("ONTEVIDEO")` would be equal to `reverse("NTEVIDEO")+"O"`,
    and so on:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 9.1 可以通过 `reverse("ONTEVIDEO")+"M"` 找到 `reverse("MONTEVIDEO")`。同样，`reverse("ONTEVIDEO")`
    将等于 `reverse("NTEVIDEO")+"O"`，以此类推：
- en: '[PRE184]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '9.2 **Climbing steps**: To climb a ladder with *n* steps, we can act in two
    ways:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 9.2 **爬楼梯步骤**：要爬一个有 *n* 级的楼梯，我们可以有两种行动方式：
- en: Climb one single step and then climb an (*n*-1) steps ladder
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先爬一个单级楼梯，然后爬一个 (*n*-1) 级的楼梯
- en: Climb two steps at once and then climb an (*n*-2) steps ladder
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次爬两级楼梯，然后爬一个 (*n*-2) 级的楼梯
- en: 'So, if we call ladder(*n*) the number of ways to climb a steps ladder, we know
    that ladder(n)= ladder(*n*-1) + ladder(*n*-2). Adding the fact that ladder(0)=1
    (there’s only one way to climb a ladder with no steps: do nothing) and ladder(1)=1,
    the solution is that ladder(*n*) equals the (*n*-1)th Fibonacci number! Check
    it out: ladder(2)=2, ladder(3)=3, ladder(4)=5, and so on.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们调用 `ladder(*n*)` 来表示爬楼梯的方式数，我们知道 `ladder(n)= ladder(*n*-1) + ladder(*n*-2)`。加上事实
    `ladder(0)=1`（没有台阶的楼梯只有一种爬法：什么都不做）和 `ladder(1)=1`，解决方案是 `ladder(*n*)` 等于 (*n*-1)
    项斐波那契数！看看这个：`ladder(2)=2`，`ladder(3)=3`，`ladder(4)=5`，以此类推。
- en: '9.3 `max`), create a new copy of the array but without that element, sort the
    copy, and then return the sorted copy with `max` added at the end. Take a look
    at how we dealt with the mutator functions to avoid modifying the original array
    and note that this sorting code only works with numbers because of the way we
    find `max`:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 9.3 使用 `max` 函数)，创建一个不包含该元素的数组的新副本，对副本进行排序，然后将 `max` 添加到排序副本的末尾。看看我们是如何处理修改器函数以避免修改原始数组的，注意这段排序代码只适用于数字，因为我们找到
    `max` 的方式：
- en: '[PRE185]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 9.4 `smaller` would be an empty array, and `greaterEqual` would be equal to
    the whole array to sort, so the logic would enter an infinite loop.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 9.4 如果 `smaller` 是一个空数组，而 `greaterEqual` 等于要排序的整个数组，那么逻辑将进入无限循环。
- en: The original code can never enter a loop because every pass removes one element
    (the pivot) so you’re guaranteed to reach a state with nothing left to sort.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码永远不会进入循环，因为每次遍历都会移除一个元素（枢轴），所以你一定会达到一个没有剩余元素可以排序的状态。
- en: '9.5 **More efficiency**: The following code does the work for us. Here, we
    use a ternary operator to decide where to push the new item:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 9.5 **更高的效率**：以下代码为我们完成了这项工作。在这里，我们使用三元运算符来决定将新项目推送到哪里：
- en: '[PRE186]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '9.6 `mapR()`, so I’ll skip repeating explanations – the only difference is
    in the `return` value, which is now a value from the array (`arr[0]` in `findLoop()`)
    instead of a mapped whole array as in `mapR()`:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 9.6 `mapR()`，所以我将跳过重复的解释——唯一的区别在于 `return` 值，现在是一个来自数组（`findLoop()` 中的 `arr[0]`）的值，而不是
    `mapR()` 中的映射整个数组：
- en: '[PRE187]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '9.7 `mapR()` example, so I won’t comment on the looping, types, and so on.
    When programming `everyR()`, we must be careful what to do with empty arrays or
    missing places; the standard `every()` method considers them to return `true`,
    so we’ll do the same:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 9.7 `mapR()` 示例，所以我不会对循环、类型等进行注释。当编程 `everyR()` 时，我们必须小心处理空数组或缺失的位置；标准的 `every()`
    方法认为它们返回 `true`，所以我们将这样做：
- en: '[PRE188]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'When programming `someR()`, an empty array means a false result, but empty
    places are skipped:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 当编程 `someR()` 时，一个空数组意味着一个错误的结果，但空位将被跳过：
- en: '[PRE189]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '9.8 **Symmetrical queens**: The key to finding only symmetric solutions is
    as follows. After the first four queens have been (tentatively) placed on the
    first half of the board, we don’t have to try all the possible positions for the
    other queens; they are automatically determined with regard to the first ones:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 9.8 **对称皇后**：找到仅对称解的关键如下。在第一个四个皇后（试探性地）放置在棋盘的前半部分之后，我们不需要尝试其他皇后的所有可能位置；它们会自动根据第一个确定：
- en: '[PRE190]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Calling `symmetricFinder()` produces four solutions, which are essentially the
    same. Make drawings and check them to make sure the solution is correct!
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `symmetricFinder()` 产生四个解，它们本质上是一样的。画图并检查它们以确保解是正确的！
- en: '[PRE191]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '9.9 `a` and `b`, can be found with recursion as follows:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 9.9 `a` 和 `b`，可以通过以下递归方式找到：
- en: If the length of `a` is zero, or if the length of `b` is zero, return zero
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 的长度为零，或者如果 `b` 的长度为零，则返回零
- en: If the first characters of `a` and `b` match, the answer is 1 plus the LCS of
    `a` and `b`, both minus their initial characters
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 和 `b` 的第一个字符匹配，答案是 1 加上 `a` 和 `b` 的 LCS，两者都减去它们的初始字符
- en: 'If the first characters of `a` and `b` do not match, the answer is the largest
    of the following two results:'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` 和 `b` 的第一个字符不匹配，答案是以下两个结果中的较大者：
- en: The LCS of `a` minus its initial character, and `b`
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LCS（最长公共子序列）的 `a` 减去其初始字符，以及 `b`
- en: The LCS of `a`, and `b` minus its initial character
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 的 LCS 减去其初始字符'
- en: 'We can implement this as follows. We do memoization “by hand” to avoid repeating
    calculations; we could have also used our memoization function:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现。我们手动进行记忆化以避免重复计算；我们也可以使用我们的记忆化函数：
- en: '[PRE192]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: As an extra exercise, you could produce not only the length of the LCS but also
    the characters that are involved.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可以不仅产生 LCS 的长度，还可以产生涉及到的字符。
- en: '9.10 `2` and check whether the remainder is `1`:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 9.10 `2` 并检查余数是否为 `1`：
- en: '[PRE193]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'You could have another solution by doing `return Boolean(n %` `2)` instead:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行 `return Boolean(n % 2)` 来得到另一个解决方案：
- en: '[PRE194]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Another way is to divide the number by 2 and check whether it has a fractional
    part:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是除以 2 并检查是否有分数部分：
- en: '[PRE195]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'If a number is odd, dividing it by 2 and dividing its predecessor by 2, both
    results have the same integer part (for instance, 9/2 and 8/2 both have integer
    part 4):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字是奇数，将其除以 2 并将其前驱除以 2，两个结果都有相同的整数部分（例如，9/2 和 8/2 都有整数部分 4）：
- en: '[PRE196]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Using bit operations is fast; an odd number will have its least significant
    bit set to `1`:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位操作速度快；奇数将会有其最低有效位设置为 `1`：
- en: '[PRE197]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'As in `isOdd1()`, you get another variation by doing `return Boolean(n &` `1)`
    instead:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `isOdd1()` 类似，你可以通过执行 `return Boolean(n & 1)` 来得到另一种变体：
- en: '[PRE198]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Shifting in binary also works; if we shift the number one bit to the right
    (dropping its least significant bit) and then shift the number back one bit to
    the left, for an odd number, we don’t get the same result:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制中的移位也有效；如果我们把数字右移一位（丢弃其最低有效位），然后把这个数字左移一位，对于奇数，我们不会得到相同的结果：
- en: '[PRE199]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Shifting to the right is the same as dividing by 2 and keeping the integer
    part, so this solution is basically the same as the third one:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 右移等同于除以 2 并保留整数部分，所以这个解决方案基本上与第三个相同：
- en: '[PRE200]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Odd numbers end in 1, 3, 5, 7, or 9, so we can also look at the string representation
    of the number and check its value:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数以 1、3、5、7 或 9 结尾，因此我们也可以查看数字的字符串表示并检查其值：
- en: '[PRE201]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: We could work with the string by using `find()` or `indexOf()`; I’ll leave these
    versions to you.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `find()` 或 `indexOf()` 来处理字符串；我将把这些版本留给你。
- en: '9.11 `trampoline()`:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 9.11 `trampoline()`：
- en: '[PRE202]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'For instance, the first `return` in `isEven()` used to be `return true`; now
    we trampoline a thunk that will call a continuation with `true`. We can now finish
    the job by providing an appropriate continuation that just returns the calculated
    value:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`isEven()` 函数中的第一个 `return` 之前是 `return true`；现在我们使用 trampoline 技巧调用一个带有
    `true` 的 continuation。现在我们可以通过提供一个仅返回计算值的适当 continuation 来完成工作：
- en: '[PRE203]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '9.12 `isEven(1)` or `isOdd(2)`, you get an infinite loop; can you see why?
    (The same will happen if you replace `1` and `2` with any odd or even number,
    respectively.) A hint: the problem is with the base cases for recursion.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 9.12 `isEven(1)` 或 `isOdd(2)`，你会得到一个无限循环；你能看出为什么？（如果你用任何奇数或偶数分别替换 `1` 和 `2`，也会发生相同的情况。）提示：问题出在递归的基本情况上。
- en: 9.13 `while()` with a `for(;;)` loop and breaking out with a `return`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 9.13 使用 `for(;;)` 循环和 `return` 语句的 `while()`。
- en: 9.14 `power()` function, sitting between `term()` and `factor()`, so its priority
    will be correctly placed.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 9.14 `power()` 函数位于 `term()` 和 `factor()` 之间，因此其优先级将被正确放置。
- en: '![Figure 2 – Power represents a sequence of exponentiations](img/Figure_2_B19301.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
  zh: '![图 2 – Power 表示指数序列](img/Figure_2_B19301.jpg)'
- en: Figure 2 – Power represents a sequence of exponentiations
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2 – Power 表示指数序列
- en: 'We’ll change `term()` to call `power()` instead of `factor()`:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 `term()` 以调用 `power()` 而不是 `factor()`：
- en: '[PRE204]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'To properly calculate “towers” such as 2^3^4, we’ll store `2`, `3`, and `4`
    in an array, and then reduce it from right to left: we’ll first calculate 3^4,
    and then 2^(the calculated result for 3^4):'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确计算“塔”如 2^3^4，我们将 `2`、`3` 和 `4` 存储在一个数组中，然后从右到左进行归约：我们首先计算 3^4，然后计算 2^(3^4
    的计算结果)：
- en: '[PRE205]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '9.15 **Error-prone evaluation**: Here are some ideas:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 9.15 **易出错的评估**：以下是一些想法：
- en: When skipping a token, check if it’s correct anyway; for instance, `factor()`
    skips the second parenthesis without actually checking whether it is, so it would
    evaluate “(1+2]” as 3, even though it’s wrong.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跳过一个标记时，检查它是否正确；例如，`factor()` 跳过了第二个括号，但实际上并没有检查它是否正确，因此它会将“（1+2]”评估为 3，尽管这是错误的。
- en: Add a special end-of-string (EOS) token, to check whether the evaluation finishes
    at that token.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个特殊的字符串结束（EOS）标记，以检查评估是否在该标记处结束。
- en: Check you do not go beyond the end of the `tokens` array whenever you advance
    to the next token.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次前进到下一个标记时，请检查您是否没有超出 `tokens` 数组的末尾。
- en: Chapter 10, Ensuring Purity – Immutability
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章，确保纯净性 – 不可变性
- en: '10.1 `jsonCopy()` in the following example, but don’t assume there aren’t any
    more problems:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 10.1 在以下示例中，`jsonCopy()`，但不要假设没有更多问题：
- en: '[PRE206]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Four of the properties got transformed into an empty object, and the function
    was ignored.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 四个属性被转换成了空对象，而函数被忽略了。
- en: '10.2 `deepCopy()` function does marginally better; with the same agent object
    as in the previous question, copying produces the following:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2 `deepCopy()` 函数略有改进；与上一个问题中的相同代理对象，复制产生以下结果：
- en: '[PRE207]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The error and the function got converted OK. The map and the set were converted
    into the right types, but they are empty; this could be fixed by adding logic
    that would scan the original objects and insert copies of them into the new ones.
    (*Question 10.10* may help.) Finally, cloning a regular expression is a tad harder,
    but google “*clone regexp in JavaScript*” and you’ll find several implementations
    for this.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和函数已正确转换。map 和 set 已转换为正确的类型，但它们是空的；可以通过添加逻辑来修复，该逻辑将扫描原始对象并将它们的副本插入到新对象中。（*问题
    10.10* 可能有所帮助。）最后，克隆正则表达式稍微困难一些，但搜索“*clone regexp in JavaScript*”将找到几个实现。
- en: '10.3 `deepCopy2()` function is as follows:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 10.3 `deepCopy2()` 函数如下：
- en: '[PRE208]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: We’ll use the `mapped` variable for our map. When we find that we have to clone
    an `obj` object, we first check (`mapped.has(obj)`) whether we have already done
    that, and if so, we return the value from the map. If this was a new, not yet
    copied object, we add it and its `aux` copy to the map (`mapped.set(obj,aux)`)
    for future reference.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `mapped` 变量进行映射。当我们发现需要克隆一个 `obj` 对象时，我们首先检查（`mapped.has(obj)`）是否已经执行过，如果是，则从映射中返回值。如果这是一个新的、尚未复制的对象，我们将将其及其
    `aux` 复制添加到映射中（`mapped.set(obj,aux)`）以供将来参考。
- en: 'We can verify how this work with a simple example:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的例子来验证其工作原理：
- en: '[PRE209]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'If we use `deepCopy()` on `circular`, we’ll get a `RangeError: Maximum call
    stack size exceeded` exception. However, with our new `deepCopy2()` function,
    the circular reference is tackled with no problem.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在`circular`上使用`deepCopy()`，我们将得到一个`RangeError: Maximum call stack size
    exceeded`异常。然而，使用我们新的`deepCopy2()`函数，循环引用问题得以解决。'
- en: '10.4 **Freezing by proxying**: As requested, a proxy allows you to intercept
    changes on an object. (See [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    for more on this.) We use recursion to apply the proxy all the way down in case
    some attributes are objects themselves:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 10.4 **通过代理冻结**：如请求，代理允许你拦截对象上的更改。（有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)）我们使用递归将代理应用到所有属性，以防某些属性本身是对象：
- en: '[PRE210]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The following is the output of the preceding code. For real-life implementations,
    you’d probably require something other than a `DON'T MODIFY ANYTHING IN ME` message,
    of course!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在前面的代码中的输出。对于现实生活中的实现，你可能会需要除了`DON'T MODIFY ANYTHING IN ME`消息之外的其他东西，当然！
- en: '[PRE211]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '10.5 **Inserting into a list, persistently**: Using recursion helps out as
    follows:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 10.5 **持久地插入到列表中**：使用递归有助于如下：
- en: If the list is empty, we cannot insert the new key.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列表为空，我们无法插入新键。
- en: If we are at a node whose key is `oldKey`, we create a clone of that node that
    points at a list that starts with a new node with `newKey` as its value and a
    pointer to the rest of the original node’s list.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们处于一个键值为`oldKey`的节点，我们将创建一个指向以`newKey`为其值的新节点和指向原始节点列表其余部分的指针的该节点的克隆。
- en: 'If we are at a node whose key isn’t `oldKey`, we create a clone of the node
    and (recursively) insert the new key somewhere in the rest of the original node’s
    list:'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们处于一个键值不是`oldKey`的节点，我们将创建该节点的克隆，并将新键（递归地）插入到原始节点列表的其余部分：
- en: '[PRE212]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'In the following code, we can see this working. The new list is similar to
    the one shown in *Figure 10**.2*. However, printing out the lists (`c3` and `newList`)
    wouldn’t be enough; you wouldn’t be able to distinguish new or old nodes, so I’ve
    included several comparisons:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们可以看到这个工作。新列表类似于*图10*.2中显示的列表。然而，仅打印列表（`c3`和`newList`）是不够的；你将无法区分新节点或旧节点，所以我包括了一些比较：
- en: '[PRE213]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: A lot of `!` non-null assertions were needed to inform TypeScript that no `null`
    values were around.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 需要很多`!`非空断言来通知TypeScript没有`null`值。
- en: 'A new question: In the preceding logic, nothing is inserted if `oldKey` isn’t
    found. Can you change the logic so, in that case, the new node is added at the
    end of the list?'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新问题：在先前的逻辑中，如果没有找到`oldKey`，则不会插入任何内容。你能改变逻辑，使得在这种情况下，新节点被添加到列表的末尾吗？
- en: '10.6 `reduce()`. Let’s write the `composeManyLenses()` function and apply it
    to the same example that was shown in the text:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 10.6 `reduce()`。让我们编写`composeManyLenses()`函数并将其应用于文本中显示的相同示例：
- en: '[PRE214]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'With the `deepObject` example seen earlier, plus all the lenses to get `c`,
    `e`, `g`, and so on, we get the following:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面看到的`deepObject`示例，以及所有获取`c`、`e`、`g`等值的透镜，我们得到以下内容：
- en: '[PRE215]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 10.7 `getField()` to `getByPath()`.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 10.7 `getField()` 到 `getByPath()`。
- en: '10.8 `fullName` attribute:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 10.8 `fullName` 属性：
- en: '[PRE216]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Being able to set several attributes based on a single value isn’t always possible,
    but if we assume the incoming name is in the `LAST,FIRST` format, we can split
    it by the comma and assign the two parts to the first and last names, respectively:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 基于单个值设置多个属性并不总是可能的，但如果我们假设传入的名称是`LAST,FIRST`格式，我们可以通过逗号分割它，并将两部分分别分配给姓氏和名字：
- en: '[PRE217]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 10.9 `view()` function would work well, but `set()` and `over()` wouldn’t work
    in a pure way since `setArray()` doesn’t return a new array; instead, it modifies
    the current one in place. Take a look at the following question for a related
    problem.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 10.9 `view()` 函数将工作得很好，但`set()`和`over()`在纯方式下不会工作，因为`setArray()`不会返回一个新数组；相反，它会在原地修改当前数组。查看以下问题以了解相关的问题。
- en: '10.10 **Lenses into maps**: Getting a value from the map poses no problem,
    but for setting, we need to clone the map:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 10.10 **映射中的透镜**：从映射中获取值没有问题，但对于设置，我们需要克隆映射：
- en: '[PRE218]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Chapter 11, Implementing Design Patterns – The Functional Way
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章，以函数式方式实现设计模式
- en: '11.1 **Decorating methods, the future way**: As we’ve already mentioned, decorators
    aren’t a fixed, definitive feature at the moment. However, by following [tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/),
    we can write the following:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1 **装饰方法，未来的方式**：正如我们之前提到的，装饰器目前不是一个固定的、最终确定的功能。然而，通过遵循 [tc39.github.io/proposal-decorators/](http://tc39.github.io/proposal-decorators/)，我们可以编写以下代码：
- en: '[PRE219]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'We want to add a `@logging` decoration to a method. We save the original method
    in `savedMethod` and substitute a new method that will log the received arguments,
    call the original method to save its return value, log that, and finally return
    it. If the original method throws an exception, we catch it, report it, and throw
    it again so that it can be processed as expected. A simple example of this is
    as follows:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想给一个方法添加 `@logging` 装饰器。我们将原始方法保存在 `savedMethod` 中，并替换为一个新方法，该新方法将记录接收到的参数，调用原始方法以保存其返回值，记录该值，并最终返回它。如果原始方法抛出异常，我们将捕获它，报告它，并再次抛出，以便它可以按预期进行处理。这个简单示例如下：
- en: '[PRE220]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '11.2 `addBar()` function that receives a `Base` class and extends it. In this
    case, I decided to add a new attribute and a new method. The constructor for the
    extended class calls the original constructor and creates the `barValue` attribute.
    The new class has both the original’s `doSomething()` method and the new `somethingElse()`
    method:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 11.2 接收 `Base` 类并扩展它的 `addBar()` 函数。在这种情况下，我决定添加一个新的属性和一个新的方法。扩展类的构造函数调用原始构造函数并创建
    `barValue` 属性。新类既有原始的 `doSomething()` 方法，也有新的 `somethingElse()` 方法：
- en: '[PRE221]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 11.3 `event.detail`; you can find out more at [developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail](http://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 11.3 `event.detail`；你可以在 [developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail](http://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
    上了解更多信息。
- en: 11.4 `flags` array with Boolean values, you don’t need any special comparison
    function; `flags.sort()` works “out of the box” and will place `false` values
    first and `true` values last. This is because the standard sort works by converting
    values into strings, and then comparing them; when you do this, Boolean values
    become `"false"` and `"true"`, and as `"false" < "true"`, everything turns out
    well!
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 11.4 带有布尔值的 `flags` 数组，你不需要任何特殊的比较函数；`flags.sort()` 可以“直接使用”并将 `false` 值放在前面，`true`
    值放在后面。这是因为标准排序是通过将值转换为字符串，然后比较它们来实现的；当你这样做时，布尔值变为 `"false"` 和 `"true"`，由于 `"false"`
    小于 `"true"`，所以一切顺利！
- en: 11.5 `RouteFinder` class with several subclasses, such as `ByFootRouteFinder`,
    `BicycleRouteFinder`, and so on, each implementing a `findRouteAlgorithm()` method
    in a different way, and a factory that chooses what subclass to instantiate.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 11.5 `RouteFinder` 类及其几个子类，如 `ByFootRouteFinder`、`BicycleRouteFinder` 等，每个子类以不同的方式实现
    `findRouteAlgorithm()` 方法，并有一个工厂来选择要实例化的子类。
- en: Chapter 12, Building Better Containers – Functional Data Types
  id: totrans-784
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章，构建更好的容器 - 函数式数据类型
- en: '12.1 `map()` method to Booleans, numbers, and strings:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1 `map()` 方法到布尔值、数字和字符串：
- en: '[PRE222]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Some examples are as follows:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE223]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '12.2 `Symbol`, whose value was defined inside a module and not exported, so
    nobody could access the corresponding attribute:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2 `Symbol`，其值是在模块内部定义的，并且没有导出，所以没有人可以访问相应的属性：
- en: '[PRE224]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Using a `Symbol` helps hide the field: the property key won’t show up in `Object.keys()`
    or in `for...in` or `for...of` loops, making them more meddle-proof. (If you haven’t
    worked with JavaScript symbols, possibly the least known of its primitive data
    types, you might want to check out [developer.mozilla.org/en-US/docs/Glossary/symbol](http://developer.mozilla.org/en-US/docs/Glossary/symbol).)'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Symbol` 有助于隐藏字段：属性键不会出现在 `Object.keys()` 或 `for...in` 或 `for...of` 循环中，这使得它们更加难以篡改。（如果你还没有使用过
    JavaScript 符号，可能是它最不为人知的原始数据类型，你可能想查看 [developer.mozilla.org/en-US/docs/Glossary/symbol](http://developer.mozilla.org/en-US/docs/Glossary/symbol)。）
- en: The `map()` method could access the “protected” attribute because it had access
    to the `VALUE` symbol, but without that, you cannot get at the attribute.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 方法能够访问“受保护”的属性，因为它可以访问 `VALUE` 符号，但如果没有那个，就无法获取该属性。'
- en: '12.3 `XXX` class to be abstract, it should start like this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3 `XXX` 类应该是一个抽象类，它应该像这样开始：
- en: '[PRE225]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '12.4 **Maybe tasks?** The following code shows a simpler solution than the
    one we looked at earlier:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 12.4 **可能是任务吗？** 以下代码显示了一个比我们之前看到的更简单的解决方案：
- en: '[PRE226]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Here, we apply one function after the other, secure in the knowledge that if
    any of these functions produces an empty result (or even if the original `listOfTasks`
    is null), the sequence of calls will go on. In the end, you will either get an
    array of task IDs or a `null` value.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依次应用一个函数，因为我们知道如果这些函数中的任何一个产生空结果（或者如果原始的`listOfTasks`是null），调用序列将继续。最终，你将得到一个任务ID数组或一个`null`值。
- en: '12.5 **Extending your trees**: Calculating the tree’s height is simple if you
    do this in a recursive fashion. The height of an empty tree is zero, while the
    height of a non-empty tree is one (for the root) plus the maximum height of its
    left and right subtrees:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 12.5 **扩展你的树**：如果你以递归方式计算，树的高度计算很简单。空树的高度为零，而非空树的高度是一（对于根节点）加上其左右子树的最大高度：
- en: '[PRE227]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Listing the keys in order is a well-known requirement. Because of the way that
    the tree is built, you list the left subtree’s keys first, then the root, and
    finally the right subtree’s keys, all in a recursive fashion:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序列出键是一个众所周知的要求。由于树是按照这种方式构建的，你首先列出左子树的键，然后是根，最后是右子树的键，所有这些都是在递归方式下完成的：
- en: '[PRE228]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Finally, deleting a key from a binary search tree is a bit more complex. First,
    you must locate the node that is going to be removed, and then there are several
    cases:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从二叉搜索树中删除一个键要复杂一些。首先，你必须找到将要被删除的节点，然后有几种情况：
- en: If the node has no subtrees, deletion is simple.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点没有子树，删除操作很简单。
- en: If the node has only one subtree, you just replace the node with its subtree
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点只有一个子树，你只需用它的子树替换节点
- en: 'If the node has two subtrees, then you have to do the following:'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点有两个子树，那么你必须这样做：
- en: Find the minimum key in the tree with a greater key
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树中找到具有更大键的最小键
- en: Place it in the node’s place
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其放在节点的位置
- en: 'Since this algorithm is well covered in all computer science textbooks, I won’t
    go into more detail about this here:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个算法在所有计算机科学教科书中都有很好的覆盖，所以我不会在这里详细介绍：
- en: '[PRE229]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '12.6 `||` operator:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 12.6 `||`运算符：
- en: '[PRE230]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Also, seeing that both alternatives in the second ternary operator are very
    similar, you could also do some shortening there:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，鉴于第二个三元运算符中的两个备选方案非常相似，你还可以在那里进行一些简化：
- en: '[PRE231]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Remember: shorter doesn’t imply better! However, I’ve found many examples of
    this kind of code tightening, and it’s better if you have been exposed to it,
    too.'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：短并不意味着好！然而，我发现了很多这种代码紧缩的例子，如果你也接触过这些，那就更好了。
- en: '12.7 **Functional lists**: Let’s add to the samples that have already been
    provided. We can simplify working with lists if we can transform a list into an
    array, and vice versa:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 12.7 **函数列表**：让我们添加已经提供的样本。如果我们能够将列表转换成数组，反之亦然，我们可以简化与列表的交互：
- en: '[PRE232]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Concatenating two lists together and appending a value to a list have simple
    recursive implementations. We can also reverse a list by using the appending function:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个列表连接在一起并将一个值追加到列表中都有简单的递归实现。我们还可以通过使用追加函数来反转列表：
- en: '[PRE233]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Finally, the basic `map()`, `filter()`, and `reduce()` operations are good
    to have:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，基本的`map()`、`filter()`和`reduce()`操作是很有用的：
- en: '[PRE234]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The following are some exercises that have been left for you to tackle. Generate
    a printable version of a list:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些留给你的练习。生成一个可打印的列表版本：
- en: Compare two lists to see whether they have the same values, in the same order
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较两个列表，看它们是否有相同的值，且顺序相同
- en: Search a list for a value
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中搜索一个值
- en: Get, update, or remove the value at the *n*th position of a list
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取、更新或删除列表中第*n*个位置上的值
- en: '12.8 `BOOLEAN` type and two special functions, `TRUE` and `FALSE`, which will
    stand for the usual `true` and `false` values:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 12.8 `BOOLEAN`类型和两个特殊函数`TRUE`和`FALSE`，它们将代表通常的`true`和`false`值：
- en: '[PRE235]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The `BOOLEAN` type receives two values and returns one of those. A `TRUE` Boolean
    returns the first of those two values; a `FALSE` Boolean returns the second. We
    can construct and check variables like this:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOLEAN`类型接收两个值并返回其中一个。一个`TRUE`布尔值返回这两个值中的第一个；一个`FALSE`布尔值返回第二个。我们可以这样构造和检查变量：'
- en: '[PRE236]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'We can now define operators:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义运算符：
- en: '[PRE237]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'These are not the only possibilities, but I’ll leave you to discover alternatives.
    Finally, we could have an `ifElse()` function to work with these `BOOLEAN` values
    and thunks:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是唯一可能的情况，但我将留给你去发现其他替代方案。最后，我们可以有一个`ifElse()`函数来处理这些`BOOLEAN`值和thunks：
- en: '[PRE238]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'A final comment: this code goes to show more things that you *could* do with
    functions, but it doesn’t mean you *should* do them this way! You can read the
    following at [www.usrsb.in/Building-Data-Structures-from-Functions.html](http://www.usrsb.in/Building-Data-Structures-from-Functions.html):'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的评论：这段代码展示了你可以用函数做更多的事情，但这并不意味着你应该这样去做！你可以在[www.usrsb.in/Building-Data-Structures-from-Functions.html](http://www.usrsb.in/Building-Data-Structures-from-Functions.html)阅读以下内容：
- en: In the end, this might strike you as nothing more than a useless programming
    trick. In a sense that’s right. I’d never use this in my own code. What makes
    this technique so valuable is that it actually fits into the broader context of
    lambda calculus, which is a mathematical abstraction of computation.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这可能会让你觉得这不过是一个无用的编程技巧。从某种意义上说，这是正确的。我永远不会在我的代码中使用这个技巧。这个技巧之所以有价值，是因为它实际上符合lambda演算的更广泛背景，而lambda演算是一种计算数学抽象。
- en: Couldn’t say it better myself!
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法用更好的方式来表达这一点！
- en: Bibliography
  id: totrans-836
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考书目
- en: 'The following texts are freely available online:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本可在网上免费获取：
- en: '*ECMA-262: ECMAScript 2022 Language Specification*, latest edition (currently
    the 13th) at [www.ecma-international.org/ecma-262/](http://www.ecma-international.org/ecma-262/).
    This provides the official standard for the current version of JavaScript.'
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《ECMA-262：ECMAScript 2022语言规范》*，最新版（目前为第13版）可在[www.ecma-international.org/ecma-262/](http://www.ecma-international.org/ecma-262/)找到。这提供了当前版本JavaScript的官方标准。'
- en: '*Eloquent JavaScript*, Second Edition, by *Marijn Haverbeke*, at [eloquentjavascript.net/](http://eloquentjavascript.net/)'
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《优雅的JavaScript》第二版*，由*Marijn Haverbeke*著，可在[eloquentjavascript.net/](http://eloquentjavascript.net/)找到'
- en: '*JavaScript for Impatient Programmers (ES2022 edition)*, by *Dr. Axel* *Rauschmayer*,
    at [exploringjs.com/impatient-js/](http://exploringjs.com/impatient-js/)'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript急速入门（ES2022版）》*，由*Dr. Axel Rauschmayer*著，可在[exploringjs.com/impatient-js/](http://exploringjs.com/impatient-js/)找到'
- en: '*Functional-Light JavaScript*, by *Kyle Simpson*, at [github.com/getify/Functional-Light-JS](http://github.com/getify/Functional-Light-JS)'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript函数式编程》*，由*Kyle Simpson*著，可在[github.com/getify/Functional-Light-JS](http://github.com/getify/Functional-Light-JS)找到'
- en: '*JavaScript Allongé (the “six” edition)*, by *Reginald Braithwaite*, at [leanpub.com/javascriptallongesix/read](http://leanpub.com/javascriptallongesix/read)'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript Allongé（第六版）》*，由*Reginald Braithwaite*著，可在[leanpub.com/javascriptallongesix/read](http://leanpub.com/javascriptallongesix/read)找到'
- en: '*Professor Frisby’s Mostly Adequate Guide to Functional Programming*, by *Dr.
    Boolean* (*Brian Lonsdorf*), at [github.com/MostlyAdequate/mostly-adequate-guide](http://github.com/MostlyAdequate/mostly-adequate-guide)'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《教授弗里斯比的函数式编程指南》*，由*Dr. Boolean*（*Brian Lonsdorf*）著，可在[github.com/MostlyAdequate/mostly-adequate-guide](http://github.com/MostlyAdequate/mostly-adequate-guide)找到'
- en: 'If you prefer printed books, you can go with this list:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢纸质书籍，可以参考以下列表：
- en: '*Beginning Functional JavaScript*, by *Anto Aravinth*, *Apress*, 2017'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript函数式编程入门》*，由*Anto Aravinth*著，*Apress*出版社，2017年'
- en: '*Discover Functional JavaScript*, by *Cristian Salcescu*, (independently published),
    2019'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《探索函数式JavaScript》*，由*Cristian Salcescu*著，（独立出版），2019年'
- en: '*Functional JavaScript*, by *Michael Fogus*, *O’Reilly* *Media*, 2013'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《函数式JavaScript》*，由*Michael Fogus*著，*O''Reilly Media*，2013年'
- en: '*Functional Programming in JavaScript*, by *Dan Mantyla*, *Packt* *Publishing*,
    2015'
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript函数式编程》*，由*Dan Mantyla*著，*Packt Publishing*，2015年'
- en: '*Functional Programming in JavaScript*, by *Luis Atencio*, *Manning* *Publications*,
    2016'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript函数式编程》*，由*Luis Atencio*著，*Manning Publications*，2016年'
- en: '*Grokking Simplicity – Taming complex software with functional thinking*, by
    *Eric Normand*, *Manning* *Publications*, 2021'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《通过函数式思维驯服复杂软件——Grokking Simplicity》*，由*Eric Normand*著，*Manning Publications*，2021年'
- en: '*Hands-on Functional Programming with TypeScript*, by *Remo Jansen*, *Packt*
    *Publishing*, 2019'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用TypeScript进行实战函数式编程》*，由*Remo Jansen*著，*Packt Publishing*，2019年'
- en: '*Introduction to Functional Programming*, by *Richard Bird and Philip Wadler*,
    *Prentice Hall International*, 1988\. A more theoretical point of view, not dealing
    specifically with JavaScript'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《函数式编程导论》*，由*Richard Bird和Philip Wadler*著，*Prentice Hall International*，1988年。这是一个更理论的观点，并不特别针对JavaScript'
- en: '*Pro JavaScript Design Patterns*, by *Ross Harmes and Dustin Díaz*, *Apress*,
    2008'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript设计模式》*，由*Ross Harmes和Dustin Díaz*著，*Apress*，2008年'
- en: '*Secrets of the JavaScript Ninja*, by John Resig and Bear Bibeault, *Manning*
    *Publications*, 2012'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《JavaScript忍者秘籍》*，由*John Resig和Bear Bibeault*著，*Manning Publications*，2012年'
- en: '*TypeScript 4 Design Patterns and Best Practices*, by *Theo Despoudis*, *Packt*
    *Publishing*, 2021'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《TypeScript 4设计模式和最佳实践》*，由*Theo Despoudis*著，*Packt Publishing*，2021年'
- en: 'Also interesting, though with a lesser focus on functional programming, are
    the following:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有趣，尽管对函数式编程的关注较少，以下是一些内容：
- en: '*High-Performance JavaScript*, by *Nicholas Zakas*, *O’Reilly* *Media*, 2010'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高性能JavaScript*，作者 *Nicholas Zakas*，*O’Reilly Media*，2010'
- en: '*JavaScript Patterns*, by *Stoyan Stefanov*, *O’Reilly* *Media*, 2010'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript模式*，作者 *Stoyan Stefanov*，*O’Reilly Media*，2010'
- en: '*JavaScript: The Good Parts*, by *Douglas Crockford*, *O’Reilly* *Media*, 2008'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript：良好的部分*，作者 *Douglas Crockford*，*O’Reilly Media*，2008'
- en: '*JavaScript with Promises*, by *Daniel Parker*, *O’Reilly* *Media*, 2015'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Promises的JavaScript*，作者 *Daniel Parker*，*O’Reilly Media*，2015'
- en: '*Learning JavaScript Design Patterns*, by *Addy Osmani*, *O’Reilly* *Media*,
    2012'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习JavaScript设计模式*，作者 *Addy Osmani*，*O’Reilly Media*，2012'
- en: '*Mastering JavaScript Design Patterns*, *Second Edition*, by *Simon Timms*,
    *Packt* *Publishing*, 2016'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通JavaScript设计模式*，第二版，作者 *Simon Timms*，*Packt Publishing*，2016'
- en: '*Mastering JavaScript High Performance*, by *Chad Adams*, *Packt* *Publishing*,
    2015'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通JavaScript高性能*，作者 *Chad Adams*，*Packt Publishing*，2015'
- en: '*Pro JavaScript Performance*, by *Tom Barker*, *Apress*, 2012'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript性能优化*，作者 *Tom Barker*，*Apress*，2012'
- en: 'These titles are on the subject of reactive functional programming:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标题都是关于响应式函数式编程主题的：
- en: '*Mastering Reactive JavaScript*, by *Erich de Souza Oliveira*, *Packt* *Publishing*,
    2017'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通响应式JavaScript*，作者 *Erich de Souza Oliveira*，*Packt Publishing*，2017'
- en: '*Reactive Programming with Node.js*, by *Fernando Doglio*, *Apress*, 2016'
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Node.js进行响应式编程*，作者 *Fernando Doglio*，*Apress*，2016'
- en: '*Reactive Programming with RxJS*, by *Sergi Mansilla*, *The Pragmatic* *Programmers*,
    2015'
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用RxJS进行响应式编程*，作者 *Sergi Mansilla*，*The Pragmatic Programmers*，2015'
