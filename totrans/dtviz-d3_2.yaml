- en: Chapter 2. A Primer on DOM, SVG, and CSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：DOM、SVG和CSS入门
- en: 'In this chapter, we''ll take a look at the core technologies that make d3.js
    tick: the **Document Object Model** (**DOM**), **Scalable Vector Graphics** (**SVG**),
    and **Cascading Style Sheets** (**CSS**).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使d3.js运行的核心技术：**文档对象模型**（**DOM**）、**可缩放矢量图形**（**SVG**）和**层叠样式表**（**CSS**）。
- en: You're probably used to manipulating DOM and CSS with libraries such as jQuery
    or MooTools, but d3.js has a full suite of manipulation tools as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了使用jQuery或MooTools等库来操作DOM和CSS，但d3.js也提供了一套完整的操作工具。
- en: SVG is at the core of building truly great visualizations, so we'll take special
    care to understand it; everything from manually drawing shapes to transformations
    and path generators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SVG是构建真正优秀可视化图表的核心，因此我们将特别关注理解它；从手动绘制形状到变换和路径生成器的一切。
- en: DOM
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: The Document Object Model is a language-agnostic model for representing structured
    documents built in HTML, XML, or similar standards. You can think of it as a tree
    of nodes that closely resembles the document parsed by the browser.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型（Document Object Model）是一种语言无关的模型，用于表示在HTML、XML或类似标准中构建的结构化文档。你可以将其想象成一个节点树，它与浏览器解析的文档非常相似。
- en: 'At the top, there is an implicit `document` node, which represents the `<html>`
    tag; browsers create this tag even if you don''t specify it and then build the
    tree off this root node according to what your document looks like. If you have
    a simple HTML file as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，有一个隐式的`document`节点，它代表`<html>`标签；即使你没有指定它，浏览器也会创建这个标签，然后根据你的文档外观从这个根节点构建树。如果你有一个简单的HTML文件如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Chrome will parse the preceding code to DOM as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome将解析前面的代码为DOM，如下所示：
- en: '![DOM](img/0007_02_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![DOM](img/0007_02_01.jpg)'
- en: In the latest Chrome builds, I can print and play with this in the **Console**
    tab; you might have to use the **Elements** tab to get the same effect. Moving
    the cursor over each element will show you where exactly it is placed on the page,
    which is very handy for debugging.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的Chrome版本中，我可以在**控制台**标签中打印和操作这些内容；你可能需要使用**元素**标签来获得相同的效果。将光标移到每个元素上，将显示它确切地放置在页面上的位置，这对于调试来说非常方便。
- en: Manipulating the DOM with d3.js
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用d3.js操作DOM
- en: Every node in a DOM tree comes with a slew of methods and properties that you
    can use to change the look of the rendered document.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DOM树中的每个节点都附带了一系列你可以用来改变渲染文档外观的方法和属性。
- en: 'Take for instance the HTML code in our previous example. If we want to change
    the word `italic` to make it underlined as well as bold and italic (the result
    of the `<em>` and `<strong>` tags), we would do it using the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们之前的例子中的HTML代码为例。如果我们想将单词`italic`改为加粗并带有下划线（即`<em>`和`<strong>`标签的结果），我们会使用以下代码来完成：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Wow! What a mouthful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！真是一大堆。
- en: We took the root `document` node and found every node created from a `<strong>`
    tag; then we took the first item in this array and added a `text-decoration` property
    to its `style` property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从根`document`节点开始，找到了所有由`<strong>`标签创建的节点；然后我们取这个数组中的第一个元素，并为其`style`属性添加了一个`text-decoration`属性。
- en: The sheer amount of code it took to do something this simple in a document with
    only eleven nodes is the reason why few people today use the DOM API directly—not
    to mention all the subtle differences between browsers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个只有十一个节点的文档中完成这样简单的事情所需要的大量代码是为什么今天很少有人直接使用DOM API的原因——更不用说浏览器之间所有细微的差异了。
- en: Since we'd like to keep our lives simple and avoid using the DOM directly, we
    need a library. jQuery is a good choice, but to make things even simpler, we can
    use d3.js. It comes with everything we need.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望生活简单，避免直接使用DOM，我们需要一个库。jQuery是一个不错的选择，但为了使事情更加简单，我们可以使用d3.js。它包含了我们所需的一切。
- en: That means we can treat HTML as just another type of data visualization. Let
    that one sink in. HTML is data visualization.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将HTML视为另一种类型的数据可视化。让我们好好消化这一点。HTML就是数据可视化。
- en: In practice, this means we can use similar techniques to present data as a table
    or an interactive image. Most of all, we can use the same data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着我们可以使用类似的技术将数据呈现为表格或交互式图像。最重要的是，我们可以使用相同的数据。
- en: 'Let''s rewrite the previous example in d3.js:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用d3.js重写之前的例子：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Much simpler! We selected the `strong` element and defined a `style` property.
    Job done!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简单多了！我们选择了`strong`元素并定义了一个`style`属性。任务完成！
- en: By the way, any property you set with d3.js can be dynamic, so you can assign
    a function as well as a value. This is going to come in handy later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以使用 d3.js 设置的任何属性都是动态的，所以你可以分配一个函数以及一个值。这将在以后派上用场。
- en: What we just did is called a **selection**. Since selections are the core of
    everything we do with d3.js, let's take a closer look.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才所做的是称为 **选择**。由于选择是我们使用 d3.js 所做的一切的核心，让我们更仔细地看看。
- en: Selections
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: A selection is an array of elements pulled from the current document according
    to a particular CSS selector. Selectors let you apply different functions to the
    whole selection at once so you never have to loop through the elements manually.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选择是一个根据特定 CSS 选择器从当前文档中提取的元素数组。选择器允许你一次性对整个选择集应用不同的函数，这样你就不必手动遍历元素。
- en: Using CSS selectors to decide which elements to work on gives us a simple language
    for defining elements in the document. It's actually the same as you're used to
    from jQuery and CSS itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CSS 选择器来决定要处理的元素，为我们提供了一个定义文档中元素的简单语言。实际上，这与你从 jQuery 和 CSS 本身所熟悉的是一样的。
- en: To get the first element with ID as `graph`, we use `.select('#graph')`; to
    get all the elements with the class `blue`, we write `.selectAll('.blue')`; and
    to get all the paragraphs in a document, we use `.selectAll('p')`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 ID 为 `graph` 的第一个元素，我们使用 `.select('#graph')`；要获取所有具有类 `blue` 的元素，我们写入 `.selectAll('.blue')`；要获取文档中的所有段落，我们使用
    `.selectAll('p')`。
- en: We can combine these to get a more complex matching. Think of it as set operations.
    You can perform an AND operation with `".this.that"`; it will get elements with
    classes `this` and `that`. Alternatively, you might perform an OR operation with
    `".this, .that"` to get elements having either the `this` or `that` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些组合起来以获得更复杂的匹配。想象成集合操作。你可以使用 `".this.that"` 进行 AND 操作；这将获取具有 `this` 和
    `that` 类的元素。或者，你可以使用 `".this, .that"` 进行 OR 操作以获取具有 `this` 或 `that` 类的元素。
- en: But what if you want to select children elements? Nested selections to the rescue.
    You can do it with a simple selector such as `"tbody td"`, or you can chain two
    `selectAll` calls as `.selectAll('tbody').selectAll('td')`. Both will select all
    the cells in a table body. Keep in mind that nested selections maintain the hierarchy
    of selected elements, which gives us some interesting capabilities. Let's look
    at a short example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要选择子元素呢？嵌套选择可以解决这个问题。你可以使用一个简单的选择器，例如 `"tbody td"`，或者你可以链式调用两个 `selectAll`
    调用，如 `.selectAll('tbody').selectAll('td')`。两者都将选择表格体中的所有单元格。请注意，嵌套选择保持所选元素之间的层次结构，这为我们提供了一些有趣的能力。让我们看看一个简短的例子。
- en: Selections example
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择示例
- en: 'Take the base HTML from our play environment in the first chapter and add a
    simple table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一章中的实验环境获取基本 HTML 并添加一个简单的表格：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pretty much the standard markup for a table, `<thead>` and `<tbody>` define
    the head and body of the table where each `<tr>` is a row and each `<td>` is a
    cell. Adding the `table` class tells bootstrap to make the table look pretty for
    us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎是表格的标准标记，`<thead>` 和 `<tbody>` 定义了表格的头部和主体，其中每个 `<tr>` 是一行，每个 `<td>` 是一个单元格。添加
    `table` 类告诉 Bootstrap 为我们使表格看起来更美观。
- en: 'Let''s jump into the console and have some fun with selections:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入控制台，用选择做一些有趣的事情：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The text will promptly turn red. Now let''s make everything in the table head
    bold by chaining two `selectAll` calls:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 文本将立即变为红色。现在让我们通过链式调用两个 `selectAll` 来使表格标题中的所有内容加粗：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Great! Let''s take nested selections a bit further and make table body cells
    green in the second and fourth column:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们进一步探讨嵌套选择，并将表格体的第二列和第四列单元格变为绿色：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The two `selectAll` calls gave us all the instances of `td` in the body, separated
    by rows, giving us an array of three arrays with five elements: `[ Array[5], Array[5],
    Array[5] ]`. Then we used `style` to change the color of every selected element.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `selectAll` 调用为我们提供了体中所有 `td` 的实例，按行分隔，给我们一个包含三个数组的数组，每个数组有五个元素：`[ Array[5],
    Array[5], Array[5] ]`。然后我们使用 `style` 改变所选元素的颜色。
- en: Using a function instead of a static property gave us the fine-grained control
    we needed. The function is called with a data attribute (we'll discuss more on
    that later) and an index of the column it's in, that is, the `i` variable. Since
    we're using nested selections, a third parameter would give us the row. Then we
    simply return either `'green'` or `'red'` based on the current index.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数而不是静态属性给了我们所需的精细控制。该函数使用数据属性（我们稍后会讨论更多）和列的索引调用，即 `i` 变量。由于我们使用嵌套选择，第三个参数将给我们行。然后我们简单地根据当前索引返回
    `'green'` 或 `'red'`。
- en: One thing to keep in mind is that chaining selections can be more efficient
    than OR selectors when it comes to very large documents. This is because each
    subsequent selection only searches through the elements matched previously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，当涉及到非常大的文档时，链式调用选择可能比使用OR选择器更高效。这是因为每个后续选择只搜索之前匹配的元素。
- en: Manipulating content
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作内容
- en: We can do far more than just playing around with selections and changing the
    properties of the elements. We can manipulate things.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的不仅仅是围绕选择和更改元素属性打转。我们可以操纵事物。
- en: With d3.js, we can change the contents of an element, add new elements, or remove
    elements we don't want.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用d3.js，我们可以更改元素的内容，添加新元素，或删除我们不需要的元素。
- en: 'Let''s add a new column to the table from our previous example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给之前示例中的表格添加一个新列：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We selected all the table rows and then appended a new cell to each using `.append()`.
    All d3.js actions return the current selection—new cells in this case—so we can
    chain actions or assign the new selection to a variable (`newCol`) for later use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了所有的表格行，然后使用 `.append()` 为每一行添加了一个新单元格。所有d3.js操作都会返回当前选择——在这个例子中是新单元格——因此我们可以链式调用操作或将新选择赋值给变量（`newCol`）以供以后使用。
- en: 'We have an empty invisible column on our hands. Let''s add some text to spruce
    things up:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手里有一个空的无形列。让我们添加一些文本来让它看起来更美观：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At least now that it''s full of instances of `a`, we can say a column is present.
    But that''s kind of pointless, so let''s follow the pattern set by other columns:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 至少现在它充满了 `a` 实例，我们可以说列是存在的。但这有点没有意义，所以让我们遵循其他列设定的模式：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The trick of dynamically defining the content via a function helps us pick the
    right string from a list of values depending on the column we're in, which we
    identify by the index `i`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数动态定义内容的技巧帮助我们根据我们所在的列从值列表中选择正确的字符串，我们通过索引 `i` 来识别列。
- en: Figured out the pattern yet? Read the top row of the table body.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经找到了这个模式了吗？阅读表体的顶部行。
- en: 'Similarly, we can remove elements using `.remove()`. To get rid of the last
    row in the table, you''d write something as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `.remove()` 来删除元素。要删除表格中的最后一行，你会写如下内容：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You have to use `[0][3]` instead of just `[3]` because selections are arrays
    of arrays.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用 `[0][3]` 而不是 `[3]`，因为选择是数组的数组。
- en: Joining data to selections
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据连接到选择
- en: We've made it to the fun part of our DOM shenanigans. Remember when I said HTML
    is data visualization? Joining data to selections is how that happens.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了我们DOM恶作剧的有趣部分。记得我曾经说过HTML是数据可视化吗？将数据连接到选择就是如何实现这一点的。
- en: To join data with a selection, we use the `.data()` function. It takes a data
    argument in the form of a function or an array, and optionally a function telling
    d3.js how to differentiate between various parts of the data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据与选择连接起来，我们使用 `.data()` 函数。它接受一个数据参数，形式为一个函数或一个数组，并且可选地提供一个函数告诉d3.js如何区分数据的不同部分。
- en: 'When you join data to a selection, one of the following three things will happen:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将数据连接到选择时，以下三种情况之一将会发生：
- en: There is more data than was already joined (the length of the data is longer
    than the length of a selection). You can reference the new entries with the `.enter()`
    function.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已连接的数据比之前更多（数据的长度超过了选择的长度）。你可以使用 `.enter()` 函数来引用新的条目。
- en: There is exactly the same amount of data as before. You can use the selection
    returned by `.data()` itself to update element states.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据量与之前完全相同。你可以使用 `.data()` 返回的选择来更新元素状态。
- en: There is less data than before. You can reference these using the `.exit()`
    function.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据量比之前少。你可以使用 `.exit()` 函数来引用这些数据。
- en: You can't chain `.enter()` and `.exit()` because they are just references and
    don't create a new selection. This means you will usually want to focus on `.enter()`
    and `.exit()` and handle the three cases separately. Mind you, all three can happen
    at once.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能链式调用 `.enter()` 和 `.exit()`，因为它们只是引用，并不会创建一个新的选择。这意味着你通常想要专注于 `.enter()`
    和 `.exit()`，并分别处理三种情况。请注意，这三种情况可能同时发生。
- en: You must be wondering, "But how's it possible for there to be both more and
    less data than before?" That's because selection elements are bound to instances
    of datum, not their number. If you shifted an array and then pushed a new value,
    the previous first item would go to the `.exit()` reference and the new addition
    would go to the `.enter()` reference.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，“但为什么数据比之前多或少了？”这是因为选择元素绑定到数据实例，而不是它们的数量。如果您移动了一个数组并添加了一个新值，那么前面的第一个项目将进入`.exit()`引用，而新的添加将进入`.enter()`引用。
- en: Let's build something cool with data joins and HTML.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用数据连接和HTML构建一些有趣的东西。
- en: An HTML visualization example
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HTML可视化示例
- en: We'll start off with the same HTML file as usual. I'd suggest coding in the
    `code.js` file from now on because things can get pretty involved. Refresh frequently
    to keep an eye on what's going on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用与往常一样的HTML文件。我建议从现在开始编码`code.js`文件，因为事情可能会变得相当复杂。经常刷新以保持对正在发生的事情的关注。
- en: Every great visualization needs a dataset; we'll be using the list of all Dr.
    Who monsters and villains since 1963\. It's been published by the *Guardian Datablog*
    in late December, 2012\. You can get the CSV file from [https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv](https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个伟大的可视化都需要一个数据集；我们将使用自1963年以来所有《神秘博士》怪物和坏蛋的列表。它是由《卫报数据博客》在2012年12月底发布的。您可以从[https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv](https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv)获取CSV文件。
- en: We are going to make a table. Not very exciting for sure, but very practical
    for HTML visualizations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个表格。当然，这并不令人兴奋，但对于HTML可视化来说非常实用。
- en: We begin with a global data variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个全局数据变量开始。
- en: 'Add the following line at the top of your `code.js` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`code.js`文件顶部添加以下行：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we append an empty table to our `graph` div using the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下代码将一个空表附加到我们的`graph` div中：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can imagine from previous examples, this code selects the target `<div>`
    tag with ID as `graph` and appends a `table` element with a `class='table'` attribute
    so that Bootstrap will make it attractive.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的示例中可以想象到的，这段代码通过ID选择目标`<div>`标签`graph`，并附加一个具有`class='table'`属性的`table`元素，这样Bootstrap就会使其看起来很吸引人。
- en: The next two lines append empty `thead` and `tbody` elements and assign them
    to variables for later use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行将空的`thead`和`tbody`元素附加到变量中，以供以后使用。
- en: 'Now we''re going to load our data and assign it to the `Data` variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将加载数据并将其分配给`Data`变量：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll be messing with the dataset later, so it's handy to have a function that
    we can call when we want to reload the data without having to refresh the page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会修改数据集，所以有一个函数在需要重新加载数据而不需要刷新页面时可以调用是很方便的。
- en: 'Because our dataset is in CSV format, we use the `csv` function of d3.js to
    load and parse it. d3.js is smart enough to understand that the first row in our
    dataset is not data but a set of labels, so it populates the `data` variable with
    an array of dictionaries as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据集是CSV格式，我们使用d3.js的`csv`函数来加载和解析它。d3.js足够聪明，能够理解我们的数据集中的第一行不是数据，而是一组标签，因此它以以下方式将字典数组填充到`data`变量中：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you run the code right now, Chrome will complain that the `redraw()` function
    doesn''t exist. Let''s write one as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行代码，Chrome会抱怨`redraw()`函数不存在。让我们按照以下方式编写一个：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We defined a `redraw` variable and assigned an empty function to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`redraw`变量，并将其分配给一个空函数。
- en: 'Our next step is to make this function do something. Let''s go into its body
    (between the two curly braces) and add some code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是让这个函数做些事情。让我们进入它的主体（在两个大括号之间）并添加一些代码：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code is divided into three parts. The first part selects all the table rows
    (of which none exist yet) and joins our `Data` using the `.data()` function. The
    resulting selection is saved in the `tr` variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为三个部分。第一部分选择所有表格行（目前还没有）并使用`.data()`函数将我们的`Data`连接起来。结果选择被保存在`tr`变量中。
- en: Next we create a table row for every new datum in the dataset using the `.enter()`
    reference. Right now, that's for all of them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用`.enter()`引用为数据集中的每个新数据创建一个表格行。现在，这是针对所有数据。
- en: The last part of this code doesn't do anything yet but will remove any `<tr>`
    element in the `.exit()` reference once we change the data later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分目前还没有做任何事情，但一旦我们稍后更改数据，它将删除`.exit()`引用中的任何`<tr>`元素。
- en: After execution, the `tr` variable will hold an array of `<tr>` elements, each
    bound to its respective place in the dataset. The first `<tr>` element holds the
    first datum, the second holds the second datum, and so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，`tr`变量将包含一个`<tr>`元素的数组，每个元素都绑定到数据集中的相应位置。第一个`<tr>`元素包含第一个数据，第二个包含第二个数据，依此类推。
- en: 'Rows are useless without cells. Let''s add some by relying on the fact that
    data stays joined to elements even after a new selection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单元格的行是没有用的。让我们通过依赖于数据在新的选择之后仍然与元素相连的事实来添加一些单元格：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We selected all the `<td>` children of each row (none exist yet). We then had
    to call the `.data()` function with the same data transformed into a list of values
    using `d3.values()`. This gave us a new chance to use `.enter()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了每一行的所有`<td>`子元素（目前还没有）。然后我们必须使用`d3.values()`将相同的数据转换成一个值列表，并调用`.data()`函数。这给了我们一个使用`.enter()`的新机会。
- en: From then on it's more of the same. Each new entry gets its own table cell,
    and the text is set to the current datum.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，情况就更加相似。每个新的条目都会得到自己的表格单元格，文本设置为当前数据。
- en: Running this code will give you an utterly confusing table specifying all the
    Dr. Who monsters and villains televised since 1963.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将给你一个完全令人困惑的表格，列出了自1963年以来在电视上出现的所有《博士》怪物和反派。
- en: Let's make it clearer. You can write this code at the bottom of the `redraw()`
    function or right in Chrome's JavaScript console if you want to see some live
    updating magic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让它更清晰。如果你想看到一些实时更新的魔法，你可以在`redraw()`函数的底部编写这段代码，或者直接在Chrome的JavaScript控制台中编写。
- en: 'To sort the table by the villain''s first appearance, we write the following
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要按反派首次出现对表格进行排序，我们编写以下代码：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Without doing anything else, this code will redraw the table with the new ordering—no
    refreshing the page, no manually adding or removing elements. Because all our
    data is joined to the HTML, we didn't even need a reference to the original `tr`
    selection or the data. Pretty nifty if you ask me.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何其他事情，这段代码将重新绘制表格并按新的顺序排列——无需刷新页面，无需手动添加或删除元素。因为所有我们的数据都与HTML相连，所以我们甚至不需要引用原始的`tr`选择或数据。如果你问我，这非常巧妙。
- en: 'The `.sort()` function takes only a comparator function. The comparator is
    given two pieces of data and must decide how to order them: `-1` for being less
    than `b`, `0` for being equal, and `1` for being more than `b`. You can also use
    `d3.ascending` and `d3.descending` comparators of d3.js.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sort()`函数只接受一个比较函数。比较函数会给出两份数据，并必须决定如何排序：`-1`表示小于`b`，`0`表示等于，`1`表示大于`b`。你还可以使用d3.js的`d3.ascending`和`d3.descending`比较器。'
- en: 'That''s still pretty unclear though. Let''s limit our table only to the latest
    Doctor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仍然不太清楚，但让我们只限制我们的表格到最新的博士：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We filtered the dataset so that it only contains rows where the actor is Matt
    Smith, and then we called the `redraw()` function. The `.exit()` selection does
    its job and a few hundred rows are removed from the table. Wait… we ended up with
    a mishmash of actors. Took me a while to figure out what's going on.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤了数据集，使其只包含演员是马特·史密斯（Matt Smith）的行，然后调用了`redraw()`函数。`.exit()`选择完成了它的任务，并从表格中删除了几百行。等等……我们最终得到了一个演员的大杂烩。花了我一段时间才弄清楚发生了什么。
- en: JavaScript is a language with instance-based identity, which means that d3.js
    can't use `a == b` to decide whether two complex objects are the same. Instead,
    it relies on indexes to identify objects. So when we filtered our data, the first
    *x* number of indexes had something in them and were considered unchanged, and
    the rest were removed. The data already attached to elements doesn't get updated,
    and we have a bad table on our hands. We can get out of this in two ways.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种基于实例的标识语言，这意味着d3.js不能使用`a == b`来判断两个复杂对象是否相同。相反，它依赖于索引来识别对象。所以当我们过滤数据时，前*x*个索引中有内容，被认为是未更改的，其余的则被删除。已经附加到元素上的数据不会更新，我们手上就有一个糟糕的表格。我们可以通过两种方式摆脱这种情况。
- en: 'We could first sort the table and then filter the data as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先对表格进行排序，然后按如下方式过滤数据：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As before, we used a comparator to sort; we used a numerical comparison between
    `a['Doc. no.']` and `b['Doc. no.']` to sort the rows in descending order with
    the highest number on top.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们使用比较器进行排序；我们使用`a['Doc. no.']`和`b['Doc. no.']`之间的数值比较来按降序排序行，最高的数字在最上面。
- en: 'Running the same code as before will give the desired result:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行与之前相同的代码将得到期望的结果：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This worked because Matt Smith was in the first *x* places of the dataset. But
    the approach only works for this example. We can use a more robust approach, but
    it doesn't happen automatically when we change the data. Remember to refresh the
    page or run `reload()` to get the whole dataset back.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为Matt Smith在数据集的前几个位置。但这种方法只适用于这个例子。我们可以使用更健壮的方法，但这不会在更改数据时自动发生。请记住刷新页面或运行`reload()`以获取整个数据集。
- en: 'Now we can filter the table directly as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接过滤表格，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `.filter()` function takes a single selector as its argument and feeds the
    current datum to it. When the function returns `false`, the element is removed
    from the selection; when it returns `true`, the element remains. In the end, we
    use the `.remove()` function to remove every row we caught. Much more robust,
    but playing with the data itself is often more elegant. Choose wisely.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter()`函数接受一个选择器作为其参数，并将当前数据传递给它。当函数返回`false`时，元素将从选择中移除；当它返回`true`时，元素将保留。最后，我们使用`.remove()`函数移除我们捕获的所有行。这更加健壮，但直接操作数据本身通常更加优雅。请明智地选择。'
- en: SVG
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SVG
- en: Scalable Vector Graphics is a vector graphics format that describes images with
    XML. It's been around since 1999 and is supported by all major browsers these
    days. Unfortunately, Internet Explorer has been a laggard and provides only limited
    support since Version 9\. Vector images can be rendered in any size without becoming
    fuzzy. This means you can render the same image on a large retina display or a
    small mobile phone, and it will look great in both cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可缩放矢量图形（Scalable Vector Graphics）是一种使用XML描述图像的矢量图形格式。它自1999年以来一直存在，并且现在所有主流浏览器都支持它。不幸的是，Internet
    Explorer一直落后，从版本9开始只提供了有限的支持。矢量图像可以以任何大小渲染而不会变得模糊。这意味着你可以在大型的视网膜显示屏或小型的手机上渲染相同的图像，两种情况下都会看起来很棒。
- en: SVG images are made up of shapes you can create from scratch using paths, or
    put together from basic shapes defined in the standard, for example, a line or
    a circle. The format itself represents shapes with XML elements and some attributes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SVG图像是由形状组成的，你可以使用路径从头开始创建这些形状，或者从标准中定义的基本形状组合而成，例如一条线或一个圆。该格式本身使用XML元素和一些属性来表示形状。
- en: As such, SVG code is just a bunch of text you can edit manually, inspect with
    your browser's normal debugging tools, and compress with standard text compression
    algorithms. Being text based also means you can use d3.js to create an image in
    your browser, then copy and paste the resulting XML to a `.svg` file, and open
    it with any SVG viewer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SVG代码只是一堆你可以手动编辑、使用浏览器正常的调试工具检查，以及使用标准文本压缩算法压缩的文本。基于文本也意味着你可以使用d3.js在你的浏览器中创建一个图像，然后将生成的XML复制并粘贴到`.svg`文件中，并用任何SVG查看器打开它。
- en: Another consequence is that browsers can consider SVG to be a normal part of
    the document. You can use CSS for styling, listening for mouse events on specific
    shapes, and even scripting the image to make animations where images are interactive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个后果是，浏览器可以将SVG视为文档的正常部分。你可以使用CSS进行样式设计，监听特定形状上的鼠标事件，甚至可以编写脚本使图像具有交互性。
- en: Drawing with SVG
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SVG绘制
- en: To draw with d3.js, you can add shapes manually by defining the appropriate
    SVG elements, or you can use helper functions that help you create advanced shapes
    easily.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用d3.js绘制图形时，你可以通过定义适当的SVG元素手动添加形状，或者你可以使用辅助函数来帮助你轻松创建高级形状。
- en: Now we're going to go through the very core of what d3.js does. Everything else
    builds from this, so pay attention.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨d3.js的核心功能。所有其他功能都是基于这个核心构建的，所以请务必注意。
- en: 'Let''s start by preparing a drawing area in our usual environment. Put this
    code at the top of a fresh `code.js` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的常规环境中准备一个绘图区域开始。将以下代码放在一个新的`code.js`文件顶部：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We appended an `<svg>` element to the main `<div>` tag and adjusted its size.
    From now on, we'll be using the `svg` variable for drawing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`<svg>`元素附加到主`<div>`标签上，并调整了其大小。从现在开始，我们将使用`svg`变量进行绘图。
- en: Manually adding elements and shapes
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动添加元素和形状
- en: 'An SVG image is a collection of elements rendered as shapes and comes with
    a set of seven basic elements. All but one of these are just an easier way to
    define a path:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SVG图像是由形状组成的元素集合，它包含一组七个基本元素。除了一个之外，这些元素只是定义路径的一种更简单的方式：
- en: Text (the only one that isn't a path)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本（唯一一个不是路径的）
- en: Straight lines
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直线
- en: Rectangles
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Circles
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: Ellipses
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆
- en: Polylines (a set of straight lines)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多段线（一组直线）
- en: Polygons (a set of straight lines, closing in on itself)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形（一组直线，闭合于自身）
- en: You build SVG images by adding these elements to the canvas and defining some
    attributes. All of them can have a `stroke` style defining how the edge is rendered,
    a `fill` style defining how the shape is filled, and all of them can be rotated,
    skewed, or moved using the `transform` attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将这些元素添加到画布中并定义一些属性来构建 SVG 图像。所有这些元素都可以有一个 `stroke` 样式来定义边缘的渲染方式，一个 `fill`
    样式来定义形状的填充方式，并且所有这些都可以使用 `transform` 属性进行旋转、倾斜或移动。
- en: Text
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本
- en: 'Text is the only element that is neither a shape nor does it translate to a
    path in the background like the others. Let''s look at it first so the rest of
    this chapter can be about shapes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是唯一一个既不是形状也不像其他元素那样在背景中转换为路径的元素。让我们先看看它，这样本章的其余部分就可以关于形状了：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We took our `svg` element and appended a `text` element. Then we defined its
    actual text and added some attributes to position the text at the `(x, y)` point
    and anchored the text at start.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取了我们的 `svg` 元素并添加了一个 `text` 元素。然后我们定义了其实际文本，并添加了一些属性来定位文本在 `(x, y)` 点，并将文本锚定在开始位置。
- en: The `text-anchor` attribute defines the horizontal positioning of rendered text
    in relation to the anchor point defined by `(x, y)`. The positions it understands
    are the start, the middle, and the end.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`text-anchor` 属性定义了渲染文本相对于由 `(x, y)` 定义的锚点的水平位置。它理解的位置是开始、中间和结束。'
- en: We can also fine tune the text's position with an offset defined by the `dx`
    and `dy` attributes. This is especially handy when adjusting the text margin and
    baseline relative to the font size because it understands the `em` unit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `dx` 和 `dy` 属性定义的偏移量来微调文本的位置。这在调整文本边距和基线相对于字体大小时特别有用，因为它理解 `em` 单位。
- en: 'Our image looks as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形象如下所示：
- en: '![Text](img/0007_02_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![文本](img/0007_02_02.jpg)'
- en: Shapes
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 形状
- en: Now that text is out of the way, let's look at something useful—shapes, the
    heart of the rest of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文本已经处理完毕，让我们看看一些有用的东西——形状，这是本书其余部分的核心。
- en: 'We begin by drawing a straight line using the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用以下代码绘制一条直线：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As before, we took the `svg` element, appended a line, and defined some attributes.
    A line is drawn between two points: `(x1, y1)` and `(x2, y2)`. To make the line
    visible, we have to define the stroke color and `stroke-width` attributes as well.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们取了 `svg` 元素，添加了一条线，并定义了一些属性。一条线在两个点之间绘制：`(x1, y1)` 和 `(x2, y2)`。为了使线条可见，我们必须定义线条颜色和
    `stroke-width` 属性。
- en: '![Shapes](img/0007_02_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_03.jpg)'
- en: Our line points downwards even though `y2` is bigger than `y1`. Hmm… that's
    because the origin in most image formats lies in the top-left corner. This means
    `(x=0, y=0)` defines the top-left corner of the image.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`y2`大于`y1`，我们的线点却向下。嗯……这是因为大多数图像格式的原点位于左上角。这意味着 `(x=0, y=0)` 定义了图像的左上角。
- en: 'To draw a rectangle, we can use the `rect` element:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个矩形，我们可以使用 `rect` 元素：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We appended a `rect` element to the `svg` element and defined some attributes.
    A rectangle is defined by its upper-left corner (`x`, `y`), `width`, and `height`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个 `rect` 元素添加到 `svg` 元素中，并定义了一些属性。一个矩形由其左上角 (`x`，`y`)、`width` 和 `height`
    定义。
- en: 'Our image now looks as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形象现在如下所示：
- en: '![Shapes](img/0007_02_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_04.jpg)'
- en: 'We have an unwieldy black rectangle. We can make it prettier by defining three
    more properties as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个难以驾驭的黑色矩形。我们可以通过定义以下三个更多属性来让它更漂亮：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Shapes](img/0007_02_05.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_05.jpg)'
- en: 'This is much better. Our rectangle has a thin, green outline. Rounded corners
    come from the `rx` and `ry` attributes, which define the corner radius along the
    x and y axis:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了。我们的矩形有一个细的、绿色的轮廓。圆角来自 `rx` 和 `ry` 属性，它们定义了沿 x 和 y 轴的角落半径：
- en: 'Let''s try adding a circle:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试添加一个圆：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A circle is defined by a central point `(cx, cy)` and a radius `r`. In this
    instance, we get a `green` circle with a `steelblue` outline in the middle of
    our rectangle. The `fill-opacity` attribute tells the circle to be slightly transparent
    so it doesn''t look too strong against the light rectangle:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个圆由一个中心点 `(cx, cy)` 和一个半径 `r` 定义。在这个例子中，我们在矩形的中间得到了一个 `green` 圆圈，有一个 `steelblue`
    轮廓。`fill-opacity` 属性告诉圆圈稍微透明，这样它就不会在浅色矩形上显得太强烈：
- en: '![Shapes](img/0007_02_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_06.jpg)'
- en: 'Mathematically speaking, a circle is just a special form of ellipse. By adding
    another radius and changing the element, we can draw one of these:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，一个圆只是一个特殊的椭圆形式。通过添加另一个半径并更改元素，我们可以绘制以下形状之一：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We added an `ellipse` element and defined some well-known attributes. The ellipse
    shape needs a central point `(cx, cy)` and two radii, `rx` and `ry`. Setting a
    low `fill-opacity` attribute makes the circle visible under the ellipse:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `ellipse` 元素并定义了一些已知的属性。椭圆形状需要一个中心点 `(cx, cy)` 和两个半径，`rx` 和 `ry`。设置一个低的
    `fill-opacity` 属性使得圆形在椭圆下可见：
- en: '![Shapes](img/0007_02_07.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_07.jpg)'
- en: 'That''s nice, but we can make it more interesting using the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这不错，但我们可以用以下代码让它更有趣：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The only trick here is that `rx` is smaller than `ry`, creating a vertical ellipse.
    Lovely!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一技巧是 `rx` 小于 `ry`，创建了一个垂直的椭圆。太棒了！
- en: '![Shapes](img/0007_02_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![形状](img/0007_02_08.jpg)'
- en: A strange green eye with a random blue line is staring at you, all thanks to
    manually adding basic SVG elements to the canvas and defining some attributes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个奇怪的绿色眼睛和一条随机的蓝色线条在盯着你，这一切都归功于手动将基本 SVG 元素添加到画布上并定义了一些属性。
- en: 'The generated SVG looks in XML form as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SVG 以 XML 形式如下所示：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Yeah, I wouldn't want to write that by hand either.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我也不想手动写那个。
- en: But you can see all the elements and attributes we added before. Being able
    to look at an image file and understand what's going on might come in handy some
    day. It's certainly cool. Usually when you open an image in a text editor, all
    you get is binary gobbledygook.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以看到我们之前添加的所有元素和属性。能够查看图像文件并理解其中发生的事情可能在某一天很有用。这确实很酷。通常当你用文本编辑器打开图像时，你得到的就是二进制的乱码。
- en: Now, I know I mentioned earlier that polylines and polygons are also basic SVG
    elements. The only reason I'm leaving off the explanation of these basic elements
    is because with d3.js, we have some great tools to work with them. Trust me, you
    don't want to do them manually.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道我之前提到过多边形和多边形也是基本的 SVG 元素。我之所以省略这些基本元素的解释，是因为在使用 d3.js 时，我们有很好的工具来处理它们。相信我，你不想手动做这些。
- en: Transformations
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换
- en: Before jumping onto more complicated things, we have to look at transformations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究更复杂的事情之前，我们必须看看变换。
- en: Without going into too much mathematical detail, it suffices to say that transformations,
    as used in SVG, are affine transformations of coordinate systems used by shapes
    in our drawing. The beautiful thing is they can be defined as matrix multiplications,
    making them very efficient to compute.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入数学细节，只需说，SVG 中使用的变换是我们绘图形状所使用的坐标系中的仿射变换。美妙的是，它们可以定义为矩阵乘法，这使得它们在计算上非常高效。
- en: But, unless your brain is made out of linear algebra, using transformations
    as matrices can get very tricky. SVG helps out by coming with a set of predefined
    transformations, namely, `translate()`, `scale()`, `rotate()`, `skewX()`, and
    `skewY()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除非你的大脑是由线性代数构成的，否则使用矩阵作为变换可能会变得非常复杂。SVG 通过提供一系列预定义的变换来帮助，即 `translate()`、`scale()`、`rotate()`、`skewX()`
    和 `skewY()`。
- en: According to Wikipedia, an affine transformation is any transformation that
    preserves points, straight lines, and planes, while keeping sets of parallel lines
    parallel. They don't necessarily preserve distances but do preserve ratios of
    distances between points on a straight line. This means if you take a rectangle,
    you can use affine transformations to rotate it, make it bigger, and even turn
    it into a parallelogram; however, no matter what you do, it will never become
    a trapezoid.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，仿射变换是任何保持点、直线和平面，同时保持平行线集合平行的变换。它们不一定保持距离，但确实保持直线上的点之间距离的比率。这意味着如果你取一个矩形，你可以使用仿射变换来旋转它，放大它，甚至将其变成平行四边形；然而，无论你做什么，它永远不会变成梯形。
- en: Computers handle transformations as matrix multiplication because any sequence
    of transformations can be collapsed into a single matrix. This means they only
    have to apply a single transformation that encompasses your sequence of transformations
    when drawing the shape, which is handy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机将变换处理为矩阵乘法，因为任何变换序列都可以折叠成一个单一的矩阵。这意味着它们在绘制形状时只需要应用一个包含你的变换序列的单个变换，这很方便。
- en: We will apply transformations with the `transform` attribute. We can define
    multiple transformations that are applied in order. The order of operations can
    change the result. You'll notice this in the following examples.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `transform` 属性应用变换。我们可以定义多个按顺序应用的变换。操作顺序可以改变结果。你将在以下示例中注意到这一点。
- en: 'Let''s move our eye to the edge of the rectangle:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把目光移到矩形的边缘：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We selected everything our eye is made of (two ellipses and a circle), and then
    applied the `translate` transformation. It moved the shape's origin along the
    `(150, 0)` vector, moving the shape 150 pixels to the right and 0 pixels down.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了眼睛所构成的一切（两个椭圆和一个圆），然后应用了 `translate` 变换。它将形状的起点沿着 `(150, 0)` 向量移动，将形状向右移动150像素，向下移动0像素。
- en: If you try moving it again, you'll notice new transformations are applied according
    to the original state of our shape. That's because there can only be one `transform`
    attribute per shape.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次尝试移动它，你会注意到新的变换是按照我们形状的原始状态应用的。这是因为每个形状只能有一个 `transform` 属性。
- en: 'Our picture looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图片看起来如下：
- en: '![Transformations](img/0007_02_08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_08.jpg)'
- en: 'Let''s rotate the eye by 45 degrees:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们旋转眼睛45度：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Transformations](img/0007_02_10.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_10.jpg)'
- en: That's not what we wanted at all.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这根本就不是我们想要的。
- en: 'What tricked us is that rotations happen around the origin of the image, not
    the shape. We have to define the rotation axis ourselves:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 欺骗我们的地方在于旋转是围绕图像的起点进行的，而不是形状。我们必须自己定义旋转轴：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By adding two more arguments to `rotate()`, we defined the rotation axis and
    achieved the desired result:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 `rotate()` 函数添加两个额外的参数，我们定义了旋转轴并达到了预期的效果：
- en: '![Transformations](img/0007_02_11.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_11.jpg)'
- en: 'Let''s make the eye a little bigger with the `scale()` transformation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `scale()` 变换使眼睛稍微大一点：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will make our object `1.2` times bigger along both the axes; two arguments
    would have scaled by different factors along the x and y axes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的对象在两个轴向上都扩大到 `1.2` 倍；两个参数会以不同的因子沿x轴和y轴缩放：
- en: '![Transformations](img/0007_02_12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_12.jpg)'
- en: Once again, we pushed the position of the eye because scaling is anchored at
    the zeroth point of the whole image. We have to use another `translate` to move
    it back. But the coordinate system we're working on is now rotated by 45 degrees
    and scaled. This makes things tricky. We need to translate between the two coordinate
    systems to move the eye correctly. To move the eye 70 pixels to the left, we have
    to move it along each axis by *70*sqrt(2)/2* pixels, which is the result of cosine
    and sine at an angle of 45.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们调整了眼睛的位置，因为缩放是以整个图像的零点为基准的。我们必须使用另一个 `translate` 来将其移回。但现在我们正在工作的坐标系已经旋转了45度并进行了缩放。这使得事情变得复杂。我们需要在这两个坐标系之间进行转换，才能正确地移动眼睛。为了将眼睛向左移动70像素，我们必须沿着每个轴移动
    *70*sqrt(2)/2* 像素，这是45度角的余弦和正弦的结果。
- en: 'But that''s just messy. The number looks funny, and we worked way too much
    for something so simple. Let''s change the order of operations instead:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是混乱。数字看起来很奇怪，我们为了这么简单的事情做了太多的工作。让我们改变操作顺序：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Much better! We get exactly what we wanted:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！我们得到了我们想要的确切效果：
- en: '![Transformations](img/0007_02_13.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_13.jpg)'
- en: A lot has changed, let's take a look.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了很大的变化，让我们看看。
- en: First we translate to our familiar position and then scale by `1.2`, pushing
    the eye out of position. We fix this by translating back to the left by `70` pixels
    and then finally performing the `45` degree rotation, making sure to divide the
    pivot point by `1.2`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将它转换到我们熟悉的位置，然后通过 `1.2` 缩放，将眼睛推离位置。我们通过向左移动 `70` 像素来修复这个问题，然后最终执行 `45`
    度旋转，确保将旋转中心点除以 `1.2`。
- en: 'There''s one more thing we can do to the poor eye; skew it. Two skew transformations
    exist: `skewX` and `skewY`. Both skew along their respective axis:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对这只可怜的眼睛做一件事；让它倾斜。存在两种倾斜变换：`skewX` 和 `skewY`。两者都沿着各自的轴倾斜：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We just bolted `skewY(20)` on to the end of the `transform` attribute.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将 `skewY(20)` 添加到 `transform` 属性的末尾。
- en: '![Transformations](img/0007_02_14.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![变换](img/0007_02_14.jpg)'
- en: We have once more destroyed our careful centering. Fixing this is left as an
    exercise for the reader (I've always wanted to say that).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又一次破坏了我们精心对齐的中心。修复这个问题留给读者作为练习（我一直想这么说）。
- en: All said, transformations really are just matrix multiplication. In fact, you
    can define any transformation you want with the `matrix()` function. I suggest
    taking a look at exactly what kind of matrix produces each of the preceding effects.
    The W3C specification available at [http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace](http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace)
    can help.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，变换实际上只是矩阵乘法。实际上，你可以使用 `matrix()` 函数定义你想要的任何变换。我建议查看确切哪种矩阵会产生前面提到的效果。W3C规范可在[http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace](http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace)找到。
- en: Using paths
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用路径
- en: Path elements define outlines of shapes that can be filled, stroked, and so
    on. They are generalizations of all other shapes and can be used to draw nearly
    anything.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 路径元素定义了可以填充、描边等形状的轮廓。它们是所有其他形状的泛化，可以用来绘制几乎任何东西。
- en: 'Most of the path''s magic stems from the `d` attribute; it uses a mini language
    of three basic commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数路径的魔法都源于 `d` 属性；它使用三种基本命令的迷你语言：
- en: '`M`, meaning moveto'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`，表示移动到'
- en: '`L`, meaning lineto'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L`，表示线到'
- en: '`Z`, meaning closepath'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Z`，表示闭合路径'
- en: 'To create a rectangle, we might write something as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个矩形，我们可能会写如下内容：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We appended a new element to our `svg` and then defined some attributes. The
    interesting bit is the `d` attribute, `M 100 100 L 300 100 L 200 300 z`. Breaking
    this down, you can see we first moved to (`100`, `100`), drew a line on (`300`,
    `100`), another line on (`200`, `300`), and then closed the path.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的 `svg` 添加了一个新元素，并定义了一些属性。有趣的部分是 `d` 属性，`M 100 100 L 300 100 L 200 300
    z`。分解来看，我们首先移动到 (`100`, `100`)，在 (`300`, `100`) 上画了一条线，然后在 (`200`, `300`) 上又画了一条线，最后闭合路径。
- en: '![Using paths](img/0007_02_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![使用路径](img/0007_02_15.jpg)'
- en: The power of paths doesn't stop there, though. Commands beyond the `M`, `L`,
    `Z` combination give us tools to create curves and arcs. But creating complex
    shapes by hand is beyond tediousness.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的力量并不仅限于此。`M`、`L`、`Z` 组合之外的命令给我们提供了创建曲线和圆弧的工具。但手动创建复杂形状已经超出了繁琐。
- en: d3.js comes with some helpful path generator functions that take JavaScript
    and turn it into path definitions. We'll be looking at those next.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js 附带一些有用的路径生成器函数，它们可以将 JavaScript 转换为路径定义。我们将在下一章中查看这些函数。
- en: Our image is getting pretty crowded, so let's restart the environment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形象变得越来越拥挤，所以让我们重新启动环境。
- en: 'To start things off, we''ll draw the humble sine function. Once again, we begin
    by preparing the drawing area:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将绘制一个谦逊的正弦函数。再一次，我们首先准备绘图区域：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We appended an `svg` element to our `#graph` div and set a large enough `width`
    and `height` for our evil plans. Then, we appended a `g` element to put our chart
    in. The `g` element is a logical grouping of SVG shapes, improving the semantics
    of our document and making it easier to use.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的 `#graph` div 添加了一个 `svg` 元素，并设置了足够大的 `width` 和 `height` 以满足我们的邪恶计划。然后，我们添加了一个
    `g` 元素来放置我们的图表。`g` 元素是 SVG 形状的逻辑分组，提高了我们文档的语义性，并使其更容易使用。
- en: Next, we need some data, which is the `sine` function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些数据，即正弦函数。
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using `d3.range(0,10)` gives us a list of integers from zero to nine. We map
    over them and turn each into a tuple, actually a 2-length array representing the
    maxima, minima, and zeroes of the curve. You might remember from your math class
    that sine starts at (0,0), then goes to (Pi/2, 1), (Pi, 0), (3Pi/2, -1), and so
    on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `d3.range(0,10)` 会给我们一个从零到九的整数列表。我们遍历它们，并将每个转换为元组，实际上是一个表示曲线的最大值、最小值和零点的2长度数组。你可能还记得从你的数学课上学到的，正弦函数从
    (0,0) 开始，然后到 (π/2, 1)，(π, 0)，(3π/2, -1)，以此类推。
- en: We'll feed these as data into a path generator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些作为数据输入到路径生成器中。
- en: Path generators are really the meat of d3.js's magic. We'll discuss the gravy
    of the magic in [Chapter 5](ch05.html "Chapter 5. Layouts – d3's Black Magic"),
    *Layouts – d3's Black Magic*. They are essentially a function that takes some
    data (joined to elements) and produces a path definition in SVG's path mini language.
    All path generators can be told how to use our data. We also get to play with
    the final output a great deal.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 路径生成器实际上是 d3.js 魔法的精髓。我们将在 [第五章](ch05.html "第五章。布局 – d3 的黑魔法") 中讨论魔法的精华，*布局
    – d3 的黑魔法*。它们本质上是一个函数，它接受一些数据（与元素相关联）并生成 SVG 路径迷你语言中的路径定义。所有路径生成器都可以被告知如何使用我们的数据。我们还可以大量地玩转最终输出。
- en: Line
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线
- en: To create a line we use the `d3.svg.line()` generator and define the x- and
    y-accessor functions. Accessors tell the generator how to read the x and y coordinates
    from datapoints.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一条线，我们使用 `d3.svg.line()` 生成器并定义 x 和 y 访问器函数。访问器告诉生成器如何从数据点读取 x 和 y 坐标。
- en: 'We begin by defining two scales. Scales are functions that map from a domain
    to a range; we''ll talk more about them in the next chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个比例尺。比例尺是从域到范围的函数；我们将在下一章中更多地讨论它们：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we get to define a simple path generator:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义一个简单的路径生成器：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is just a matter of taking the basic line generator and attaching some accessors
    to it. We told the generator to use our `x` scale on the first element and the
    `y` scale on the second element of every tuple. By default, it assumes our dataset
    as a collection of arrays defining points directly so that `d[0]` is `x` and `d[1]`
    is `y`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将基本线生成器与一些访问器附加在一起的问题。我们告诉生成器使用我们的 `x` 尺度在元组的第一个元素上，并在第二个元素上使用 `y` 尺度。默认情况下，它假设我们的数据集是一个直接定义点的数组的集合，因此
    `d[0]` 是 `x`，`d[1]` 是 `y`。
- en: 'All that''s left now is drawing the actual line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下绘制实际的线：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Append a path, and add the `sine` data using `.datum()`. Using this instead
    of `.data()` means we can render the function as a single element instead of creating
    a new line for every point. We let our generator define the `d` attribute. The
    rest just makes things visible.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个路径，并使用 `.datum()` 添加 `sine` 数据。使用这种方法而不是 `.data()` 意味着我们可以将函数渲染为单个元素，而不是为每个点创建新的一行。我们让生成器定义
    `d` 属性。其余的只是使事物可见。
- en: 'Our graph looks as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表如下所示：
- en: '![Line](img/0007_02_16.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![线](img/0007_02_16.jpg)'
- en: 'If you look at the generated code, you''ll see this sort of gobbledygook:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看生成的代码，您会看到这种乱七八糟的东西：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See! I told you nobody wants to write that by hand.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧！我告诉过你没有人愿意手动编写这些。
- en: That's a very jagged `sine` function we've got there, nothing similar to what
    the math teacher used to draw in high school. We can make it better with interpolation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个非常锯齿状的 `sine` 函数，与高中数学老师画的不一样。我们可以通过插值来改进它。
- en: Interpolation is the act of guessing where unspecified points of a line should
    appear, considering the points we do know. By default, we're using the `linear`
    interpolator that just draws straight lines between points.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是猜测线条上未指定点应出现的位置的行为，考虑到我们已知的点。默认情况下，我们使用 `linear` 插值器，它只是在点之间绘制直线。
- en: 'Let''s try something else:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试其他的东西：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is the same code as before, but we used the `step-before` interpolator and
    changed the styling to produce this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码相同，但我们使用了 `step-before` 插值器，并更改了样式以生成以下内容：
- en: '![Line](img/0007_02_17.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![线](img/0007_02_17.jpg)'
- en: d3.js offers 12 line interpolators in total, which I am not going to list here.
    You can look them up on the official wiki page at [https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js 总共提供了 12 个线插值器，这里不再一一列举。您可以在官方维基页面上查找它们：[https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate)。
- en: I suggest trying out all of them to get a feel of what they do.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议尝试所有这些，以了解它们的作用。
- en: Area
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区域
- en: An area is the colored part between two lines, a polygon really.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 区域是两条线之间的彩色部分，实际上是一个多边形。
- en: We define an area similar to how we define a line, so take a path generator
    and tell it how to use our data. For a simple horizontal area, we have to define
    one x accessor and two y accessors, `y0` and `y1`, for both the bottom and the
    top.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个区域，类似于定义线的方式，所以取一个路径生成器并告诉它如何使用我们的数据。对于简单的水平区域，我们必须定义一个 x 访问器和两个 y 访问器，`y0`
    和 `y1`，用于底部和顶部。
- en: 'We''ll compare different generators side by side, so let''s add a new graph:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将并排比较不同的生成器，所以让我们添加一个新的图表：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we define an `area` generator and draw an area.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个 `area` 生成器并绘制一个区域。
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We took a vanilla `d3.svg.area()` path generator and told it to get the coordinates
    through the `x` and `y` scales we defined earlier. The `basis` interpolator will
    use a B-spline to create a smooth curve from our data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取了一个普通的 `d3.svg.area()` 路径生成器，并告诉它通过我们之前定义的 `x` 和 `y` 尺度获取坐标。`basis` 插值器将使用
    B 样条从我们的数据创建平滑曲线。
- en: 'To draw the bottom edge, we defined `y0` as the bottom of our graph and produced
    a colored sine approximation:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制底部边缘，我们将 `y0` 定义为图表的底部，并生成一个彩色的正弦近似：
- en: '![Area](img/0007_02_19.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![面积](img/0007_02_19.jpg)'
- en: 'Areas are often used together with lines that make an important edge stand
    out. Let''s try that:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 区域通常与使重要边缘突出的线一起使用。让我们试试这个：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We could re-use the same line generator as before; we just need to make sure
    that we use the same interpolator as for the area. This way, the image looks much
    better:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用之前的线生成器；我们只需要确保使用与区域相同的插值器。这样，图像看起来会好得多：
- en: '![Area](img/0007_02_20.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![面积](img/0007_02_20.jpg)'
- en: Arc
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弧
- en: An arc is a circular path with an inner and outer radius, going from one angle
    to another. They are often used for pie and donut charts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 弧是一个有内半径和外半径的圆形路径，从一个角度到另一个角度。它们通常用于饼图和甜甜圈图。
- en: Everything works as before; we just tell the base generator how to use our data.
    The only difference is that this time the default accessors expect named attributes
    instead of 2-value arrays we've gotten used to.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都和以前一样工作；我们只需告诉基础生成器如何使用我们的数据。唯一的不同是这次默认的访问器期望的是命名属性，而不是我们习惯的2值数组。
- en: 'Let''s draw an arc:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们画一个弧：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This time we could get away with using the default `d3.svg.arc()` generator.
    Instead of using data, we calculated the angles by hand and also nudged the arc
    towards the center.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们可以使用默认的 `d3.svg.arc()` 生成器。我们不是使用数据，而是手动计算角度，并将弧推向中心。
- en: '![Arc](img/0007_02_21.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![弧](img/0007_02_21.jpg)'
- en: See, a simple arc. Rejoice!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 看看，一个简单的弧。庆祝吧！
- en: Even though SVG normally uses degrees, the start and end angles use radians.
    The zero angle points upwards with negative values going anticlockwise and positive
    values going the other way. Every *2Pi* we come back to zero.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SVG通常使用度数，但起始和结束角度使用弧度。零角度向上，负值逆时针移动，正值朝相反方向移动。每 `2Pi` 我们回到零。
- en: Symbol
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 符号
- en: Sometimes when visualizing data, we need a simple way to mark datapoints. That's
    where symbols come in, tiny glyphs used to distinguish between datapoints.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在可视化数据时，我们需要一种简单的方式来标记数据点。这就是符号的作用，它们是用于区分数据点的微小符号。
- en: The `d3.svg.symbol()` generator takes a `type` accessor and a `size` accessor,
    and leaves the positioning to us. We are going to add some symbols to our area
    chart showing where the function is going when it crosses zero.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.svg.symbol()` 生成器接受一个 `type` 访问器和 `size` 访问器，并将定位留给我们。我们将在我们的面积图中添加一些符号，以显示函数穿过零时函数的走向。'
- en: 'As always, we start with a path generator:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从路径生成器开始：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've given the `d3.svg.symbol()` generator a `type` accessor telling it to
    draw a downward pointing triangle when the y coordinate is positive and an upward
    one when not positive. This works because our `sine` data isn't mathematically
    perfect due to `Math.PI` not being infinite and due to floating point precision;
    we get infinitesimal numbers close to zero whose signedness depends on whether
    the `Math.sin` argument is slightly less or slightly more than the perfect point
    for `sin=0`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 `d3.svg.symbol()` 生成器提供了一个 `type` 访问器，告诉它在 y 坐标为正时绘制向下指的三角形，在非正时绘制向上指的三角形。这之所以有效，是因为我们的
    `sine` 数据由于 `Math.PI` 不是无限的以及由于浮点精度，数学上并不完美；我们得到接近零的无限小数，其符号取决于 `Math.sin` 参数是略小于还是略大于
    `sin=0` 的完美点。
- en: The `size` accessor tells `symbol()` how much area each symbol should occupy.
    Because every other datapoint is close to zero, we hide the others with an area
    equal to zero.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 访问器告诉 `symbol()` 每个符号应该占用多少面积。因为其他每个数据点都接近零，所以我们用面积为零的方式隐藏了它们。'
- en: 'Now we can draw some symbols:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制一些符号：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Go through the data, append a new path for each entry, and turn it into a symbol
    moved into position. The result looks as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数据，为每个条目添加一个新的路径，并将其转换为一个移动到位置的符号。结果如下所示：
- en: '![Symbol](img/0007_02_22.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![符号](img/0007_02_22.jpg)'
- en: You can see other available symbols by printing `d3.svg.symbolTypes`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打印 `d3.svg.symbolTypes` 来查看其他可用的符号。
- en: Chord
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弦
- en: Good news! We are leaving the world of simple charts and entering the world
    of magic.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！我们正在离开简单图表的世界，进入魔法的世界。
- en: Chords are most often used to display relations between group elements when
    arranged in a circle. They use quadratic Bezier curves to create a closed shape
    connecting two points on an arc.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 弦通常用于在圆形排列中显示组元素之间的关系。它们使用二次贝塞尔曲线创建一个封闭形状，连接圆弧上的两个点。
- en: 'If you don''t have a strong background in computer graphics, that tells you
    nothing. A basic chord looks similar to half a villain''s moustache:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有强大的计算机图形背景，这对你来说毫无意义。基本弦看起来像半个坏蛋的胡须：
- en: '![Chord](img/0007_02_23.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![弦](img/0007_02_23.jpg)'
- en: 'To draw that, we use the following piece of code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制这个，我们使用以下代码片段：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This code adds a new grouping element, defines a dataset with a single datum,
    and appends a path using the default `d3.svg.chord()` generator for the `d` attribute.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一个新的分组元素，定义了一个包含单个数据的数据集，并使用默认的 `d3.svg.chord()` 生成器为 `d` 属性附加了一个路径。
- en: The data itself plays right into the hands of the default accessors. `Source`
    defines where the chord begins and `target` where it ends. Both are fed to another
    set of accessors, specifying the arc's `radius`, `startAngle`, and `endAngle`.
    As with the arc generator, angles are defined using radians.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本身正好符合默认访问器的处理方式。`Source`定义了和弦的起始位置，`target`定义了和弦的结束位置。这两个都输入到另一组访问器中，指定弧的`radius`、`startAngle`和`endAngle`。与弧生成器一样，角度使用弧度定义。
- en: 'Let''s make up some data and draw a chord diagram:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编造一些数据并绘制一个弦图：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Nothing too fancy. We defined two arrays of numbers, shuffled one, and merged
    them into an array of pairs; we will look at the details in the next chapter.
    Then we defined some colors.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么太花哨的。我们定义了两个数字数组，其中一个被随机打乱，然后合并成一个成对的数组；我们将在下一章中查看细节。然后我们定义了一些颜色。
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All of this just defines the generator. We're going to divide a circle into
    sections and connect random pairs with chords.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是定义了生成器。我们将把圆分成几个部分，并用弦连接随机配对的点。
- en: The `.source()` and `.target()` accessors tell us the first item in every pair
    is the source and the second is the target. For `startAngle`, we remember a full
    circle is *2Pi* and divide it by the number of sections. Finally, to pick a section,
    we multiply by the current datum. The `endAngle` accessor is more of the same,
    except with datums offset by one.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`.source()`和`.target()`访问器告诉我们每一对中的第一个元素是源，第二个是目标。对于`startAngle`，我们记得一个完整的圆是*2Pi*，然后除以部分的数量。最后，为了选择一个部分，我们乘以当前的值。`endAngle`访问器与之前类似，只是数据偏移了一个。'
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To draw the actual diagram we create a new grouping, join the dataset, and then
    append a path for each datum. The `chord` generator gives it a shape. To make
    everything look better, we define colors dynamically with the `colors` array.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制实际的图表，我们创建一个新的分组，连接数据集，然后为每个数据项附加一个路径。`chord`生成器给它一个形状。为了使一切看起来更好，我们使用`colors`数组动态定义颜色。
- en: 'The end result changes with every refresh but looks something like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果每次刷新都会改变，但看起来可能像这样：
- en: '![Chord](img/0007_02_24.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![弦图](img/0007_02_24.jpg)'
- en: Diagonal
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对角线
- en: The `diagonal` generator creates cubic Bezier curves—smooth curves between two
    points. It is very useful for visualizing trees with a node-link diagram.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`diagonal`生成器创建三次贝塞尔曲线——两点之间的平滑曲线。这对于用节点-链接图可视化树非常有用。'
- en: Once again, the default accessors assume your data is a dictionary with keys
    named after the specific accessor. You need `source` and `target`, which are fed
    into `projection`, which then projects Cartesian coordinates into whatever coordinate
    space you like. By default, it just returns Cartesian coordinates.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，默认访问器假设你的数据是一个字典，键名与特定的访问器同名。你需要`source`和`target`，它们被输入到`projection`中，然后它将笛卡尔坐标投影到你喜欢的任何坐标空间中。默认情况下，它只返回笛卡尔坐标。
- en: 'Let''s draw a moustache. Trees are hard without `d3.layouts` and we''ll do
    those later:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们画一个胡子。没有`d3.layouts`，树状图就很难画，我们稍后再做这些：
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We started off with a fresh graph on our drawing area and defined some data
    that should create a sweet ''stache:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在绘图区域上创建一个新的图形，并定义了一些应该创建一个甜美的胡子的数据：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The rest is a simple matter of joining data to our drawing and using the `d3.svg.diagonal()`
    generator for the `d` attribute:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是一个简单地将数据连接到我们的绘图并使用`d3.svg.diagonal()`生成器为`d`属性：
- en: '![Diagonal](img/0007_02_25.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![对角线](img/0007_02_25.jpg)'
- en: Okay, it's a bit Daliesque. It may be, but it doesn't really look anything like
    a moustache. That's because the tangents defining how Bezier curves bend are tweaked
    to create good-looking fan-out in tree diagrams. Unfortunately d3.js doesn't give
    us a simple way of changing these, and manually defining Bezier curves through
    SVG's path mini language is tedious at best.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这有点像达利式的画风。可能吧，但它实际上看起来并不像胡子。这是因为定义贝塞尔曲线弯曲方式的切线被调整以在树状图中创建好看的扇出效果。不幸的是，d3.js并没有给我们提供简单更改这些设置的方法，而且通过SVG的路径迷你语言手动定义贝塞尔曲线最多也只能算是繁琐。
- en: 'Either way, we have created a side-by-side comparison of path generators:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都创建了一个路径生成器的并排比较：
- en: '![Diagonal](img/0007_02_26.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![对角线](img/0007_02_26.jpg)'
- en: Axes
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 轴
- en: But we haven't done anything useful with our paths and shapes yet. One way we
    can do that is using lines and text to create graph axes. It would be tedious
    though, so d3.js makes our lives easier with axis generators. They take care of
    drawing a line, putting on some ticks, adding labels, evenly spacing them, and
    so on.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有对我们的路径和形状做任何有用的事情。我们可以通过使用线条和文本来创建图形轴来实现这一点。但这会很繁琐，所以d3.js通过轴生成器使我们的工作变得更简单。它们负责绘制线条、添加刻度、添加标签、均匀地间隔它们等等。
- en: A d3.js axis is just a combination of path generators configured for awesomeness.
    All we have to do for a simple linear axis is create a scale and tell the axis
    to use it. That's it!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js 轴只是配置为酷炫的路径生成器的组合。对于简单的线性轴，我们只需要创建一个刻度并告诉轴使用它。就是这样！
- en: For a more customized axis, we might have to define the desired number of ticks
    and specify the labels, perhaps something even more interesting. There are even
    ways to make circular axes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更定制的轴，我们可能需要定义所需的刻度数并指定标签，也许甚至更有趣。甚至有方法制作圆形轴。
- en: Using a fresh version of the environment, let's create an axis.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个全新的环境版本，让我们创建一个轴。
- en: 'We begin with a drawing area:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个绘图区域开始：
- en: '[PRE58]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also need a linear scale:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个线性刻度：
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Our axis is going to use the following to translate data points (`domain`)
    tocoordinates (`range`):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的轴将使用以下方式将数据点（`域`）转换为坐标（`范围`）：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We've told the `d3.svg.axis()` generator to use our `x` scale. Then, we simply
    created a new grouping element, joined some data, and called the axis. It's very
    important to call the `axis` generator on all of the data at once so it can handle
    appending its own element.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉 `d3.svg.axis()` 生成器使用我们的 `x` 刻度。然后，我们简单地创建了一个新的分组元素，连接了一些数据，并调用了轴。同时调用
    `axis` 生成器对所有数据非常重要，这样它就可以处理附加自己的元素。
- en: '![Axes](img/0007_02_27.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![轴](img/0007_02_27.jpg)'
- en: The result doesn't look good at all.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来一点也不好。
- en: Axes are complex objects, so fixing this problem is convoluted without CSS,
    which comes in the next section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 轴是复杂对象，所以没有 CSS 的情况下解决这个问题很复杂，CSS 将在下一节中介绍。
- en: 'For now, adding this code will be sufficient:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，添加以下代码就足够了：
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'An axis is a collection of paths and lines; we give them some swagger and get
    a nice-looking axis in return:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 轴是一系列路径和线条；我们给它们一些风格，就能得到一个看起来很棒的轴：
- en: '![Axes](img/0007_02_28.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![轴](img/0007_02_28.jpg)'
- en: If you play around with the amount, make sure the scale's domain and the range's
    max value match, and you'll notice axes are smart enough to always pick the perfect
    amount of ticks.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调整刻度数量，确保刻度范围的域和范围的最大值匹配，你会发现轴足够智能，总是能选择完美的刻度数量。
- en: Let's compare what the different settings do to axes. We're going to loop through
    several axes and render the same data.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较不同设置对轴的影响。我们将遍历几个轴并渲染相同的数据。
- en: 'Wrap your axis-drawing code in a loop by adding this line just above `svg.append(''g'')`.
    Don''t forget to close off the loop just after the last `stroke-width`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `svg.append('g')` 之上添加这一行来将你的轴绘制代码包裹在一个循环中。别忘了在最后一个 `stroke-width` 之后关闭循环：
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You should also change the `.attr('transform', …)` line to put each axis 50
    pixels below the previous one.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该将 `.attr('transform', …)` 这一行改为将每个轴放置在上一轴下方 50 像素的位置。
- en: '[PRE63]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that''s done, we can start defining an array of axes:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了，我们可以开始定义一个轴数组：
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Two for now: one is the plain vanilla version and the other will render with
    exactly `5` ticks:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有两个版本：一个是普通版本，另一个将渲染出恰好 `5` 个刻度：
- en: '![Axes](img/0007_02_29.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![轴](img/0007_02_29.jpg)'
- en: It worked! The `axis` generator figured out which ticks are best left off and
    relabeled everything without us doing much.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！`axis` 生成器已经找到了哪些刻度最好不显示，并重新标记了所有内容，我们几乎没做什么。
- en: 'Let''s add more axes to the array and see what happens:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在数组中添加更多轴并看看会发生什么：
- en: '[PRE65]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'With `.tickSubdivide()`, we instruct the generator to add some subdivisions
    between the major ticks; `.tickSize()` tells it to make the minor ticks smaller.
    The arguments are major, minor, and end tick size:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.tickSubdivide()`，我们指示生成器在主刻度之间添加一些细分；`.tickSize()` 告诉它使次刻度更小。参数是主要、次要和末端刻度大小：
- en: '![Axes](img/0007_02_30.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![轴](img/0007_02_30.jpg)'
- en: 'For our final trick, let''s define some custom ticks and place them above the
    axis. We''ll add another axis to the array:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个技巧，让我们定义一些自定义刻度并将它们放置在轴上方。我们将在数组中添加另一个轴：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Three things happen here: `.tickValues()`exactly defines which values should
    have a tick, `.tickFormat()` specifies how to render the labels—d3 comes with
    a slew of helpful formatters in `d3.format` by the way—and finally `.orient(''top'')`
    puts the labels above their axis.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了三件事：`.tickValues()` 精确定义了哪些值应该有刻度，`.tickFormat()` 指定了标签的渲染方式——顺便说一句，d3
    在 `d3.format` 中提供了一系列有用的格式化工具——最后 `.orient('top')` 将标签放在轴的上方。
- en: You might have guessed the default orient is `'bottom'`. For a vertical axis,
    you can use `'left'` or `'right'` but don't forget to assign an appropriate scale.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了默认方向是 `'bottom'`。对于垂直轴，你可以使用 `'left'` 或 `'right'`，但别忘了分配适当的刻度。
- en: '![Axes](img/0007_02_31.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![轴](img/0007_02_31.jpg)'
- en: CSS
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS
- en: Cascading Stylesheets have been with us since 1996, making them one of the oldest
    staples of the Web, even though they only reached widespread popularity with the
    tables versus CSS wars of the early 2000s.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 层叠样式表（Cascading Stylesheets）自 1996 年以来一直伴随着我们，使它们成为网络中最古老的基石之一，尽管它们直到 21 世纪初的表格与
    CSS 战争才达到广泛的流行。
- en: You're probably familiar with using CSS for styling HTML. So this section will
    be a refreshing breeze after all that SVG stuff.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉使用 CSS 为 HTML 添加样式。所以，在所有关于 SVG 的内容之后，这一节将会像一阵清新的微风。
- en: My favorite thing about CSS is its simplicity; refer to the following code.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的 CSS 之处在于它的简单性；参考以下代码。
- en: '[PRE67]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And that's it. Everything you need to know about CSS in three lines.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。关于 CSS 的所有你需要知道的内容都在三行之内。
- en: 'The selectors can get fairly complicated and are beyond the scope of this book.I
    suggest looking around the Internet for a good guide. We just need to know some
    basics:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可能会相当复杂，超出了本书的范围。我建议在网上寻找一个好的指南。我们只需要了解一些基础知识：
- en: '`path`: Selects all the `<path>` elements'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 选择所有 `<path>` 元素'
- en: '`.axis`: Selects all the elements with a `class="axis"` attribute'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.axis`: 选择所有具有 `class="axis"` 属性的元素'
- en: '`.axis line`: Selects all the `<line>` elements that are children of `class="axis"`
    elements'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.axis line`: 选择所有是 `class="axis"` 元素子元素的 `<line>` 元素'
- en: '`.axis, line`: Selects all the `class="axis"` and `<line>` elements'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.axis, line`: 选择所有 `class="axis"` 和 `<line>` 元素'
- en: Right now you might be thinking, "Oh hey! That's the same as selectors for d3.js
    selections." Yes! It is exactly the same. d3.js selections are a subset of CSS
    selectors.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能正在想，“哦，嘿！这和 d3.js 选择器的选择器是一样的。”是的！它确实是完全一样的。d3.js 选择器是 CSS 选择器的一个子集。
- en: 'We can invoke CSS with d3.js in three ways: define a class attribute with the
    `.attr()` method, which can be brittle; use the `.classed()` method, the preferred
    way to define classes; or define styling directly with the `.style()` method.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三种方式使用 d3.js 调用 CSS：使用 `.attr()` 方法定义一个类属性，这可能会很脆弱；使用 `.classed()` 方法，这是定义类的首选方式；或者直接使用
    `.style()` 方法定义样式。
- en: Let's improve the axes example from before and make the styling less cumbersome.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进之前的轴示例，并使样式更简洁。
- en: 'Go into the HTML and add some CSS right before the `<div id="graph">` tag as
    follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 HTML 并在 `<div id="graph">` 标签之前添加一些 CSS，如下所示：
- en: '[PRE68]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is very similar to changing SVG attributes directly, but with CSS. We used
    `stroke` and `fill` to define the shape of the line and set `shape-rendering`
    to `crispEdges`. This will make things better.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 它与直接更改 SVG 属性非常相似，但使用 CSS。我们使用 `stroke` 和 `fill` 来定义线的形状，并将 `shape-rendering`
    设置为 `crispEdges`。这将使事情变得更好。
- en: We've also defined an extra type of axis with red lines.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一种带有红色线条的额外类型的轴。
- en: 'Now we fix the drawing loop to look as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将绘图循环修正如下：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: None of that foolishness with specifying the same looks five times in a row.
    Using the `.classed()` function, we add the `axis` class to each axis and every
    second axis is red. `.classed()` adds the specified class if the second argument
    is true and removes it otherwise.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要连续五次指定相同的样式。使用 `.classed()` 函数，我们为每个轴添加 `axis` 类，每隔一个轴是红色。`.classed()` 如果第二个参数为真则添加指定的类，否则移除。
- en: '![CSS](img/0007_02_32.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![CSS](img/0007_02_32.jpg)'
- en: Colors
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: Beautiful visualizations often involve color beyond the basic names you can
    think of off the top of your head. Sometimes you want to play with colors depending
    on what the data looks like.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 美观的视觉化往往涉及比你能立刻想到的基本名称更多的颜色。有时你想要根据数据的样子来玩弄颜色。
- en: 'd3.js has us covered with a slew of functions devoted to manipulating color
    in four popular color spaces: RGB, HSL, HCL, and L*a*b. The most useful for us
    are going to be RGB (red green blue) and HSL (hue saturation lightness), which
    is secretly just another way of looking at RGB. Either way, all color spaces use
    the same functions, so you can use what fits your needs best.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: d3.js 提供了一系列用于在四个流行的颜色空间中操作颜色的函数：RGB、HSL、HCL 和 L*a*b。对我们最有用的是 RGB（红绿蓝）和 HSL（色调饱和度亮度），这实际上是另一种查看
    RGB 的方式。无论如何，所有颜色空间都使用相同的函数，所以你可以使用最适合你需求的。
- en: To construct an RGB color, we use `d3.rgb(r, g, b)` where `r`, `g`, and `b`
    specify the channel values for red, green, and blue. We can also replace the triplet
    with a simple CSS color argument. Then we get to make the color darker or brighter,
    which is much better than shading by hand.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个 RGB 颜色，我们使用 `d3.rgb(r, g, b)`，其中 `r`、`g` 和 `b` 分别指定红色、绿色和蓝色的通道值。我们也可以用简单的
    CSS 颜色参数替换三元组。然后我们可以使颜色变得更暗或更亮，这比手动着色要好得多。
- en: Time to play with color in a fresh environment. We'll draw two color wheels
    with their brightness changing from the center towards the outside.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在新的环境中玩转颜色了。我们将绘制两个颜色轮，它们的亮度从中心向外部逐渐变化。
- en: 'As always, we begin with some variables and a drawing area:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从一个变量和一个绘图区域开始：
- en: '[PRE70]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The main variable henceforth will be `rings`; it will tell the code how many
    levels of brightness we want. We also need some basic colors and a way to calculate
    angles:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 从此以后，主要变量将是`rings`；它将告诉代码我们想要多少亮度级别。我们还需要一些基本颜色和计算角度的方法：
- en: '[PRE71]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`colors` is technically a scale, but we''ll use it as data. Category20b is
    one of four predefined color scales that come with d3.js—an easy way to get a
    list of well picked colors.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`colors`在技术上是一个比例尺，但我们将它用作数据。Category20b是d3.js附带的前定义颜色比例尺之一——一种获取精选颜色列表的简单方法。'
- en: To calculate angles, we're using a linear scale that maps the `[0, 20]` domain
    to a full circle `[0, 2*pi]`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算角度，我们使用一个线性比例尺，它将`[0, 20]`域映射到完整的圆圈`[0, 2*pi]`。
- en: 'Next we need an `arc` generator and two data accessors to change the color
    shade for every ring:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一个`arc`生成器和两个数据访问器来改变每个环的颜色色调：
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The arc will calculate the inner and outer radii from a simple ring counter,
    and the angles will use the `angle` scale, which will automatically calculate
    the correct radian values. The `j` argument tells us which arc section is currently
    being drawn.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 弧将根据简单的环计数器计算内半径和外半径，角度将使用`angle`比例尺，这将自动计算正确的弧度值。`j`参数告诉我们当前正在绘制哪个弧段。
- en: Since we're making two pictures, we can simplify the code by using two different
    shaders from a dictionary.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们制作了两幅图，我们可以通过使用字典中的两个不同的着色器来简化代码。
- en: Each shader will take a `d3.rgb()` color from the colors scale and then darken
    or brighten it by the appropriate number of steps, depending on which ring it's
    drawing. Once again, the `j` argument tells us which arc section we're in, and
    the `d` argument tells us which ring we're at.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 每个着色器将从一个颜色比例尺中获取`d3.rgb()`颜色，然后根据它绘制的环数相应地变暗或变亮。再次强调，`j`参数告诉我们我们处于哪个弧段，`d`参数告诉我们我们处于哪个环。
- en: 'Finally, we draw the two color wheels:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制两个颜色轮：
- en: '[PRE73]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Wow! That's quite a bit of code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这段代码相当多。
- en: We take two triplets, each defining the color wheel's position and which shader
    to use; then call a function that draws a shiny colorful circle with each.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取两个三元组，每个三元组定义了颜色轮的位置和要使用的着色器；然后调用一个函数，用每个着色器绘制一个闪亮的彩色圆圈。
- en: For each circle, we append a `<g>` element and move it into position, and then
    use `colors.range()` to get a full list of colors and join it as data. For every
    new color, we create another `<g>` element and select all the `<path>` elements
    it contains.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个圆圈，我们添加一个`<g>`元素并将其移动到位置，然后使用`colors.range()`获取完整的颜色列表并将其作为数据连接。对于每个新的颜色，我们创建另一个`<g>`元素并选择它包含的所有`<path>`元素。
- en: Here things get magical. We join more data but just an array of numbers going
    from `0` to `rings` this time. For every element in this array, we append a `<path>`
    element and use the `arc` generator to define its shape. Finally we calculate
    the `fill` attribute with an appropriately shaded color.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得神奇。我们连接了更多的数据，但这次只是一个从`0`到`rings`的数字数组。对于这个数组中的每个元素，我们添加一个`<path>`元素并使用`arc`生成器定义其形状。最后，我们使用适当的阴影颜色计算`fill`属性。
- en: 'The result looks as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来如下：
- en: '![Colors](img/0007_02_33.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![颜色](img/0007_02_33.jpg)'
- en: Our main trick was that joining a second dimension of data retains the knowledge
    of the first dimension via the third attribute supplied to data accessors.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要技巧是将数据的第二维连接起来，通过提供给数据访问器的第三个属性保留了第一维的知识。
- en: Summary
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Wow! We've gone through so much in this chapter.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！在这一章中我们已经学到了很多。
- en: You should now have a firm grasp of the basics that go into great visualizations.
    We've gone through DOM manipulation and looked at SVG in great detail, everything
    from drawing shapes manually to path generators. Finally we looked at CSS as a
    better alternative for making things pretty.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经牢固掌握了构建优秀可视化所需的基本知识。我们学习了DOM操作，并详细探讨了SVG，从手动绘制形状到路径生成器。最后，我们探讨了CSS作为使事物更美观的更好替代方案。
- en: Everything we look at from now on is going to build on these basics, but you
    now have the tools to draw anything you can think of. The rest of this book just
    shows you more elegant ways of doing it.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们所看到的一切都将建立在这些基础知识之上，但你现在有了绘制任何你能想到的东西的工具。这本书的其余部分只是展示了更多优雅的实现方式。
