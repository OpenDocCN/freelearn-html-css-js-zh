- en: Chapter 2. A Primer on DOM, SVG, and CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at the core technologies that make d3.js
    tick: the **Document Object Model** (**DOM**), **Scalable Vector Graphics** (**SVG**),
    and **Cascading Style Sheets** (**CSS**).'
  prefs: []
  type: TYPE_NORMAL
- en: You're probably used to manipulating DOM and CSS with libraries such as jQuery
    or MooTools, but d3.js has a full suite of manipulation tools as well.
  prefs: []
  type: TYPE_NORMAL
- en: SVG is at the core of building truly great visualizations, so we'll take special
    care to understand it; everything from manually drawing shapes to transformations
    and path generators.
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Document Object Model is a language-agnostic model for representing structured
    documents built in HTML, XML, or similar standards. You can think of it as a tree
    of nodes that closely resembles the document parsed by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top, there is an implicit `document` node, which represents the `<html>`
    tag; browsers create this tag even if you don''t specify it and then build the
    tree off this root node according to what your document looks like. If you have
    a simple HTML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Chrome will parse the preceding code to DOM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM](img/0007_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the latest Chrome builds, I can print and play with this in the **Console**
    tab; you might have to use the **Elements** tab to get the same effect. Moving
    the cursor over each element will show you where exactly it is placed on the page,
    which is very handy for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the DOM with d3.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every node in a DOM tree comes with a slew of methods and properties that you
    can use to change the look of the rendered document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for instance the HTML code in our previous example. If we want to change
    the word `italic` to make it underlined as well as bold and italic (the result
    of the `<em>` and `<strong>` tags), we would do it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Wow! What a mouthful.
  prefs: []
  type: TYPE_NORMAL
- en: We took the root `document` node and found every node created from a `<strong>`
    tag; then we took the first item in this array and added a `text-decoration` property
    to its `style` property.
  prefs: []
  type: TYPE_NORMAL
- en: The sheer amount of code it took to do something this simple in a document with
    only eleven nodes is the reason why few people today use the DOM API directly—not
    to mention all the subtle differences between browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Since we'd like to keep our lives simple and avoid using the DOM directly, we
    need a library. jQuery is a good choice, but to make things even simpler, we can
    use d3.js. It comes with everything we need.
  prefs: []
  type: TYPE_NORMAL
- en: That means we can treat HTML as just another type of data visualization. Let
    that one sink in. HTML is data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means we can use similar techniques to present data as a table
    or an interactive image. Most of all, we can use the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the previous example in d3.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Much simpler! We selected the `strong` element and defined a `style` property.
    Job done!
  prefs: []
  type: TYPE_NORMAL
- en: By the way, any property you set with d3.js can be dynamic, so you can assign
    a function as well as a value. This is going to come in handy later.
  prefs: []
  type: TYPE_NORMAL
- en: What we just did is called a **selection**. Since selections are the core of
    everything we do with d3.js, let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Selections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A selection is an array of elements pulled from the current document according
    to a particular CSS selector. Selectors let you apply different functions to the
    whole selection at once so you never have to loop through the elements manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS selectors to decide which elements to work on gives us a simple language
    for defining elements in the document. It's actually the same as you're used to
    from jQuery and CSS itself.
  prefs: []
  type: TYPE_NORMAL
- en: To get the first element with ID as `graph`, we use `.select('#graph')`; to
    get all the elements with the class `blue`, we write `.selectAll('.blue')`; and
    to get all the paragraphs in a document, we use `.selectAll('p')`.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine these to get a more complex matching. Think of it as set operations.
    You can perform an AND operation with `".this.that"`; it will get elements with
    classes `this` and `that`. Alternatively, you might perform an OR operation with
    `".this, .that"` to get elements having either the `this` or `that` class.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to select children elements? Nested selections to the rescue.
    You can do it with a simple selector such as `"tbody td"`, or you can chain two
    `selectAll` calls as `.selectAll('tbody').selectAll('td')`. Both will select all
    the cells in a table body. Keep in mind that nested selections maintain the hierarchy
    of selected elements, which gives us some interesting capabilities. Let's look
    at a short example.
  prefs: []
  type: TYPE_NORMAL
- en: Selections example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take the base HTML from our play environment in the first chapter and add a
    simple table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pretty much the standard markup for a table, `<thead>` and `<tbody>` define
    the head and body of the table where each `<tr>` is a row and each `<td>` is a
    cell. Adding the `table` class tells bootstrap to make the table look pretty for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into the console and have some fun with selections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The text will promptly turn red. Now let''s make everything in the table head
    bold by chaining two `selectAll` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Let''s take nested selections a bit further and make table body cells
    green in the second and fourth column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The two `selectAll` calls gave us all the instances of `td` in the body, separated
    by rows, giving us an array of three arrays with five elements: `[ Array[5], Array[5],
    Array[5] ]`. Then we used `style` to change the color of every selected element.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a function instead of a static property gave us the fine-grained control
    we needed. The function is called with a data attribute (we'll discuss more on
    that later) and an index of the column it's in, that is, the `i` variable. Since
    we're using nested selections, a third parameter would give us the row. Then we
    simply return either `'green'` or `'red'` based on the current index.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that chaining selections can be more efficient
    than OR selectors when it comes to very large documents. This is because each
    subsequent selection only searches through the elements matched previously.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do far more than just playing around with selections and changing the
    properties of the elements. We can manipulate things.
  prefs: []
  type: TYPE_NORMAL
- en: With d3.js, we can change the contents of an element, add new elements, or remove
    elements we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a new column to the table from our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We selected all the table rows and then appended a new cell to each using `.append()`.
    All d3.js actions return the current selection—new cells in this case—so we can
    chain actions or assign the new selection to a variable (`newCol`) for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an empty invisible column on our hands. Let''s add some text to spruce
    things up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At least now that it''s full of instances of `a`, we can say a column is present.
    But that''s kind of pointless, so let''s follow the pattern set by other columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The trick of dynamically defining the content via a function helps us pick the
    right string from a list of values depending on the column we're in, which we
    identify by the index `i`.
  prefs: []
  type: TYPE_NORMAL
- en: Figured out the pattern yet? Read the top row of the table body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can remove elements using `.remove()`. To get rid of the last
    row in the table, you''d write something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You have to use `[0][3]` instead of just `[3]` because selections are arrays
    of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Joining data to selections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've made it to the fun part of our DOM shenanigans. Remember when I said HTML
    is data visualization? Joining data to selections is how that happens.
  prefs: []
  type: TYPE_NORMAL
- en: To join data with a selection, we use the `.data()` function. It takes a data
    argument in the form of a function or an array, and optionally a function telling
    d3.js how to differentiate between various parts of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you join data to a selection, one of the following three things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: There is more data than was already joined (the length of the data is longer
    than the length of a selection). You can reference the new entries with the `.enter()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is exactly the same amount of data as before. You can use the selection
    returned by `.data()` itself to update element states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is less data than before. You can reference these using the `.exit()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't chain `.enter()` and `.exit()` because they are just references and
    don't create a new selection. This means you will usually want to focus on `.enter()`
    and `.exit()` and handle the three cases separately. Mind you, all three can happen
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering, "But how's it possible for there to be both more and
    less data than before?" That's because selection elements are bound to instances
    of datum, not their number. If you shifted an array and then pushed a new value,
    the previous first item would go to the `.exit()` reference and the new addition
    would go to the `.enter()` reference.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build something cool with data joins and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: An HTML visualization example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start off with the same HTML file as usual. I'd suggest coding in the
    `code.js` file from now on because things can get pretty involved. Refresh frequently
    to keep an eye on what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: Every great visualization needs a dataset; we'll be using the list of all Dr.
    Who monsters and villains since 1963\. It's been published by the *Guardian Datablog*
    in late December, 2012\. You can get the CSV file from [https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv](https://github.com/Swizec/d3.js-book-examples/blob/master/ch2/villains.csv).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make a table. Not very exciting for sure, but very practical
    for HTML visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a global data variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line at the top of your `code.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we append an empty table to our `graph` div using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine from previous examples, this code selects the target `<div>`
    tag with ID as `graph` and appends a `table` element with a `class='table'` attribute
    so that Bootstrap will make it attractive.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines append empty `thead` and `tbody` elements and assign them
    to variables for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re going to load our data and assign it to the `Data` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We'll be messing with the dataset later, so it's handy to have a function that
    we can call when we want to reload the data without having to refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because our dataset is in CSV format, we use the `csv` function of d3.js to
    load and parse it. d3.js is smart enough to understand that the first row in our
    dataset is not data but a set of labels, so it populates the `data` variable with
    an array of dictionaries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code right now, Chrome will complain that the `redraw()` function
    doesn''t exist. Let''s write one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We defined a `redraw` variable and assigned an empty function to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to make this function do something. Let''s go into its body
    (between the two curly braces) and add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code is divided into three parts. The first part selects all the table rows
    (of which none exist yet) and joins our `Data` using the `.data()` function. The
    resulting selection is saved in the `tr` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a table row for every new datum in the dataset using the `.enter()`
    reference. Right now, that's for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this code doesn't do anything yet but will remove any `<tr>`
    element in the `.exit()` reference once we change the data later.
  prefs: []
  type: TYPE_NORMAL
- en: After execution, the `tr` variable will hold an array of `<tr>` elements, each
    bound to its respective place in the dataset. The first `<tr>` element holds the
    first datum, the second holds the second datum, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rows are useless without cells. Let''s add some by relying on the fact that
    data stays joined to elements even after a new selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We selected all the `<td>` children of each row (none exist yet). We then had
    to call the `.data()` function with the same data transformed into a list of values
    using `d3.values()`. This gave us a new chance to use `.enter()`.
  prefs: []
  type: TYPE_NORMAL
- en: From then on it's more of the same. Each new entry gets its own table cell,
    and the text is set to the current datum.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code will give you an utterly confusing table specifying all the
    Dr. Who monsters and villains televised since 1963.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make it clearer. You can write this code at the bottom of the `redraw()`
    function or right in Chrome's JavaScript console if you want to see some live
    updating magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort the table by the villain''s first appearance, we write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Without doing anything else, this code will redraw the table with the new ordering—no
    refreshing the page, no manually adding or removing elements. Because all our
    data is joined to the HTML, we didn't even need a reference to the original `tr`
    selection or the data. Pretty nifty if you ask me.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.sort()` function takes only a comparator function. The comparator is
    given two pieces of data and must decide how to order them: `-1` for being less
    than `b`, `0` for being equal, and `1` for being more than `b`. You can also use
    `d3.ascending` and `d3.descending` comparators of d3.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s still pretty unclear though. Let''s limit our table only to the latest
    Doctor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We filtered the dataset so that it only contains rows where the actor is Matt
    Smith, and then we called the `redraw()` function. The `.exit()` selection does
    its job and a few hundred rows are removed from the table. Wait… we ended up with
    a mishmash of actors. Took me a while to figure out what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a language with instance-based identity, which means that d3.js
    can't use `a == b` to decide whether two complex objects are the same. Instead,
    it relies on indexes to identify objects. So when we filtered our data, the first
    *x* number of indexes had something in them and were considered unchanged, and
    the rest were removed. The data already attached to elements doesn't get updated,
    and we have a bad table on our hands. We can get out of this in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could first sort the table and then filter the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As before, we used a comparator to sort; we used a numerical comparison between
    `a['Doc. no.']` and `b['Doc. no.']` to sort the rows in descending order with
    the highest number on top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the same code as before will give the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This worked because Matt Smith was in the first *x* places of the dataset. But
    the approach only works for this example. We can use a more robust approach, but
    it doesn't happen automatically when we change the data. Remember to refresh the
    page or run `reload()` to get the whole dataset back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can filter the table directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `.filter()` function takes a single selector as its argument and feeds the
    current datum to it. When the function returns `false`, the element is removed
    from the selection; when it returns `true`, the element remains. In the end, we
    use the `.remove()` function to remove every row we caught. Much more robust,
    but playing with the data itself is often more elegant. Choose wisely.
  prefs: []
  type: TYPE_NORMAL
- en: SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalable Vector Graphics is a vector graphics format that describes images with
    XML. It's been around since 1999 and is supported by all major browsers these
    days. Unfortunately, Internet Explorer has been a laggard and provides only limited
    support since Version 9\. Vector images can be rendered in any size without becoming
    fuzzy. This means you can render the same image on a large retina display or a
    small mobile phone, and it will look great in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: SVG images are made up of shapes you can create from scratch using paths, or
    put together from basic shapes defined in the standard, for example, a line or
    a circle. The format itself represents shapes with XML elements and some attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As such, SVG code is just a bunch of text you can edit manually, inspect with
    your browser's normal debugging tools, and compress with standard text compression
    algorithms. Being text based also means you can use d3.js to create an image in
    your browser, then copy and paste the resulting XML to a `.svg` file, and open
    it with any SVG viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Another consequence is that browsers can consider SVG to be a normal part of
    the document. You can use CSS for styling, listening for mouse events on specific
    shapes, and even scripting the image to make animations where images are interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with SVG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw with d3.js, you can add shapes manually by defining the appropriate
    SVG elements, or you can use helper functions that help you create advanced shapes
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're going to go through the very core of what d3.js does. Everything else
    builds from this, so pay attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by preparing a drawing area in our usual environment. Put this
    code at the top of a fresh `code.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We appended an `<svg>` element to the main `<div>` tag and adjusted its size.
    From now on, we'll be using the `svg` variable for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Manually adding elements and shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An SVG image is a collection of elements rendered as shapes and comes with
    a set of seven basic elements. All but one of these are just an easier way to
    define a path:'
  prefs: []
  type: TYPE_NORMAL
- en: Text (the only one that isn't a path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Straight lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polylines (a set of straight lines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polygons (a set of straight lines, closing in on itself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You build SVG images by adding these elements to the canvas and defining some
    attributes. All of them can have a `stroke` style defining how the edge is rendered,
    a `fill` style defining how the shape is filled, and all of them can be rotated,
    skewed, or moved using the `transform` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Text is the only element that is neither a shape nor does it translate to a
    path in the background like the others. Let''s look at it first so the rest of
    this chapter can be about shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We took our `svg` element and appended a `text` element. Then we defined its
    actual text and added some attributes to position the text at the `(x, y)` point
    and anchored the text at start.
  prefs: []
  type: TYPE_NORMAL
- en: The `text-anchor` attribute defines the horizontal positioning of rendered text
    in relation to the anchor point defined by `(x, y)`. The positions it understands
    are the start, the middle, and the end.
  prefs: []
  type: TYPE_NORMAL
- en: We can also fine tune the text's position with an offset defined by the `dx`
    and `dy` attributes. This is especially handy when adjusting the text margin and
    baseline relative to the font size because it understands the `em` unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our image looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text](img/0007_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shapes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that text is out of the way, let's look at something useful—shapes, the
    heart of the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by drawing a straight line using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we took the `svg` element, appended a line, and defined some attributes.
    A line is drawn between two points: `(x1, y1)` and `(x2, y2)`. To make the line
    visible, we have to define the stroke color and `stroke-width` attributes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapes](img/0007_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our line points downwards even though `y2` is bigger than `y1`. Hmm… that's
    because the origin in most image formats lies in the top-left corner. This means
    `(x=0, y=0)` defines the top-left corner of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a rectangle, we can use the `rect` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We appended a `rect` element to the `svg` element and defined some attributes.
    A rectangle is defined by its upper-left corner (`x`, `y`), `width`, and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our image now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapes](img/0007_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have an unwieldy black rectangle. We can make it prettier by defining three
    more properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Shapes](img/0007_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is much better. Our rectangle has a thin, green outline. Rounded corners
    come from the `rx` and `ry` attributes, which define the corner radius along the
    x and y axis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try adding a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A circle is defined by a central point `(cx, cy)` and a radius `r`. In this
    instance, we get a `green` circle with a `steelblue` outline in the middle of
    our rectangle. The `fill-opacity` attribute tells the circle to be slightly transparent
    so it doesn''t look too strong against the light rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapes](img/0007_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Mathematically speaking, a circle is just a special form of ellipse. By adding
    another radius and changing the element, we can draw one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an `ellipse` element and defined some well-known attributes. The ellipse
    shape needs a central point `(cx, cy)` and two radii, `rx` and `ry`. Setting a
    low `fill-opacity` attribute makes the circle visible under the ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapes](img/0007_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s nice, but we can make it more interesting using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The only trick here is that `rx` is smaller than `ry`, creating a vertical ellipse.
    Lovely!
  prefs: []
  type: TYPE_NORMAL
- en: '![Shapes](img/0007_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A strange green eye with a random blue line is staring at you, all thanks to
    manually adding basic SVG elements to the canvas and defining some attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated SVG looks in XML form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, I wouldn't want to write that by hand either.
  prefs: []
  type: TYPE_NORMAL
- en: But you can see all the elements and attributes we added before. Being able
    to look at an image file and understand what's going on might come in handy some
    day. It's certainly cool. Usually when you open an image in a text editor, all
    you get is binary gobbledygook.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I know I mentioned earlier that polylines and polygons are also basic SVG
    elements. The only reason I'm leaving off the explanation of these basic elements
    is because with d3.js, we have some great tools to work with them. Trust me, you
    don't want to do them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before jumping onto more complicated things, we have to look at transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Without going into too much mathematical detail, it suffices to say that transformations,
    as used in SVG, are affine transformations of coordinate systems used by shapes
    in our drawing. The beautiful thing is they can be defined as matrix multiplications,
    making them very efficient to compute.
  prefs: []
  type: TYPE_NORMAL
- en: But, unless your brain is made out of linear algebra, using transformations
    as matrices can get very tricky. SVG helps out by coming with a set of predefined
    transformations, namely, `translate()`, `scale()`, `rotate()`, `skewX()`, and
    `skewY()`.
  prefs: []
  type: TYPE_NORMAL
- en: According to Wikipedia, an affine transformation is any transformation that
    preserves points, straight lines, and planes, while keeping sets of parallel lines
    parallel. They don't necessarily preserve distances but do preserve ratios of
    distances between points on a straight line. This means if you take a rectangle,
    you can use affine transformations to rotate it, make it bigger, and even turn
    it into a parallelogram; however, no matter what you do, it will never become
    a trapezoid.
  prefs: []
  type: TYPE_NORMAL
- en: Computers handle transformations as matrix multiplication because any sequence
    of transformations can be collapsed into a single matrix. This means they only
    have to apply a single transformation that encompasses your sequence of transformations
    when drawing the shape, which is handy.
  prefs: []
  type: TYPE_NORMAL
- en: We will apply transformations with the `transform` attribute. We can define
    multiple transformations that are applied in order. The order of operations can
    change the result. You'll notice this in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move our eye to the edge of the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We selected everything our eye is made of (two ellipses and a circle), and then
    applied the `translate` transformation. It moved the shape's origin along the
    `(150, 0)` vector, moving the shape 150 pixels to the right and 0 pixels down.
  prefs: []
  type: TYPE_NORMAL
- en: If you try moving it again, you'll notice new transformations are applied according
    to the original state of our shape. That's because there can only be one `transform`
    attribute per shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our picture looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations](img/0007_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s rotate the eye by 45 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Transformations](img/0007_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's not what we wanted at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'What tricked us is that rotations happen around the origin of the image, not
    the shape. We have to define the rotation axis ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding two more arguments to `rotate()`, we defined the rotation axis and
    achieved the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations](img/0007_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make the eye a little bigger with the `scale()` transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make our object `1.2` times bigger along both the axes; two arguments
    would have scaled by different factors along the x and y axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations](img/0007_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once again, we pushed the position of the eye because scaling is anchored at
    the zeroth point of the whole image. We have to use another `translate` to move
    it back. But the coordinate system we're working on is now rotated by 45 degrees
    and scaled. This makes things tricky. We need to translate between the two coordinate
    systems to move the eye correctly. To move the eye 70 pixels to the left, we have
    to move it along each axis by *70*sqrt(2)/2* pixels, which is the result of cosine
    and sine at an angle of 45.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that''s just messy. The number looks funny, and we worked way too much
    for something so simple. Let''s change the order of operations instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Much better! We get exactly what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations](img/0007_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A lot has changed, let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: First we translate to our familiar position and then scale by `1.2`, pushing
    the eye out of position. We fix this by translating back to the left by `70` pixels
    and then finally performing the `45` degree rotation, making sure to divide the
    pivot point by `1.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more thing we can do to the poor eye; skew it. Two skew transformations
    exist: `skewX` and `skewY`. Both skew along their respective axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We just bolted `skewY(20)` on to the end of the `transform` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '![Transformations](img/0007_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have once more destroyed our careful centering. Fixing this is left as an
    exercise for the reader (I've always wanted to say that).
  prefs: []
  type: TYPE_NORMAL
- en: All said, transformations really are just matrix multiplication. In fact, you
    can define any transformation you want with the `matrix()` function. I suggest
    taking a look at exactly what kind of matrix produces each of the preceding effects.
    The W3C specification available at [http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace](http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace)
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: Using paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Path elements define outlines of shapes that can be filled, stroked, and so
    on. They are generalizations of all other shapes and can be used to draw nearly
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the path''s magic stems from the `d` attribute; it uses a mini language
    of three basic commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M`, meaning moveto'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L`, meaning lineto'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z`, meaning closepath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a rectangle, we might write something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We appended a new element to our `svg` and then defined some attributes. The
    interesting bit is the `d` attribute, `M 100 100 L 300 100 L 200 300 z`. Breaking
    this down, you can see we first moved to (`100`, `100`), drew a line on (`300`,
    `100`), another line on (`200`, `300`), and then closed the path.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using paths](img/0007_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The power of paths doesn't stop there, though. Commands beyond the `M`, `L`,
    `Z` combination give us tools to create curves and arcs. But creating complex
    shapes by hand is beyond tediousness.
  prefs: []
  type: TYPE_NORMAL
- en: d3.js comes with some helpful path generator functions that take JavaScript
    and turn it into path definitions. We'll be looking at those next.
  prefs: []
  type: TYPE_NORMAL
- en: Our image is getting pretty crowded, so let's restart the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start things off, we''ll draw the humble sine function. Once again, we begin
    by preparing the drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We appended an `svg` element to our `#graph` div and set a large enough `width`
    and `height` for our evil plans. Then, we appended a `g` element to put our chart
    in. The `g` element is a logical grouping of SVG shapes, improving the semantics
    of our document and making it easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need some data, which is the `sine` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using `d3.range(0,10)` gives us a list of integers from zero to nine. We map
    over them and turn each into a tuple, actually a 2-length array representing the
    maxima, minima, and zeroes of the curve. You might remember from your math class
    that sine starts at (0,0), then goes to (Pi/2, 1), (Pi, 0), (3Pi/2, -1), and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: We'll feed these as data into a path generator.
  prefs: []
  type: TYPE_NORMAL
- en: Path generators are really the meat of d3.js's magic. We'll discuss the gravy
    of the magic in [Chapter 5](ch05.html "Chapter 5. Layouts – d3's Black Magic"),
    *Layouts – d3's Black Magic*. They are essentially a function that takes some
    data (joined to elements) and produces a path definition in SVG's path mini language.
    All path generators can be told how to use our data. We also get to play with
    the final output a great deal.
  prefs: []
  type: TYPE_NORMAL
- en: Line
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a line we use the `d3.svg.line()` generator and define the x- and
    y-accessor functions. Accessors tell the generator how to read the x and y coordinates
    from datapoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by defining two scales. Scales are functions that map from a domain
    to a range; we''ll talk more about them in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get to define a simple path generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It is just a matter of taking the basic line generator and attaching some accessors
    to it. We told the generator to use our `x` scale on the first element and the
    `y` scale on the second element of every tuple. By default, it assumes our dataset
    as a collection of arrays defining points directly so that `d[0]` is `x` and `d[1]`
    is `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left now is drawing the actual line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Append a path, and add the `sine` data using `.datum()`. Using this instead
    of `.data()` means we can render the function as a single element instead of creating
    a new line for every point. We let our generator define the `d` attribute. The
    rest just makes things visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our graph looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Line](img/0007_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the generated code, you''ll see this sort of gobbledygook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See! I told you nobody wants to write that by hand.
  prefs: []
  type: TYPE_NORMAL
- en: That's a very jagged `sine` function we've got there, nothing similar to what
    the math teacher used to draw in high school. We can make it better with interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation is the act of guessing where unspecified points of a line should
    appear, considering the points we do know. By default, we're using the `linear`
    interpolator that just draws straight lines between points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same code as before, but we used the `step-before` interpolator and
    changed the styling to produce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Line](img/0007_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: d3.js offers 12 line interpolators in total, which I am not going to list here.
    You can look them up on the official wiki page at [https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate](https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-line_interpolate).
  prefs: []
  type: TYPE_NORMAL
- en: I suggest trying out all of them to get a feel of what they do.
  prefs: []
  type: TYPE_NORMAL
- en: Area
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An area is the colored part between two lines, a polygon really.
  prefs: []
  type: TYPE_NORMAL
- en: We define an area similar to how we define a line, so take a path generator
    and tell it how to use our data. For a simple horizontal area, we have to define
    one x accessor and two y accessors, `y0` and `y1`, for both the bottom and the
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll compare different generators side by side, so let''s add a new graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now we define an `area` generator and draw an area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We took a vanilla `d3.svg.area()` path generator and told it to get the coordinates
    through the `x` and `y` scales we defined earlier. The `basis` interpolator will
    use a B-spline to create a smooth curve from our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the bottom edge, we defined `y0` as the bottom of our graph and produced
    a colored sine approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area](img/0007_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Areas are often used together with lines that make an important edge stand
    out. Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We could re-use the same line generator as before; we just need to make sure
    that we use the same interpolator as for the area. This way, the image looks much
    better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Area](img/0007_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Arc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An arc is a circular path with an inner and outer radius, going from one angle
    to another. They are often used for pie and donut charts.
  prefs: []
  type: TYPE_NORMAL
- en: Everything works as before; we just tell the base generator how to use our data.
    The only difference is that this time the default accessors expect named attributes
    instead of 2-value arrays we've gotten used to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s draw an arc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This time we could get away with using the default `d3.svg.arc()` generator.
    Instead of using data, we calculated the angles by hand and also nudged the arc
    towards the center.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arc](img/0007_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See, a simple arc. Rejoice!
  prefs: []
  type: TYPE_NORMAL
- en: Even though SVG normally uses degrees, the start and end angles use radians.
    The zero angle points upwards with negative values going anticlockwise and positive
    values going the other way. Every *2Pi* we come back to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes when visualizing data, we need a simple way to mark datapoints. That's
    where symbols come in, tiny glyphs used to distinguish between datapoints.
  prefs: []
  type: TYPE_NORMAL
- en: The `d3.svg.symbol()` generator takes a `type` accessor and a `size` accessor,
    and leaves the positioning to us. We are going to add some symbols to our area
    chart showing where the function is going when it crosses zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we start with a path generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've given the `d3.svg.symbol()` generator a `type` accessor telling it to
    draw a downward pointing triangle when the y coordinate is positive and an upward
    one when not positive. This works because our `sine` data isn't mathematically
    perfect due to `Math.PI` not being infinite and due to floating point precision;
    we get infinitesimal numbers close to zero whose signedness depends on whether
    the `Math.sin` argument is slightly less or slightly more than the perfect point
    for `sin=0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `size` accessor tells `symbol()` how much area each symbol should occupy.
    Because every other datapoint is close to zero, we hide the others with an area
    equal to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can draw some symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Go through the data, append a new path for each entry, and turn it into a symbol
    moved into position. The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Symbol](img/0007_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see other available symbols by printing `d3.svg.symbolTypes`.
  prefs: []
  type: TYPE_NORMAL
- en: Chord
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Good news! We are leaving the world of simple charts and entering the world
    of magic.
  prefs: []
  type: TYPE_NORMAL
- en: Chords are most often used to display relations between group elements when
    arranged in a circle. They use quadratic Bezier curves to create a closed shape
    connecting two points on an arc.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have a strong background in computer graphics, that tells you
    nothing. A basic chord looks similar to half a villain''s moustache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chord](img/0007_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To draw that, we use the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a new grouping element, defines a dataset with a single datum,
    and appends a path using the default `d3.svg.chord()` generator for the `d` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The data itself plays right into the hands of the default accessors. `Source`
    defines where the chord begins and `target` where it ends. Both are fed to another
    set of accessors, specifying the arc's `radius`, `startAngle`, and `endAngle`.
    As with the arc generator, angles are defined using radians.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make up some data and draw a chord diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Nothing too fancy. We defined two arrays of numbers, shuffled one, and merged
    them into an array of pairs; we will look at the details in the next chapter.
    Then we defined some colors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All of this just defines the generator. We're going to divide a circle into
    sections and connect random pairs with chords.
  prefs: []
  type: TYPE_NORMAL
- en: The `.source()` and `.target()` accessors tell us the first item in every pair
    is the source and the second is the target. For `startAngle`, we remember a full
    circle is *2Pi* and divide it by the number of sections. Finally, to pick a section,
    we multiply by the current datum. The `endAngle` accessor is more of the same,
    except with datums offset by one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To draw the actual diagram we create a new grouping, join the dataset, and then
    append a path for each datum. The `chord` generator gives it a shape. To make
    everything look better, we define colors dynamically with the `colors` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result changes with every refresh but looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chord](img/0007_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagonal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `diagonal` generator creates cubic Bezier curves—smooth curves between two
    points. It is very useful for visualizing trees with a node-link diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the default accessors assume your data is a dictionary with keys
    named after the specific accessor. You need `source` and `target`, which are fed
    into `projection`, which then projects Cartesian coordinates into whatever coordinate
    space you like. By default, it just returns Cartesian coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s draw a moustache. Trees are hard without `d3.layouts` and we''ll do
    those later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We started off with a fresh graph on our drawing area and defined some data
    that should create a sweet ''stache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest is a simple matter of joining data to our drawing and using the `d3.svg.diagonal()`
    generator for the `d` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagonal](img/0007_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, it's a bit Daliesque. It may be, but it doesn't really look anything like
    a moustache. That's because the tangents defining how Bezier curves bend are tweaked
    to create good-looking fan-out in tree diagrams. Unfortunately d3.js doesn't give
    us a simple way of changing these, and manually defining Bezier curves through
    SVG's path mini language is tedious at best.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, we have created a side-by-side comparison of path generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagonal](img/0007_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Axes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: But we haven't done anything useful with our paths and shapes yet. One way we
    can do that is using lines and text to create graph axes. It would be tedious
    though, so d3.js makes our lives easier with axis generators. They take care of
    drawing a line, putting on some ticks, adding labels, evenly spacing them, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: A d3.js axis is just a combination of path generators configured for awesomeness.
    All we have to do for a simple linear axis is create a scale and tell the axis
    to use it. That's it!
  prefs: []
  type: TYPE_NORMAL
- en: For a more customized axis, we might have to define the desired number of ticks
    and specify the labels, perhaps something even more interesting. There are even
    ways to make circular axes.
  prefs: []
  type: TYPE_NORMAL
- en: Using a fresh version of the environment, let's create an axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a linear scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Our axis is going to use the following to translate data points (`domain`)
    tocoordinates (`range`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We've told the `d3.svg.axis()` generator to use our `x` scale. Then, we simply
    created a new grouping element, joined some data, and called the axis. It's very
    important to call the `axis` generator on all of the data at once so it can handle
    appending its own element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes](img/0007_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result doesn't look good at all.
  prefs: []
  type: TYPE_NORMAL
- en: Axes are complex objects, so fixing this problem is convoluted without CSS,
    which comes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, adding this code will be sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'An axis is a collection of paths and lines; we give them some swagger and get
    a nice-looking axis in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes](img/0007_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you play around with the amount, make sure the scale's domain and the range's
    max value match, and you'll notice axes are smart enough to always pick the perfect
    amount of ticks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare what the different settings do to axes. We're going to loop through
    several axes and render the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap your axis-drawing code in a loop by adding this line just above `svg.append(''g'')`.
    Don''t forget to close off the loop just after the last `stroke-width`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You should also change the `.attr('transform', …)` line to put each axis 50
    pixels below the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that''s done, we can start defining an array of axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Two for now: one is the plain vanilla version and the other will render with
    exactly `5` ticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes](img/0007_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It worked! The `axis` generator figured out which ticks are best left off and
    relabeled everything without us doing much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add more axes to the array and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With `.tickSubdivide()`, we instruct the generator to add some subdivisions
    between the major ticks; `.tickSize()` tells it to make the minor ticks smaller.
    The arguments are major, minor, and end tick size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes](img/0007_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our final trick, let''s define some custom ticks and place them above the
    axis. We''ll add another axis to the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Three things happen here: `.tickValues()`exactly defines which values should
    have a tick, `.tickFormat()` specifies how to render the labels—d3 comes with
    a slew of helpful formatters in `d3.format` by the way—and finally `.orient(''top'')`
    puts the labels above their axis.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have guessed the default orient is `'bottom'`. For a vertical axis,
    you can use `'left'` or `'right'` but don't forget to assign an appropriate scale.
  prefs: []
  type: TYPE_NORMAL
- en: '![Axes](img/0007_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cascading Stylesheets have been with us since 1996, making them one of the oldest
    staples of the Web, even though they only reached widespread popularity with the
    tables versus CSS wars of the early 2000s.
  prefs: []
  type: TYPE_NORMAL
- en: You're probably familiar with using CSS for styling HTML. So this section will
    be a refreshing breeze after all that SVG stuff.
  prefs: []
  type: TYPE_NORMAL
- en: My favorite thing about CSS is its simplicity; refer to the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. Everything you need to know about CSS in three lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The selectors can get fairly complicated and are beyond the scope of this book.I
    suggest looking around the Internet for a good guide. We just need to know some
    basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: Selects all the `<path>` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.axis`: Selects all the elements with a `class="axis"` attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.axis line`: Selects all the `<line>` elements that are children of `class="axis"`
    elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.axis, line`: Selects all the `class="axis"` and `<line>` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now you might be thinking, "Oh hey! That's the same as selectors for d3.js
    selections." Yes! It is exactly the same. d3.js selections are a subset of CSS
    selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke CSS with d3.js in three ways: define a class attribute with the
    `.attr()` method, which can be brittle; use the `.classed()` method, the preferred
    way to define classes; or define styling directly with the `.style()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's improve the axes example from before and make the styling less cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the HTML and add some CSS right before the `<div id="graph">` tag as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It is very similar to changing SVG attributes directly, but with CSS. We used
    `stroke` and `fill` to define the shape of the line and set `shape-rendering`
    to `crispEdges`. This will make things better.
  prefs: []
  type: TYPE_NORMAL
- en: We've also defined an extra type of axis with red lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we fix the drawing loop to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: None of that foolishness with specifying the same looks five times in a row.
    Using the `.classed()` function, we add the `axis` class to each axis and every
    second axis is red. `.classed()` adds the specified class if the second argument
    is true and removes it otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS](img/0007_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beautiful visualizations often involve color beyond the basic names you can
    think of off the top of your head. Sometimes you want to play with colors depending
    on what the data looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'd3.js has us covered with a slew of functions devoted to manipulating color
    in four popular color spaces: RGB, HSL, HCL, and L*a*b. The most useful for us
    are going to be RGB (red green blue) and HSL (hue saturation lightness), which
    is secretly just another way of looking at RGB. Either way, all color spaces use
    the same functions, so you can use what fits your needs best.'
  prefs: []
  type: TYPE_NORMAL
- en: To construct an RGB color, we use `d3.rgb(r, g, b)` where `r`, `g`, and `b`
    specify the channel values for red, green, and blue. We can also replace the triplet
    with a simple CSS color argument. Then we get to make the color darker or brighter,
    which is much better than shading by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Time to play with color in a fresh environment. We'll draw two color wheels
    with their brightness changing from the center towards the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we begin with some variables and a drawing area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The main variable henceforth will be `rings`; it will tell the code how many
    levels of brightness we want. We also need some basic colors and a way to calculate
    angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`colors` is technically a scale, but we''ll use it as data. Category20b is
    one of four predefined color scales that come with d3.js—an easy way to get a
    list of well picked colors.'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate angles, we're using a linear scale that maps the `[0, 20]` domain
    to a full circle `[0, 2*pi]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need an `arc` generator and two data accessors to change the color
    shade for every ring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The arc will calculate the inner and outer radii from a simple ring counter,
    and the angles will use the `angle` scale, which will automatically calculate
    the correct radian values. The `j` argument tells us which arc section is currently
    being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're making two pictures, we can simplify the code by using two different
    shaders from a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Each shader will take a `d3.rgb()` color from the colors scale and then darken
    or brighten it by the appropriate number of steps, depending on which ring it's
    drawing. Once again, the `j` argument tells us which arc section we're in, and
    the `d` argument tells us which ring we're at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we draw the two color wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Wow! That's quite a bit of code.
  prefs: []
  type: TYPE_NORMAL
- en: We take two triplets, each defining the color wheel's position and which shader
    to use; then call a function that draws a shiny colorful circle with each.
  prefs: []
  type: TYPE_NORMAL
- en: For each circle, we append a `<g>` element and move it into position, and then
    use `colors.range()` to get a full list of colors and join it as data. For every
    new color, we create another `<g>` element and select all the `<path>` elements
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Here things get magical. We join more data but just an array of numbers going
    from `0` to `rings` this time. For every element in this array, we append a `<path>`
    element and use the `arc` generator to define its shape. Finally we calculate
    the `fill` attribute with an appropriately shaded color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Colors](img/0007_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our main trick was that joining a second dimension of data retains the knowledge
    of the first dimension via the third attribute supplied to data accessors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow! We've gone through so much in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a firm grasp of the basics that go into great visualizations.
    We've gone through DOM manipulation and looked at SVG in great detail, everything
    from drawing shapes manually to path generators. Finally we looked at CSS as a
    better alternative for making things pretty.
  prefs: []
  type: TYPE_NORMAL
- en: Everything we look at from now on is going to build on these basics, but you
    now have the tools to draw anything you can think of. The rest of this book just
    shows you more elegant ways of doing it.
  prefs: []
  type: TYPE_NORMAL
