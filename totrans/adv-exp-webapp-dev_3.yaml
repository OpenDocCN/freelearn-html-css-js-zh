- en: Chapter 3. Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our Web API in place, so let's turn our attention to the client. In
    this chapter, we will consume our Web API and present our data using a mixture
    of both server-side and client-side templating. We will serve a`./views/index.html`
    masterpage file from the server with Express and use `consolidate.js` and `handlebars.js`
    for templating. On the client side we will use `backbone.js` and precompiled handlebars
    templates served directly out of the `./public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now our Express server has only served JSON; let's install a couple
    of modules that will assist us in serving HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '`consolidate.js` is a template engine consolidation library that was created
    to map all of Node''s popular templating engines to the Express convention for
    templating, allowing them to work within Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`handlebars.js` is an extension to the mustache templating language. Handlebars
    is a logic-less templating language that keeps view and code separated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to serve our handlebar templates, we will have to make
    some changes to our Express server. Let''s change the default template engine
    to handlebars by setting the `app.engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now register `html` as our view file extension. If we did not set this, we would
    need to name our view `index.hbs` instead of `index.html`, with `.hbs` being the
    extension for handlebars templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our single page application view; this will be served by our
    Express server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the location of our `views` folder and the location of our static
    files folder; it is here that we will store `components`, for example, CSS and
    JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now create a folder called `public` and add the following directory structure,
    so that static resources are served with the subdirectory as prefix, for example,
    `vision/vision.css.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature: Master Page'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a test to `./test/home.js` for our feature `Master Page`. This resource
    will `GET` our master page from route `./` and return a `200 OK` response. The
    `Content-Type` of the response should be `HTML:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement our `Master Page` feature. Let''s create a new module that
    exposes a route `./lib/routes/home.js` and add a new `index` function. We start
    by defining a route called `index`. We create a view `model` with meta information
    for a page and then render the view passing the view `model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new route to our Express server `./lib/express/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Package management with Bower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now install the various components that make up our client, namely `Handlebars.js`,
    `Backbone.js`, and Twitter Bootstrap Version 2 using **Bower**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bower is a package manager for the web. A Bower package can contain assets
    of different types, such as CSS, JavaScript, and images. Let''s install Bower
    globally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Bower, dependencies are listed in a `bower.json` file, similar to Node''s
    `package.json`. Let''s create a `./bower.json` file and define our client-side
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the following Bower configuration file `./.bowerrc`, which allows
    us to define our target directory and the name of our `bower.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to install all of the dependencies listed in our
    `bower.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Twitter Bootstrap''s assets are stored in the folder specified in the path
    in the following snippet, so let''s add a `static` middleware to override our
    Express server. This will keep our paths consistent on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our master page contains the following sections. In order to facilitate a client-side
    templating model using `backbone.js`, we will split up our master page into templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new folder called `./templates` and add the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to avoid compiling the templates on demand, let''s install the grunt
    task `grunt-contrib-handlebars`, which will precompile our handlebar templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We outline the grunt configuration for our handlebars compilation in the following
    code; it simply takes as input a template location `templates/*.hbs` and compiles
    these templates into a single JavaScript file and stores it at `public/components/vision/templates.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We complete this section by taking a look at the master page template `./views/index.html`.
    The body contains the following areas: a header, which includes either a `login`
    button or a `logout` button with a `welcome` message, a `project-list` form, `repository-list`,
    `commit-list`, and `issue-list`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Client-side development with Backbone.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Backbone.js` is a lightweight and very flexible **JavaScript Model View**
    (**MV***) framework that simplifies the building of complex JavaScript applications.
    It includes some very basic primitives that allow us to decouple our client''s
    model and logic from its view. Backbone supports a **RESTful JSON** interface
    that ties models/collections to a RESTful API. Further information on `Backbone.js`
    can be found at [http://backbonejs.org](http://backbonejs.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: List projects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build the client for our feature `List projects`. Each item in the list
    consists of a project name and an edit and delete button. Clicking on the name
    will display a list of repositories; clicking on **edit** will display an inline
    form populated with the models' data, and clicking on **delete** will delete the
    item from our database. We will return to hook up these three functions later.
    For now, we will simply display a project list.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is an HTML template `./templates/projects.hbs` for a project item;
    it contains a placeholder `{{_id}}`, which will be replaced by our Backbone application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a skeleton Backbone application with all of its pieces in place:
    `./public/components/vision/vision.js`. We start by defining the `Vision` namespace;
    we add to it an outer function called `Application`, that has a single method
    called `start`. Here we instantiate a `router` and call `Backbone.history.start()`
    in order to start the Backbone application. We then call `router.navigate(''index'',
    true)` and navigate to our home page. With this function in place, we instantiate
    new `Vision.Application()` and call `start()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's now create the application `Router`. Generally, Backbone applications
    only have one of these; a router is the entry point for our application.
  prefs: []
  type: TYPE_NORMAL
- en: First we add a function `Router`, which extends the Backbone `Router` type.
    We add a view for our list of projects called `projectListView`, and add a `routes`
    hash, which defines a single route. The entry point for our application is an
    empty route mapped to a method called `index`. The `initialize` or constructor
    method is called when the router is instantiated; from here we call a method `project`,
    which instantiates a `ProjectListView`. The `index` method, which matches the
    route as defined previously, renders our view by calling `projectApplication.render()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement our `Project` model to support our view. We start by adding
    a function `Project`, which extends the Backbone `Model` type and includes a hash
    of default values for the two properties in our model. We override the `idAttribute`
    parameter in order to accommodate MongoDB identifiers. We will use the MongoDB
    `_id` as our model identifier; by default Backbone will use `id`. This identifier
    will be appended to any request Backbone makes to the server, for example, when
    performing GET, POST, PUT, or DELETE. We already added the API for this model
    in [Chapter 2](ch02.html "Chapter 2. Building a Web API"), *Building a Web API*.
    The `urlRoot` parameter links this model to the web API route `/project` to return
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a collection; `ProjectList` for our `Project` model. We add
    a function, `ProjectList`, that extends the Backbone `Collection` type and we
    specify model type as `Vision.Project`. We add a `url` method which returns our
    web API route `/project` to return a list of projects. The `initialize` method
    is called when the collection is instantiated; from here we do our initial `fetch()`
    to get our projects; thus calls the API `/project`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before we implement `ProjectListView`, let's create `event_aggregator`; this
    will allow our views to trigger and bind named events that other views can respond
    to. We will need to do this in order for `ProjectListView` to inform `RepositoryListView`
    that it's time to display a `RepositoryList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an `event_aggregator` function to the Backbone view prototype using
    the `underscore.js` extend method to mix in the Backbone `event` module into our
    views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a view for our `Project` collection— `ProjectListView`. We start
    by defining a function `ProjectListView` which extends the Backbone `View` type,
    and add a `Projects` array for our project list. We assign a DOM element to `el`;
    an unordered list called `projects-list`. This is the element our view will be
    inserted into. Backbone will construct an empty `div` tag if you do not assign
    it to `el`.
  prefs: []
  type: TYPE_NORMAL
- en: The `initialize` method is called when the view is instantiated; here we instantiate
    a new `ProjectList`, passing our `Projects` array. We then call `collection.on('add')`,
    which upon fetching data from the API will call the `add` method. The `add` method
    instantiates `ProjectView`, passing to it a `project` model. We then append `ProjectView`
    to our DOM element via `$el` and return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We complete this section by implementing a view for a single project—`ProjectView`.
    We start by defining a function `ProjectView`, which extends the Backbone `View`
    type, and add a `tagName` and assign `li` to it. This tag will be wrapped around
    our project view; our DOM element is a `ul` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then include `viewTemplate` and assign our precompiled handlebars template
    to it. Although the templates are compiled to a single file —`./vision/templates.js`—
    we still refer to the template by name; `templates/projects.hbs`. The `render`
    method renders the view; we pass the `project` model to our `viewTemplate`, which
    is then added via `$el` to our DOM element and we return the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you go into MongoDB and add the following record to the projects collection
    in the vision database, when visiting the Vision application in a browser you
    can see this record in the project list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature: List repositories'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build the client for our feature `List repositories`. Each item in the
    list consists of a repository name, a short description, and a checkbox; which
    allows us to add or remove the repository from the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is an HTML template `./templates/repositories.hbs` for a repository
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's add a `Repository` model. We add a function `Repository` that extends
    the Backbone `Model` type and add a hash of default values for the four properties
    in our model. The `enabled` property signifies that a repository is included in
    the selected project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a collection for our `Repository` model. We start by defining
    a function `RepositoryList`, which extends the Backbone `Collection` type. We
    add the `projectId` of the selected project, and set the model type as `Vision.Repository`.
    We then add a `url` method and use the web API route `/project/:id/repos` to get
    a list of repositories for a project.
  prefs: []
  type: TYPE_NORMAL
- en: The `initialize` method is called when the collection is instantiated; from
    here, we assign the selected `projectId`. The `parse` method is called when a
    fetch is performed and will parse the response; here we assign our MongoDB `_id`
    to the `response.id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We now implement a view for a single repository. We add a function, `RepositoryView`,
    that extends the Backbone `View` type and add a `tagName` and assign `li` to it.
    This tag will be wrapped around our `RepositoryView` function; our DOM element
    is a `ul` tag. We include a `viewTemplate` function and assign our precompiled
    handlebars template `templates/repositories.hbs` to it. The `render` method renders
    the view; we pass the `repository` model to our `viewTemplate` function, which
    is then added via `$el` to our DOM element, and we return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a view for our `RepositoryList` called `RepositoryListView`.
    We start by defining a function, `RepositoryListView`, that extends the Backbone
    `View` type and adds a `Repositories` array for our repository list. We add an
    `initialize` method; if `projectId` is empty we return. A valid `projectId` results
    in rendering the view; first, we clear the DOM element, and we then assign a new
    `RepositoryList` function to the views `collection`. We initialize the list with
    our `Repositories` array and our `projectId`, we then call `fetch` in our collection,
    and then we call `render` for a successful fetch.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` method uses underscore to loop through the repository collection
    called `collection.models`, calling `add(item)` for each project. We include an
    `add` method that instantiates a `RepositoryView` function, passing to it a `repository`
    model. We then append a rendered `RepositoryView` to our DOM element via `$el`
    and return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's make a few changes to our `ProjectView` and add a click event when selecting
    a project. We start by defining an `events` hash with a single event called click
    a, that calls the `repository` method. The `repository` method grabs `projectId`
    from our model and then calls the `trigger` method on `event_aggregator` for the
    event `repository:join`, passing `projectId`. We will listen to this event on
    `ProjectListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's hook up the other side of the previous event and add an event binder to
    `ProjectListView`. We add an `event_aggregator.bind` statement to our `initialize`
    method, binding the event `repository:join` to the `repository` method. The `repository`
    method triggers a `join` event on the router.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let's complete the picture and change router to listen to the `join` event.
    We add a `repositoryListView` function to the router and add a `listenTo` event
    to the `initialize` method that calls the `join` method. The `join` method calls
    `repository`, which instantiates the `RepositoryListView` function, passing `projectId`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you click on a project item's name in `ProjectView`, `RepositoryListView`
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: Create a project'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a project form for our feature `Create a project`. It consists of
    a large **Add project** button, a text box for our project name, and `save` and
    `cancel` buttons. Clicking on **save** will POST the project to our Express server,
    whereas, clicking on **cancel** closes the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is an HTML template `./templates/project-form.hbs` for a repository
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a few changes to `router` and wire up a route to our `Add Project`
    button. `routes` now includes a route called `add`, which calls a method called
    `add`. We include an `add` method that calls `projectListView.showForm()`, rendering
    our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's make some changes to `projectListView` and modify the `initialize` method.
    We bind this view to the `reset`, `add`, and `remove` events of the `collection`.
    We also add a `showForm` method as called in the preceding code. The method renders
    a project form by calling `this.add()`, passing `new Vision.Project()`, and calling
    `add()` on the view returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's add some validation to our `Project` model so we can validate form input
    for our project. We add a `validate` method to our `Project` model and validate
    our `Project` model's name. If validation fails, we return an `errors` array containing
    error messages. We are actually overriding the `validate` method. `Backbone.js`
    requires that you override the validate method with your custom validation logic.
    By default, the method `validate` is also called as part of a `save` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let's make some changes to `projectView`. We start by adding a new template
    called `formTemplate`, which displays a form for adding a new project. We add
    two new events to the `events` hash—a button `save` event and a button `cancel`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The `cancel` method, which responds to the cancel event, will get the current
    `projectId` from our model and check if the `model.isNew`. If it's new we simply
    remove the `projectView` from our `projectListView`. If its not new, we render
    our view and also render `repositoryListView` by calling `repository`. We then
    navigate to the `index` page using `history.navigate`.
  prefs: []
  type: TYPE_NORMAL
- en: The `save` method, which responds to the `save` event, grabs `projectId` from
    our model and the form data. We then call `model.isValid`, which calls the `validate`
    method in our project model. Any error returned results in calling `formError`.
    If the model is valid, we go off and get our selected repositories and assign
    this to our form. We then attempt to save the form as `Project` with a call to
    `model.save`. Any error returned results in calling `formError`. A successful
    save enables us to render the `project` in `ProjectListView`. We also render `RepositoryListView`
    by calling `repository`. We then navigate to the `index` page using `history.navigate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You will now be able to complete the form and add a new project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: Edit a project'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add an edit project form for our feature `Edit a project`. It consists
    of a text box for the project name a save and cancel button. Clicking on **save**
    will PUT the project to our Express server; clicking on **cancel** closes the
    form. We will use the same handlebars template we used for adding a project. In
    order to make `RepositoryListView` editable, we will need to introduce the concept
    of an edit state. We have called `editMode`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some changes to `projectView`. We start by adding a new event `edit`
    to the `events` hash, which calls an `edit` function. We change our `repository`
    method by passing a new `arg.editMode` to `event_aggregator`, which will inform
    our `RepositoryListView` that it is in edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `edit` method, which displays our project `formTemplate`, populated with
    our `project` model data calls the `repository` method with `editMode` set to
    `false`, informing `RepositoryListView` that it is in edit mode. Finally, we update
    our `add`, `cancel`, and `save` methods; calls in these methods to the `repository`
    method should pass `{editMode:false}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let's make some changes to `RepositoryListView`. The `initialize` method will
    now either enable or disable the form checkboxes based on `editMode` when `collection.fetch`
    makes a successful request. The `enableForm` function removes the `disabled` tag
    from our `RepositoryListView` checkbox list. The `disableForm` function adds the
    `disabled` tag to our `RepositoryListView` checkbox list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now you will be able to edit your existing projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: Delete a project'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a **delete** button to our form for the feature `Delete a project`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a change to `ProjectView` and add a new event to the `events` hash,
    called `delete`, which calls the `delete` method. We add a `delete` method, which
    destroys the model and removes `ProjectView`. We then call `repository`, removing
    `RepositoryListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let's make a change to `ProjectListView` and add a `collection` event handler
    to `initialize`. The event handler calls the `remove` method when an item is removed.
    The `remove` method grabs the model's attributes and searches the `Projects` collection,
    removing the item when finding it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will now be able to delete a project by clicking on the delete button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: List commits'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a list of commits for the feature `List Commits`. Each item in the
    list consists of a commit `message`, project `name`, a `date`, and the committer''s
    `username`. The following is a HTML template `./templates/commits.hbs` for a commit
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement our `Commit` model. We define a function, `Commit`, which extends
    the Backbone `Model` type, and we include a hash of default values for the properties
    in our model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a collection, `CommitList`, for our `Commit` model. We define
    a function, `CommitList`, which extends the Backbone `Collection` type. We specify
    the model type as `Vision.Commit`. We add a `url` method that uses the web API
    route `/project/:id/commits` to return a list of commits. The `initialize` method
    is called when the collection is instantiated; from here we assign `projectId`.
    The `parse` method is called when a fetch is performed and will parse the response.
    Here we assign our MongoDB `_id` to `response.id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a view for our `Commit` collection. We define a function, `CommitListView`,
    which extends the Backbone `View` type, and adds a `Commits` array for our commits
    list. The `initialize` method is called when the view is instantiated; from here
    we call `create` and instantiate a new `CommitList`, passing our `Commits` array.
    We call `refresh` ,which loops through the `Commits` collection rendering the
    view with a call to `render`. The `render` method uses underscore to loop through
    the `Commits` collection called `collection.models` by calling `add(item)` for
    each `commit`. The method `add` instantiates `CommitView`, passing to it a `Commit`
    model, it then appends a rendered `CommitView` to the DOM element via `$el` and
    returns the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We continue by adding a view for a single commit item. We define a function,
    `CommitView`, which extends the Backbone `View` type, and add a `tagName` and
    assign `li` to it. This tag will be wrapped around our commit view; our DOM element
    is a `ul` tag. We include `viewTemplate` and assign our precompiled handlebars
    template `./templates/commits.hbs` to it. The `render` method renders the view;
    we pass the `commit` model to our `viewTemplate`, which is then added via `$el`
    to our DOM element and we return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let's complete the picture and change our router; we add a `CommitListView`
    to the router and call `commits` inside the `join` method. The `commits` method
    instantiates a `CommitListView` passing the current `projectId` and a list of
    commits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Vision will now display a list of commits when selecting a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: List issues'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build our issues list. Each item in the list simply consists of an issue
    title, project name, a date, the issuer's username, and its status.
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is an HTML template `./templates/issues.hbs` for a issues item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement our `Issue` model; we define a function `Issue`, which extends
    the Backbone `Model` type, and includes a hash of `default` values for the properties
    in our model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a collection called `IssueList` for our `Issue` model. We define
    a function, `IssueList`, which extends the Backbone `Collection` type, and specifies
    the model type as `Vision.Issue`. We add a `url` method that uses the web API
    route `/project/:id/issues` to return a list of issues. The `initialize` method
    is called when the collection is instantiated; from here we assign the selected
    `projectId`. The `parse` method is called when a fetch is performed and will parse
    the response; here we assign our MongoDB `_id` to the `response.id`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement a view for our `Issue` collection. We define a function, `IssueListView`,
    which extends the Backbone `View` type, and add an `Issues` array for our issue
    list. The `initialize` method is called when the `view` is instantiated; from
    here we call `create` and instantiate a new `IssueList`, passing our `Issues`
    array. We then call `refresh`, which loops through the `Issues` collection, rendering
    the view with a call to `render`. The `render` method uses underscore to loop
    through the `Issues` collection called `collection.models`; and calls `add(item)`for
    each issue. The method `add` instantiates `IssueView`, passing to it an `Issue`
    model. We then append a rendered `IssueView` to our DOM element via `$el` and
    return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We continue by adding a view for a single issue. We define a function, `IssueView`,
    which extends the Backbone `View` type, and add a `tagName` and assign `li` to
    it; this tag will be wrapped around our `IssueView` function. Our DOM element
    is a `ul` tag. We include a `viewTemplate` and assign our precompiled handlebars
    template `templates/issues.hbs` to it. The `render` method renders the view; we
    pass the `issue` model to `viewTemplate` which is then added via `$el` to our
    DOM element and we return the view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Let's complete the picture and change our router; we add a `issueListView` to
    the router and call `issues` inside the `join` method. The `issues` method instantiates
    `IssueListView`, passing `projectId` and a list of issues.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Vision will now display a list of issues when selecting a project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now completed the first part of our client. We have implemented a project
    list view that allows us to add, update, and remove projects. We have also implemented
    a repository list view that displays a list of repositories for our access token;
    these repositories can be assigned to the project. We also display a list of commits
    and issues for all repositories in our project. In the next chapter, we will display
    a real-time list of commits and issues using Socket.IO.
  prefs: []
  type: TYPE_NORMAL
